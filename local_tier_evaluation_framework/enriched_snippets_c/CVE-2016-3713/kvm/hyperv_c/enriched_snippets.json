[
  {
    "function_name": "kvm_hv_hypercall",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.c",
    "lines": "1067-1141",
    "snippet": "int kvm_hv_hypercall(struct kvm_vcpu *vcpu)\n{\n\tu64 param, ingpa, outgpa, ret;\n\tuint16_t code, rep_idx, rep_cnt, res = HV_STATUS_SUCCESS, rep_done = 0;\n\tbool fast, longmode;\n\n\t/*\n\t * hypercall generates UD from non zero cpl and real mode\n\t * per HYPER-V spec\n\t */\n\tif (kvm_x86_ops->get_cpl(vcpu) != 0 || !is_protmode(vcpu)) {\n\t\tkvm_queue_exception(vcpu, UD_VECTOR);\n\t\treturn 1;\n\t}\n\n\tlongmode = is_64_bit_mode(vcpu);\n\n\tif (!longmode) {\n\t\tparam = ((u64)kvm_register_read(vcpu, VCPU_REGS_RDX) << 32) |\n\t\t\t(kvm_register_read(vcpu, VCPU_REGS_RAX) & 0xffffffff);\n\t\tingpa = ((u64)kvm_register_read(vcpu, VCPU_REGS_RBX) << 32) |\n\t\t\t(kvm_register_read(vcpu, VCPU_REGS_RCX) & 0xffffffff);\n\t\toutgpa = ((u64)kvm_register_read(vcpu, VCPU_REGS_RDI) << 32) |\n\t\t\t(kvm_register_read(vcpu, VCPU_REGS_RSI) & 0xffffffff);\n\t}\n#ifdef CONFIG_X86_64\n\telse {\n\t\tparam = kvm_register_read(vcpu, VCPU_REGS_RCX);\n\t\tingpa = kvm_register_read(vcpu, VCPU_REGS_RDX);\n\t\toutgpa = kvm_register_read(vcpu, VCPU_REGS_R8);\n\t}\n#endif\n\n\tcode = param & 0xffff;\n\tfast = (param >> 16) & 0x1;\n\trep_cnt = (param >> 32) & 0xfff;\n\trep_idx = (param >> 48) & 0xfff;\n\n\ttrace_kvm_hv_hypercall(code, fast, rep_cnt, rep_idx, ingpa, outgpa);\n\n\t/* Hypercall continuation is not supported yet */\n\tif (rep_cnt || rep_idx) {\n\t\tres = HV_STATUS_INVALID_HYPERCALL_CODE;\n\t\tgoto set_result;\n\t}\n\n\tswitch (code) {\n\tcase HVCALL_NOTIFY_LONG_SPIN_WAIT:\n\t\tkvm_vcpu_on_spin(vcpu);\n\t\tbreak;\n\tcase HVCALL_POST_MESSAGE:\n\tcase HVCALL_SIGNAL_EVENT:\n\t\t/* don't bother userspace if it has no way to handle it */\n\t\tif (!vcpu_to_synic(vcpu)->active) {\n\t\t\tres = HV_STATUS_INVALID_HYPERCALL_CODE;\n\t\t\tbreak;\n\t\t}\n\t\tvcpu->run->exit_reason = KVM_EXIT_HYPERV;\n\t\tvcpu->run->hyperv.type = KVM_EXIT_HYPERV_HCALL;\n\t\tvcpu->run->hyperv.u.hcall.input = param;\n\t\tvcpu->run->hyperv.u.hcall.params[0] = ingpa;\n\t\tvcpu->run->hyperv.u.hcall.params[1] = outgpa;\n\t\tvcpu->arch.complete_userspace_io =\n\t\t\t\tkvm_hv_hypercall_complete_userspace;\n\t\treturn 0;\n\tdefault:\n\t\tres = HV_STATUS_INVALID_HYPERCALL_CODE;\n\t\tbreak;\n\t}\n\nset_result:\n\tret = res | (((u64)rep_done & 0xfff) << 32);\n\tkvm_hv_hypercall_set_result(vcpu, ret);\n\treturn 1;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/apicdef.h>",
      "#include <linux/highmem.h>",
      "#include <linux/kvm_host.h>",
      "#include \"hyperv.h\"",
      "#include \"ioapic.h\"",
      "#include \"lapic.h\"",
      "#include \"x86.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_hv_hypercall_set_result",
          "args": [
            "vcpu",
            "ret"
          ],
          "line": 1139
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_hv_hypercall_set_result",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.c",
          "lines": "1046-1057",
          "snippet": "static void kvm_hv_hypercall_set_result(struct kvm_vcpu *vcpu, u64 result)\n{\n\tbool longmode;\n\n\tlongmode = is_64_bit_mode(vcpu);\n\tif (longmode)\n\t\tkvm_register_write(vcpu, VCPU_REGS_RAX, result);\n\telse {\n\t\tkvm_register_write(vcpu, VCPU_REGS_RDX, result >> 32);\n\t\tkvm_register_write(vcpu, VCPU_REGS_RAX, result & 0xffffffff);\n\t}\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic void kvm_hv_hypercall_set_result(struct kvm_vcpu *vcpu, u64 result)\n{\n\tbool longmode;\n\n\tlongmode = is_64_bit_mode(vcpu);\n\tif (longmode)\n\t\tkvm_register_write(vcpu, VCPU_REGS_RAX, result);\n\telse {\n\t\tkvm_register_write(vcpu, VCPU_REGS_RDX, result >> 32);\n\t\tkvm_register_write(vcpu, VCPU_REGS_RAX, result & 0xffffffff);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "vcpu_to_synic",
          "args": [
            "vcpu"
          ],
          "line": 1120
        },
        "resolved": true,
        "details": {
          "function_name": "vcpu_to_synic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.h",
          "lines": "40-43",
          "snippet": "static inline struct kvm_vcpu_hv_synic *vcpu_to_synic(struct kvm_vcpu *vcpu)\n{\n\treturn &vcpu->arch.hyperv.synic;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct kvm_vcpu_hv_synic *vcpu_to_synic(struct kvm_vcpu *vcpu)\n{\n\treturn &vcpu->arch.hyperv.synic;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_on_spin",
          "args": [
            "vcpu"
          ],
          "line": 1115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_kvm_hv_hypercall",
          "args": [
            "code",
            "fast",
            "rep_cnt",
            "rep_idx",
            "ingpa",
            "outgpa"
          ],
          "line": 1105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_register_read",
          "args": [
            "vcpu",
            "VCPU_REGS_R8"
          ],
          "line": 1096
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_register_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "9-16",
          "snippet": "static inline unsigned long kvm_register_read(struct kvm_vcpu *vcpu,\n\t\t\t\t\t      enum kvm_reg reg)\n{\n\tif (!test_bit(reg, (unsigned long *)&vcpu->arch.regs_avail))\n\t\tkvm_x86_ops->cache_reg(vcpu, reg);\n\n\treturn vcpu->arch.regs[reg];\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline unsigned long kvm_register_read(struct kvm_vcpu *vcpu,\n\t\t\t\t\t      enum kvm_reg reg)\n{\n\tif (!test_bit(reg, (unsigned long *)&vcpu->arch.regs_avail))\n\t\tkvm_x86_ops->cache_reg(vcpu, reg);\n\n\treturn vcpu->arch.regs[reg];\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_64_bit_mode",
          "args": [
            "vcpu"
          ],
          "line": 1082
        },
        "resolved": true,
        "details": {
          "function_name": "is_64_bit_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.h",
          "lines": "52-60",
          "snippet": "static inline bool is_64_bit_mode(struct kvm_vcpu *vcpu)\n{\n\tint cs_db, cs_l;\n\n\tif (!is_long_mode(vcpu))\n\t\treturn false;\n\tkvm_x86_ops->get_cs_db_l_bits(vcpu, &cs_db, &cs_l);\n\treturn cs_l;\n}",
          "includes": [
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline bool is_64_bit_mode(struct kvm_vcpu *vcpu)\n{\n\tint cs_db, cs_l;\n\n\tif (!is_long_mode(vcpu))\n\t\treturn false;\n\tkvm_x86_ops->get_cs_db_l_bits(vcpu, &cs_db, &cs_l);\n\treturn cs_l;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_queue_exception",
          "args": [
            "vcpu",
            "UD_VECTOR"
          ],
          "line": 1078
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_queue_exception",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "409-412",
          "snippet": "void kvm_queue_exception(struct kvm_vcpu *vcpu, unsigned nr)\n{\n\tkvm_multiple_exception(vcpu, nr, false, 0, false);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nvoid kvm_queue_exception(struct kvm_vcpu *vcpu, unsigned nr)\n{\n\tkvm_multiple_exception(vcpu, nr, false, 0, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_protmode",
          "args": [
            "vcpu"
          ],
          "line": 1077
        },
        "resolved": true,
        "details": {
          "function_name": "is_protmode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.h",
          "lines": "38-41",
          "snippet": "static inline bool is_protmode(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_read_cr0_bits(vcpu, X86_CR0_PE);\n}",
          "includes": [
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline bool is_protmode(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_read_cr0_bits(vcpu, X86_CR0_PE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_x86_ops->get_cpl",
          "args": [
            "vcpu"
          ],
          "line": 1077
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nint kvm_hv_hypercall(struct kvm_vcpu *vcpu)\n{\n\tu64 param, ingpa, outgpa, ret;\n\tuint16_t code, rep_idx, rep_cnt, res = HV_STATUS_SUCCESS, rep_done = 0;\n\tbool fast, longmode;\n\n\t/*\n\t * hypercall generates UD from non zero cpl and real mode\n\t * per HYPER-V spec\n\t */\n\tif (kvm_x86_ops->get_cpl(vcpu) != 0 || !is_protmode(vcpu)) {\n\t\tkvm_queue_exception(vcpu, UD_VECTOR);\n\t\treturn 1;\n\t}\n\n\tlongmode = is_64_bit_mode(vcpu);\n\n\tif (!longmode) {\n\t\tparam = ((u64)kvm_register_read(vcpu, VCPU_REGS_RDX) << 32) |\n\t\t\t(kvm_register_read(vcpu, VCPU_REGS_RAX) & 0xffffffff);\n\t\tingpa = ((u64)kvm_register_read(vcpu, VCPU_REGS_RBX) << 32) |\n\t\t\t(kvm_register_read(vcpu, VCPU_REGS_RCX) & 0xffffffff);\n\t\toutgpa = ((u64)kvm_register_read(vcpu, VCPU_REGS_RDI) << 32) |\n\t\t\t(kvm_register_read(vcpu, VCPU_REGS_RSI) & 0xffffffff);\n\t}\n#ifdef CONFIG_X86_64\n\telse {\n\t\tparam = kvm_register_read(vcpu, VCPU_REGS_RCX);\n\t\tingpa = kvm_register_read(vcpu, VCPU_REGS_RDX);\n\t\toutgpa = kvm_register_read(vcpu, VCPU_REGS_R8);\n\t}\n#endif\n\n\tcode = param & 0xffff;\n\tfast = (param >> 16) & 0x1;\n\trep_cnt = (param >> 32) & 0xfff;\n\trep_idx = (param >> 48) & 0xfff;\n\n\ttrace_kvm_hv_hypercall(code, fast, rep_cnt, rep_idx, ingpa, outgpa);\n\n\t/* Hypercall continuation is not supported yet */\n\tif (rep_cnt || rep_idx) {\n\t\tres = HV_STATUS_INVALID_HYPERCALL_CODE;\n\t\tgoto set_result;\n\t}\n\n\tswitch (code) {\n\tcase HVCALL_NOTIFY_LONG_SPIN_WAIT:\n\t\tkvm_vcpu_on_spin(vcpu);\n\t\tbreak;\n\tcase HVCALL_POST_MESSAGE:\n\tcase HVCALL_SIGNAL_EVENT:\n\t\t/* don't bother userspace if it has no way to handle it */\n\t\tif (!vcpu_to_synic(vcpu)->active) {\n\t\t\tres = HV_STATUS_INVALID_HYPERCALL_CODE;\n\t\t\tbreak;\n\t\t}\n\t\tvcpu->run->exit_reason = KVM_EXIT_HYPERV;\n\t\tvcpu->run->hyperv.type = KVM_EXIT_HYPERV_HCALL;\n\t\tvcpu->run->hyperv.u.hcall.input = param;\n\t\tvcpu->run->hyperv.u.hcall.params[0] = ingpa;\n\t\tvcpu->run->hyperv.u.hcall.params[1] = outgpa;\n\t\tvcpu->arch.complete_userspace_io =\n\t\t\t\tkvm_hv_hypercall_complete_userspace;\n\t\treturn 0;\n\tdefault:\n\t\tres = HV_STATUS_INVALID_HYPERCALL_CODE;\n\t\tbreak;\n\t}\n\nset_result:\n\tret = res | (((u64)rep_done & 0xfff) << 32);\n\tkvm_hv_hypercall_set_result(vcpu, ret);\n\treturn 1;\n}"
  },
  {
    "function_name": "kvm_hv_hypercall_complete_userspace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.c",
    "lines": "1059-1065",
    "snippet": "static int kvm_hv_hypercall_complete_userspace(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_run *run = vcpu->run;\n\n\tkvm_hv_hypercall_set_result(vcpu, run->hyperv.u.hcall.result);\n\treturn 1;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/apicdef.h>",
      "#include <linux/highmem.h>",
      "#include <linux/kvm_host.h>",
      "#include \"hyperv.h\"",
      "#include \"ioapic.h\"",
      "#include \"lapic.h\"",
      "#include \"x86.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_hv_hypercall_set_result",
          "args": [
            "vcpu",
            "run->hyperv.u.hcall.result"
          ],
          "line": 1063
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_hv_hypercall_set_result",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.c",
          "lines": "1046-1057",
          "snippet": "static void kvm_hv_hypercall_set_result(struct kvm_vcpu *vcpu, u64 result)\n{\n\tbool longmode;\n\n\tlongmode = is_64_bit_mode(vcpu);\n\tif (longmode)\n\t\tkvm_register_write(vcpu, VCPU_REGS_RAX, result);\n\telse {\n\t\tkvm_register_write(vcpu, VCPU_REGS_RDX, result >> 32);\n\t\tkvm_register_write(vcpu, VCPU_REGS_RAX, result & 0xffffffff);\n\t}\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic void kvm_hv_hypercall_set_result(struct kvm_vcpu *vcpu, u64 result)\n{\n\tbool longmode;\n\n\tlongmode = is_64_bit_mode(vcpu);\n\tif (longmode)\n\t\tkvm_register_write(vcpu, VCPU_REGS_RAX, result);\n\telse {\n\t\tkvm_register_write(vcpu, VCPU_REGS_RDX, result >> 32);\n\t\tkvm_register_write(vcpu, VCPU_REGS_RAX, result & 0xffffffff);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic int kvm_hv_hypercall_complete_userspace(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_run *run = vcpu->run;\n\n\tkvm_hv_hypercall_set_result(vcpu, run->hyperv.u.hcall.result);\n\treturn 1;\n}"
  },
  {
    "function_name": "kvm_hv_hypercall_set_result",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.c",
    "lines": "1046-1057",
    "snippet": "static void kvm_hv_hypercall_set_result(struct kvm_vcpu *vcpu, u64 result)\n{\n\tbool longmode;\n\n\tlongmode = is_64_bit_mode(vcpu);\n\tif (longmode)\n\t\tkvm_register_write(vcpu, VCPU_REGS_RAX, result);\n\telse {\n\t\tkvm_register_write(vcpu, VCPU_REGS_RDX, result >> 32);\n\t\tkvm_register_write(vcpu, VCPU_REGS_RAX, result & 0xffffffff);\n\t}\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/apicdef.h>",
      "#include <linux/highmem.h>",
      "#include <linux/kvm_host.h>",
      "#include \"hyperv.h\"",
      "#include \"ioapic.h\"",
      "#include \"lapic.h\"",
      "#include \"x86.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_register_write",
          "args": [
            "vcpu",
            "VCPU_REGS_RAX",
            "result & 0xffffffff"
          ],
          "line": 1055
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_register_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "18-25",
          "snippet": "static inline void kvm_register_write(struct kvm_vcpu *vcpu,\n\t\t\t\t      enum kvm_reg reg,\n\t\t\t\t      unsigned long val)\n{\n\tvcpu->arch.regs[reg] = val;\n\t__set_bit(reg, (unsigned long *)&vcpu->arch.regs_dirty);\n\t__set_bit(reg, (unsigned long *)&vcpu->arch.regs_avail);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void kvm_register_write(struct kvm_vcpu *vcpu,\n\t\t\t\t      enum kvm_reg reg,\n\t\t\t\t      unsigned long val)\n{\n\tvcpu->arch.regs[reg] = val;\n\t__set_bit(reg, (unsigned long *)&vcpu->arch.regs_dirty);\n\t__set_bit(reg, (unsigned long *)&vcpu->arch.regs_avail);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_64_bit_mode",
          "args": [
            "vcpu"
          ],
          "line": 1050
        },
        "resolved": true,
        "details": {
          "function_name": "is_64_bit_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.h",
          "lines": "52-60",
          "snippet": "static inline bool is_64_bit_mode(struct kvm_vcpu *vcpu)\n{\n\tint cs_db, cs_l;\n\n\tif (!is_long_mode(vcpu))\n\t\treturn false;\n\tkvm_x86_ops->get_cs_db_l_bits(vcpu, &cs_db, &cs_l);\n\treturn cs_l;\n}",
          "includes": [
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline bool is_64_bit_mode(struct kvm_vcpu *vcpu)\n{\n\tint cs_db, cs_l;\n\n\tif (!is_long_mode(vcpu))\n\t\treturn false;\n\tkvm_x86_ops->get_cs_db_l_bits(vcpu, &cs_db, &cs_l);\n\treturn cs_l;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic void kvm_hv_hypercall_set_result(struct kvm_vcpu *vcpu, u64 result)\n{\n\tbool longmode;\n\n\tlongmode = is_64_bit_mode(vcpu);\n\tif (longmode)\n\t\tkvm_register_write(vcpu, VCPU_REGS_RAX, result);\n\telse {\n\t\tkvm_register_write(vcpu, VCPU_REGS_RDX, result >> 32);\n\t\tkvm_register_write(vcpu, VCPU_REGS_RAX, result & 0xffffffff);\n\t}\n}"
  },
  {
    "function_name": "kvm_hv_hypercall_enabled",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.c",
    "lines": "1041-1044",
    "snippet": "bool kvm_hv_hypercall_enabled(struct kvm *kvm)\n{\n\treturn kvm->arch.hyperv.hv_hypercall & HV_X64_MSR_HYPERCALL_ENABLE;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/apicdef.h>",
      "#include <linux/highmem.h>",
      "#include <linux/kvm_host.h>",
      "#include \"hyperv.h\"",
      "#include \"ioapic.h\"",
      "#include \"lapic.h\"",
      "#include \"x86.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nbool kvm_hv_hypercall_enabled(struct kvm *kvm)\n{\n\treturn kvm->arch.hyperv.hv_hypercall & HV_X64_MSR_HYPERCALL_ENABLE;\n}"
  },
  {
    "function_name": "kvm_hv_get_msr_common",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.c",
    "lines": "1028-1039",
    "snippet": "int kvm_hv_get_msr_common(struct kvm_vcpu *vcpu, u32 msr, u64 *pdata)\n{\n\tif (kvm_hv_msr_partition_wide(msr)) {\n\t\tint r;\n\n\t\tmutex_lock(&vcpu->kvm->lock);\n\t\tr = kvm_hv_get_msr_pw(vcpu, msr, pdata);\n\t\tmutex_unlock(&vcpu->kvm->lock);\n\t\treturn r;\n\t} else\n\t\treturn kvm_hv_get_msr(vcpu, msr, pdata);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/apicdef.h>",
      "#include <linux/highmem.h>",
      "#include <linux/kvm_host.h>",
      "#include \"hyperv.h\"",
      "#include \"ioapic.h\"",
      "#include \"lapic.h\"",
      "#include \"x86.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_hv_get_msr",
          "args": [
            "vcpu",
            "msr",
            "pdata"
          ],
          "line": 1038
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_hv_get_msr_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.c",
          "lines": "1028-1039",
          "snippet": "int kvm_hv_get_msr_common(struct kvm_vcpu *vcpu, u32 msr, u64 *pdata)\n{\n\tif (kvm_hv_msr_partition_wide(msr)) {\n\t\tint r;\n\n\t\tmutex_lock(&vcpu->kvm->lock);\n\t\tr = kvm_hv_get_msr_pw(vcpu, msr, pdata);\n\t\tmutex_unlock(&vcpu->kvm->lock);\n\t\treturn r;\n\t} else\n\t\treturn kvm_hv_get_msr(vcpu, msr, pdata);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&vcpu->kvm->lock"
          ],
          "line": 1035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_hv_get_msr_pw",
          "args": [
            "vcpu",
            "msr",
            "pdata"
          ],
          "line": 1034
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_hv_get_msr_pw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.c",
          "lines": "915-950",
          "snippet": "static int kvm_hv_get_msr_pw(struct kvm_vcpu *vcpu, u32 msr, u64 *pdata)\n{\n\tu64 data = 0;\n\tstruct kvm *kvm = vcpu->kvm;\n\tstruct kvm_hv *hv = &kvm->arch.hyperv;\n\n\tswitch (msr) {\n\tcase HV_X64_MSR_GUEST_OS_ID:\n\t\tdata = hv->hv_guest_os_id;\n\t\tbreak;\n\tcase HV_X64_MSR_HYPERCALL:\n\t\tdata = hv->hv_hypercall;\n\t\tbreak;\n\tcase HV_X64_MSR_TIME_REF_COUNT:\n\t\tdata = get_time_ref_counter(kvm);\n\t\tbreak;\n\tcase HV_X64_MSR_REFERENCE_TSC:\n\t\tdata = hv->hv_tsc_page;\n\t\tbreak;\n\tcase HV_X64_MSR_CRASH_P0 ... HV_X64_MSR_CRASH_P4:\n\t\treturn kvm_hv_msr_get_crash_data(vcpu,\n\t\t\t\t\t\t msr - HV_X64_MSR_CRASH_P0,\n\t\t\t\t\t\t pdata);\n\tcase HV_X64_MSR_CRASH_CTL:\n\t\treturn kvm_hv_msr_get_crash_ctl(vcpu, pdata);\n\tcase HV_X64_MSR_RESET:\n\t\tdata = 0;\n\t\tbreak;\n\tdefault:\n\t\tvcpu_unimpl(vcpu, \"Hyper-V unhandled rdmsr: 0x%x\\n\", msr);\n\t\treturn 1;\n\t}\n\n\t*pdata = data;\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic int kvm_hv_get_msr_pw(struct kvm_vcpu *vcpu, u32 msr, u64 *pdata)\n{\n\tu64 data = 0;\n\tstruct kvm *kvm = vcpu->kvm;\n\tstruct kvm_hv *hv = &kvm->arch.hyperv;\n\n\tswitch (msr) {\n\tcase HV_X64_MSR_GUEST_OS_ID:\n\t\tdata = hv->hv_guest_os_id;\n\t\tbreak;\n\tcase HV_X64_MSR_HYPERCALL:\n\t\tdata = hv->hv_hypercall;\n\t\tbreak;\n\tcase HV_X64_MSR_TIME_REF_COUNT:\n\t\tdata = get_time_ref_counter(kvm);\n\t\tbreak;\n\tcase HV_X64_MSR_REFERENCE_TSC:\n\t\tdata = hv->hv_tsc_page;\n\t\tbreak;\n\tcase HV_X64_MSR_CRASH_P0 ... HV_X64_MSR_CRASH_P4:\n\t\treturn kvm_hv_msr_get_crash_data(vcpu,\n\t\t\t\t\t\t msr - HV_X64_MSR_CRASH_P0,\n\t\t\t\t\t\t pdata);\n\tcase HV_X64_MSR_CRASH_CTL:\n\t\treturn kvm_hv_msr_get_crash_ctl(vcpu, pdata);\n\tcase HV_X64_MSR_RESET:\n\t\tdata = 0;\n\t\tbreak;\n\tdefault:\n\t\tvcpu_unimpl(vcpu, \"Hyper-V unhandled rdmsr: 0x%x\\n\", msr);\n\t\treturn 1;\n\t}\n\n\t*pdata = data;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&vcpu->kvm->lock"
          ],
          "line": 1033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_hv_msr_partition_wide",
          "args": [
            "msr"
          ],
          "line": 1030
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_hv_msr_partition_wide",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.c",
          "lines": "685-702",
          "snippet": "static bool kvm_hv_msr_partition_wide(u32 msr)\n{\n\tbool r = false;\n\n\tswitch (msr) {\n\tcase HV_X64_MSR_GUEST_OS_ID:\n\tcase HV_X64_MSR_HYPERCALL:\n\tcase HV_X64_MSR_REFERENCE_TSC:\n\tcase HV_X64_MSR_TIME_REF_COUNT:\n\tcase HV_X64_MSR_CRASH_CTL:\n\tcase HV_X64_MSR_CRASH_P0 ... HV_X64_MSR_CRASH_P4:\n\tcase HV_X64_MSR_RESET:\n\t\tr = true;\n\t\tbreak;\n\t}\n\n\treturn r;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic bool kvm_hv_msr_partition_wide(u32 msr)\n{\n\tbool r = false;\n\n\tswitch (msr) {\n\tcase HV_X64_MSR_GUEST_OS_ID:\n\tcase HV_X64_MSR_HYPERCALL:\n\tcase HV_X64_MSR_REFERENCE_TSC:\n\tcase HV_X64_MSR_TIME_REF_COUNT:\n\tcase HV_X64_MSR_CRASH_CTL:\n\tcase HV_X64_MSR_CRASH_P0 ... HV_X64_MSR_CRASH_P4:\n\tcase HV_X64_MSR_RESET:\n\t\tr = true;\n\t\tbreak;\n\t}\n\n\treturn r;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nint kvm_hv_get_msr_common(struct kvm_vcpu *vcpu, u32 msr, u64 *pdata)\n{\n\tif (kvm_hv_msr_partition_wide(msr)) {\n\t\tint r;\n\n\t\tmutex_lock(&vcpu->kvm->lock);\n\t\tr = kvm_hv_get_msr_pw(vcpu, msr, pdata);\n\t\tmutex_unlock(&vcpu->kvm->lock);\n\t\treturn r;\n\t} else\n\t\treturn kvm_hv_get_msr(vcpu, msr, pdata);\n}"
  },
  {
    "function_name": "kvm_hv_set_msr_common",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.c",
    "lines": "1015-1026",
    "snippet": "int kvm_hv_set_msr_common(struct kvm_vcpu *vcpu, u32 msr, u64 data, bool host)\n{\n\tif (kvm_hv_msr_partition_wide(msr)) {\n\t\tint r;\n\n\t\tmutex_lock(&vcpu->kvm->lock);\n\t\tr = kvm_hv_set_msr_pw(vcpu, msr, data, host);\n\t\tmutex_unlock(&vcpu->kvm->lock);\n\t\treturn r;\n\t} else\n\t\treturn kvm_hv_set_msr(vcpu, msr, data, host);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/apicdef.h>",
      "#include <linux/highmem.h>",
      "#include <linux/kvm_host.h>",
      "#include \"hyperv.h\"",
      "#include \"ioapic.h\"",
      "#include \"lapic.h\"",
      "#include \"x86.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_hv_set_msr",
          "args": [
            "vcpu",
            "msr",
            "data",
            "host"
          ],
          "line": 1025
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_hv_set_msr_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.c",
          "lines": "1015-1026",
          "snippet": "int kvm_hv_set_msr_common(struct kvm_vcpu *vcpu, u32 msr, u64 data, bool host)\n{\n\tif (kvm_hv_msr_partition_wide(msr)) {\n\t\tint r;\n\n\t\tmutex_lock(&vcpu->kvm->lock);\n\t\tr = kvm_hv_set_msr_pw(vcpu, msr, data, host);\n\t\tmutex_unlock(&vcpu->kvm->lock);\n\t\treturn r;\n\t} else\n\t\treturn kvm_hv_set_msr(vcpu, msr, data, host);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&vcpu->kvm->lock"
          ],
          "line": 1022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_hv_set_msr_pw",
          "args": [
            "vcpu",
            "msr",
            "data",
            "host"
          ],
          "line": 1021
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_hv_set_msr_pw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.c",
          "lines": "759-831",
          "snippet": "static int kvm_hv_set_msr_pw(struct kvm_vcpu *vcpu, u32 msr, u64 data,\n\t\t\t     bool host)\n{\n\tstruct kvm *kvm = vcpu->kvm;\n\tstruct kvm_hv *hv = &kvm->arch.hyperv;\n\n\tswitch (msr) {\n\tcase HV_X64_MSR_GUEST_OS_ID:\n\t\thv->hv_guest_os_id = data;\n\t\t/* setting guest os id to zero disables hypercall page */\n\t\tif (!hv->hv_guest_os_id)\n\t\t\thv->hv_hypercall &= ~HV_X64_MSR_HYPERCALL_ENABLE;\n\t\tbreak;\n\tcase HV_X64_MSR_HYPERCALL: {\n\t\tu64 gfn;\n\t\tunsigned long addr;\n\t\tu8 instructions[4];\n\n\t\t/* if guest os id is not set hypercall should remain disabled */\n\t\tif (!hv->hv_guest_os_id)\n\t\t\tbreak;\n\t\tif (!(data & HV_X64_MSR_HYPERCALL_ENABLE)) {\n\t\t\thv->hv_hypercall = data;\n\t\t\tbreak;\n\t\t}\n\t\tgfn = data >> HV_X64_MSR_HYPERCALL_PAGE_ADDRESS_SHIFT;\n\t\taddr = gfn_to_hva(kvm, gfn);\n\t\tif (kvm_is_error_hva(addr))\n\t\t\treturn 1;\n\t\tkvm_x86_ops->patch_hypercall(vcpu, instructions);\n\t\t((unsigned char *)instructions)[3] = 0xc3; /* ret */\n\t\tif (__copy_to_user((void __user *)addr, instructions, 4))\n\t\t\treturn 1;\n\t\thv->hv_hypercall = data;\n\t\tmark_page_dirty(kvm, gfn);\n\t\tbreak;\n\t}\n\tcase HV_X64_MSR_REFERENCE_TSC: {\n\t\tu64 gfn;\n\t\tHV_REFERENCE_TSC_PAGE tsc_ref;\n\n\t\tmemset(&tsc_ref, 0, sizeof(tsc_ref));\n\t\thv->hv_tsc_page = data;\n\t\tif (!(data & HV_X64_MSR_TSC_REFERENCE_ENABLE))\n\t\t\tbreak;\n\t\tgfn = data >> HV_X64_MSR_TSC_REFERENCE_ADDRESS_SHIFT;\n\t\tif (kvm_write_guest(\n\t\t\t\tkvm,\n\t\t\t\tgfn << HV_X64_MSR_TSC_REFERENCE_ADDRESS_SHIFT,\n\t\t\t\t&tsc_ref, sizeof(tsc_ref)))\n\t\t\treturn 1;\n\t\tmark_page_dirty(kvm, gfn);\n\t\tbreak;\n\t}\n\tcase HV_X64_MSR_CRASH_P0 ... HV_X64_MSR_CRASH_P4:\n\t\treturn kvm_hv_msr_set_crash_data(vcpu,\n\t\t\t\t\t\t msr - HV_X64_MSR_CRASH_P0,\n\t\t\t\t\t\t data);\n\tcase HV_X64_MSR_CRASH_CTL:\n\t\treturn kvm_hv_msr_set_crash_ctl(vcpu, data, host);\n\tcase HV_X64_MSR_RESET:\n\t\tif (data == 1) {\n\t\t\tvcpu_debug(vcpu, \"hyper-v reset requested\\n\");\n\t\t\tkvm_make_request(KVM_REQ_HV_RESET, vcpu);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tvcpu_unimpl(vcpu, \"Hyper-V uhandled wrmsr: 0x%x data 0x%llx\\n\",\n\t\t\t    msr, data);\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic int kvm_hv_set_msr_pw(struct kvm_vcpu *vcpu, u32 msr, u64 data,\n\t\t\t     bool host)\n{\n\tstruct kvm *kvm = vcpu->kvm;\n\tstruct kvm_hv *hv = &kvm->arch.hyperv;\n\n\tswitch (msr) {\n\tcase HV_X64_MSR_GUEST_OS_ID:\n\t\thv->hv_guest_os_id = data;\n\t\t/* setting guest os id to zero disables hypercall page */\n\t\tif (!hv->hv_guest_os_id)\n\t\t\thv->hv_hypercall &= ~HV_X64_MSR_HYPERCALL_ENABLE;\n\t\tbreak;\n\tcase HV_X64_MSR_HYPERCALL: {\n\t\tu64 gfn;\n\t\tunsigned long addr;\n\t\tu8 instructions[4];\n\n\t\t/* if guest os id is not set hypercall should remain disabled */\n\t\tif (!hv->hv_guest_os_id)\n\t\t\tbreak;\n\t\tif (!(data & HV_X64_MSR_HYPERCALL_ENABLE)) {\n\t\t\thv->hv_hypercall = data;\n\t\t\tbreak;\n\t\t}\n\t\tgfn = data >> HV_X64_MSR_HYPERCALL_PAGE_ADDRESS_SHIFT;\n\t\taddr = gfn_to_hva(kvm, gfn);\n\t\tif (kvm_is_error_hva(addr))\n\t\t\treturn 1;\n\t\tkvm_x86_ops->patch_hypercall(vcpu, instructions);\n\t\t((unsigned char *)instructions)[3] = 0xc3; /* ret */\n\t\tif (__copy_to_user((void __user *)addr, instructions, 4))\n\t\t\treturn 1;\n\t\thv->hv_hypercall = data;\n\t\tmark_page_dirty(kvm, gfn);\n\t\tbreak;\n\t}\n\tcase HV_X64_MSR_REFERENCE_TSC: {\n\t\tu64 gfn;\n\t\tHV_REFERENCE_TSC_PAGE tsc_ref;\n\n\t\tmemset(&tsc_ref, 0, sizeof(tsc_ref));\n\t\thv->hv_tsc_page = data;\n\t\tif (!(data & HV_X64_MSR_TSC_REFERENCE_ENABLE))\n\t\t\tbreak;\n\t\tgfn = data >> HV_X64_MSR_TSC_REFERENCE_ADDRESS_SHIFT;\n\t\tif (kvm_write_guest(\n\t\t\t\tkvm,\n\t\t\t\tgfn << HV_X64_MSR_TSC_REFERENCE_ADDRESS_SHIFT,\n\t\t\t\t&tsc_ref, sizeof(tsc_ref)))\n\t\t\treturn 1;\n\t\tmark_page_dirty(kvm, gfn);\n\t\tbreak;\n\t}\n\tcase HV_X64_MSR_CRASH_P0 ... HV_X64_MSR_CRASH_P4:\n\t\treturn kvm_hv_msr_set_crash_data(vcpu,\n\t\t\t\t\t\t msr - HV_X64_MSR_CRASH_P0,\n\t\t\t\t\t\t data);\n\tcase HV_X64_MSR_CRASH_CTL:\n\t\treturn kvm_hv_msr_set_crash_ctl(vcpu, data, host);\n\tcase HV_X64_MSR_RESET:\n\t\tif (data == 1) {\n\t\t\tvcpu_debug(vcpu, \"hyper-v reset requested\\n\");\n\t\t\tkvm_make_request(KVM_REQ_HV_RESET, vcpu);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tvcpu_unimpl(vcpu, \"Hyper-V uhandled wrmsr: 0x%x data 0x%llx\\n\",\n\t\t\t    msr, data);\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&vcpu->kvm->lock"
          ],
          "line": 1020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_hv_msr_partition_wide",
          "args": [
            "msr"
          ],
          "line": 1017
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_hv_msr_partition_wide",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.c",
          "lines": "685-702",
          "snippet": "static bool kvm_hv_msr_partition_wide(u32 msr)\n{\n\tbool r = false;\n\n\tswitch (msr) {\n\tcase HV_X64_MSR_GUEST_OS_ID:\n\tcase HV_X64_MSR_HYPERCALL:\n\tcase HV_X64_MSR_REFERENCE_TSC:\n\tcase HV_X64_MSR_TIME_REF_COUNT:\n\tcase HV_X64_MSR_CRASH_CTL:\n\tcase HV_X64_MSR_CRASH_P0 ... HV_X64_MSR_CRASH_P4:\n\tcase HV_X64_MSR_RESET:\n\t\tr = true;\n\t\tbreak;\n\t}\n\n\treturn r;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic bool kvm_hv_msr_partition_wide(u32 msr)\n{\n\tbool r = false;\n\n\tswitch (msr) {\n\tcase HV_X64_MSR_GUEST_OS_ID:\n\tcase HV_X64_MSR_HYPERCALL:\n\tcase HV_X64_MSR_REFERENCE_TSC:\n\tcase HV_X64_MSR_TIME_REF_COUNT:\n\tcase HV_X64_MSR_CRASH_CTL:\n\tcase HV_X64_MSR_CRASH_P0 ... HV_X64_MSR_CRASH_P4:\n\tcase HV_X64_MSR_RESET:\n\t\tr = true;\n\t\tbreak;\n\t}\n\n\treturn r;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nint kvm_hv_set_msr_common(struct kvm_vcpu *vcpu, u32 msr, u64 data, bool host)\n{\n\tif (kvm_hv_msr_partition_wide(msr)) {\n\t\tint r;\n\n\t\tmutex_lock(&vcpu->kvm->lock);\n\t\tr = kvm_hv_set_msr_pw(vcpu, msr, data, host);\n\t\tmutex_unlock(&vcpu->kvm->lock);\n\t\treturn r;\n\t} else\n\t\treturn kvm_hv_set_msr(vcpu, msr, data, host);\n}"
  },
  {
    "function_name": "kvm_hv_get_msr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.c",
    "lines": "952-1013",
    "snippet": "static int kvm_hv_get_msr(struct kvm_vcpu *vcpu, u32 msr, u64 *pdata)\n{\n\tu64 data = 0;\n\tstruct kvm_vcpu_hv *hv = &vcpu->arch.hyperv;\n\n\tswitch (msr) {\n\tcase HV_X64_MSR_VP_INDEX: {\n\t\tint r;\n\t\tstruct kvm_vcpu *v;\n\n\t\tkvm_for_each_vcpu(r, v, vcpu->kvm) {\n\t\t\tif (v == vcpu) {\n\t\t\t\tdata = r;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\tcase HV_X64_MSR_EOI:\n\t\treturn kvm_hv_vapic_msr_read(vcpu, APIC_EOI, pdata);\n\tcase HV_X64_MSR_ICR:\n\t\treturn kvm_hv_vapic_msr_read(vcpu, APIC_ICR, pdata);\n\tcase HV_X64_MSR_TPR:\n\t\treturn kvm_hv_vapic_msr_read(vcpu, APIC_TASKPRI, pdata);\n\tcase HV_X64_MSR_APIC_ASSIST_PAGE:\n\t\tdata = hv->hv_vapic;\n\t\tbreak;\n\tcase HV_X64_MSR_VP_RUNTIME:\n\t\tdata = current_task_runtime_100ns() + hv->runtime_offset;\n\t\tbreak;\n\tcase HV_X64_MSR_SCONTROL:\n\tcase HV_X64_MSR_SVERSION:\n\tcase HV_X64_MSR_SIEFP:\n\tcase HV_X64_MSR_SIMP:\n\tcase HV_X64_MSR_EOM:\n\tcase HV_X64_MSR_SINT0 ... HV_X64_MSR_SINT15:\n\t\treturn synic_get_msr(vcpu_to_synic(vcpu), msr, pdata);\n\tcase HV_X64_MSR_STIMER0_CONFIG:\n\tcase HV_X64_MSR_STIMER1_CONFIG:\n\tcase HV_X64_MSR_STIMER2_CONFIG:\n\tcase HV_X64_MSR_STIMER3_CONFIG: {\n\t\tint timer_index = (msr - HV_X64_MSR_STIMER0_CONFIG)/2;\n\n\t\treturn stimer_get_config(vcpu_to_stimer(vcpu, timer_index),\n\t\t\t\t\t pdata);\n\t}\n\tcase HV_X64_MSR_STIMER0_COUNT:\n\tcase HV_X64_MSR_STIMER1_COUNT:\n\tcase HV_X64_MSR_STIMER2_COUNT:\n\tcase HV_X64_MSR_STIMER3_COUNT: {\n\t\tint timer_index = (msr - HV_X64_MSR_STIMER0_COUNT)/2;\n\n\t\treturn stimer_get_count(vcpu_to_stimer(vcpu, timer_index),\n\t\t\t\t\tpdata);\n\t}\n\tdefault:\n\t\tvcpu_unimpl(vcpu, \"Hyper-V unhandled rdmsr: 0x%x\\n\", msr);\n\t\treturn 1;\n\t}\n\t*pdata = data;\n\treturn 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/apicdef.h>",
      "#include <linux/highmem.h>",
      "#include <linux/kvm_host.h>",
      "#include \"hyperv.h\"",
      "#include \"ioapic.h\"",
      "#include \"lapic.h\"",
      "#include \"x86.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vcpu_unimpl",
          "args": [
            "vcpu",
            "\"Hyper-V unhandled rdmsr: 0x%x\\n\"",
            "msr"
          ],
          "line": 1008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stimer_get_count",
          "args": [
            "vcpu_to_stimer(vcpu, timer_index)",
            "pdata"
          ],
          "line": 1004
        },
        "resolved": true,
        "details": {
          "function_name": "stimer_get_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.c",
          "lines": "525-529",
          "snippet": "static int stimer_get_count(struct kvm_vcpu_hv_stimer *stimer, u64 *pcount)\n{\n\t*pcount = stimer->count;\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic int stimer_get_count(struct kvm_vcpu_hv_stimer *stimer, u64 *pcount)\n{\n\t*pcount = stimer->count;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vcpu_to_stimer",
          "args": [
            "vcpu",
            "timer_index"
          ],
          "line": 1004
        },
        "resolved": true,
        "details": {
          "function_name": "vcpu_to_stimer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.h",
          "lines": "64-68",
          "snippet": "static inline struct kvm_vcpu_hv_stimer *vcpu_to_stimer(struct kvm_vcpu *vcpu,\n\t\t\t\t\t\t\tint timer_index)\n{\n\treturn &vcpu_to_hv_vcpu(vcpu)->stimer[timer_index];\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct kvm_vcpu_hv_stimer *vcpu_to_stimer(struct kvm_vcpu *vcpu,\n\t\t\t\t\t\t\tint timer_index)\n{\n\treturn &vcpu_to_hv_vcpu(vcpu)->stimer[timer_index];\n}"
        }
      },
      {
        "call_info": {
          "callee": "stimer_get_config",
          "args": [
            "vcpu_to_stimer(vcpu, timer_index)",
            "pdata"
          ],
          "line": 995
        },
        "resolved": true,
        "details": {
          "function_name": "stimer_get_config",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.c",
          "lines": "519-523",
          "snippet": "static int stimer_get_config(struct kvm_vcpu_hv_stimer *stimer, u64 *pconfig)\n{\n\t*pconfig = stimer->config;\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic int stimer_get_config(struct kvm_vcpu_hv_stimer *stimer, u64 *pconfig)\n{\n\t*pconfig = stimer->config;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "synic_get_msr",
          "args": [
            "vcpu_to_synic(vcpu)",
            "msr",
            "pdata"
          ],
          "line": 988
        },
        "resolved": true,
        "details": {
          "function_name": "synic_get_msr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.c",
          "lines": "260-292",
          "snippet": "static int synic_get_msr(struct kvm_vcpu_hv_synic *synic, u32 msr, u64 *pdata)\n{\n\tint ret;\n\n\tif (!synic->active)\n\t\treturn 1;\n\n\tret = 0;\n\tswitch (msr) {\n\tcase HV_X64_MSR_SCONTROL:\n\t\t*pdata = synic->control;\n\t\tbreak;\n\tcase HV_X64_MSR_SVERSION:\n\t\t*pdata = synic->version;\n\t\tbreak;\n\tcase HV_X64_MSR_SIEFP:\n\t\t*pdata = synic->evt_page;\n\t\tbreak;\n\tcase HV_X64_MSR_SIMP:\n\t\t*pdata = synic->msg_page;\n\t\tbreak;\n\tcase HV_X64_MSR_EOM:\n\t\t*pdata = 0;\n\t\tbreak;\n\tcase HV_X64_MSR_SINT0 ... HV_X64_MSR_SINT15:\n\t\t*pdata = atomic64_read(&synic->sint[msr - HV_X64_MSR_SINT0]);\n\t\tbreak;\n\tdefault:\n\t\tret = 1;\n\t\tbreak;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic int synic_get_msr(struct kvm_vcpu_hv_synic *synic, u32 msr, u64 *pdata)\n{\n\tint ret;\n\n\tif (!synic->active)\n\t\treturn 1;\n\n\tret = 0;\n\tswitch (msr) {\n\tcase HV_X64_MSR_SCONTROL:\n\t\t*pdata = synic->control;\n\t\tbreak;\n\tcase HV_X64_MSR_SVERSION:\n\t\t*pdata = synic->version;\n\t\tbreak;\n\tcase HV_X64_MSR_SIEFP:\n\t\t*pdata = synic->evt_page;\n\t\tbreak;\n\tcase HV_X64_MSR_SIMP:\n\t\t*pdata = synic->msg_page;\n\t\tbreak;\n\tcase HV_X64_MSR_EOM:\n\t\t*pdata = 0;\n\t\tbreak;\n\tcase HV_X64_MSR_SINT0 ... HV_X64_MSR_SINT15:\n\t\t*pdata = atomic64_read(&synic->sint[msr - HV_X64_MSR_SINT0]);\n\t\tbreak;\n\tdefault:\n\t\tret = 1;\n\t\tbreak;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vcpu_to_synic",
          "args": [
            "vcpu"
          ],
          "line": 988
        },
        "resolved": true,
        "details": {
          "function_name": "vcpu_to_synic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.h",
          "lines": "40-43",
          "snippet": "static inline struct kvm_vcpu_hv_synic *vcpu_to_synic(struct kvm_vcpu *vcpu)\n{\n\treturn &vcpu->arch.hyperv.synic;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct kvm_vcpu_hv_synic *vcpu_to_synic(struct kvm_vcpu *vcpu)\n{\n\treturn &vcpu->arch.hyperv.synic;\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_task_runtime_100ns",
          "args": [],
          "line": 980
        },
        "resolved": true,
        "details": {
          "function_name": "current_task_runtime_100ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.c",
          "lines": "834-840",
          "snippet": "static u64 current_task_runtime_100ns(void)\n{\n\tcputime_t utime, stime;\n\n\ttask_cputime_adjusted(current, &utime, &stime);\n\treturn div_u64(cputime_to_nsecs(utime + stime), 100);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic u64 current_task_runtime_100ns(void)\n{\n\tcputime_t utime, stime;\n\n\ttask_cputime_adjusted(current, &utime, &stime);\n\treturn div_u64(cputime_to_nsecs(utime + stime), 100);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_hv_vapic_msr_read",
          "args": [
            "vcpu",
            "APIC_TASKPRI",
            "pdata"
          ],
          "line": 975
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_hv_vapic_msr_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "2164-2180",
          "snippet": "int kvm_hv_vapic_msr_read(struct kvm_vcpu *vcpu, u32 reg, u64 *data)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tu32 low, high = 0;\n\n\tif (!lapic_in_kernel(vcpu))\n\t\treturn 1;\n\n\tif (kvm_lapic_reg_read(apic, reg, 4, &low))\n\t\treturn 1;\n\tif (reg == APIC_ICR)\n\t\tkvm_lapic_reg_read(apic, APIC_ICR2, 4, &high);\n\n\t*data = (((u64)high) << 32) | low;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nint kvm_hv_vapic_msr_read(struct kvm_vcpu *vcpu, u32 reg, u64 *data)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tu32 low, high = 0;\n\n\tif (!lapic_in_kernel(vcpu))\n\t\treturn 1;\n\n\tif (kvm_lapic_reg_read(apic, reg, 4, &low))\n\t\treturn 1;\n\tif (reg == APIC_ICR)\n\t\tkvm_lapic_reg_read(apic, APIC_ICR2, 4, &high);\n\n\t*data = (((u64)high) << 32) | low;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_for_each_vcpu",
          "args": [
            "r",
            "v",
            "vcpu->kvm"
          ],
          "line": 962
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic int kvm_hv_get_msr(struct kvm_vcpu *vcpu, u32 msr, u64 *pdata)\n{\n\tu64 data = 0;\n\tstruct kvm_vcpu_hv *hv = &vcpu->arch.hyperv;\n\n\tswitch (msr) {\n\tcase HV_X64_MSR_VP_INDEX: {\n\t\tint r;\n\t\tstruct kvm_vcpu *v;\n\n\t\tkvm_for_each_vcpu(r, v, vcpu->kvm) {\n\t\t\tif (v == vcpu) {\n\t\t\t\tdata = r;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\tcase HV_X64_MSR_EOI:\n\t\treturn kvm_hv_vapic_msr_read(vcpu, APIC_EOI, pdata);\n\tcase HV_X64_MSR_ICR:\n\t\treturn kvm_hv_vapic_msr_read(vcpu, APIC_ICR, pdata);\n\tcase HV_X64_MSR_TPR:\n\t\treturn kvm_hv_vapic_msr_read(vcpu, APIC_TASKPRI, pdata);\n\tcase HV_X64_MSR_APIC_ASSIST_PAGE:\n\t\tdata = hv->hv_vapic;\n\t\tbreak;\n\tcase HV_X64_MSR_VP_RUNTIME:\n\t\tdata = current_task_runtime_100ns() + hv->runtime_offset;\n\t\tbreak;\n\tcase HV_X64_MSR_SCONTROL:\n\tcase HV_X64_MSR_SVERSION:\n\tcase HV_X64_MSR_SIEFP:\n\tcase HV_X64_MSR_SIMP:\n\tcase HV_X64_MSR_EOM:\n\tcase HV_X64_MSR_SINT0 ... HV_X64_MSR_SINT15:\n\t\treturn synic_get_msr(vcpu_to_synic(vcpu), msr, pdata);\n\tcase HV_X64_MSR_STIMER0_CONFIG:\n\tcase HV_X64_MSR_STIMER1_CONFIG:\n\tcase HV_X64_MSR_STIMER2_CONFIG:\n\tcase HV_X64_MSR_STIMER3_CONFIG: {\n\t\tint timer_index = (msr - HV_X64_MSR_STIMER0_CONFIG)/2;\n\n\t\treturn stimer_get_config(vcpu_to_stimer(vcpu, timer_index),\n\t\t\t\t\t pdata);\n\t}\n\tcase HV_X64_MSR_STIMER0_COUNT:\n\tcase HV_X64_MSR_STIMER1_COUNT:\n\tcase HV_X64_MSR_STIMER2_COUNT:\n\tcase HV_X64_MSR_STIMER3_COUNT: {\n\t\tint timer_index = (msr - HV_X64_MSR_STIMER0_COUNT)/2;\n\n\t\treturn stimer_get_count(vcpu_to_stimer(vcpu, timer_index),\n\t\t\t\t\tpdata);\n\t}\n\tdefault:\n\t\tvcpu_unimpl(vcpu, \"Hyper-V unhandled rdmsr: 0x%x\\n\", msr);\n\t\treturn 1;\n\t}\n\t*pdata = data;\n\treturn 0;\n}"
  },
  {
    "function_name": "kvm_hv_get_msr_pw",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.c",
    "lines": "915-950",
    "snippet": "static int kvm_hv_get_msr_pw(struct kvm_vcpu *vcpu, u32 msr, u64 *pdata)\n{\n\tu64 data = 0;\n\tstruct kvm *kvm = vcpu->kvm;\n\tstruct kvm_hv *hv = &kvm->arch.hyperv;\n\n\tswitch (msr) {\n\tcase HV_X64_MSR_GUEST_OS_ID:\n\t\tdata = hv->hv_guest_os_id;\n\t\tbreak;\n\tcase HV_X64_MSR_HYPERCALL:\n\t\tdata = hv->hv_hypercall;\n\t\tbreak;\n\tcase HV_X64_MSR_TIME_REF_COUNT:\n\t\tdata = get_time_ref_counter(kvm);\n\t\tbreak;\n\tcase HV_X64_MSR_REFERENCE_TSC:\n\t\tdata = hv->hv_tsc_page;\n\t\tbreak;\n\tcase HV_X64_MSR_CRASH_P0 ... HV_X64_MSR_CRASH_P4:\n\t\treturn kvm_hv_msr_get_crash_data(vcpu,\n\t\t\t\t\t\t msr - HV_X64_MSR_CRASH_P0,\n\t\t\t\t\t\t pdata);\n\tcase HV_X64_MSR_CRASH_CTL:\n\t\treturn kvm_hv_msr_get_crash_ctl(vcpu, pdata);\n\tcase HV_X64_MSR_RESET:\n\t\tdata = 0;\n\t\tbreak;\n\tdefault:\n\t\tvcpu_unimpl(vcpu, \"Hyper-V unhandled rdmsr: 0x%x\\n\", msr);\n\t\treturn 1;\n\t}\n\n\t*pdata = data;\n\treturn 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/apicdef.h>",
      "#include <linux/highmem.h>",
      "#include <linux/kvm_host.h>",
      "#include \"hyperv.h\"",
      "#include \"ioapic.h\"",
      "#include \"lapic.h\"",
      "#include \"x86.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vcpu_unimpl",
          "args": [
            "vcpu",
            "\"Hyper-V unhandled rdmsr: 0x%x\\n\"",
            "msr"
          ],
          "line": 944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_hv_msr_get_crash_ctl",
          "args": [
            "vcpu",
            "pdata"
          ],
          "line": 939
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_hv_msr_get_crash_ctl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.c",
          "lines": "716-722",
          "snippet": "static int kvm_hv_msr_get_crash_ctl(struct kvm_vcpu *vcpu, u64 *pdata)\n{\n\tstruct kvm_hv *hv = &vcpu->kvm->arch.hyperv;\n\n\t*pdata = hv->hv_crash_ctl;\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic int kvm_hv_msr_get_crash_ctl(struct kvm_vcpu *vcpu, u64 *pdata)\n{\n\tstruct kvm_hv *hv = &vcpu->kvm->arch.hyperv;\n\n\t*pdata = hv->hv_crash_ctl;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_hv_msr_get_crash_data",
          "args": [
            "vcpu",
            "msr - HV_X64_MSR_CRASH_P0",
            "pdata"
          ],
          "line": 935
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_hv_msr_get_crash_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.c",
          "lines": "704-714",
          "snippet": "static int kvm_hv_msr_get_crash_data(struct kvm_vcpu *vcpu,\n\t\t\t\t     u32 index, u64 *pdata)\n{\n\tstruct kvm_hv *hv = &vcpu->kvm->arch.hyperv;\n\n\tif (WARN_ON_ONCE(index >= ARRAY_SIZE(hv->hv_crash_param)))\n\t\treturn -EINVAL;\n\n\t*pdata = hv->hv_crash_param[index];\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic int kvm_hv_msr_get_crash_data(struct kvm_vcpu *vcpu,\n\t\t\t\t     u32 index, u64 *pdata)\n{\n\tstruct kvm_hv *hv = &vcpu->kvm->arch.hyperv;\n\n\tif (WARN_ON_ONCE(index >= ARRAY_SIZE(hv->hv_crash_param)))\n\t\treturn -EINVAL;\n\n\t*pdata = hv->hv_crash_param[index];\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_time_ref_counter",
          "args": [
            "kvm"
          ],
          "line": 929
        },
        "resolved": true,
        "details": {
          "function_name": "get_time_ref_counter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.c",
          "lines": "387-390",
          "snippet": "static u64 get_time_ref_counter(struct kvm *kvm)\n{\n\treturn div_u64(get_kernel_ns() + kvm->arch.kvmclock_offset, 100);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic u64 get_time_ref_counter(struct kvm *kvm)\n{\n\treturn div_u64(get_kernel_ns() + kvm->arch.kvmclock_offset, 100);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic int kvm_hv_get_msr_pw(struct kvm_vcpu *vcpu, u32 msr, u64 *pdata)\n{\n\tu64 data = 0;\n\tstruct kvm *kvm = vcpu->kvm;\n\tstruct kvm_hv *hv = &kvm->arch.hyperv;\n\n\tswitch (msr) {\n\tcase HV_X64_MSR_GUEST_OS_ID:\n\t\tdata = hv->hv_guest_os_id;\n\t\tbreak;\n\tcase HV_X64_MSR_HYPERCALL:\n\t\tdata = hv->hv_hypercall;\n\t\tbreak;\n\tcase HV_X64_MSR_TIME_REF_COUNT:\n\t\tdata = get_time_ref_counter(kvm);\n\t\tbreak;\n\tcase HV_X64_MSR_REFERENCE_TSC:\n\t\tdata = hv->hv_tsc_page;\n\t\tbreak;\n\tcase HV_X64_MSR_CRASH_P0 ... HV_X64_MSR_CRASH_P4:\n\t\treturn kvm_hv_msr_get_crash_data(vcpu,\n\t\t\t\t\t\t msr - HV_X64_MSR_CRASH_P0,\n\t\t\t\t\t\t pdata);\n\tcase HV_X64_MSR_CRASH_CTL:\n\t\treturn kvm_hv_msr_get_crash_ctl(vcpu, pdata);\n\tcase HV_X64_MSR_RESET:\n\t\tdata = 0;\n\t\tbreak;\n\tdefault:\n\t\tvcpu_unimpl(vcpu, \"Hyper-V unhandled rdmsr: 0x%x\\n\", msr);\n\t\treturn 1;\n\t}\n\n\t*pdata = data;\n\treturn 0;\n}"
  },
  {
    "function_name": "kvm_hv_set_msr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.c",
    "lines": "842-913",
    "snippet": "static int kvm_hv_set_msr(struct kvm_vcpu *vcpu, u32 msr, u64 data, bool host)\n{\n\tstruct kvm_vcpu_hv *hv = &vcpu->arch.hyperv;\n\n\tswitch (msr) {\n\tcase HV_X64_MSR_APIC_ASSIST_PAGE: {\n\t\tu64 gfn;\n\t\tunsigned long addr;\n\n\t\tif (!(data & HV_X64_MSR_APIC_ASSIST_PAGE_ENABLE)) {\n\t\t\thv->hv_vapic = data;\n\t\t\tif (kvm_lapic_enable_pv_eoi(vcpu, 0))\n\t\t\t\treturn 1;\n\t\t\tbreak;\n\t\t}\n\t\tgfn = data >> HV_X64_MSR_APIC_ASSIST_PAGE_ADDRESS_SHIFT;\n\t\taddr = kvm_vcpu_gfn_to_hva(vcpu, gfn);\n\t\tif (kvm_is_error_hva(addr))\n\t\t\treturn 1;\n\t\tif (__clear_user((void __user *)addr, PAGE_SIZE))\n\t\t\treturn 1;\n\t\thv->hv_vapic = data;\n\t\tkvm_vcpu_mark_page_dirty(vcpu, gfn);\n\t\tif (kvm_lapic_enable_pv_eoi(vcpu,\n\t\t\t\t\t    gfn_to_gpa(gfn) | KVM_MSR_ENABLED))\n\t\t\treturn 1;\n\t\tbreak;\n\t}\n\tcase HV_X64_MSR_EOI:\n\t\treturn kvm_hv_vapic_msr_write(vcpu, APIC_EOI, data);\n\tcase HV_X64_MSR_ICR:\n\t\treturn kvm_hv_vapic_msr_write(vcpu, APIC_ICR, data);\n\tcase HV_X64_MSR_TPR:\n\t\treturn kvm_hv_vapic_msr_write(vcpu, APIC_TASKPRI, data);\n\tcase HV_X64_MSR_VP_RUNTIME:\n\t\tif (!host)\n\t\t\treturn 1;\n\t\thv->runtime_offset = data - current_task_runtime_100ns();\n\t\tbreak;\n\tcase HV_X64_MSR_SCONTROL:\n\tcase HV_X64_MSR_SVERSION:\n\tcase HV_X64_MSR_SIEFP:\n\tcase HV_X64_MSR_SIMP:\n\tcase HV_X64_MSR_EOM:\n\tcase HV_X64_MSR_SINT0 ... HV_X64_MSR_SINT15:\n\t\treturn synic_set_msr(vcpu_to_synic(vcpu), msr, data, host);\n\tcase HV_X64_MSR_STIMER0_CONFIG:\n\tcase HV_X64_MSR_STIMER1_CONFIG:\n\tcase HV_X64_MSR_STIMER2_CONFIG:\n\tcase HV_X64_MSR_STIMER3_CONFIG: {\n\t\tint timer_index = (msr - HV_X64_MSR_STIMER0_CONFIG)/2;\n\n\t\treturn stimer_set_config(vcpu_to_stimer(vcpu, timer_index),\n\t\t\t\t\t data, host);\n\t}\n\tcase HV_X64_MSR_STIMER0_COUNT:\n\tcase HV_X64_MSR_STIMER1_COUNT:\n\tcase HV_X64_MSR_STIMER2_COUNT:\n\tcase HV_X64_MSR_STIMER3_COUNT: {\n\t\tint timer_index = (msr - HV_X64_MSR_STIMER0_COUNT)/2;\n\n\t\treturn stimer_set_count(vcpu_to_stimer(vcpu, timer_index),\n\t\t\t\t\tdata, host);\n\t}\n\tdefault:\n\t\tvcpu_unimpl(vcpu, \"Hyper-V uhandled wrmsr: 0x%x data 0x%llx\\n\",\n\t\t\t    msr, data);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/apicdef.h>",
      "#include <linux/highmem.h>",
      "#include <linux/kvm_host.h>",
      "#include \"hyperv.h\"",
      "#include \"ioapic.h\"",
      "#include \"lapic.h\"",
      "#include \"x86.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vcpu_unimpl",
          "args": [
            "vcpu",
            "\"Hyper-V uhandled wrmsr: 0x%x data 0x%llx\\n\"",
            "msr",
            "data"
          ],
          "line": 907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stimer_set_count",
          "args": [
            "vcpu_to_stimer(vcpu, timer_index)",
            "data",
            "host"
          ],
          "line": 903
        },
        "resolved": true,
        "details": {
          "function_name": "stimer_set_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.c",
          "lines": "503-517",
          "snippet": "static int stimer_set_count(struct kvm_vcpu_hv_stimer *stimer, u64 count,\n\t\t\t    bool host)\n{\n\ttrace_kvm_hv_stimer_set_count(stimer_to_vcpu(stimer)->vcpu_id,\n\t\t\t\t      stimer->index, count, host);\n\n\tstimer_cleanup(stimer);\n\tstimer->count = count;\n\tif (stimer->count == 0)\n\t\tstimer->config &= ~HV_STIMER_ENABLE;\n\telse if (stimer->config & HV_STIMER_AUTOENABLE)\n\t\tstimer->config |= HV_STIMER_ENABLE;\n\tstimer_mark_pending(stimer, false);\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic int stimer_set_count(struct kvm_vcpu_hv_stimer *stimer, u64 count,\n\t\t\t    bool host)\n{\n\ttrace_kvm_hv_stimer_set_count(stimer_to_vcpu(stimer)->vcpu_id,\n\t\t\t\t      stimer->index, count, host);\n\n\tstimer_cleanup(stimer);\n\tstimer->count = count;\n\tif (stimer->count == 0)\n\t\tstimer->config &= ~HV_STIMER_ENABLE;\n\telse if (stimer->config & HV_STIMER_AUTOENABLE)\n\t\tstimer->config |= HV_STIMER_ENABLE;\n\tstimer_mark_pending(stimer, false);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vcpu_to_stimer",
          "args": [
            "vcpu",
            "timer_index"
          ],
          "line": 903
        },
        "resolved": true,
        "details": {
          "function_name": "vcpu_to_stimer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.h",
          "lines": "64-68",
          "snippet": "static inline struct kvm_vcpu_hv_stimer *vcpu_to_stimer(struct kvm_vcpu *vcpu,\n\t\t\t\t\t\t\tint timer_index)\n{\n\treturn &vcpu_to_hv_vcpu(vcpu)->stimer[timer_index];\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct kvm_vcpu_hv_stimer *vcpu_to_stimer(struct kvm_vcpu *vcpu,\n\t\t\t\t\t\t\tint timer_index)\n{\n\treturn &vcpu_to_hv_vcpu(vcpu)->stimer[timer_index];\n}"
        }
      },
      {
        "call_info": {
          "callee": "stimer_set_config",
          "args": [
            "vcpu_to_stimer(vcpu, timer_index)",
            "data",
            "host"
          ],
          "line": 894
        },
        "resolved": true,
        "details": {
          "function_name": "stimer_set_config",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.c",
          "lines": "489-501",
          "snippet": "static int stimer_set_config(struct kvm_vcpu_hv_stimer *stimer, u64 config,\n\t\t\t     bool host)\n{\n\ttrace_kvm_hv_stimer_set_config(stimer_to_vcpu(stimer)->vcpu_id,\n\t\t\t\t       stimer->index, config, host);\n\n\tstimer_cleanup(stimer);\n\tif ((stimer->config & HV_STIMER_ENABLE) && HV_STIMER_SINT(config) == 0)\n\t\tconfig &= ~HV_STIMER_ENABLE;\n\tstimer->config = config;\n\tstimer_mark_pending(stimer, false);\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic int stimer_set_config(struct kvm_vcpu_hv_stimer *stimer, u64 config,\n\t\t\t     bool host)\n{\n\ttrace_kvm_hv_stimer_set_config(stimer_to_vcpu(stimer)->vcpu_id,\n\t\t\t\t       stimer->index, config, host);\n\n\tstimer_cleanup(stimer);\n\tif ((stimer->config & HV_STIMER_ENABLE) && HV_STIMER_SINT(config) == 0)\n\t\tconfig &= ~HV_STIMER_ENABLE;\n\tstimer->config = config;\n\tstimer_mark_pending(stimer, false);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "synic_set_msr",
          "args": [
            "vcpu_to_synic(vcpu)",
            "msr",
            "data",
            "host"
          ],
          "line": 887
        },
        "resolved": true,
        "details": {
          "function_name": "synic_set_msr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.c",
          "lines": "196-258",
          "snippet": "static int synic_set_msr(struct kvm_vcpu_hv_synic *synic,\n\t\t\t u32 msr, u64 data, bool host)\n{\n\tstruct kvm_vcpu *vcpu = synic_to_vcpu(synic);\n\tint ret;\n\n\tif (!synic->active)\n\t\treturn 1;\n\n\ttrace_kvm_hv_synic_set_msr(vcpu->vcpu_id, msr, data, host);\n\n\tret = 0;\n\tswitch (msr) {\n\tcase HV_X64_MSR_SCONTROL:\n\t\tsynic->control = data;\n\t\tif (!host)\n\t\t\tsynic_exit(synic, msr);\n\t\tbreak;\n\tcase HV_X64_MSR_SVERSION:\n\t\tif (!host) {\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\t\tsynic->version = data;\n\t\tbreak;\n\tcase HV_X64_MSR_SIEFP:\n\t\tif (data & HV_SYNIC_SIEFP_ENABLE)\n\t\t\tif (kvm_clear_guest(vcpu->kvm,\n\t\t\t\t\t    data & PAGE_MASK, PAGE_SIZE)) {\n\t\t\t\tret = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tsynic->evt_page = data;\n\t\tif (!host)\n\t\t\tsynic_exit(synic, msr);\n\t\tbreak;\n\tcase HV_X64_MSR_SIMP:\n\t\tif (data & HV_SYNIC_SIMP_ENABLE)\n\t\t\tif (kvm_clear_guest(vcpu->kvm,\n\t\t\t\t\t    data & PAGE_MASK, PAGE_SIZE)) {\n\t\t\t\tret = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tsynic->msg_page = data;\n\t\tif (!host)\n\t\t\tsynic_exit(synic, msr);\n\t\tbreak;\n\tcase HV_X64_MSR_EOM: {\n\t\tint i;\n\n\t\tfor (i = 0; i < ARRAY_SIZE(synic->sint); i++)\n\t\t\tkvm_hv_notify_acked_sint(vcpu, i);\n\t\tbreak;\n\t}\n\tcase HV_X64_MSR_SINT0 ... HV_X64_MSR_SINT15:\n\t\tret = synic_set_sint(synic, msr - HV_X64_MSR_SINT0, data, host);\n\t\tbreak;\n\tdefault:\n\t\tret = 1;\n\t\tbreak;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic int synic_set_msr(struct kvm_vcpu_hv_synic *synic,\n\t\t\t u32 msr, u64 data, bool host)\n{\n\tstruct kvm_vcpu *vcpu = synic_to_vcpu(synic);\n\tint ret;\n\n\tif (!synic->active)\n\t\treturn 1;\n\n\ttrace_kvm_hv_synic_set_msr(vcpu->vcpu_id, msr, data, host);\n\n\tret = 0;\n\tswitch (msr) {\n\tcase HV_X64_MSR_SCONTROL:\n\t\tsynic->control = data;\n\t\tif (!host)\n\t\t\tsynic_exit(synic, msr);\n\t\tbreak;\n\tcase HV_X64_MSR_SVERSION:\n\t\tif (!host) {\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\t\tsynic->version = data;\n\t\tbreak;\n\tcase HV_X64_MSR_SIEFP:\n\t\tif (data & HV_SYNIC_SIEFP_ENABLE)\n\t\t\tif (kvm_clear_guest(vcpu->kvm,\n\t\t\t\t\t    data & PAGE_MASK, PAGE_SIZE)) {\n\t\t\t\tret = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tsynic->evt_page = data;\n\t\tif (!host)\n\t\t\tsynic_exit(synic, msr);\n\t\tbreak;\n\tcase HV_X64_MSR_SIMP:\n\t\tif (data & HV_SYNIC_SIMP_ENABLE)\n\t\t\tif (kvm_clear_guest(vcpu->kvm,\n\t\t\t\t\t    data & PAGE_MASK, PAGE_SIZE)) {\n\t\t\t\tret = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tsynic->msg_page = data;\n\t\tif (!host)\n\t\t\tsynic_exit(synic, msr);\n\t\tbreak;\n\tcase HV_X64_MSR_EOM: {\n\t\tint i;\n\n\t\tfor (i = 0; i < ARRAY_SIZE(synic->sint); i++)\n\t\t\tkvm_hv_notify_acked_sint(vcpu, i);\n\t\tbreak;\n\t}\n\tcase HV_X64_MSR_SINT0 ... HV_X64_MSR_SINT15:\n\t\tret = synic_set_sint(synic, msr - HV_X64_MSR_SINT0, data, host);\n\t\tbreak;\n\tdefault:\n\t\tret = 1;\n\t\tbreak;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vcpu_to_synic",
          "args": [
            "vcpu"
          ],
          "line": 887
        },
        "resolved": true,
        "details": {
          "function_name": "vcpu_to_synic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.h",
          "lines": "40-43",
          "snippet": "static inline struct kvm_vcpu_hv_synic *vcpu_to_synic(struct kvm_vcpu *vcpu)\n{\n\treturn &vcpu->arch.hyperv.synic;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct kvm_vcpu_hv_synic *vcpu_to_synic(struct kvm_vcpu *vcpu)\n{\n\treturn &vcpu->arch.hyperv.synic;\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_task_runtime_100ns",
          "args": [],
          "line": 879
        },
        "resolved": true,
        "details": {
          "function_name": "current_task_runtime_100ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.c",
          "lines": "834-840",
          "snippet": "static u64 current_task_runtime_100ns(void)\n{\n\tcputime_t utime, stime;\n\n\ttask_cputime_adjusted(current, &utime, &stime);\n\treturn div_u64(cputime_to_nsecs(utime + stime), 100);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic u64 current_task_runtime_100ns(void)\n{\n\tcputime_t utime, stime;\n\n\ttask_cputime_adjusted(current, &utime, &stime);\n\treturn div_u64(cputime_to_nsecs(utime + stime), 100);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_hv_vapic_msr_write",
          "args": [
            "vcpu",
            "APIC_TASKPRI",
            "data"
          ],
          "line": 875
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_hv_vapic_msr_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "2151-2162",
          "snippet": "int kvm_hv_vapic_msr_write(struct kvm_vcpu *vcpu, u32 reg, u64 data)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tif (!lapic_in_kernel(vcpu))\n\t\treturn 1;\n\n\t/* if this is ICR write vector before command */\n\tif (reg == APIC_ICR)\n\t\tkvm_lapic_reg_write(apic, APIC_ICR2, (u32)(data >> 32));\n\treturn kvm_lapic_reg_write(apic, reg, (u32)data);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nint kvm_hv_vapic_msr_write(struct kvm_vcpu *vcpu, u32 reg, u64 data)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tif (!lapic_in_kernel(vcpu))\n\t\treturn 1;\n\n\t/* if this is ICR write vector before command */\n\tif (reg == APIC_ICR)\n\t\tkvm_lapic_reg_write(apic, APIC_ICR2, (u32)(data >> 32));\n\treturn kvm_lapic_reg_write(apic, reg, (u32)data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_lapic_enable_pv_eoi",
          "args": [
            "vcpu",
            "gfn_to_gpa(gfn) | KVM_MSR_ENABLED"
          ],
          "line": 865
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_enable_pv_eoi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "2182-2193",
          "snippet": "int kvm_lapic_enable_pv_eoi(struct kvm_vcpu *vcpu, u64 data)\n{\n\tu64 addr = data & ~KVM_MSR_ENABLED;\n\tif (!IS_ALIGNED(addr, 4))\n\t\treturn 1;\n\n\tvcpu->arch.pv_eoi.msr_val = data;\n\tif (!pv_eoi_enabled(vcpu))\n\t\treturn 0;\n\treturn kvm_gfn_to_hva_cache_init(vcpu->kvm, &vcpu->arch.pv_eoi.data,\n\t\t\t\t\t addr, sizeof(u8));\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nint kvm_lapic_enable_pv_eoi(struct kvm_vcpu *vcpu, u64 data)\n{\n\tu64 addr = data & ~KVM_MSR_ENABLED;\n\tif (!IS_ALIGNED(addr, 4))\n\t\treturn 1;\n\n\tvcpu->arch.pv_eoi.msr_val = data;\n\tif (!pv_eoi_enabled(vcpu))\n\t\treturn 0;\n\treturn kvm_gfn_to_hva_cache_init(vcpu->kvm, &vcpu->arch.pv_eoi.data,\n\t\t\t\t\t addr, sizeof(u8));\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfn_to_gpa",
          "args": [
            "gfn"
          ],
          "line": 866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_mark_page_dirty",
          "args": [
            "vcpu",
            "gfn"
          ],
          "line": 864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__clear_user",
          "args": [
            "(void __user *)addr",
            "PAGE_SIZE"
          ],
          "line": 861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_is_error_hva",
          "args": [
            "addr"
          ],
          "line": 859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_gfn_to_hva",
          "args": [
            "vcpu",
            "gfn"
          ],
          "line": 858
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic int kvm_hv_set_msr(struct kvm_vcpu *vcpu, u32 msr, u64 data, bool host)\n{\n\tstruct kvm_vcpu_hv *hv = &vcpu->arch.hyperv;\n\n\tswitch (msr) {\n\tcase HV_X64_MSR_APIC_ASSIST_PAGE: {\n\t\tu64 gfn;\n\t\tunsigned long addr;\n\n\t\tif (!(data & HV_X64_MSR_APIC_ASSIST_PAGE_ENABLE)) {\n\t\t\thv->hv_vapic = data;\n\t\t\tif (kvm_lapic_enable_pv_eoi(vcpu, 0))\n\t\t\t\treturn 1;\n\t\t\tbreak;\n\t\t}\n\t\tgfn = data >> HV_X64_MSR_APIC_ASSIST_PAGE_ADDRESS_SHIFT;\n\t\taddr = kvm_vcpu_gfn_to_hva(vcpu, gfn);\n\t\tif (kvm_is_error_hva(addr))\n\t\t\treturn 1;\n\t\tif (__clear_user((void __user *)addr, PAGE_SIZE))\n\t\t\treturn 1;\n\t\thv->hv_vapic = data;\n\t\tkvm_vcpu_mark_page_dirty(vcpu, gfn);\n\t\tif (kvm_lapic_enable_pv_eoi(vcpu,\n\t\t\t\t\t    gfn_to_gpa(gfn) | KVM_MSR_ENABLED))\n\t\t\treturn 1;\n\t\tbreak;\n\t}\n\tcase HV_X64_MSR_EOI:\n\t\treturn kvm_hv_vapic_msr_write(vcpu, APIC_EOI, data);\n\tcase HV_X64_MSR_ICR:\n\t\treturn kvm_hv_vapic_msr_write(vcpu, APIC_ICR, data);\n\tcase HV_X64_MSR_TPR:\n\t\treturn kvm_hv_vapic_msr_write(vcpu, APIC_TASKPRI, data);\n\tcase HV_X64_MSR_VP_RUNTIME:\n\t\tif (!host)\n\t\t\treturn 1;\n\t\thv->runtime_offset = data - current_task_runtime_100ns();\n\t\tbreak;\n\tcase HV_X64_MSR_SCONTROL:\n\tcase HV_X64_MSR_SVERSION:\n\tcase HV_X64_MSR_SIEFP:\n\tcase HV_X64_MSR_SIMP:\n\tcase HV_X64_MSR_EOM:\n\tcase HV_X64_MSR_SINT0 ... HV_X64_MSR_SINT15:\n\t\treturn synic_set_msr(vcpu_to_synic(vcpu), msr, data, host);\n\tcase HV_X64_MSR_STIMER0_CONFIG:\n\tcase HV_X64_MSR_STIMER1_CONFIG:\n\tcase HV_X64_MSR_STIMER2_CONFIG:\n\tcase HV_X64_MSR_STIMER3_CONFIG: {\n\t\tint timer_index = (msr - HV_X64_MSR_STIMER0_CONFIG)/2;\n\n\t\treturn stimer_set_config(vcpu_to_stimer(vcpu, timer_index),\n\t\t\t\t\t data, host);\n\t}\n\tcase HV_X64_MSR_STIMER0_COUNT:\n\tcase HV_X64_MSR_STIMER1_COUNT:\n\tcase HV_X64_MSR_STIMER2_COUNT:\n\tcase HV_X64_MSR_STIMER3_COUNT: {\n\t\tint timer_index = (msr - HV_X64_MSR_STIMER0_COUNT)/2;\n\n\t\treturn stimer_set_count(vcpu_to_stimer(vcpu, timer_index),\n\t\t\t\t\tdata, host);\n\t}\n\tdefault:\n\t\tvcpu_unimpl(vcpu, \"Hyper-V uhandled wrmsr: 0x%x data 0x%llx\\n\",\n\t\t\t    msr, data);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "current_task_runtime_100ns",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.c",
    "lines": "834-840",
    "snippet": "static u64 current_task_runtime_100ns(void)\n{\n\tcputime_t utime, stime;\n\n\ttask_cputime_adjusted(current, &utime, &stime);\n\treturn div_u64(cputime_to_nsecs(utime + stime), 100);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/apicdef.h>",
      "#include <linux/highmem.h>",
      "#include <linux/kvm_host.h>",
      "#include \"hyperv.h\"",
      "#include \"ioapic.h\"",
      "#include \"lapic.h\"",
      "#include \"x86.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "div_u64",
          "args": [
            "cputime_to_nsecs(utime + stime)",
            "100"
          ],
          "line": 839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cputime_to_nsecs",
          "args": [
            "utime + stime"
          ],
          "line": 839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_cputime_adjusted",
          "args": [
            "current",
            "&utime",
            "&stime"
          ],
          "line": 838
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic u64 current_task_runtime_100ns(void)\n{\n\tcputime_t utime, stime;\n\n\ttask_cputime_adjusted(current, &utime, &stime);\n\treturn div_u64(cputime_to_nsecs(utime + stime), 100);\n}"
  },
  {
    "function_name": "kvm_hv_set_msr_pw",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.c",
    "lines": "759-831",
    "snippet": "static int kvm_hv_set_msr_pw(struct kvm_vcpu *vcpu, u32 msr, u64 data,\n\t\t\t     bool host)\n{\n\tstruct kvm *kvm = vcpu->kvm;\n\tstruct kvm_hv *hv = &kvm->arch.hyperv;\n\n\tswitch (msr) {\n\tcase HV_X64_MSR_GUEST_OS_ID:\n\t\thv->hv_guest_os_id = data;\n\t\t/* setting guest os id to zero disables hypercall page */\n\t\tif (!hv->hv_guest_os_id)\n\t\t\thv->hv_hypercall &= ~HV_X64_MSR_HYPERCALL_ENABLE;\n\t\tbreak;\n\tcase HV_X64_MSR_HYPERCALL: {\n\t\tu64 gfn;\n\t\tunsigned long addr;\n\t\tu8 instructions[4];\n\n\t\t/* if guest os id is not set hypercall should remain disabled */\n\t\tif (!hv->hv_guest_os_id)\n\t\t\tbreak;\n\t\tif (!(data & HV_X64_MSR_HYPERCALL_ENABLE)) {\n\t\t\thv->hv_hypercall = data;\n\t\t\tbreak;\n\t\t}\n\t\tgfn = data >> HV_X64_MSR_HYPERCALL_PAGE_ADDRESS_SHIFT;\n\t\taddr = gfn_to_hva(kvm, gfn);\n\t\tif (kvm_is_error_hva(addr))\n\t\t\treturn 1;\n\t\tkvm_x86_ops->patch_hypercall(vcpu, instructions);\n\t\t((unsigned char *)instructions)[3] = 0xc3; /* ret */\n\t\tif (__copy_to_user((void __user *)addr, instructions, 4))\n\t\t\treturn 1;\n\t\thv->hv_hypercall = data;\n\t\tmark_page_dirty(kvm, gfn);\n\t\tbreak;\n\t}\n\tcase HV_X64_MSR_REFERENCE_TSC: {\n\t\tu64 gfn;\n\t\tHV_REFERENCE_TSC_PAGE tsc_ref;\n\n\t\tmemset(&tsc_ref, 0, sizeof(tsc_ref));\n\t\thv->hv_tsc_page = data;\n\t\tif (!(data & HV_X64_MSR_TSC_REFERENCE_ENABLE))\n\t\t\tbreak;\n\t\tgfn = data >> HV_X64_MSR_TSC_REFERENCE_ADDRESS_SHIFT;\n\t\tif (kvm_write_guest(\n\t\t\t\tkvm,\n\t\t\t\tgfn << HV_X64_MSR_TSC_REFERENCE_ADDRESS_SHIFT,\n\t\t\t\t&tsc_ref, sizeof(tsc_ref)))\n\t\t\treturn 1;\n\t\tmark_page_dirty(kvm, gfn);\n\t\tbreak;\n\t}\n\tcase HV_X64_MSR_CRASH_P0 ... HV_X64_MSR_CRASH_P4:\n\t\treturn kvm_hv_msr_set_crash_data(vcpu,\n\t\t\t\t\t\t msr - HV_X64_MSR_CRASH_P0,\n\t\t\t\t\t\t data);\n\tcase HV_X64_MSR_CRASH_CTL:\n\t\treturn kvm_hv_msr_set_crash_ctl(vcpu, data, host);\n\tcase HV_X64_MSR_RESET:\n\t\tif (data == 1) {\n\t\t\tvcpu_debug(vcpu, \"hyper-v reset requested\\n\");\n\t\t\tkvm_make_request(KVM_REQ_HV_RESET, vcpu);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tvcpu_unimpl(vcpu, \"Hyper-V uhandled wrmsr: 0x%x data 0x%llx\\n\",\n\t\t\t    msr, data);\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/apicdef.h>",
      "#include <linux/highmem.h>",
      "#include <linux/kvm_host.h>",
      "#include \"hyperv.h\"",
      "#include \"ioapic.h\"",
      "#include \"lapic.h\"",
      "#include \"x86.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vcpu_unimpl",
          "args": [
            "vcpu",
            "\"Hyper-V uhandled wrmsr: 0x%x data 0x%llx\\n\"",
            "msr",
            "data"
          ],
          "line": 826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_make_request",
          "args": [
            "KVM_REQ_HV_RESET",
            "vcpu"
          ],
          "line": 822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vcpu_debug",
          "args": [
            "vcpu",
            "\"hyper-v reset requested\\n\""
          ],
          "line": 821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_hv_msr_set_crash_ctl",
          "args": [
            "vcpu",
            "data",
            "host"
          ],
          "line": 818
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_hv_msr_set_crash_ctl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.c",
          "lines": "724-745",
          "snippet": "static int kvm_hv_msr_set_crash_ctl(struct kvm_vcpu *vcpu, u64 data, bool host)\n{\n\tstruct kvm_hv *hv = &vcpu->kvm->arch.hyperv;\n\n\tif (host)\n\t\thv->hv_crash_ctl = data & HV_X64_MSR_CRASH_CTL_NOTIFY;\n\n\tif (!host && (data & HV_X64_MSR_CRASH_CTL_NOTIFY)) {\n\n\t\tvcpu_debug(vcpu, \"hv crash (0x%llx 0x%llx 0x%llx 0x%llx 0x%llx)\\n\",\n\t\t\t  hv->hv_crash_param[0],\n\t\t\t  hv->hv_crash_param[1],\n\t\t\t  hv->hv_crash_param[2],\n\t\t\t  hv->hv_crash_param[3],\n\t\t\t  hv->hv_crash_param[4]);\n\n\t\t/* Send notification about crash to user space */\n\t\tkvm_make_request(KVM_REQ_HV_CRASH, vcpu);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic int kvm_hv_msr_set_crash_ctl(struct kvm_vcpu *vcpu, u64 data, bool host)\n{\n\tstruct kvm_hv *hv = &vcpu->kvm->arch.hyperv;\n\n\tif (host)\n\t\thv->hv_crash_ctl = data & HV_X64_MSR_CRASH_CTL_NOTIFY;\n\n\tif (!host && (data & HV_X64_MSR_CRASH_CTL_NOTIFY)) {\n\n\t\tvcpu_debug(vcpu, \"hv crash (0x%llx 0x%llx 0x%llx 0x%llx 0x%llx)\\n\",\n\t\t\t  hv->hv_crash_param[0],\n\t\t\t  hv->hv_crash_param[1],\n\t\t\t  hv->hv_crash_param[2],\n\t\t\t  hv->hv_crash_param[3],\n\t\t\t  hv->hv_crash_param[4]);\n\n\t\t/* Send notification about crash to user space */\n\t\tkvm_make_request(KVM_REQ_HV_CRASH, vcpu);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_hv_msr_set_crash_data",
          "args": [
            "vcpu",
            "msr - HV_X64_MSR_CRASH_P0",
            "data"
          ],
          "line": 814
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_hv_msr_set_crash_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.c",
          "lines": "747-757",
          "snippet": "static int kvm_hv_msr_set_crash_data(struct kvm_vcpu *vcpu,\n\t\t\t\t     u32 index, u64 data)\n{\n\tstruct kvm_hv *hv = &vcpu->kvm->arch.hyperv;\n\n\tif (WARN_ON_ONCE(index >= ARRAY_SIZE(hv->hv_crash_param)))\n\t\treturn -EINVAL;\n\n\thv->hv_crash_param[index] = data;\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic int kvm_hv_msr_set_crash_data(struct kvm_vcpu *vcpu,\n\t\t\t\t     u32 index, u64 data)\n{\n\tstruct kvm_hv *hv = &vcpu->kvm->arch.hyperv;\n\n\tif (WARN_ON_ONCE(index >= ARRAY_SIZE(hv->hv_crash_param)))\n\t\treturn -EINVAL;\n\n\thv->hv_crash_param[index] = data;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_page_dirty",
          "args": [
            "kvm",
            "gfn"
          ],
          "line": 810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_write_guest",
          "args": [
            "kvm",
            "gfn << HV_X64_MSR_TSC_REFERENCE_ADDRESS_SHIFT",
            "&tsc_ref",
            "sizeof(tsc_ref)"
          ],
          "line": 805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&tsc_ref",
            "0",
            "sizeof(tsc_ref)"
          ],
          "line": 800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_page_dirty",
          "args": [
            "kvm",
            "gfn"
          ],
          "line": 793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__copy_to_user",
          "args": [
            "(void __user *)addr",
            "instructions",
            "4"
          ],
          "line": 790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_x86_ops->patch_hypercall",
          "args": [
            "vcpu",
            "instructions"
          ],
          "line": 788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_is_error_hva",
          "args": [
            "addr"
          ],
          "line": 786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfn_to_hva",
          "args": [
            "kvm",
            "gfn"
          ],
          "line": 785
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic int kvm_hv_set_msr_pw(struct kvm_vcpu *vcpu, u32 msr, u64 data,\n\t\t\t     bool host)\n{\n\tstruct kvm *kvm = vcpu->kvm;\n\tstruct kvm_hv *hv = &kvm->arch.hyperv;\n\n\tswitch (msr) {\n\tcase HV_X64_MSR_GUEST_OS_ID:\n\t\thv->hv_guest_os_id = data;\n\t\t/* setting guest os id to zero disables hypercall page */\n\t\tif (!hv->hv_guest_os_id)\n\t\t\thv->hv_hypercall &= ~HV_X64_MSR_HYPERCALL_ENABLE;\n\t\tbreak;\n\tcase HV_X64_MSR_HYPERCALL: {\n\t\tu64 gfn;\n\t\tunsigned long addr;\n\t\tu8 instructions[4];\n\n\t\t/* if guest os id is not set hypercall should remain disabled */\n\t\tif (!hv->hv_guest_os_id)\n\t\t\tbreak;\n\t\tif (!(data & HV_X64_MSR_HYPERCALL_ENABLE)) {\n\t\t\thv->hv_hypercall = data;\n\t\t\tbreak;\n\t\t}\n\t\tgfn = data >> HV_X64_MSR_HYPERCALL_PAGE_ADDRESS_SHIFT;\n\t\taddr = gfn_to_hva(kvm, gfn);\n\t\tif (kvm_is_error_hva(addr))\n\t\t\treturn 1;\n\t\tkvm_x86_ops->patch_hypercall(vcpu, instructions);\n\t\t((unsigned char *)instructions)[3] = 0xc3; /* ret */\n\t\tif (__copy_to_user((void __user *)addr, instructions, 4))\n\t\t\treturn 1;\n\t\thv->hv_hypercall = data;\n\t\tmark_page_dirty(kvm, gfn);\n\t\tbreak;\n\t}\n\tcase HV_X64_MSR_REFERENCE_TSC: {\n\t\tu64 gfn;\n\t\tHV_REFERENCE_TSC_PAGE tsc_ref;\n\n\t\tmemset(&tsc_ref, 0, sizeof(tsc_ref));\n\t\thv->hv_tsc_page = data;\n\t\tif (!(data & HV_X64_MSR_TSC_REFERENCE_ENABLE))\n\t\t\tbreak;\n\t\tgfn = data >> HV_X64_MSR_TSC_REFERENCE_ADDRESS_SHIFT;\n\t\tif (kvm_write_guest(\n\t\t\t\tkvm,\n\t\t\t\tgfn << HV_X64_MSR_TSC_REFERENCE_ADDRESS_SHIFT,\n\t\t\t\t&tsc_ref, sizeof(tsc_ref)))\n\t\t\treturn 1;\n\t\tmark_page_dirty(kvm, gfn);\n\t\tbreak;\n\t}\n\tcase HV_X64_MSR_CRASH_P0 ... HV_X64_MSR_CRASH_P4:\n\t\treturn kvm_hv_msr_set_crash_data(vcpu,\n\t\t\t\t\t\t msr - HV_X64_MSR_CRASH_P0,\n\t\t\t\t\t\t data);\n\tcase HV_X64_MSR_CRASH_CTL:\n\t\treturn kvm_hv_msr_set_crash_ctl(vcpu, data, host);\n\tcase HV_X64_MSR_RESET:\n\t\tif (data == 1) {\n\t\t\tvcpu_debug(vcpu, \"hyper-v reset requested\\n\");\n\t\t\tkvm_make_request(KVM_REQ_HV_RESET, vcpu);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tvcpu_unimpl(vcpu, \"Hyper-V uhandled wrmsr: 0x%x data 0x%llx\\n\",\n\t\t\t    msr, data);\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "kvm_hv_msr_set_crash_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.c",
    "lines": "747-757",
    "snippet": "static int kvm_hv_msr_set_crash_data(struct kvm_vcpu *vcpu,\n\t\t\t\t     u32 index, u64 data)\n{\n\tstruct kvm_hv *hv = &vcpu->kvm->arch.hyperv;\n\n\tif (WARN_ON_ONCE(index >= ARRAY_SIZE(hv->hv_crash_param)))\n\t\treturn -EINVAL;\n\n\thv->hv_crash_param[index] = data;\n\treturn 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/apicdef.h>",
      "#include <linux/highmem.h>",
      "#include <linux/kvm_host.h>",
      "#include \"hyperv.h\"",
      "#include \"ioapic.h\"",
      "#include \"lapic.h\"",
      "#include \"x86.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "index >= ARRAY_SIZE(hv->hv_crash_param)"
          ],
          "line": 752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "hv->hv_crash_param"
          ],
          "line": 752
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic int kvm_hv_msr_set_crash_data(struct kvm_vcpu *vcpu,\n\t\t\t\t     u32 index, u64 data)\n{\n\tstruct kvm_hv *hv = &vcpu->kvm->arch.hyperv;\n\n\tif (WARN_ON_ONCE(index >= ARRAY_SIZE(hv->hv_crash_param)))\n\t\treturn -EINVAL;\n\n\thv->hv_crash_param[index] = data;\n\treturn 0;\n}"
  },
  {
    "function_name": "kvm_hv_msr_set_crash_ctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.c",
    "lines": "724-745",
    "snippet": "static int kvm_hv_msr_set_crash_ctl(struct kvm_vcpu *vcpu, u64 data, bool host)\n{\n\tstruct kvm_hv *hv = &vcpu->kvm->arch.hyperv;\n\n\tif (host)\n\t\thv->hv_crash_ctl = data & HV_X64_MSR_CRASH_CTL_NOTIFY;\n\n\tif (!host && (data & HV_X64_MSR_CRASH_CTL_NOTIFY)) {\n\n\t\tvcpu_debug(vcpu, \"hv crash (0x%llx 0x%llx 0x%llx 0x%llx 0x%llx)\\n\",\n\t\t\t  hv->hv_crash_param[0],\n\t\t\t  hv->hv_crash_param[1],\n\t\t\t  hv->hv_crash_param[2],\n\t\t\t  hv->hv_crash_param[3],\n\t\t\t  hv->hv_crash_param[4]);\n\n\t\t/* Send notification about crash to user space */\n\t\tkvm_make_request(KVM_REQ_HV_CRASH, vcpu);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/apicdef.h>",
      "#include <linux/highmem.h>",
      "#include <linux/kvm_host.h>",
      "#include \"hyperv.h\"",
      "#include \"ioapic.h\"",
      "#include \"lapic.h\"",
      "#include \"x86.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_make_request",
          "args": [
            "KVM_REQ_HV_CRASH",
            "vcpu"
          ],
          "line": 741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vcpu_debug",
          "args": [
            "vcpu",
            "\"hv crash (0x%llx 0x%llx 0x%llx 0x%llx 0x%llx)\\n\"",
            "hv->hv_crash_param[0]",
            "hv->hv_crash_param[1]",
            "hv->hv_crash_param[2]",
            "hv->hv_crash_param[3]",
            "hv->hv_crash_param[4]"
          ],
          "line": 733
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic int kvm_hv_msr_set_crash_ctl(struct kvm_vcpu *vcpu, u64 data, bool host)\n{\n\tstruct kvm_hv *hv = &vcpu->kvm->arch.hyperv;\n\n\tif (host)\n\t\thv->hv_crash_ctl = data & HV_X64_MSR_CRASH_CTL_NOTIFY;\n\n\tif (!host && (data & HV_X64_MSR_CRASH_CTL_NOTIFY)) {\n\n\t\tvcpu_debug(vcpu, \"hv crash (0x%llx 0x%llx 0x%llx 0x%llx 0x%llx)\\n\",\n\t\t\t  hv->hv_crash_param[0],\n\t\t\t  hv->hv_crash_param[1],\n\t\t\t  hv->hv_crash_param[2],\n\t\t\t  hv->hv_crash_param[3],\n\t\t\t  hv->hv_crash_param[4]);\n\n\t\t/* Send notification about crash to user space */\n\t\tkvm_make_request(KVM_REQ_HV_CRASH, vcpu);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "kvm_hv_msr_get_crash_ctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.c",
    "lines": "716-722",
    "snippet": "static int kvm_hv_msr_get_crash_ctl(struct kvm_vcpu *vcpu, u64 *pdata)\n{\n\tstruct kvm_hv *hv = &vcpu->kvm->arch.hyperv;\n\n\t*pdata = hv->hv_crash_ctl;\n\treturn 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/apicdef.h>",
      "#include <linux/highmem.h>",
      "#include <linux/kvm_host.h>",
      "#include \"hyperv.h\"",
      "#include \"ioapic.h\"",
      "#include \"lapic.h\"",
      "#include \"x86.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic int kvm_hv_msr_get_crash_ctl(struct kvm_vcpu *vcpu, u64 *pdata)\n{\n\tstruct kvm_hv *hv = &vcpu->kvm->arch.hyperv;\n\n\t*pdata = hv->hv_crash_ctl;\n\treturn 0;\n}"
  },
  {
    "function_name": "kvm_hv_msr_get_crash_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.c",
    "lines": "704-714",
    "snippet": "static int kvm_hv_msr_get_crash_data(struct kvm_vcpu *vcpu,\n\t\t\t\t     u32 index, u64 *pdata)\n{\n\tstruct kvm_hv *hv = &vcpu->kvm->arch.hyperv;\n\n\tif (WARN_ON_ONCE(index >= ARRAY_SIZE(hv->hv_crash_param)))\n\t\treturn -EINVAL;\n\n\t*pdata = hv->hv_crash_param[index];\n\treturn 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/apicdef.h>",
      "#include <linux/highmem.h>",
      "#include <linux/kvm_host.h>",
      "#include \"hyperv.h\"",
      "#include \"ioapic.h\"",
      "#include \"lapic.h\"",
      "#include \"x86.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "index >= ARRAY_SIZE(hv->hv_crash_param)"
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "hv->hv_crash_param"
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic int kvm_hv_msr_get_crash_data(struct kvm_vcpu *vcpu,\n\t\t\t\t     u32 index, u64 *pdata)\n{\n\tstruct kvm_hv *hv = &vcpu->kvm->arch.hyperv;\n\n\tif (WARN_ON_ONCE(index >= ARRAY_SIZE(hv->hv_crash_param)))\n\t\treturn -EINVAL;\n\n\t*pdata = hv->hv_crash_param[index];\n\treturn 0;\n}"
  },
  {
    "function_name": "kvm_hv_msr_partition_wide",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.c",
    "lines": "685-702",
    "snippet": "static bool kvm_hv_msr_partition_wide(u32 msr)\n{\n\tbool r = false;\n\n\tswitch (msr) {\n\tcase HV_X64_MSR_GUEST_OS_ID:\n\tcase HV_X64_MSR_HYPERCALL:\n\tcase HV_X64_MSR_REFERENCE_TSC:\n\tcase HV_X64_MSR_TIME_REF_COUNT:\n\tcase HV_X64_MSR_CRASH_CTL:\n\tcase HV_X64_MSR_CRASH_P0 ... HV_X64_MSR_CRASH_P4:\n\tcase HV_X64_MSR_RESET:\n\t\tr = true;\n\t\tbreak;\n\t}\n\n\treturn r;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/apicdef.h>",
      "#include <linux/highmem.h>",
      "#include <linux/kvm_host.h>",
      "#include \"hyperv.h\"",
      "#include \"ioapic.h\"",
      "#include \"lapic.h\"",
      "#include \"x86.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic bool kvm_hv_msr_partition_wide(u32 msr)\n{\n\tbool r = false;\n\n\tswitch (msr) {\n\tcase HV_X64_MSR_GUEST_OS_ID:\n\tcase HV_X64_MSR_HYPERCALL:\n\tcase HV_X64_MSR_REFERENCE_TSC:\n\tcase HV_X64_MSR_TIME_REF_COUNT:\n\tcase HV_X64_MSR_CRASH_CTL:\n\tcase HV_X64_MSR_CRASH_P0 ... HV_X64_MSR_CRASH_P4:\n\tcase HV_X64_MSR_RESET:\n\t\tr = true;\n\t\tbreak;\n\t}\n\n\treturn r;\n}"
  },
  {
    "function_name": "kvm_hv_activate_synic",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.c",
    "lines": "674-683",
    "snippet": "int kvm_hv_activate_synic(struct kvm_vcpu *vcpu)\n{\n\t/*\n\t * Hyper-V SynIC auto EOI SINT's are\n\t * not compatible with APICV, so deactivate APICV\n\t */\n\tkvm_vcpu_deactivate_apicv(vcpu);\n\tvcpu_to_synic(vcpu)->active = true;\n\treturn 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/apicdef.h>",
      "#include <linux/highmem.h>",
      "#include <linux/kvm_host.h>",
      "#include \"hyperv.h\"",
      "#include \"ioapic.h\"",
      "#include \"lapic.h\"",
      "#include \"x86.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vcpu_to_synic",
          "args": [
            "vcpu"
          ],
          "line": 681
        },
        "resolved": true,
        "details": {
          "function_name": "vcpu_to_synic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.h",
          "lines": "40-43",
          "snippet": "static inline struct kvm_vcpu_hv_synic *vcpu_to_synic(struct kvm_vcpu *vcpu)\n{\n\treturn &vcpu->arch.hyperv.synic;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct kvm_vcpu_hv_synic *vcpu_to_synic(struct kvm_vcpu *vcpu)\n{\n\treturn &vcpu->arch.hyperv.synic;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_deactivate_apicv",
          "args": [
            "vcpu"
          ],
          "line": 680
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_vcpu_deactivate_apicv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "5942-5946",
          "snippet": "void kvm_vcpu_deactivate_apicv(struct kvm_vcpu *vcpu)\n{\n\tvcpu->arch.apicv_active = false;\n\tkvm_x86_ops->refresh_apicv_exec_ctrl(vcpu);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "struct kvm_x86_ops *kvm_x86_ops"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nvoid kvm_vcpu_deactivate_apicv(struct kvm_vcpu *vcpu)\n{\n\tvcpu->arch.apicv_active = false;\n\tkvm_x86_ops->refresh_apicv_exec_ctrl(vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nint kvm_hv_activate_synic(struct kvm_vcpu *vcpu)\n{\n\t/*\n\t * Hyper-V SynIC auto EOI SINT's are\n\t * not compatible with APICV, so deactivate APICV\n\t */\n\tkvm_vcpu_deactivate_apicv(vcpu);\n\tvcpu_to_synic(vcpu)->active = true;\n\treturn 0;\n}"
  },
  {
    "function_name": "kvm_hv_vcpu_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.c",
    "lines": "662-672",
    "snippet": "void kvm_hv_vcpu_init(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_vcpu_hv *hv_vcpu = vcpu_to_hv_vcpu(vcpu);\n\tint i;\n\n\tsynic_init(&hv_vcpu->synic);\n\n\tbitmap_zero(hv_vcpu->stimer_pending_bitmap, HV_SYNIC_STIMER_COUNT);\n\tfor (i = 0; i < ARRAY_SIZE(hv_vcpu->stimer); i++)\n\t\tstimer_init(&hv_vcpu->stimer[i], i);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/apicdef.h>",
      "#include <linux/highmem.h>",
      "#include <linux/kvm_host.h>",
      "#include \"hyperv.h\"",
      "#include \"ioapic.h\"",
      "#include \"lapic.h\"",
      "#include \"x86.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "stimer_init",
          "args": [
            "&hv_vcpu->stimer[i]",
            "i"
          ],
          "line": 671
        },
        "resolved": true,
        "details": {
          "function_name": "stimer_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.c",
          "lines": "653-660",
          "snippet": "static void stimer_init(struct kvm_vcpu_hv_stimer *stimer, int timer_index)\n{\n\tmemset(stimer, 0, sizeof(*stimer));\n\tstimer->index = timer_index;\n\thrtimer_init(&stimer->timer, CLOCK_MONOTONIC, HRTIMER_MODE_ABS);\n\tstimer->timer.function = stimer_timer_callback;\n\tstimer_prepare_msg(stimer);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic void stimer_init(struct kvm_vcpu_hv_stimer *stimer, int timer_index)\n{\n\tmemset(stimer, 0, sizeof(*stimer));\n\tstimer->index = timer_index;\n\thrtimer_init(&stimer->timer, CLOCK_MONOTONIC, HRTIMER_MODE_ABS);\n\tstimer->timer.function = stimer_timer_callback;\n\tstimer_prepare_msg(stimer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "hv_vcpu->stimer"
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bitmap_zero",
          "args": [
            "hv_vcpu->stimer_pending_bitmap",
            "HV_SYNIC_STIMER_COUNT"
          ],
          "line": 669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "synic_init",
          "args": [
            "&hv_vcpu->synic"
          ],
          "line": 667
        },
        "resolved": true,
        "details": {
          "function_name": "synic_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.c",
          "lines": "375-385",
          "snippet": "static void synic_init(struct kvm_vcpu_hv_synic *synic)\n{\n\tint i;\n\n\tmemset(synic, 0, sizeof(*synic));\n\tsynic->version = HV_SYNIC_VERSION_1;\n\tfor (i = 0; i < ARRAY_SIZE(synic->sint); i++) {\n\t\tatomic64_set(&synic->sint[i], HV_SYNIC_SINT_MASKED);\n\t\tatomic_set(&synic->sint_to_gsi[i], -1);\n\t}\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic void synic_init(struct kvm_vcpu_hv_synic *synic)\n{\n\tint i;\n\n\tmemset(synic, 0, sizeof(*synic));\n\tsynic->version = HV_SYNIC_VERSION_1;\n\tfor (i = 0; i < ARRAY_SIZE(synic->sint); i++) {\n\t\tatomic64_set(&synic->sint[i], HV_SYNIC_SINT_MASKED);\n\t\tatomic_set(&synic->sint_to_gsi[i], -1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "vcpu_to_hv_vcpu",
          "args": [
            "vcpu"
          ],
          "line": 664
        },
        "resolved": true,
        "details": {
          "function_name": "vcpu_to_hv_vcpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.h",
          "lines": "27-30",
          "snippet": "static inline struct kvm_vcpu_hv *vcpu_to_hv_vcpu(struct kvm_vcpu *vcpu)\n{\n\treturn &vcpu->arch.hyperv;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct kvm_vcpu_hv *vcpu_to_hv_vcpu(struct kvm_vcpu *vcpu)\n{\n\treturn &vcpu->arch.hyperv;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nvoid kvm_hv_vcpu_init(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_vcpu_hv *hv_vcpu = vcpu_to_hv_vcpu(vcpu);\n\tint i;\n\n\tsynic_init(&hv_vcpu->synic);\n\n\tbitmap_zero(hv_vcpu->stimer_pending_bitmap, HV_SYNIC_STIMER_COUNT);\n\tfor (i = 0; i < ARRAY_SIZE(hv_vcpu->stimer); i++)\n\t\tstimer_init(&hv_vcpu->stimer[i], i);\n}"
  },
  {
    "function_name": "stimer_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.c",
    "lines": "653-660",
    "snippet": "static void stimer_init(struct kvm_vcpu_hv_stimer *stimer, int timer_index)\n{\n\tmemset(stimer, 0, sizeof(*stimer));\n\tstimer->index = timer_index;\n\thrtimer_init(&stimer->timer, CLOCK_MONOTONIC, HRTIMER_MODE_ABS);\n\tstimer->timer.function = stimer_timer_callback;\n\tstimer_prepare_msg(stimer);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/apicdef.h>",
      "#include <linux/highmem.h>",
      "#include <linux/kvm_host.h>",
      "#include \"hyperv.h\"",
      "#include \"ioapic.h\"",
      "#include \"lapic.h\"",
      "#include \"x86.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "stimer_prepare_msg",
          "args": [
            "stimer"
          ],
          "line": 659
        },
        "resolved": true,
        "details": {
          "function_name": "stimer_prepare_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.c",
          "lines": "638-651",
          "snippet": "static void stimer_prepare_msg(struct kvm_vcpu_hv_stimer *stimer)\n{\n\tstruct hv_message *msg = &stimer->msg;\n\tstruct hv_timer_message_payload *payload =\n\t\t\t(struct hv_timer_message_payload *)&msg->u.payload;\n\n\tmemset(&msg->header, 0, sizeof(msg->header));\n\tmsg->header.message_type = HVMSG_TIMER_EXPIRED;\n\tmsg->header.payload_size = sizeof(*payload);\n\n\tpayload->timer_index = stimer->index;\n\tpayload->expiration_time = 0;\n\tpayload->delivery_time = 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic void stimer_prepare_msg(struct kvm_vcpu_hv_stimer *stimer)\n{\n\tstruct hv_message *msg = &stimer->msg;\n\tstruct hv_timer_message_payload *payload =\n\t\t\t(struct hv_timer_message_payload *)&msg->u.payload;\n\n\tmemset(&msg->header, 0, sizeof(msg->header));\n\tmsg->header.message_type = HVMSG_TIMER_EXPIRED;\n\tmsg->header.payload_size = sizeof(*payload);\n\n\tpayload->timer_index = stimer->index;\n\tpayload->expiration_time = 0;\n\tpayload->delivery_time = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtimer_init",
          "args": [
            "&stimer->timer",
            "CLOCK_MONOTONIC",
            "HRTIMER_MODE_ABS"
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "stimer",
            "0",
            "sizeof(*stimer)"
          ],
          "line": 655
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic void stimer_init(struct kvm_vcpu_hv_stimer *stimer, int timer_index)\n{\n\tmemset(stimer, 0, sizeof(*stimer));\n\tstimer->index = timer_index;\n\thrtimer_init(&stimer->timer, CLOCK_MONOTONIC, HRTIMER_MODE_ABS);\n\tstimer->timer.function = stimer_timer_callback;\n\tstimer_prepare_msg(stimer);\n}"
  },
  {
    "function_name": "stimer_prepare_msg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.c",
    "lines": "638-651",
    "snippet": "static void stimer_prepare_msg(struct kvm_vcpu_hv_stimer *stimer)\n{\n\tstruct hv_message *msg = &stimer->msg;\n\tstruct hv_timer_message_payload *payload =\n\t\t\t(struct hv_timer_message_payload *)&msg->u.payload;\n\n\tmemset(&msg->header, 0, sizeof(msg->header));\n\tmsg->header.message_type = HVMSG_TIMER_EXPIRED;\n\tmsg->header.payload_size = sizeof(*payload);\n\n\tpayload->timer_index = stimer->index;\n\tpayload->expiration_time = 0;\n\tpayload->delivery_time = 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/apicdef.h>",
      "#include <linux/highmem.h>",
      "#include <linux/kvm_host.h>",
      "#include \"hyperv.h\"",
      "#include \"ioapic.h\"",
      "#include \"lapic.h\"",
      "#include \"x86.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&msg->header",
            "0",
            "sizeof(msg->header)"
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic void stimer_prepare_msg(struct kvm_vcpu_hv_stimer *stimer)\n{\n\tstruct hv_message *msg = &stimer->msg;\n\tstruct hv_timer_message_payload *payload =\n\t\t\t(struct hv_timer_message_payload *)&msg->u.payload;\n\n\tmemset(&msg->header, 0, sizeof(msg->header));\n\tmsg->header.message_type = HVMSG_TIMER_EXPIRED;\n\tmsg->header.payload_size = sizeof(*payload);\n\n\tpayload->timer_index = stimer->index;\n\tpayload->expiration_time = 0;\n\tpayload->delivery_time = 0;\n}"
  },
  {
    "function_name": "kvm_hv_vcpu_uninit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.c",
    "lines": "629-636",
    "snippet": "void kvm_hv_vcpu_uninit(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_vcpu_hv *hv_vcpu = vcpu_to_hv_vcpu(vcpu);\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(hv_vcpu->stimer); i++)\n\t\tstimer_cleanup(&hv_vcpu->stimer[i]);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/apicdef.h>",
      "#include <linux/highmem.h>",
      "#include <linux/kvm_host.h>",
      "#include \"hyperv.h\"",
      "#include \"ioapic.h\"",
      "#include \"lapic.h\"",
      "#include \"x86.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "stimer_cleanup",
          "args": [
            "&hv_vcpu->stimer[i]"
          ],
          "line": 635
        },
        "resolved": true,
        "details": {
          "function_name": "stimer_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.c",
          "lines": "404-416",
          "snippet": "static void stimer_cleanup(struct kvm_vcpu_hv_stimer *stimer)\n{\n\tstruct kvm_vcpu *vcpu = stimer_to_vcpu(stimer);\n\n\ttrace_kvm_hv_stimer_cleanup(stimer_to_vcpu(stimer)->vcpu_id,\n\t\t\t\t    stimer->index);\n\n\thrtimer_cancel(&stimer->timer);\n\tclear_bit(stimer->index,\n\t\t  vcpu_to_hv_vcpu(vcpu)->stimer_pending_bitmap);\n\tstimer->msg_pending = false;\n\tstimer->exp_time = 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic void stimer_cleanup(struct kvm_vcpu_hv_stimer *stimer)\n{\n\tstruct kvm_vcpu *vcpu = stimer_to_vcpu(stimer);\n\n\ttrace_kvm_hv_stimer_cleanup(stimer_to_vcpu(stimer)->vcpu_id,\n\t\t\t\t    stimer->index);\n\n\thrtimer_cancel(&stimer->timer);\n\tclear_bit(stimer->index,\n\t\t  vcpu_to_hv_vcpu(vcpu)->stimer_pending_bitmap);\n\tstimer->msg_pending = false;\n\tstimer->exp_time = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "hv_vcpu->stimer"
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vcpu_to_hv_vcpu",
          "args": [
            "vcpu"
          ],
          "line": 631
        },
        "resolved": true,
        "details": {
          "function_name": "vcpu_to_hv_vcpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.h",
          "lines": "27-30",
          "snippet": "static inline struct kvm_vcpu_hv *vcpu_to_hv_vcpu(struct kvm_vcpu *vcpu)\n{\n\treturn &vcpu->arch.hyperv;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct kvm_vcpu_hv *vcpu_to_hv_vcpu(struct kvm_vcpu *vcpu)\n{\n\treturn &vcpu->arch.hyperv;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nvoid kvm_hv_vcpu_uninit(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_vcpu_hv *hv_vcpu = vcpu_to_hv_vcpu(vcpu);\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(hv_vcpu->stimer); i++)\n\t\tstimer_cleanup(&hv_vcpu->stimer[i]);\n}"
  },
  {
    "function_name": "kvm_hv_process_stimers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.c",
    "lines": "600-627",
    "snippet": "void kvm_hv_process_stimers(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_vcpu_hv *hv_vcpu = vcpu_to_hv_vcpu(vcpu);\n\tstruct kvm_vcpu_hv_stimer *stimer;\n\tu64 time_now, exp_time;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(hv_vcpu->stimer); i++)\n\t\tif (test_and_clear_bit(i, hv_vcpu->stimer_pending_bitmap)) {\n\t\t\tstimer = &hv_vcpu->stimer[i];\n\t\t\tif (stimer->config & HV_STIMER_ENABLE) {\n\t\t\t\texp_time = stimer->exp_time;\n\n\t\t\t\tif (exp_time) {\n\t\t\t\t\ttime_now =\n\t\t\t\t\t\tget_time_ref_counter(vcpu->kvm);\n\t\t\t\t\tif (time_now >= exp_time)\n\t\t\t\t\t\tstimer_expiration(stimer);\n\t\t\t\t}\n\n\t\t\t\tif ((stimer->config & HV_STIMER_ENABLE) &&\n\t\t\t\t    stimer->count)\n\t\t\t\t\tstimer_start(stimer);\n\t\t\t\telse\n\t\t\t\t\tstimer_cleanup(stimer);\n\t\t\t}\n\t\t}\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/apicdef.h>",
      "#include <linux/highmem.h>",
      "#include <linux/kvm_host.h>",
      "#include \"hyperv.h\"",
      "#include \"ioapic.h\"",
      "#include \"lapic.h\"",
      "#include \"x86.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "stimer_cleanup",
          "args": [
            "stimer"
          ],
          "line": 624
        },
        "resolved": true,
        "details": {
          "function_name": "stimer_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.c",
          "lines": "404-416",
          "snippet": "static void stimer_cleanup(struct kvm_vcpu_hv_stimer *stimer)\n{\n\tstruct kvm_vcpu *vcpu = stimer_to_vcpu(stimer);\n\n\ttrace_kvm_hv_stimer_cleanup(stimer_to_vcpu(stimer)->vcpu_id,\n\t\t\t\t    stimer->index);\n\n\thrtimer_cancel(&stimer->timer);\n\tclear_bit(stimer->index,\n\t\t  vcpu_to_hv_vcpu(vcpu)->stimer_pending_bitmap);\n\tstimer->msg_pending = false;\n\tstimer->exp_time = 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic void stimer_cleanup(struct kvm_vcpu_hv_stimer *stimer)\n{\n\tstruct kvm_vcpu *vcpu = stimer_to_vcpu(stimer);\n\n\ttrace_kvm_hv_stimer_cleanup(stimer_to_vcpu(stimer)->vcpu_id,\n\t\t\t\t    stimer->index);\n\n\thrtimer_cancel(&stimer->timer);\n\tclear_bit(stimer->index,\n\t\t  vcpu_to_hv_vcpu(vcpu)->stimer_pending_bitmap);\n\tstimer->msg_pending = false;\n\tstimer->exp_time = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "stimer_start",
          "args": [
            "stimer"
          ],
          "line": 622
        },
        "resolved": true,
        "details": {
          "function_name": "stimer_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.c",
          "lines": "435-487",
          "snippet": "static int stimer_start(struct kvm_vcpu_hv_stimer *stimer)\n{\n\tu64 time_now;\n\tktime_t ktime_now;\n\n\ttime_now = get_time_ref_counter(stimer_to_vcpu(stimer)->kvm);\n\tktime_now = ktime_get();\n\n\tif (stimer->config & HV_STIMER_PERIODIC) {\n\t\tif (stimer->exp_time) {\n\t\t\tif (time_now >= stimer->exp_time) {\n\t\t\t\tu64 remainder;\n\n\t\t\t\tdiv64_u64_rem(time_now - stimer->exp_time,\n\t\t\t\t\t      stimer->count, &remainder);\n\t\t\t\tstimer->exp_time =\n\t\t\t\t\ttime_now + (stimer->count - remainder);\n\t\t\t}\n\t\t} else\n\t\t\tstimer->exp_time = time_now + stimer->count;\n\n\t\ttrace_kvm_hv_stimer_start_periodic(\n\t\t\t\t\tstimer_to_vcpu(stimer)->vcpu_id,\n\t\t\t\t\tstimer->index,\n\t\t\t\t\ttime_now, stimer->exp_time);\n\n\t\thrtimer_start(&stimer->timer,\n\t\t\t      ktime_add_ns(ktime_now,\n\t\t\t\t\t   100 * (stimer->exp_time - time_now)),\n\t\t\t      HRTIMER_MODE_ABS);\n\t\treturn 0;\n\t}\n\tstimer->exp_time = stimer->count;\n\tif (time_now >= stimer->count) {\n\t\t/*\n\t\t * Expire timer according to Hypervisor Top-Level Functional\n\t\t * specification v4(15.3.1):\n\t\t * \"If a one shot is enabled and the specified count is in\n\t\t * the past, it will expire immediately.\"\n\t\t */\n\t\tstimer_mark_pending(stimer, false);\n\t\treturn 0;\n\t}\n\n\ttrace_kvm_hv_stimer_start_one_shot(stimer_to_vcpu(stimer)->vcpu_id,\n\t\t\t\t\t   stimer->index,\n\t\t\t\t\t   time_now, stimer->count);\n\n\thrtimer_start(&stimer->timer,\n\t\t      ktime_add_ns(ktime_now, 100 * (stimer->count - time_now)),\n\t\t      HRTIMER_MODE_ABS);\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic int stimer_start(struct kvm_vcpu_hv_stimer *stimer)\n{\n\tu64 time_now;\n\tktime_t ktime_now;\n\n\ttime_now = get_time_ref_counter(stimer_to_vcpu(stimer)->kvm);\n\tktime_now = ktime_get();\n\n\tif (stimer->config & HV_STIMER_PERIODIC) {\n\t\tif (stimer->exp_time) {\n\t\t\tif (time_now >= stimer->exp_time) {\n\t\t\t\tu64 remainder;\n\n\t\t\t\tdiv64_u64_rem(time_now - stimer->exp_time,\n\t\t\t\t\t      stimer->count, &remainder);\n\t\t\t\tstimer->exp_time =\n\t\t\t\t\ttime_now + (stimer->count - remainder);\n\t\t\t}\n\t\t} else\n\t\t\tstimer->exp_time = time_now + stimer->count;\n\n\t\ttrace_kvm_hv_stimer_start_periodic(\n\t\t\t\t\tstimer_to_vcpu(stimer)->vcpu_id,\n\t\t\t\t\tstimer->index,\n\t\t\t\t\ttime_now, stimer->exp_time);\n\n\t\thrtimer_start(&stimer->timer,\n\t\t\t      ktime_add_ns(ktime_now,\n\t\t\t\t\t   100 * (stimer->exp_time - time_now)),\n\t\t\t      HRTIMER_MODE_ABS);\n\t\treturn 0;\n\t}\n\tstimer->exp_time = stimer->count;\n\tif (time_now >= stimer->count) {\n\t\t/*\n\t\t * Expire timer according to Hypervisor Top-Level Functional\n\t\t * specification v4(15.3.1):\n\t\t * \"If a one shot is enabled and the specified count is in\n\t\t * the past, it will expire immediately.\"\n\t\t */\n\t\tstimer_mark_pending(stimer, false);\n\t\treturn 0;\n\t}\n\n\ttrace_kvm_hv_stimer_start_one_shot(stimer_to_vcpu(stimer)->vcpu_id,\n\t\t\t\t\t   stimer->index,\n\t\t\t\t\t   time_now, stimer->count);\n\n\thrtimer_start(&stimer->timer,\n\t\t      ktime_add_ns(ktime_now, 100 * (stimer->count - time_now)),\n\t\t      HRTIMER_MODE_ABS);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "stimer_expiration",
          "args": [
            "stimer"
          ],
          "line": 617
        },
        "resolved": true,
        "details": {
          "function_name": "stimer_expiration",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.c",
          "lines": "585-598",
          "snippet": "static void stimer_expiration(struct kvm_vcpu_hv_stimer *stimer)\n{\n\tint r;\n\n\tstimer->msg_pending = true;\n\tr = stimer_send_msg(stimer);\n\ttrace_kvm_hv_stimer_expiration(stimer_to_vcpu(stimer)->vcpu_id,\n\t\t\t\t       stimer->index, r);\n\tif (!r) {\n\t\tstimer->msg_pending = false;\n\t\tif (!(stimer->config & HV_STIMER_PERIODIC))\n\t\t\tstimer->config &= ~HV_STIMER_ENABLE;\n\t}\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic void stimer_expiration(struct kvm_vcpu_hv_stimer *stimer)\n{\n\tint r;\n\n\tstimer->msg_pending = true;\n\tr = stimer_send_msg(stimer);\n\ttrace_kvm_hv_stimer_expiration(stimer_to_vcpu(stimer)->vcpu_id,\n\t\t\t\t       stimer->index, r);\n\tif (!r) {\n\t\tstimer->msg_pending = false;\n\t\tif (!(stimer->config & HV_STIMER_PERIODIC))\n\t\t\tstimer->config &= ~HV_STIMER_ENABLE;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_time_ref_counter",
          "args": [
            "vcpu->kvm"
          ],
          "line": 615
        },
        "resolved": true,
        "details": {
          "function_name": "get_time_ref_counter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.c",
          "lines": "387-390",
          "snippet": "static u64 get_time_ref_counter(struct kvm *kvm)\n{\n\treturn div_u64(get_kernel_ns() + kvm->arch.kvmclock_offset, 100);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic u64 get_time_ref_counter(struct kvm *kvm)\n{\n\treturn div_u64(get_kernel_ns() + kvm->arch.kvmclock_offset, 100);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_and_clear_bit",
          "args": [
            "i",
            "hv_vcpu->stimer_pending_bitmap"
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "hv_vcpu->stimer"
          ],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vcpu_to_hv_vcpu",
          "args": [
            "vcpu"
          ],
          "line": 602
        },
        "resolved": true,
        "details": {
          "function_name": "vcpu_to_hv_vcpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.h",
          "lines": "27-30",
          "snippet": "static inline struct kvm_vcpu_hv *vcpu_to_hv_vcpu(struct kvm_vcpu *vcpu)\n{\n\treturn &vcpu->arch.hyperv;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct kvm_vcpu_hv *vcpu_to_hv_vcpu(struct kvm_vcpu *vcpu)\n{\n\treturn &vcpu->arch.hyperv;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nvoid kvm_hv_process_stimers(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_vcpu_hv *hv_vcpu = vcpu_to_hv_vcpu(vcpu);\n\tstruct kvm_vcpu_hv_stimer *stimer;\n\tu64 time_now, exp_time;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(hv_vcpu->stimer); i++)\n\t\tif (test_and_clear_bit(i, hv_vcpu->stimer_pending_bitmap)) {\n\t\t\tstimer = &hv_vcpu->stimer[i];\n\t\t\tif (stimer->config & HV_STIMER_ENABLE) {\n\t\t\t\texp_time = stimer->exp_time;\n\n\t\t\t\tif (exp_time) {\n\t\t\t\t\ttime_now =\n\t\t\t\t\t\tget_time_ref_counter(vcpu->kvm);\n\t\t\t\t\tif (time_now >= exp_time)\n\t\t\t\t\t\tstimer_expiration(stimer);\n\t\t\t\t}\n\n\t\t\t\tif ((stimer->config & HV_STIMER_ENABLE) &&\n\t\t\t\t    stimer->count)\n\t\t\t\t\tstimer_start(stimer);\n\t\t\t\telse\n\t\t\t\t\tstimer_cleanup(stimer);\n\t\t\t}\n\t\t}\n}"
  },
  {
    "function_name": "stimer_expiration",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.c",
    "lines": "585-598",
    "snippet": "static void stimer_expiration(struct kvm_vcpu_hv_stimer *stimer)\n{\n\tint r;\n\n\tstimer->msg_pending = true;\n\tr = stimer_send_msg(stimer);\n\ttrace_kvm_hv_stimer_expiration(stimer_to_vcpu(stimer)->vcpu_id,\n\t\t\t\t       stimer->index, r);\n\tif (!r) {\n\t\tstimer->msg_pending = false;\n\t\tif (!(stimer->config & HV_STIMER_PERIODIC))\n\t\t\tstimer->config &= ~HV_STIMER_ENABLE;\n\t}\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/apicdef.h>",
      "#include <linux/highmem.h>",
      "#include <linux/kvm_host.h>",
      "#include \"hyperv.h\"",
      "#include \"ioapic.h\"",
      "#include \"lapic.h\"",
      "#include \"x86.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_kvm_hv_stimer_expiration",
          "args": [
            "stimer_to_vcpu(stimer)->vcpu_id",
            "stimer->index",
            "r"
          ],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stimer_to_vcpu",
          "args": [
            "stimer"
          ],
          "line": 591
        },
        "resolved": true,
        "details": {
          "function_name": "stimer_to_vcpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.h",
          "lines": "70-77",
          "snippet": "static inline struct kvm_vcpu *stimer_to_vcpu(struct kvm_vcpu_hv_stimer *stimer)\n{\n\tstruct kvm_vcpu_hv *hv_vcpu;\n\n\thv_vcpu = container_of(stimer - stimer->index, struct kvm_vcpu_hv,\n\t\t\t       stimer[0]);\n\treturn hv_vcpu_to_vcpu(hv_vcpu);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct kvm_vcpu *stimer_to_vcpu(struct kvm_vcpu_hv_stimer *stimer)\n{\n\tstruct kvm_vcpu_hv *hv_vcpu;\n\n\thv_vcpu = container_of(stimer - stimer->index, struct kvm_vcpu_hv,\n\t\t\t       stimer[0]);\n\treturn hv_vcpu_to_vcpu(hv_vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "stimer_send_msg",
          "args": [
            "stimer"
          ],
          "line": 590
        },
        "resolved": true,
        "details": {
          "function_name": "stimer_send_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.c",
          "lines": "572-583",
          "snippet": "static int stimer_send_msg(struct kvm_vcpu_hv_stimer *stimer)\n{\n\tstruct kvm_vcpu *vcpu = stimer_to_vcpu(stimer);\n\tstruct hv_message *msg = &stimer->msg;\n\tstruct hv_timer_message_payload *payload =\n\t\t\t(struct hv_timer_message_payload *)&msg->u.payload;\n\n\tpayload->expiration_time = stimer->exp_time;\n\tpayload->delivery_time = get_time_ref_counter(vcpu->kvm);\n\treturn synic_deliver_msg(vcpu_to_synic(vcpu),\n\t\t\t\t HV_STIMER_SINT(stimer->config), msg);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic int stimer_send_msg(struct kvm_vcpu_hv_stimer *stimer)\n{\n\tstruct kvm_vcpu *vcpu = stimer_to_vcpu(stimer);\n\tstruct hv_message *msg = &stimer->msg;\n\tstruct hv_timer_message_payload *payload =\n\t\t\t(struct hv_timer_message_payload *)&msg->u.payload;\n\n\tpayload->expiration_time = stimer->exp_time;\n\tpayload->delivery_time = get_time_ref_counter(vcpu->kvm);\n\treturn synic_deliver_msg(vcpu_to_synic(vcpu),\n\t\t\t\t HV_STIMER_SINT(stimer->config), msg);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic void stimer_expiration(struct kvm_vcpu_hv_stimer *stimer)\n{\n\tint r;\n\n\tstimer->msg_pending = true;\n\tr = stimer_send_msg(stimer);\n\ttrace_kvm_hv_stimer_expiration(stimer_to_vcpu(stimer)->vcpu_id,\n\t\t\t\t       stimer->index, r);\n\tif (!r) {\n\t\tstimer->msg_pending = false;\n\t\tif (!(stimer->config & HV_STIMER_PERIODIC))\n\t\t\tstimer->config &= ~HV_STIMER_ENABLE;\n\t}\n}"
  },
  {
    "function_name": "stimer_send_msg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.c",
    "lines": "572-583",
    "snippet": "static int stimer_send_msg(struct kvm_vcpu_hv_stimer *stimer)\n{\n\tstruct kvm_vcpu *vcpu = stimer_to_vcpu(stimer);\n\tstruct hv_message *msg = &stimer->msg;\n\tstruct hv_timer_message_payload *payload =\n\t\t\t(struct hv_timer_message_payload *)&msg->u.payload;\n\n\tpayload->expiration_time = stimer->exp_time;\n\tpayload->delivery_time = get_time_ref_counter(vcpu->kvm);\n\treturn synic_deliver_msg(vcpu_to_synic(vcpu),\n\t\t\t\t HV_STIMER_SINT(stimer->config), msg);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/apicdef.h>",
      "#include <linux/highmem.h>",
      "#include <linux/kvm_host.h>",
      "#include \"hyperv.h\"",
      "#include \"ioapic.h\"",
      "#include \"lapic.h\"",
      "#include \"x86.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "synic_deliver_msg",
          "args": [
            "vcpu_to_synic(vcpu)",
            "HV_STIMER_SINT(stimer->config)",
            "msg"
          ],
          "line": 581
        },
        "resolved": true,
        "details": {
          "function_name": "synic_deliver_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.c",
          "lines": "531-570",
          "snippet": "static int synic_deliver_msg(struct kvm_vcpu_hv_synic *synic, u32 sint,\n\t\t\t     struct hv_message *src_msg)\n{\n\tstruct kvm_vcpu *vcpu = synic_to_vcpu(synic);\n\tstruct page *page;\n\tgpa_t gpa;\n\tstruct hv_message *dst_msg;\n\tint r;\n\tstruct hv_message_page *msg_page;\n\n\tif (!(synic->msg_page & HV_SYNIC_SIMP_ENABLE))\n\t\treturn -ENOENT;\n\n\tgpa = synic->msg_page & PAGE_MASK;\n\tpage = kvm_vcpu_gfn_to_page(vcpu, gpa >> PAGE_SHIFT);\n\tif (is_error_page(page))\n\t\treturn -EFAULT;\n\n\tmsg_page = kmap_atomic(page);\n\tdst_msg = &msg_page->sint_message[sint];\n\tif (sync_cmpxchg(&dst_msg->header.message_type, HVMSG_NONE,\n\t\t\t src_msg->header.message_type) != HVMSG_NONE) {\n\t\tdst_msg->header.message_flags.msg_pending = 1;\n\t\tr = -EAGAIN;\n\t} else {\n\t\tmemcpy(&dst_msg->u.payload, &src_msg->u.payload,\n\t\t       src_msg->header.payload_size);\n\t\tdst_msg->header.message_type = src_msg->header.message_type;\n\t\tdst_msg->header.payload_size = src_msg->header.payload_size;\n\t\tr = synic_set_irq(synic, sint);\n\t\tif (r >= 1)\n\t\t\tr = 0;\n\t\telse if (r == 0)\n\t\t\tr = -EFAULT;\n\t}\n\tkunmap_atomic(msg_page);\n\tkvm_release_page_dirty(page);\n\tkvm_vcpu_mark_page_dirty(vcpu, gpa >> PAGE_SHIFT);\n\treturn r;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic int synic_deliver_msg(struct kvm_vcpu_hv_synic *synic, u32 sint,\n\t\t\t     struct hv_message *src_msg)\n{\n\tstruct kvm_vcpu *vcpu = synic_to_vcpu(synic);\n\tstruct page *page;\n\tgpa_t gpa;\n\tstruct hv_message *dst_msg;\n\tint r;\n\tstruct hv_message_page *msg_page;\n\n\tif (!(synic->msg_page & HV_SYNIC_SIMP_ENABLE))\n\t\treturn -ENOENT;\n\n\tgpa = synic->msg_page & PAGE_MASK;\n\tpage = kvm_vcpu_gfn_to_page(vcpu, gpa >> PAGE_SHIFT);\n\tif (is_error_page(page))\n\t\treturn -EFAULT;\n\n\tmsg_page = kmap_atomic(page);\n\tdst_msg = &msg_page->sint_message[sint];\n\tif (sync_cmpxchg(&dst_msg->header.message_type, HVMSG_NONE,\n\t\t\t src_msg->header.message_type) != HVMSG_NONE) {\n\t\tdst_msg->header.message_flags.msg_pending = 1;\n\t\tr = -EAGAIN;\n\t} else {\n\t\tmemcpy(&dst_msg->u.payload, &src_msg->u.payload,\n\t\t       src_msg->header.payload_size);\n\t\tdst_msg->header.message_type = src_msg->header.message_type;\n\t\tdst_msg->header.payload_size = src_msg->header.payload_size;\n\t\tr = synic_set_irq(synic, sint);\n\t\tif (r >= 1)\n\t\t\tr = 0;\n\t\telse if (r == 0)\n\t\t\tr = -EFAULT;\n\t}\n\tkunmap_atomic(msg_page);\n\tkvm_release_page_dirty(page);\n\tkvm_vcpu_mark_page_dirty(vcpu, gpa >> PAGE_SHIFT);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HV_STIMER_SINT",
          "args": [
            "stimer->config"
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vcpu_to_synic",
          "args": [
            "vcpu"
          ],
          "line": 581
        },
        "resolved": true,
        "details": {
          "function_name": "vcpu_to_synic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.h",
          "lines": "40-43",
          "snippet": "static inline struct kvm_vcpu_hv_synic *vcpu_to_synic(struct kvm_vcpu *vcpu)\n{\n\treturn &vcpu->arch.hyperv.synic;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct kvm_vcpu_hv_synic *vcpu_to_synic(struct kvm_vcpu *vcpu)\n{\n\treturn &vcpu->arch.hyperv.synic;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_time_ref_counter",
          "args": [
            "vcpu->kvm"
          ],
          "line": 580
        },
        "resolved": true,
        "details": {
          "function_name": "get_time_ref_counter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.c",
          "lines": "387-390",
          "snippet": "static u64 get_time_ref_counter(struct kvm *kvm)\n{\n\treturn div_u64(get_kernel_ns() + kvm->arch.kvmclock_offset, 100);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic u64 get_time_ref_counter(struct kvm *kvm)\n{\n\treturn div_u64(get_kernel_ns() + kvm->arch.kvmclock_offset, 100);\n}"
        }
      },
      {
        "call_info": {
          "callee": "stimer_to_vcpu",
          "args": [
            "stimer"
          ],
          "line": 574
        },
        "resolved": true,
        "details": {
          "function_name": "stimer_to_vcpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.h",
          "lines": "70-77",
          "snippet": "static inline struct kvm_vcpu *stimer_to_vcpu(struct kvm_vcpu_hv_stimer *stimer)\n{\n\tstruct kvm_vcpu_hv *hv_vcpu;\n\n\thv_vcpu = container_of(stimer - stimer->index, struct kvm_vcpu_hv,\n\t\t\t       stimer[0]);\n\treturn hv_vcpu_to_vcpu(hv_vcpu);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct kvm_vcpu *stimer_to_vcpu(struct kvm_vcpu_hv_stimer *stimer)\n{\n\tstruct kvm_vcpu_hv *hv_vcpu;\n\n\thv_vcpu = container_of(stimer - stimer->index, struct kvm_vcpu_hv,\n\t\t\t       stimer[0]);\n\treturn hv_vcpu_to_vcpu(hv_vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic int stimer_send_msg(struct kvm_vcpu_hv_stimer *stimer)\n{\n\tstruct kvm_vcpu *vcpu = stimer_to_vcpu(stimer);\n\tstruct hv_message *msg = &stimer->msg;\n\tstruct hv_timer_message_payload *payload =\n\t\t\t(struct hv_timer_message_payload *)&msg->u.payload;\n\n\tpayload->expiration_time = stimer->exp_time;\n\tpayload->delivery_time = get_time_ref_counter(vcpu->kvm);\n\treturn synic_deliver_msg(vcpu_to_synic(vcpu),\n\t\t\t\t HV_STIMER_SINT(stimer->config), msg);\n}"
  },
  {
    "function_name": "synic_deliver_msg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.c",
    "lines": "531-570",
    "snippet": "static int synic_deliver_msg(struct kvm_vcpu_hv_synic *synic, u32 sint,\n\t\t\t     struct hv_message *src_msg)\n{\n\tstruct kvm_vcpu *vcpu = synic_to_vcpu(synic);\n\tstruct page *page;\n\tgpa_t gpa;\n\tstruct hv_message *dst_msg;\n\tint r;\n\tstruct hv_message_page *msg_page;\n\n\tif (!(synic->msg_page & HV_SYNIC_SIMP_ENABLE))\n\t\treturn -ENOENT;\n\n\tgpa = synic->msg_page & PAGE_MASK;\n\tpage = kvm_vcpu_gfn_to_page(vcpu, gpa >> PAGE_SHIFT);\n\tif (is_error_page(page))\n\t\treturn -EFAULT;\n\n\tmsg_page = kmap_atomic(page);\n\tdst_msg = &msg_page->sint_message[sint];\n\tif (sync_cmpxchg(&dst_msg->header.message_type, HVMSG_NONE,\n\t\t\t src_msg->header.message_type) != HVMSG_NONE) {\n\t\tdst_msg->header.message_flags.msg_pending = 1;\n\t\tr = -EAGAIN;\n\t} else {\n\t\tmemcpy(&dst_msg->u.payload, &src_msg->u.payload,\n\t\t       src_msg->header.payload_size);\n\t\tdst_msg->header.message_type = src_msg->header.message_type;\n\t\tdst_msg->header.payload_size = src_msg->header.payload_size;\n\t\tr = synic_set_irq(synic, sint);\n\t\tif (r >= 1)\n\t\t\tr = 0;\n\t\telse if (r == 0)\n\t\t\tr = -EFAULT;\n\t}\n\tkunmap_atomic(msg_page);\n\tkvm_release_page_dirty(page);\n\tkvm_vcpu_mark_page_dirty(vcpu, gpa >> PAGE_SHIFT);\n\treturn r;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/apicdef.h>",
      "#include <linux/highmem.h>",
      "#include <linux/kvm_host.h>",
      "#include \"hyperv.h\"",
      "#include \"ioapic.h\"",
      "#include \"lapic.h\"",
      "#include \"x86.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_vcpu_mark_page_dirty",
          "args": [
            "vcpu",
            "gpa >> PAGE_SHIFT"
          ],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_release_page_dirty",
          "args": [
            "page"
          ],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "msg_page"
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "synic_set_irq",
          "args": [
            "synic",
            "sint"
          ],
          "line": 560
        },
        "resolved": true,
        "details": {
          "function_name": "synic_set_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.c",
          "lines": "294-317",
          "snippet": "int synic_set_irq(struct kvm_vcpu_hv_synic *synic, u32 sint)\n{\n\tstruct kvm_vcpu *vcpu = synic_to_vcpu(synic);\n\tstruct kvm_lapic_irq irq;\n\tint ret, vector;\n\n\tif (sint >= ARRAY_SIZE(synic->sint))\n\t\treturn -EINVAL;\n\n\tvector = synic_get_sint_vector(synic_read_sint(synic, sint));\n\tif (vector < 0)\n\t\treturn -ENOENT;\n\n\tmemset(&irq, 0, sizeof(irq));\n\tirq.dest_id = kvm_apic_id(vcpu->arch.apic);\n\tirq.dest_mode = APIC_DEST_PHYSICAL;\n\tirq.delivery_mode = APIC_DM_FIXED;\n\tirq.vector = vector;\n\tirq.level = 1;\n\n\tret = kvm_irq_delivery_to_apic(vcpu->kvm, NULL, &irq, NULL);\n\ttrace_kvm_hv_synic_set_irq(vcpu->vcpu_id, sint, irq.vector, ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nint synic_set_irq(struct kvm_vcpu_hv_synic *synic, u32 sint)\n{\n\tstruct kvm_vcpu *vcpu = synic_to_vcpu(synic);\n\tstruct kvm_lapic_irq irq;\n\tint ret, vector;\n\n\tif (sint >= ARRAY_SIZE(synic->sint))\n\t\treturn -EINVAL;\n\n\tvector = synic_get_sint_vector(synic_read_sint(synic, sint));\n\tif (vector < 0)\n\t\treturn -ENOENT;\n\n\tmemset(&irq, 0, sizeof(irq));\n\tirq.dest_id = kvm_apic_id(vcpu->arch.apic);\n\tirq.dest_mode = APIC_DEST_PHYSICAL;\n\tirq.delivery_mode = APIC_DM_FIXED;\n\tirq.vector = vector;\n\tirq.level = 1;\n\n\tret = kvm_irq_delivery_to_apic(vcpu->kvm, NULL, &irq, NULL);\n\ttrace_kvm_hv_synic_set_irq(vcpu->vcpu_id, sint, irq.vector, ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&dst_msg->u.payload",
            "&src_msg->u.payload",
            "src_msg->header.payload_size"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sync_cmpxchg",
          "args": [
            "&dst_msg->header.message_type",
            "HVMSG_NONE",
            "src_msg->header.message_type"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "page"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_error_page",
          "args": [
            "page"
          ],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_gfn_to_page",
          "args": [
            "vcpu",
            "gpa >> PAGE_SHIFT"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "synic_to_vcpu",
          "args": [
            "synic"
          ],
          "line": 534
        },
        "resolved": true,
        "details": {
          "function_name": "synic_to_vcpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.h",
          "lines": "45-48",
          "snippet": "static inline struct kvm_vcpu *synic_to_vcpu(struct kvm_vcpu_hv_synic *synic)\n{\n\treturn hv_vcpu_to_vcpu(container_of(synic, struct kvm_vcpu_hv, synic));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct kvm_vcpu *synic_to_vcpu(struct kvm_vcpu_hv_synic *synic)\n{\n\treturn hv_vcpu_to_vcpu(container_of(synic, struct kvm_vcpu_hv, synic));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic int synic_deliver_msg(struct kvm_vcpu_hv_synic *synic, u32 sint,\n\t\t\t     struct hv_message *src_msg)\n{\n\tstruct kvm_vcpu *vcpu = synic_to_vcpu(synic);\n\tstruct page *page;\n\tgpa_t gpa;\n\tstruct hv_message *dst_msg;\n\tint r;\n\tstruct hv_message_page *msg_page;\n\n\tif (!(synic->msg_page & HV_SYNIC_SIMP_ENABLE))\n\t\treturn -ENOENT;\n\n\tgpa = synic->msg_page & PAGE_MASK;\n\tpage = kvm_vcpu_gfn_to_page(vcpu, gpa >> PAGE_SHIFT);\n\tif (is_error_page(page))\n\t\treturn -EFAULT;\n\n\tmsg_page = kmap_atomic(page);\n\tdst_msg = &msg_page->sint_message[sint];\n\tif (sync_cmpxchg(&dst_msg->header.message_type, HVMSG_NONE,\n\t\t\t src_msg->header.message_type) != HVMSG_NONE) {\n\t\tdst_msg->header.message_flags.msg_pending = 1;\n\t\tr = -EAGAIN;\n\t} else {\n\t\tmemcpy(&dst_msg->u.payload, &src_msg->u.payload,\n\t\t       src_msg->header.payload_size);\n\t\tdst_msg->header.message_type = src_msg->header.message_type;\n\t\tdst_msg->header.payload_size = src_msg->header.payload_size;\n\t\tr = synic_set_irq(synic, sint);\n\t\tif (r >= 1)\n\t\t\tr = 0;\n\t\telse if (r == 0)\n\t\t\tr = -EFAULT;\n\t}\n\tkunmap_atomic(msg_page);\n\tkvm_release_page_dirty(page);\n\tkvm_vcpu_mark_page_dirty(vcpu, gpa >> PAGE_SHIFT);\n\treturn r;\n}"
  },
  {
    "function_name": "stimer_get_count",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.c",
    "lines": "525-529",
    "snippet": "static int stimer_get_count(struct kvm_vcpu_hv_stimer *stimer, u64 *pcount)\n{\n\t*pcount = stimer->count;\n\treturn 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/apicdef.h>",
      "#include <linux/highmem.h>",
      "#include <linux/kvm_host.h>",
      "#include \"hyperv.h\"",
      "#include \"ioapic.h\"",
      "#include \"lapic.h\"",
      "#include \"x86.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic int stimer_get_count(struct kvm_vcpu_hv_stimer *stimer, u64 *pcount)\n{\n\t*pcount = stimer->count;\n\treturn 0;\n}"
  },
  {
    "function_name": "stimer_get_config",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.c",
    "lines": "519-523",
    "snippet": "static int stimer_get_config(struct kvm_vcpu_hv_stimer *stimer, u64 *pconfig)\n{\n\t*pconfig = stimer->config;\n\treturn 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/apicdef.h>",
      "#include <linux/highmem.h>",
      "#include <linux/kvm_host.h>",
      "#include \"hyperv.h\"",
      "#include \"ioapic.h\"",
      "#include \"lapic.h\"",
      "#include \"x86.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic int stimer_get_config(struct kvm_vcpu_hv_stimer *stimer, u64 *pconfig)\n{\n\t*pconfig = stimer->config;\n\treturn 0;\n}"
  },
  {
    "function_name": "stimer_set_count",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.c",
    "lines": "503-517",
    "snippet": "static int stimer_set_count(struct kvm_vcpu_hv_stimer *stimer, u64 count,\n\t\t\t    bool host)\n{\n\ttrace_kvm_hv_stimer_set_count(stimer_to_vcpu(stimer)->vcpu_id,\n\t\t\t\t      stimer->index, count, host);\n\n\tstimer_cleanup(stimer);\n\tstimer->count = count;\n\tif (stimer->count == 0)\n\t\tstimer->config &= ~HV_STIMER_ENABLE;\n\telse if (stimer->config & HV_STIMER_AUTOENABLE)\n\t\tstimer->config |= HV_STIMER_ENABLE;\n\tstimer_mark_pending(stimer, false);\n\treturn 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/apicdef.h>",
      "#include <linux/highmem.h>",
      "#include <linux/kvm_host.h>",
      "#include \"hyperv.h\"",
      "#include \"ioapic.h\"",
      "#include \"lapic.h\"",
      "#include \"x86.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "stimer_mark_pending",
          "args": [
            "stimer",
            "false"
          ],
          "line": 515
        },
        "resolved": true,
        "details": {
          "function_name": "stimer_mark_pending",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.c",
          "lines": "392-402",
          "snippet": "static void stimer_mark_pending(struct kvm_vcpu_hv_stimer *stimer,\n\t\t\t\tbool vcpu_kick)\n{\n\tstruct kvm_vcpu *vcpu = stimer_to_vcpu(stimer);\n\n\tset_bit(stimer->index,\n\t\tvcpu_to_hv_vcpu(vcpu)->stimer_pending_bitmap);\n\tkvm_make_request(KVM_REQ_HV_STIMER, vcpu);\n\tif (vcpu_kick)\n\t\tkvm_vcpu_kick(vcpu);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic void stimer_mark_pending(struct kvm_vcpu_hv_stimer *stimer,\n\t\t\t\tbool vcpu_kick)\n{\n\tstruct kvm_vcpu *vcpu = stimer_to_vcpu(stimer);\n\n\tset_bit(stimer->index,\n\t\tvcpu_to_hv_vcpu(vcpu)->stimer_pending_bitmap);\n\tkvm_make_request(KVM_REQ_HV_STIMER, vcpu);\n\tif (vcpu_kick)\n\t\tkvm_vcpu_kick(vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "stimer_cleanup",
          "args": [
            "stimer"
          ],
          "line": 509
        },
        "resolved": true,
        "details": {
          "function_name": "stimer_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.c",
          "lines": "404-416",
          "snippet": "static void stimer_cleanup(struct kvm_vcpu_hv_stimer *stimer)\n{\n\tstruct kvm_vcpu *vcpu = stimer_to_vcpu(stimer);\n\n\ttrace_kvm_hv_stimer_cleanup(stimer_to_vcpu(stimer)->vcpu_id,\n\t\t\t\t    stimer->index);\n\n\thrtimer_cancel(&stimer->timer);\n\tclear_bit(stimer->index,\n\t\t  vcpu_to_hv_vcpu(vcpu)->stimer_pending_bitmap);\n\tstimer->msg_pending = false;\n\tstimer->exp_time = 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic void stimer_cleanup(struct kvm_vcpu_hv_stimer *stimer)\n{\n\tstruct kvm_vcpu *vcpu = stimer_to_vcpu(stimer);\n\n\ttrace_kvm_hv_stimer_cleanup(stimer_to_vcpu(stimer)->vcpu_id,\n\t\t\t\t    stimer->index);\n\n\thrtimer_cancel(&stimer->timer);\n\tclear_bit(stimer->index,\n\t\t  vcpu_to_hv_vcpu(vcpu)->stimer_pending_bitmap);\n\tstimer->msg_pending = false;\n\tstimer->exp_time = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_kvm_hv_stimer_set_count",
          "args": [
            "stimer_to_vcpu(stimer)->vcpu_id",
            "stimer->index",
            "count",
            "host"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stimer_to_vcpu",
          "args": [
            "stimer"
          ],
          "line": 506
        },
        "resolved": true,
        "details": {
          "function_name": "stimer_to_vcpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.h",
          "lines": "70-77",
          "snippet": "static inline struct kvm_vcpu *stimer_to_vcpu(struct kvm_vcpu_hv_stimer *stimer)\n{\n\tstruct kvm_vcpu_hv *hv_vcpu;\n\n\thv_vcpu = container_of(stimer - stimer->index, struct kvm_vcpu_hv,\n\t\t\t       stimer[0]);\n\treturn hv_vcpu_to_vcpu(hv_vcpu);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct kvm_vcpu *stimer_to_vcpu(struct kvm_vcpu_hv_stimer *stimer)\n{\n\tstruct kvm_vcpu_hv *hv_vcpu;\n\n\thv_vcpu = container_of(stimer - stimer->index, struct kvm_vcpu_hv,\n\t\t\t       stimer[0]);\n\treturn hv_vcpu_to_vcpu(hv_vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic int stimer_set_count(struct kvm_vcpu_hv_stimer *stimer, u64 count,\n\t\t\t    bool host)\n{\n\ttrace_kvm_hv_stimer_set_count(stimer_to_vcpu(stimer)->vcpu_id,\n\t\t\t\t      stimer->index, count, host);\n\n\tstimer_cleanup(stimer);\n\tstimer->count = count;\n\tif (stimer->count == 0)\n\t\tstimer->config &= ~HV_STIMER_ENABLE;\n\telse if (stimer->config & HV_STIMER_AUTOENABLE)\n\t\tstimer->config |= HV_STIMER_ENABLE;\n\tstimer_mark_pending(stimer, false);\n\treturn 0;\n}"
  },
  {
    "function_name": "stimer_set_config",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.c",
    "lines": "489-501",
    "snippet": "static int stimer_set_config(struct kvm_vcpu_hv_stimer *stimer, u64 config,\n\t\t\t     bool host)\n{\n\ttrace_kvm_hv_stimer_set_config(stimer_to_vcpu(stimer)->vcpu_id,\n\t\t\t\t       stimer->index, config, host);\n\n\tstimer_cleanup(stimer);\n\tif ((stimer->config & HV_STIMER_ENABLE) && HV_STIMER_SINT(config) == 0)\n\t\tconfig &= ~HV_STIMER_ENABLE;\n\tstimer->config = config;\n\tstimer_mark_pending(stimer, false);\n\treturn 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/apicdef.h>",
      "#include <linux/highmem.h>",
      "#include <linux/kvm_host.h>",
      "#include \"hyperv.h\"",
      "#include \"ioapic.h\"",
      "#include \"lapic.h\"",
      "#include \"x86.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "stimer_mark_pending",
          "args": [
            "stimer",
            "false"
          ],
          "line": 499
        },
        "resolved": true,
        "details": {
          "function_name": "stimer_mark_pending",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.c",
          "lines": "392-402",
          "snippet": "static void stimer_mark_pending(struct kvm_vcpu_hv_stimer *stimer,\n\t\t\t\tbool vcpu_kick)\n{\n\tstruct kvm_vcpu *vcpu = stimer_to_vcpu(stimer);\n\n\tset_bit(stimer->index,\n\t\tvcpu_to_hv_vcpu(vcpu)->stimer_pending_bitmap);\n\tkvm_make_request(KVM_REQ_HV_STIMER, vcpu);\n\tif (vcpu_kick)\n\t\tkvm_vcpu_kick(vcpu);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic void stimer_mark_pending(struct kvm_vcpu_hv_stimer *stimer,\n\t\t\t\tbool vcpu_kick)\n{\n\tstruct kvm_vcpu *vcpu = stimer_to_vcpu(stimer);\n\n\tset_bit(stimer->index,\n\t\tvcpu_to_hv_vcpu(vcpu)->stimer_pending_bitmap);\n\tkvm_make_request(KVM_REQ_HV_STIMER, vcpu);\n\tif (vcpu_kick)\n\t\tkvm_vcpu_kick(vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "HV_STIMER_SINT",
          "args": [
            "config"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stimer_cleanup",
          "args": [
            "stimer"
          ],
          "line": 495
        },
        "resolved": true,
        "details": {
          "function_name": "stimer_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.c",
          "lines": "404-416",
          "snippet": "static void stimer_cleanup(struct kvm_vcpu_hv_stimer *stimer)\n{\n\tstruct kvm_vcpu *vcpu = stimer_to_vcpu(stimer);\n\n\ttrace_kvm_hv_stimer_cleanup(stimer_to_vcpu(stimer)->vcpu_id,\n\t\t\t\t    stimer->index);\n\n\thrtimer_cancel(&stimer->timer);\n\tclear_bit(stimer->index,\n\t\t  vcpu_to_hv_vcpu(vcpu)->stimer_pending_bitmap);\n\tstimer->msg_pending = false;\n\tstimer->exp_time = 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic void stimer_cleanup(struct kvm_vcpu_hv_stimer *stimer)\n{\n\tstruct kvm_vcpu *vcpu = stimer_to_vcpu(stimer);\n\n\ttrace_kvm_hv_stimer_cleanup(stimer_to_vcpu(stimer)->vcpu_id,\n\t\t\t\t    stimer->index);\n\n\thrtimer_cancel(&stimer->timer);\n\tclear_bit(stimer->index,\n\t\t  vcpu_to_hv_vcpu(vcpu)->stimer_pending_bitmap);\n\tstimer->msg_pending = false;\n\tstimer->exp_time = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_kvm_hv_stimer_set_config",
          "args": [
            "stimer_to_vcpu(stimer)->vcpu_id",
            "stimer->index",
            "config",
            "host"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stimer_to_vcpu",
          "args": [
            "stimer"
          ],
          "line": 492
        },
        "resolved": true,
        "details": {
          "function_name": "stimer_to_vcpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.h",
          "lines": "70-77",
          "snippet": "static inline struct kvm_vcpu *stimer_to_vcpu(struct kvm_vcpu_hv_stimer *stimer)\n{\n\tstruct kvm_vcpu_hv *hv_vcpu;\n\n\thv_vcpu = container_of(stimer - stimer->index, struct kvm_vcpu_hv,\n\t\t\t       stimer[0]);\n\treturn hv_vcpu_to_vcpu(hv_vcpu);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct kvm_vcpu *stimer_to_vcpu(struct kvm_vcpu_hv_stimer *stimer)\n{\n\tstruct kvm_vcpu_hv *hv_vcpu;\n\n\thv_vcpu = container_of(stimer - stimer->index, struct kvm_vcpu_hv,\n\t\t\t       stimer[0]);\n\treturn hv_vcpu_to_vcpu(hv_vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic int stimer_set_config(struct kvm_vcpu_hv_stimer *stimer, u64 config,\n\t\t\t     bool host)\n{\n\ttrace_kvm_hv_stimer_set_config(stimer_to_vcpu(stimer)->vcpu_id,\n\t\t\t\t       stimer->index, config, host);\n\n\tstimer_cleanup(stimer);\n\tif ((stimer->config & HV_STIMER_ENABLE) && HV_STIMER_SINT(config) == 0)\n\t\tconfig &= ~HV_STIMER_ENABLE;\n\tstimer->config = config;\n\tstimer_mark_pending(stimer, false);\n\treturn 0;\n}"
  },
  {
    "function_name": "stimer_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.c",
    "lines": "435-487",
    "snippet": "static int stimer_start(struct kvm_vcpu_hv_stimer *stimer)\n{\n\tu64 time_now;\n\tktime_t ktime_now;\n\n\ttime_now = get_time_ref_counter(stimer_to_vcpu(stimer)->kvm);\n\tktime_now = ktime_get();\n\n\tif (stimer->config & HV_STIMER_PERIODIC) {\n\t\tif (stimer->exp_time) {\n\t\t\tif (time_now >= stimer->exp_time) {\n\t\t\t\tu64 remainder;\n\n\t\t\t\tdiv64_u64_rem(time_now - stimer->exp_time,\n\t\t\t\t\t      stimer->count, &remainder);\n\t\t\t\tstimer->exp_time =\n\t\t\t\t\ttime_now + (stimer->count - remainder);\n\t\t\t}\n\t\t} else\n\t\t\tstimer->exp_time = time_now + stimer->count;\n\n\t\ttrace_kvm_hv_stimer_start_periodic(\n\t\t\t\t\tstimer_to_vcpu(stimer)->vcpu_id,\n\t\t\t\t\tstimer->index,\n\t\t\t\t\ttime_now, stimer->exp_time);\n\n\t\thrtimer_start(&stimer->timer,\n\t\t\t      ktime_add_ns(ktime_now,\n\t\t\t\t\t   100 * (stimer->exp_time - time_now)),\n\t\t\t      HRTIMER_MODE_ABS);\n\t\treturn 0;\n\t}\n\tstimer->exp_time = stimer->count;\n\tif (time_now >= stimer->count) {\n\t\t/*\n\t\t * Expire timer according to Hypervisor Top-Level Functional\n\t\t * specification v4(15.3.1):\n\t\t * \"If a one shot is enabled and the specified count is in\n\t\t * the past, it will expire immediately.\"\n\t\t */\n\t\tstimer_mark_pending(stimer, false);\n\t\treturn 0;\n\t}\n\n\ttrace_kvm_hv_stimer_start_one_shot(stimer_to_vcpu(stimer)->vcpu_id,\n\t\t\t\t\t   stimer->index,\n\t\t\t\t\t   time_now, stimer->count);\n\n\thrtimer_start(&stimer->timer,\n\t\t      ktime_add_ns(ktime_now, 100 * (stimer->count - time_now)),\n\t\t      HRTIMER_MODE_ABS);\n\treturn 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/apicdef.h>",
      "#include <linux/highmem.h>",
      "#include <linux/kvm_host.h>",
      "#include \"hyperv.h\"",
      "#include \"ioapic.h\"",
      "#include \"lapic.h\"",
      "#include \"x86.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hrtimer_start",
          "args": [
            "&stimer->timer",
            "ktime_add_ns(ktime_now, 100 * (stimer->count - time_now))",
            "HRTIMER_MODE_ABS"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_add_ns",
          "args": [
            "ktime_now",
            "100 * (stimer->count - time_now)"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_kvm_hv_stimer_start_one_shot",
          "args": [
            "stimer_to_vcpu(stimer)->vcpu_id",
            "stimer->index",
            "time_now",
            "stimer->count"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stimer_to_vcpu",
          "args": [
            "stimer"
          ],
          "line": 479
        },
        "resolved": true,
        "details": {
          "function_name": "stimer_to_vcpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.h",
          "lines": "70-77",
          "snippet": "static inline struct kvm_vcpu *stimer_to_vcpu(struct kvm_vcpu_hv_stimer *stimer)\n{\n\tstruct kvm_vcpu_hv *hv_vcpu;\n\n\thv_vcpu = container_of(stimer - stimer->index, struct kvm_vcpu_hv,\n\t\t\t       stimer[0]);\n\treturn hv_vcpu_to_vcpu(hv_vcpu);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct kvm_vcpu *stimer_to_vcpu(struct kvm_vcpu_hv_stimer *stimer)\n{\n\tstruct kvm_vcpu_hv *hv_vcpu;\n\n\thv_vcpu = container_of(stimer - stimer->index, struct kvm_vcpu_hv,\n\t\t\t       stimer[0]);\n\treturn hv_vcpu_to_vcpu(hv_vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "stimer_mark_pending",
          "args": [
            "stimer",
            "false"
          ],
          "line": 475
        },
        "resolved": true,
        "details": {
          "function_name": "stimer_mark_pending",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.c",
          "lines": "392-402",
          "snippet": "static void stimer_mark_pending(struct kvm_vcpu_hv_stimer *stimer,\n\t\t\t\tbool vcpu_kick)\n{\n\tstruct kvm_vcpu *vcpu = stimer_to_vcpu(stimer);\n\n\tset_bit(stimer->index,\n\t\tvcpu_to_hv_vcpu(vcpu)->stimer_pending_bitmap);\n\tkvm_make_request(KVM_REQ_HV_STIMER, vcpu);\n\tif (vcpu_kick)\n\t\tkvm_vcpu_kick(vcpu);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic void stimer_mark_pending(struct kvm_vcpu_hv_stimer *stimer,\n\t\t\t\tbool vcpu_kick)\n{\n\tstruct kvm_vcpu *vcpu = stimer_to_vcpu(stimer);\n\n\tset_bit(stimer->index,\n\t\tvcpu_to_hv_vcpu(vcpu)->stimer_pending_bitmap);\n\tkvm_make_request(KVM_REQ_HV_STIMER, vcpu);\n\tif (vcpu_kick)\n\t\tkvm_vcpu_kick(vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtimer_start",
          "args": [
            "&stimer->timer",
            "ktime_add_ns(ktime_now,\n\t\t\t\t\t   100 * (stimer->exp_time - time_now))",
            "HRTIMER_MODE_ABS"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_add_ns",
          "args": [
            "ktime_now",
            "100 * (stimer->exp_time - time_now)"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_kvm_hv_stimer_start_periodic",
          "args": [
            "stimer_to_vcpu(stimer)->vcpu_id",
            "stimer->index",
            "time_now",
            "stimer->exp_time"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "div64_u64_rem",
          "args": [
            "time_now - stimer->exp_time",
            "stimer->count",
            "&remainder"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_get",
          "args": [],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_time_ref_counter",
          "args": [
            "stimer_to_vcpu(stimer)->kvm"
          ],
          "line": 440
        },
        "resolved": true,
        "details": {
          "function_name": "get_time_ref_counter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.c",
          "lines": "387-390",
          "snippet": "static u64 get_time_ref_counter(struct kvm *kvm)\n{\n\treturn div_u64(get_kernel_ns() + kvm->arch.kvmclock_offset, 100);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic u64 get_time_ref_counter(struct kvm *kvm)\n{\n\treturn div_u64(get_kernel_ns() + kvm->arch.kvmclock_offset, 100);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic int stimer_start(struct kvm_vcpu_hv_stimer *stimer)\n{\n\tu64 time_now;\n\tktime_t ktime_now;\n\n\ttime_now = get_time_ref_counter(stimer_to_vcpu(stimer)->kvm);\n\tktime_now = ktime_get();\n\n\tif (stimer->config & HV_STIMER_PERIODIC) {\n\t\tif (stimer->exp_time) {\n\t\t\tif (time_now >= stimer->exp_time) {\n\t\t\t\tu64 remainder;\n\n\t\t\t\tdiv64_u64_rem(time_now - stimer->exp_time,\n\t\t\t\t\t      stimer->count, &remainder);\n\t\t\t\tstimer->exp_time =\n\t\t\t\t\ttime_now + (stimer->count - remainder);\n\t\t\t}\n\t\t} else\n\t\t\tstimer->exp_time = time_now + stimer->count;\n\n\t\ttrace_kvm_hv_stimer_start_periodic(\n\t\t\t\t\tstimer_to_vcpu(stimer)->vcpu_id,\n\t\t\t\t\tstimer->index,\n\t\t\t\t\ttime_now, stimer->exp_time);\n\n\t\thrtimer_start(&stimer->timer,\n\t\t\t      ktime_add_ns(ktime_now,\n\t\t\t\t\t   100 * (stimer->exp_time - time_now)),\n\t\t\t      HRTIMER_MODE_ABS);\n\t\treturn 0;\n\t}\n\tstimer->exp_time = stimer->count;\n\tif (time_now >= stimer->count) {\n\t\t/*\n\t\t * Expire timer according to Hypervisor Top-Level Functional\n\t\t * specification v4(15.3.1):\n\t\t * \"If a one shot is enabled and the specified count is in\n\t\t * the past, it will expire immediately.\"\n\t\t */\n\t\tstimer_mark_pending(stimer, false);\n\t\treturn 0;\n\t}\n\n\ttrace_kvm_hv_stimer_start_one_shot(stimer_to_vcpu(stimer)->vcpu_id,\n\t\t\t\t\t   stimer->index,\n\t\t\t\t\t   time_now, stimer->count);\n\n\thrtimer_start(&stimer->timer,\n\t\t      ktime_add_ns(ktime_now, 100 * (stimer->count - time_now)),\n\t\t      HRTIMER_MODE_ABS);\n\treturn 0;\n}"
  },
  {
    "function_name": "stimer_timer_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.c",
    "lines": "418-428",
    "snippet": "static enum hrtimer_restart stimer_timer_callback(struct hrtimer *timer)\n{\n\tstruct kvm_vcpu_hv_stimer *stimer;\n\n\tstimer = container_of(timer, struct kvm_vcpu_hv_stimer, timer);\n\ttrace_kvm_hv_stimer_callback(stimer_to_vcpu(stimer)->vcpu_id,\n\t\t\t\t     stimer->index);\n\tstimer_mark_pending(stimer, true);\n\n\treturn HRTIMER_NORESTART;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/apicdef.h>",
      "#include <linux/highmem.h>",
      "#include <linux/kvm_host.h>",
      "#include \"hyperv.h\"",
      "#include \"ioapic.h\"",
      "#include \"lapic.h\"",
      "#include \"x86.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "stimer_mark_pending",
          "args": [
            "stimer",
            "true"
          ],
          "line": 425
        },
        "resolved": true,
        "details": {
          "function_name": "stimer_mark_pending",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.c",
          "lines": "392-402",
          "snippet": "static void stimer_mark_pending(struct kvm_vcpu_hv_stimer *stimer,\n\t\t\t\tbool vcpu_kick)\n{\n\tstruct kvm_vcpu *vcpu = stimer_to_vcpu(stimer);\n\n\tset_bit(stimer->index,\n\t\tvcpu_to_hv_vcpu(vcpu)->stimer_pending_bitmap);\n\tkvm_make_request(KVM_REQ_HV_STIMER, vcpu);\n\tif (vcpu_kick)\n\t\tkvm_vcpu_kick(vcpu);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic void stimer_mark_pending(struct kvm_vcpu_hv_stimer *stimer,\n\t\t\t\tbool vcpu_kick)\n{\n\tstruct kvm_vcpu *vcpu = stimer_to_vcpu(stimer);\n\n\tset_bit(stimer->index,\n\t\tvcpu_to_hv_vcpu(vcpu)->stimer_pending_bitmap);\n\tkvm_make_request(KVM_REQ_HV_STIMER, vcpu);\n\tif (vcpu_kick)\n\t\tkvm_vcpu_kick(vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_kvm_hv_stimer_callback",
          "args": [
            "stimer_to_vcpu(stimer)->vcpu_id",
            "stimer->index"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stimer_to_vcpu",
          "args": [
            "stimer"
          ],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "stimer_to_vcpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.h",
          "lines": "70-77",
          "snippet": "static inline struct kvm_vcpu *stimer_to_vcpu(struct kvm_vcpu_hv_stimer *stimer)\n{\n\tstruct kvm_vcpu_hv *hv_vcpu;\n\n\thv_vcpu = container_of(stimer - stimer->index, struct kvm_vcpu_hv,\n\t\t\t       stimer[0]);\n\treturn hv_vcpu_to_vcpu(hv_vcpu);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct kvm_vcpu *stimer_to_vcpu(struct kvm_vcpu_hv_stimer *stimer)\n{\n\tstruct kvm_vcpu_hv *hv_vcpu;\n\n\thv_vcpu = container_of(stimer - stimer->index, struct kvm_vcpu_hv,\n\t\t\t       stimer[0]);\n\treturn hv_vcpu_to_vcpu(hv_vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "timer",
            "structkvm_vcpu_hv_stimer",
            "timer"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic enum hrtimer_restart stimer_timer_callback(struct hrtimer *timer)\n{\n\tstruct kvm_vcpu_hv_stimer *stimer;\n\n\tstimer = container_of(timer, struct kvm_vcpu_hv_stimer, timer);\n\ttrace_kvm_hv_stimer_callback(stimer_to_vcpu(stimer)->vcpu_id,\n\t\t\t\t     stimer->index);\n\tstimer_mark_pending(stimer, true);\n\n\treturn HRTIMER_NORESTART;\n}"
  },
  {
    "function_name": "stimer_cleanup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.c",
    "lines": "404-416",
    "snippet": "static void stimer_cleanup(struct kvm_vcpu_hv_stimer *stimer)\n{\n\tstruct kvm_vcpu *vcpu = stimer_to_vcpu(stimer);\n\n\ttrace_kvm_hv_stimer_cleanup(stimer_to_vcpu(stimer)->vcpu_id,\n\t\t\t\t    stimer->index);\n\n\thrtimer_cancel(&stimer->timer);\n\tclear_bit(stimer->index,\n\t\t  vcpu_to_hv_vcpu(vcpu)->stimer_pending_bitmap);\n\tstimer->msg_pending = false;\n\tstimer->exp_time = 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/apicdef.h>",
      "#include <linux/highmem.h>",
      "#include <linux/kvm_host.h>",
      "#include \"hyperv.h\"",
      "#include \"ioapic.h\"",
      "#include \"lapic.h\"",
      "#include \"x86.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "stimer->index",
            "vcpu_to_hv_vcpu(vcpu)->stimer_pending_bitmap"
          ],
          "line": 412
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_clear_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/vmx.c",
          "lines": "1592-1597",
          "snippet": "static __always_inline void vmcs_clear_bits(unsigned long field, u32 mask)\n{\n        BUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x2000,\n\t\t\t \"vmcs_clear_bits does not support 64-bit fields\");\n\t__vmcs_writel(field, __vmcs_readl(field) & ~mask);\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"trace.h\"",
            "#include <asm/irq_remapping.h>",
            "#include <asm/apic.h>",
            "#include <asm/kexec.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/mce.h>",
            "#include <asm/virtext.h>",
            "#include <asm/vmx.h>",
            "#include <asm/desc.h>",
            "#include <asm/io.h>",
            "#include <asm/cpu.h>",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/hrtimer.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include \"lapic.h\"",
            "#include \"cpuid.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"trace.h\"\n#include <asm/irq_remapping.h>\n#include <asm/apic.h>\n#include <asm/kexec.h>\n#include <asm/debugreg.h>\n#include <asm/perf_event.h>\n#include <asm/fpu/internal.h>\n#include <asm/mce.h>\n#include <asm/virtext.h>\n#include <asm/vmx.h>\n#include <asm/desc.h>\n#include <asm/io.h>\n#include <asm/cpu.h>\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/hrtimer.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic __always_inline void vmcs_clear_bits(unsigned long field, u32 mask)\n{\n        BUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x2000,\n\t\t\t \"vmcs_clear_bits does not support 64-bit fields\");\n\t__vmcs_writel(field, __vmcs_readl(field) & ~mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vcpu_to_hv_vcpu",
          "args": [
            "vcpu"
          ],
          "line": 413
        },
        "resolved": true,
        "details": {
          "function_name": "vcpu_to_hv_vcpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.h",
          "lines": "27-30",
          "snippet": "static inline struct kvm_vcpu_hv *vcpu_to_hv_vcpu(struct kvm_vcpu *vcpu)\n{\n\treturn &vcpu->arch.hyperv;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct kvm_vcpu_hv *vcpu_to_hv_vcpu(struct kvm_vcpu *vcpu)\n{\n\treturn &vcpu->arch.hyperv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtimer_cancel",
          "args": [
            "&stimer->timer"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_kvm_hv_stimer_cleanup",
          "args": [
            "stimer_to_vcpu(stimer)->vcpu_id",
            "stimer->index"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stimer_to_vcpu",
          "args": [
            "stimer"
          ],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "stimer_to_vcpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.h",
          "lines": "70-77",
          "snippet": "static inline struct kvm_vcpu *stimer_to_vcpu(struct kvm_vcpu_hv_stimer *stimer)\n{\n\tstruct kvm_vcpu_hv *hv_vcpu;\n\n\thv_vcpu = container_of(stimer - stimer->index, struct kvm_vcpu_hv,\n\t\t\t       stimer[0]);\n\treturn hv_vcpu_to_vcpu(hv_vcpu);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct kvm_vcpu *stimer_to_vcpu(struct kvm_vcpu_hv_stimer *stimer)\n{\n\tstruct kvm_vcpu_hv *hv_vcpu;\n\n\thv_vcpu = container_of(stimer - stimer->index, struct kvm_vcpu_hv,\n\t\t\t       stimer[0]);\n\treturn hv_vcpu_to_vcpu(hv_vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic void stimer_cleanup(struct kvm_vcpu_hv_stimer *stimer)\n{\n\tstruct kvm_vcpu *vcpu = stimer_to_vcpu(stimer);\n\n\ttrace_kvm_hv_stimer_cleanup(stimer_to_vcpu(stimer)->vcpu_id,\n\t\t\t\t    stimer->index);\n\n\thrtimer_cancel(&stimer->timer);\n\tclear_bit(stimer->index,\n\t\t  vcpu_to_hv_vcpu(vcpu)->stimer_pending_bitmap);\n\tstimer->msg_pending = false;\n\tstimer->exp_time = 0;\n}"
  },
  {
    "function_name": "stimer_mark_pending",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.c",
    "lines": "392-402",
    "snippet": "static void stimer_mark_pending(struct kvm_vcpu_hv_stimer *stimer,\n\t\t\t\tbool vcpu_kick)\n{\n\tstruct kvm_vcpu *vcpu = stimer_to_vcpu(stimer);\n\n\tset_bit(stimer->index,\n\t\tvcpu_to_hv_vcpu(vcpu)->stimer_pending_bitmap);\n\tkvm_make_request(KVM_REQ_HV_STIMER, vcpu);\n\tif (vcpu_kick)\n\t\tkvm_vcpu_kick(vcpu);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/apicdef.h>",
      "#include <linux/highmem.h>",
      "#include <linux/kvm_host.h>",
      "#include \"hyperv.h\"",
      "#include \"ioapic.h\"",
      "#include \"lapic.h\"",
      "#include \"x86.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_vcpu_kick",
          "args": [
            "vcpu"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_make_request",
          "args": [
            "KVM_REQ_HV_STIMER",
            "vcpu"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "stimer->index",
            "vcpu_to_hv_vcpu(vcpu)->stimer_pending_bitmap"
          ],
          "line": 397
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_set_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/vmx.c",
          "lines": "1599-1604",
          "snippet": "static __always_inline void vmcs_set_bits(unsigned long field, u32 mask)\n{\n        BUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x2000,\n\t\t\t \"vmcs_set_bits does not support 64-bit fields\");\n\t__vmcs_writel(field, __vmcs_readl(field) | mask);\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"trace.h\"",
            "#include <asm/irq_remapping.h>",
            "#include <asm/apic.h>",
            "#include <asm/kexec.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/mce.h>",
            "#include <asm/virtext.h>",
            "#include <asm/vmx.h>",
            "#include <asm/desc.h>",
            "#include <asm/io.h>",
            "#include <asm/cpu.h>",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/hrtimer.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include \"lapic.h\"",
            "#include \"cpuid.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"trace.h\"\n#include <asm/irq_remapping.h>\n#include <asm/apic.h>\n#include <asm/kexec.h>\n#include <asm/debugreg.h>\n#include <asm/perf_event.h>\n#include <asm/fpu/internal.h>\n#include <asm/mce.h>\n#include <asm/virtext.h>\n#include <asm/vmx.h>\n#include <asm/desc.h>\n#include <asm/io.h>\n#include <asm/cpu.h>\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/hrtimer.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic __always_inline void vmcs_set_bits(unsigned long field, u32 mask)\n{\n        BUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x2000,\n\t\t\t \"vmcs_set_bits does not support 64-bit fields\");\n\t__vmcs_writel(field, __vmcs_readl(field) | mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vcpu_to_hv_vcpu",
          "args": [
            "vcpu"
          ],
          "line": 398
        },
        "resolved": true,
        "details": {
          "function_name": "vcpu_to_hv_vcpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.h",
          "lines": "27-30",
          "snippet": "static inline struct kvm_vcpu_hv *vcpu_to_hv_vcpu(struct kvm_vcpu *vcpu)\n{\n\treturn &vcpu->arch.hyperv;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct kvm_vcpu_hv *vcpu_to_hv_vcpu(struct kvm_vcpu *vcpu)\n{\n\treturn &vcpu->arch.hyperv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "stimer_to_vcpu",
          "args": [
            "stimer"
          ],
          "line": 395
        },
        "resolved": true,
        "details": {
          "function_name": "stimer_to_vcpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.h",
          "lines": "70-77",
          "snippet": "static inline struct kvm_vcpu *stimer_to_vcpu(struct kvm_vcpu_hv_stimer *stimer)\n{\n\tstruct kvm_vcpu_hv *hv_vcpu;\n\n\thv_vcpu = container_of(stimer - stimer->index, struct kvm_vcpu_hv,\n\t\t\t       stimer[0]);\n\treturn hv_vcpu_to_vcpu(hv_vcpu);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct kvm_vcpu *stimer_to_vcpu(struct kvm_vcpu_hv_stimer *stimer)\n{\n\tstruct kvm_vcpu_hv *hv_vcpu;\n\n\thv_vcpu = container_of(stimer - stimer->index, struct kvm_vcpu_hv,\n\t\t\t       stimer[0]);\n\treturn hv_vcpu_to_vcpu(hv_vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic void stimer_mark_pending(struct kvm_vcpu_hv_stimer *stimer,\n\t\t\t\tbool vcpu_kick)\n{\n\tstruct kvm_vcpu *vcpu = stimer_to_vcpu(stimer);\n\n\tset_bit(stimer->index,\n\t\tvcpu_to_hv_vcpu(vcpu)->stimer_pending_bitmap);\n\tkvm_make_request(KVM_REQ_HV_STIMER, vcpu);\n\tif (vcpu_kick)\n\t\tkvm_vcpu_kick(vcpu);\n}"
  },
  {
    "function_name": "get_time_ref_counter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.c",
    "lines": "387-390",
    "snippet": "static u64 get_time_ref_counter(struct kvm *kvm)\n{\n\treturn div_u64(get_kernel_ns() + kvm->arch.kvmclock_offset, 100);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/apicdef.h>",
      "#include <linux/highmem.h>",
      "#include <linux/kvm_host.h>",
      "#include \"hyperv.h\"",
      "#include \"ioapic.h\"",
      "#include \"lapic.h\"",
      "#include \"x86.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "div_u64",
          "args": [
            "get_kernel_ns() + kvm->arch.kvmclock_offset",
            "100"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_kernel_ns",
          "args": [],
          "line": 389
        },
        "resolved": true,
        "details": {
          "function_name": "get_kernel_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.h",
          "lines": "150-153",
          "snippet": "static inline u64 get_kernel_ns(void)\n{\n\treturn ktime_get_boot_ns();\n}",
          "includes": [
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline u64 get_kernel_ns(void)\n{\n\treturn ktime_get_boot_ns();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic u64 get_time_ref_counter(struct kvm *kvm)\n{\n\treturn div_u64(get_kernel_ns() + kvm->arch.kvmclock_offset, 100);\n}"
  },
  {
    "function_name": "synic_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.c",
    "lines": "375-385",
    "snippet": "static void synic_init(struct kvm_vcpu_hv_synic *synic)\n{\n\tint i;\n\n\tmemset(synic, 0, sizeof(*synic));\n\tsynic->version = HV_SYNIC_VERSION_1;\n\tfor (i = 0; i < ARRAY_SIZE(synic->sint); i++) {\n\t\tatomic64_set(&synic->sint[i], HV_SYNIC_SINT_MASKED);\n\t\tatomic_set(&synic->sint_to_gsi[i], -1);\n\t}\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/apicdef.h>",
      "#include <linux/highmem.h>",
      "#include <linux/kvm_host.h>",
      "#include \"hyperv.h\"",
      "#include \"ioapic.h\"",
      "#include \"lapic.h\"",
      "#include \"x86.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&synic->sint_to_gsi[i]",
            "-1"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic64_set",
          "args": [
            "&synic->sint[i]",
            "HV_SYNIC_SINT_MASKED"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "synic->sint"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "synic",
            "0",
            "sizeof(*synic)"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic void synic_init(struct kvm_vcpu_hv_synic *synic)\n{\n\tint i;\n\n\tmemset(synic, 0, sizeof(*synic));\n\tsynic->version = HV_SYNIC_VERSION_1;\n\tfor (i = 0; i < ARRAY_SIZE(synic->sint); i++) {\n\t\tatomic64_set(&synic->sint[i], HV_SYNIC_SINT_MASKED);\n\t\tatomic_set(&synic->sint_to_gsi[i], -1);\n\t}\n}"
  },
  {
    "function_name": "kvm_hv_irq_routing_update",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.c",
    "lines": "357-373",
    "snippet": "void kvm_hv_irq_routing_update(struct kvm *kvm)\n{\n\tstruct kvm_irq_routing_table *irq_rt;\n\tstruct kvm_kernel_irq_routing_entry *e;\n\tu32 gsi;\n\n\tirq_rt = srcu_dereference_check(kvm->irq_routing, &kvm->irq_srcu,\n\t\t\t\t\tlockdep_is_held(&kvm->irq_lock));\n\n\tfor (gsi = 0; gsi < irq_rt->nr_rt_entries; gsi++) {\n\t\thlist_for_each_entry(e, &irq_rt->map[gsi], link) {\n\t\t\tif (e->type == KVM_IRQ_ROUTING_HV_SINT)\n\t\t\t\tkvm_hv_set_sint_gsi(kvm, e->hv_sint.vcpu,\n\t\t\t\t\t\t    e->hv_sint.sint, gsi);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/apicdef.h>",
      "#include <linux/highmem.h>",
      "#include <linux/kvm_host.h>",
      "#include \"hyperv.h\"",
      "#include \"ioapic.h\"",
      "#include \"lapic.h\"",
      "#include \"x86.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_hv_set_sint_gsi",
          "args": [
            "kvm",
            "e->hv_sint.vcpu",
            "e->hv_sint.sint",
            "gsi"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_hv_set_sint_gsi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.c",
          "lines": "342-355",
          "snippet": "static int kvm_hv_set_sint_gsi(struct kvm *kvm, u32 vcpu_id, u32 sint, int gsi)\n{\n\tstruct kvm_vcpu_hv_synic *synic;\n\n\tsynic = synic_get(kvm, vcpu_id);\n\tif (!synic)\n\t\treturn -EINVAL;\n\n\tif (sint >= ARRAY_SIZE(synic->sint_to_gsi))\n\t\treturn -EINVAL;\n\n\tatomic_set(&synic->sint_to_gsi[sint], gsi);\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic int kvm_hv_set_sint_gsi(struct kvm *kvm, u32 vcpu_id, u32 sint, int gsi)\n{\n\tstruct kvm_vcpu_hv_synic *synic;\n\n\tsynic = synic_get(kvm, vcpu_id);\n\tif (!synic)\n\t\treturn -EINVAL;\n\n\tif (sint >= ARRAY_SIZE(synic->sint_to_gsi))\n\t\treturn -EINVAL;\n\n\tatomic_set(&synic->sint_to_gsi[sint], gsi);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry",
          "args": [
            "e",
            "&irq_rt->map[gsi]",
            "link"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "srcu_dereference_check",
          "args": [
            "kvm->irq_routing",
            "&kvm->irq_srcu",
            "lockdep_is_held(&kvm->irq_lock)"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_is_held",
          "args": [
            "&kvm->irq_lock"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nvoid kvm_hv_irq_routing_update(struct kvm *kvm)\n{\n\tstruct kvm_irq_routing_table *irq_rt;\n\tstruct kvm_kernel_irq_routing_entry *e;\n\tu32 gsi;\n\n\tirq_rt = srcu_dereference_check(kvm->irq_routing, &kvm->irq_srcu,\n\t\t\t\t\tlockdep_is_held(&kvm->irq_lock));\n\n\tfor (gsi = 0; gsi < irq_rt->nr_rt_entries; gsi++) {\n\t\thlist_for_each_entry(e, &irq_rt->map[gsi], link) {\n\t\t\tif (e->type == KVM_IRQ_ROUTING_HV_SINT)\n\t\t\t\tkvm_hv_set_sint_gsi(kvm, e->hv_sint.vcpu,\n\t\t\t\t\t\t    e->hv_sint.sint, gsi);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "kvm_hv_set_sint_gsi",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.c",
    "lines": "342-355",
    "snippet": "static int kvm_hv_set_sint_gsi(struct kvm *kvm, u32 vcpu_id, u32 sint, int gsi)\n{\n\tstruct kvm_vcpu_hv_synic *synic;\n\n\tsynic = synic_get(kvm, vcpu_id);\n\tif (!synic)\n\t\treturn -EINVAL;\n\n\tif (sint >= ARRAY_SIZE(synic->sint_to_gsi))\n\t\treturn -EINVAL;\n\n\tatomic_set(&synic->sint_to_gsi[sint], gsi);\n\treturn 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/apicdef.h>",
      "#include <linux/highmem.h>",
      "#include <linux/kvm_host.h>",
      "#include \"hyperv.h\"",
      "#include \"ioapic.h\"",
      "#include \"lapic.h\"",
      "#include \"x86.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&synic->sint_to_gsi[sint]",
            "gsi"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "synic->sint_to_gsi"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "synic_get",
          "args": [
            "kvm",
            "vcpu_id"
          ],
          "line": 346
        },
        "resolved": true,
        "details": {
          "function_name": "synic_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.c",
          "lines": "107-119",
          "snippet": "static struct kvm_vcpu_hv_synic *synic_get(struct kvm *kvm, u32 vcpu_id)\n{\n\tstruct kvm_vcpu *vcpu;\n\tstruct kvm_vcpu_hv_synic *synic;\n\n\tif (vcpu_id >= atomic_read(&kvm->online_vcpus))\n\t\treturn NULL;\n\tvcpu = kvm_get_vcpu(kvm, vcpu_id);\n\tif (!vcpu)\n\t\treturn NULL;\n\tsynic = vcpu_to_synic(vcpu);\n\treturn (synic->active) ? synic : NULL;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic struct kvm_vcpu_hv_synic *synic_get(struct kvm *kvm, u32 vcpu_id)\n{\n\tstruct kvm_vcpu *vcpu;\n\tstruct kvm_vcpu_hv_synic *synic;\n\n\tif (vcpu_id >= atomic_read(&kvm->online_vcpus))\n\t\treturn NULL;\n\tvcpu = kvm_get_vcpu(kvm, vcpu_id);\n\tif (!vcpu)\n\t\treturn NULL;\n\tsynic = vcpu_to_synic(vcpu);\n\treturn (synic->active) ? synic : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic int kvm_hv_set_sint_gsi(struct kvm *kvm, u32 vcpu_id, u32 sint, int gsi)\n{\n\tstruct kvm_vcpu_hv_synic *synic;\n\n\tsynic = synic_get(kvm, vcpu_id);\n\tif (!synic)\n\t\treturn -EINVAL;\n\n\tif (sint >= ARRAY_SIZE(synic->sint_to_gsi))\n\t\treturn -EINVAL;\n\n\tatomic_set(&synic->sint_to_gsi[sint], gsi);\n\treturn 0;\n}"
  },
  {
    "function_name": "kvm_hv_synic_send_eoi",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.c",
    "lines": "330-340",
    "snippet": "void kvm_hv_synic_send_eoi(struct kvm_vcpu *vcpu, int vector)\n{\n\tstruct kvm_vcpu_hv_synic *synic = vcpu_to_synic(vcpu);\n\tint i;\n\n\ttrace_kvm_hv_synic_send_eoi(vcpu->vcpu_id, vector);\n\n\tfor (i = 0; i < ARRAY_SIZE(synic->sint); i++)\n\t\tif (synic_get_sint_vector(synic_read_sint(synic, i)) == vector)\n\t\t\tkvm_hv_notify_acked_sint(vcpu, i);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/apicdef.h>",
      "#include <linux/highmem.h>",
      "#include <linux/kvm_host.h>",
      "#include \"hyperv.h\"",
      "#include \"ioapic.h\"",
      "#include \"lapic.h\"",
      "#include \"x86.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_hv_notify_acked_sint",
          "args": [
            "vcpu",
            "i"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_hv_notify_acked_sint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.c",
          "lines": "147-180",
          "snippet": "static void kvm_hv_notify_acked_sint(struct kvm_vcpu *vcpu, u32 sint)\n{\n\tstruct kvm *kvm = vcpu->kvm;\n\tstruct kvm_vcpu_hv_synic *synic = vcpu_to_synic(vcpu);\n\tstruct kvm_vcpu_hv *hv_vcpu = vcpu_to_hv_vcpu(vcpu);\n\tstruct kvm_vcpu_hv_stimer *stimer;\n\tint gsi, idx, stimers_pending;\n\n\ttrace_kvm_hv_notify_acked_sint(vcpu->vcpu_id, sint);\n\n\tif (synic->msg_page & HV_SYNIC_SIMP_ENABLE)\n\t\tsynic_clear_sint_msg_pending(synic, sint);\n\n\t/* Try to deliver pending Hyper-V SynIC timers messages */\n\tstimers_pending = 0;\n\tfor (idx = 0; idx < ARRAY_SIZE(hv_vcpu->stimer); idx++) {\n\t\tstimer = &hv_vcpu->stimer[idx];\n\t\tif (stimer->msg_pending &&\n\t\t    (stimer->config & HV_STIMER_ENABLE) &&\n\t\t    HV_STIMER_SINT(stimer->config) == sint) {\n\t\t\tset_bit(stimer->index,\n\t\t\t\thv_vcpu->stimer_pending_bitmap);\n\t\t\tstimers_pending++;\n\t\t}\n\t}\n\tif (stimers_pending)\n\t\tkvm_make_request(KVM_REQ_HV_STIMER, vcpu);\n\n\tidx = srcu_read_lock(&kvm->irq_srcu);\n\tgsi = atomic_read(&synic->sint_to_gsi[sint]);\n\tif (gsi != -1)\n\t\tkvm_notify_acked_gsi(kvm, gsi);\n\tsrcu_read_unlock(&kvm->irq_srcu, idx);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic void kvm_hv_notify_acked_sint(struct kvm_vcpu *vcpu, u32 sint)\n{\n\tstruct kvm *kvm = vcpu->kvm;\n\tstruct kvm_vcpu_hv_synic *synic = vcpu_to_synic(vcpu);\n\tstruct kvm_vcpu_hv *hv_vcpu = vcpu_to_hv_vcpu(vcpu);\n\tstruct kvm_vcpu_hv_stimer *stimer;\n\tint gsi, idx, stimers_pending;\n\n\ttrace_kvm_hv_notify_acked_sint(vcpu->vcpu_id, sint);\n\n\tif (synic->msg_page & HV_SYNIC_SIMP_ENABLE)\n\t\tsynic_clear_sint_msg_pending(synic, sint);\n\n\t/* Try to deliver pending Hyper-V SynIC timers messages */\n\tstimers_pending = 0;\n\tfor (idx = 0; idx < ARRAY_SIZE(hv_vcpu->stimer); idx++) {\n\t\tstimer = &hv_vcpu->stimer[idx];\n\t\tif (stimer->msg_pending &&\n\t\t    (stimer->config & HV_STIMER_ENABLE) &&\n\t\t    HV_STIMER_SINT(stimer->config) == sint) {\n\t\t\tset_bit(stimer->index,\n\t\t\t\thv_vcpu->stimer_pending_bitmap);\n\t\t\tstimers_pending++;\n\t\t}\n\t}\n\tif (stimers_pending)\n\t\tkvm_make_request(KVM_REQ_HV_STIMER, vcpu);\n\n\tidx = srcu_read_lock(&kvm->irq_srcu);\n\tgsi = atomic_read(&synic->sint_to_gsi[sint]);\n\tif (gsi != -1)\n\t\tkvm_notify_acked_gsi(kvm, gsi);\n\tsrcu_read_unlock(&kvm->irq_srcu, idx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "synic_get_sint_vector",
          "args": [
            "synic_read_sint(synic, i)"
          ],
          "line": 338
        },
        "resolved": true,
        "details": {
          "function_name": "synic_get_sint_vector",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.c",
          "lines": "41-46",
          "snippet": "static inline int synic_get_sint_vector(u64 sint_value)\n{\n\tif (sint_value & HV_SYNIC_SINT_MASKED)\n\t\treturn -1;\n\treturn sint_value & HV_SYNIC_SINT_VECTOR_MASK;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic inline int synic_get_sint_vector(u64 sint_value)\n{\n\tif (sint_value & HV_SYNIC_SINT_MASKED)\n\t\treturn -1;\n\treturn sint_value & HV_SYNIC_SINT_VECTOR_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "synic_read_sint",
          "args": [
            "synic",
            "i"
          ],
          "line": 338
        },
        "resolved": true,
        "details": {
          "function_name": "synic_read_sint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.c",
          "lines": "36-39",
          "snippet": "static inline u64 synic_read_sint(struct kvm_vcpu_hv_synic *synic, int sint)\n{\n\treturn atomic64_read(&synic->sint[sint]);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic inline u64 synic_read_sint(struct kvm_vcpu_hv_synic *synic, int sint)\n{\n\treturn atomic64_read(&synic->sint[sint]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "synic->sint"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_kvm_hv_synic_send_eoi",
          "args": [
            "vcpu->vcpu_id",
            "vector"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vcpu_to_synic",
          "args": [
            "vcpu"
          ],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "vcpu_to_synic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.h",
          "lines": "40-43",
          "snippet": "static inline struct kvm_vcpu_hv_synic *vcpu_to_synic(struct kvm_vcpu *vcpu)\n{\n\treturn &vcpu->arch.hyperv.synic;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct kvm_vcpu_hv_synic *vcpu_to_synic(struct kvm_vcpu *vcpu)\n{\n\treturn &vcpu->arch.hyperv.synic;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nvoid kvm_hv_synic_send_eoi(struct kvm_vcpu *vcpu, int vector)\n{\n\tstruct kvm_vcpu_hv_synic *synic = vcpu_to_synic(vcpu);\n\tint i;\n\n\ttrace_kvm_hv_synic_send_eoi(vcpu->vcpu_id, vector);\n\n\tfor (i = 0; i < ARRAY_SIZE(synic->sint); i++)\n\t\tif (synic_get_sint_vector(synic_read_sint(synic, i)) == vector)\n\t\t\tkvm_hv_notify_acked_sint(vcpu, i);\n}"
  },
  {
    "function_name": "kvm_hv_synic_set_irq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.c",
    "lines": "319-328",
    "snippet": "int kvm_hv_synic_set_irq(struct kvm *kvm, u32 vcpu_id, u32 sint)\n{\n\tstruct kvm_vcpu_hv_synic *synic;\n\n\tsynic = synic_get(kvm, vcpu_id);\n\tif (!synic)\n\t\treturn -EINVAL;\n\n\treturn synic_set_irq(synic, sint);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/apicdef.h>",
      "#include <linux/highmem.h>",
      "#include <linux/kvm_host.h>",
      "#include \"hyperv.h\"",
      "#include \"ioapic.h\"",
      "#include \"lapic.h\"",
      "#include \"x86.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "synic_set_irq",
          "args": [
            "synic",
            "sint"
          ],
          "line": 327
        },
        "resolved": true,
        "details": {
          "function_name": "synic_set_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.c",
          "lines": "294-317",
          "snippet": "int synic_set_irq(struct kvm_vcpu_hv_synic *synic, u32 sint)\n{\n\tstruct kvm_vcpu *vcpu = synic_to_vcpu(synic);\n\tstruct kvm_lapic_irq irq;\n\tint ret, vector;\n\n\tif (sint >= ARRAY_SIZE(synic->sint))\n\t\treturn -EINVAL;\n\n\tvector = synic_get_sint_vector(synic_read_sint(synic, sint));\n\tif (vector < 0)\n\t\treturn -ENOENT;\n\n\tmemset(&irq, 0, sizeof(irq));\n\tirq.dest_id = kvm_apic_id(vcpu->arch.apic);\n\tirq.dest_mode = APIC_DEST_PHYSICAL;\n\tirq.delivery_mode = APIC_DM_FIXED;\n\tirq.vector = vector;\n\tirq.level = 1;\n\n\tret = kvm_irq_delivery_to_apic(vcpu->kvm, NULL, &irq, NULL);\n\ttrace_kvm_hv_synic_set_irq(vcpu->vcpu_id, sint, irq.vector, ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nint synic_set_irq(struct kvm_vcpu_hv_synic *synic, u32 sint)\n{\n\tstruct kvm_vcpu *vcpu = synic_to_vcpu(synic);\n\tstruct kvm_lapic_irq irq;\n\tint ret, vector;\n\n\tif (sint >= ARRAY_SIZE(synic->sint))\n\t\treturn -EINVAL;\n\n\tvector = synic_get_sint_vector(synic_read_sint(synic, sint));\n\tif (vector < 0)\n\t\treturn -ENOENT;\n\n\tmemset(&irq, 0, sizeof(irq));\n\tirq.dest_id = kvm_apic_id(vcpu->arch.apic);\n\tirq.dest_mode = APIC_DEST_PHYSICAL;\n\tirq.delivery_mode = APIC_DM_FIXED;\n\tirq.vector = vector;\n\tirq.level = 1;\n\n\tret = kvm_irq_delivery_to_apic(vcpu->kvm, NULL, &irq, NULL);\n\ttrace_kvm_hv_synic_set_irq(vcpu->vcpu_id, sint, irq.vector, ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "synic_get",
          "args": [
            "kvm",
            "vcpu_id"
          ],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "synic_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.c",
          "lines": "107-119",
          "snippet": "static struct kvm_vcpu_hv_synic *synic_get(struct kvm *kvm, u32 vcpu_id)\n{\n\tstruct kvm_vcpu *vcpu;\n\tstruct kvm_vcpu_hv_synic *synic;\n\n\tif (vcpu_id >= atomic_read(&kvm->online_vcpus))\n\t\treturn NULL;\n\tvcpu = kvm_get_vcpu(kvm, vcpu_id);\n\tif (!vcpu)\n\t\treturn NULL;\n\tsynic = vcpu_to_synic(vcpu);\n\treturn (synic->active) ? synic : NULL;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic struct kvm_vcpu_hv_synic *synic_get(struct kvm *kvm, u32 vcpu_id)\n{\n\tstruct kvm_vcpu *vcpu;\n\tstruct kvm_vcpu_hv_synic *synic;\n\n\tif (vcpu_id >= atomic_read(&kvm->online_vcpus))\n\t\treturn NULL;\n\tvcpu = kvm_get_vcpu(kvm, vcpu_id);\n\tif (!vcpu)\n\t\treturn NULL;\n\tsynic = vcpu_to_synic(vcpu);\n\treturn (synic->active) ? synic : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nint kvm_hv_synic_set_irq(struct kvm *kvm, u32 vcpu_id, u32 sint)\n{\n\tstruct kvm_vcpu_hv_synic *synic;\n\n\tsynic = synic_get(kvm, vcpu_id);\n\tif (!synic)\n\t\treturn -EINVAL;\n\n\treturn synic_set_irq(synic, sint);\n}"
  },
  {
    "function_name": "synic_set_irq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.c",
    "lines": "294-317",
    "snippet": "int synic_set_irq(struct kvm_vcpu_hv_synic *synic, u32 sint)\n{\n\tstruct kvm_vcpu *vcpu = synic_to_vcpu(synic);\n\tstruct kvm_lapic_irq irq;\n\tint ret, vector;\n\n\tif (sint >= ARRAY_SIZE(synic->sint))\n\t\treturn -EINVAL;\n\n\tvector = synic_get_sint_vector(synic_read_sint(synic, sint));\n\tif (vector < 0)\n\t\treturn -ENOENT;\n\n\tmemset(&irq, 0, sizeof(irq));\n\tirq.dest_id = kvm_apic_id(vcpu->arch.apic);\n\tirq.dest_mode = APIC_DEST_PHYSICAL;\n\tirq.delivery_mode = APIC_DM_FIXED;\n\tirq.vector = vector;\n\tirq.level = 1;\n\n\tret = kvm_irq_delivery_to_apic(vcpu->kvm, NULL, &irq, NULL);\n\ttrace_kvm_hv_synic_set_irq(vcpu->vcpu_id, sint, irq.vector, ret);\n\treturn ret;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/apicdef.h>",
      "#include <linux/highmem.h>",
      "#include <linux/kvm_host.h>",
      "#include \"hyperv.h\"",
      "#include \"ioapic.h\"",
      "#include \"lapic.h\"",
      "#include \"x86.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_kvm_hv_synic_set_irq",
          "args": [
            "vcpu->vcpu_id",
            "sint",
            "irq.vector",
            "ret"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_irq_delivery_to_apic",
          "args": [
            "vcpu->kvm",
            "NULL",
            "&irq",
            "NULL"
          ],
          "line": 314
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_irq_delivery_to_apic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/irq_comm.c",
          "lines": "56-111",
          "snippet": "int kvm_irq_delivery_to_apic(struct kvm *kvm, struct kvm_lapic *src,\n\t\tstruct kvm_lapic_irq *irq, struct dest_map *dest_map)\n{\n\tint i, r = -1;\n\tstruct kvm_vcpu *vcpu, *lowest = NULL;\n\tunsigned long dest_vcpu_bitmap[BITS_TO_LONGS(KVM_MAX_VCPUS)];\n\tunsigned int dest_vcpus = 0;\n\n\tif (irq->dest_mode == 0 && irq->dest_id == 0xff &&\n\t\t\tkvm_lowest_prio_delivery(irq)) {\n\t\tprintk(KERN_INFO \"kvm: apic: phys broadcast and lowest prio\\n\");\n\t\tirq->delivery_mode = APIC_DM_FIXED;\n\t}\n\n\tif (kvm_irq_delivery_to_apic_fast(kvm, src, irq, &r, dest_map))\n\t\treturn r;\n\n\tmemset(dest_vcpu_bitmap, 0, sizeof(dest_vcpu_bitmap));\n\n\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\tif (!kvm_apic_present(vcpu))\n\t\t\tcontinue;\n\n\t\tif (!kvm_apic_match_dest(vcpu, src, irq->shorthand,\n\t\t\t\t\tirq->dest_id, irq->dest_mode))\n\t\t\tcontinue;\n\n\t\tif (!kvm_lowest_prio_delivery(irq)) {\n\t\t\tif (r < 0)\n\t\t\t\tr = 0;\n\t\t\tr += kvm_apic_set_irq(vcpu, irq, dest_map);\n\t\t} else if (kvm_lapic_enabled(vcpu)) {\n\t\t\tif (!kvm_vector_hashing_enabled()) {\n\t\t\t\tif (!lowest)\n\t\t\t\t\tlowest = vcpu;\n\t\t\t\telse if (kvm_apic_compare_prio(vcpu, lowest) < 0)\n\t\t\t\t\tlowest = vcpu;\n\t\t\t} else {\n\t\t\t\t__set_bit(i, dest_vcpu_bitmap);\n\t\t\t\tdest_vcpus++;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (dest_vcpus != 0) {\n\t\tint idx = kvm_vector_to_index(irq->vector, dest_vcpus,\n\t\t\t\t\tdest_vcpu_bitmap, KVM_MAX_VCPUS);\n\n\t\tlowest = kvm_get_vcpu(kvm, idx);\n\t}\n\n\tif (lowest)\n\t\tr = kvm_apic_set_irq(lowest, irq, dest_map);\n\n\treturn r;\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"hyperv.h\"",
            "#include \"lapic.h\"",
            "#include \"ioapic.h\"",
            "#include \"irq.h\"",
            "#include <asm/msidef.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"hyperv.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include \"irq.h\"\n#include <asm/msidef.h>\n#include <trace/events/kvm.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nint kvm_irq_delivery_to_apic(struct kvm *kvm, struct kvm_lapic *src,\n\t\tstruct kvm_lapic_irq *irq, struct dest_map *dest_map)\n{\n\tint i, r = -1;\n\tstruct kvm_vcpu *vcpu, *lowest = NULL;\n\tunsigned long dest_vcpu_bitmap[BITS_TO_LONGS(KVM_MAX_VCPUS)];\n\tunsigned int dest_vcpus = 0;\n\n\tif (irq->dest_mode == 0 && irq->dest_id == 0xff &&\n\t\t\tkvm_lowest_prio_delivery(irq)) {\n\t\tprintk(KERN_INFO \"kvm: apic: phys broadcast and lowest prio\\n\");\n\t\tirq->delivery_mode = APIC_DM_FIXED;\n\t}\n\n\tif (kvm_irq_delivery_to_apic_fast(kvm, src, irq, &r, dest_map))\n\t\treturn r;\n\n\tmemset(dest_vcpu_bitmap, 0, sizeof(dest_vcpu_bitmap));\n\n\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\tif (!kvm_apic_present(vcpu))\n\t\t\tcontinue;\n\n\t\tif (!kvm_apic_match_dest(vcpu, src, irq->shorthand,\n\t\t\t\t\tirq->dest_id, irq->dest_mode))\n\t\t\tcontinue;\n\n\t\tif (!kvm_lowest_prio_delivery(irq)) {\n\t\t\tif (r < 0)\n\t\t\t\tr = 0;\n\t\t\tr += kvm_apic_set_irq(vcpu, irq, dest_map);\n\t\t} else if (kvm_lapic_enabled(vcpu)) {\n\t\t\tif (!kvm_vector_hashing_enabled()) {\n\t\t\t\tif (!lowest)\n\t\t\t\t\tlowest = vcpu;\n\t\t\t\telse if (kvm_apic_compare_prio(vcpu, lowest) < 0)\n\t\t\t\t\tlowest = vcpu;\n\t\t\t} else {\n\t\t\t\t__set_bit(i, dest_vcpu_bitmap);\n\t\t\t\tdest_vcpus++;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (dest_vcpus != 0) {\n\t\tint idx = kvm_vector_to_index(irq->vector, dest_vcpus,\n\t\t\t\t\tdest_vcpu_bitmap, KVM_MAX_VCPUS);\n\n\t\tlowest = kvm_get_vcpu(kvm, idx);\n\t}\n\n\tif (lowest)\n\t\tr = kvm_apic_set_irq(lowest, irq, dest_map);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_apic_id",
          "args": [
            "vcpu->arch.apic"
          ],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.h",
          "lines": "202-205",
          "snippet": "static inline int kvm_apic_id(struct kvm_lapic *apic)\n{\n\treturn (kvm_lapic_get_reg(apic, APIC_ID) >> 24) & 0xff;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline int kvm_apic_id(struct kvm_lapic *apic)\n{\n\treturn (kvm_lapic_get_reg(apic, APIC_ID) >> 24) & 0xff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&irq",
            "0",
            "sizeof(irq)"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "synic_get_sint_vector",
          "args": [
            "synic_read_sint(synic, sint)"
          ],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "synic_get_sint_vector",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.c",
          "lines": "41-46",
          "snippet": "static inline int synic_get_sint_vector(u64 sint_value)\n{\n\tif (sint_value & HV_SYNIC_SINT_MASKED)\n\t\treturn -1;\n\treturn sint_value & HV_SYNIC_SINT_VECTOR_MASK;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic inline int synic_get_sint_vector(u64 sint_value)\n{\n\tif (sint_value & HV_SYNIC_SINT_MASKED)\n\t\treturn -1;\n\treturn sint_value & HV_SYNIC_SINT_VECTOR_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "synic_read_sint",
          "args": [
            "synic",
            "sint"
          ],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "synic_read_sint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.c",
          "lines": "36-39",
          "snippet": "static inline u64 synic_read_sint(struct kvm_vcpu_hv_synic *synic, int sint)\n{\n\treturn atomic64_read(&synic->sint[sint]);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic inline u64 synic_read_sint(struct kvm_vcpu_hv_synic *synic, int sint)\n{\n\treturn atomic64_read(&synic->sint[sint]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "synic->sint"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "synic_to_vcpu",
          "args": [
            "synic"
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "synic_to_vcpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.h",
          "lines": "45-48",
          "snippet": "static inline struct kvm_vcpu *synic_to_vcpu(struct kvm_vcpu_hv_synic *synic)\n{\n\treturn hv_vcpu_to_vcpu(container_of(synic, struct kvm_vcpu_hv, synic));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct kvm_vcpu *synic_to_vcpu(struct kvm_vcpu_hv_synic *synic)\n{\n\treturn hv_vcpu_to_vcpu(container_of(synic, struct kvm_vcpu_hv, synic));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nint synic_set_irq(struct kvm_vcpu_hv_synic *synic, u32 sint)\n{\n\tstruct kvm_vcpu *vcpu = synic_to_vcpu(synic);\n\tstruct kvm_lapic_irq irq;\n\tint ret, vector;\n\n\tif (sint >= ARRAY_SIZE(synic->sint))\n\t\treturn -EINVAL;\n\n\tvector = synic_get_sint_vector(synic_read_sint(synic, sint));\n\tif (vector < 0)\n\t\treturn -ENOENT;\n\n\tmemset(&irq, 0, sizeof(irq));\n\tirq.dest_id = kvm_apic_id(vcpu->arch.apic);\n\tirq.dest_mode = APIC_DEST_PHYSICAL;\n\tirq.delivery_mode = APIC_DM_FIXED;\n\tirq.vector = vector;\n\tirq.level = 1;\n\n\tret = kvm_irq_delivery_to_apic(vcpu->kvm, NULL, &irq, NULL);\n\ttrace_kvm_hv_synic_set_irq(vcpu->vcpu_id, sint, irq.vector, ret);\n\treturn ret;\n}"
  },
  {
    "function_name": "synic_get_msr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.c",
    "lines": "260-292",
    "snippet": "static int synic_get_msr(struct kvm_vcpu_hv_synic *synic, u32 msr, u64 *pdata)\n{\n\tint ret;\n\n\tif (!synic->active)\n\t\treturn 1;\n\n\tret = 0;\n\tswitch (msr) {\n\tcase HV_X64_MSR_SCONTROL:\n\t\t*pdata = synic->control;\n\t\tbreak;\n\tcase HV_X64_MSR_SVERSION:\n\t\t*pdata = synic->version;\n\t\tbreak;\n\tcase HV_X64_MSR_SIEFP:\n\t\t*pdata = synic->evt_page;\n\t\tbreak;\n\tcase HV_X64_MSR_SIMP:\n\t\t*pdata = synic->msg_page;\n\t\tbreak;\n\tcase HV_X64_MSR_EOM:\n\t\t*pdata = 0;\n\t\tbreak;\n\tcase HV_X64_MSR_SINT0 ... HV_X64_MSR_SINT15:\n\t\t*pdata = atomic64_read(&synic->sint[msr - HV_X64_MSR_SINT0]);\n\t\tbreak;\n\tdefault:\n\t\tret = 1;\n\t\tbreak;\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/apicdef.h>",
      "#include <linux/highmem.h>",
      "#include <linux/kvm_host.h>",
      "#include \"hyperv.h\"",
      "#include \"ioapic.h\"",
      "#include \"lapic.h\"",
      "#include \"x86.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic64_read",
          "args": [
            "&synic->sint[msr - HV_X64_MSR_SINT0]"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic int synic_get_msr(struct kvm_vcpu_hv_synic *synic, u32 msr, u64 *pdata)\n{\n\tint ret;\n\n\tif (!synic->active)\n\t\treturn 1;\n\n\tret = 0;\n\tswitch (msr) {\n\tcase HV_X64_MSR_SCONTROL:\n\t\t*pdata = synic->control;\n\t\tbreak;\n\tcase HV_X64_MSR_SVERSION:\n\t\t*pdata = synic->version;\n\t\tbreak;\n\tcase HV_X64_MSR_SIEFP:\n\t\t*pdata = synic->evt_page;\n\t\tbreak;\n\tcase HV_X64_MSR_SIMP:\n\t\t*pdata = synic->msg_page;\n\t\tbreak;\n\tcase HV_X64_MSR_EOM:\n\t\t*pdata = 0;\n\t\tbreak;\n\tcase HV_X64_MSR_SINT0 ... HV_X64_MSR_SINT15:\n\t\t*pdata = atomic64_read(&synic->sint[msr - HV_X64_MSR_SINT0]);\n\t\tbreak;\n\tdefault:\n\t\tret = 1;\n\t\tbreak;\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "synic_set_msr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.c",
    "lines": "196-258",
    "snippet": "static int synic_set_msr(struct kvm_vcpu_hv_synic *synic,\n\t\t\t u32 msr, u64 data, bool host)\n{\n\tstruct kvm_vcpu *vcpu = synic_to_vcpu(synic);\n\tint ret;\n\n\tif (!synic->active)\n\t\treturn 1;\n\n\ttrace_kvm_hv_synic_set_msr(vcpu->vcpu_id, msr, data, host);\n\n\tret = 0;\n\tswitch (msr) {\n\tcase HV_X64_MSR_SCONTROL:\n\t\tsynic->control = data;\n\t\tif (!host)\n\t\t\tsynic_exit(synic, msr);\n\t\tbreak;\n\tcase HV_X64_MSR_SVERSION:\n\t\tif (!host) {\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\t\tsynic->version = data;\n\t\tbreak;\n\tcase HV_X64_MSR_SIEFP:\n\t\tif (data & HV_SYNIC_SIEFP_ENABLE)\n\t\t\tif (kvm_clear_guest(vcpu->kvm,\n\t\t\t\t\t    data & PAGE_MASK, PAGE_SIZE)) {\n\t\t\t\tret = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tsynic->evt_page = data;\n\t\tif (!host)\n\t\t\tsynic_exit(synic, msr);\n\t\tbreak;\n\tcase HV_X64_MSR_SIMP:\n\t\tif (data & HV_SYNIC_SIMP_ENABLE)\n\t\t\tif (kvm_clear_guest(vcpu->kvm,\n\t\t\t\t\t    data & PAGE_MASK, PAGE_SIZE)) {\n\t\t\t\tret = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tsynic->msg_page = data;\n\t\tif (!host)\n\t\t\tsynic_exit(synic, msr);\n\t\tbreak;\n\tcase HV_X64_MSR_EOM: {\n\t\tint i;\n\n\t\tfor (i = 0; i < ARRAY_SIZE(synic->sint); i++)\n\t\t\tkvm_hv_notify_acked_sint(vcpu, i);\n\t\tbreak;\n\t}\n\tcase HV_X64_MSR_SINT0 ... HV_X64_MSR_SINT15:\n\t\tret = synic_set_sint(synic, msr - HV_X64_MSR_SINT0, data, host);\n\t\tbreak;\n\tdefault:\n\t\tret = 1;\n\t\tbreak;\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/apicdef.h>",
      "#include <linux/highmem.h>",
      "#include <linux/kvm_host.h>",
      "#include \"hyperv.h\"",
      "#include \"ioapic.h\"",
      "#include \"lapic.h\"",
      "#include \"x86.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "synic_set_sint",
          "args": [
            "synic",
            "msr - HV_X64_MSR_SINT0",
            "data",
            "host"
          ],
          "line": 251
        },
        "resolved": true,
        "details": {
          "function_name": "synic_set_sint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.c",
          "lines": "75-105",
          "snippet": "static int synic_set_sint(struct kvm_vcpu_hv_synic *synic, int sint,\n\t\t\t  u64 data, bool host)\n{\n\tint vector;\n\n\tvector = data & HV_SYNIC_SINT_VECTOR_MASK;\n\tif (vector < 16 && !host)\n\t\treturn 1;\n\t/*\n\t * Guest may configure multiple SINTs to use the same vector, so\n\t * we maintain a bitmap of vectors handled by synic, and a\n\t * bitmap of vectors with auto-eoi behavior.  The bitmaps are\n\t * updated here, and atomically queried on fast paths.\n\t */\n\n\tatomic64_set(&synic->sint[sint], data);\n\n\tif (synic_has_vector_connected(synic, vector))\n\t\t__set_bit(vector, synic->vec_bitmap);\n\telse\n\t\t__clear_bit(vector, synic->vec_bitmap);\n\n\tif (synic_has_vector_auto_eoi(synic, vector))\n\t\t__set_bit(vector, synic->auto_eoi_bitmap);\n\telse\n\t\t__clear_bit(vector, synic->auto_eoi_bitmap);\n\n\t/* Load SynIC vectors into EOI exit bitmap */\n\tkvm_make_request(KVM_REQ_SCAN_IOAPIC, synic_to_vcpu(synic));\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic int synic_set_sint(struct kvm_vcpu_hv_synic *synic, int sint,\n\t\t\t  u64 data, bool host)\n{\n\tint vector;\n\n\tvector = data & HV_SYNIC_SINT_VECTOR_MASK;\n\tif (vector < 16 && !host)\n\t\treturn 1;\n\t/*\n\t * Guest may configure multiple SINTs to use the same vector, so\n\t * we maintain a bitmap of vectors handled by synic, and a\n\t * bitmap of vectors with auto-eoi behavior.  The bitmaps are\n\t * updated here, and atomically queried on fast paths.\n\t */\n\n\tatomic64_set(&synic->sint[sint], data);\n\n\tif (synic_has_vector_connected(synic, vector))\n\t\t__set_bit(vector, synic->vec_bitmap);\n\telse\n\t\t__clear_bit(vector, synic->vec_bitmap);\n\n\tif (synic_has_vector_auto_eoi(synic, vector))\n\t\t__set_bit(vector, synic->auto_eoi_bitmap);\n\telse\n\t\t__clear_bit(vector, synic->auto_eoi_bitmap);\n\n\t/* Load SynIC vectors into EOI exit bitmap */\n\tkvm_make_request(KVM_REQ_SCAN_IOAPIC, synic_to_vcpu(synic));\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_hv_notify_acked_sint",
          "args": [
            "vcpu",
            "i"
          ],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_hv_notify_acked_sint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.c",
          "lines": "147-180",
          "snippet": "static void kvm_hv_notify_acked_sint(struct kvm_vcpu *vcpu, u32 sint)\n{\n\tstruct kvm *kvm = vcpu->kvm;\n\tstruct kvm_vcpu_hv_synic *synic = vcpu_to_synic(vcpu);\n\tstruct kvm_vcpu_hv *hv_vcpu = vcpu_to_hv_vcpu(vcpu);\n\tstruct kvm_vcpu_hv_stimer *stimer;\n\tint gsi, idx, stimers_pending;\n\n\ttrace_kvm_hv_notify_acked_sint(vcpu->vcpu_id, sint);\n\n\tif (synic->msg_page & HV_SYNIC_SIMP_ENABLE)\n\t\tsynic_clear_sint_msg_pending(synic, sint);\n\n\t/* Try to deliver pending Hyper-V SynIC timers messages */\n\tstimers_pending = 0;\n\tfor (idx = 0; idx < ARRAY_SIZE(hv_vcpu->stimer); idx++) {\n\t\tstimer = &hv_vcpu->stimer[idx];\n\t\tif (stimer->msg_pending &&\n\t\t    (stimer->config & HV_STIMER_ENABLE) &&\n\t\t    HV_STIMER_SINT(stimer->config) == sint) {\n\t\t\tset_bit(stimer->index,\n\t\t\t\thv_vcpu->stimer_pending_bitmap);\n\t\t\tstimers_pending++;\n\t\t}\n\t}\n\tif (stimers_pending)\n\t\tkvm_make_request(KVM_REQ_HV_STIMER, vcpu);\n\n\tidx = srcu_read_lock(&kvm->irq_srcu);\n\tgsi = atomic_read(&synic->sint_to_gsi[sint]);\n\tif (gsi != -1)\n\t\tkvm_notify_acked_gsi(kvm, gsi);\n\tsrcu_read_unlock(&kvm->irq_srcu, idx);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic void kvm_hv_notify_acked_sint(struct kvm_vcpu *vcpu, u32 sint)\n{\n\tstruct kvm *kvm = vcpu->kvm;\n\tstruct kvm_vcpu_hv_synic *synic = vcpu_to_synic(vcpu);\n\tstruct kvm_vcpu_hv *hv_vcpu = vcpu_to_hv_vcpu(vcpu);\n\tstruct kvm_vcpu_hv_stimer *stimer;\n\tint gsi, idx, stimers_pending;\n\n\ttrace_kvm_hv_notify_acked_sint(vcpu->vcpu_id, sint);\n\n\tif (synic->msg_page & HV_SYNIC_SIMP_ENABLE)\n\t\tsynic_clear_sint_msg_pending(synic, sint);\n\n\t/* Try to deliver pending Hyper-V SynIC timers messages */\n\tstimers_pending = 0;\n\tfor (idx = 0; idx < ARRAY_SIZE(hv_vcpu->stimer); idx++) {\n\t\tstimer = &hv_vcpu->stimer[idx];\n\t\tif (stimer->msg_pending &&\n\t\t    (stimer->config & HV_STIMER_ENABLE) &&\n\t\t    HV_STIMER_SINT(stimer->config) == sint) {\n\t\t\tset_bit(stimer->index,\n\t\t\t\thv_vcpu->stimer_pending_bitmap);\n\t\t\tstimers_pending++;\n\t\t}\n\t}\n\tif (stimers_pending)\n\t\tkvm_make_request(KVM_REQ_HV_STIMER, vcpu);\n\n\tidx = srcu_read_lock(&kvm->irq_srcu);\n\tgsi = atomic_read(&synic->sint_to_gsi[sint]);\n\tif (gsi != -1)\n\t\tkvm_notify_acked_gsi(kvm, gsi);\n\tsrcu_read_unlock(&kvm->irq_srcu, idx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "synic->sint"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "synic_exit",
          "args": [
            "synic",
            "msr"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "synic_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.c",
          "lines": "182-194",
          "snippet": "static void synic_exit(struct kvm_vcpu_hv_synic *synic, u32 msr)\n{\n\tstruct kvm_vcpu *vcpu = synic_to_vcpu(synic);\n\tstruct kvm_vcpu_hv *hv_vcpu = &vcpu->arch.hyperv;\n\n\thv_vcpu->exit.type = KVM_EXIT_HYPERV_SYNIC;\n\thv_vcpu->exit.u.synic.msr = msr;\n\thv_vcpu->exit.u.synic.control = synic->control;\n\thv_vcpu->exit.u.synic.evt_page = synic->evt_page;\n\thv_vcpu->exit.u.synic.msg_page = synic->msg_page;\n\n\tkvm_make_request(KVM_REQ_HV_EXIT, vcpu);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic void synic_exit(struct kvm_vcpu_hv_synic *synic, u32 msr)\n{\n\tstruct kvm_vcpu *vcpu = synic_to_vcpu(synic);\n\tstruct kvm_vcpu_hv *hv_vcpu = &vcpu->arch.hyperv;\n\n\thv_vcpu->exit.type = KVM_EXIT_HYPERV_SYNIC;\n\thv_vcpu->exit.u.synic.msr = msr;\n\thv_vcpu->exit.u.synic.control = synic->control;\n\thv_vcpu->exit.u.synic.evt_page = synic->evt_page;\n\thv_vcpu->exit.u.synic.msg_page = synic->msg_page;\n\n\tkvm_make_request(KVM_REQ_HV_EXIT, vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_clear_guest",
          "args": [
            "vcpu->kvm",
            "data & PAGE_MASK",
            "PAGE_SIZE"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_clear_guest",
          "args": [
            "vcpu->kvm",
            "data & PAGE_MASK",
            "PAGE_SIZE"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_kvm_hv_synic_set_msr",
          "args": [
            "vcpu->vcpu_id",
            "msr",
            "data",
            "host"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "synic_to_vcpu",
          "args": [
            "synic"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "synic_to_vcpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.h",
          "lines": "45-48",
          "snippet": "static inline struct kvm_vcpu *synic_to_vcpu(struct kvm_vcpu_hv_synic *synic)\n{\n\treturn hv_vcpu_to_vcpu(container_of(synic, struct kvm_vcpu_hv, synic));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct kvm_vcpu *synic_to_vcpu(struct kvm_vcpu_hv_synic *synic)\n{\n\treturn hv_vcpu_to_vcpu(container_of(synic, struct kvm_vcpu_hv, synic));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic int synic_set_msr(struct kvm_vcpu_hv_synic *synic,\n\t\t\t u32 msr, u64 data, bool host)\n{\n\tstruct kvm_vcpu *vcpu = synic_to_vcpu(synic);\n\tint ret;\n\n\tif (!synic->active)\n\t\treturn 1;\n\n\ttrace_kvm_hv_synic_set_msr(vcpu->vcpu_id, msr, data, host);\n\n\tret = 0;\n\tswitch (msr) {\n\tcase HV_X64_MSR_SCONTROL:\n\t\tsynic->control = data;\n\t\tif (!host)\n\t\t\tsynic_exit(synic, msr);\n\t\tbreak;\n\tcase HV_X64_MSR_SVERSION:\n\t\tif (!host) {\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\t\tsynic->version = data;\n\t\tbreak;\n\tcase HV_X64_MSR_SIEFP:\n\t\tif (data & HV_SYNIC_SIEFP_ENABLE)\n\t\t\tif (kvm_clear_guest(vcpu->kvm,\n\t\t\t\t\t    data & PAGE_MASK, PAGE_SIZE)) {\n\t\t\t\tret = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tsynic->evt_page = data;\n\t\tif (!host)\n\t\t\tsynic_exit(synic, msr);\n\t\tbreak;\n\tcase HV_X64_MSR_SIMP:\n\t\tif (data & HV_SYNIC_SIMP_ENABLE)\n\t\t\tif (kvm_clear_guest(vcpu->kvm,\n\t\t\t\t\t    data & PAGE_MASK, PAGE_SIZE)) {\n\t\t\t\tret = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tsynic->msg_page = data;\n\t\tif (!host)\n\t\t\tsynic_exit(synic, msr);\n\t\tbreak;\n\tcase HV_X64_MSR_EOM: {\n\t\tint i;\n\n\t\tfor (i = 0; i < ARRAY_SIZE(synic->sint); i++)\n\t\t\tkvm_hv_notify_acked_sint(vcpu, i);\n\t\tbreak;\n\t}\n\tcase HV_X64_MSR_SINT0 ... HV_X64_MSR_SINT15:\n\t\tret = synic_set_sint(synic, msr - HV_X64_MSR_SINT0, data, host);\n\t\tbreak;\n\tdefault:\n\t\tret = 1;\n\t\tbreak;\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "synic_exit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.c",
    "lines": "182-194",
    "snippet": "static void synic_exit(struct kvm_vcpu_hv_synic *synic, u32 msr)\n{\n\tstruct kvm_vcpu *vcpu = synic_to_vcpu(synic);\n\tstruct kvm_vcpu_hv *hv_vcpu = &vcpu->arch.hyperv;\n\n\thv_vcpu->exit.type = KVM_EXIT_HYPERV_SYNIC;\n\thv_vcpu->exit.u.synic.msr = msr;\n\thv_vcpu->exit.u.synic.control = synic->control;\n\thv_vcpu->exit.u.synic.evt_page = synic->evt_page;\n\thv_vcpu->exit.u.synic.msg_page = synic->msg_page;\n\n\tkvm_make_request(KVM_REQ_HV_EXIT, vcpu);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/apicdef.h>",
      "#include <linux/highmem.h>",
      "#include <linux/kvm_host.h>",
      "#include \"hyperv.h\"",
      "#include \"ioapic.h\"",
      "#include \"lapic.h\"",
      "#include \"x86.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_make_request",
          "args": [
            "KVM_REQ_HV_EXIT",
            "vcpu"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "synic_to_vcpu",
          "args": [
            "synic"
          ],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "synic_to_vcpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.h",
          "lines": "45-48",
          "snippet": "static inline struct kvm_vcpu *synic_to_vcpu(struct kvm_vcpu_hv_synic *synic)\n{\n\treturn hv_vcpu_to_vcpu(container_of(synic, struct kvm_vcpu_hv, synic));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct kvm_vcpu *synic_to_vcpu(struct kvm_vcpu_hv_synic *synic)\n{\n\treturn hv_vcpu_to_vcpu(container_of(synic, struct kvm_vcpu_hv, synic));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic void synic_exit(struct kvm_vcpu_hv_synic *synic, u32 msr)\n{\n\tstruct kvm_vcpu *vcpu = synic_to_vcpu(synic);\n\tstruct kvm_vcpu_hv *hv_vcpu = &vcpu->arch.hyperv;\n\n\thv_vcpu->exit.type = KVM_EXIT_HYPERV_SYNIC;\n\thv_vcpu->exit.u.synic.msr = msr;\n\thv_vcpu->exit.u.synic.control = synic->control;\n\thv_vcpu->exit.u.synic.evt_page = synic->evt_page;\n\thv_vcpu->exit.u.synic.msg_page = synic->msg_page;\n\n\tkvm_make_request(KVM_REQ_HV_EXIT, vcpu);\n}"
  },
  {
    "function_name": "kvm_hv_notify_acked_sint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.c",
    "lines": "147-180",
    "snippet": "static void kvm_hv_notify_acked_sint(struct kvm_vcpu *vcpu, u32 sint)\n{\n\tstruct kvm *kvm = vcpu->kvm;\n\tstruct kvm_vcpu_hv_synic *synic = vcpu_to_synic(vcpu);\n\tstruct kvm_vcpu_hv *hv_vcpu = vcpu_to_hv_vcpu(vcpu);\n\tstruct kvm_vcpu_hv_stimer *stimer;\n\tint gsi, idx, stimers_pending;\n\n\ttrace_kvm_hv_notify_acked_sint(vcpu->vcpu_id, sint);\n\n\tif (synic->msg_page & HV_SYNIC_SIMP_ENABLE)\n\t\tsynic_clear_sint_msg_pending(synic, sint);\n\n\t/* Try to deliver pending Hyper-V SynIC timers messages */\n\tstimers_pending = 0;\n\tfor (idx = 0; idx < ARRAY_SIZE(hv_vcpu->stimer); idx++) {\n\t\tstimer = &hv_vcpu->stimer[idx];\n\t\tif (stimer->msg_pending &&\n\t\t    (stimer->config & HV_STIMER_ENABLE) &&\n\t\t    HV_STIMER_SINT(stimer->config) == sint) {\n\t\t\tset_bit(stimer->index,\n\t\t\t\thv_vcpu->stimer_pending_bitmap);\n\t\t\tstimers_pending++;\n\t\t}\n\t}\n\tif (stimers_pending)\n\t\tkvm_make_request(KVM_REQ_HV_STIMER, vcpu);\n\n\tidx = srcu_read_lock(&kvm->irq_srcu);\n\tgsi = atomic_read(&synic->sint_to_gsi[sint]);\n\tif (gsi != -1)\n\t\tkvm_notify_acked_gsi(kvm, gsi);\n\tsrcu_read_unlock(&kvm->irq_srcu, idx);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/apicdef.h>",
      "#include <linux/highmem.h>",
      "#include <linux/kvm_host.h>",
      "#include \"hyperv.h\"",
      "#include \"ioapic.h\"",
      "#include \"lapic.h\"",
      "#include \"x86.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "srcu_read_unlock",
          "args": [
            "&kvm->irq_srcu",
            "idx"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_notify_acked_gsi",
          "args": [
            "kvm",
            "gsi"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&synic->sint_to_gsi[sint]"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "srcu_read_lock",
          "args": [
            "&kvm->irq_srcu"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_make_request",
          "args": [
            "KVM_REQ_HV_STIMER",
            "vcpu"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "stimer->index",
            "hv_vcpu->stimer_pending_bitmap"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_set_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/vmx.c",
          "lines": "1599-1604",
          "snippet": "static __always_inline void vmcs_set_bits(unsigned long field, u32 mask)\n{\n        BUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x2000,\n\t\t\t \"vmcs_set_bits does not support 64-bit fields\");\n\t__vmcs_writel(field, __vmcs_readl(field) | mask);\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"trace.h\"",
            "#include <asm/irq_remapping.h>",
            "#include <asm/apic.h>",
            "#include <asm/kexec.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/mce.h>",
            "#include <asm/virtext.h>",
            "#include <asm/vmx.h>",
            "#include <asm/desc.h>",
            "#include <asm/io.h>",
            "#include <asm/cpu.h>",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/hrtimer.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include \"lapic.h\"",
            "#include \"cpuid.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"trace.h\"\n#include <asm/irq_remapping.h>\n#include <asm/apic.h>\n#include <asm/kexec.h>\n#include <asm/debugreg.h>\n#include <asm/perf_event.h>\n#include <asm/fpu/internal.h>\n#include <asm/mce.h>\n#include <asm/virtext.h>\n#include <asm/vmx.h>\n#include <asm/desc.h>\n#include <asm/io.h>\n#include <asm/cpu.h>\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/hrtimer.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic __always_inline void vmcs_set_bits(unsigned long field, u32 mask)\n{\n        BUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x2000,\n\t\t\t \"vmcs_set_bits does not support 64-bit fields\");\n\t__vmcs_writel(field, __vmcs_readl(field) | mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "HV_STIMER_SINT",
          "args": [
            "stimer->config"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "hv_vcpu->stimer"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "synic_clear_sint_msg_pending",
          "args": [
            "synic",
            "sint"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "synic_clear_sint_msg_pending",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.c",
          "lines": "121-145",
          "snippet": "static void synic_clear_sint_msg_pending(struct kvm_vcpu_hv_synic *synic,\n\t\t\t\t\tu32 sint)\n{\n\tstruct kvm_vcpu *vcpu = synic_to_vcpu(synic);\n\tstruct page *page;\n\tgpa_t gpa;\n\tstruct hv_message *msg;\n\tstruct hv_message_page *msg_page;\n\n\tgpa = synic->msg_page & PAGE_MASK;\n\tpage = kvm_vcpu_gfn_to_page(vcpu, gpa >> PAGE_SHIFT);\n\tif (is_error_page(page)) {\n\t\tvcpu_err(vcpu, \"Hyper-V SynIC can't get msg page, gpa 0x%llx\\n\",\n\t\t\t gpa);\n\t\treturn;\n\t}\n\tmsg_page = kmap_atomic(page);\n\n\tmsg = &msg_page->sint_message[sint];\n\tmsg->header.message_flags.msg_pending = 0;\n\n\tkunmap_atomic(msg_page);\n\tkvm_release_page_dirty(page);\n\tkvm_vcpu_mark_page_dirty(vcpu, gpa >> PAGE_SHIFT);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic void synic_clear_sint_msg_pending(struct kvm_vcpu_hv_synic *synic,\n\t\t\t\t\tu32 sint)\n{\n\tstruct kvm_vcpu *vcpu = synic_to_vcpu(synic);\n\tstruct page *page;\n\tgpa_t gpa;\n\tstruct hv_message *msg;\n\tstruct hv_message_page *msg_page;\n\n\tgpa = synic->msg_page & PAGE_MASK;\n\tpage = kvm_vcpu_gfn_to_page(vcpu, gpa >> PAGE_SHIFT);\n\tif (is_error_page(page)) {\n\t\tvcpu_err(vcpu, \"Hyper-V SynIC can't get msg page, gpa 0x%llx\\n\",\n\t\t\t gpa);\n\t\treturn;\n\t}\n\tmsg_page = kmap_atomic(page);\n\n\tmsg = &msg_page->sint_message[sint];\n\tmsg->header.message_flags.msg_pending = 0;\n\n\tkunmap_atomic(msg_page);\n\tkvm_release_page_dirty(page);\n\tkvm_vcpu_mark_page_dirty(vcpu, gpa >> PAGE_SHIFT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_kvm_hv_notify_acked_sint",
          "args": [
            "vcpu->vcpu_id",
            "sint"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vcpu_to_hv_vcpu",
          "args": [
            "vcpu"
          ],
          "line": 151
        },
        "resolved": true,
        "details": {
          "function_name": "vcpu_to_hv_vcpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.h",
          "lines": "27-30",
          "snippet": "static inline struct kvm_vcpu_hv *vcpu_to_hv_vcpu(struct kvm_vcpu *vcpu)\n{\n\treturn &vcpu->arch.hyperv;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct kvm_vcpu_hv *vcpu_to_hv_vcpu(struct kvm_vcpu *vcpu)\n{\n\treturn &vcpu->arch.hyperv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vcpu_to_synic",
          "args": [
            "vcpu"
          ],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "vcpu_to_synic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.h",
          "lines": "40-43",
          "snippet": "static inline struct kvm_vcpu_hv_synic *vcpu_to_synic(struct kvm_vcpu *vcpu)\n{\n\treturn &vcpu->arch.hyperv.synic;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct kvm_vcpu_hv_synic *vcpu_to_synic(struct kvm_vcpu *vcpu)\n{\n\treturn &vcpu->arch.hyperv.synic;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic void kvm_hv_notify_acked_sint(struct kvm_vcpu *vcpu, u32 sint)\n{\n\tstruct kvm *kvm = vcpu->kvm;\n\tstruct kvm_vcpu_hv_synic *synic = vcpu_to_synic(vcpu);\n\tstruct kvm_vcpu_hv *hv_vcpu = vcpu_to_hv_vcpu(vcpu);\n\tstruct kvm_vcpu_hv_stimer *stimer;\n\tint gsi, idx, stimers_pending;\n\n\ttrace_kvm_hv_notify_acked_sint(vcpu->vcpu_id, sint);\n\n\tif (synic->msg_page & HV_SYNIC_SIMP_ENABLE)\n\t\tsynic_clear_sint_msg_pending(synic, sint);\n\n\t/* Try to deliver pending Hyper-V SynIC timers messages */\n\tstimers_pending = 0;\n\tfor (idx = 0; idx < ARRAY_SIZE(hv_vcpu->stimer); idx++) {\n\t\tstimer = &hv_vcpu->stimer[idx];\n\t\tif (stimer->msg_pending &&\n\t\t    (stimer->config & HV_STIMER_ENABLE) &&\n\t\t    HV_STIMER_SINT(stimer->config) == sint) {\n\t\t\tset_bit(stimer->index,\n\t\t\t\thv_vcpu->stimer_pending_bitmap);\n\t\t\tstimers_pending++;\n\t\t}\n\t}\n\tif (stimers_pending)\n\t\tkvm_make_request(KVM_REQ_HV_STIMER, vcpu);\n\n\tidx = srcu_read_lock(&kvm->irq_srcu);\n\tgsi = atomic_read(&synic->sint_to_gsi[sint]);\n\tif (gsi != -1)\n\t\tkvm_notify_acked_gsi(kvm, gsi);\n\tsrcu_read_unlock(&kvm->irq_srcu, idx);\n}"
  },
  {
    "function_name": "synic_clear_sint_msg_pending",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.c",
    "lines": "121-145",
    "snippet": "static void synic_clear_sint_msg_pending(struct kvm_vcpu_hv_synic *synic,\n\t\t\t\t\tu32 sint)\n{\n\tstruct kvm_vcpu *vcpu = synic_to_vcpu(synic);\n\tstruct page *page;\n\tgpa_t gpa;\n\tstruct hv_message *msg;\n\tstruct hv_message_page *msg_page;\n\n\tgpa = synic->msg_page & PAGE_MASK;\n\tpage = kvm_vcpu_gfn_to_page(vcpu, gpa >> PAGE_SHIFT);\n\tif (is_error_page(page)) {\n\t\tvcpu_err(vcpu, \"Hyper-V SynIC can't get msg page, gpa 0x%llx\\n\",\n\t\t\t gpa);\n\t\treturn;\n\t}\n\tmsg_page = kmap_atomic(page);\n\n\tmsg = &msg_page->sint_message[sint];\n\tmsg->header.message_flags.msg_pending = 0;\n\n\tkunmap_atomic(msg_page);\n\tkvm_release_page_dirty(page);\n\tkvm_vcpu_mark_page_dirty(vcpu, gpa >> PAGE_SHIFT);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/apicdef.h>",
      "#include <linux/highmem.h>",
      "#include <linux/kvm_host.h>",
      "#include \"hyperv.h\"",
      "#include \"ioapic.h\"",
      "#include \"lapic.h\"",
      "#include \"x86.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_vcpu_mark_page_dirty",
          "args": [
            "vcpu",
            "gpa >> PAGE_SHIFT"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_release_page_dirty",
          "args": [
            "page"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "msg_page"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "page"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vcpu_err",
          "args": [
            "vcpu",
            "\"Hyper-V SynIC can't get msg page, gpa 0x%llx\\n\"",
            "gpa"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_error_page",
          "args": [
            "page"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_gfn_to_page",
          "args": [
            "vcpu",
            "gpa >> PAGE_SHIFT"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "synic_to_vcpu",
          "args": [
            "synic"
          ],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "synic_to_vcpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.h",
          "lines": "45-48",
          "snippet": "static inline struct kvm_vcpu *synic_to_vcpu(struct kvm_vcpu_hv_synic *synic)\n{\n\treturn hv_vcpu_to_vcpu(container_of(synic, struct kvm_vcpu_hv, synic));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct kvm_vcpu *synic_to_vcpu(struct kvm_vcpu_hv_synic *synic)\n{\n\treturn hv_vcpu_to_vcpu(container_of(synic, struct kvm_vcpu_hv, synic));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic void synic_clear_sint_msg_pending(struct kvm_vcpu_hv_synic *synic,\n\t\t\t\t\tu32 sint)\n{\n\tstruct kvm_vcpu *vcpu = synic_to_vcpu(synic);\n\tstruct page *page;\n\tgpa_t gpa;\n\tstruct hv_message *msg;\n\tstruct hv_message_page *msg_page;\n\n\tgpa = synic->msg_page & PAGE_MASK;\n\tpage = kvm_vcpu_gfn_to_page(vcpu, gpa >> PAGE_SHIFT);\n\tif (is_error_page(page)) {\n\t\tvcpu_err(vcpu, \"Hyper-V SynIC can't get msg page, gpa 0x%llx\\n\",\n\t\t\t gpa);\n\t\treturn;\n\t}\n\tmsg_page = kmap_atomic(page);\n\n\tmsg = &msg_page->sint_message[sint];\n\tmsg->header.message_flags.msg_pending = 0;\n\n\tkunmap_atomic(msg_page);\n\tkvm_release_page_dirty(page);\n\tkvm_vcpu_mark_page_dirty(vcpu, gpa >> PAGE_SHIFT);\n}"
  },
  {
    "function_name": "synic_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.c",
    "lines": "107-119",
    "snippet": "static struct kvm_vcpu_hv_synic *synic_get(struct kvm *kvm, u32 vcpu_id)\n{\n\tstruct kvm_vcpu *vcpu;\n\tstruct kvm_vcpu_hv_synic *synic;\n\n\tif (vcpu_id >= atomic_read(&kvm->online_vcpus))\n\t\treturn NULL;\n\tvcpu = kvm_get_vcpu(kvm, vcpu_id);\n\tif (!vcpu)\n\t\treturn NULL;\n\tsynic = vcpu_to_synic(vcpu);\n\treturn (synic->active) ? synic : NULL;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/apicdef.h>",
      "#include <linux/highmem.h>",
      "#include <linux/kvm_host.h>",
      "#include \"hyperv.h\"",
      "#include \"ioapic.h\"",
      "#include \"lapic.h\"",
      "#include \"x86.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vcpu_to_synic",
          "args": [
            "vcpu"
          ],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "vcpu_to_synic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.h",
          "lines": "40-43",
          "snippet": "static inline struct kvm_vcpu_hv_synic *vcpu_to_synic(struct kvm_vcpu *vcpu)\n{\n\treturn &vcpu->arch.hyperv.synic;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct kvm_vcpu_hv_synic *vcpu_to_synic(struct kvm_vcpu *vcpu)\n{\n\treturn &vcpu->arch.hyperv.synic;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_get_vcpu",
          "args": [
            "kvm",
            "vcpu_id"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&kvm->online_vcpus"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic struct kvm_vcpu_hv_synic *synic_get(struct kvm *kvm, u32 vcpu_id)\n{\n\tstruct kvm_vcpu *vcpu;\n\tstruct kvm_vcpu_hv_synic *synic;\n\n\tif (vcpu_id >= atomic_read(&kvm->online_vcpus))\n\t\treturn NULL;\n\tvcpu = kvm_get_vcpu(kvm, vcpu_id);\n\tif (!vcpu)\n\t\treturn NULL;\n\tsynic = vcpu_to_synic(vcpu);\n\treturn (synic->active) ? synic : NULL;\n}"
  },
  {
    "function_name": "synic_set_sint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.c",
    "lines": "75-105",
    "snippet": "static int synic_set_sint(struct kvm_vcpu_hv_synic *synic, int sint,\n\t\t\t  u64 data, bool host)\n{\n\tint vector;\n\n\tvector = data & HV_SYNIC_SINT_VECTOR_MASK;\n\tif (vector < 16 && !host)\n\t\treturn 1;\n\t/*\n\t * Guest may configure multiple SINTs to use the same vector, so\n\t * we maintain a bitmap of vectors handled by synic, and a\n\t * bitmap of vectors with auto-eoi behavior.  The bitmaps are\n\t * updated here, and atomically queried on fast paths.\n\t */\n\n\tatomic64_set(&synic->sint[sint], data);\n\n\tif (synic_has_vector_connected(synic, vector))\n\t\t__set_bit(vector, synic->vec_bitmap);\n\telse\n\t\t__clear_bit(vector, synic->vec_bitmap);\n\n\tif (synic_has_vector_auto_eoi(synic, vector))\n\t\t__set_bit(vector, synic->auto_eoi_bitmap);\n\telse\n\t\t__clear_bit(vector, synic->auto_eoi_bitmap);\n\n\t/* Load SynIC vectors into EOI exit bitmap */\n\tkvm_make_request(KVM_REQ_SCAN_IOAPIC, synic_to_vcpu(synic));\n\treturn 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/apicdef.h>",
      "#include <linux/highmem.h>",
      "#include <linux/kvm_host.h>",
      "#include \"hyperv.h\"",
      "#include \"ioapic.h\"",
      "#include \"lapic.h\"",
      "#include \"x86.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_make_request",
          "args": [
            "KVM_REQ_SCAN_IOAPIC",
            "synic_to_vcpu(synic)"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "synic_to_vcpu",
          "args": [
            "synic"
          ],
          "line": 103
        },
        "resolved": true,
        "details": {
          "function_name": "synic_to_vcpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.h",
          "lines": "45-48",
          "snippet": "static inline struct kvm_vcpu *synic_to_vcpu(struct kvm_vcpu_hv_synic *synic)\n{\n\treturn hv_vcpu_to_vcpu(container_of(synic, struct kvm_vcpu_hv, synic));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct kvm_vcpu *synic_to_vcpu(struct kvm_vcpu_hv_synic *synic)\n{\n\treturn hv_vcpu_to_vcpu(container_of(synic, struct kvm_vcpu_hv, synic));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__clear_bit",
          "args": [
            "vector",
            "synic->auto_eoi_bitmap"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__set_bit",
          "args": [
            "vector",
            "synic->auto_eoi_bitmap"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "synic_has_vector_auto_eoi",
          "args": [
            "synic",
            "vector"
          ],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "synic_has_vector_auto_eoi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.c",
          "lines": "60-73",
          "snippet": "static bool synic_has_vector_auto_eoi(struct kvm_vcpu_hv_synic *synic,\n\t\t\t\t     int vector)\n{\n\tint i;\n\tu64 sint_value;\n\n\tfor (i = 0; i < ARRAY_SIZE(synic->sint); i++) {\n\t\tsint_value = synic_read_sint(synic, i);\n\t\tif (synic_get_sint_vector(sint_value) == vector &&\n\t\t    sint_value & HV_SYNIC_SINT_AUTO_EOI)\n\t\t\treturn true;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic bool synic_has_vector_auto_eoi(struct kvm_vcpu_hv_synic *synic,\n\t\t\t\t     int vector)\n{\n\tint i;\n\tu64 sint_value;\n\n\tfor (i = 0; i < ARRAY_SIZE(synic->sint); i++) {\n\t\tsint_value = synic_read_sint(synic, i);\n\t\tif (synic_get_sint_vector(sint_value) == vector &&\n\t\t    sint_value & HV_SYNIC_SINT_AUTO_EOI)\n\t\t\treturn true;\n\t}\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__clear_bit",
          "args": [
            "vector",
            "synic->vec_bitmap"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__set_bit",
          "args": [
            "vector",
            "synic->vec_bitmap"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "synic_has_vector_connected",
          "args": [
            "synic",
            "vector"
          ],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "synic_has_vector_connected",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.c",
          "lines": "48-58",
          "snippet": "static bool synic_has_vector_connected(struct kvm_vcpu_hv_synic *synic,\n\t\t\t\t      int vector)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(synic->sint); i++) {\n\t\tif (synic_get_sint_vector(synic_read_sint(synic, i)) == vector)\n\t\t\treturn true;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic bool synic_has_vector_connected(struct kvm_vcpu_hv_synic *synic,\n\t\t\t\t      int vector)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(synic->sint); i++) {\n\t\tif (synic_get_sint_vector(synic_read_sint(synic, i)) == vector)\n\t\t\treturn true;\n\t}\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic64_set",
          "args": [
            "&synic->sint[sint]",
            "data"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic int synic_set_sint(struct kvm_vcpu_hv_synic *synic, int sint,\n\t\t\t  u64 data, bool host)\n{\n\tint vector;\n\n\tvector = data & HV_SYNIC_SINT_VECTOR_MASK;\n\tif (vector < 16 && !host)\n\t\treturn 1;\n\t/*\n\t * Guest may configure multiple SINTs to use the same vector, so\n\t * we maintain a bitmap of vectors handled by synic, and a\n\t * bitmap of vectors with auto-eoi behavior.  The bitmaps are\n\t * updated here, and atomically queried on fast paths.\n\t */\n\n\tatomic64_set(&synic->sint[sint], data);\n\n\tif (synic_has_vector_connected(synic, vector))\n\t\t__set_bit(vector, synic->vec_bitmap);\n\telse\n\t\t__clear_bit(vector, synic->vec_bitmap);\n\n\tif (synic_has_vector_auto_eoi(synic, vector))\n\t\t__set_bit(vector, synic->auto_eoi_bitmap);\n\telse\n\t\t__clear_bit(vector, synic->auto_eoi_bitmap);\n\n\t/* Load SynIC vectors into EOI exit bitmap */\n\tkvm_make_request(KVM_REQ_SCAN_IOAPIC, synic_to_vcpu(synic));\n\treturn 0;\n}"
  },
  {
    "function_name": "synic_has_vector_auto_eoi",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.c",
    "lines": "60-73",
    "snippet": "static bool synic_has_vector_auto_eoi(struct kvm_vcpu_hv_synic *synic,\n\t\t\t\t     int vector)\n{\n\tint i;\n\tu64 sint_value;\n\n\tfor (i = 0; i < ARRAY_SIZE(synic->sint); i++) {\n\t\tsint_value = synic_read_sint(synic, i);\n\t\tif (synic_get_sint_vector(sint_value) == vector &&\n\t\t    sint_value & HV_SYNIC_SINT_AUTO_EOI)\n\t\t\treturn true;\n\t}\n\treturn false;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/apicdef.h>",
      "#include <linux/highmem.h>",
      "#include <linux/kvm_host.h>",
      "#include \"hyperv.h\"",
      "#include \"ioapic.h\"",
      "#include \"lapic.h\"",
      "#include \"x86.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "synic_get_sint_vector",
          "args": [
            "sint_value"
          ],
          "line": 68
        },
        "resolved": true,
        "details": {
          "function_name": "synic_get_sint_vector",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.c",
          "lines": "41-46",
          "snippet": "static inline int synic_get_sint_vector(u64 sint_value)\n{\n\tif (sint_value & HV_SYNIC_SINT_MASKED)\n\t\treturn -1;\n\treturn sint_value & HV_SYNIC_SINT_VECTOR_MASK;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic inline int synic_get_sint_vector(u64 sint_value)\n{\n\tif (sint_value & HV_SYNIC_SINT_MASKED)\n\t\treturn -1;\n\treturn sint_value & HV_SYNIC_SINT_VECTOR_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "synic_read_sint",
          "args": [
            "synic",
            "i"
          ],
          "line": 67
        },
        "resolved": true,
        "details": {
          "function_name": "synic_read_sint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.c",
          "lines": "36-39",
          "snippet": "static inline u64 synic_read_sint(struct kvm_vcpu_hv_synic *synic, int sint)\n{\n\treturn atomic64_read(&synic->sint[sint]);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic inline u64 synic_read_sint(struct kvm_vcpu_hv_synic *synic, int sint)\n{\n\treturn atomic64_read(&synic->sint[sint]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "synic->sint"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic bool synic_has_vector_auto_eoi(struct kvm_vcpu_hv_synic *synic,\n\t\t\t\t     int vector)\n{\n\tint i;\n\tu64 sint_value;\n\n\tfor (i = 0; i < ARRAY_SIZE(synic->sint); i++) {\n\t\tsint_value = synic_read_sint(synic, i);\n\t\tif (synic_get_sint_vector(sint_value) == vector &&\n\t\t    sint_value & HV_SYNIC_SINT_AUTO_EOI)\n\t\t\treturn true;\n\t}\n\treturn false;\n}"
  },
  {
    "function_name": "synic_has_vector_connected",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.c",
    "lines": "48-58",
    "snippet": "static bool synic_has_vector_connected(struct kvm_vcpu_hv_synic *synic,\n\t\t\t\t      int vector)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(synic->sint); i++) {\n\t\tif (synic_get_sint_vector(synic_read_sint(synic, i)) == vector)\n\t\t\treturn true;\n\t}\n\treturn false;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/apicdef.h>",
      "#include <linux/highmem.h>",
      "#include <linux/kvm_host.h>",
      "#include \"hyperv.h\"",
      "#include \"ioapic.h\"",
      "#include \"lapic.h\"",
      "#include \"x86.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "synic_get_sint_vector",
          "args": [
            "synic_read_sint(synic, i)"
          ],
          "line": 54
        },
        "resolved": true,
        "details": {
          "function_name": "synic_get_sint_vector",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.c",
          "lines": "41-46",
          "snippet": "static inline int synic_get_sint_vector(u64 sint_value)\n{\n\tif (sint_value & HV_SYNIC_SINT_MASKED)\n\t\treturn -1;\n\treturn sint_value & HV_SYNIC_SINT_VECTOR_MASK;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic inline int synic_get_sint_vector(u64 sint_value)\n{\n\tif (sint_value & HV_SYNIC_SINT_MASKED)\n\t\treturn -1;\n\treturn sint_value & HV_SYNIC_SINT_VECTOR_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "synic_read_sint",
          "args": [
            "synic",
            "i"
          ],
          "line": 54
        },
        "resolved": true,
        "details": {
          "function_name": "synic_read_sint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.c",
          "lines": "36-39",
          "snippet": "static inline u64 synic_read_sint(struct kvm_vcpu_hv_synic *synic, int sint)\n{\n\treturn atomic64_read(&synic->sint[sint]);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic inline u64 synic_read_sint(struct kvm_vcpu_hv_synic *synic, int sint)\n{\n\treturn atomic64_read(&synic->sint[sint]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "synic->sint"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic bool synic_has_vector_connected(struct kvm_vcpu_hv_synic *synic,\n\t\t\t\t      int vector)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(synic->sint); i++) {\n\t\tif (synic_get_sint_vector(synic_read_sint(synic, i)) == vector)\n\t\t\treturn true;\n\t}\n\treturn false;\n}"
  },
  {
    "function_name": "synic_get_sint_vector",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.c",
    "lines": "41-46",
    "snippet": "static inline int synic_get_sint_vector(u64 sint_value)\n{\n\tif (sint_value & HV_SYNIC_SINT_MASKED)\n\t\treturn -1;\n\treturn sint_value & HV_SYNIC_SINT_VECTOR_MASK;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/apicdef.h>",
      "#include <linux/highmem.h>",
      "#include <linux/kvm_host.h>",
      "#include \"hyperv.h\"",
      "#include \"ioapic.h\"",
      "#include \"lapic.h\"",
      "#include \"x86.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic inline int synic_get_sint_vector(u64 sint_value)\n{\n\tif (sint_value & HV_SYNIC_SINT_MASKED)\n\t\treturn -1;\n\treturn sint_value & HV_SYNIC_SINT_VECTOR_MASK;\n}"
  },
  {
    "function_name": "synic_read_sint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.c",
    "lines": "36-39",
    "snippet": "static inline u64 synic_read_sint(struct kvm_vcpu_hv_synic *synic, int sint)\n{\n\treturn atomic64_read(&synic->sint[sint]);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/apicdef.h>",
      "#include <linux/highmem.h>",
      "#include <linux/kvm_host.h>",
      "#include \"hyperv.h\"",
      "#include \"ioapic.h\"",
      "#include \"lapic.h\"",
      "#include \"x86.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic64_read",
          "args": [
            "&synic->sint[sint]"
          ],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic inline u64 synic_read_sint(struct kvm_vcpu_hv_synic *synic, int sint)\n{\n\treturn atomic64_read(&synic->sint[sint]);\n}"
  }
]