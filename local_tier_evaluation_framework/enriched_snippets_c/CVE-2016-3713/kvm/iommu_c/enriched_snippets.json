[
  {
    "function_name": "kvm_iommu_unmap_guest",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/iommu.c",
    "lines": "342-358",
    "snippet": "int kvm_iommu_unmap_guest(struct kvm *kvm)\n{\n\tstruct iommu_domain *domain = kvm->arch.iommu_domain;\n\n\t/* check if iommu exists and in use */\n\tif (!domain)\n\t\treturn 0;\n\n\tmutex_lock(&kvm->slots_lock);\n\tkvm_iommu_unmap_memslots(kvm);\n\tkvm->arch.iommu_domain = NULL;\n\tkvm->arch.iommu_noncoherent = false;\n\tmutex_unlock(&kvm->slots_lock);\n\n\tiommu_domain_free(domain);\n\treturn 0;\n}",
    "includes": [
      "#include \"assigned-dev.h\"",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/dmar.h>",
      "#include <linux/stat.h>",
      "#include <linux/pci.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int kvm_iommu_unmap_memslots(struct kvm *kvm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "iommu_domain_free",
          "args": [
            "domain"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&kvm->slots_lock"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_iommu_unmap_memslots",
          "args": [
            "kvm"
          ],
          "line": 351
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_iommu_unmap_memslots",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/iommu.c",
          "lines": "322-340",
          "snippet": "static int kvm_iommu_unmap_memslots(struct kvm *kvm)\n{\n\tint idx;\n\tstruct kvm_memslots *slots;\n\tstruct kvm_memory_slot *memslot;\n\n\tidx = srcu_read_lock(&kvm->srcu);\n\tslots = kvm_memslots(kvm);\n\n\tkvm_for_each_memslot(memslot, slots)\n\t\tkvm_iommu_unmap_pages(kvm, memslot);\n\n\tsrcu_read_unlock(&kvm->srcu, idx);\n\n\tif (kvm->arch.iommu_noncoherent)\n\t\tkvm_arch_unregister_noncoherent_dma(kvm);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"assigned-dev.h\"",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/dmar.h>",
            "#include <linux/stat.h>",
            "#include <linux/pci.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int kvm_iommu_unmap_memslots(struct kvm *kvm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"assigned-dev.h\"\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/dmar.h>\n#include <linux/stat.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/list.h>\n\nstatic int kvm_iommu_unmap_memslots(struct kvm *kvm);\n\nstatic int kvm_iommu_unmap_memslots(struct kvm *kvm)\n{\n\tint idx;\n\tstruct kvm_memslots *slots;\n\tstruct kvm_memory_slot *memslot;\n\n\tidx = srcu_read_lock(&kvm->srcu);\n\tslots = kvm_memslots(kvm);\n\n\tkvm_for_each_memslot(memslot, slots)\n\t\tkvm_iommu_unmap_pages(kvm, memslot);\n\n\tsrcu_read_unlock(&kvm->srcu, idx);\n\n\tif (kvm->arch.iommu_noncoherent)\n\t\tkvm_arch_unregister_noncoherent_dma(kvm);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&kvm->slots_lock"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"assigned-dev.h\"\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/dmar.h>\n#include <linux/stat.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/list.h>\n\nstatic int kvm_iommu_unmap_memslots(struct kvm *kvm);\n\nint kvm_iommu_unmap_guest(struct kvm *kvm)\n{\n\tstruct iommu_domain *domain = kvm->arch.iommu_domain;\n\n\t/* check if iommu exists and in use */\n\tif (!domain)\n\t\treturn 0;\n\n\tmutex_lock(&kvm->slots_lock);\n\tkvm_iommu_unmap_memslots(kvm);\n\tkvm->arch.iommu_domain = NULL;\n\tkvm->arch.iommu_noncoherent = false;\n\tmutex_unlock(&kvm->slots_lock);\n\n\tiommu_domain_free(domain);\n\treturn 0;\n}"
  },
  {
    "function_name": "kvm_iommu_unmap_memslots",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/iommu.c",
    "lines": "322-340",
    "snippet": "static int kvm_iommu_unmap_memslots(struct kvm *kvm)\n{\n\tint idx;\n\tstruct kvm_memslots *slots;\n\tstruct kvm_memory_slot *memslot;\n\n\tidx = srcu_read_lock(&kvm->srcu);\n\tslots = kvm_memslots(kvm);\n\n\tkvm_for_each_memslot(memslot, slots)\n\t\tkvm_iommu_unmap_pages(kvm, memslot);\n\n\tsrcu_read_unlock(&kvm->srcu, idx);\n\n\tif (kvm->arch.iommu_noncoherent)\n\t\tkvm_arch_unregister_noncoherent_dma(kvm);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"assigned-dev.h\"",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/dmar.h>",
      "#include <linux/stat.h>",
      "#include <linux/pci.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int kvm_iommu_unmap_memslots(struct kvm *kvm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_arch_unregister_noncoherent_dma",
          "args": [
            "kvm"
          ],
          "line": 337
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_arch_unregister_noncoherent_dma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "8355-8358",
          "snippet": "void kvm_arch_unregister_noncoherent_dma(struct kvm *kvm)\n{\n\tatomic_dec(&kvm->arch.noncoherent_dma_count);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nvoid kvm_arch_unregister_noncoherent_dma(struct kvm *kvm)\n{\n\tatomic_dec(&kvm->arch.noncoherent_dma_count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "srcu_read_unlock",
          "args": [
            "&kvm->srcu",
            "idx"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_iommu_unmap_pages",
          "args": [
            "kvm",
            "memslot"
          ],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_iommu_unmap_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/iommu.c",
          "lines": "317-320",
          "snippet": "void kvm_iommu_unmap_pages(struct kvm *kvm, struct kvm_memory_slot *slot)\n{\n\tkvm_iommu_put_pages(kvm, slot->base_gfn, slot->npages);\n}",
          "includes": [
            "#include \"assigned-dev.h\"",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/dmar.h>",
            "#include <linux/stat.h>",
            "#include <linux/pci.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int kvm_iommu_unmap_memslots(struct kvm *kvm);",
            "static void kvm_iommu_put_pages(struct kvm *kvm,\n\t\t\t\tgfn_t base_gfn, unsigned long npages);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"assigned-dev.h\"\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/dmar.h>\n#include <linux/stat.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/list.h>\n\nstatic int kvm_iommu_unmap_memslots(struct kvm *kvm);\nstatic void kvm_iommu_put_pages(struct kvm *kvm,\n\t\t\t\tgfn_t base_gfn, unsigned long npages);\n\nvoid kvm_iommu_unmap_pages(struct kvm *kvm, struct kvm_memory_slot *slot)\n{\n\tkvm_iommu_put_pages(kvm, slot->base_gfn, slot->npages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_for_each_memslot",
          "args": [
            "memslot",
            "slots"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_memslots",
          "args": [
            "kvm"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "srcu_read_lock",
          "args": [
            "&kvm->srcu"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"assigned-dev.h\"\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/dmar.h>\n#include <linux/stat.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/list.h>\n\nstatic int kvm_iommu_unmap_memslots(struct kvm *kvm);\n\nstatic int kvm_iommu_unmap_memslots(struct kvm *kvm)\n{\n\tint idx;\n\tstruct kvm_memslots *slots;\n\tstruct kvm_memory_slot *memslot;\n\n\tidx = srcu_read_lock(&kvm->srcu);\n\tslots = kvm_memslots(kvm);\n\n\tkvm_for_each_memslot(memslot, slots)\n\t\tkvm_iommu_unmap_pages(kvm, memslot);\n\n\tsrcu_read_unlock(&kvm->srcu, idx);\n\n\tif (kvm->arch.iommu_noncoherent)\n\t\tkvm_arch_unregister_noncoherent_dma(kvm);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "kvm_iommu_unmap_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/iommu.c",
    "lines": "317-320",
    "snippet": "void kvm_iommu_unmap_pages(struct kvm *kvm, struct kvm_memory_slot *slot)\n{\n\tkvm_iommu_put_pages(kvm, slot->base_gfn, slot->npages);\n}",
    "includes": [
      "#include \"assigned-dev.h\"",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/dmar.h>",
      "#include <linux/stat.h>",
      "#include <linux/pci.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int kvm_iommu_unmap_memslots(struct kvm *kvm);",
      "static void kvm_iommu_put_pages(struct kvm *kvm,\n\t\t\t\tgfn_t base_gfn, unsigned long npages);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_iommu_put_pages",
          "args": [
            "kvm",
            "slot->base_gfn",
            "slot->npages"
          ],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_iommu_put_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/iommu.c",
          "lines": "274-315",
          "snippet": "static void kvm_iommu_put_pages(struct kvm *kvm,\n\t\t\t\tgfn_t base_gfn, unsigned long npages)\n{\n\tstruct iommu_domain *domain;\n\tgfn_t end_gfn, gfn;\n\tkvm_pfn_t pfn;\n\tu64 phys;\n\n\tdomain  = kvm->arch.iommu_domain;\n\tend_gfn = base_gfn + npages;\n\tgfn     = base_gfn;\n\n\t/* check if iommu exists and in use */\n\tif (!domain)\n\t\treturn;\n\n\twhile (gfn < end_gfn) {\n\t\tunsigned long unmap_pages;\n\t\tsize_t size;\n\n\t\t/* Get physical address */\n\t\tphys = iommu_iova_to_phys(domain, gfn_to_gpa(gfn));\n\n\t\tif (!phys) {\n\t\t\tgfn++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tpfn  = phys >> PAGE_SHIFT;\n\n\t\t/* Unmap address from IO address space */\n\t\tsize       = iommu_unmap(domain, gfn_to_gpa(gfn), PAGE_SIZE);\n\t\tunmap_pages = 1ULL << get_order(size);\n\n\t\t/* Unpin all pages we just unmapped to not leak any memory */\n\t\tkvm_unpin_pages(kvm, pfn, unmap_pages);\n\n\t\tgfn += unmap_pages;\n\n\t\tcond_resched();\n\t}\n}",
          "includes": [
            "#include \"assigned-dev.h\"",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/dmar.h>",
            "#include <linux/stat.h>",
            "#include <linux/pci.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int kvm_iommu_unmap_memslots(struct kvm *kvm);",
            "static void kvm_iommu_put_pages(struct kvm *kvm,\n\t\t\t\tgfn_t base_gfn, unsigned long npages);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"assigned-dev.h\"\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/dmar.h>\n#include <linux/stat.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/list.h>\n\nstatic int kvm_iommu_unmap_memslots(struct kvm *kvm);\nstatic void kvm_iommu_put_pages(struct kvm *kvm,\n\t\t\t\tgfn_t base_gfn, unsigned long npages);\n\nstatic void kvm_iommu_put_pages(struct kvm *kvm,\n\t\t\t\tgfn_t base_gfn, unsigned long npages)\n{\n\tstruct iommu_domain *domain;\n\tgfn_t end_gfn, gfn;\n\tkvm_pfn_t pfn;\n\tu64 phys;\n\n\tdomain  = kvm->arch.iommu_domain;\n\tend_gfn = base_gfn + npages;\n\tgfn     = base_gfn;\n\n\t/* check if iommu exists and in use */\n\tif (!domain)\n\t\treturn;\n\n\twhile (gfn < end_gfn) {\n\t\tunsigned long unmap_pages;\n\t\tsize_t size;\n\n\t\t/* Get physical address */\n\t\tphys = iommu_iova_to_phys(domain, gfn_to_gpa(gfn));\n\n\t\tif (!phys) {\n\t\t\tgfn++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tpfn  = phys >> PAGE_SHIFT;\n\n\t\t/* Unmap address from IO address space */\n\t\tsize       = iommu_unmap(domain, gfn_to_gpa(gfn), PAGE_SIZE);\n\t\tunmap_pages = 1ULL << get_order(size);\n\n\t\t/* Unpin all pages we just unmapped to not leak any memory */\n\t\tkvm_unpin_pages(kvm, pfn, unmap_pages);\n\n\t\tgfn += unmap_pages;\n\n\t\tcond_resched();\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"assigned-dev.h\"\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/dmar.h>\n#include <linux/stat.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/list.h>\n\nstatic int kvm_iommu_unmap_memslots(struct kvm *kvm);\nstatic void kvm_iommu_put_pages(struct kvm *kvm,\n\t\t\t\tgfn_t base_gfn, unsigned long npages);\n\nvoid kvm_iommu_unmap_pages(struct kvm *kvm, struct kvm_memory_slot *slot)\n{\n\tkvm_iommu_put_pages(kvm, slot->base_gfn, slot->npages);\n}"
  },
  {
    "function_name": "kvm_iommu_put_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/iommu.c",
    "lines": "274-315",
    "snippet": "static void kvm_iommu_put_pages(struct kvm *kvm,\n\t\t\t\tgfn_t base_gfn, unsigned long npages)\n{\n\tstruct iommu_domain *domain;\n\tgfn_t end_gfn, gfn;\n\tkvm_pfn_t pfn;\n\tu64 phys;\n\n\tdomain  = kvm->arch.iommu_domain;\n\tend_gfn = base_gfn + npages;\n\tgfn     = base_gfn;\n\n\t/* check if iommu exists and in use */\n\tif (!domain)\n\t\treturn;\n\n\twhile (gfn < end_gfn) {\n\t\tunsigned long unmap_pages;\n\t\tsize_t size;\n\n\t\t/* Get physical address */\n\t\tphys = iommu_iova_to_phys(domain, gfn_to_gpa(gfn));\n\n\t\tif (!phys) {\n\t\t\tgfn++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tpfn  = phys >> PAGE_SHIFT;\n\n\t\t/* Unmap address from IO address space */\n\t\tsize       = iommu_unmap(domain, gfn_to_gpa(gfn), PAGE_SIZE);\n\t\tunmap_pages = 1ULL << get_order(size);\n\n\t\t/* Unpin all pages we just unmapped to not leak any memory */\n\t\tkvm_unpin_pages(kvm, pfn, unmap_pages);\n\n\t\tgfn += unmap_pages;\n\n\t\tcond_resched();\n\t}\n}",
    "includes": [
      "#include \"assigned-dev.h\"",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/dmar.h>",
      "#include <linux/stat.h>",
      "#include <linux/pci.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int kvm_iommu_unmap_memslots(struct kvm *kvm);",
      "static void kvm_iommu_put_pages(struct kvm *kvm,\n\t\t\t\tgfn_t base_gfn, unsigned long npages);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_unpin_pages",
          "args": [
            "kvm",
            "pfn",
            "unmap_pages"
          ],
          "line": 309
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_unpin_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/iommu.c",
          "lines": "65-72",
          "snippet": "static void kvm_unpin_pages(struct kvm *kvm, kvm_pfn_t pfn,\n\t\tunsigned long npages)\n{\n\tunsigned long i;\n\n\tfor (i = 0; i < npages; ++i)\n\t\tkvm_release_pfn_clean(pfn + i);\n}",
          "includes": [
            "#include \"assigned-dev.h\"",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/dmar.h>",
            "#include <linux/stat.h>",
            "#include <linux/pci.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int kvm_iommu_unmap_memslots(struct kvm *kvm);",
            "static void kvm_iommu_put_pages(struct kvm *kvm,\n\t\t\t\tgfn_t base_gfn, unsigned long npages);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"assigned-dev.h\"\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/dmar.h>\n#include <linux/stat.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/list.h>\n\nstatic int kvm_iommu_unmap_memslots(struct kvm *kvm);\nstatic void kvm_iommu_put_pages(struct kvm *kvm,\n\t\t\t\tgfn_t base_gfn, unsigned long npages);\n\nstatic void kvm_unpin_pages(struct kvm *kvm, kvm_pfn_t pfn,\n\t\tunsigned long npages)\n{\n\tunsigned long i;\n\n\tfor (i = 0; i < npages; ++i)\n\t\tkvm_release_pfn_clean(pfn + i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_order",
          "args": [
            "size"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iommu_unmap",
          "args": [
            "domain",
            "gfn_to_gpa(gfn)",
            "PAGE_SIZE"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfn_to_gpa",
          "args": [
            "gfn"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iommu_iova_to_phys",
          "args": [
            "domain",
            "gfn_to_gpa(gfn)"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfn_to_gpa",
          "args": [
            "gfn"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"assigned-dev.h\"\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/dmar.h>\n#include <linux/stat.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/list.h>\n\nstatic int kvm_iommu_unmap_memslots(struct kvm *kvm);\nstatic void kvm_iommu_put_pages(struct kvm *kvm,\n\t\t\t\tgfn_t base_gfn, unsigned long npages);\n\nstatic void kvm_iommu_put_pages(struct kvm *kvm,\n\t\t\t\tgfn_t base_gfn, unsigned long npages)\n{\n\tstruct iommu_domain *domain;\n\tgfn_t end_gfn, gfn;\n\tkvm_pfn_t pfn;\n\tu64 phys;\n\n\tdomain  = kvm->arch.iommu_domain;\n\tend_gfn = base_gfn + npages;\n\tgfn     = base_gfn;\n\n\t/* check if iommu exists and in use */\n\tif (!domain)\n\t\treturn;\n\n\twhile (gfn < end_gfn) {\n\t\tunsigned long unmap_pages;\n\t\tsize_t size;\n\n\t\t/* Get physical address */\n\t\tphys = iommu_iova_to_phys(domain, gfn_to_gpa(gfn));\n\n\t\tif (!phys) {\n\t\t\tgfn++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tpfn  = phys >> PAGE_SHIFT;\n\n\t\t/* Unmap address from IO address space */\n\t\tsize       = iommu_unmap(domain, gfn_to_gpa(gfn), PAGE_SIZE);\n\t\tunmap_pages = 1ULL << get_order(size);\n\n\t\t/* Unpin all pages we just unmapped to not leak any memory */\n\t\tkvm_unpin_pages(kvm, pfn, unmap_pages);\n\n\t\tgfn += unmap_pages;\n\n\t\tcond_resched();\n\t}\n}"
  },
  {
    "function_name": "kvm_iommu_map_guest",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/iommu.c",
    "lines": "236-272",
    "snippet": "int kvm_iommu_map_guest(struct kvm *kvm)\n{\n\tint r;\n\n\tif (!iommu_present(&pci_bus_type)) {\n\t\tprintk(KERN_ERR \"%s: iommu not found\\n\", __func__);\n\t\treturn -ENODEV;\n\t}\n\n\tmutex_lock(&kvm->slots_lock);\n\n\tkvm->arch.iommu_domain = iommu_domain_alloc(&pci_bus_type);\n\tif (!kvm->arch.iommu_domain) {\n\t\tr = -ENOMEM;\n\t\tgoto out_unlock;\n\t}\n\n\tif (!allow_unsafe_assigned_interrupts &&\n\t    !iommu_capable(&pci_bus_type, IOMMU_CAP_INTR_REMAP)) {\n\t\tprintk(KERN_WARNING \"%s: No interrupt remapping support,\"\n\t\t       \" disallowing device assignment.\"\n\t\t       \" Re-enble with \\\"allow_unsafe_assigned_interrupts=1\\\"\"\n\t\t       \" module option.\\n\", __func__);\n\t\tiommu_domain_free(kvm->arch.iommu_domain);\n\t\tkvm->arch.iommu_domain = NULL;\n\t\tr = -EPERM;\n\t\tgoto out_unlock;\n\t}\n\n\tr = kvm_iommu_map_memslots(kvm);\n\tif (r)\n\t\tkvm_iommu_unmap_memslots(kvm);\n\nout_unlock:\n\tmutex_unlock(&kvm->slots_lock);\n\treturn r;\n}",
    "includes": [
      "#include \"assigned-dev.h\"",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/dmar.h>",
      "#include <linux/stat.h>",
      "#include <linux/pci.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool allow_unsafe_assigned_interrupts;",
      "static int kvm_iommu_unmap_memslots(struct kvm *kvm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&kvm->slots_lock"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_iommu_unmap_memslots",
          "args": [
            "kvm"
          ],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_iommu_unmap_memslots",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/iommu.c",
          "lines": "322-340",
          "snippet": "static int kvm_iommu_unmap_memslots(struct kvm *kvm)\n{\n\tint idx;\n\tstruct kvm_memslots *slots;\n\tstruct kvm_memory_slot *memslot;\n\n\tidx = srcu_read_lock(&kvm->srcu);\n\tslots = kvm_memslots(kvm);\n\n\tkvm_for_each_memslot(memslot, slots)\n\t\tkvm_iommu_unmap_pages(kvm, memslot);\n\n\tsrcu_read_unlock(&kvm->srcu, idx);\n\n\tif (kvm->arch.iommu_noncoherent)\n\t\tkvm_arch_unregister_noncoherent_dma(kvm);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"assigned-dev.h\"",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/dmar.h>",
            "#include <linux/stat.h>",
            "#include <linux/pci.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int kvm_iommu_unmap_memslots(struct kvm *kvm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"assigned-dev.h\"\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/dmar.h>\n#include <linux/stat.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/list.h>\n\nstatic int kvm_iommu_unmap_memslots(struct kvm *kvm);\n\nstatic int kvm_iommu_unmap_memslots(struct kvm *kvm)\n{\n\tint idx;\n\tstruct kvm_memslots *slots;\n\tstruct kvm_memory_slot *memslot;\n\n\tidx = srcu_read_lock(&kvm->srcu);\n\tslots = kvm_memslots(kvm);\n\n\tkvm_for_each_memslot(memslot, slots)\n\t\tkvm_iommu_unmap_pages(kvm, memslot);\n\n\tsrcu_read_unlock(&kvm->srcu, idx);\n\n\tif (kvm->arch.iommu_noncoherent)\n\t\tkvm_arch_unregister_noncoherent_dma(kvm);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_iommu_map_memslots",
          "args": [
            "kvm"
          ],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_iommu_map_memslots",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/iommu.c",
          "lines": "152-172",
          "snippet": "static int kvm_iommu_map_memslots(struct kvm *kvm)\n{\n\tint idx, r = 0;\n\tstruct kvm_memslots *slots;\n\tstruct kvm_memory_slot *memslot;\n\n\tif (kvm->arch.iommu_noncoherent)\n\t\tkvm_arch_register_noncoherent_dma(kvm);\n\n\tidx = srcu_read_lock(&kvm->srcu);\n\tslots = kvm_memslots(kvm);\n\n\tkvm_for_each_memslot(memslot, slots) {\n\t\tr = kvm_iommu_map_pages(kvm, memslot);\n\t\tif (r)\n\t\t\tbreak;\n\t}\n\tsrcu_read_unlock(&kvm->srcu, idx);\n\n\treturn r;\n}",
          "includes": [
            "#include \"assigned-dev.h\"",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/dmar.h>",
            "#include <linux/stat.h>",
            "#include <linux/pci.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int kvm_iommu_unmap_memslots(struct kvm *kvm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"assigned-dev.h\"\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/dmar.h>\n#include <linux/stat.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/list.h>\n\nstatic int kvm_iommu_unmap_memslots(struct kvm *kvm);\n\nstatic int kvm_iommu_map_memslots(struct kvm *kvm)\n{\n\tint idx, r = 0;\n\tstruct kvm_memslots *slots;\n\tstruct kvm_memory_slot *memslot;\n\n\tif (kvm->arch.iommu_noncoherent)\n\t\tkvm_arch_register_noncoherent_dma(kvm);\n\n\tidx = srcu_read_lock(&kvm->srcu);\n\tslots = kvm_memslots(kvm);\n\n\tkvm_for_each_memslot(memslot, slots) {\n\t\tr = kvm_iommu_map_pages(kvm, memslot);\n\t\tif (r)\n\t\t\tbreak;\n\t}\n\tsrcu_read_unlock(&kvm->srcu, idx);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iommu_domain_free",
          "args": [
            "kvm->arch.iommu_domain"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"%s: No interrupt remapping support,\"\n\t\t       \" disallowing device assignment.\"\n\t\t       \" Re-enble with \\\"allow_unsafe_assigned_interrupts=1\\\"\"\n\t\t       \" module option.\\n\"",
            "__func__"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iommu_capable",
          "args": [
            "&pci_bus_type",
            "IOMMU_CAP_INTR_REMAP"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iommu_domain_alloc",
          "args": [
            "&pci_bus_type"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&kvm->slots_lock"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"%s: iommu not found\\n\"",
            "__func__"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iommu_present",
          "args": [
            "&pci_bus_type"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"assigned-dev.h\"\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/dmar.h>\n#include <linux/stat.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/list.h>\n\nstatic bool allow_unsafe_assigned_interrupts;\nstatic int kvm_iommu_unmap_memslots(struct kvm *kvm);\n\nint kvm_iommu_map_guest(struct kvm *kvm)\n{\n\tint r;\n\n\tif (!iommu_present(&pci_bus_type)) {\n\t\tprintk(KERN_ERR \"%s: iommu not found\\n\", __func__);\n\t\treturn -ENODEV;\n\t}\n\n\tmutex_lock(&kvm->slots_lock);\n\n\tkvm->arch.iommu_domain = iommu_domain_alloc(&pci_bus_type);\n\tif (!kvm->arch.iommu_domain) {\n\t\tr = -ENOMEM;\n\t\tgoto out_unlock;\n\t}\n\n\tif (!allow_unsafe_assigned_interrupts &&\n\t    !iommu_capable(&pci_bus_type, IOMMU_CAP_INTR_REMAP)) {\n\t\tprintk(KERN_WARNING \"%s: No interrupt remapping support,\"\n\t\t       \" disallowing device assignment.\"\n\t\t       \" Re-enble with \\\"allow_unsafe_assigned_interrupts=1\\\"\"\n\t\t       \" module option.\\n\", __func__);\n\t\tiommu_domain_free(kvm->arch.iommu_domain);\n\t\tkvm->arch.iommu_domain = NULL;\n\t\tr = -EPERM;\n\t\tgoto out_unlock;\n\t}\n\n\tr = kvm_iommu_map_memslots(kvm);\n\tif (r)\n\t\tkvm_iommu_unmap_memslots(kvm);\n\nout_unlock:\n\tmutex_unlock(&kvm->slots_lock);\n\treturn r;\n}"
  },
  {
    "function_name": "kvm_deassign_device",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/iommu.c",
    "lines": "215-234",
    "snippet": "int kvm_deassign_device(struct kvm *kvm, struct pci_dev *pdev)\n{\n\tstruct iommu_domain *domain = kvm->arch.iommu_domain;\n\n\t/* check if iommu exists and in use */\n\tif (!domain)\n\t\treturn 0;\n\n\tif (pdev == NULL)\n\t\treturn -ENODEV;\n\n\tiommu_detach_device(domain, &pdev->dev);\n\n\tpci_clear_dev_assigned(pdev);\n\tkvm_arch_end_assignment(kvm);\n\n\tdev_info(&pdev->dev, \"kvm deassign device\\n\");\n\n\treturn 0;\n}",
    "includes": [
      "#include \"assigned-dev.h\"",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/dmar.h>",
      "#include <linux/stat.h>",
      "#include <linux/pci.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int kvm_iommu_unmap_memslots(struct kvm *kvm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dev_info",
          "args": [
            "&pdev->dev",
            "\"kvm deassign device\\n\""
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_arch_end_assignment",
          "args": [
            "kvm"
          ],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_arch_end_assignment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "8337-8340",
          "snippet": "void kvm_arch_end_assignment(struct kvm *kvm)\n{\n\tatomic_dec(&kvm->arch.assigned_device_count);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nvoid kvm_arch_end_assignment(struct kvm *kvm)\n{\n\tatomic_dec(&kvm->arch.assigned_device_count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pci_clear_dev_assigned",
          "args": [
            "pdev"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iommu_detach_device",
          "args": [
            "domain",
            "&pdev->dev"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"assigned-dev.h\"\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/dmar.h>\n#include <linux/stat.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/list.h>\n\nstatic int kvm_iommu_unmap_memslots(struct kvm *kvm);\n\nint kvm_deassign_device(struct kvm *kvm, struct pci_dev *pdev)\n{\n\tstruct iommu_domain *domain = kvm->arch.iommu_domain;\n\n\t/* check if iommu exists and in use */\n\tif (!domain)\n\t\treturn 0;\n\n\tif (pdev == NULL)\n\t\treturn -ENODEV;\n\n\tiommu_detach_device(domain, &pdev->dev);\n\n\tpci_clear_dev_assigned(pdev);\n\tkvm_arch_end_assignment(kvm);\n\n\tdev_info(&pdev->dev, \"kvm deassign device\\n\");\n\n\treturn 0;\n}"
  },
  {
    "function_name": "kvm_assign_device",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/iommu.c",
    "lines": "174-213",
    "snippet": "int kvm_assign_device(struct kvm *kvm, struct pci_dev *pdev)\n{\n\tstruct iommu_domain *domain = kvm->arch.iommu_domain;\n\tint r;\n\tbool noncoherent;\n\n\t/* check if iommu exists and in use */\n\tif (!domain)\n\t\treturn 0;\n\n\tif (pdev == NULL)\n\t\treturn -ENODEV;\n\n\tr = iommu_attach_device(domain, &pdev->dev);\n\tif (r) {\n\t\tdev_err(&pdev->dev, \"kvm assign device failed ret %d\", r);\n\t\treturn r;\n\t}\n\n\tnoncoherent = !iommu_capable(&pci_bus_type, IOMMU_CAP_CACHE_COHERENCY);\n\n\t/* Check if need to update IOMMU page table for guest memory */\n\tif (noncoherent != kvm->arch.iommu_noncoherent) {\n\t\tkvm_iommu_unmap_memslots(kvm);\n\t\tkvm->arch.iommu_noncoherent = noncoherent;\n\t\tr = kvm_iommu_map_memslots(kvm);\n\t\tif (r)\n\t\t\tgoto out_unmap;\n\t}\n\n\tkvm_arch_start_assignment(kvm);\n\tpci_set_dev_assigned(pdev);\n\n\tdev_info(&pdev->dev, \"kvm assign device\\n\");\n\n\treturn 0;\nout_unmap:\n\tkvm_iommu_unmap_memslots(kvm);\n\treturn r;\n}",
    "includes": [
      "#include \"assigned-dev.h\"",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/dmar.h>",
      "#include <linux/stat.h>",
      "#include <linux/pci.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int kvm_iommu_unmap_memslots(struct kvm *kvm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_iommu_unmap_memslots",
          "args": [
            "kvm"
          ],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_iommu_unmap_memslots",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/iommu.c",
          "lines": "322-340",
          "snippet": "static int kvm_iommu_unmap_memslots(struct kvm *kvm)\n{\n\tint idx;\n\tstruct kvm_memslots *slots;\n\tstruct kvm_memory_slot *memslot;\n\n\tidx = srcu_read_lock(&kvm->srcu);\n\tslots = kvm_memslots(kvm);\n\n\tkvm_for_each_memslot(memslot, slots)\n\t\tkvm_iommu_unmap_pages(kvm, memslot);\n\n\tsrcu_read_unlock(&kvm->srcu, idx);\n\n\tif (kvm->arch.iommu_noncoherent)\n\t\tkvm_arch_unregister_noncoherent_dma(kvm);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"assigned-dev.h\"",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/dmar.h>",
            "#include <linux/stat.h>",
            "#include <linux/pci.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int kvm_iommu_unmap_memslots(struct kvm *kvm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"assigned-dev.h\"\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/dmar.h>\n#include <linux/stat.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/list.h>\n\nstatic int kvm_iommu_unmap_memslots(struct kvm *kvm);\n\nstatic int kvm_iommu_unmap_memslots(struct kvm *kvm)\n{\n\tint idx;\n\tstruct kvm_memslots *slots;\n\tstruct kvm_memory_slot *memslot;\n\n\tidx = srcu_read_lock(&kvm->srcu);\n\tslots = kvm_memslots(kvm);\n\n\tkvm_for_each_memslot(memslot, slots)\n\t\tkvm_iommu_unmap_pages(kvm, memslot);\n\n\tsrcu_read_unlock(&kvm->srcu, idx);\n\n\tif (kvm->arch.iommu_noncoherent)\n\t\tkvm_arch_unregister_noncoherent_dma(kvm);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dev_info",
          "args": [
            "&pdev->dev",
            "\"kvm assign device\\n\""
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_set_dev_assigned",
          "args": [
            "pdev"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_arch_start_assignment",
          "args": [
            "kvm"
          ],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_arch_start_assignment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "8331-8334",
          "snippet": "void kvm_arch_start_assignment(struct kvm *kvm)\n{\n\tatomic_inc(&kvm->arch.assigned_device_count);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nvoid kvm_arch_start_assignment(struct kvm *kvm)\n{\n\tatomic_inc(&kvm->arch.assigned_device_count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_iommu_map_memslots",
          "args": [
            "kvm"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_iommu_map_memslots",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/iommu.c",
          "lines": "152-172",
          "snippet": "static int kvm_iommu_map_memslots(struct kvm *kvm)\n{\n\tint idx, r = 0;\n\tstruct kvm_memslots *slots;\n\tstruct kvm_memory_slot *memslot;\n\n\tif (kvm->arch.iommu_noncoherent)\n\t\tkvm_arch_register_noncoherent_dma(kvm);\n\n\tidx = srcu_read_lock(&kvm->srcu);\n\tslots = kvm_memslots(kvm);\n\n\tkvm_for_each_memslot(memslot, slots) {\n\t\tr = kvm_iommu_map_pages(kvm, memslot);\n\t\tif (r)\n\t\t\tbreak;\n\t}\n\tsrcu_read_unlock(&kvm->srcu, idx);\n\n\treturn r;\n}",
          "includes": [
            "#include \"assigned-dev.h\"",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/dmar.h>",
            "#include <linux/stat.h>",
            "#include <linux/pci.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int kvm_iommu_unmap_memslots(struct kvm *kvm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"assigned-dev.h\"\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/dmar.h>\n#include <linux/stat.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/list.h>\n\nstatic int kvm_iommu_unmap_memslots(struct kvm *kvm);\n\nstatic int kvm_iommu_map_memslots(struct kvm *kvm)\n{\n\tint idx, r = 0;\n\tstruct kvm_memslots *slots;\n\tstruct kvm_memory_slot *memslot;\n\n\tif (kvm->arch.iommu_noncoherent)\n\t\tkvm_arch_register_noncoherent_dma(kvm);\n\n\tidx = srcu_read_lock(&kvm->srcu);\n\tslots = kvm_memslots(kvm);\n\n\tkvm_for_each_memslot(memslot, slots) {\n\t\tr = kvm_iommu_map_pages(kvm, memslot);\n\t\tif (r)\n\t\t\tbreak;\n\t}\n\tsrcu_read_unlock(&kvm->srcu, idx);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iommu_capable",
          "args": [
            "&pci_bus_type",
            "IOMMU_CAP_CACHE_COHERENCY"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_err",
          "args": [
            "&pdev->dev",
            "\"kvm assign device failed ret %d\"",
            "r"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iommu_attach_device",
          "args": [
            "domain",
            "&pdev->dev"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"assigned-dev.h\"\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/dmar.h>\n#include <linux/stat.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/list.h>\n\nstatic int kvm_iommu_unmap_memslots(struct kvm *kvm);\n\nint kvm_assign_device(struct kvm *kvm, struct pci_dev *pdev)\n{\n\tstruct iommu_domain *domain = kvm->arch.iommu_domain;\n\tint r;\n\tbool noncoherent;\n\n\t/* check if iommu exists and in use */\n\tif (!domain)\n\t\treturn 0;\n\n\tif (pdev == NULL)\n\t\treturn -ENODEV;\n\n\tr = iommu_attach_device(domain, &pdev->dev);\n\tif (r) {\n\t\tdev_err(&pdev->dev, \"kvm assign device failed ret %d\", r);\n\t\treturn r;\n\t}\n\n\tnoncoherent = !iommu_capable(&pci_bus_type, IOMMU_CAP_CACHE_COHERENCY);\n\n\t/* Check if need to update IOMMU page table for guest memory */\n\tif (noncoherent != kvm->arch.iommu_noncoherent) {\n\t\tkvm_iommu_unmap_memslots(kvm);\n\t\tkvm->arch.iommu_noncoherent = noncoherent;\n\t\tr = kvm_iommu_map_memslots(kvm);\n\t\tif (r)\n\t\t\tgoto out_unmap;\n\t}\n\n\tkvm_arch_start_assignment(kvm);\n\tpci_set_dev_assigned(pdev);\n\n\tdev_info(&pdev->dev, \"kvm assign device\\n\");\n\n\treturn 0;\nout_unmap:\n\tkvm_iommu_unmap_memslots(kvm);\n\treturn r;\n}"
  },
  {
    "function_name": "kvm_iommu_map_memslots",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/iommu.c",
    "lines": "152-172",
    "snippet": "static int kvm_iommu_map_memslots(struct kvm *kvm)\n{\n\tint idx, r = 0;\n\tstruct kvm_memslots *slots;\n\tstruct kvm_memory_slot *memslot;\n\n\tif (kvm->arch.iommu_noncoherent)\n\t\tkvm_arch_register_noncoherent_dma(kvm);\n\n\tidx = srcu_read_lock(&kvm->srcu);\n\tslots = kvm_memslots(kvm);\n\n\tkvm_for_each_memslot(memslot, slots) {\n\t\tr = kvm_iommu_map_pages(kvm, memslot);\n\t\tif (r)\n\t\t\tbreak;\n\t}\n\tsrcu_read_unlock(&kvm->srcu, idx);\n\n\treturn r;\n}",
    "includes": [
      "#include \"assigned-dev.h\"",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/dmar.h>",
      "#include <linux/stat.h>",
      "#include <linux/pci.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int kvm_iommu_unmap_memslots(struct kvm *kvm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "srcu_read_unlock",
          "args": [
            "&kvm->srcu",
            "idx"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_iommu_map_pages",
          "args": [
            "kvm",
            "memslot"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_iommu_map_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/iommu.c",
          "lines": "74-150",
          "snippet": "int kvm_iommu_map_pages(struct kvm *kvm, struct kvm_memory_slot *slot)\n{\n\tgfn_t gfn, end_gfn;\n\tkvm_pfn_t pfn;\n\tint r = 0;\n\tstruct iommu_domain *domain = kvm->arch.iommu_domain;\n\tint flags;\n\n\t/* check if iommu exists and in use */\n\tif (!domain)\n\t\treturn 0;\n\n\tgfn     = slot->base_gfn;\n\tend_gfn = gfn + slot->npages;\n\n\tflags = IOMMU_READ;\n\tif (!(slot->flags & KVM_MEM_READONLY))\n\t\tflags |= IOMMU_WRITE;\n\tif (!kvm->arch.iommu_noncoherent)\n\t\tflags |= IOMMU_CACHE;\n\n\n\twhile (gfn < end_gfn) {\n\t\tunsigned long page_size;\n\n\t\t/* Check if already mapped */\n\t\tif (iommu_iova_to_phys(domain, gfn_to_gpa(gfn))) {\n\t\t\tgfn += 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Get the page size we could use to map */\n\t\tpage_size = kvm_host_page_size(kvm, gfn);\n\n\t\t/* Make sure the page_size does not exceed the memslot */\n\t\twhile ((gfn + (page_size >> PAGE_SHIFT)) > end_gfn)\n\t\t\tpage_size >>= 1;\n\n\t\t/* Make sure gfn is aligned to the page size we want to map */\n\t\twhile ((gfn << PAGE_SHIFT) & (page_size - 1))\n\t\t\tpage_size >>= 1;\n\n\t\t/* Make sure hva is aligned to the page size we want to map */\n\t\twhile (__gfn_to_hva_memslot(slot, gfn) & (page_size - 1))\n\t\t\tpage_size >>= 1;\n\n\t\t/*\n\t\t * Pin all pages we are about to map in memory. This is\n\t\t * important because we unmap and unpin in 4kb steps later.\n\t\t */\n\t\tpfn = kvm_pin_pages(slot, gfn, page_size >> PAGE_SHIFT);\n\t\tif (is_error_noslot_pfn(pfn)) {\n\t\t\tgfn += 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Map into IO address space */\n\t\tr = iommu_map(domain, gfn_to_gpa(gfn), pfn_to_hpa(pfn),\n\t\t\t      page_size, flags);\n\t\tif (r) {\n\t\t\tprintk(KERN_ERR \"kvm_iommu_map_address:\"\n\t\t\t       \"iommu failed to map pfn=%llx\\n\", pfn);\n\t\t\tkvm_unpin_pages(kvm, pfn, page_size >> PAGE_SHIFT);\n\t\t\tgoto unmap_pages;\n\t\t}\n\n\t\tgfn += page_size >> PAGE_SHIFT;\n\n\t\tcond_resched();\n\t}\n\n\treturn 0;\n\nunmap_pages:\n\tkvm_iommu_put_pages(kvm, slot->base_gfn, gfn - slot->base_gfn);\n\treturn r;\n}",
          "includes": [
            "#include \"assigned-dev.h\"",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/dmar.h>",
            "#include <linux/stat.h>",
            "#include <linux/pci.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int kvm_iommu_unmap_memslots(struct kvm *kvm);",
            "static void kvm_iommu_put_pages(struct kvm *kvm,\n\t\t\t\tgfn_t base_gfn, unsigned long npages);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"assigned-dev.h\"\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/dmar.h>\n#include <linux/stat.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/list.h>\n\nstatic int kvm_iommu_unmap_memslots(struct kvm *kvm);\nstatic void kvm_iommu_put_pages(struct kvm *kvm,\n\t\t\t\tgfn_t base_gfn, unsigned long npages);\n\nint kvm_iommu_map_pages(struct kvm *kvm, struct kvm_memory_slot *slot)\n{\n\tgfn_t gfn, end_gfn;\n\tkvm_pfn_t pfn;\n\tint r = 0;\n\tstruct iommu_domain *domain = kvm->arch.iommu_domain;\n\tint flags;\n\n\t/* check if iommu exists and in use */\n\tif (!domain)\n\t\treturn 0;\n\n\tgfn     = slot->base_gfn;\n\tend_gfn = gfn + slot->npages;\n\n\tflags = IOMMU_READ;\n\tif (!(slot->flags & KVM_MEM_READONLY))\n\t\tflags |= IOMMU_WRITE;\n\tif (!kvm->arch.iommu_noncoherent)\n\t\tflags |= IOMMU_CACHE;\n\n\n\twhile (gfn < end_gfn) {\n\t\tunsigned long page_size;\n\n\t\t/* Check if already mapped */\n\t\tif (iommu_iova_to_phys(domain, gfn_to_gpa(gfn))) {\n\t\t\tgfn += 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Get the page size we could use to map */\n\t\tpage_size = kvm_host_page_size(kvm, gfn);\n\n\t\t/* Make sure the page_size does not exceed the memslot */\n\t\twhile ((gfn + (page_size >> PAGE_SHIFT)) > end_gfn)\n\t\t\tpage_size >>= 1;\n\n\t\t/* Make sure gfn is aligned to the page size we want to map */\n\t\twhile ((gfn << PAGE_SHIFT) & (page_size - 1))\n\t\t\tpage_size >>= 1;\n\n\t\t/* Make sure hva is aligned to the page size we want to map */\n\t\twhile (__gfn_to_hva_memslot(slot, gfn) & (page_size - 1))\n\t\t\tpage_size >>= 1;\n\n\t\t/*\n\t\t * Pin all pages we are about to map in memory. This is\n\t\t * important because we unmap and unpin in 4kb steps later.\n\t\t */\n\t\tpfn = kvm_pin_pages(slot, gfn, page_size >> PAGE_SHIFT);\n\t\tif (is_error_noslot_pfn(pfn)) {\n\t\t\tgfn += 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Map into IO address space */\n\t\tr = iommu_map(domain, gfn_to_gpa(gfn), pfn_to_hpa(pfn),\n\t\t\t      page_size, flags);\n\t\tif (r) {\n\t\t\tprintk(KERN_ERR \"kvm_iommu_map_address:\"\n\t\t\t       \"iommu failed to map pfn=%llx\\n\", pfn);\n\t\t\tkvm_unpin_pages(kvm, pfn, page_size >> PAGE_SHIFT);\n\t\t\tgoto unmap_pages;\n\t\t}\n\n\t\tgfn += page_size >> PAGE_SHIFT;\n\n\t\tcond_resched();\n\t}\n\n\treturn 0;\n\nunmap_pages:\n\tkvm_iommu_put_pages(kvm, slot->base_gfn, gfn - slot->base_gfn);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_for_each_memslot",
          "args": [
            "memslot",
            "slots"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_memslots",
          "args": [
            "kvm"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "srcu_read_lock",
          "args": [
            "&kvm->srcu"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_arch_register_noncoherent_dma",
          "args": [
            "kvm"
          ],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_arch_register_noncoherent_dma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "8349-8352",
          "snippet": "void kvm_arch_register_noncoherent_dma(struct kvm *kvm)\n{\n\tatomic_inc(&kvm->arch.noncoherent_dma_count);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nvoid kvm_arch_register_noncoherent_dma(struct kvm *kvm)\n{\n\tatomic_inc(&kvm->arch.noncoherent_dma_count);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"assigned-dev.h\"\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/dmar.h>\n#include <linux/stat.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/list.h>\n\nstatic int kvm_iommu_unmap_memslots(struct kvm *kvm);\n\nstatic int kvm_iommu_map_memslots(struct kvm *kvm)\n{\n\tint idx, r = 0;\n\tstruct kvm_memslots *slots;\n\tstruct kvm_memory_slot *memslot;\n\n\tif (kvm->arch.iommu_noncoherent)\n\t\tkvm_arch_register_noncoherent_dma(kvm);\n\n\tidx = srcu_read_lock(&kvm->srcu);\n\tslots = kvm_memslots(kvm);\n\n\tkvm_for_each_memslot(memslot, slots) {\n\t\tr = kvm_iommu_map_pages(kvm, memslot);\n\t\tif (r)\n\t\t\tbreak;\n\t}\n\tsrcu_read_unlock(&kvm->srcu, idx);\n\n\treturn r;\n}"
  },
  {
    "function_name": "kvm_iommu_map_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/iommu.c",
    "lines": "74-150",
    "snippet": "int kvm_iommu_map_pages(struct kvm *kvm, struct kvm_memory_slot *slot)\n{\n\tgfn_t gfn, end_gfn;\n\tkvm_pfn_t pfn;\n\tint r = 0;\n\tstruct iommu_domain *domain = kvm->arch.iommu_domain;\n\tint flags;\n\n\t/* check if iommu exists and in use */\n\tif (!domain)\n\t\treturn 0;\n\n\tgfn     = slot->base_gfn;\n\tend_gfn = gfn + slot->npages;\n\n\tflags = IOMMU_READ;\n\tif (!(slot->flags & KVM_MEM_READONLY))\n\t\tflags |= IOMMU_WRITE;\n\tif (!kvm->arch.iommu_noncoherent)\n\t\tflags |= IOMMU_CACHE;\n\n\n\twhile (gfn < end_gfn) {\n\t\tunsigned long page_size;\n\n\t\t/* Check if already mapped */\n\t\tif (iommu_iova_to_phys(domain, gfn_to_gpa(gfn))) {\n\t\t\tgfn += 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Get the page size we could use to map */\n\t\tpage_size = kvm_host_page_size(kvm, gfn);\n\n\t\t/* Make sure the page_size does not exceed the memslot */\n\t\twhile ((gfn + (page_size >> PAGE_SHIFT)) > end_gfn)\n\t\t\tpage_size >>= 1;\n\n\t\t/* Make sure gfn is aligned to the page size we want to map */\n\t\twhile ((gfn << PAGE_SHIFT) & (page_size - 1))\n\t\t\tpage_size >>= 1;\n\n\t\t/* Make sure hva is aligned to the page size we want to map */\n\t\twhile (__gfn_to_hva_memslot(slot, gfn) & (page_size - 1))\n\t\t\tpage_size >>= 1;\n\n\t\t/*\n\t\t * Pin all pages we are about to map in memory. This is\n\t\t * important because we unmap and unpin in 4kb steps later.\n\t\t */\n\t\tpfn = kvm_pin_pages(slot, gfn, page_size >> PAGE_SHIFT);\n\t\tif (is_error_noslot_pfn(pfn)) {\n\t\t\tgfn += 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Map into IO address space */\n\t\tr = iommu_map(domain, gfn_to_gpa(gfn), pfn_to_hpa(pfn),\n\t\t\t      page_size, flags);\n\t\tif (r) {\n\t\t\tprintk(KERN_ERR \"kvm_iommu_map_address:\"\n\t\t\t       \"iommu failed to map pfn=%llx\\n\", pfn);\n\t\t\tkvm_unpin_pages(kvm, pfn, page_size >> PAGE_SHIFT);\n\t\t\tgoto unmap_pages;\n\t\t}\n\n\t\tgfn += page_size >> PAGE_SHIFT;\n\n\t\tcond_resched();\n\t}\n\n\treturn 0;\n\nunmap_pages:\n\tkvm_iommu_put_pages(kvm, slot->base_gfn, gfn - slot->base_gfn);\n\treturn r;\n}",
    "includes": [
      "#include \"assigned-dev.h\"",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/dmar.h>",
      "#include <linux/stat.h>",
      "#include <linux/pci.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int kvm_iommu_unmap_memslots(struct kvm *kvm);",
      "static void kvm_iommu_put_pages(struct kvm *kvm,\n\t\t\t\tgfn_t base_gfn, unsigned long npages);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_iommu_put_pages",
          "args": [
            "kvm",
            "slot->base_gfn",
            "gfn - slot->base_gfn"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_iommu_put_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/iommu.c",
          "lines": "274-315",
          "snippet": "static void kvm_iommu_put_pages(struct kvm *kvm,\n\t\t\t\tgfn_t base_gfn, unsigned long npages)\n{\n\tstruct iommu_domain *domain;\n\tgfn_t end_gfn, gfn;\n\tkvm_pfn_t pfn;\n\tu64 phys;\n\n\tdomain  = kvm->arch.iommu_domain;\n\tend_gfn = base_gfn + npages;\n\tgfn     = base_gfn;\n\n\t/* check if iommu exists and in use */\n\tif (!domain)\n\t\treturn;\n\n\twhile (gfn < end_gfn) {\n\t\tunsigned long unmap_pages;\n\t\tsize_t size;\n\n\t\t/* Get physical address */\n\t\tphys = iommu_iova_to_phys(domain, gfn_to_gpa(gfn));\n\n\t\tif (!phys) {\n\t\t\tgfn++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tpfn  = phys >> PAGE_SHIFT;\n\n\t\t/* Unmap address from IO address space */\n\t\tsize       = iommu_unmap(domain, gfn_to_gpa(gfn), PAGE_SIZE);\n\t\tunmap_pages = 1ULL << get_order(size);\n\n\t\t/* Unpin all pages we just unmapped to not leak any memory */\n\t\tkvm_unpin_pages(kvm, pfn, unmap_pages);\n\n\t\tgfn += unmap_pages;\n\n\t\tcond_resched();\n\t}\n}",
          "includes": [
            "#include \"assigned-dev.h\"",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/dmar.h>",
            "#include <linux/stat.h>",
            "#include <linux/pci.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int kvm_iommu_unmap_memslots(struct kvm *kvm);",
            "static void kvm_iommu_put_pages(struct kvm *kvm,\n\t\t\t\tgfn_t base_gfn, unsigned long npages);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"assigned-dev.h\"\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/dmar.h>\n#include <linux/stat.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/list.h>\n\nstatic int kvm_iommu_unmap_memslots(struct kvm *kvm);\nstatic void kvm_iommu_put_pages(struct kvm *kvm,\n\t\t\t\tgfn_t base_gfn, unsigned long npages);\n\nstatic void kvm_iommu_put_pages(struct kvm *kvm,\n\t\t\t\tgfn_t base_gfn, unsigned long npages)\n{\n\tstruct iommu_domain *domain;\n\tgfn_t end_gfn, gfn;\n\tkvm_pfn_t pfn;\n\tu64 phys;\n\n\tdomain  = kvm->arch.iommu_domain;\n\tend_gfn = base_gfn + npages;\n\tgfn     = base_gfn;\n\n\t/* check if iommu exists and in use */\n\tif (!domain)\n\t\treturn;\n\n\twhile (gfn < end_gfn) {\n\t\tunsigned long unmap_pages;\n\t\tsize_t size;\n\n\t\t/* Get physical address */\n\t\tphys = iommu_iova_to_phys(domain, gfn_to_gpa(gfn));\n\n\t\tif (!phys) {\n\t\t\tgfn++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tpfn  = phys >> PAGE_SHIFT;\n\n\t\t/* Unmap address from IO address space */\n\t\tsize       = iommu_unmap(domain, gfn_to_gpa(gfn), PAGE_SIZE);\n\t\tunmap_pages = 1ULL << get_order(size);\n\n\t\t/* Unpin all pages we just unmapped to not leak any memory */\n\t\tkvm_unpin_pages(kvm, pfn, unmap_pages);\n\n\t\tgfn += unmap_pages;\n\n\t\tcond_resched();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_unpin_pages",
          "args": [
            "kvm",
            "pfn",
            "page_size >> PAGE_SHIFT"
          ],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_unpin_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/iommu.c",
          "lines": "65-72",
          "snippet": "static void kvm_unpin_pages(struct kvm *kvm, kvm_pfn_t pfn,\n\t\tunsigned long npages)\n{\n\tunsigned long i;\n\n\tfor (i = 0; i < npages; ++i)\n\t\tkvm_release_pfn_clean(pfn + i);\n}",
          "includes": [
            "#include \"assigned-dev.h\"",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/dmar.h>",
            "#include <linux/stat.h>",
            "#include <linux/pci.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int kvm_iommu_unmap_memslots(struct kvm *kvm);",
            "static void kvm_iommu_put_pages(struct kvm *kvm,\n\t\t\t\tgfn_t base_gfn, unsigned long npages);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"assigned-dev.h\"\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/dmar.h>\n#include <linux/stat.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/list.h>\n\nstatic int kvm_iommu_unmap_memslots(struct kvm *kvm);\nstatic void kvm_iommu_put_pages(struct kvm *kvm,\n\t\t\t\tgfn_t base_gfn, unsigned long npages);\n\nstatic void kvm_unpin_pages(struct kvm *kvm, kvm_pfn_t pfn,\n\t\tunsigned long npages)\n{\n\tunsigned long i;\n\n\tfor (i = 0; i < npages; ++i)\n\t\tkvm_release_pfn_clean(pfn + i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"kvm_iommu_map_address:\"\n\t\t\t       \"iommu failed to map pfn=%llx\\n\"",
            "pfn"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iommu_map",
          "args": [
            "domain",
            "gfn_to_gpa(gfn)",
            "pfn_to_hpa(pfn)",
            "page_size",
            "flags"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_to_hpa",
          "args": [
            "pfn"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfn_to_gpa",
          "args": [
            "gfn"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_error_noslot_pfn",
          "args": [
            "pfn"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_pin_pages",
          "args": [
            "slot",
            "gfn",
            "page_size >> PAGE_SHIFT"
          ],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_pin_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/iommu.c",
          "lines": "46-63",
          "snippet": "static kvm_pfn_t kvm_pin_pages(struct kvm_memory_slot *slot, gfn_t gfn,\n\t\t\t   unsigned long npages)\n{\n\tgfn_t end_gfn;\n\tkvm_pfn_t pfn;\n\n\tpfn     = gfn_to_pfn_memslot(slot, gfn);\n\tend_gfn = gfn + npages;\n\tgfn    += 1;\n\n\tif (is_error_noslot_pfn(pfn))\n\t\treturn pfn;\n\n\twhile (gfn < end_gfn)\n\t\tgfn_to_pfn_memslot(slot, gfn++);\n\n\treturn pfn;\n}",
          "includes": [
            "#include \"assigned-dev.h\"",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/dmar.h>",
            "#include <linux/stat.h>",
            "#include <linux/pci.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void kvm_iommu_put_pages(struct kvm *kvm,\n\t\t\t\tgfn_t base_gfn, unsigned long npages);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"assigned-dev.h\"\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/dmar.h>\n#include <linux/stat.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/list.h>\n\nstatic void kvm_iommu_put_pages(struct kvm *kvm,\n\t\t\t\tgfn_t base_gfn, unsigned long npages);\n\nstatic kvm_pfn_t kvm_pin_pages(struct kvm_memory_slot *slot, gfn_t gfn,\n\t\t\t   unsigned long npages)\n{\n\tgfn_t end_gfn;\n\tkvm_pfn_t pfn;\n\n\tpfn     = gfn_to_pfn_memslot(slot, gfn);\n\tend_gfn = gfn + npages;\n\tgfn    += 1;\n\n\tif (is_error_noslot_pfn(pfn))\n\t\treturn pfn;\n\n\twhile (gfn < end_gfn)\n\t\tgfn_to_pfn_memslot(slot, gfn++);\n\n\treturn pfn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__gfn_to_hva_memslot",
          "args": [
            "slot",
            "gfn"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_host_page_size",
          "args": [
            "kvm",
            "gfn"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iommu_iova_to_phys",
          "args": [
            "domain",
            "gfn_to_gpa(gfn)"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfn_to_gpa",
          "args": [
            "gfn"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"assigned-dev.h\"\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/dmar.h>\n#include <linux/stat.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/list.h>\n\nstatic int kvm_iommu_unmap_memslots(struct kvm *kvm);\nstatic void kvm_iommu_put_pages(struct kvm *kvm,\n\t\t\t\tgfn_t base_gfn, unsigned long npages);\n\nint kvm_iommu_map_pages(struct kvm *kvm, struct kvm_memory_slot *slot)\n{\n\tgfn_t gfn, end_gfn;\n\tkvm_pfn_t pfn;\n\tint r = 0;\n\tstruct iommu_domain *domain = kvm->arch.iommu_domain;\n\tint flags;\n\n\t/* check if iommu exists and in use */\n\tif (!domain)\n\t\treturn 0;\n\n\tgfn     = slot->base_gfn;\n\tend_gfn = gfn + slot->npages;\n\n\tflags = IOMMU_READ;\n\tif (!(slot->flags & KVM_MEM_READONLY))\n\t\tflags |= IOMMU_WRITE;\n\tif (!kvm->arch.iommu_noncoherent)\n\t\tflags |= IOMMU_CACHE;\n\n\n\twhile (gfn < end_gfn) {\n\t\tunsigned long page_size;\n\n\t\t/* Check if already mapped */\n\t\tif (iommu_iova_to_phys(domain, gfn_to_gpa(gfn))) {\n\t\t\tgfn += 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Get the page size we could use to map */\n\t\tpage_size = kvm_host_page_size(kvm, gfn);\n\n\t\t/* Make sure the page_size does not exceed the memslot */\n\t\twhile ((gfn + (page_size >> PAGE_SHIFT)) > end_gfn)\n\t\t\tpage_size >>= 1;\n\n\t\t/* Make sure gfn is aligned to the page size we want to map */\n\t\twhile ((gfn << PAGE_SHIFT) & (page_size - 1))\n\t\t\tpage_size >>= 1;\n\n\t\t/* Make sure hva is aligned to the page size we want to map */\n\t\twhile (__gfn_to_hva_memslot(slot, gfn) & (page_size - 1))\n\t\t\tpage_size >>= 1;\n\n\t\t/*\n\t\t * Pin all pages we are about to map in memory. This is\n\t\t * important because we unmap and unpin in 4kb steps later.\n\t\t */\n\t\tpfn = kvm_pin_pages(slot, gfn, page_size >> PAGE_SHIFT);\n\t\tif (is_error_noslot_pfn(pfn)) {\n\t\t\tgfn += 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Map into IO address space */\n\t\tr = iommu_map(domain, gfn_to_gpa(gfn), pfn_to_hpa(pfn),\n\t\t\t      page_size, flags);\n\t\tif (r) {\n\t\t\tprintk(KERN_ERR \"kvm_iommu_map_address:\"\n\t\t\t       \"iommu failed to map pfn=%llx\\n\", pfn);\n\t\t\tkvm_unpin_pages(kvm, pfn, page_size >> PAGE_SHIFT);\n\t\t\tgoto unmap_pages;\n\t\t}\n\n\t\tgfn += page_size >> PAGE_SHIFT;\n\n\t\tcond_resched();\n\t}\n\n\treturn 0;\n\nunmap_pages:\n\tkvm_iommu_put_pages(kvm, slot->base_gfn, gfn - slot->base_gfn);\n\treturn r;\n}"
  },
  {
    "function_name": "kvm_unpin_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/iommu.c",
    "lines": "65-72",
    "snippet": "static void kvm_unpin_pages(struct kvm *kvm, kvm_pfn_t pfn,\n\t\tunsigned long npages)\n{\n\tunsigned long i;\n\n\tfor (i = 0; i < npages; ++i)\n\t\tkvm_release_pfn_clean(pfn + i);\n}",
    "includes": [
      "#include \"assigned-dev.h\"",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/dmar.h>",
      "#include <linux/stat.h>",
      "#include <linux/pci.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int kvm_iommu_unmap_memslots(struct kvm *kvm);",
      "static void kvm_iommu_put_pages(struct kvm *kvm,\n\t\t\t\tgfn_t base_gfn, unsigned long npages);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_release_pfn_clean",
          "args": [
            "pfn + i"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"assigned-dev.h\"\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/dmar.h>\n#include <linux/stat.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/list.h>\n\nstatic int kvm_iommu_unmap_memslots(struct kvm *kvm);\nstatic void kvm_iommu_put_pages(struct kvm *kvm,\n\t\t\t\tgfn_t base_gfn, unsigned long npages);\n\nstatic void kvm_unpin_pages(struct kvm *kvm, kvm_pfn_t pfn,\n\t\tunsigned long npages)\n{\n\tunsigned long i;\n\n\tfor (i = 0; i < npages; ++i)\n\t\tkvm_release_pfn_clean(pfn + i);\n}"
  },
  {
    "function_name": "kvm_pin_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/iommu.c",
    "lines": "46-63",
    "snippet": "static kvm_pfn_t kvm_pin_pages(struct kvm_memory_slot *slot, gfn_t gfn,\n\t\t\t   unsigned long npages)\n{\n\tgfn_t end_gfn;\n\tkvm_pfn_t pfn;\n\n\tpfn     = gfn_to_pfn_memslot(slot, gfn);\n\tend_gfn = gfn + npages;\n\tgfn    += 1;\n\n\tif (is_error_noslot_pfn(pfn))\n\t\treturn pfn;\n\n\twhile (gfn < end_gfn)\n\t\tgfn_to_pfn_memslot(slot, gfn++);\n\n\treturn pfn;\n}",
    "includes": [
      "#include \"assigned-dev.h\"",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/dmar.h>",
      "#include <linux/stat.h>",
      "#include <linux/pci.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void kvm_iommu_put_pages(struct kvm *kvm,\n\t\t\t\tgfn_t base_gfn, unsigned long npages);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfn_to_pfn_memslot",
          "args": [
            "slot",
            "gfn++"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_error_noslot_pfn",
          "args": [
            "pfn"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfn_to_pfn_memslot",
          "args": [
            "slot",
            "gfn"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"assigned-dev.h\"\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/dmar.h>\n#include <linux/stat.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/list.h>\n\nstatic void kvm_iommu_put_pages(struct kvm *kvm,\n\t\t\t\tgfn_t base_gfn, unsigned long npages);\n\nstatic kvm_pfn_t kvm_pin_pages(struct kvm_memory_slot *slot, gfn_t gfn,\n\t\t\t   unsigned long npages)\n{\n\tgfn_t end_gfn;\n\tkvm_pfn_t pfn;\n\n\tpfn     = gfn_to_pfn_memslot(slot, gfn);\n\tend_gfn = gfn + npages;\n\tgfn    += 1;\n\n\tif (is_error_noslot_pfn(pfn))\n\t\treturn pfn;\n\n\twhile (gfn < end_gfn)\n\t\tgfn_to_pfn_memslot(slot, gfn++);\n\n\treturn pfn;\n}"
  }
]