[
  {
    "function_name": "intel_pmu_reset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/pmu_intel.c",
    "lines": "326-343",
    "snippet": "static void intel_pmu_reset(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_pmu *pmu = vcpu_to_pmu(vcpu);\n\tint i;\n\n\tfor (i = 0; i < INTEL_PMC_MAX_GENERIC; i++) {\n\t\tstruct kvm_pmc *pmc = &pmu->gp_counters[i];\n\n\t\tpmc_stop_counter(pmc);\n\t\tpmc->counter = pmc->eventsel = 0;\n\t}\n\n\tfor (i = 0; i < INTEL_PMC_MAX_FIXED; i++)\n\t\tpmc_stop_counter(&pmu->fixed_counters[i]);\n\n\tpmu->fixed_ctr_ctrl = pmu->global_ctrl = pmu->global_status =\n\t\tpmu->global_ovf_ctrl = 0;\n}",
    "includes": [
      "#include \"pmu.h\"",
      "#include \"lapic.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include <asm/perf_event.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pmc_stop_counter",
          "args": [
            "&pmu->fixed_counters[i]"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "pmc_stop_counter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/pmu.h",
          "lines": "52-59",
          "snippet": "static inline void pmc_stop_counter(struct kvm_pmc *pmc)\n{\n\tif (pmc->perf_event) {\n\t\tpmc->counter = pmc_read_counter(pmc);\n\t\tperf_event_release_kernel(pmc->perf_event);\n\t\tpmc->perf_event = NULL;\n\t}\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void pmc_stop_counter(struct kvm_pmc *pmc)\n{\n\tif (pmc->perf_event) {\n\t\tpmc->counter = pmc_read_counter(pmc);\n\t\tperf_event_release_kernel(pmc->perf_event);\n\t\tpmc->perf_event = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "vcpu_to_pmu",
          "args": [
            "vcpu"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include <asm/perf_event.h>\n#include <linux/perf_event.h>\n#include <linux/kvm_host.h>\n#include <linux/types.h>\n\nstatic void intel_pmu_reset(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_pmu *pmu = vcpu_to_pmu(vcpu);\n\tint i;\n\n\tfor (i = 0; i < INTEL_PMC_MAX_GENERIC; i++) {\n\t\tstruct kvm_pmc *pmc = &pmu->gp_counters[i];\n\n\t\tpmc_stop_counter(pmc);\n\t\tpmc->counter = pmc->eventsel = 0;\n\t}\n\n\tfor (i = 0; i < INTEL_PMC_MAX_FIXED; i++)\n\t\tpmc_stop_counter(&pmu->fixed_counters[i]);\n\n\tpmu->fixed_ctr_ctrl = pmu->global_ctrl = pmu->global_status =\n\t\tpmu->global_ovf_ctrl = 0;\n}"
  },
  {
    "function_name": "intel_pmu_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/pmu_intel.c",
    "lines": "308-324",
    "snippet": "static void intel_pmu_init(struct kvm_vcpu *vcpu)\n{\n\tint i;\n\tstruct kvm_pmu *pmu = vcpu_to_pmu(vcpu);\n\n\tfor (i = 0; i < INTEL_PMC_MAX_GENERIC; i++) {\n\t\tpmu->gp_counters[i].type = KVM_PMC_GP;\n\t\tpmu->gp_counters[i].vcpu = vcpu;\n\t\tpmu->gp_counters[i].idx = i;\n\t}\n\n\tfor (i = 0; i < INTEL_PMC_MAX_FIXED; i++) {\n\t\tpmu->fixed_counters[i].type = KVM_PMC_FIXED;\n\t\tpmu->fixed_counters[i].vcpu = vcpu;\n\t\tpmu->fixed_counters[i].idx = i + INTEL_PMC_IDX_FIXED;\n\t}\n}",
    "includes": [
      "#include \"pmu.h\"",
      "#include \"lapic.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include <asm/perf_event.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vcpu_to_pmu",
          "args": [
            "vcpu"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include <asm/perf_event.h>\n#include <linux/perf_event.h>\n#include <linux/kvm_host.h>\n#include <linux/types.h>\n\nstatic void intel_pmu_init(struct kvm_vcpu *vcpu)\n{\n\tint i;\n\tstruct kvm_pmu *pmu = vcpu_to_pmu(vcpu);\n\n\tfor (i = 0; i < INTEL_PMC_MAX_GENERIC; i++) {\n\t\tpmu->gp_counters[i].type = KVM_PMC_GP;\n\t\tpmu->gp_counters[i].vcpu = vcpu;\n\t\tpmu->gp_counters[i].idx = i;\n\t}\n\n\tfor (i = 0; i < INTEL_PMC_MAX_FIXED; i++) {\n\t\tpmu->fixed_counters[i].type = KVM_PMC_FIXED;\n\t\tpmu->fixed_counters[i].vcpu = vcpu;\n\t\tpmu->fixed_counters[i].idx = i + INTEL_PMC_IDX_FIXED;\n\t}\n}"
  },
  {
    "function_name": "intel_pmu_refresh",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/pmu_intel.c",
    "lines": "257-306",
    "snippet": "static void intel_pmu_refresh(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_pmu *pmu = vcpu_to_pmu(vcpu);\n\tstruct kvm_cpuid_entry2 *entry;\n\tunion cpuid10_eax eax;\n\tunion cpuid10_edx edx;\n\n\tpmu->nr_arch_gp_counters = 0;\n\tpmu->nr_arch_fixed_counters = 0;\n\tpmu->counter_bitmask[KVM_PMC_GP] = 0;\n\tpmu->counter_bitmask[KVM_PMC_FIXED] = 0;\n\tpmu->version = 0;\n\tpmu->reserved_bits = 0xffffffff00200000ull;\n\n\tentry = kvm_find_cpuid_entry(vcpu, 0xa, 0);\n\tif (!entry)\n\t\treturn;\n\teax.full = entry->eax;\n\tedx.full = entry->edx;\n\n\tpmu->version = eax.split.version_id;\n\tif (!pmu->version)\n\t\treturn;\n\n\tpmu->nr_arch_gp_counters = min_t(int, eax.split.num_counters,\n\t\t\t\t\tINTEL_PMC_MAX_GENERIC);\n\tpmu->counter_bitmask[KVM_PMC_GP] = ((u64)1 << eax.split.bit_width) - 1;\n\tpmu->available_event_types = ~entry->ebx &\n\t\t\t\t\t((1ull << eax.split.mask_length) - 1);\n\n\tif (pmu->version == 1) {\n\t\tpmu->nr_arch_fixed_counters = 0;\n\t} else {\n\t\tpmu->nr_arch_fixed_counters =\n\t\t\tmin_t(int, edx.split.num_counters_fixed,\n\t\t\t\tINTEL_PMC_MAX_FIXED);\n\t\tpmu->counter_bitmask[KVM_PMC_FIXED] =\n\t\t\t((u64)1 << edx.split.bit_width_fixed) - 1;\n\t}\n\n\tpmu->global_ctrl = ((1 << pmu->nr_arch_gp_counters) - 1) |\n\t\t(((1ull << pmu->nr_arch_fixed_counters) - 1) << INTEL_PMC_IDX_FIXED);\n\tpmu->global_ctrl_mask = ~pmu->global_ctrl;\n\n\tentry = kvm_find_cpuid_entry(vcpu, 7, 0);\n\tif (entry &&\n\t    (boot_cpu_has(X86_FEATURE_HLE) || boot_cpu_has(X86_FEATURE_RTM)) &&\n\t    (entry->ebx & (X86_FEATURE_HLE|X86_FEATURE_RTM)))\n\t\tpmu->reserved_bits ^= HSW_IN_TX|HSW_IN_TX_CHECKPOINTED;\n}",
    "includes": [
      "#include \"pmu.h\"",
      "#include \"lapic.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include <asm/perf_event.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "boot_cpu_has",
          "args": [
            "X86_FEATURE_RTM"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "boot_cpu_has",
          "args": [
            "X86_FEATURE_HLE"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_find_cpuid_entry",
          "args": [
            "vcpu",
            "7",
            "0"
          ],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_find_cpuid_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/cpuid.c",
          "lines": "794-812",
          "snippet": "struct kvm_cpuid_entry2 *kvm_find_cpuid_entry(struct kvm_vcpu *vcpu,\n\t\t\t\t\t      u32 function, u32 index)\n{\n\tint i;\n\tstruct kvm_cpuid_entry2 *best = NULL;\n\n\tfor (i = 0; i < vcpu->arch.cpuid_nent; ++i) {\n\t\tstruct kvm_cpuid_entry2 *e;\n\n\t\te = &vcpu->arch.cpuid_entries[i];\n\t\tif (is_matching_cpuid_entry(e, function, index)) {\n\t\t\tif (e->flags & KVM_CPUID_FLAG_STATEFUL_FUNC)\n\t\t\t\tmove_to_next_stateful_cpuid_entry(vcpu, i);\n\t\t\tbest = e;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn best;\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"trace.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"cpuid.h\"",
            "#include <asm/fpu/xstate.h>",
            "#include <asm/user.h>",
            "#include <asm/fpu/internal.h> /* For use_eager_fpu.  Ugh! */",
            "#include <linux/uaccess.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"trace.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include <asm/fpu/xstate.h>\n#include <asm/user.h>\n#include <asm/fpu/internal.h> /* For use_eager_fpu.  Ugh! */\n#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n\nstruct kvm_cpuid_entry2 *kvm_find_cpuid_entry(struct kvm_vcpu *vcpu,\n\t\t\t\t\t      u32 function, u32 index)\n{\n\tint i;\n\tstruct kvm_cpuid_entry2 *best = NULL;\n\n\tfor (i = 0; i < vcpu->arch.cpuid_nent; ++i) {\n\t\tstruct kvm_cpuid_entry2 *e;\n\n\t\te = &vcpu->arch.cpuid_entries[i];\n\t\tif (is_matching_cpuid_entry(e, function, index)) {\n\t\t\tif (e->flags & KVM_CPUID_FLAG_STATEFUL_FUNC)\n\t\t\t\tmove_to_next_stateful_cpuid_entry(vcpu, i);\n\t\t\tbest = e;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn best;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "int",
            "edx.split.num_counters_fixed",
            "INTEL_PMC_MAX_FIXED"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "int",
            "eax.split.num_counters",
            "INTEL_PMC_MAX_GENERIC"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vcpu_to_pmu",
          "args": [
            "vcpu"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include <asm/perf_event.h>\n#include <linux/perf_event.h>\n#include <linux/kvm_host.h>\n#include <linux/types.h>\n\nstatic void intel_pmu_refresh(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_pmu *pmu = vcpu_to_pmu(vcpu);\n\tstruct kvm_cpuid_entry2 *entry;\n\tunion cpuid10_eax eax;\n\tunion cpuid10_edx edx;\n\n\tpmu->nr_arch_gp_counters = 0;\n\tpmu->nr_arch_fixed_counters = 0;\n\tpmu->counter_bitmask[KVM_PMC_GP] = 0;\n\tpmu->counter_bitmask[KVM_PMC_FIXED] = 0;\n\tpmu->version = 0;\n\tpmu->reserved_bits = 0xffffffff00200000ull;\n\n\tentry = kvm_find_cpuid_entry(vcpu, 0xa, 0);\n\tif (!entry)\n\t\treturn;\n\teax.full = entry->eax;\n\tedx.full = entry->edx;\n\n\tpmu->version = eax.split.version_id;\n\tif (!pmu->version)\n\t\treturn;\n\n\tpmu->nr_arch_gp_counters = min_t(int, eax.split.num_counters,\n\t\t\t\t\tINTEL_PMC_MAX_GENERIC);\n\tpmu->counter_bitmask[KVM_PMC_GP] = ((u64)1 << eax.split.bit_width) - 1;\n\tpmu->available_event_types = ~entry->ebx &\n\t\t\t\t\t((1ull << eax.split.mask_length) - 1);\n\n\tif (pmu->version == 1) {\n\t\tpmu->nr_arch_fixed_counters = 0;\n\t} else {\n\t\tpmu->nr_arch_fixed_counters =\n\t\t\tmin_t(int, edx.split.num_counters_fixed,\n\t\t\t\tINTEL_PMC_MAX_FIXED);\n\t\tpmu->counter_bitmask[KVM_PMC_FIXED] =\n\t\t\t((u64)1 << edx.split.bit_width_fixed) - 1;\n\t}\n\n\tpmu->global_ctrl = ((1 << pmu->nr_arch_gp_counters) - 1) |\n\t\t(((1ull << pmu->nr_arch_fixed_counters) - 1) << INTEL_PMC_IDX_FIXED);\n\tpmu->global_ctrl_mask = ~pmu->global_ctrl;\n\n\tentry = kvm_find_cpuid_entry(vcpu, 7, 0);\n\tif (entry &&\n\t    (boot_cpu_has(X86_FEATURE_HLE) || boot_cpu_has(X86_FEATURE_RTM)) &&\n\t    (entry->ebx & (X86_FEATURE_HLE|X86_FEATURE_RTM)))\n\t\tpmu->reserved_bits ^= HSW_IN_TX|HSW_IN_TX_CHECKPOINTED;\n}"
  },
  {
    "function_name": "intel_pmu_set_msr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/pmu_intel.c",
    "lines": "199-255",
    "snippet": "static int intel_pmu_set_msr(struct kvm_vcpu *vcpu, struct msr_data *msr_info)\n{\n\tstruct kvm_pmu *pmu = vcpu_to_pmu(vcpu);\n\tstruct kvm_pmc *pmc;\n\tu32 msr = msr_info->index;\n\tu64 data = msr_info->data;\n\n\tswitch (msr) {\n\tcase MSR_CORE_PERF_FIXED_CTR_CTRL:\n\t\tif (pmu->fixed_ctr_ctrl == data)\n\t\t\treturn 0;\n\t\tif (!(data & 0xfffffffffffff444ull)) {\n\t\t\treprogram_fixed_counters(pmu, data);\n\t\t\treturn 0;\n\t\t}\n\t\tbreak;\n\tcase MSR_CORE_PERF_GLOBAL_STATUS:\n\t\tif (msr_info->host_initiated) {\n\t\t\tpmu->global_status = data;\n\t\t\treturn 0;\n\t\t}\n\t\tbreak; /* RO MSR */\n\tcase MSR_CORE_PERF_GLOBAL_CTRL:\n\t\tif (pmu->global_ctrl == data)\n\t\t\treturn 0;\n\t\tif (!(data & pmu->global_ctrl_mask)) {\n\t\t\tglobal_ctrl_changed(pmu, data);\n\t\t\treturn 0;\n\t\t}\n\t\tbreak;\n\tcase MSR_CORE_PERF_GLOBAL_OVF_CTRL:\n\t\tif (!(data & (pmu->global_ctrl_mask & ~(3ull<<62)))) {\n\t\t\tif (!msr_info->host_initiated)\n\t\t\t\tpmu->global_status &= ~data;\n\t\t\tpmu->global_ovf_ctrl = data;\n\t\t\treturn 0;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tif ((pmc = get_gp_pmc(pmu, msr, MSR_IA32_PERFCTR0)) ||\n\t\t    (pmc = get_fixed_pmc(pmu, msr))) {\n\t\t\tif (!msr_info->host_initiated)\n\t\t\t\tdata = (s64)(s32)data;\n\t\t\tpmc->counter += data - pmc_read_counter(pmc);\n\t\t\treturn 0;\n\t\t} else if ((pmc = get_gp_pmc(pmu, msr, MSR_P6_EVNTSEL0))) {\n\t\t\tif (data == pmc->eventsel)\n\t\t\t\treturn 0;\n\t\t\tif (!(data & pmu->reserved_bits)) {\n\t\t\t\treprogram_gp_counter(pmc, data);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 1;\n}",
    "includes": [
      "#include \"pmu.h\"",
      "#include \"lapic.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include <asm/perf_event.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reprogram_gp_counter",
          "args": [
            "pmc",
            "data"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "reprogram_gp_counter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/pmu.c",
          "lines": "136-175",
          "snippet": "void reprogram_gp_counter(struct kvm_pmc *pmc, u64 eventsel)\n{\n\tunsigned config, type = PERF_TYPE_RAW;\n\tu8 event_select, unit_mask;\n\n\tif (eventsel & ARCH_PERFMON_EVENTSEL_PIN_CONTROL)\n\t\tprintk_once(\"kvm pmu: pin control bit is ignored\\n\");\n\n\tpmc->eventsel = eventsel;\n\n\tpmc_stop_counter(pmc);\n\n\tif (!(eventsel & ARCH_PERFMON_EVENTSEL_ENABLE) || !pmc_is_enabled(pmc))\n\t\treturn;\n\n\tevent_select = eventsel & ARCH_PERFMON_EVENTSEL_EVENT;\n\tunit_mask = (eventsel & ARCH_PERFMON_EVENTSEL_UMASK) >> 8;\n\n\tif (!(eventsel & (ARCH_PERFMON_EVENTSEL_EDGE |\n\t\t\t  ARCH_PERFMON_EVENTSEL_INV |\n\t\t\t  ARCH_PERFMON_EVENTSEL_CMASK |\n\t\t\t  HSW_IN_TX |\n\t\t\t  HSW_IN_TX_CHECKPOINTED))) {\n\t\tconfig = kvm_x86_ops->pmu_ops->find_arch_event(pmc_to_pmu(pmc),\n\t\t\t\t\t\t      event_select,\n\t\t\t\t\t\t      unit_mask);\n\t\tif (config != PERF_COUNT_HW_MAX)\n\t\t\ttype = PERF_TYPE_HARDWARE;\n\t}\n\n\tif (type == PERF_TYPE_RAW)\n\t\tconfig = eventsel & X86_RAW_EVENT_MASK;\n\n\tpmc_reprogram_counter(pmc, type, config,\n\t\t\t      !(eventsel & ARCH_PERFMON_EVENTSEL_USR),\n\t\t\t      !(eventsel & ARCH_PERFMON_EVENTSEL_OS),\n\t\t\t      eventsel & ARCH_PERFMON_EVENTSEL_INT,\n\t\t\t      (eventsel & HSW_IN_TX),\n\t\t\t      (eventsel & HSW_IN_TX_CHECKPOINTED));\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"lapic.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include <asm/perf_event.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include <asm/perf_event.h>\n#include <linux/perf_event.h>\n#include <linux/kvm_host.h>\n#include <linux/types.h>\n\nvoid reprogram_gp_counter(struct kvm_pmc *pmc, u64 eventsel)\n{\n\tunsigned config, type = PERF_TYPE_RAW;\n\tu8 event_select, unit_mask;\n\n\tif (eventsel & ARCH_PERFMON_EVENTSEL_PIN_CONTROL)\n\t\tprintk_once(\"kvm pmu: pin control bit is ignored\\n\");\n\n\tpmc->eventsel = eventsel;\n\n\tpmc_stop_counter(pmc);\n\n\tif (!(eventsel & ARCH_PERFMON_EVENTSEL_ENABLE) || !pmc_is_enabled(pmc))\n\t\treturn;\n\n\tevent_select = eventsel & ARCH_PERFMON_EVENTSEL_EVENT;\n\tunit_mask = (eventsel & ARCH_PERFMON_EVENTSEL_UMASK) >> 8;\n\n\tif (!(eventsel & (ARCH_PERFMON_EVENTSEL_EDGE |\n\t\t\t  ARCH_PERFMON_EVENTSEL_INV |\n\t\t\t  ARCH_PERFMON_EVENTSEL_CMASK |\n\t\t\t  HSW_IN_TX |\n\t\t\t  HSW_IN_TX_CHECKPOINTED))) {\n\t\tconfig = kvm_x86_ops->pmu_ops->find_arch_event(pmc_to_pmu(pmc),\n\t\t\t\t\t\t      event_select,\n\t\t\t\t\t\t      unit_mask);\n\t\tif (config != PERF_COUNT_HW_MAX)\n\t\t\ttype = PERF_TYPE_HARDWARE;\n\t}\n\n\tif (type == PERF_TYPE_RAW)\n\t\tconfig = eventsel & X86_RAW_EVENT_MASK;\n\n\tpmc_reprogram_counter(pmc, type, config,\n\t\t\t      !(eventsel & ARCH_PERFMON_EVENTSEL_USR),\n\t\t\t      !(eventsel & ARCH_PERFMON_EVENTSEL_OS),\n\t\t\t      eventsel & ARCH_PERFMON_EVENTSEL_INT,\n\t\t\t      (eventsel & HSW_IN_TX),\n\t\t\t      (eventsel & HSW_IN_TX_CHECKPOINTED));\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_gp_pmc",
          "args": [
            "pmu",
            "msr",
            "MSR_P6_EVNTSEL0"
          ],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "get_gp_pmc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/pmu.h",
          "lines": "80-87",
          "snippet": "static inline struct kvm_pmc *get_gp_pmc(struct kvm_pmu *pmu, u32 msr,\n\t\t\t\t\t u32 base)\n{\n\tif (msr >= base && msr < base + pmu->nr_arch_gp_counters)\n\t\treturn &pmu->gp_counters[msr - base];\n\n\treturn NULL;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct kvm_pmc *get_gp_pmc(struct kvm_pmu *pmu, u32 msr,\n\t\t\t\t\t u32 base)\n{\n\tif (msr >= base && msr < base + pmu->nr_arch_gp_counters)\n\t\treturn &pmu->gp_counters[msr - base];\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pmc_read_counter",
          "args": [
            "pmc"
          ],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "pmc_read_counter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/pmu.h",
          "lines": "40-50",
          "snippet": "static inline u64 pmc_read_counter(struct kvm_pmc *pmc)\n{\n\tu64 counter, enabled, running;\n\n\tcounter = pmc->counter;\n\tif (pmc->perf_event)\n\t\tcounter += perf_event_read_value(pmc->perf_event,\n\t\t\t\t\t\t &enabled, &running);\n\t/* FIXME: Scaling needed? */\n\treturn counter & pmc_bitmask(pmc);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline u64 pmc_read_counter(struct kvm_pmc *pmc)\n{\n\tu64 counter, enabled, running;\n\n\tcounter = pmc->counter;\n\tif (pmc->perf_event)\n\t\tcounter += perf_event_read_value(pmc->perf_event,\n\t\t\t\t\t\t &enabled, &running);\n\t/* FIXME: Scaling needed? */\n\treturn counter & pmc_bitmask(pmc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_fixed_pmc",
          "args": [
            "pmu",
            "msr"
          ],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "get_fixed_pmc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/pmu.h",
          "lines": "90-98",
          "snippet": "static inline struct kvm_pmc *get_fixed_pmc(struct kvm_pmu *pmu, u32 msr)\n{\n\tint base = MSR_CORE_PERF_FIXED_CTR0;\n\n\tif (msr >= base && msr < base + pmu->nr_arch_fixed_counters)\n\t\treturn &pmu->fixed_counters[msr - base];\n\n\treturn NULL;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct kvm_pmc *get_fixed_pmc(struct kvm_pmu *pmu, u32 msr)\n{\n\tint base = MSR_CORE_PERF_FIXED_CTR0;\n\n\tif (msr >= base && msr < base + pmu->nr_arch_fixed_counters)\n\t\treturn &pmu->fixed_counters[msr - base];\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "global_ctrl_changed",
          "args": [
            "pmu",
            "data"
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "global_ctrl_changed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/pmu_intel.c",
          "lines": "59-68",
          "snippet": "static void global_ctrl_changed(struct kvm_pmu *pmu, u64 data)\n{\n\tint bit;\n\tu64 diff = pmu->global_ctrl ^ data;\n\n\tpmu->global_ctrl = data;\n\n\tfor_each_set_bit(bit, (unsigned long *)&diff, X86_PMC_IDX_MAX)\n\t\treprogram_counter(pmu, bit);\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"lapic.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include <asm/perf_event.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include <asm/perf_event.h>\n#include <linux/perf_event.h>\n#include <linux/kvm_host.h>\n#include <linux/types.h>\n\nstatic void global_ctrl_changed(struct kvm_pmu *pmu, u64 data)\n{\n\tint bit;\n\tu64 diff = pmu->global_ctrl ^ data;\n\n\tpmu->global_ctrl = data;\n\n\tfor_each_set_bit(bit, (unsigned long *)&diff, X86_PMC_IDX_MAX)\n\t\treprogram_counter(pmu, bit);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reprogram_fixed_counters",
          "args": [
            "pmu",
            "data"
          ],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "reprogram_fixed_counters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/pmu_intel.c",
          "lines": "38-56",
          "snippet": "static void reprogram_fixed_counters(struct kvm_pmu *pmu, u64 data)\n{\n\tint i;\n\n\tfor (i = 0; i < pmu->nr_arch_fixed_counters; i++) {\n\t\tu8 new_ctrl = fixed_ctrl_field(data, i);\n\t\tu8 old_ctrl = fixed_ctrl_field(pmu->fixed_ctr_ctrl, i);\n\t\tstruct kvm_pmc *pmc;\n\n\t\tpmc = get_fixed_pmc(pmu, MSR_CORE_PERF_FIXED_CTR0 + i);\n\n\t\tif (old_ctrl == new_ctrl)\n\t\t\tcontinue;\n\n\t\treprogram_fixed_counter(pmc, new_ctrl, i);\n\t}\n\n\tpmu->fixed_ctr_ctrl = data;\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"lapic.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include <asm/perf_event.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include <asm/perf_event.h>\n#include <linux/perf_event.h>\n#include <linux/kvm_host.h>\n#include <linux/types.h>\n\nstatic void reprogram_fixed_counters(struct kvm_pmu *pmu, u64 data)\n{\n\tint i;\n\n\tfor (i = 0; i < pmu->nr_arch_fixed_counters; i++) {\n\t\tu8 new_ctrl = fixed_ctrl_field(data, i);\n\t\tu8 old_ctrl = fixed_ctrl_field(pmu->fixed_ctr_ctrl, i);\n\t\tstruct kvm_pmc *pmc;\n\n\t\tpmc = get_fixed_pmc(pmu, MSR_CORE_PERF_FIXED_CTR0 + i);\n\n\t\tif (old_ctrl == new_ctrl)\n\t\t\tcontinue;\n\n\t\treprogram_fixed_counter(pmc, new_ctrl, i);\n\t}\n\n\tpmu->fixed_ctr_ctrl = data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vcpu_to_pmu",
          "args": [
            "vcpu"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include <asm/perf_event.h>\n#include <linux/perf_event.h>\n#include <linux/kvm_host.h>\n#include <linux/types.h>\n\nstatic int intel_pmu_set_msr(struct kvm_vcpu *vcpu, struct msr_data *msr_info)\n{\n\tstruct kvm_pmu *pmu = vcpu_to_pmu(vcpu);\n\tstruct kvm_pmc *pmc;\n\tu32 msr = msr_info->index;\n\tu64 data = msr_info->data;\n\n\tswitch (msr) {\n\tcase MSR_CORE_PERF_FIXED_CTR_CTRL:\n\t\tif (pmu->fixed_ctr_ctrl == data)\n\t\t\treturn 0;\n\t\tif (!(data & 0xfffffffffffff444ull)) {\n\t\t\treprogram_fixed_counters(pmu, data);\n\t\t\treturn 0;\n\t\t}\n\t\tbreak;\n\tcase MSR_CORE_PERF_GLOBAL_STATUS:\n\t\tif (msr_info->host_initiated) {\n\t\t\tpmu->global_status = data;\n\t\t\treturn 0;\n\t\t}\n\t\tbreak; /* RO MSR */\n\tcase MSR_CORE_PERF_GLOBAL_CTRL:\n\t\tif (pmu->global_ctrl == data)\n\t\t\treturn 0;\n\t\tif (!(data & pmu->global_ctrl_mask)) {\n\t\t\tglobal_ctrl_changed(pmu, data);\n\t\t\treturn 0;\n\t\t}\n\t\tbreak;\n\tcase MSR_CORE_PERF_GLOBAL_OVF_CTRL:\n\t\tif (!(data & (pmu->global_ctrl_mask & ~(3ull<<62)))) {\n\t\t\tif (!msr_info->host_initiated)\n\t\t\t\tpmu->global_status &= ~data;\n\t\t\tpmu->global_ovf_ctrl = data;\n\t\t\treturn 0;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tif ((pmc = get_gp_pmc(pmu, msr, MSR_IA32_PERFCTR0)) ||\n\t\t    (pmc = get_fixed_pmc(pmu, msr))) {\n\t\t\tif (!msr_info->host_initiated)\n\t\t\t\tdata = (s64)(s32)data;\n\t\t\tpmc->counter += data - pmc_read_counter(pmc);\n\t\t\treturn 0;\n\t\t} else if ((pmc = get_gp_pmc(pmu, msr, MSR_P6_EVNTSEL0))) {\n\t\t\tif (data == pmc->eventsel)\n\t\t\t\treturn 0;\n\t\t\tif (!(data & pmu->reserved_bits)) {\n\t\t\t\treprogram_gp_counter(pmc, data);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 1;\n}"
  },
  {
    "function_name": "intel_pmu_get_msr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/pmu_intel.c",
    "lines": "167-197",
    "snippet": "static int intel_pmu_get_msr(struct kvm_vcpu *vcpu, u32 msr, u64 *data)\n{\n\tstruct kvm_pmu *pmu = vcpu_to_pmu(vcpu);\n\tstruct kvm_pmc *pmc;\n\n\tswitch (msr) {\n\tcase MSR_CORE_PERF_FIXED_CTR_CTRL:\n\t\t*data = pmu->fixed_ctr_ctrl;\n\t\treturn 0;\n\tcase MSR_CORE_PERF_GLOBAL_STATUS:\n\t\t*data = pmu->global_status;\n\t\treturn 0;\n\tcase MSR_CORE_PERF_GLOBAL_CTRL:\n\t\t*data = pmu->global_ctrl;\n\t\treturn 0;\n\tcase MSR_CORE_PERF_GLOBAL_OVF_CTRL:\n\t\t*data = pmu->global_ovf_ctrl;\n\t\treturn 0;\n\tdefault:\n\t\tif ((pmc = get_gp_pmc(pmu, msr, MSR_IA32_PERFCTR0)) ||\n\t\t    (pmc = get_fixed_pmc(pmu, msr))) {\n\t\t\t*data = pmc_read_counter(pmc);\n\t\t\treturn 0;\n\t\t} else if ((pmc = get_gp_pmc(pmu, msr, MSR_P6_EVNTSEL0))) {\n\t\t\t*data = pmc->eventsel;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn 1;\n}",
    "includes": [
      "#include \"pmu.h\"",
      "#include \"lapic.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include <asm/perf_event.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_gp_pmc",
          "args": [
            "pmu",
            "msr",
            "MSR_P6_EVNTSEL0"
          ],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "get_gp_pmc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/pmu.h",
          "lines": "80-87",
          "snippet": "static inline struct kvm_pmc *get_gp_pmc(struct kvm_pmu *pmu, u32 msr,\n\t\t\t\t\t u32 base)\n{\n\tif (msr >= base && msr < base + pmu->nr_arch_gp_counters)\n\t\treturn &pmu->gp_counters[msr - base];\n\n\treturn NULL;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct kvm_pmc *get_gp_pmc(struct kvm_pmu *pmu, u32 msr,\n\t\t\t\t\t u32 base)\n{\n\tif (msr >= base && msr < base + pmu->nr_arch_gp_counters)\n\t\treturn &pmu->gp_counters[msr - base];\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pmc_read_counter",
          "args": [
            "pmc"
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "pmc_read_counter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/pmu.h",
          "lines": "40-50",
          "snippet": "static inline u64 pmc_read_counter(struct kvm_pmc *pmc)\n{\n\tu64 counter, enabled, running;\n\n\tcounter = pmc->counter;\n\tif (pmc->perf_event)\n\t\tcounter += perf_event_read_value(pmc->perf_event,\n\t\t\t\t\t\t &enabled, &running);\n\t/* FIXME: Scaling needed? */\n\treturn counter & pmc_bitmask(pmc);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline u64 pmc_read_counter(struct kvm_pmc *pmc)\n{\n\tu64 counter, enabled, running;\n\n\tcounter = pmc->counter;\n\tif (pmc->perf_event)\n\t\tcounter += perf_event_read_value(pmc->perf_event,\n\t\t\t\t\t\t &enabled, &running);\n\t/* FIXME: Scaling needed? */\n\treturn counter & pmc_bitmask(pmc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_fixed_pmc",
          "args": [
            "pmu",
            "msr"
          ],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "get_fixed_pmc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/pmu.h",
          "lines": "90-98",
          "snippet": "static inline struct kvm_pmc *get_fixed_pmc(struct kvm_pmu *pmu, u32 msr)\n{\n\tint base = MSR_CORE_PERF_FIXED_CTR0;\n\n\tif (msr >= base && msr < base + pmu->nr_arch_fixed_counters)\n\t\treturn &pmu->fixed_counters[msr - base];\n\n\treturn NULL;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct kvm_pmc *get_fixed_pmc(struct kvm_pmu *pmu, u32 msr)\n{\n\tint base = MSR_CORE_PERF_FIXED_CTR0;\n\n\tif (msr >= base && msr < base + pmu->nr_arch_fixed_counters)\n\t\treturn &pmu->fixed_counters[msr - base];\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vcpu_to_pmu",
          "args": [
            "vcpu"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include <asm/perf_event.h>\n#include <linux/perf_event.h>\n#include <linux/kvm_host.h>\n#include <linux/types.h>\n\nstatic int intel_pmu_get_msr(struct kvm_vcpu *vcpu, u32 msr, u64 *data)\n{\n\tstruct kvm_pmu *pmu = vcpu_to_pmu(vcpu);\n\tstruct kvm_pmc *pmc;\n\n\tswitch (msr) {\n\tcase MSR_CORE_PERF_FIXED_CTR_CTRL:\n\t\t*data = pmu->fixed_ctr_ctrl;\n\t\treturn 0;\n\tcase MSR_CORE_PERF_GLOBAL_STATUS:\n\t\t*data = pmu->global_status;\n\t\treturn 0;\n\tcase MSR_CORE_PERF_GLOBAL_CTRL:\n\t\t*data = pmu->global_ctrl;\n\t\treturn 0;\n\tcase MSR_CORE_PERF_GLOBAL_OVF_CTRL:\n\t\t*data = pmu->global_ovf_ctrl;\n\t\treturn 0;\n\tdefault:\n\t\tif ((pmc = get_gp_pmc(pmu, msr, MSR_IA32_PERFCTR0)) ||\n\t\t    (pmc = get_fixed_pmc(pmu, msr))) {\n\t\t\t*data = pmc_read_counter(pmc);\n\t\t\treturn 0;\n\t\t} else if ((pmc = get_gp_pmc(pmu, msr, MSR_P6_EVNTSEL0))) {\n\t\t\t*data = pmc->eventsel;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn 1;\n}"
  },
  {
    "function_name": "intel_is_valid_msr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/pmu_intel.c",
    "lines": "145-165",
    "snippet": "static bool intel_is_valid_msr(struct kvm_vcpu *vcpu, u32 msr)\n{\n\tstruct kvm_pmu *pmu = vcpu_to_pmu(vcpu);\n\tint ret;\n\n\tswitch (msr) {\n\tcase MSR_CORE_PERF_FIXED_CTR_CTRL:\n\tcase MSR_CORE_PERF_GLOBAL_STATUS:\n\tcase MSR_CORE_PERF_GLOBAL_CTRL:\n\tcase MSR_CORE_PERF_GLOBAL_OVF_CTRL:\n\t\tret = pmu->version > 1;\n\t\tbreak;\n\tdefault:\n\t\tret = get_gp_pmc(pmu, msr, MSR_IA32_PERFCTR0) ||\n\t\t\tget_gp_pmc(pmu, msr, MSR_P6_EVNTSEL0) ||\n\t\t\tget_fixed_pmc(pmu, msr);\n\t\tbreak;\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"pmu.h\"",
      "#include \"lapic.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include <asm/perf_event.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_fixed_pmc",
          "args": [
            "pmu",
            "msr"
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "get_fixed_pmc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/pmu.h",
          "lines": "90-98",
          "snippet": "static inline struct kvm_pmc *get_fixed_pmc(struct kvm_pmu *pmu, u32 msr)\n{\n\tint base = MSR_CORE_PERF_FIXED_CTR0;\n\n\tif (msr >= base && msr < base + pmu->nr_arch_fixed_counters)\n\t\treturn &pmu->fixed_counters[msr - base];\n\n\treturn NULL;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct kvm_pmc *get_fixed_pmc(struct kvm_pmu *pmu, u32 msr)\n{\n\tint base = MSR_CORE_PERF_FIXED_CTR0;\n\n\tif (msr >= base && msr < base + pmu->nr_arch_fixed_counters)\n\t\treturn &pmu->fixed_counters[msr - base];\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_gp_pmc",
          "args": [
            "pmu",
            "msr",
            "MSR_P6_EVNTSEL0"
          ],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "get_gp_pmc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/pmu.h",
          "lines": "80-87",
          "snippet": "static inline struct kvm_pmc *get_gp_pmc(struct kvm_pmu *pmu, u32 msr,\n\t\t\t\t\t u32 base)\n{\n\tif (msr >= base && msr < base + pmu->nr_arch_gp_counters)\n\t\treturn &pmu->gp_counters[msr - base];\n\n\treturn NULL;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct kvm_pmc *get_gp_pmc(struct kvm_pmu *pmu, u32 msr,\n\t\t\t\t\t u32 base)\n{\n\tif (msr >= base && msr < base + pmu->nr_arch_gp_counters)\n\t\treturn &pmu->gp_counters[msr - base];\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vcpu_to_pmu",
          "args": [
            "vcpu"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include <asm/perf_event.h>\n#include <linux/perf_event.h>\n#include <linux/kvm_host.h>\n#include <linux/types.h>\n\nstatic bool intel_is_valid_msr(struct kvm_vcpu *vcpu, u32 msr)\n{\n\tstruct kvm_pmu *pmu = vcpu_to_pmu(vcpu);\n\tint ret;\n\n\tswitch (msr) {\n\tcase MSR_CORE_PERF_FIXED_CTR_CTRL:\n\tcase MSR_CORE_PERF_GLOBAL_STATUS:\n\tcase MSR_CORE_PERF_GLOBAL_CTRL:\n\tcase MSR_CORE_PERF_GLOBAL_OVF_CTRL:\n\t\tret = pmu->version > 1;\n\t\tbreak;\n\tdefault:\n\t\tret = get_gp_pmc(pmu, msr, MSR_IA32_PERFCTR0) ||\n\t\t\tget_gp_pmc(pmu, msr, MSR_P6_EVNTSEL0) ||\n\t\t\tget_fixed_pmc(pmu, msr);\n\t\tbreak;\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "intel_msr_idx_to_pmc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/pmu_intel.c",
    "lines": "128-143",
    "snippet": "static struct kvm_pmc *intel_msr_idx_to_pmc(struct kvm_vcpu *vcpu,\n\t\t\t\t\t    unsigned idx)\n{\n\tstruct kvm_pmu *pmu = vcpu_to_pmu(vcpu);\n\tbool fixed = idx & (1u << 30);\n\tstruct kvm_pmc *counters;\n\n\tidx &= ~(3u << 30);\n\tif (!fixed && idx >= pmu->nr_arch_gp_counters)\n\t\treturn NULL;\n\tif (fixed && idx >= pmu->nr_arch_fixed_counters)\n\t\treturn NULL;\n\tcounters = fixed ? pmu->fixed_counters : pmu->gp_counters;\n\n\treturn &counters[idx];\n}",
    "includes": [
      "#include \"pmu.h\"",
      "#include \"lapic.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include <asm/perf_event.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vcpu_to_pmu",
          "args": [
            "vcpu"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include <asm/perf_event.h>\n#include <linux/perf_event.h>\n#include <linux/kvm_host.h>\n#include <linux/types.h>\n\nstatic struct kvm_pmc *intel_msr_idx_to_pmc(struct kvm_vcpu *vcpu,\n\t\t\t\t\t    unsigned idx)\n{\n\tstruct kvm_pmu *pmu = vcpu_to_pmu(vcpu);\n\tbool fixed = idx & (1u << 30);\n\tstruct kvm_pmc *counters;\n\n\tidx &= ~(3u << 30);\n\tif (!fixed && idx >= pmu->nr_arch_gp_counters)\n\t\treturn NULL;\n\tif (fixed && idx >= pmu->nr_arch_fixed_counters)\n\t\treturn NULL;\n\tcounters = fixed ? pmu->fixed_counters : pmu->gp_counters;\n\n\treturn &counters[idx];\n}"
  },
  {
    "function_name": "intel_is_valid_msr_idx",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/pmu_intel.c",
    "lines": "117-126",
    "snippet": "static int intel_is_valid_msr_idx(struct kvm_vcpu *vcpu, unsigned idx)\n{\n\tstruct kvm_pmu *pmu = vcpu_to_pmu(vcpu);\n\tbool fixed = idx & (1u << 30);\n\n\tidx &= ~(3u << 30);\n\n\treturn (!fixed && idx >= pmu->nr_arch_gp_counters) ||\n\t\t(fixed && idx >= pmu->nr_arch_fixed_counters);\n}",
    "includes": [
      "#include \"pmu.h\"",
      "#include \"lapic.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include <asm/perf_event.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vcpu_to_pmu",
          "args": [
            "vcpu"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include <asm/perf_event.h>\n#include <linux/perf_event.h>\n#include <linux/kvm_host.h>\n#include <linux/types.h>\n\nstatic int intel_is_valid_msr_idx(struct kvm_vcpu *vcpu, unsigned idx)\n{\n\tstruct kvm_pmu *pmu = vcpu_to_pmu(vcpu);\n\tbool fixed = idx & (1u << 30);\n\n\tidx &= ~(3u << 30);\n\n\treturn (!fixed && idx >= pmu->nr_arch_gp_counters) ||\n\t\t(fixed && idx >= pmu->nr_arch_fixed_counters);\n}"
  },
  {
    "function_name": "intel_pmc_idx_to_pmc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/pmu_intel.c",
    "lines": "104-114",
    "snippet": "static struct kvm_pmc *intel_pmc_idx_to_pmc(struct kvm_pmu *pmu, int pmc_idx)\n{\n\tif (pmc_idx < INTEL_PMC_IDX_FIXED)\n\t\treturn get_gp_pmc(pmu, MSR_P6_EVNTSEL0 + pmc_idx,\n\t\t\t\t  MSR_P6_EVNTSEL0);\n\telse {\n\t\tu32 idx = pmc_idx - INTEL_PMC_IDX_FIXED;\n\n\t\treturn get_fixed_pmc(pmu, idx + MSR_CORE_PERF_FIXED_CTR0);\n\t}\n}",
    "includes": [
      "#include \"pmu.h\"",
      "#include \"lapic.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include <asm/perf_event.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_fixed_pmc",
          "args": [
            "pmu",
            "idx + MSR_CORE_PERF_FIXED_CTR0"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "get_fixed_pmc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/pmu.h",
          "lines": "90-98",
          "snippet": "static inline struct kvm_pmc *get_fixed_pmc(struct kvm_pmu *pmu, u32 msr)\n{\n\tint base = MSR_CORE_PERF_FIXED_CTR0;\n\n\tif (msr >= base && msr < base + pmu->nr_arch_fixed_counters)\n\t\treturn &pmu->fixed_counters[msr - base];\n\n\treturn NULL;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct kvm_pmc *get_fixed_pmc(struct kvm_pmu *pmu, u32 msr)\n{\n\tint base = MSR_CORE_PERF_FIXED_CTR0;\n\n\tif (msr >= base && msr < base + pmu->nr_arch_fixed_counters)\n\t\treturn &pmu->fixed_counters[msr - base];\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_gp_pmc",
          "args": [
            "pmu",
            "MSR_P6_EVNTSEL0 + pmc_idx",
            "MSR_P6_EVNTSEL0"
          ],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "get_gp_pmc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/pmu.h",
          "lines": "80-87",
          "snippet": "static inline struct kvm_pmc *get_gp_pmc(struct kvm_pmu *pmu, u32 msr,\n\t\t\t\t\t u32 base)\n{\n\tif (msr >= base && msr < base + pmu->nr_arch_gp_counters)\n\t\treturn &pmu->gp_counters[msr - base];\n\n\treturn NULL;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct kvm_pmc *get_gp_pmc(struct kvm_pmu *pmu, u32 msr,\n\t\t\t\t\t u32 base)\n{\n\tif (msr >= base && msr < base + pmu->nr_arch_gp_counters)\n\t\treturn &pmu->gp_counters[msr - base];\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include <asm/perf_event.h>\n#include <linux/perf_event.h>\n#include <linux/kvm_host.h>\n#include <linux/types.h>\n\nstatic struct kvm_pmc *intel_pmc_idx_to_pmc(struct kvm_pmu *pmu, int pmc_idx)\n{\n\tif (pmc_idx < INTEL_PMC_IDX_FIXED)\n\t\treturn get_gp_pmc(pmu, MSR_P6_EVNTSEL0 + pmc_idx,\n\t\t\t\t  MSR_P6_EVNTSEL0);\n\telse {\n\t\tu32 idx = pmc_idx - INTEL_PMC_IDX_FIXED;\n\n\t\treturn get_fixed_pmc(pmu, idx + MSR_CORE_PERF_FIXED_CTR0);\n\t}\n}"
  },
  {
    "function_name": "intel_pmc_is_enabled",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/pmu_intel.c",
    "lines": "97-102",
    "snippet": "static bool intel_pmc_is_enabled(struct kvm_pmc *pmc)\n{\n\tstruct kvm_pmu *pmu = pmc_to_pmu(pmc);\n\n\treturn test_bit(pmc->idx, (unsigned long *)&pmu->global_ctrl);\n}",
    "includes": [
      "#include \"pmu.h\"",
      "#include \"lapic.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include <asm/perf_event.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "pmc->idx",
            "(unsigned long *)&pmu->global_ctrl"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmc_to_pmu",
          "args": [
            "pmc"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include <asm/perf_event.h>\n#include <linux/perf_event.h>\n#include <linux/kvm_host.h>\n#include <linux/types.h>\n\nstatic bool intel_pmc_is_enabled(struct kvm_pmc *pmc)\n{\n\tstruct kvm_pmu *pmu = pmc_to_pmu(pmc);\n\n\treturn test_bit(pmc->idx, (unsigned long *)&pmu->global_ctrl);\n}"
  },
  {
    "function_name": "intel_find_fixed_event",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/pmu_intel.c",
    "lines": "88-94",
    "snippet": "static unsigned intel_find_fixed_event(int idx)\n{\n\tif (idx >= ARRAY_SIZE(fixed_pmc_events))\n\t\treturn PERF_COUNT_HW_MAX;\n\n\treturn intel_arch_events[fixed_pmc_events[idx]].event_type;\n}",
    "includes": [
      "#include \"pmu.h\"",
      "#include \"lapic.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include <asm/perf_event.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kvm_event_hw_type_mapping intel_arch_events[] = {\n\t/* Index must match CPUID 0x0A.EBX bit vector */\n\t[0] = { 0x3c, 0x00, PERF_COUNT_HW_CPU_CYCLES },\n\t[1] = { 0xc0, 0x00, PERF_COUNT_HW_INSTRUCTIONS },\n\t[2] = { 0x3c, 0x01, PERF_COUNT_HW_BUS_CYCLES  },\n\t[3] = { 0x2e, 0x4f, PERF_COUNT_HW_CACHE_REFERENCES },\n\t[4] = { 0x2e, 0x41, PERF_COUNT_HW_CACHE_MISSES },\n\t[5] = { 0xc4, 0x00, PERF_COUNT_HW_BRANCH_INSTRUCTIONS },\n\t[6] = { 0xc5, 0x00, PERF_COUNT_HW_BRANCH_MISSES },\n\t[7] = { 0x00, 0x30, PERF_COUNT_HW_REF_CPU_CYCLES },\n};",
      "static int fixed_pmc_events[] = {1, 0, 7};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "fixed_pmc_events"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include <asm/perf_event.h>\n#include <linux/perf_event.h>\n#include <linux/kvm_host.h>\n#include <linux/types.h>\n\nstatic struct kvm_event_hw_type_mapping intel_arch_events[] = {\n\t/* Index must match CPUID 0x0A.EBX bit vector */\n\t[0] = { 0x3c, 0x00, PERF_COUNT_HW_CPU_CYCLES },\n\t[1] = { 0xc0, 0x00, PERF_COUNT_HW_INSTRUCTIONS },\n\t[2] = { 0x3c, 0x01, PERF_COUNT_HW_BUS_CYCLES  },\n\t[3] = { 0x2e, 0x4f, PERF_COUNT_HW_CACHE_REFERENCES },\n\t[4] = { 0x2e, 0x41, PERF_COUNT_HW_CACHE_MISSES },\n\t[5] = { 0xc4, 0x00, PERF_COUNT_HW_BRANCH_INSTRUCTIONS },\n\t[6] = { 0xc5, 0x00, PERF_COUNT_HW_BRANCH_MISSES },\n\t[7] = { 0x00, 0x30, PERF_COUNT_HW_REF_CPU_CYCLES },\n};\nstatic int fixed_pmc_events[] = {1, 0, 7};\n\nstatic unsigned intel_find_fixed_event(int idx)\n{\n\tif (idx >= ARRAY_SIZE(fixed_pmc_events))\n\t\treturn PERF_COUNT_HW_MAX;\n\n\treturn intel_arch_events[fixed_pmc_events[idx]].event_type;\n}"
  },
  {
    "function_name": "intel_find_arch_event",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/pmu_intel.c",
    "lines": "70-86",
    "snippet": "static unsigned intel_find_arch_event(struct kvm_pmu *pmu,\n\t\t\t\t      u8 event_select,\n\t\t\t\t      u8 unit_mask)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(intel_arch_events); i++)\n\t\tif (intel_arch_events[i].eventsel == event_select\n\t\t    && intel_arch_events[i].unit_mask == unit_mask\n\t\t    && (pmu->available_event_types & (1 << i)))\n\t\t\tbreak;\n\n\tif (i == ARRAY_SIZE(intel_arch_events))\n\t\treturn PERF_COUNT_HW_MAX;\n\n\treturn intel_arch_events[i].event_type;\n}",
    "includes": [
      "#include \"pmu.h\"",
      "#include \"lapic.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include <asm/perf_event.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kvm_event_hw_type_mapping intel_arch_events[] = {\n\t/* Index must match CPUID 0x0A.EBX bit vector */\n\t[0] = { 0x3c, 0x00, PERF_COUNT_HW_CPU_CYCLES },\n\t[1] = { 0xc0, 0x00, PERF_COUNT_HW_INSTRUCTIONS },\n\t[2] = { 0x3c, 0x01, PERF_COUNT_HW_BUS_CYCLES  },\n\t[3] = { 0x2e, 0x4f, PERF_COUNT_HW_CACHE_REFERENCES },\n\t[4] = { 0x2e, 0x41, PERF_COUNT_HW_CACHE_MISSES },\n\t[5] = { 0xc4, 0x00, PERF_COUNT_HW_BRANCH_INSTRUCTIONS },\n\t[6] = { 0xc5, 0x00, PERF_COUNT_HW_BRANCH_MISSES },\n\t[7] = { 0x00, 0x30, PERF_COUNT_HW_REF_CPU_CYCLES },\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "intel_arch_events"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "intel_arch_events"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include <asm/perf_event.h>\n#include <linux/perf_event.h>\n#include <linux/kvm_host.h>\n#include <linux/types.h>\n\nstatic struct kvm_event_hw_type_mapping intel_arch_events[] = {\n\t/* Index must match CPUID 0x0A.EBX bit vector */\n\t[0] = { 0x3c, 0x00, PERF_COUNT_HW_CPU_CYCLES },\n\t[1] = { 0xc0, 0x00, PERF_COUNT_HW_INSTRUCTIONS },\n\t[2] = { 0x3c, 0x01, PERF_COUNT_HW_BUS_CYCLES  },\n\t[3] = { 0x2e, 0x4f, PERF_COUNT_HW_CACHE_REFERENCES },\n\t[4] = { 0x2e, 0x41, PERF_COUNT_HW_CACHE_MISSES },\n\t[5] = { 0xc4, 0x00, PERF_COUNT_HW_BRANCH_INSTRUCTIONS },\n\t[6] = { 0xc5, 0x00, PERF_COUNT_HW_BRANCH_MISSES },\n\t[7] = { 0x00, 0x30, PERF_COUNT_HW_REF_CPU_CYCLES },\n};\n\nstatic unsigned intel_find_arch_event(struct kvm_pmu *pmu,\n\t\t\t\t      u8 event_select,\n\t\t\t\t      u8 unit_mask)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(intel_arch_events); i++)\n\t\tif (intel_arch_events[i].eventsel == event_select\n\t\t    && intel_arch_events[i].unit_mask == unit_mask\n\t\t    && (pmu->available_event_types & (1 << i)))\n\t\t\tbreak;\n\n\tif (i == ARRAY_SIZE(intel_arch_events))\n\t\treturn PERF_COUNT_HW_MAX;\n\n\treturn intel_arch_events[i].event_type;\n}"
  },
  {
    "function_name": "global_ctrl_changed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/pmu_intel.c",
    "lines": "59-68",
    "snippet": "static void global_ctrl_changed(struct kvm_pmu *pmu, u64 data)\n{\n\tint bit;\n\tu64 diff = pmu->global_ctrl ^ data;\n\n\tpmu->global_ctrl = data;\n\n\tfor_each_set_bit(bit, (unsigned long *)&diff, X86_PMC_IDX_MAX)\n\t\treprogram_counter(pmu, bit);\n}",
    "includes": [
      "#include \"pmu.h\"",
      "#include \"lapic.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include <asm/perf_event.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reprogram_counter",
          "args": [
            "pmu",
            "bit"
          ],
          "line": 67
        },
        "resolved": true,
        "details": {
          "function_name": "reprogram_counter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/pmu.c",
          "lines": "196-211",
          "snippet": "void reprogram_counter(struct kvm_pmu *pmu, int pmc_idx)\n{\n\tstruct kvm_pmc *pmc = kvm_x86_ops->pmu_ops->pmc_idx_to_pmc(pmu, pmc_idx);\n\n\tif (!pmc)\n\t\treturn;\n\n\tif (pmc_is_gp(pmc))\n\t\treprogram_gp_counter(pmc, pmc->eventsel);\n\telse {\n\t\tint idx = pmc_idx - INTEL_PMC_IDX_FIXED;\n\t\tu8 ctrl = fixed_ctrl_field(pmu->fixed_ctr_ctrl, idx);\n\n\t\treprogram_fixed_counter(pmc, ctrl, idx);\n\t}\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"lapic.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include <asm/perf_event.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include <asm/perf_event.h>\n#include <linux/perf_event.h>\n#include <linux/kvm_host.h>\n#include <linux/types.h>\n\nvoid reprogram_counter(struct kvm_pmu *pmu, int pmc_idx)\n{\n\tstruct kvm_pmc *pmc = kvm_x86_ops->pmu_ops->pmc_idx_to_pmc(pmu, pmc_idx);\n\n\tif (!pmc)\n\t\treturn;\n\n\tif (pmc_is_gp(pmc))\n\t\treprogram_gp_counter(pmc, pmc->eventsel);\n\telse {\n\t\tint idx = pmc_idx - INTEL_PMC_IDX_FIXED;\n\t\tu8 ctrl = fixed_ctrl_field(pmu->fixed_ctr_ctrl, idx);\n\n\t\treprogram_fixed_counter(pmc, ctrl, idx);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_set_bit",
          "args": [
            "bit",
            "(unsigned long *)&diff",
            "X86_PMC_IDX_MAX"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include <asm/perf_event.h>\n#include <linux/perf_event.h>\n#include <linux/kvm_host.h>\n#include <linux/types.h>\n\nstatic void global_ctrl_changed(struct kvm_pmu *pmu, u64 data)\n{\n\tint bit;\n\tu64 diff = pmu->global_ctrl ^ data;\n\n\tpmu->global_ctrl = data;\n\n\tfor_each_set_bit(bit, (unsigned long *)&diff, X86_PMC_IDX_MAX)\n\t\treprogram_counter(pmu, bit);\n}"
  },
  {
    "function_name": "reprogram_fixed_counters",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/pmu_intel.c",
    "lines": "38-56",
    "snippet": "static void reprogram_fixed_counters(struct kvm_pmu *pmu, u64 data)\n{\n\tint i;\n\n\tfor (i = 0; i < pmu->nr_arch_fixed_counters; i++) {\n\t\tu8 new_ctrl = fixed_ctrl_field(data, i);\n\t\tu8 old_ctrl = fixed_ctrl_field(pmu->fixed_ctr_ctrl, i);\n\t\tstruct kvm_pmc *pmc;\n\n\t\tpmc = get_fixed_pmc(pmu, MSR_CORE_PERF_FIXED_CTR0 + i);\n\n\t\tif (old_ctrl == new_ctrl)\n\t\t\tcontinue;\n\n\t\treprogram_fixed_counter(pmc, new_ctrl, i);\n\t}\n\n\tpmu->fixed_ctr_ctrl = data;\n}",
    "includes": [
      "#include \"pmu.h\"",
      "#include \"lapic.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include <asm/perf_event.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reprogram_fixed_counter",
          "args": [
            "pmc",
            "new_ctrl",
            "i"
          ],
          "line": 52
        },
        "resolved": true,
        "details": {
          "function_name": "reprogram_fixed_counter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/pmu.c",
          "lines": "178-193",
          "snippet": "void reprogram_fixed_counter(struct kvm_pmc *pmc, u8 ctrl, int idx)\n{\n\tunsigned en_field = ctrl & 0x3;\n\tbool pmi = ctrl & 0x8;\n\n\tpmc_stop_counter(pmc);\n\n\tif (!en_field || !pmc_is_enabled(pmc))\n\t\treturn;\n\n\tpmc_reprogram_counter(pmc, PERF_TYPE_HARDWARE,\n\t\t\t      kvm_x86_ops->pmu_ops->find_fixed_event(idx),\n\t\t\t      !(en_field & 0x2), /* exclude user */\n\t\t\t      !(en_field & 0x1), /* exclude kernel */\n\t\t\t      pmi, false, false);\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"lapic.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include <asm/perf_event.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include <asm/perf_event.h>\n#include <linux/perf_event.h>\n#include <linux/kvm_host.h>\n#include <linux/types.h>\n\nvoid reprogram_fixed_counter(struct kvm_pmc *pmc, u8 ctrl, int idx)\n{\n\tunsigned en_field = ctrl & 0x3;\n\tbool pmi = ctrl & 0x8;\n\n\tpmc_stop_counter(pmc);\n\n\tif (!en_field || !pmc_is_enabled(pmc))\n\t\treturn;\n\n\tpmc_reprogram_counter(pmc, PERF_TYPE_HARDWARE,\n\t\t\t      kvm_x86_ops->pmu_ops->find_fixed_event(idx),\n\t\t\t      !(en_field & 0x2), /* exclude user */\n\t\t\t      !(en_field & 0x1), /* exclude kernel */\n\t\t\t      pmi, false, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_fixed_pmc",
          "args": [
            "pmu",
            "MSR_CORE_PERF_FIXED_CTR0 + i"
          ],
          "line": 47
        },
        "resolved": true,
        "details": {
          "function_name": "get_fixed_pmc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/pmu.h",
          "lines": "90-98",
          "snippet": "static inline struct kvm_pmc *get_fixed_pmc(struct kvm_pmu *pmu, u32 msr)\n{\n\tint base = MSR_CORE_PERF_FIXED_CTR0;\n\n\tif (msr >= base && msr < base + pmu->nr_arch_fixed_counters)\n\t\treturn &pmu->fixed_counters[msr - base];\n\n\treturn NULL;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct kvm_pmc *get_fixed_pmc(struct kvm_pmu *pmu, u32 msr)\n{\n\tint base = MSR_CORE_PERF_FIXED_CTR0;\n\n\tif (msr >= base && msr < base + pmu->nr_arch_fixed_counters)\n\t\treturn &pmu->fixed_counters[msr - base];\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fixed_ctrl_field",
          "args": [
            "pmu->fixed_ctr_ctrl",
            "i"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fixed_ctrl_field",
          "args": [
            "data",
            "i"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include <asm/perf_event.h>\n#include <linux/perf_event.h>\n#include <linux/kvm_host.h>\n#include <linux/types.h>\n\nstatic void reprogram_fixed_counters(struct kvm_pmu *pmu, u64 data)\n{\n\tint i;\n\n\tfor (i = 0; i < pmu->nr_arch_fixed_counters; i++) {\n\t\tu8 new_ctrl = fixed_ctrl_field(data, i);\n\t\tu8 old_ctrl = fixed_ctrl_field(pmu->fixed_ctr_ctrl, i);\n\t\tstruct kvm_pmc *pmc;\n\n\t\tpmc = get_fixed_pmc(pmu, MSR_CORE_PERF_FIXED_CTR0 + i);\n\n\t\tif (old_ctrl == new_ctrl)\n\t\t\tcontinue;\n\n\t\treprogram_fixed_counter(pmc, new_ctrl, i);\n\t}\n\n\tpmu->fixed_ctr_ctrl = data;\n}"
  }
]