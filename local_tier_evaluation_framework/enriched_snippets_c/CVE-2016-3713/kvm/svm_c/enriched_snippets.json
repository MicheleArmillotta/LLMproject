[
  {
    "function_name": "svm_exit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "5078-5081",
    "snippet": "static void __exit svm_exit(void)\n{\n\tkvm_exit();\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_exit",
          "args": [],
          "line": 5080
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void __exit svm_exit(void)\n{\n\tkvm_exit();\n}"
  },
  {
    "function_name": "svm_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "5072-5076",
    "snippet": "static int __init svm_init(void)\n{\n\treturn kvm_init(&svm_x86_ops, sizeof(struct vcpu_svm),\n\t\t\t__alignof__(struct vcpu_svm), THIS_MODULE);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kvm_x86_ops svm_x86_ops = {\n\t.cpu_has_kvm_support = has_svm,\n\t.disabled_by_bios = is_disabled,\n\t.hardware_setup = svm_hardware_setup,\n\t.hardware_unsetup = svm_hardware_unsetup,\n\t.check_processor_compatibility = svm_check_processor_compat,\n\t.hardware_enable = svm_hardware_enable,\n\t.hardware_disable = svm_hardware_disable,\n\t.cpu_has_accelerated_tpr = svm_cpu_has_accelerated_tpr,\n\t.cpu_has_high_real_mode_segbase = svm_has_high_real_mode_segbase,\n\n\t.vcpu_create = svm_create_vcpu,\n\t.vcpu_free = svm_free_vcpu,\n\t.vcpu_reset = svm_vcpu_reset,\n\n\t.vm_init = avic_vm_init,\n\t.vm_destroy = avic_vm_destroy,\n\n\t.prepare_guest_switch = svm_prepare_guest_switch,\n\t.vcpu_load = svm_vcpu_load,\n\t.vcpu_put = svm_vcpu_put,\n\t.vcpu_blocking = svm_vcpu_blocking,\n\t.vcpu_unblocking = svm_vcpu_unblocking,\n\n\t.update_bp_intercept = update_bp_intercept,\n\t.get_msr = svm_get_msr,\n\t.set_msr = svm_set_msr,\n\t.get_segment_base = svm_get_segment_base,\n\t.get_segment = svm_get_segment,\n\t.set_segment = svm_set_segment,\n\t.get_cpl = svm_get_cpl,\n\t.get_cs_db_l_bits = kvm_get_cs_db_l_bits,\n\t.decache_cr0_guest_bits = svm_decache_cr0_guest_bits,\n\t.decache_cr3 = svm_decache_cr3,\n\t.decache_cr4_guest_bits = svm_decache_cr4_guest_bits,\n\t.set_cr0 = svm_set_cr0,\n\t.set_cr3 = svm_set_cr3,\n\t.set_cr4 = svm_set_cr4,\n\t.set_efer = svm_set_efer,\n\t.get_idt = svm_get_idt,\n\t.set_idt = svm_set_idt,\n\t.get_gdt = svm_get_gdt,\n\t.set_gdt = svm_set_gdt,\n\t.get_dr6 = svm_get_dr6,\n\t.set_dr6 = svm_set_dr6,\n\t.set_dr7 = svm_set_dr7,\n\t.sync_dirty_debug_regs = svm_sync_dirty_debug_regs,\n\t.cache_reg = svm_cache_reg,\n\t.get_rflags = svm_get_rflags,\n\t.set_rflags = svm_set_rflags,\n\n\t.get_pkru = svm_get_pkru,\n\n\t.fpu_activate = svm_fpu_activate,\n\t.fpu_deactivate = svm_fpu_deactivate,\n\n\t.tlb_flush = svm_flush_tlb,\n\n\t.run = svm_vcpu_run,\n\t.handle_exit = handle_exit,\n\t.skip_emulated_instruction = skip_emulated_instruction,\n\t.set_interrupt_shadow = svm_set_interrupt_shadow,\n\t.get_interrupt_shadow = svm_get_interrupt_shadow,\n\t.patch_hypercall = svm_patch_hypercall,\n\t.set_irq = svm_set_irq,\n\t.set_nmi = svm_inject_nmi,\n\t.queue_exception = svm_queue_exception,\n\t.cancel_injection = svm_cancel_injection,\n\t.interrupt_allowed = svm_interrupt_allowed,\n\t.nmi_allowed = svm_nmi_allowed,\n\t.get_nmi_mask = svm_get_nmi_mask,\n\t.set_nmi_mask = svm_set_nmi_mask,\n\t.enable_nmi_window = enable_nmi_window,\n\t.enable_irq_window = enable_irq_window,\n\t.update_cr8_intercept = update_cr8_intercept,\n\t.set_virtual_x2apic_mode = svm_set_virtual_x2apic_mode,\n\t.get_enable_apicv = svm_get_enable_apicv,\n\t.refresh_apicv_exec_ctrl = svm_refresh_apicv_exec_ctrl,\n\t.load_eoi_exitmap = svm_load_eoi_exitmap,\n\t.sync_pir_to_irr = svm_sync_pir_to_irr,\n\t.hwapic_irr_update = svm_hwapic_irr_update,\n\t.hwapic_isr_update = svm_hwapic_isr_update,\n\t.apicv_post_state_restore = avic_post_state_restore,\n\n\t.set_tss_addr = svm_set_tss_addr,\n\t.get_tdp_level = get_npt_level,\n\t.get_mt_mask = svm_get_mt_mask,\n\n\t.get_exit_info = svm_get_exit_info,\n\n\t.get_lpage_level = svm_get_lpage_level,\n\n\t.cpuid_update = svm_cpuid_update,\n\n\t.rdtscp_supported = svm_rdtscp_supported,\n\t.invpcid_supported = svm_invpcid_supported,\n\t.mpx_supported = svm_mpx_supported,\n\t.xsaves_supported = svm_xsaves_supported,\n\n\t.set_supported_cpuid = svm_set_supported_cpuid,\n\n\t.has_wbinvd_exit = svm_has_wbinvd_exit,\n\n\t.read_tsc_offset = svm_read_tsc_offset,\n\t.write_tsc_offset = svm_write_tsc_offset,\n\t.adjust_tsc_offset_guest = svm_adjust_tsc_offset_guest,\n\t.read_l1_tsc = svm_read_l1_tsc,\n\n\t.set_tdp_cr3 = set_tdp_cr3,\n\n\t.check_intercept = svm_check_intercept,\n\t.handle_external_intr = svm_handle_external_intr,\n\n\t.sched_in = svm_sched_in,\n\n\t.pmu_ops = &amd_pmu_ops,\n\t.deliver_posted_interrupt = svm_deliver_avic_intr,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_init",
          "args": [
            "&svm_x86_ops",
            "sizeof(struct vcpu_svm)",
            "__alignof__(struct vcpu_svm)",
            "THIS_MODULE"
          ],
          "line": 5074
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic struct kvm_x86_ops svm_x86_ops = {\n\t.cpu_has_kvm_support = has_svm,\n\t.disabled_by_bios = is_disabled,\n\t.hardware_setup = svm_hardware_setup,\n\t.hardware_unsetup = svm_hardware_unsetup,\n\t.check_processor_compatibility = svm_check_processor_compat,\n\t.hardware_enable = svm_hardware_enable,\n\t.hardware_disable = svm_hardware_disable,\n\t.cpu_has_accelerated_tpr = svm_cpu_has_accelerated_tpr,\n\t.cpu_has_high_real_mode_segbase = svm_has_high_real_mode_segbase,\n\n\t.vcpu_create = svm_create_vcpu,\n\t.vcpu_free = svm_free_vcpu,\n\t.vcpu_reset = svm_vcpu_reset,\n\n\t.vm_init = avic_vm_init,\n\t.vm_destroy = avic_vm_destroy,\n\n\t.prepare_guest_switch = svm_prepare_guest_switch,\n\t.vcpu_load = svm_vcpu_load,\n\t.vcpu_put = svm_vcpu_put,\n\t.vcpu_blocking = svm_vcpu_blocking,\n\t.vcpu_unblocking = svm_vcpu_unblocking,\n\n\t.update_bp_intercept = update_bp_intercept,\n\t.get_msr = svm_get_msr,\n\t.set_msr = svm_set_msr,\n\t.get_segment_base = svm_get_segment_base,\n\t.get_segment = svm_get_segment,\n\t.set_segment = svm_set_segment,\n\t.get_cpl = svm_get_cpl,\n\t.get_cs_db_l_bits = kvm_get_cs_db_l_bits,\n\t.decache_cr0_guest_bits = svm_decache_cr0_guest_bits,\n\t.decache_cr3 = svm_decache_cr3,\n\t.decache_cr4_guest_bits = svm_decache_cr4_guest_bits,\n\t.set_cr0 = svm_set_cr0,\n\t.set_cr3 = svm_set_cr3,\n\t.set_cr4 = svm_set_cr4,\n\t.set_efer = svm_set_efer,\n\t.get_idt = svm_get_idt,\n\t.set_idt = svm_set_idt,\n\t.get_gdt = svm_get_gdt,\n\t.set_gdt = svm_set_gdt,\n\t.get_dr6 = svm_get_dr6,\n\t.set_dr6 = svm_set_dr6,\n\t.set_dr7 = svm_set_dr7,\n\t.sync_dirty_debug_regs = svm_sync_dirty_debug_regs,\n\t.cache_reg = svm_cache_reg,\n\t.get_rflags = svm_get_rflags,\n\t.set_rflags = svm_set_rflags,\n\n\t.get_pkru = svm_get_pkru,\n\n\t.fpu_activate = svm_fpu_activate,\n\t.fpu_deactivate = svm_fpu_deactivate,\n\n\t.tlb_flush = svm_flush_tlb,\n\n\t.run = svm_vcpu_run,\n\t.handle_exit = handle_exit,\n\t.skip_emulated_instruction = skip_emulated_instruction,\n\t.set_interrupt_shadow = svm_set_interrupt_shadow,\n\t.get_interrupt_shadow = svm_get_interrupt_shadow,\n\t.patch_hypercall = svm_patch_hypercall,\n\t.set_irq = svm_set_irq,\n\t.set_nmi = svm_inject_nmi,\n\t.queue_exception = svm_queue_exception,\n\t.cancel_injection = svm_cancel_injection,\n\t.interrupt_allowed = svm_interrupt_allowed,\n\t.nmi_allowed = svm_nmi_allowed,\n\t.get_nmi_mask = svm_get_nmi_mask,\n\t.set_nmi_mask = svm_set_nmi_mask,\n\t.enable_nmi_window = enable_nmi_window,\n\t.enable_irq_window = enable_irq_window,\n\t.update_cr8_intercept = update_cr8_intercept,\n\t.set_virtual_x2apic_mode = svm_set_virtual_x2apic_mode,\n\t.get_enable_apicv = svm_get_enable_apicv,\n\t.refresh_apicv_exec_ctrl = svm_refresh_apicv_exec_ctrl,\n\t.load_eoi_exitmap = svm_load_eoi_exitmap,\n\t.sync_pir_to_irr = svm_sync_pir_to_irr,\n\t.hwapic_irr_update = svm_hwapic_irr_update,\n\t.hwapic_isr_update = svm_hwapic_isr_update,\n\t.apicv_post_state_restore = avic_post_state_restore,\n\n\t.set_tss_addr = svm_set_tss_addr,\n\t.get_tdp_level = get_npt_level,\n\t.get_mt_mask = svm_get_mt_mask,\n\n\t.get_exit_info = svm_get_exit_info,\n\n\t.get_lpage_level = svm_get_lpage_level,\n\n\t.cpuid_update = svm_cpuid_update,\n\n\t.rdtscp_supported = svm_rdtscp_supported,\n\t.invpcid_supported = svm_invpcid_supported,\n\t.mpx_supported = svm_mpx_supported,\n\t.xsaves_supported = svm_xsaves_supported,\n\n\t.set_supported_cpuid = svm_set_supported_cpuid,\n\n\t.has_wbinvd_exit = svm_has_wbinvd_exit,\n\n\t.read_tsc_offset = svm_read_tsc_offset,\n\t.write_tsc_offset = svm_write_tsc_offset,\n\t.adjust_tsc_offset_guest = svm_adjust_tsc_offset_guest,\n\t.read_l1_tsc = svm_read_l1_tsc,\n\n\t.set_tdp_cr3 = set_tdp_cr3,\n\n\t.check_intercept = svm_check_intercept,\n\t.handle_external_intr = svm_handle_external_intr,\n\n\t.sched_in = svm_sched_in,\n\n\t.pmu_ops = &amd_pmu_ops,\n\t.deliver_posted_interrupt = svm_deliver_avic_intr,\n};\n\nstatic int __init svm_init(void)\n{\n\treturn kvm_init(&svm_x86_ops, sizeof(struct vcpu_svm),\n\t\t\t__alignof__(struct vcpu_svm), THIS_MODULE);\n}"
  },
  {
    "function_name": "avic_post_state_restore",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "4944-4951",
    "snippet": "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu)\n{\n\tif (avic_handle_apic_id_update(vcpu) != 0)\n\t\treturn;\n\tif (avic_handle_dfr_update(vcpu) != 0)\n\t\treturn;\n\tavic_handle_ldr_update(vcpu);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "avic_handle_ldr_update",
          "args": [
            "vcpu"
          ],
          "line": 4950
        },
        "resolved": true,
        "details": {
          "function_name": "avic_handle_ldr_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "3707-3724",
          "snippet": "static int avic_handle_ldr_update(struct kvm_vcpu *vcpu)\n{\n\tint ret;\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tu32 ldr = kvm_lapic_get_reg(vcpu->arch.apic, APIC_LDR);\n\n\tif (!ldr)\n\t\treturn 1;\n\n\tret = avic_ldr_write(vcpu, vcpu->vcpu_id, ldr, true);\n\tif (ret && svm->ldr_reg) {\n\t\tavic_ldr_write(vcpu, 0, svm->ldr_reg, false);\n\t\tsvm->ldr_reg = 0;\n\t} else {\n\t\tsvm->ldr_reg = ldr;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic int avic_handle_ldr_update(struct kvm_vcpu *vcpu)\n{\n\tint ret;\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tu32 ldr = kvm_lapic_get_reg(vcpu->arch.apic, APIC_LDR);\n\n\tif (!ldr)\n\t\treturn 1;\n\n\tret = avic_ldr_write(vcpu, vcpu->vcpu_id, ldr, true);\n\tif (ret && svm->ldr_reg) {\n\t\tavic_ldr_write(vcpu, 0, svm->ldr_reg, false);\n\t\tsvm->ldr_reg = 0;\n\t} else {\n\t\tsvm->ldr_reg = ldr;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "avic_handle_dfr_update",
          "args": [
            "vcpu"
          ],
          "line": 4948
        },
        "resolved": true,
        "details": {
          "function_name": "avic_handle_dfr_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "3756-3777",
          "snippet": "static int avic_handle_dfr_update(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tstruct kvm_arch *vm_data = &vcpu->kvm->arch;\n\tu32 dfr = kvm_lapic_get_reg(vcpu->arch.apic, APIC_DFR);\n\tu32 mod = (dfr >> 28) & 0xf;\n\n\t/*\n\t * We assume that all local APICs are using the same type.\n\t * If this changes, we need to flush the AVIC logical\n\t * APID id table.\n\t */\n\tif (vm_data->ldr_mode == mod)\n\t\treturn 0;\n\n\tclear_page(page_address(vm_data->avic_logical_id_table_page));\n\tvm_data->ldr_mode = mod;\n\n\tif (svm->ldr_reg)\n\t\tavic_handle_ldr_update(vcpu);\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic int avic_handle_dfr_update(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tstruct kvm_arch *vm_data = &vcpu->kvm->arch;\n\tu32 dfr = kvm_lapic_get_reg(vcpu->arch.apic, APIC_DFR);\n\tu32 mod = (dfr >> 28) & 0xf;\n\n\t/*\n\t * We assume that all local APICs are using the same type.\n\t * If this changes, we need to flush the AVIC logical\n\t * APID id table.\n\t */\n\tif (vm_data->ldr_mode == mod)\n\t\treturn 0;\n\n\tclear_page(page_address(vm_data->avic_logical_id_table_page));\n\tvm_data->ldr_mode = mod;\n\n\tif (svm->ldr_reg)\n\t\tavic_handle_ldr_update(vcpu);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "avic_handle_apic_id_update",
          "args": [
            "vcpu"
          ],
          "line": 4946
        },
        "resolved": true,
        "details": {
          "function_name": "avic_handle_apic_id_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "3726-3754",
          "snippet": "static int avic_handle_apic_id_update(struct kvm_vcpu *vcpu)\n{\n\tu64 *old, *new;\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tu32 apic_id_reg = kvm_lapic_get_reg(vcpu->arch.apic, APIC_ID);\n\tu32 id = (apic_id_reg >> 24) & 0xff;\n\n\tif (vcpu->vcpu_id == id)\n\t\treturn 0;\n\n\told = avic_get_physical_id_entry(vcpu, vcpu->vcpu_id);\n\tnew = avic_get_physical_id_entry(vcpu, id);\n\tif (!new || !old)\n\t\treturn 1;\n\n\t/* We need to move physical_id_entry to new offset */\n\t*new = *old;\n\t*old = 0ULL;\n\tto_svm(vcpu)->avic_physical_id_cache = new;\n\n\t/*\n\t * Also update the guest physical APIC ID in the logical\n\t * APIC ID table entry if already setup the LDR.\n\t */\n\tif (svm->ldr_reg)\n\t\tavic_handle_ldr_update(vcpu);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic int avic_handle_apic_id_update(struct kvm_vcpu *vcpu)\n{\n\tu64 *old, *new;\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tu32 apic_id_reg = kvm_lapic_get_reg(vcpu->arch.apic, APIC_ID);\n\tu32 id = (apic_id_reg >> 24) & 0xff;\n\n\tif (vcpu->vcpu_id == id)\n\t\treturn 0;\n\n\told = avic_get_physical_id_entry(vcpu, vcpu->vcpu_id);\n\tnew = avic_get_physical_id_entry(vcpu, id);\n\tif (!new || !old)\n\t\treturn 1;\n\n\t/* We need to move physical_id_entry to new offset */\n\t*new = *old;\n\t*old = 0ULL;\n\tto_svm(vcpu)->avic_physical_id_cache = new;\n\n\t/*\n\t * Also update the guest physical APIC ID in the logical\n\t * APIC ID table entry if already setup the LDR.\n\t */\n\tif (svm->ldr_reg)\n\t\tavic_handle_ldr_update(vcpu);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\n\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu)\n{\n\tif (avic_handle_apic_id_update(vcpu) != 0)\n\t\treturn;\n\tif (avic_handle_dfr_update(vcpu) != 0)\n\t\treturn;\n\tavic_handle_ldr_update(vcpu);\n}"
  },
  {
    "function_name": "svm_sched_in",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "4940-4942",
    "snippet": "static void svm_sched_in(struct kvm_vcpu *vcpu, int cpu)\n{\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\n\nstatic void svm_sched_in(struct kvm_vcpu *vcpu, int cpu)\n{\n}"
  },
  {
    "function_name": "svm_handle_external_intr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "4935-4938",
    "snippet": "static void svm_handle_external_intr(struct kvm_vcpu *vcpu)\n{\n\tlocal_irq_enable();\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_enable",
          "args": [],
          "line": 4937
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\n\nstatic void svm_handle_external_intr(struct kvm_vcpu *vcpu)\n{\n\tlocal_irq_enable();\n}"
  },
  {
    "function_name": "svm_check_intercept",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "4815-4933",
    "snippet": "static int svm_check_intercept(struct kvm_vcpu *vcpu,\n\t\t\t       struct x86_instruction_info *info,\n\t\t\t       enum x86_intercept_stage stage)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tint vmexit, ret = X86EMUL_CONTINUE;\n\tstruct __x86_intercept icpt_info;\n\tstruct vmcb *vmcb = svm->vmcb;\n\n\tif (info->intercept >= ARRAY_SIZE(x86_intercept_map))\n\t\tgoto out;\n\n\ticpt_info = x86_intercept_map[info->intercept];\n\n\tif (stage != icpt_info.stage)\n\t\tgoto out;\n\n\tswitch (icpt_info.exit_code) {\n\tcase SVM_EXIT_READ_CR0:\n\t\tif (info->intercept == x86_intercept_cr_read)\n\t\t\ticpt_info.exit_code += info->modrm_reg;\n\t\tbreak;\n\tcase SVM_EXIT_WRITE_CR0: {\n\t\tunsigned long cr0, val;\n\t\tu64 intercept;\n\n\t\tif (info->intercept == x86_intercept_cr_write)\n\t\t\ticpt_info.exit_code += info->modrm_reg;\n\n\t\tif (icpt_info.exit_code != SVM_EXIT_WRITE_CR0 ||\n\t\t    info->intercept == x86_intercept_clts)\n\t\t\tbreak;\n\n\t\tintercept = svm->nested.intercept;\n\n\t\tif (!(intercept & (1ULL << INTERCEPT_SELECTIVE_CR0)))\n\t\t\tbreak;\n\n\t\tcr0 = vcpu->arch.cr0 & ~SVM_CR0_SELECTIVE_MASK;\n\t\tval = info->src_val  & ~SVM_CR0_SELECTIVE_MASK;\n\n\t\tif (info->intercept == x86_intercept_lmsw) {\n\t\t\tcr0 &= 0xfUL;\n\t\t\tval &= 0xfUL;\n\t\t\t/* lmsw can't clear PE - catch this here */\n\t\t\tif (cr0 & X86_CR0_PE)\n\t\t\t\tval |= X86_CR0_PE;\n\t\t}\n\n\t\tif (cr0 ^ val)\n\t\t\ticpt_info.exit_code = SVM_EXIT_CR0_SEL_WRITE;\n\n\t\tbreak;\n\t}\n\tcase SVM_EXIT_READ_DR0:\n\tcase SVM_EXIT_WRITE_DR0:\n\t\ticpt_info.exit_code += info->modrm_reg;\n\t\tbreak;\n\tcase SVM_EXIT_MSR:\n\t\tif (info->intercept == x86_intercept_wrmsr)\n\t\t\tvmcb->control.exit_info_1 = 1;\n\t\telse\n\t\t\tvmcb->control.exit_info_1 = 0;\n\t\tbreak;\n\tcase SVM_EXIT_PAUSE:\n\t\t/*\n\t\t * We get this for NOP only, but pause\n\t\t * is rep not, check this here\n\t\t */\n\t\tif (info->rep_prefix != REPE_PREFIX)\n\t\t\tgoto out;\n\tcase SVM_EXIT_IOIO: {\n\t\tu64 exit_info;\n\t\tu32 bytes;\n\n\t\tif (info->intercept == x86_intercept_in ||\n\t\t    info->intercept == x86_intercept_ins) {\n\t\t\texit_info = ((info->src_val & 0xffff) << 16) |\n\t\t\t\tSVM_IOIO_TYPE_MASK;\n\t\t\tbytes = info->dst_bytes;\n\t\t} else {\n\t\t\texit_info = (info->dst_val & 0xffff) << 16;\n\t\t\tbytes = info->src_bytes;\n\t\t}\n\n\t\tif (info->intercept == x86_intercept_outs ||\n\t\t    info->intercept == x86_intercept_ins)\n\t\t\texit_info |= SVM_IOIO_STR_MASK;\n\n\t\tif (info->rep_prefix)\n\t\t\texit_info |= SVM_IOIO_REP_MASK;\n\n\t\tbytes = min(bytes, 4u);\n\n\t\texit_info |= bytes << SVM_IOIO_SIZE_SHIFT;\n\n\t\texit_info |= (u32)info->ad_bytes << (SVM_IOIO_ASIZE_SHIFT - 1);\n\n\t\tvmcb->control.exit_info_1 = exit_info;\n\t\tvmcb->control.exit_info_2 = info->next_rip;\n\n\t\tbreak;\n\t}\n\tdefault:\n\t\tbreak;\n\t}\n\n\t/* TODO: Advertise NRIPS to guest hypervisor unconditionally */\n\tif (static_cpu_has(X86_FEATURE_NRIPS))\n\t\tvmcb->control.next_rip  = info->next_rip;\n\tvmcb->control.exit_code = icpt_info.exit_code;\n\tvmexit = nested_svm_exit_handled(svm);\n\n\tret = (vmexit == NESTED_EXIT_DONE) ? X86EMUL_INTERCEPTED\n\t\t\t\t\t   : X86EMUL_CONTINUE;\n\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define NESTED_EXIT_DONE\t1\t/* Exit caused nested vmexit  */"
    ],
    "globals_used": [
      "static int nested = true;",
      "static void svm_set_cr0(struct kvm_vcpu *vcpu, unsigned long cr0);",
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);",
      "static const struct __x86_intercept {\n\tu32 exit_code;\n\tenum x86_intercept_stage stage;\n} x86_intercept_map[] = {\n\t[x86_intercept_cr_read]\t\t= POST_EX(SVM_EXIT_READ_CR0),\n\t[x86_intercept_cr_write]\t= POST_EX(SVM_EXIT_WRITE_CR0),\n\t[x86_intercept_clts]\t\t= POST_EX(SVM_EXIT_WRITE_CR0),\n\t[x86_intercept_lmsw]\t\t= POST_EX(SVM_EXIT_WRITE_CR0),\n\t[x86_intercept_smsw]\t\t= POST_EX(SVM_EXIT_READ_CR0),\n\t[x86_intercept_dr_read]\t\t= POST_EX(SVM_EXIT_READ_DR0),\n\t[x86_intercept_dr_write]\t= POST_EX(SVM_EXIT_WRITE_DR0),\n\t[x86_intercept_sldt]\t\t= POST_EX(SVM_EXIT_LDTR_READ),\n\t[x86_intercept_str]\t\t= POST_EX(SVM_EXIT_TR_READ),\n\t[x86_intercept_lldt]\t\t= POST_EX(SVM_EXIT_LDTR_WRITE),\n\t[x86_intercept_ltr]\t\t= POST_EX(SVM_EXIT_TR_WRITE),\n\t[x86_intercept_sgdt]\t\t= POST_EX(SVM_EXIT_GDTR_READ),\n\t[x86_intercept_sidt]\t\t= POST_EX(SVM_EXIT_IDTR_READ),\n\t[x86_intercept_lgdt]\t\t= POST_EX(SVM_EXIT_GDTR_WRITE),\n\t[x86_intercept_lidt]\t\t= POST_EX(SVM_EXIT_IDTR_WRITE),\n\t[x86_intercept_vmrun]\t\t= POST_EX(SVM_EXIT_VMRUN),\n\t[x86_intercept_vmmcall]\t\t= POST_EX(SVM_EXIT_VMMCALL),\n\t[x86_intercept_vmload]\t\t= POST_EX(SVM_EXIT_VMLOAD),\n\t[x86_intercept_vmsave]\t\t= POST_EX(SVM_EXIT_VMSAVE),\n\t[x86_intercept_stgi]\t\t= POST_EX(SVM_EXIT_STGI),\n\t[x86_intercept_clgi]\t\t= POST_EX(SVM_EXIT_CLGI),\n\t[x86_intercept_skinit]\t\t= POST_EX(SVM_EXIT_SKINIT),\n\t[x86_intercept_invlpga]\t\t= POST_EX(SVM_EXIT_INVLPGA),\n\t[x86_intercept_rdtscp]\t\t= POST_EX(SVM_EXIT_RDTSCP),\n\t[x86_intercept_monitor]\t\t= POST_MEM(SVM_EXIT_MONITOR),\n\t[x86_intercept_mwait]\t\t= POST_EX(SVM_EXIT_MWAIT),\n\t[x86_intercept_invlpg]\t\t= POST_EX(SVM_EXIT_INVLPG),\n\t[x86_intercept_invd]\t\t= POST_EX(SVM_EXIT_INVD),\n\t[x86_intercept_wbinvd]\t\t= POST_EX(SVM_EXIT_WBINVD),\n\t[x86_intercept_wrmsr]\t\t= POST_EX(SVM_EXIT_MSR),\n\t[x86_intercept_rdtsc]\t\t= POST_EX(SVM_EXIT_RDTSC),\n\t[x86_intercept_rdmsr]\t\t= POST_EX(SVM_EXIT_MSR),\n\t[x86_intercept_rdpmc]\t\t= POST_EX(SVM_EXIT_RDPMC),\n\t[x86_intercept_cpuid]\t\t= PRE_EX(SVM_EXIT_CPUID),\n\t[x86_intercept_rsm]\t\t= PRE_EX(SVM_EXIT_RSM),\n\t[x86_intercept_pause]\t\t= PRE_EX(SVM_EXIT_PAUSE),\n\t[x86_intercept_pushf]\t\t= PRE_EX(SVM_EXIT_PUSHF),\n\t[x86_intercept_popf]\t\t= PRE_EX(SVM_EXIT_POPF),\n\t[x86_intercept_intn]\t\t= PRE_EX(SVM_EXIT_SWINT),\n\t[x86_intercept_iret]\t\t= PRE_EX(SVM_EXIT_IRET),\n\t[x86_intercept_icebp]\t\t= PRE_EX(SVM_EXIT_ICEBP),\n\t[x86_intercept_hlt]\t\t= POST_EX(SVM_EXIT_HLT),\n\t[x86_intercept_in]\t\t= POST_EX(SVM_EXIT_IOIO),\n\t[x86_intercept_ins]\t\t= POST_EX(SVM_EXIT_IOIO),\n\t[x86_intercept_out]\t\t= POST_EX(SVM_EXIT_IOIO),\n\t[x86_intercept_outs]\t\t= POST_EX(SVM_EXIT_IOIO),\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nested_svm_exit_handled",
          "args": [
            "svm"
          ],
          "line": 4926
        },
        "resolved": true,
        "details": {
          "function_name": "nested_svm_exit_handled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "2492-2502",
          "snippet": "static int nested_svm_exit_handled(struct vcpu_svm *svm)\n{\n\tint vmexit;\n\n\tvmexit = nested_svm_intercept(svm);\n\n\tif (vmexit == NESTED_EXIT_DONE)\n\t\tnested_svm_vmexit(svm);\n\n\treturn vmexit;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define NESTED_EXIT_DONE\t1\t/* Exit caused nested vmexit  */"
          ],
          "globals_used": [
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define NESTED_EXIT_DONE\t1\t/* Exit caused nested vmexit  */\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm)\n{\n\tint vmexit;\n\n\tvmexit = nested_svm_intercept(svm);\n\n\tif (vmexit == NESTED_EXIT_DONE)\n\t\tnested_svm_vmexit(svm);\n\n\treturn vmexit;\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_cpu_has",
          "args": [
            "X86_FEATURE_NRIPS"
          ],
          "line": 4923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "bytes",
            "4u"
          ],
          "line": 4907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "x86_intercept_map"
          ],
          "line": 4824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 4819
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "294-297",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define NESTED_EXIT_DONE\t1\t/* Exit caused nested vmexit  */\n\nstatic int nested = true;\nstatic void svm_set_cr0(struct kvm_vcpu *vcpu, unsigned long cr0);\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\nstatic const struct __x86_intercept {\n\tu32 exit_code;\n\tenum x86_intercept_stage stage;\n} x86_intercept_map[] = {\n\t[x86_intercept_cr_read]\t\t= POST_EX(SVM_EXIT_READ_CR0),\n\t[x86_intercept_cr_write]\t= POST_EX(SVM_EXIT_WRITE_CR0),\n\t[x86_intercept_clts]\t\t= POST_EX(SVM_EXIT_WRITE_CR0),\n\t[x86_intercept_lmsw]\t\t= POST_EX(SVM_EXIT_WRITE_CR0),\n\t[x86_intercept_smsw]\t\t= POST_EX(SVM_EXIT_READ_CR0),\n\t[x86_intercept_dr_read]\t\t= POST_EX(SVM_EXIT_READ_DR0),\n\t[x86_intercept_dr_write]\t= POST_EX(SVM_EXIT_WRITE_DR0),\n\t[x86_intercept_sldt]\t\t= POST_EX(SVM_EXIT_LDTR_READ),\n\t[x86_intercept_str]\t\t= POST_EX(SVM_EXIT_TR_READ),\n\t[x86_intercept_lldt]\t\t= POST_EX(SVM_EXIT_LDTR_WRITE),\n\t[x86_intercept_ltr]\t\t= POST_EX(SVM_EXIT_TR_WRITE),\n\t[x86_intercept_sgdt]\t\t= POST_EX(SVM_EXIT_GDTR_READ),\n\t[x86_intercept_sidt]\t\t= POST_EX(SVM_EXIT_IDTR_READ),\n\t[x86_intercept_lgdt]\t\t= POST_EX(SVM_EXIT_GDTR_WRITE),\n\t[x86_intercept_lidt]\t\t= POST_EX(SVM_EXIT_IDTR_WRITE),\n\t[x86_intercept_vmrun]\t\t= POST_EX(SVM_EXIT_VMRUN),\n\t[x86_intercept_vmmcall]\t\t= POST_EX(SVM_EXIT_VMMCALL),\n\t[x86_intercept_vmload]\t\t= POST_EX(SVM_EXIT_VMLOAD),\n\t[x86_intercept_vmsave]\t\t= POST_EX(SVM_EXIT_VMSAVE),\n\t[x86_intercept_stgi]\t\t= POST_EX(SVM_EXIT_STGI),\n\t[x86_intercept_clgi]\t\t= POST_EX(SVM_EXIT_CLGI),\n\t[x86_intercept_skinit]\t\t= POST_EX(SVM_EXIT_SKINIT),\n\t[x86_intercept_invlpga]\t\t= POST_EX(SVM_EXIT_INVLPGA),\n\t[x86_intercept_rdtscp]\t\t= POST_EX(SVM_EXIT_RDTSCP),\n\t[x86_intercept_monitor]\t\t= POST_MEM(SVM_EXIT_MONITOR),\n\t[x86_intercept_mwait]\t\t= POST_EX(SVM_EXIT_MWAIT),\n\t[x86_intercept_invlpg]\t\t= POST_EX(SVM_EXIT_INVLPG),\n\t[x86_intercept_invd]\t\t= POST_EX(SVM_EXIT_INVD),\n\t[x86_intercept_wbinvd]\t\t= POST_EX(SVM_EXIT_WBINVD),\n\t[x86_intercept_wrmsr]\t\t= POST_EX(SVM_EXIT_MSR),\n\t[x86_intercept_rdtsc]\t\t= POST_EX(SVM_EXIT_RDTSC),\n\t[x86_intercept_rdmsr]\t\t= POST_EX(SVM_EXIT_MSR),\n\t[x86_intercept_rdpmc]\t\t= POST_EX(SVM_EXIT_RDPMC),\n\t[x86_intercept_cpuid]\t\t= PRE_EX(SVM_EXIT_CPUID),\n\t[x86_intercept_rsm]\t\t= PRE_EX(SVM_EXIT_RSM),\n\t[x86_intercept_pause]\t\t= PRE_EX(SVM_EXIT_PAUSE),\n\t[x86_intercept_pushf]\t\t= PRE_EX(SVM_EXIT_PUSHF),\n\t[x86_intercept_popf]\t\t= PRE_EX(SVM_EXIT_POPF),\n\t[x86_intercept_intn]\t\t= PRE_EX(SVM_EXIT_SWINT),\n\t[x86_intercept_iret]\t\t= PRE_EX(SVM_EXIT_IRET),\n\t[x86_intercept_icebp]\t\t= PRE_EX(SVM_EXIT_ICEBP),\n\t[x86_intercept_hlt]\t\t= POST_EX(SVM_EXIT_HLT),\n\t[x86_intercept_in]\t\t= POST_EX(SVM_EXIT_IOIO),\n\t[x86_intercept_ins]\t\t= POST_EX(SVM_EXIT_IOIO),\n\t[x86_intercept_out]\t\t= POST_EX(SVM_EXIT_IOIO),\n\t[x86_intercept_outs]\t\t= POST_EX(SVM_EXIT_IOIO),\n};\n\nstatic int svm_check_intercept(struct kvm_vcpu *vcpu,\n\t\t\t       struct x86_instruction_info *info,\n\t\t\t       enum x86_intercept_stage stage)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tint vmexit, ret = X86EMUL_CONTINUE;\n\tstruct __x86_intercept icpt_info;\n\tstruct vmcb *vmcb = svm->vmcb;\n\n\tif (info->intercept >= ARRAY_SIZE(x86_intercept_map))\n\t\tgoto out;\n\n\ticpt_info = x86_intercept_map[info->intercept];\n\n\tif (stage != icpt_info.stage)\n\t\tgoto out;\n\n\tswitch (icpt_info.exit_code) {\n\tcase SVM_EXIT_READ_CR0:\n\t\tif (info->intercept == x86_intercept_cr_read)\n\t\t\ticpt_info.exit_code += info->modrm_reg;\n\t\tbreak;\n\tcase SVM_EXIT_WRITE_CR0: {\n\t\tunsigned long cr0, val;\n\t\tu64 intercept;\n\n\t\tif (info->intercept == x86_intercept_cr_write)\n\t\t\ticpt_info.exit_code += info->modrm_reg;\n\n\t\tif (icpt_info.exit_code != SVM_EXIT_WRITE_CR0 ||\n\t\t    info->intercept == x86_intercept_clts)\n\t\t\tbreak;\n\n\t\tintercept = svm->nested.intercept;\n\n\t\tif (!(intercept & (1ULL << INTERCEPT_SELECTIVE_CR0)))\n\t\t\tbreak;\n\n\t\tcr0 = vcpu->arch.cr0 & ~SVM_CR0_SELECTIVE_MASK;\n\t\tval = info->src_val  & ~SVM_CR0_SELECTIVE_MASK;\n\n\t\tif (info->intercept == x86_intercept_lmsw) {\n\t\t\tcr0 &= 0xfUL;\n\t\t\tval &= 0xfUL;\n\t\t\t/* lmsw can't clear PE - catch this here */\n\t\t\tif (cr0 & X86_CR0_PE)\n\t\t\t\tval |= X86_CR0_PE;\n\t\t}\n\n\t\tif (cr0 ^ val)\n\t\t\ticpt_info.exit_code = SVM_EXIT_CR0_SEL_WRITE;\n\n\t\tbreak;\n\t}\n\tcase SVM_EXIT_READ_DR0:\n\tcase SVM_EXIT_WRITE_DR0:\n\t\ticpt_info.exit_code += info->modrm_reg;\n\t\tbreak;\n\tcase SVM_EXIT_MSR:\n\t\tif (info->intercept == x86_intercept_wrmsr)\n\t\t\tvmcb->control.exit_info_1 = 1;\n\t\telse\n\t\t\tvmcb->control.exit_info_1 = 0;\n\t\tbreak;\n\tcase SVM_EXIT_PAUSE:\n\t\t/*\n\t\t * We get this for NOP only, but pause\n\t\t * is rep not, check this here\n\t\t */\n\t\tif (info->rep_prefix != REPE_PREFIX)\n\t\t\tgoto out;\n\tcase SVM_EXIT_IOIO: {\n\t\tu64 exit_info;\n\t\tu32 bytes;\n\n\t\tif (info->intercept == x86_intercept_in ||\n\t\t    info->intercept == x86_intercept_ins) {\n\t\t\texit_info = ((info->src_val & 0xffff) << 16) |\n\t\t\t\tSVM_IOIO_TYPE_MASK;\n\t\t\tbytes = info->dst_bytes;\n\t\t} else {\n\t\t\texit_info = (info->dst_val & 0xffff) << 16;\n\t\t\tbytes = info->src_bytes;\n\t\t}\n\n\t\tif (info->intercept == x86_intercept_outs ||\n\t\t    info->intercept == x86_intercept_ins)\n\t\t\texit_info |= SVM_IOIO_STR_MASK;\n\n\t\tif (info->rep_prefix)\n\t\t\texit_info |= SVM_IOIO_REP_MASK;\n\n\t\tbytes = min(bytes, 4u);\n\n\t\texit_info |= bytes << SVM_IOIO_SIZE_SHIFT;\n\n\t\texit_info |= (u32)info->ad_bytes << (SVM_IOIO_ASIZE_SHIFT - 1);\n\n\t\tvmcb->control.exit_info_1 = exit_info;\n\t\tvmcb->control.exit_info_2 = info->next_rip;\n\n\t\tbreak;\n\t}\n\tdefault:\n\t\tbreak;\n\t}\n\n\t/* TODO: Advertise NRIPS to guest hypervisor unconditionally */\n\tif (static_cpu_has(X86_FEATURE_NRIPS))\n\t\tvmcb->control.next_rip  = info->next_rip;\n\tvmcb->control.exit_code = icpt_info.exit_code;\n\tvmexit = nested_svm_exit_handled(svm);\n\n\tret = (vmexit == NESTED_EXIT_DONE) ? X86EMUL_INTERCEPTED\n\t\t\t\t\t   : X86EMUL_CONTINUE;\n\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "svm_fpu_deactivate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "4744-4750",
    "snippet": "static void svm_fpu_deactivate(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tset_exception_intercept(svm, NM_VECTOR);\n\tupdate_cr0_intercept(svm);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "update_cr0_intercept",
          "args": [
            "svm"
          ],
          "line": 4749
        },
        "resolved": true,
        "details": {
          "function_name": "update_cr0_intercept",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "1755-1775",
          "snippet": "static void update_cr0_intercept(struct vcpu_svm *svm)\n{\n\tulong gcr0 = svm->vcpu.arch.cr0;\n\tu64 *hcr0 = &svm->vmcb->save.cr0;\n\n\tif (!svm->vcpu.fpu_active)\n\t\t*hcr0 |= SVM_CR0_SELECTIVE_MASK;\n\telse\n\t\t*hcr0 = (*hcr0 & ~SVM_CR0_SELECTIVE_MASK)\n\t\t\t| (gcr0 & SVM_CR0_SELECTIVE_MASK);\n\n\tmark_dirty(svm->vmcb, VMCB_CR);\n\n\tif (gcr0 == *hcr0 && svm->vcpu.fpu_active) {\n\t\tclr_cr_intercept(svm, INTERCEPT_CR0_READ);\n\t\tclr_cr_intercept(svm, INTERCEPT_CR0_WRITE);\n\t} else {\n\t\tset_cr_intercept(svm, INTERCEPT_CR0_READ);\n\t\tset_cr_intercept(svm, INTERCEPT_CR0_WRITE);\n\t}\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_set_cr0(struct kvm_vcpu *vcpu, unsigned long cr0);",
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_set_cr0(struct kvm_vcpu *vcpu, unsigned long cr0);\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic void update_cr0_intercept(struct vcpu_svm *svm)\n{\n\tulong gcr0 = svm->vcpu.arch.cr0;\n\tu64 *hcr0 = &svm->vmcb->save.cr0;\n\n\tif (!svm->vcpu.fpu_active)\n\t\t*hcr0 |= SVM_CR0_SELECTIVE_MASK;\n\telse\n\t\t*hcr0 = (*hcr0 & ~SVM_CR0_SELECTIVE_MASK)\n\t\t\t| (gcr0 & SVM_CR0_SELECTIVE_MASK);\n\n\tmark_dirty(svm->vmcb, VMCB_CR);\n\n\tif (gcr0 == *hcr0 && svm->vcpu.fpu_active) {\n\t\tclr_cr_intercept(svm, INTERCEPT_CR0_READ);\n\t\tclr_cr_intercept(svm, INTERCEPT_CR0_WRITE);\n\t} else {\n\t\tset_cr_intercept(svm, INTERCEPT_CR0_READ);\n\t\tset_cr_intercept(svm, INTERCEPT_CR0_WRITE);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_exception_intercept",
          "args": [
            "svm",
            "NM_VECTOR"
          ],
          "line": 4748
        },
        "resolved": true,
        "details": {
          "function_name": "set_exception_intercept",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "402-409",
          "snippet": "static inline void set_exception_intercept(struct vcpu_svm *svm, int bit)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept_exceptions |= (1U << bit);\n\n\trecalc_intercepts(svm);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic inline void set_exception_intercept(struct vcpu_svm *svm, int bit)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept_exceptions |= (1U << bit);\n\n\trecalc_intercepts(svm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 4746
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "294-297",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic void svm_fpu_deactivate(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tset_exception_intercept(svm, NM_VECTOR);\n\tupdate_cr0_intercept(svm);\n}"
  },
  {
    "function_name": "svm_has_wbinvd_exit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "4739-4742",
    "snippet": "static bool svm_has_wbinvd_exit(void)\n{\n\treturn true;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic bool svm_has_wbinvd_exit(void)\n{\n\treturn true;\n}"
  },
  {
    "function_name": "svm_xsaves_supported",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "4734-4737",
    "snippet": "static bool svm_xsaves_supported(void)\n{\n\treturn false;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic bool svm_xsaves_supported(void)\n{\n\treturn false;\n}"
  },
  {
    "function_name": "svm_mpx_supported",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "4729-4732",
    "snippet": "static bool svm_mpx_supported(void)\n{\n\treturn false;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic bool svm_mpx_supported(void)\n{\n\treturn false;\n}"
  },
  {
    "function_name": "svm_invpcid_supported",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "4724-4727",
    "snippet": "static bool svm_invpcid_supported(void)\n{\n\treturn false;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic bool svm_invpcid_supported(void)\n{\n\treturn false;\n}"
  },
  {
    "function_name": "svm_rdtscp_supported",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "4719-4722",
    "snippet": "static bool svm_rdtscp_supported(void)\n{\n\treturn boot_cpu_has(X86_FEATURE_RDTSCP);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "boot_cpu_has",
          "args": [
            "X86_FEATURE_RDTSCP"
          ],
          "line": 4721
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic bool svm_rdtscp_supported(void)\n{\n\treturn boot_cpu_has(X86_FEATURE_RDTSCP);\n}"
  },
  {
    "function_name": "svm_get_lpage_level",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "4714-4717",
    "snippet": "static int svm_get_lpage_level(void)\n{\n\treturn PT_PDPE_LEVEL;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int svm_get_lpage_level(void)\n{\n\treturn PT_PDPE_LEVEL;\n}"
  },
  {
    "function_name": "svm_set_supported_cpuid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "4683-4712",
    "snippet": "static void svm_set_supported_cpuid(u32 func, struct kvm_cpuid_entry2 *entry)\n{\n\tswitch (func) {\n\tcase 0x1:\n\t\tif (avic)\n\t\t\tentry->ecx &= ~bit(X86_FEATURE_X2APIC);\n\t\tbreak;\n\tcase 0x80000001:\n\t\tif (nested)\n\t\t\tentry->ecx |= (1 << 2); /* Set SVM bit */\n\t\tbreak;\n\tcase 0x8000000A:\n\t\tentry->eax = 1; /* SVM revision 1 */\n\t\tentry->ebx = 8; /* Lets support 8 ASIDs in case we add proper\n\t\t\t\t   ASID emulation to nested SVM */\n\t\tentry->ecx = 0; /* Reserved */\n\t\tentry->edx = 0; /* Per default do not support any\n\t\t\t\t   additional features */\n\n\t\t/* Support next_rip if host supports it */\n\t\tif (boot_cpu_has(X86_FEATURE_NRIPS))\n\t\t\tentry->edx |= SVM_FEATURE_NRIP;\n\n\t\t/* Support NPT for the guest if enabled */\n\t\tif (npt_enabled)\n\t\t\tentry->edx |= SVM_FEATURE_NPT;\n\n\t\tbreak;\n\t}\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define SVM_FEATURE_NRIP           (1 <<  3)",
      "#define SVM_FEATURE_NPT            (1 <<  0)"
    ],
    "globals_used": [
      "static int nested = true;",
      "static int avic;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "boot_cpu_has",
          "args": [
            "X86_FEATURE_NRIPS"
          ],
          "line": 4703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bit",
          "args": [
            "X86_FEATURE_X2APIC"
          ],
          "line": 4688
        },
        "resolved": true,
        "details": {
          "function_name": "svm_decache_cr4_guest_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "1751-1753",
          "snippet": "static void svm_decache_cr4_guest_bits(struct kvm_vcpu *vcpu)\n{\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\n\nstatic void svm_decache_cr4_guest_bits(struct kvm_vcpu *vcpu)\n{\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define SVM_FEATURE_NRIP           (1 <<  3)\n#define SVM_FEATURE_NPT            (1 <<  0)\n\nstatic int nested = true;\nstatic int avic;\n\nstatic void svm_set_supported_cpuid(u32 func, struct kvm_cpuid_entry2 *entry)\n{\n\tswitch (func) {\n\tcase 0x1:\n\t\tif (avic)\n\t\t\tentry->ecx &= ~bit(X86_FEATURE_X2APIC);\n\t\tbreak;\n\tcase 0x80000001:\n\t\tif (nested)\n\t\t\tentry->ecx |= (1 << 2); /* Set SVM bit */\n\t\tbreak;\n\tcase 0x8000000A:\n\t\tentry->eax = 1; /* SVM revision 1 */\n\t\tentry->ebx = 8; /* Lets support 8 ASIDs in case we add proper\n\t\t\t\t   ASID emulation to nested SVM */\n\t\tentry->ecx = 0; /* Reserved */\n\t\tentry->edx = 0; /* Per default do not support any\n\t\t\t\t   additional features */\n\n\t\t/* Support next_rip if host supports it */\n\t\tif (boot_cpu_has(X86_FEATURE_NRIPS))\n\t\t\tentry->edx |= SVM_FEATURE_NRIP;\n\n\t\t/* Support NPT for the guest if enabled */\n\t\tif (npt_enabled)\n\t\t\tentry->edx |= SVM_FEATURE_NPT;\n\n\t\tbreak;\n\t}\n}"
  },
  {
    "function_name": "svm_cpuid_update",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "4667-4681",
    "snippet": "static void svm_cpuid_update(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tstruct kvm_cpuid_entry2 *entry;\n\n\t/* Update nrips enabled cache */\n\tsvm->nrips_enabled = !!guest_cpuid_has_nrips(&svm->vcpu);\n\n\tif (!kvm_vcpu_apicv_active(vcpu))\n\t\treturn;\n\n\tentry = kvm_find_cpuid_entry(vcpu, 1, 0);\n\tif (entry)\n\t\tentry->ecx &= ~bit(X86_FEATURE_X2APIC);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bit",
          "args": [
            "X86_FEATURE_X2APIC"
          ],
          "line": 4680
        },
        "resolved": true,
        "details": {
          "function_name": "svm_decache_cr4_guest_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "1751-1753",
          "snippet": "static void svm_decache_cr4_guest_bits(struct kvm_vcpu *vcpu)\n{\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\n\nstatic void svm_decache_cr4_guest_bits(struct kvm_vcpu *vcpu)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_find_cpuid_entry",
          "args": [
            "vcpu",
            "1",
            "0"
          ],
          "line": 4678
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_find_cpuid_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/cpuid.c",
          "lines": "794-812",
          "snippet": "struct kvm_cpuid_entry2 *kvm_find_cpuid_entry(struct kvm_vcpu *vcpu,\n\t\t\t\t\t      u32 function, u32 index)\n{\n\tint i;\n\tstruct kvm_cpuid_entry2 *best = NULL;\n\n\tfor (i = 0; i < vcpu->arch.cpuid_nent; ++i) {\n\t\tstruct kvm_cpuid_entry2 *e;\n\n\t\te = &vcpu->arch.cpuid_entries[i];\n\t\tif (is_matching_cpuid_entry(e, function, index)) {\n\t\t\tif (e->flags & KVM_CPUID_FLAG_STATEFUL_FUNC)\n\t\t\t\tmove_to_next_stateful_cpuid_entry(vcpu, i);\n\t\t\tbest = e;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn best;\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"trace.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"cpuid.h\"",
            "#include <asm/fpu/xstate.h>",
            "#include <asm/user.h>",
            "#include <asm/fpu/internal.h> /* For use_eager_fpu.  Ugh! */",
            "#include <linux/uaccess.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"trace.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include <asm/fpu/xstate.h>\n#include <asm/user.h>\n#include <asm/fpu/internal.h> /* For use_eager_fpu.  Ugh! */\n#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n\nstruct kvm_cpuid_entry2 *kvm_find_cpuid_entry(struct kvm_vcpu *vcpu,\n\t\t\t\t\t      u32 function, u32 index)\n{\n\tint i;\n\tstruct kvm_cpuid_entry2 *best = NULL;\n\n\tfor (i = 0; i < vcpu->arch.cpuid_nent; ++i) {\n\t\tstruct kvm_cpuid_entry2 *e;\n\n\t\te = &vcpu->arch.cpuid_entries[i];\n\t\tif (is_matching_cpuid_entry(e, function, index)) {\n\t\t\tif (e->flags & KVM_CPUID_FLAG_STATEFUL_FUNC)\n\t\t\t\tmove_to_next_stateful_cpuid_entry(vcpu, i);\n\t\t\tbest = e;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn best;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_apicv_active",
          "args": [
            "vcpu"
          ],
          "line": 4675
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_vcpu_apicv_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.h",
          "lines": "181-184",
          "snippet": "static inline bool kvm_vcpu_apicv_active(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.apic && vcpu->arch.apicv_active;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline bool kvm_vcpu_apicv_active(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.apic && vcpu->arch.apicv_active;\n}"
        }
      },
      {
        "call_info": {
          "callee": "guest_cpuid_has_nrips",
          "args": [
            "&svm->vcpu"
          ],
          "line": 4673
        },
        "resolved": true,
        "details": {
          "function_name": "guest_cpuid_has_nrips",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/cpuid.h",
          "lines": "168-180",
          "snippet": "static inline bool guest_cpuid_has_nrips(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_cpuid_entry2 *best;\n\n\tbest = kvm_find_cpuid_entry(vcpu, 0x8000000a, 0);\n\n\t/*\n\t * NRIPS is a scattered cpuid feature, so we can't use\n\t * X86_FEATURE_NRIPS here (X86_FEATURE_NRIPS would be bit\n\t * position 8, not 3).\n\t */\n\treturn best && (best->edx & bit(BIT_NRIPS));\n}",
          "includes": [
            "#include <asm/cpu.h>",
            "#include \"x86.h\""
          ],
          "macros_used": [
            "#define BIT_NRIPS\t3"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpu.h>\n#include \"x86.h\"\n\n#define BIT_NRIPS\t3\n\nstatic inline bool guest_cpuid_has_nrips(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_cpuid_entry2 *best;\n\n\tbest = kvm_find_cpuid_entry(vcpu, 0x8000000a, 0);\n\n\t/*\n\t * NRIPS is a scattered cpuid feature, so we can't use\n\t * X86_FEATURE_NRIPS here (X86_FEATURE_NRIPS would be bit\n\t * position 8, not 3).\n\t */\n\treturn best && (best->edx & bit(BIT_NRIPS));\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 4669
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "294-297",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic void svm_cpuid_update(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tstruct kvm_cpuid_entry2 *entry;\n\n\t/* Update nrips enabled cache */\n\tsvm->nrips_enabled = !!guest_cpuid_has_nrips(&svm->vcpu);\n\n\tif (!kvm_vcpu_apicv_active(vcpu))\n\t\treturn;\n\n\tentry = kvm_find_cpuid_entry(vcpu, 1, 0);\n\tif (entry)\n\t\tentry->ecx &= ~bit(X86_FEATURE_X2APIC);\n}"
  },
  {
    "function_name": "svm_get_mt_mask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "4662-4665",
    "snippet": "static u64 svm_get_mt_mask(struct kvm_vcpu *vcpu, gfn_t gfn, bool is_mmio)\n{\n\treturn 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\n\nstatic u64 svm_get_mt_mask(struct kvm_vcpu *vcpu, gfn_t gfn, bool is_mmio)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "svm_has_high_real_mode_segbase",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "4657-4660",
    "snippet": "static bool svm_has_high_real_mode_segbase(void)\n{\n\treturn true;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic bool svm_has_high_real_mode_segbase(void)\n{\n\treturn true;\n}"
  },
  {
    "function_name": "svm_cpu_has_accelerated_tpr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "4652-4655",
    "snippet": "static bool svm_cpu_has_accelerated_tpr(void)\n{\n\treturn false;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic bool svm_cpu_has_accelerated_tpr(void)\n{\n\treturn false;\n}"
  },
  {
    "function_name": "svm_check_processor_compat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "4647-4650",
    "snippet": "static void svm_check_processor_compat(void *rtn)\n{\n\t*(int *)rtn = 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_check_processor_compat(void *rtn)\n{\n\t*(int *)rtn = 0;\n}"
  },
  {
    "function_name": "svm_patch_hypercall",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "4636-4645",
    "snippet": "static void\nsvm_patch_hypercall(struct kvm_vcpu *vcpu, unsigned char *hypercall)\n{\n\t/*\n\t * Patch in the VMMCALL instruction:\n\t */\n\thypercall[0] = 0x0f;\n\thypercall[1] = 0x01;\n\thypercall[2] = 0xd9;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\n\nstatic void\nsvm_patch_hypercall(struct kvm_vcpu *vcpu, unsigned char *hypercall)\n{\n\t/*\n\t * Patch in the VMMCALL instruction:\n\t */\n\thypercall[0] = 0x0f;\n\thypercall[1] = 0x01;\n\thypercall[2] = 0xd9;\n}"
  },
  {
    "function_name": "is_disabled",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "4625-4634",
    "snippet": "static int is_disabled(void)\n{\n\tu64 vm_cr;\n\n\trdmsrl(MSR_VM_CR, vm_cr);\n\tif (vm_cr & (1 << SVM_VM_CR_SVM_DISABLE))\n\t\treturn 1;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rdmsrl",
          "args": [
            "MSR_VM_CR",
            "vm_cr"
          ],
          "line": 4629
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int is_disabled(void)\n{\n\tu64 vm_cr;\n\n\trdmsrl(MSR_VM_CR, vm_cr);\n\tif (vm_cr & (1 << SVM_VM_CR_SVM_DISABLE))\n\t\treturn 1;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "set_tdp_cr3",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "4611-4623",
    "snippet": "static void set_tdp_cr3(struct kvm_vcpu *vcpu, unsigned long root)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tsvm->vmcb->control.nested_cr3 = root;\n\tmark_dirty(svm->vmcb, VMCB_NPT);\n\n\t/* Also sync guest cr3 here in case we live migrate */\n\tsvm->vmcb->save.cr3 = kvm_read_cr3(vcpu);\n\tmark_dirty(svm->vmcb, VMCB_CR);\n\n\tsvm_flush_tlb(vcpu);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "svm_flush_tlb",
          "args": [
            "vcpu"
          ],
          "line": 4622
        },
        "resolved": true,
        "details": {
          "function_name": "svm_flush_tlb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "4334-4342",
          "snippet": "static void svm_flush_tlb(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (static_cpu_has(X86_FEATURE_FLUSHBYASID))\n\t\tsvm->vmcb->control.tlb_ctl = TLB_CONTROL_FLUSH_ASID;\n\telse\n\t\tsvm->asid_generation--;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (static_cpu_has(X86_FEATURE_FLUSHBYASID))\n\t\tsvm->vmcb->control.tlb_ctl = TLB_CONTROL_FLUSH_ASID;\n\telse\n\t\tsvm->asid_generation--;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_dirty",
          "args": [
            "svm->vmcb",
            "VMCB_CR"
          ],
          "line": 4620
        },
        "resolved": true,
        "details": {
          "function_name": "mark_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "289-292",
          "snippet": "static inline void mark_dirty(struct vmcb *vmcb, int bit)\n{\n\tvmcb->control.clean &= ~(1 << bit);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic inline void mark_dirty(struct vmcb *vmcb, int bit)\n{\n\tvmcb->control.clean &= ~(1 << bit);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_read_cr3",
          "args": [
            "vcpu"
          ],
          "line": 4619
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_read_cr3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "69-74",
          "snippet": "static inline ulong kvm_read_cr3(struct kvm_vcpu *vcpu)\n{\n\tif (!test_bit(VCPU_EXREG_CR3, (ulong *)&vcpu->arch.regs_avail))\n\t\tkvm_x86_ops->decache_cr3(vcpu);\n\treturn vcpu->arch.cr3;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline ulong kvm_read_cr3(struct kvm_vcpu *vcpu)\n{\n\tif (!test_bit(VCPU_EXREG_CR3, (ulong *)&vcpu->arch.regs_avail))\n\t\tkvm_x86_ops->decache_cr3(vcpu);\n\treturn vcpu->arch.cr3;\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 4613
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "294-297",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic void set_tdp_cr3(struct kvm_vcpu *vcpu, unsigned long root)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tsvm->vmcb->control.nested_cr3 = root;\n\tmark_dirty(svm->vmcb, VMCB_NPT);\n\n\t/* Also sync guest cr3 here in case we live migrate */\n\tsvm->vmcb->save.cr3 = kvm_read_cr3(vcpu);\n\tmark_dirty(svm->vmcb, VMCB_CR);\n\n\tsvm_flush_tlb(vcpu);\n}"
  },
  {
    "function_name": "svm_set_cr3",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "4602-4609",
    "snippet": "static void svm_set_cr3(struct kvm_vcpu *vcpu, unsigned long root)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tsvm->vmcb->save.cr3 = root;\n\tmark_dirty(svm->vmcb, VMCB_CR);\n\tsvm_flush_tlb(vcpu);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "svm_flush_tlb",
          "args": [
            "vcpu"
          ],
          "line": 4608
        },
        "resolved": true,
        "details": {
          "function_name": "svm_flush_tlb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "4334-4342",
          "snippet": "static void svm_flush_tlb(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (static_cpu_has(X86_FEATURE_FLUSHBYASID))\n\t\tsvm->vmcb->control.tlb_ctl = TLB_CONTROL_FLUSH_ASID;\n\telse\n\t\tsvm->asid_generation--;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (static_cpu_has(X86_FEATURE_FLUSHBYASID))\n\t\tsvm->vmcb->control.tlb_ctl = TLB_CONTROL_FLUSH_ASID;\n\telse\n\t\tsvm->asid_generation--;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_dirty",
          "args": [
            "svm->vmcb",
            "VMCB_CR"
          ],
          "line": 4607
        },
        "resolved": true,
        "details": {
          "function_name": "mark_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "289-292",
          "snippet": "static inline void mark_dirty(struct vmcb *vmcb, int bit)\n{\n\tvmcb->control.clean &= ~(1 << bit);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic inline void mark_dirty(struct vmcb *vmcb, int bit)\n{\n\tvmcb->control.clean &= ~(1 << bit);\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 4604
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "294-297",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic void svm_set_cr3(struct kvm_vcpu *vcpu, unsigned long root)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tsvm->vmcb->save.cr3 = root;\n\tmark_dirty(svm->vmcb, VMCB_CR);\n\tsvm_flush_tlb(vcpu);\n}"
  },
  {
    "function_name": "svm_vcpu_run",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "4450-4600",
    "snippet": "static void svm_vcpu_run(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tsvm->vmcb->save.rax = vcpu->arch.regs[VCPU_REGS_RAX];\n\tsvm->vmcb->save.rsp = vcpu->arch.regs[VCPU_REGS_RSP];\n\tsvm->vmcb->save.rip = vcpu->arch.regs[VCPU_REGS_RIP];\n\n\t/*\n\t * A vmexit emulation is required before the vcpu can be executed\n\t * again.\n\t */\n\tif (unlikely(svm->nested.exit_required))\n\t\treturn;\n\n\tpre_svm_run(svm);\n\n\tsync_lapic_to_cr8(vcpu);\n\n\tsvm->vmcb->save.cr2 = vcpu->arch.cr2;\n\n\tclgi();\n\n\tlocal_irq_enable();\n\n\tasm volatile (\n\t\t\"push %%\" _ASM_BP \"; \\n\\t\"\n\t\t\"mov %c[rbx](%[svm]), %%\" _ASM_BX \" \\n\\t\"\n\t\t\"mov %c[rcx](%[svm]), %%\" _ASM_CX \" \\n\\t\"\n\t\t\"mov %c[rdx](%[svm]), %%\" _ASM_DX \" \\n\\t\"\n\t\t\"mov %c[rsi](%[svm]), %%\" _ASM_SI \" \\n\\t\"\n\t\t\"mov %c[rdi](%[svm]), %%\" _ASM_DI \" \\n\\t\"\n\t\t\"mov %c[rbp](%[svm]), %%\" _ASM_BP \" \\n\\t\"\n#ifdef CONFIG_X86_64\n\t\t\"mov %c[r8](%[svm]),  %%r8  \\n\\t\"\n\t\t\"mov %c[r9](%[svm]),  %%r9  \\n\\t\"\n\t\t\"mov %c[r10](%[svm]), %%r10 \\n\\t\"\n\t\t\"mov %c[r11](%[svm]), %%r11 \\n\\t\"\n\t\t\"mov %c[r12](%[svm]), %%r12 \\n\\t\"\n\t\t\"mov %c[r13](%[svm]), %%r13 \\n\\t\"\n\t\t\"mov %c[r14](%[svm]), %%r14 \\n\\t\"\n\t\t\"mov %c[r15](%[svm]), %%r15 \\n\\t\"\n#endif\n\n\t\t/* Enter guest mode */\n\t\t\"push %%\" _ASM_AX \" \\n\\t\"\n\t\t\"mov %c[vmcb](%[svm]), %%\" _ASM_AX \" \\n\\t\"\n\t\t__ex(SVM_VMLOAD) \"\\n\\t\"\n\t\t__ex(SVM_VMRUN) \"\\n\\t\"\n\t\t__ex(SVM_VMSAVE) \"\\n\\t\"\n\t\t\"pop %%\" _ASM_AX \" \\n\\t\"\n\n\t\t/* Save guest registers, load host registers */\n\t\t\"mov %%\" _ASM_BX \", %c[rbx](%[svm]) \\n\\t\"\n\t\t\"mov %%\" _ASM_CX \", %c[rcx](%[svm]) \\n\\t\"\n\t\t\"mov %%\" _ASM_DX \", %c[rdx](%[svm]) \\n\\t\"\n\t\t\"mov %%\" _ASM_SI \", %c[rsi](%[svm]) \\n\\t\"\n\t\t\"mov %%\" _ASM_DI \", %c[rdi](%[svm]) \\n\\t\"\n\t\t\"mov %%\" _ASM_BP \", %c[rbp](%[svm]) \\n\\t\"\n#ifdef CONFIG_X86_64\n\t\t\"mov %%r8,  %c[r8](%[svm]) \\n\\t\"\n\t\t\"mov %%r9,  %c[r9](%[svm]) \\n\\t\"\n\t\t\"mov %%r10, %c[r10](%[svm]) \\n\\t\"\n\t\t\"mov %%r11, %c[r11](%[svm]) \\n\\t\"\n\t\t\"mov %%r12, %c[r12](%[svm]) \\n\\t\"\n\t\t\"mov %%r13, %c[r13](%[svm]) \\n\\t\"\n\t\t\"mov %%r14, %c[r14](%[svm]) \\n\\t\"\n\t\t\"mov %%r15, %c[r15](%[svm]) \\n\\t\"\n#endif\n\t\t\"pop %%\" _ASM_BP\n\t\t:\n\t\t: [svm]\"a\"(svm),\n\t\t  [vmcb]\"i\"(offsetof(struct vcpu_svm, vmcb_pa)),\n\t\t  [rbx]\"i\"(offsetof(struct vcpu_svm, vcpu.arch.regs[VCPU_REGS_RBX])),\n\t\t  [rcx]\"i\"(offsetof(struct vcpu_svm, vcpu.arch.regs[VCPU_REGS_RCX])),\n\t\t  [rdx]\"i\"(offsetof(struct vcpu_svm, vcpu.arch.regs[VCPU_REGS_RDX])),\n\t\t  [rsi]\"i\"(offsetof(struct vcpu_svm, vcpu.arch.regs[VCPU_REGS_RSI])),\n\t\t  [rdi]\"i\"(offsetof(struct vcpu_svm, vcpu.arch.regs[VCPU_REGS_RDI])),\n\t\t  [rbp]\"i\"(offsetof(struct vcpu_svm, vcpu.arch.regs[VCPU_REGS_RBP]))\n#ifdef CONFIG_X86_64\n\t\t  , [r8]\"i\"(offsetof(struct vcpu_svm, vcpu.arch.regs[VCPU_REGS_R8])),\n\t\t  [r9]\"i\"(offsetof(struct vcpu_svm, vcpu.arch.regs[VCPU_REGS_R9])),\n\t\t  [r10]\"i\"(offsetof(struct vcpu_svm, vcpu.arch.regs[VCPU_REGS_R10])),\n\t\t  [r11]\"i\"(offsetof(struct vcpu_svm, vcpu.arch.regs[VCPU_REGS_R11])),\n\t\t  [r12]\"i\"(offsetof(struct vcpu_svm, vcpu.arch.regs[VCPU_REGS_R12])),\n\t\t  [r13]\"i\"(offsetof(struct vcpu_svm, vcpu.arch.regs[VCPU_REGS_R13])),\n\t\t  [r14]\"i\"(offsetof(struct vcpu_svm, vcpu.arch.regs[VCPU_REGS_R14])),\n\t\t  [r15]\"i\"(offsetof(struct vcpu_svm, vcpu.arch.regs[VCPU_REGS_R15]))\n#endif\n\t\t: \"cc\", \"memory\"\n#ifdef CONFIG_X86_64\n\t\t, \"rbx\", \"rcx\", \"rdx\", \"rsi\", \"rdi\"\n\t\t, \"r8\", \"r9\", \"r10\", \"r11\" , \"r12\", \"r13\", \"r14\", \"r15\"\n#else\n\t\t, \"ebx\", \"ecx\", \"edx\", \"esi\", \"edi\"\n#endif\n\t\t);\n\n#ifdef CONFIG_X86_64\n\twrmsrl(MSR_GS_BASE, svm->host.gs_base);\n#else\n\tloadsegment(fs, svm->host.fs);\n#ifndef CONFIG_X86_32_LAZY_GS\n\tloadsegment(gs, svm->host.gs);\n#endif\n#endif\n\n\treload_tss(vcpu);\n\n\tlocal_irq_disable();\n\n\tvcpu->arch.cr2 = svm->vmcb->save.cr2;\n\tvcpu->arch.regs[VCPU_REGS_RAX] = svm->vmcb->save.rax;\n\tvcpu->arch.regs[VCPU_REGS_RSP] = svm->vmcb->save.rsp;\n\tvcpu->arch.regs[VCPU_REGS_RIP] = svm->vmcb->save.rip;\n\n\tif (unlikely(svm->vmcb->control.exit_code == SVM_EXIT_NMI))\n\t\tkvm_before_handle_nmi(&svm->vcpu);\n\n\tstgi();\n\n\t/* Any pending NMI will happen here */\n\n\tif (unlikely(svm->vmcb->control.exit_code == SVM_EXIT_NMI))\n\t\tkvm_after_handle_nmi(&svm->vcpu);\n\n\tsync_cr8_to_lapic(vcpu);\n\n\tsvm->next_rip = 0;\n\n\tsvm->vmcb->control.tlb_ctl = TLB_CONTROL_DO_NOTHING;\n\n\t/* if exit due to PF check for async PF */\n\tif (svm->vmcb->control.exit_code == SVM_EXIT_EXCP_BASE + PF_VECTOR)\n\t\tsvm->apf_reason = kvm_read_and_reset_pf_reason();\n\n\tif (npt_enabled) {\n\t\tvcpu->arch.regs_avail &= ~(1 << VCPU_EXREG_PDPTR);\n\t\tvcpu->arch.regs_dirty &= ~(1 << VCPU_EXREG_PDPTR);\n\t}\n\n\t/*\n\t * We need to handle MC intercepts here before the vcpu has a chance to\n\t * change the physical cpu\n\t */\n\tif (unlikely(svm->vmcb->control.exit_code ==\n\t\t     SVM_EXIT_EXCP_BASE + MC_VECTOR))\n\t\tsvm_handle_mce(svm);\n\n\tmark_all_clean(svm->vmcb);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int nested = true;",
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_all_clean",
          "args": [
            "svm->vmcb"
          ],
          "line": 4599
        },
        "resolved": true,
        "details": {
          "function_name": "mark_all_clean",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "283-287",
          "snippet": "static inline void mark_all_clean(struct vmcb *vmcb)\n{\n\tvmcb->control.clean = ((1 << VMCB_DIRTY_MAX) - 1)\n\t\t\t       & ~VMCB_ALWAYS_DIRTY_MASK;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define VMCB_ALWAYS_DIRTY_MASK\t((1U << VMCB_INTR) | (1U << VMCB_CR2))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define VMCB_ALWAYS_DIRTY_MASK\t((1U << VMCB_INTR) | (1U << VMCB_CR2))\n\nstatic inline void mark_all_clean(struct vmcb *vmcb)\n{\n\tvmcb->control.clean = ((1 << VMCB_DIRTY_MAX) - 1)\n\t\t\t       & ~VMCB_ALWAYS_DIRTY_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "svm_handle_mce",
          "args": [
            "svm"
          ],
          "line": 4597
        },
        "resolved": true,
        "details": {
          "function_name": "svm_handle_mce",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "2074-2097",
          "snippet": "static void svm_handle_mce(struct vcpu_svm *svm)\n{\n\tif (is_erratum_383()) {\n\t\t/*\n\t\t * Erratum 383 triggered. Guest state is corrupt so kill the\n\t\t * guest.\n\t\t */\n\t\tpr_err(\"KVM: Guest triggered AMD Erratum 383\\n\");\n\n\t\tkvm_make_request(KVM_REQ_TRIPLE_FAULT, &svm->vcpu);\n\n\t\treturn;\n\t}\n\n\t/*\n\t * On an #MC intercept the MCE handler is not called automatically in\n\t * the host. So do it by hand here.\n\t */\n\tasm volatile (\n\t\t\"int $0x12\\n\");\n\t/* not sure if we ever come back to this point */\n\n\treturn;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic void svm_handle_mce(struct vcpu_svm *svm)\n{\n\tif (is_erratum_383()) {\n\t\t/*\n\t\t * Erratum 383 triggered. Guest state is corrupt so kill the\n\t\t * guest.\n\t\t */\n\t\tpr_err(\"KVM: Guest triggered AMD Erratum 383\\n\");\n\n\t\tkvm_make_request(KVM_REQ_TRIPLE_FAULT, &svm->vcpu);\n\n\t\treturn;\n\t}\n\n\t/*\n\t * On an #MC intercept the MCE handler is not called automatically in\n\t * the host. So do it by hand here.\n\t */\n\tasm volatile (\n\t\t\"int $0x12\\n\");\n\t/* not sure if we ever come back to this point */\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "svm->vmcb->control.exit_code ==\n\t\t     SVM_EXIT_EXCP_BASE + MC_VECTOR"
          ],
          "line": 4595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_read_and_reset_pf_reason",
          "args": [],
          "line": 4584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sync_cr8_to_lapic",
          "args": [
            "vcpu"
          ],
          "line": 4576
        },
        "resolved": true,
        "details": {
          "function_name": "sync_cr8_to_lapic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "4348-4359",
          "snippet": "static inline void sync_cr8_to_lapic(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (svm_nested_virtualize_tpr(vcpu))\n\t\treturn;\n\n\tif (!is_cr_intercept(svm, INTERCEPT_CR8_WRITE)) {\n\t\tint cr8 = svm->vmcb->control.int_ctl & V_TPR_MASK;\n\t\tkvm_set_cr8(vcpu, cr8);\n\t}\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic inline void sync_cr8_to_lapic(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (svm_nested_virtualize_tpr(vcpu))\n\t\treturn;\n\n\tif (!is_cr_intercept(svm, INTERCEPT_CR8_WRITE)) {\n\t\tint cr8 = svm->vmcb->control.int_ctl & V_TPR_MASK;\n\t\tkvm_set_cr8(vcpu, cr8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_after_handle_nmi",
          "args": [
            "&svm->vcpu"
          ],
          "line": 4574
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_after_handle_nmi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "5748-5751",
          "snippet": "void kvm_after_handle_nmi(struct kvm_vcpu *vcpu)\n{\n\t__this_cpu_write(current_vcpu, NULL);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nvoid kvm_after_handle_nmi(struct kvm_vcpu *vcpu)\n{\n\t__this_cpu_write(current_vcpu, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "svm->vmcb->control.exit_code == SVM_EXIT_NMI"
          ],
          "line": 4573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stgi",
          "args": [],
          "line": 4569
        },
        "resolved": true,
        "details": {
          "function_name": "stgi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "516-519",
          "snippet": "static inline void stgi(void)\n{\n\tasm volatile (__ex(SVM_STGI));\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic inline void stgi(void)\n{\n\tasm volatile (__ex(SVM_STGI));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_before_handle_nmi",
          "args": [
            "&svm->vcpu"
          ],
          "line": 4567
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_before_handle_nmi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "5742-5745",
          "snippet": "void kvm_before_handle_nmi(struct kvm_vcpu *vcpu)\n{\n\t__this_cpu_write(current_vcpu, vcpu);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nvoid kvm_before_handle_nmi(struct kvm_vcpu *vcpu)\n{\n\t__this_cpu_write(current_vcpu, vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "svm->vmcb->control.exit_code == SVM_EXIT_NMI"
          ],
          "line": 4566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_disable",
          "args": [],
          "line": 4559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reload_tss",
          "args": [
            "vcpu"
          ],
          "line": 4557
        },
        "resolved": true,
        "details": {
          "function_name": "reload_tss",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "4113-4120",
          "snippet": "static void reload_tss(struct kvm_vcpu *vcpu)\n{\n\tint cpu = raw_smp_processor_id();\n\n\tstruct svm_cpu_data *sd = per_cpu(svm_data, cpu);\n\tsd->tss_desc->type = 9; /* available 32/64-bit TSS */\n\tload_TR_desc();\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
            "static DEFINE_PER_CPU(struct svm_cpu_data *, svm_data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic DEFINE_PER_CPU(struct svm_cpu_data *, svm_data);\n\nstatic void reload_tss(struct kvm_vcpu *vcpu)\n{\n\tint cpu = raw_smp_processor_id();\n\n\tstruct svm_cpu_data *sd = per_cpu(svm_data, cpu);\n\tsd->tss_desc->type = 9; /* available 32/64-bit TSS */\n\tload_TR_desc();\n}"
        }
      },
      {
        "call_info": {
          "callee": "loadsegment",
          "args": [
            "gs",
            "svm->host.gs"
          ],
          "line": 4553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "loadsegment",
          "args": [
            "fs",
            "svm->host.fs"
          ],
          "line": 4551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wrmsrl",
          "args": [
            "MSR_GS_BASE",
            "svm->host.gs_base"
          ],
          "line": 4549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "\"i\"",
          "args": [
            "offsetof(struct vcpu_svm, vcpu.arch.regs[VCPU_REGS_RBP]"
          ],
          "line": 4528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "\"i\"",
          "args": [
            "offsetof(struct vcpu_svm, vcpu.arch.regs[VCPU_REGS_RDI]"
          ],
          "line": 4527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "\"i\"",
          "args": [
            "offsetof(struct vcpu_svm, vcpu.arch.regs[VCPU_REGS_RSI]"
          ],
          "line": 4526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "\"i\"",
          "args": [
            "offsetof(struct vcpu_svm, vcpu.arch.regs[VCPU_REGS_RDX]"
          ],
          "line": 4525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "\"i\"",
          "args": [
            "offsetof(struct vcpu_svm, vcpu.arch.regs[VCPU_REGS_RCX]"
          ],
          "line": 4524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "\"i\"",
          "args": [
            "offsetof(struct vcpu_svm, vcpu.arch.regs[VCPU_REGS_RBX]"
          ],
          "line": 4523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "\"i\"",
          "args": [
            "offsetof(struct vcpu_svm, vmcb_pa)"
          ],
          "line": 4522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "\"a\"",
          "args": [
            "svm"
          ],
          "line": 4521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "\"\\n\\t\"\n\t\t__ex",
          "args": [
            "SVM_VMSAVE"
          ],
          "line": 4498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "\"\\n\\t\"\n\t\t__ex",
          "args": [
            "SVM_VMRUN"
          ],
          "line": 4497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asm volatile",
          "args": [
            "SVM_VMLOAD"
          ],
          "line": 4475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_enable",
          "args": [],
          "line": 4473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clgi",
          "args": [],
          "line": 4471
        },
        "resolved": true,
        "details": {
          "function_name": "clgi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "511-514",
          "snippet": "static inline void clgi(void)\n{\n\tasm volatile (__ex(SVM_CLGI));\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic inline void clgi(void)\n{\n\tasm volatile (__ex(SVM_CLGI));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sync_lapic_to_cr8",
          "args": [
            "vcpu"
          ],
          "line": 4467
        },
        "resolved": true,
        "details": {
          "function_name": "sync_lapic_to_cr8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "4361-4373",
          "snippet": "static inline void sync_lapic_to_cr8(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tu64 cr8;\n\n\tif (svm_nested_virtualize_tpr(vcpu) ||\n\t    kvm_vcpu_apicv_active(vcpu))\n\t\treturn;\n\n\tcr8 = kvm_get_cr8(vcpu);\n\tsvm->vmcb->control.int_ctl &= ~V_TPR_MASK;\n\tsvm->vmcb->control.int_ctl |= cr8 & V_TPR_MASK;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic inline void sync_lapic_to_cr8(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tu64 cr8;\n\n\tif (svm_nested_virtualize_tpr(vcpu) ||\n\t    kvm_vcpu_apicv_active(vcpu))\n\t\treturn;\n\n\tcr8 = kvm_get_cr8(vcpu);\n\tsvm->vmcb->control.int_ctl &= ~V_TPR_MASK;\n\tsvm->vmcb->control.int_ctl |= cr8 & V_TPR_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pre_svm_run",
          "args": [
            "svm"
          ],
          "line": 4465
        },
        "resolved": true,
        "details": {
          "function_name": "pre_svm_run",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "4122-4131",
          "snippet": "static void pre_svm_run(struct vcpu_svm *svm)\n{\n\tint cpu = raw_smp_processor_id();\n\n\tstruct svm_cpu_data *sd = per_cpu(svm_data, cpu);\n\n\t/* FIXME: handle wraparound of asid_generation */\n\tif (svm->asid_generation != sd->asid_generation)\n\t\tnew_asid(svm, sd);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);",
            "static DEFINE_PER_CPU(struct svm_cpu_data *, svm_data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\nstatic DEFINE_PER_CPU(struct svm_cpu_data *, svm_data);\n\nstatic void pre_svm_run(struct vcpu_svm *svm)\n{\n\tint cpu = raw_smp_processor_id();\n\n\tstruct svm_cpu_data *sd = per_cpu(svm_data, cpu);\n\n\t/* FIXME: handle wraparound of asid_generation */\n\tif (svm->asid_generation != sd->asid_generation)\n\t\tnew_asid(svm, sd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "svm->nested.exit_required"
          ],
          "line": 4462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 4452
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "294-297",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int nested = true;\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic void svm_vcpu_run(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tsvm->vmcb->save.rax = vcpu->arch.regs[VCPU_REGS_RAX];\n\tsvm->vmcb->save.rsp = vcpu->arch.regs[VCPU_REGS_RSP];\n\tsvm->vmcb->save.rip = vcpu->arch.regs[VCPU_REGS_RIP];\n\n\t/*\n\t * A vmexit emulation is required before the vcpu can be executed\n\t * again.\n\t */\n\tif (unlikely(svm->nested.exit_required))\n\t\treturn;\n\n\tpre_svm_run(svm);\n\n\tsync_lapic_to_cr8(vcpu);\n\n\tsvm->vmcb->save.cr2 = vcpu->arch.cr2;\n\n\tclgi();\n\n\tlocal_irq_enable();\n\n\tasm volatile (\n\t\t\"push %%\" _ASM_BP \"; \\n\\t\"\n\t\t\"mov %c[rbx](%[svm]), %%\" _ASM_BX \" \\n\\t\"\n\t\t\"mov %c[rcx](%[svm]), %%\" _ASM_CX \" \\n\\t\"\n\t\t\"mov %c[rdx](%[svm]), %%\" _ASM_DX \" \\n\\t\"\n\t\t\"mov %c[rsi](%[svm]), %%\" _ASM_SI \" \\n\\t\"\n\t\t\"mov %c[rdi](%[svm]), %%\" _ASM_DI \" \\n\\t\"\n\t\t\"mov %c[rbp](%[svm]), %%\" _ASM_BP \" \\n\\t\"\n#ifdef CONFIG_X86_64\n\t\t\"mov %c[r8](%[svm]),  %%r8  \\n\\t\"\n\t\t\"mov %c[r9](%[svm]),  %%r9  \\n\\t\"\n\t\t\"mov %c[r10](%[svm]), %%r10 \\n\\t\"\n\t\t\"mov %c[r11](%[svm]), %%r11 \\n\\t\"\n\t\t\"mov %c[r12](%[svm]), %%r12 \\n\\t\"\n\t\t\"mov %c[r13](%[svm]), %%r13 \\n\\t\"\n\t\t\"mov %c[r14](%[svm]), %%r14 \\n\\t\"\n\t\t\"mov %c[r15](%[svm]), %%r15 \\n\\t\"\n#endif\n\n\t\t/* Enter guest mode */\n\t\t\"push %%\" _ASM_AX \" \\n\\t\"\n\t\t\"mov %c[vmcb](%[svm]), %%\" _ASM_AX \" \\n\\t\"\n\t\t__ex(SVM_VMLOAD) \"\\n\\t\"\n\t\t__ex(SVM_VMRUN) \"\\n\\t\"\n\t\t__ex(SVM_VMSAVE) \"\\n\\t\"\n\t\t\"pop %%\" _ASM_AX \" \\n\\t\"\n\n\t\t/* Save guest registers, load host registers */\n\t\t\"mov %%\" _ASM_BX \", %c[rbx](%[svm]) \\n\\t\"\n\t\t\"mov %%\" _ASM_CX \", %c[rcx](%[svm]) \\n\\t\"\n\t\t\"mov %%\" _ASM_DX \", %c[rdx](%[svm]) \\n\\t\"\n\t\t\"mov %%\" _ASM_SI \", %c[rsi](%[svm]) \\n\\t\"\n\t\t\"mov %%\" _ASM_DI \", %c[rdi](%[svm]) \\n\\t\"\n\t\t\"mov %%\" _ASM_BP \", %c[rbp](%[svm]) \\n\\t\"\n#ifdef CONFIG_X86_64\n\t\t\"mov %%r8,  %c[r8](%[svm]) \\n\\t\"\n\t\t\"mov %%r9,  %c[r9](%[svm]) \\n\\t\"\n\t\t\"mov %%r10, %c[r10](%[svm]) \\n\\t\"\n\t\t\"mov %%r11, %c[r11](%[svm]) \\n\\t\"\n\t\t\"mov %%r12, %c[r12](%[svm]) \\n\\t\"\n\t\t\"mov %%r13, %c[r13](%[svm]) \\n\\t\"\n\t\t\"mov %%r14, %c[r14](%[svm]) \\n\\t\"\n\t\t\"mov %%r15, %c[r15](%[svm]) \\n\\t\"\n#endif\n\t\t\"pop %%\" _ASM_BP\n\t\t:\n\t\t: [svm]\"a\"(svm),\n\t\t  [vmcb]\"i\"(offsetof(struct vcpu_svm, vmcb_pa)),\n\t\t  [rbx]\"i\"(offsetof(struct vcpu_svm, vcpu.arch.regs[VCPU_REGS_RBX])),\n\t\t  [rcx]\"i\"(offsetof(struct vcpu_svm, vcpu.arch.regs[VCPU_REGS_RCX])),\n\t\t  [rdx]\"i\"(offsetof(struct vcpu_svm, vcpu.arch.regs[VCPU_REGS_RDX])),\n\t\t  [rsi]\"i\"(offsetof(struct vcpu_svm, vcpu.arch.regs[VCPU_REGS_RSI])),\n\t\t  [rdi]\"i\"(offsetof(struct vcpu_svm, vcpu.arch.regs[VCPU_REGS_RDI])),\n\t\t  [rbp]\"i\"(offsetof(struct vcpu_svm, vcpu.arch.regs[VCPU_REGS_RBP]))\n#ifdef CONFIG_X86_64\n\t\t  , [r8]\"i\"(offsetof(struct vcpu_svm, vcpu.arch.regs[VCPU_REGS_R8])),\n\t\t  [r9]\"i\"(offsetof(struct vcpu_svm, vcpu.arch.regs[VCPU_REGS_R9])),\n\t\t  [r10]\"i\"(offsetof(struct vcpu_svm, vcpu.arch.regs[VCPU_REGS_R10])),\n\t\t  [r11]\"i\"(offsetof(struct vcpu_svm, vcpu.arch.regs[VCPU_REGS_R11])),\n\t\t  [r12]\"i\"(offsetof(struct vcpu_svm, vcpu.arch.regs[VCPU_REGS_R12])),\n\t\t  [r13]\"i\"(offsetof(struct vcpu_svm, vcpu.arch.regs[VCPU_REGS_R13])),\n\t\t  [r14]\"i\"(offsetof(struct vcpu_svm, vcpu.arch.regs[VCPU_REGS_R14])),\n\t\t  [r15]\"i\"(offsetof(struct vcpu_svm, vcpu.arch.regs[VCPU_REGS_R15]))\n#endif\n\t\t: \"cc\", \"memory\"\n#ifdef CONFIG_X86_64\n\t\t, \"rbx\", \"rcx\", \"rdx\", \"rsi\", \"rdi\"\n\t\t, \"r8\", \"r9\", \"r10\", \"r11\" , \"r12\", \"r13\", \"r14\", \"r15\"\n#else\n\t\t, \"ebx\", \"ecx\", \"edx\", \"esi\", \"edi\"\n#endif\n\t\t);\n\n#ifdef CONFIG_X86_64\n\twrmsrl(MSR_GS_BASE, svm->host.gs_base);\n#else\n\tloadsegment(fs, svm->host.fs);\n#ifndef CONFIG_X86_32_LAZY_GS\n\tloadsegment(gs, svm->host.gs);\n#endif\n#endif\n\n\treload_tss(vcpu);\n\n\tlocal_irq_disable();\n\n\tvcpu->arch.cr2 = svm->vmcb->save.cr2;\n\tvcpu->arch.regs[VCPU_REGS_RAX] = svm->vmcb->save.rax;\n\tvcpu->arch.regs[VCPU_REGS_RSP] = svm->vmcb->save.rsp;\n\tvcpu->arch.regs[VCPU_REGS_RIP] = svm->vmcb->save.rip;\n\n\tif (unlikely(svm->vmcb->control.exit_code == SVM_EXIT_NMI))\n\t\tkvm_before_handle_nmi(&svm->vcpu);\n\n\tstgi();\n\n\t/* Any pending NMI will happen here */\n\n\tif (unlikely(svm->vmcb->control.exit_code == SVM_EXIT_NMI))\n\t\tkvm_after_handle_nmi(&svm->vcpu);\n\n\tsync_cr8_to_lapic(vcpu);\n\n\tsvm->next_rip = 0;\n\n\tsvm->vmcb->control.tlb_ctl = TLB_CONTROL_DO_NOTHING;\n\n\t/* if exit due to PF check for async PF */\n\tif (svm->vmcb->control.exit_code == SVM_EXIT_EXCP_BASE + PF_VECTOR)\n\t\tsvm->apf_reason = kvm_read_and_reset_pf_reason();\n\n\tif (npt_enabled) {\n\t\tvcpu->arch.regs_avail &= ~(1 << VCPU_EXREG_PDPTR);\n\t\tvcpu->arch.regs_dirty &= ~(1 << VCPU_EXREG_PDPTR);\n\t}\n\n\t/*\n\t * We need to handle MC intercepts here before the vcpu has a chance to\n\t * change the physical cpu\n\t */\n\tif (unlikely(svm->vmcb->control.exit_code ==\n\t\t     SVM_EXIT_EXCP_BASE + MC_VECTOR))\n\t\tsvm_handle_mce(svm);\n\n\tmark_all_clean(svm->vmcb);\n}"
  },
  {
    "function_name": "svm_cancel_injection",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "4439-4448",
    "snippet": "static void svm_cancel_injection(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tstruct vmcb_control_area *control = &svm->vmcb->control;\n\n\tcontrol->exit_int_info = control->event_inj;\n\tcontrol->exit_int_info_err = control->event_inj_err;\n\tcontrol->event_inj = 0;\n\tsvm_complete_interrupts(svm);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "svm_complete_interrupts",
          "args": [
            "svm"
          ],
          "line": 4447
        },
        "resolved": true,
        "details": {
          "function_name": "svm_complete_interrupts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "4375-4437",
          "snippet": "static void svm_complete_interrupts(struct vcpu_svm *svm)\n{\n\tu8 vector;\n\tint type;\n\tu32 exitintinfo = svm->vmcb->control.exit_int_info;\n\tunsigned int3_injected = svm->int3_injected;\n\n\tsvm->int3_injected = 0;\n\n\t/*\n\t * If we've made progress since setting HF_IRET_MASK, we've\n\t * executed an IRET and can allow NMI injection.\n\t */\n\tif ((svm->vcpu.arch.hflags & HF_IRET_MASK)\n\t    && kvm_rip_read(&svm->vcpu) != svm->nmi_iret_rip) {\n\t\tsvm->vcpu.arch.hflags &= ~(HF_NMI_MASK | HF_IRET_MASK);\n\t\tkvm_make_request(KVM_REQ_EVENT, &svm->vcpu);\n\t}\n\n\tsvm->vcpu.arch.nmi_injected = false;\n\tkvm_clear_exception_queue(&svm->vcpu);\n\tkvm_clear_interrupt_queue(&svm->vcpu);\n\n\tif (!(exitintinfo & SVM_EXITINTINFO_VALID))\n\t\treturn;\n\n\tkvm_make_request(KVM_REQ_EVENT, &svm->vcpu);\n\n\tvector = exitintinfo & SVM_EXITINTINFO_VEC_MASK;\n\ttype = exitintinfo & SVM_EXITINTINFO_TYPE_MASK;\n\n\tswitch (type) {\n\tcase SVM_EXITINTINFO_TYPE_NMI:\n\t\tsvm->vcpu.arch.nmi_injected = true;\n\t\tbreak;\n\tcase SVM_EXITINTINFO_TYPE_EXEPT:\n\t\t/*\n\t\t * In case of software exceptions, do not reinject the vector,\n\t\t * but re-execute the instruction instead. Rewind RIP first\n\t\t * if we emulated INT3 before.\n\t\t */\n\t\tif (kvm_exception_is_soft(vector)) {\n\t\t\tif (vector == BP_VECTOR && int3_injected &&\n\t\t\t    kvm_is_linear_rip(&svm->vcpu, svm->int3_rip))\n\t\t\t\tkvm_rip_write(&svm->vcpu,\n\t\t\t\t\t      kvm_rip_read(&svm->vcpu) -\n\t\t\t\t\t      int3_injected);\n\t\t\tbreak;\n\t\t}\n\t\tif (exitintinfo & SVM_EXITINTINFO_VALID_ERR) {\n\t\t\tu32 err = svm->vmcb->control.exit_int_info_err;\n\t\t\tkvm_requeue_exception_e(&svm->vcpu, vector, err);\n\n\t\t} else\n\t\t\tkvm_requeue_exception(&svm->vcpu, vector);\n\t\tbreak;\n\tcase SVM_EXITINTINFO_TYPE_INTR:\n\t\tkvm_queue_interrupt(&svm->vcpu, vector, false);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm)\n{\n\tu8 vector;\n\tint type;\n\tu32 exitintinfo = svm->vmcb->control.exit_int_info;\n\tunsigned int3_injected = svm->int3_injected;\n\n\tsvm->int3_injected = 0;\n\n\t/*\n\t * If we've made progress since setting HF_IRET_MASK, we've\n\t * executed an IRET and can allow NMI injection.\n\t */\n\tif ((svm->vcpu.arch.hflags & HF_IRET_MASK)\n\t    && kvm_rip_read(&svm->vcpu) != svm->nmi_iret_rip) {\n\t\tsvm->vcpu.arch.hflags &= ~(HF_NMI_MASK | HF_IRET_MASK);\n\t\tkvm_make_request(KVM_REQ_EVENT, &svm->vcpu);\n\t}\n\n\tsvm->vcpu.arch.nmi_injected = false;\n\tkvm_clear_exception_queue(&svm->vcpu);\n\tkvm_clear_interrupt_queue(&svm->vcpu);\n\n\tif (!(exitintinfo & SVM_EXITINTINFO_VALID))\n\t\treturn;\n\n\tkvm_make_request(KVM_REQ_EVENT, &svm->vcpu);\n\n\tvector = exitintinfo & SVM_EXITINTINFO_VEC_MASK;\n\ttype = exitintinfo & SVM_EXITINTINFO_TYPE_MASK;\n\n\tswitch (type) {\n\tcase SVM_EXITINTINFO_TYPE_NMI:\n\t\tsvm->vcpu.arch.nmi_injected = true;\n\t\tbreak;\n\tcase SVM_EXITINTINFO_TYPE_EXEPT:\n\t\t/*\n\t\t * In case of software exceptions, do not reinject the vector,\n\t\t * but re-execute the instruction instead. Rewind RIP first\n\t\t * if we emulated INT3 before.\n\t\t */\n\t\tif (kvm_exception_is_soft(vector)) {\n\t\t\tif (vector == BP_VECTOR && int3_injected &&\n\t\t\t    kvm_is_linear_rip(&svm->vcpu, svm->int3_rip))\n\t\t\t\tkvm_rip_write(&svm->vcpu,\n\t\t\t\t\t      kvm_rip_read(&svm->vcpu) -\n\t\t\t\t\t      int3_injected);\n\t\t\tbreak;\n\t\t}\n\t\tif (exitintinfo & SVM_EXITINTINFO_VALID_ERR) {\n\t\t\tu32 err = svm->vmcb->control.exit_int_info_err;\n\t\t\tkvm_requeue_exception_e(&svm->vcpu, vector, err);\n\n\t\t} else\n\t\t\tkvm_requeue_exception(&svm->vcpu, vector);\n\t\tbreak;\n\tcase SVM_EXITINTINFO_TYPE_INTR:\n\t\tkvm_queue_interrupt(&svm->vcpu, vector, false);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 4441
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "294-297",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic void svm_cancel_injection(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tstruct vmcb_control_area *control = &svm->vmcb->control;\n\n\tcontrol->exit_int_info = control->event_inj;\n\tcontrol->exit_int_info_err = control->event_inj_err;\n\tcontrol->event_inj = 0;\n\tsvm_complete_interrupts(svm);\n}"
  },
  {
    "function_name": "svm_complete_interrupts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "4375-4437",
    "snippet": "static void svm_complete_interrupts(struct vcpu_svm *svm)\n{\n\tu8 vector;\n\tint type;\n\tu32 exitintinfo = svm->vmcb->control.exit_int_info;\n\tunsigned int3_injected = svm->int3_injected;\n\n\tsvm->int3_injected = 0;\n\n\t/*\n\t * If we've made progress since setting HF_IRET_MASK, we've\n\t * executed an IRET and can allow NMI injection.\n\t */\n\tif ((svm->vcpu.arch.hflags & HF_IRET_MASK)\n\t    && kvm_rip_read(&svm->vcpu) != svm->nmi_iret_rip) {\n\t\tsvm->vcpu.arch.hflags &= ~(HF_NMI_MASK | HF_IRET_MASK);\n\t\tkvm_make_request(KVM_REQ_EVENT, &svm->vcpu);\n\t}\n\n\tsvm->vcpu.arch.nmi_injected = false;\n\tkvm_clear_exception_queue(&svm->vcpu);\n\tkvm_clear_interrupt_queue(&svm->vcpu);\n\n\tif (!(exitintinfo & SVM_EXITINTINFO_VALID))\n\t\treturn;\n\n\tkvm_make_request(KVM_REQ_EVENT, &svm->vcpu);\n\n\tvector = exitintinfo & SVM_EXITINTINFO_VEC_MASK;\n\ttype = exitintinfo & SVM_EXITINTINFO_TYPE_MASK;\n\n\tswitch (type) {\n\tcase SVM_EXITINTINFO_TYPE_NMI:\n\t\tsvm->vcpu.arch.nmi_injected = true;\n\t\tbreak;\n\tcase SVM_EXITINTINFO_TYPE_EXEPT:\n\t\t/*\n\t\t * In case of software exceptions, do not reinject the vector,\n\t\t * but re-execute the instruction instead. Rewind RIP first\n\t\t * if we emulated INT3 before.\n\t\t */\n\t\tif (kvm_exception_is_soft(vector)) {\n\t\t\tif (vector == BP_VECTOR && int3_injected &&\n\t\t\t    kvm_is_linear_rip(&svm->vcpu, svm->int3_rip))\n\t\t\t\tkvm_rip_write(&svm->vcpu,\n\t\t\t\t\t      kvm_rip_read(&svm->vcpu) -\n\t\t\t\t\t      int3_injected);\n\t\t\tbreak;\n\t\t}\n\t\tif (exitintinfo & SVM_EXITINTINFO_VALID_ERR) {\n\t\t\tu32 err = svm->vmcb->control.exit_int_info_err;\n\t\t\tkvm_requeue_exception_e(&svm->vcpu, vector, err);\n\n\t\t} else\n\t\t\tkvm_requeue_exception(&svm->vcpu, vector);\n\t\tbreak;\n\tcase SVM_EXITINTINFO_TYPE_INTR:\n\t\tkvm_queue_interrupt(&svm->vcpu, vector, false);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_queue_interrupt",
          "args": [
            "&svm->vcpu",
            "vector",
            "false"
          ],
          "line": 4432
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_queue_interrupt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.h",
          "lines": "14-20",
          "snippet": "static inline void kvm_queue_interrupt(struct kvm_vcpu *vcpu, u8 vector,\n\tbool soft)\n{\n\tvcpu->arch.interrupt.pending = true;\n\tvcpu->arch.interrupt.soft = soft;\n\tvcpu->arch.interrupt.nr = vector;\n}",
          "includes": [
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline void kvm_queue_interrupt(struct kvm_vcpu *vcpu, u8 vector,\n\tbool soft)\n{\n\tvcpu->arch.interrupt.pending = true;\n\tvcpu->arch.interrupt.soft = soft;\n\tvcpu->arch.interrupt.nr = vector;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_requeue_exception",
          "args": [
            "&svm->vcpu",
            "vector"
          ],
          "line": 4429
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_requeue_exception",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "415-418",
          "snippet": "void kvm_requeue_exception(struct kvm_vcpu *vcpu, unsigned nr)\n{\n\tkvm_multiple_exception(vcpu, nr, false, 0, true);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nvoid kvm_requeue_exception(struct kvm_vcpu *vcpu, unsigned nr)\n{\n\tkvm_multiple_exception(vcpu, nr, false, 0, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_requeue_exception_e",
          "args": [
            "&svm->vcpu",
            "vector",
            "err"
          ],
          "line": 4426
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_requeue_exception_e",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "461-464",
          "snippet": "void kvm_requeue_exception_e(struct kvm_vcpu *vcpu, unsigned nr, u32 error_code)\n{\n\tkvm_multiple_exception(vcpu, nr, true, error_code, true);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nvoid kvm_requeue_exception_e(struct kvm_vcpu *vcpu, unsigned nr, u32 error_code)\n{\n\tkvm_multiple_exception(vcpu, nr, true, error_code, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_rip_write",
          "args": [
            "&svm->vcpu",
            "kvm_rip_read(&svm->vcpu) -\n\t\t\t\t\t      int3_injected"
          ],
          "line": 4419
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_rip_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "32-35",
          "snippet": "static inline void kvm_rip_write(struct kvm_vcpu *vcpu, unsigned long val)\n{\n\tkvm_register_write(vcpu, VCPU_REGS_RIP, val);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void kvm_rip_write(struct kvm_vcpu *vcpu, unsigned long val)\n{\n\tkvm_register_write(vcpu, VCPU_REGS_RIP, val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_rip_read",
          "args": [
            "&svm->vcpu"
          ],
          "line": 4420
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_rip_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "27-30",
          "snippet": "static inline unsigned long kvm_rip_read(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_register_read(vcpu, VCPU_REGS_RIP);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline unsigned long kvm_rip_read(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_register_read(vcpu, VCPU_REGS_RIP);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_is_linear_rip",
          "args": [
            "&svm->vcpu",
            "svm->int3_rip"
          ],
          "line": 4418
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_is_linear_rip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "8157-8160",
          "snippet": "bool kvm_is_linear_rip(struct kvm_vcpu *vcpu, unsigned long linear_rip)\n{\n\treturn kvm_get_linear_rip(vcpu) == linear_rip;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nbool kvm_is_linear_rip(struct kvm_vcpu *vcpu, unsigned long linear_rip)\n{\n\treturn kvm_get_linear_rip(vcpu) == linear_rip;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_exception_is_soft",
          "args": [
            "vector"
          ],
          "line": 4416
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_exception_is_soft",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.h",
          "lines": "33-36",
          "snippet": "static inline bool kvm_exception_is_soft(unsigned int nr)\n{\n\treturn (nr == BP_VECTOR) || (nr == OF_VECTOR);\n}",
          "includes": [
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline bool kvm_exception_is_soft(unsigned int nr)\n{\n\treturn (nr == BP_VECTOR) || (nr == OF_VECTOR);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_make_request",
          "args": [
            "KVM_REQ_EVENT",
            "&svm->vcpu"
          ],
          "line": 4401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_clear_interrupt_queue",
          "args": [
            "&svm->vcpu"
          ],
          "line": 4396
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_clear_interrupt_queue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.h",
          "lines": "22-25",
          "snippet": "static inline void kvm_clear_interrupt_queue(struct kvm_vcpu *vcpu)\n{\n\tvcpu->arch.interrupt.pending = false;\n}",
          "includes": [
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline void kvm_clear_interrupt_queue(struct kvm_vcpu *vcpu)\n{\n\tvcpu->arch.interrupt.pending = false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_clear_exception_queue",
          "args": [
            "&svm->vcpu"
          ],
          "line": 4395
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_clear_exception_queue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.h",
          "lines": "9-12",
          "snippet": "static inline void kvm_clear_exception_queue(struct kvm_vcpu *vcpu)\n{\n\tvcpu->arch.exception.pending = false;\n}",
          "includes": [
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline void kvm_clear_exception_queue(struct kvm_vcpu *vcpu)\n{\n\tvcpu->arch.exception.pending = false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_make_request",
          "args": [
            "KVM_REQ_EVENT",
            "&svm->vcpu"
          ],
          "line": 4391
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm)\n{\n\tu8 vector;\n\tint type;\n\tu32 exitintinfo = svm->vmcb->control.exit_int_info;\n\tunsigned int3_injected = svm->int3_injected;\n\n\tsvm->int3_injected = 0;\n\n\t/*\n\t * If we've made progress since setting HF_IRET_MASK, we've\n\t * executed an IRET and can allow NMI injection.\n\t */\n\tif ((svm->vcpu.arch.hflags & HF_IRET_MASK)\n\t    && kvm_rip_read(&svm->vcpu) != svm->nmi_iret_rip) {\n\t\tsvm->vcpu.arch.hflags &= ~(HF_NMI_MASK | HF_IRET_MASK);\n\t\tkvm_make_request(KVM_REQ_EVENT, &svm->vcpu);\n\t}\n\n\tsvm->vcpu.arch.nmi_injected = false;\n\tkvm_clear_exception_queue(&svm->vcpu);\n\tkvm_clear_interrupt_queue(&svm->vcpu);\n\n\tif (!(exitintinfo & SVM_EXITINTINFO_VALID))\n\t\treturn;\n\n\tkvm_make_request(KVM_REQ_EVENT, &svm->vcpu);\n\n\tvector = exitintinfo & SVM_EXITINTINFO_VEC_MASK;\n\ttype = exitintinfo & SVM_EXITINTINFO_TYPE_MASK;\n\n\tswitch (type) {\n\tcase SVM_EXITINTINFO_TYPE_NMI:\n\t\tsvm->vcpu.arch.nmi_injected = true;\n\t\tbreak;\n\tcase SVM_EXITINTINFO_TYPE_EXEPT:\n\t\t/*\n\t\t * In case of software exceptions, do not reinject the vector,\n\t\t * but re-execute the instruction instead. Rewind RIP first\n\t\t * if we emulated INT3 before.\n\t\t */\n\t\tif (kvm_exception_is_soft(vector)) {\n\t\t\tif (vector == BP_VECTOR && int3_injected &&\n\t\t\t    kvm_is_linear_rip(&svm->vcpu, svm->int3_rip))\n\t\t\t\tkvm_rip_write(&svm->vcpu,\n\t\t\t\t\t      kvm_rip_read(&svm->vcpu) -\n\t\t\t\t\t      int3_injected);\n\t\t\tbreak;\n\t\t}\n\t\tif (exitintinfo & SVM_EXITINTINFO_VALID_ERR) {\n\t\t\tu32 err = svm->vmcb->control.exit_int_info_err;\n\t\t\tkvm_requeue_exception_e(&svm->vcpu, vector, err);\n\n\t\t} else\n\t\t\tkvm_requeue_exception(&svm->vcpu, vector);\n\t\tbreak;\n\tcase SVM_EXITINTINFO_TYPE_INTR:\n\t\tkvm_queue_interrupt(&svm->vcpu, vector, false);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}"
  },
  {
    "function_name": "sync_lapic_to_cr8",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "4361-4373",
    "snippet": "static inline void sync_lapic_to_cr8(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tu64 cr8;\n\n\tif (svm_nested_virtualize_tpr(vcpu) ||\n\t    kvm_vcpu_apicv_active(vcpu))\n\t\treturn;\n\n\tcr8 = kvm_get_cr8(vcpu);\n\tsvm->vmcb->control.int_ctl &= ~V_TPR_MASK;\n\tsvm->vmcb->control.int_ctl |= cr8 & V_TPR_MASK;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_get_cr8",
          "args": [
            "vcpu"
          ],
          "line": 4370
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_get_cr8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "816-822",
          "snippet": "unsigned long kvm_get_cr8(struct kvm_vcpu *vcpu)\n{\n\tif (lapic_in_kernel(vcpu))\n\t\treturn kvm_lapic_get_cr8(vcpu);\n\telse\n\t\treturn vcpu->arch.cr8;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nunsigned long kvm_get_cr8(struct kvm_vcpu *vcpu)\n{\n\tif (lapic_in_kernel(vcpu))\n\t\treturn kvm_lapic_get_cr8(vcpu);\n\telse\n\t\treturn vcpu->arch.cr8;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_apicv_active",
          "args": [
            "vcpu"
          ],
          "line": 4367
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_vcpu_apicv_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.h",
          "lines": "181-184",
          "snippet": "static inline bool kvm_vcpu_apicv_active(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.apic && vcpu->arch.apicv_active;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline bool kvm_vcpu_apicv_active(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.apic && vcpu->arch.apicv_active;\n}"
        }
      },
      {
        "call_info": {
          "callee": "svm_nested_virtualize_tpr",
          "args": [
            "vcpu"
          ],
          "line": 4366
        },
        "resolved": true,
        "details": {
          "function_name": "svm_nested_virtualize_tpr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "4169-4172",
          "snippet": "static inline bool svm_nested_virtualize_tpr(struct kvm_vcpu *vcpu)\n{\n\treturn is_guest_mode(vcpu) && (vcpu->arch.hflags & HF_VINTR_MASK);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\n\nstatic inline bool svm_nested_virtualize_tpr(struct kvm_vcpu *vcpu)\n{\n\treturn is_guest_mode(vcpu) && (vcpu->arch.hflags & HF_VINTR_MASK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 4363
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "294-297",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic inline void sync_lapic_to_cr8(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tu64 cr8;\n\n\tif (svm_nested_virtualize_tpr(vcpu) ||\n\t    kvm_vcpu_apicv_active(vcpu))\n\t\treturn;\n\n\tcr8 = kvm_get_cr8(vcpu);\n\tsvm->vmcb->control.int_ctl &= ~V_TPR_MASK;\n\tsvm->vmcb->control.int_ctl |= cr8 & V_TPR_MASK;\n}"
  },
  {
    "function_name": "sync_cr8_to_lapic",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "4348-4359",
    "snippet": "static inline void sync_cr8_to_lapic(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (svm_nested_virtualize_tpr(vcpu))\n\t\treturn;\n\n\tif (!is_cr_intercept(svm, INTERCEPT_CR8_WRITE)) {\n\t\tint cr8 = svm->vmcb->control.int_ctl & V_TPR_MASK;\n\t\tkvm_set_cr8(vcpu, cr8);\n\t}\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_set_cr8",
          "args": [
            "vcpu",
            "cr8"
          ],
          "line": 4357
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_set_cr8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "804-813",
          "snippet": "int kvm_set_cr8(struct kvm_vcpu *vcpu, unsigned long cr8)\n{\n\tif (cr8 & CR8_RESERVED_BITS)\n\t\treturn 1;\n\tif (lapic_in_kernel(vcpu))\n\t\tkvm_lapic_set_tpr(vcpu, cr8);\n\telse\n\t\tvcpu->arch.cr8 = cr8;\n\treturn 0;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nint kvm_set_cr8(struct kvm_vcpu *vcpu, unsigned long cr8)\n{\n\tif (cr8 & CR8_RESERVED_BITS)\n\t\treturn 1;\n\tif (lapic_in_kernel(vcpu))\n\t\tkvm_lapic_set_tpr(vcpu, cr8);\n\telse\n\t\tvcpu->arch.cr8 = cr8;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_cr_intercept",
          "args": [
            "svm",
            "INTERCEPT_CR8_WRITE"
          ],
          "line": 4355
        },
        "resolved": true,
        "details": {
          "function_name": "is_cr_intercept",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "362-367",
          "snippet": "static inline bool is_cr_intercept(struct vcpu_svm *svm, int bit)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\treturn vmcb->control.intercept_cr & (1U << bit);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic inline bool is_cr_intercept(struct vcpu_svm *svm, int bit)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\treturn vmcb->control.intercept_cr & (1U << bit);\n}"
        }
      },
      {
        "call_info": {
          "callee": "svm_nested_virtualize_tpr",
          "args": [
            "vcpu"
          ],
          "line": 4352
        },
        "resolved": true,
        "details": {
          "function_name": "svm_nested_virtualize_tpr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "4169-4172",
          "snippet": "static inline bool svm_nested_virtualize_tpr(struct kvm_vcpu *vcpu)\n{\n\treturn is_guest_mode(vcpu) && (vcpu->arch.hflags & HF_VINTR_MASK);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\n\nstatic inline bool svm_nested_virtualize_tpr(struct kvm_vcpu *vcpu)\n{\n\treturn is_guest_mode(vcpu) && (vcpu->arch.hflags & HF_VINTR_MASK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 4350
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "294-297",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic inline void sync_cr8_to_lapic(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (svm_nested_virtualize_tpr(vcpu))\n\t\treturn;\n\n\tif (!is_cr_intercept(svm, INTERCEPT_CR8_WRITE)) {\n\t\tint cr8 = svm->vmcb->control.int_ctl & V_TPR_MASK;\n\t\tkvm_set_cr8(vcpu, cr8);\n\t}\n}"
  },
  {
    "function_name": "svm_prepare_guest_switch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "4344-4346",
    "snippet": "static void svm_prepare_guest_switch(struct kvm_vcpu *vcpu)\n{\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\n\nstatic void svm_prepare_guest_switch(struct kvm_vcpu *vcpu)\n{\n}"
  },
  {
    "function_name": "svm_flush_tlb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "4334-4342",
    "snippet": "static void svm_flush_tlb(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (static_cpu_has(X86_FEATURE_FLUSHBYASID))\n\t\tsvm->vmcb->control.tlb_ctl = TLB_CONTROL_FLUSH_ASID;\n\telse\n\t\tsvm->asid_generation--;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "static_cpu_has",
          "args": [
            "X86_FEATURE_FLUSHBYASID"
          ],
          "line": 4338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 4336
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "294-297",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (static_cpu_has(X86_FEATURE_FLUSHBYASID))\n\t\tsvm->vmcb->control.tlb_ctl = TLB_CONTROL_FLUSH_ASID;\n\telse\n\t\tsvm->asid_generation--;\n}"
  },
  {
    "function_name": "svm_set_tss_addr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "4329-4332",
    "snippet": "static int svm_set_tss_addr(struct kvm *kvm, unsigned int addr)\n{\n\treturn 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int svm_set_tss_addr(struct kvm *kvm, unsigned int addr)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "enable_nmi_window",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "4313-4327",
    "snippet": "static void enable_nmi_window(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif ((svm->vcpu.arch.hflags & (HF_NMI_MASK | HF_IRET_MASK))\n\t    == HF_NMI_MASK)\n\t\treturn; /* IRET will cause a vm exit */\n\n\t/*\n\t * Something prevents NMI from been injected. Single step over possible\n\t * problem (IRET or exception injection or interrupt shadow)\n\t */\n\tsvm->nmi_singlestep = true;\n\tsvm->vmcb->save.rflags |= (X86_EFLAGS_TF | X86_EFLAGS_RF);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 4315
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "294-297",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic void enable_nmi_window(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif ((svm->vcpu.arch.hflags & (HF_NMI_MASK | HF_IRET_MASK))\n\t    == HF_NMI_MASK)\n\t\treturn; /* IRET will cause a vm exit */\n\n\t/*\n\t * Something prevents NMI from been injected. Single step over possible\n\t * problem (IRET or exception injection or interrupt shadow)\n\t */\n\tsvm->nmi_singlestep = true;\n\tsvm->vmcb->save.rflags |= (X86_EFLAGS_TF | X86_EFLAGS_RF);\n}"
  },
  {
    "function_name": "enable_irq_window",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "4294-4311",
    "snippet": "static void enable_irq_window(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (kvm_vcpu_apicv_active(vcpu))\n\t\treturn;\n\n\t/*\n\t * In case GIF=0 we can't rely on the CPU to tell us when GIF becomes\n\t * 1, because that's a separate STGI/VMRUN intercept.  The next time we\n\t * get that intercept, this function will be called again though and\n\t * we'll get the vintr intercept.\n\t */\n\tif (gif_set(svm) && nested_svm_intr(svm)) {\n\t\tsvm_set_vintr(svm);\n\t\tsvm_inject_irq(svm, 0x0);\n\t}\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "svm_inject_irq",
          "args": [
            "svm",
            "0x0"
          ],
          "line": 4309
        },
        "resolved": true,
        "details": {
          "function_name": "svm_inject_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "4143-4154",
          "snippet": "static inline void svm_inject_irq(struct vcpu_svm *svm, int irq)\n{\n\tstruct vmcb_control_area *control;\n\n\t/* The following fields are ignored when AVIC is enabled */\n\tcontrol = &svm->vmcb->control;\n\tcontrol->int_vector = irq;\n\tcontrol->int_ctl &= ~V_INTR_PRIO_MASK;\n\tcontrol->int_ctl |= V_IRQ_MASK |\n\t\t((/*control->int_vector >> 4*/ 0xf) << V_INTR_PRIO_SHIFT);\n\tmark_dirty(svm->vmcb, VMCB_INTR);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic inline void svm_inject_irq(struct vcpu_svm *svm, int irq)\n{\n\tstruct vmcb_control_area *control;\n\n\t/* The following fields are ignored when AVIC is enabled */\n\tcontrol = &svm->vmcb->control;\n\tcontrol->int_vector = irq;\n\tcontrol->int_ctl &= ~V_INTR_PRIO_MASK;\n\tcontrol->int_ctl |= V_IRQ_MASK |\n\t\t((/*control->int_vector >> 4*/ 0xf) << V_INTR_PRIO_SHIFT);\n\tmark_dirty(svm->vmcb, VMCB_INTR);\n}"
        }
      },
      {
        "call_info": {
          "callee": "svm_set_vintr",
          "args": [
            "svm"
          ],
          "line": 4308
        },
        "resolved": true,
        "details": {
          "function_name": "svm_set_vintr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "1599-1602",
          "snippet": "static void svm_set_vintr(struct vcpu_svm *svm)\n{\n\tset_intercept(svm, INTERCEPT_VINTR);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic void svm_set_vintr(struct vcpu_svm *svm)\n{\n\tset_intercept(svm, INTERCEPT_VINTR);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nested_svm_intr",
          "args": [
            "svm"
          ],
          "line": 4307
        },
        "resolved": true,
        "details": {
          "function_name": "nested_svm_intr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "2283-2319",
          "snippet": "static inline bool nested_svm_intr(struct vcpu_svm *svm)\n{\n\tif (!is_guest_mode(&svm->vcpu))\n\t\treturn true;\n\n\tif (!(svm->vcpu.arch.hflags & HF_VINTR_MASK))\n\t\treturn true;\n\n\tif (!(svm->vcpu.arch.hflags & HF_HIF_MASK))\n\t\treturn false;\n\n\t/*\n\t * if vmexit was already requested (by intercepted exception\n\t * for instance) do not overwrite it with \"external interrupt\"\n\t * vmexit.\n\t */\n\tif (svm->nested.exit_required)\n\t\treturn false;\n\n\tsvm->vmcb->control.exit_code   = SVM_EXIT_INTR;\n\tsvm->vmcb->control.exit_info_1 = 0;\n\tsvm->vmcb->control.exit_info_2 = 0;\n\n\tif (svm->nested.intercept & 1ULL) {\n\t\t/*\n\t\t * The #vmexit can't be emulated here directly because this\n\t\t * code path runs with irqs and preemption disabled. A\n\t\t * #vmexit emulation might sleep. Only signal request for\n\t\t * the #vmexit here.\n\t\t */\n\t\tsvm->nested.exit_required = true;\n\t\ttrace_kvm_nested_intr_vmexit(svm->vmcb->save.rip);\n\t\treturn false;\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nested = true;",
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int nested = true;\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic inline bool nested_svm_intr(struct vcpu_svm *svm)\n{\n\tif (!is_guest_mode(&svm->vcpu))\n\t\treturn true;\n\n\tif (!(svm->vcpu.arch.hflags & HF_VINTR_MASK))\n\t\treturn true;\n\n\tif (!(svm->vcpu.arch.hflags & HF_HIF_MASK))\n\t\treturn false;\n\n\t/*\n\t * if vmexit was already requested (by intercepted exception\n\t * for instance) do not overwrite it with \"external interrupt\"\n\t * vmexit.\n\t */\n\tif (svm->nested.exit_required)\n\t\treturn false;\n\n\tsvm->vmcb->control.exit_code   = SVM_EXIT_INTR;\n\tsvm->vmcb->control.exit_info_1 = 0;\n\tsvm->vmcb->control.exit_info_2 = 0;\n\n\tif (svm->nested.intercept & 1ULL) {\n\t\t/*\n\t\t * The #vmexit can't be emulated here directly because this\n\t\t * code path runs with irqs and preemption disabled. A\n\t\t * #vmexit emulation might sleep. Only signal request for\n\t\t * the #vmexit here.\n\t\t */\n\t\tsvm->nested.exit_required = true;\n\t\ttrace_kvm_nested_intr_vmexit(svm->vmcb->save.rip);\n\t\treturn false;\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gif_set",
          "args": [
            "svm"
          ],
          "line": 4307
        },
        "resolved": true,
        "details": {
          "function_name": "gif_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "448-451",
          "snippet": "static inline bool gif_set(struct vcpu_svm *svm)\n{\n\treturn !!(svm->vcpu.arch.hflags & HF_GIF_MASK);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic inline bool gif_set(struct vcpu_svm *svm)\n{\n\treturn !!(svm->vcpu.arch.hflags & HF_GIF_MASK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_apicv_active",
          "args": [
            "vcpu"
          ],
          "line": 4298
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_vcpu_apicv_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.h",
          "lines": "181-184",
          "snippet": "static inline bool kvm_vcpu_apicv_active(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.apic && vcpu->arch.apicv_active;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline bool kvm_vcpu_apicv_active(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.apic && vcpu->arch.apicv_active;\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 4296
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "294-297",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic void enable_irq_window(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (kvm_vcpu_apicv_active(vcpu))\n\t\treturn;\n\n\t/*\n\t * In case GIF=0 we can't rely on the CPU to tell us when GIF becomes\n\t * 1, because that's a separate STGI/VMRUN intercept.  The next time we\n\t * get that intercept, this function will be called again though and\n\t * we'll get the vintr intercept.\n\t */\n\tif (gif_set(svm) && nested_svm_intr(svm)) {\n\t\tsvm_set_vintr(svm);\n\t\tsvm_inject_irq(svm, 0x0);\n\t}\n}"
  },
  {
    "function_name": "svm_interrupt_allowed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "4276-4292",
    "snippet": "static int svm_interrupt_allowed(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tstruct vmcb *vmcb = svm->vmcb;\n\tint ret;\n\n\tif (!gif_set(svm) ||\n\t     (vmcb->control.int_state & SVM_INTERRUPT_SHADOW_MASK))\n\t\treturn 0;\n\n\tret = !!(kvm_get_rflags(vcpu) & X86_EFLAGS_IF);\n\n\tif (is_guest_mode(vcpu))\n\t\treturn ret && !(svm->vcpu.arch.hflags & HF_VINTR_MASK);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "is_guest_mode",
          "args": [
            "vcpu"
          ],
          "line": 4288
        },
        "resolved": true,
        "details": {
          "function_name": "is_guest_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "102-105",
          "snippet": "static inline bool is_guest_mode(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.hflags & HF_GUEST_MASK;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline bool is_guest_mode(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.hflags & HF_GUEST_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_get_rflags",
          "args": [
            "vcpu"
          ],
          "line": 4286
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_get_rflags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "8163-8171",
          "snippet": "unsigned long kvm_get_rflags(struct kvm_vcpu *vcpu)\n{\n\tunsigned long rflags;\n\n\trflags = kvm_x86_ops->get_rflags(vcpu);\n\tif (vcpu->guest_debug & KVM_GUESTDBG_SINGLESTEP)\n\t\trflags &= ~X86_EFLAGS_TF;\n\treturn rflags;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void __kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags);",
            "struct kvm_x86_ops *kvm_x86_ops"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void __kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nunsigned long kvm_get_rflags(struct kvm_vcpu *vcpu)\n{\n\tunsigned long rflags;\n\n\trflags = kvm_x86_ops->get_rflags(vcpu);\n\tif (vcpu->guest_debug & KVM_GUESTDBG_SINGLESTEP)\n\t\trflags &= ~X86_EFLAGS_TF;\n\treturn rflags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gif_set",
          "args": [
            "svm"
          ],
          "line": 4282
        },
        "resolved": true,
        "details": {
          "function_name": "gif_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "448-451",
          "snippet": "static inline bool gif_set(struct vcpu_svm *svm)\n{\n\treturn !!(svm->vcpu.arch.hflags & HF_GIF_MASK);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic inline bool gif_set(struct vcpu_svm *svm)\n{\n\treturn !!(svm->vcpu.arch.hflags & HF_GIF_MASK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 4278
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "294-297",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic int svm_interrupt_allowed(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tstruct vmcb *vmcb = svm->vmcb;\n\tint ret;\n\n\tif (!gif_set(svm) ||\n\t     (vmcb->control.int_state & SVM_INTERRUPT_SHADOW_MASK))\n\t\treturn 0;\n\n\tret = !!(kvm_get_rflags(vcpu) & X86_EFLAGS_IF);\n\n\tif (is_guest_mode(vcpu))\n\t\treturn ret && !(svm->vcpu.arch.hflags & HF_VINTR_MASK);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "svm_set_nmi_mask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "4263-4274",
    "snippet": "static void svm_set_nmi_mask(struct kvm_vcpu *vcpu, bool masked)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (masked) {\n\t\tsvm->vcpu.arch.hflags |= HF_NMI_MASK;\n\t\tset_intercept(svm, INTERCEPT_IRET);\n\t} else {\n\t\tsvm->vcpu.arch.hflags &= ~HF_NMI_MASK;\n\t\tclr_intercept(svm, INTERCEPT_IRET);\n\t}\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "clr_intercept",
          "args": [
            "svm",
            "INTERCEPT_IRET"
          ],
          "line": 4272
        },
        "resolved": true,
        "details": {
          "function_name": "clr_intercept",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "429-436",
          "snippet": "static inline void clr_intercept(struct vcpu_svm *svm, int bit)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept &= ~(1ULL << bit);\n\n\trecalc_intercepts(svm);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic inline void clr_intercept(struct vcpu_svm *svm, int bit)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept &= ~(1ULL << bit);\n\n\trecalc_intercepts(svm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_intercept",
          "args": [
            "svm",
            "INTERCEPT_IRET"
          ],
          "line": 4269
        },
        "resolved": true,
        "details": {
          "function_name": "set_intercept",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "420-427",
          "snippet": "static inline void set_intercept(struct vcpu_svm *svm, int bit)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept |= (1ULL << bit);\n\n\trecalc_intercepts(svm);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic inline void set_intercept(struct vcpu_svm *svm, int bit)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept |= (1ULL << bit);\n\n\trecalc_intercepts(svm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 4265
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "294-297",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic void svm_set_nmi_mask(struct kvm_vcpu *vcpu, bool masked)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (masked) {\n\t\tsvm->vcpu.arch.hflags |= HF_NMI_MASK;\n\t\tset_intercept(svm, INTERCEPT_IRET);\n\t} else {\n\t\tsvm->vcpu.arch.hflags &= ~HF_NMI_MASK;\n\t\tclr_intercept(svm, INTERCEPT_IRET);\n\t}\n}"
  },
  {
    "function_name": "svm_get_nmi_mask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "4256-4261",
    "snippet": "static bool svm_get_nmi_mask(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\treturn !!(svm->vcpu.arch.hflags & HF_NMI_MASK);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 4258
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "294-297",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic bool svm_get_nmi_mask(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\treturn !!(svm->vcpu.arch.hflags & HF_NMI_MASK);\n}"
  },
  {
    "function_name": "svm_nmi_allowed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "4244-4254",
    "snippet": "static int svm_nmi_allowed(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tstruct vmcb *vmcb = svm->vmcb;\n\tint ret;\n\tret = !(vmcb->control.int_state & SVM_INTERRUPT_SHADOW_MASK) &&\n\t      !(svm->vcpu.arch.hflags & HF_NMI_MASK);\n\tret = ret && gif_set(svm) && nested_svm_nmi(svm);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nested_svm_nmi",
          "args": [
            "svm"
          ],
          "line": 4251
        },
        "resolved": true,
        "details": {
          "function_name": "nested_svm_nmi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "2322-2334",
          "snippet": "static inline bool nested_svm_nmi(struct vcpu_svm *svm)\n{\n\tif (!is_guest_mode(&svm->vcpu))\n\t\treturn true;\n\n\tif (!(svm->nested.intercept & (1ULL << INTERCEPT_NMI)))\n\t\treturn true;\n\n\tsvm->vmcb->control.exit_code = SVM_EXIT_NMI;\n\tsvm->nested.exit_required = true;\n\n\treturn false;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nested = true;",
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int nested = true;\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic inline bool nested_svm_nmi(struct vcpu_svm *svm)\n{\n\tif (!is_guest_mode(&svm->vcpu))\n\t\treturn true;\n\n\tif (!(svm->nested.intercept & (1ULL << INTERCEPT_NMI)))\n\t\treturn true;\n\n\tsvm->vmcb->control.exit_code = SVM_EXIT_NMI;\n\tsvm->nested.exit_required = true;\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gif_set",
          "args": [
            "svm"
          ],
          "line": 4251
        },
        "resolved": true,
        "details": {
          "function_name": "gif_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "448-451",
          "snippet": "static inline bool gif_set(struct vcpu_svm *svm)\n{\n\treturn !!(svm->vcpu.arch.hflags & HF_GIF_MASK);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic inline bool gif_set(struct vcpu_svm *svm)\n{\n\treturn !!(svm->vcpu.arch.hflags & HF_GIF_MASK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 4246
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "294-297",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic int svm_nmi_allowed(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tstruct vmcb *vmcb = svm->vmcb;\n\tint ret;\n\tret = !(vmcb->control.int_state & SVM_INTERRUPT_SHADOW_MASK) &&\n\t      !(svm->vcpu.arch.hflags & HF_NMI_MASK);\n\tret = ret && gif_set(svm) && nested_svm_nmi(svm);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "svm_deliver_avic_intr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "4232-4242",
    "snippet": "static void svm_deliver_avic_intr(struct kvm_vcpu *vcpu, int vec)\n{\n\tkvm_lapic_set_irr(vec, vcpu->arch.apic);\n\tsmp_mb__after_atomic();\n\n\tif (avic_vcpu_is_running(vcpu))\n\t\twrmsrl(SVM_AVIC_DOORBELL,\n\t\t       __default_cpu_present_to_apicid(vcpu->cpu));\n\telse\n\t\tkvm_vcpu_wake_up(vcpu);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define SVM_AVIC_DOORBELL\t0xc001011b"
    ],
    "globals_used": [
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_vcpu_wake_up",
          "args": [
            "vcpu"
          ],
          "line": 4241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wrmsrl",
          "args": [
            "SVM_AVIC_DOORBELL",
            "__default_cpu_present_to_apicid(vcpu->cpu)"
          ],
          "line": 4238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__default_cpu_present_to_apicid",
          "args": [
            "vcpu->cpu"
          ],
          "line": 4239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "avic_vcpu_is_running",
          "args": [
            "vcpu"
          ],
          "line": 4237
        },
        "resolved": true,
        "details": {
          "function_name": "avic_vcpu_is_running",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "305-314",
          "snippet": "static inline bool avic_vcpu_is_running(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tu64 *entry = svm->avic_physical_id_cache;\n\n\tif (!entry)\n\t\treturn false;\n\n\treturn (READ_ONCE(*entry) & AVIC_PHYSICAL_ID_ENTRY_IS_RUNNING_MASK);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define AVIC_PHYSICAL_ID_ENTRY_IS_RUNNING_MASK\t\t(1ULL << 62)"
          ],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define AVIC_PHYSICAL_ID_ENTRY_IS_RUNNING_MASK\t\t(1ULL << 62)\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic inline bool avic_vcpu_is_running(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tu64 *entry = svm->avic_physical_id_cache;\n\n\tif (!entry)\n\t\treturn false;\n\n\treturn (READ_ONCE(*entry) & AVIC_PHYSICAL_ID_ENTRY_IS_RUNNING_MASK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_mb__after_atomic",
          "args": [],
          "line": 4235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_lapic_set_irr",
          "args": [
            "vec",
            "vcpu->arch.apic"
          ],
          "line": 4234
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_set_irr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.h",
          "lines": "119-127",
          "snippet": "static inline void kvm_lapic_set_irr(int vec, struct kvm_lapic *apic)\n{\n\tkvm_lapic_set_vector(vec, apic->regs + APIC_IRR);\n\t/*\n\t * irr_pending must be true if any interrupt is pending; set it after\n\t * APIC_IRR to avoid race with apic_clear_irr\n\t */\n\tapic->irr_pending = true;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline void kvm_lapic_set_irr(int vec, struct kvm_lapic *apic)\n{\n\tkvm_lapic_set_vector(vec, apic->regs + APIC_IRR);\n\t/*\n\t * irr_pending must be true if any interrupt is pending; set it after\n\t * APIC_IRR to avoid race with apic_clear_irr\n\t */\n\tapic->irr_pending = true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define SVM_AVIC_DOORBELL\t0xc001011b\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\n\nstatic void svm_deliver_avic_intr(struct kvm_vcpu *vcpu, int vec)\n{\n\tkvm_lapic_set_irr(vec, vcpu->arch.apic);\n\tsmp_mb__after_atomic();\n\n\tif (avic_vcpu_is_running(vcpu))\n\t\twrmsrl(SVM_AVIC_DOORBELL,\n\t\t       __default_cpu_present_to_apicid(vcpu->cpu));\n\telse\n\t\tkvm_vcpu_wake_up(vcpu);\n}"
  },
  {
    "function_name": "svm_sync_pir_to_irr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "4227-4230",
    "snippet": "static void svm_sync_pir_to_irr(struct kvm_vcpu *vcpu)\n{\n\treturn;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\n\nstatic void svm_sync_pir_to_irr(struct kvm_vcpu *vcpu)\n{\n\treturn;\n}"
  },
  {
    "function_name": "svm_load_eoi_exitmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "4222-4225",
    "snippet": "static void svm_load_eoi_exitmap(struct kvm_vcpu *vcpu, u64 *eoi_exit_bitmap)\n{\n\treturn;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\n\nstatic void svm_load_eoi_exitmap(struct kvm_vcpu *vcpu, u64 *eoi_exit_bitmap)\n{\n\treturn;\n}"
  },
  {
    "function_name": "svm_refresh_apicv_exec_ctrl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "4210-4220",
    "snippet": "static void svm_refresh_apicv_exec_ctrl(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tstruct vmcb *vmcb = svm->vmcb;\n\n\tif (!avic)\n\t\treturn;\n\n\tvmcb->control.int_ctl &= ~AVIC_ENABLE_MASK;\n\tmark_dirty(vmcb, VMCB_INTR);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int avic;",
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_dirty",
          "args": [
            "vmcb",
            "VMCB_INTR"
          ],
          "line": 4219
        },
        "resolved": true,
        "details": {
          "function_name": "mark_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "289-292",
          "snippet": "static inline void mark_dirty(struct vmcb *vmcb, int bit)\n{\n\tvmcb->control.clean &= ~(1 << bit);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic inline void mark_dirty(struct vmcb *vmcb, int bit)\n{\n\tvmcb->control.clean &= ~(1 << bit);\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 4212
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "294-297",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int avic;\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic void svm_refresh_apicv_exec_ctrl(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tstruct vmcb *vmcb = svm->vmcb;\n\n\tif (!avic)\n\t\treturn;\n\n\tvmcb->control.int_ctl &= ~AVIC_ENABLE_MASK;\n\tmark_dirty(vmcb, VMCB_INTR);\n}"
  },
  {
    "function_name": "svm_hwapic_isr_update",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "4205-4207",
    "snippet": "static void svm_hwapic_isr_update(struct kvm_vcpu *vcpu, int max_isr)\n{\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\n\nstatic void svm_hwapic_isr_update(struct kvm_vcpu *vcpu, int max_isr)\n{\n}"
  },
  {
    "function_name": "svm_hwapic_irr_update",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "4201-4203",
    "snippet": "static void svm_hwapic_irr_update(struct kvm_vcpu *vcpu, int max_irr)\n{\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\n\nstatic void svm_hwapic_irr_update(struct kvm_vcpu *vcpu, int max_irr)\n{\n}"
  },
  {
    "function_name": "svm_get_enable_apicv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "4196-4199",
    "snippet": "static bool svm_get_enable_apicv(void)\n{\n\treturn avic;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int avic;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int avic;\n\nstatic bool svm_get_enable_apicv(void)\n{\n\treturn avic;\n}"
  },
  {
    "function_name": "svm_set_virtual_x2apic_mode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "4191-4194",
    "snippet": "static void svm_set_virtual_x2apic_mode(struct kvm_vcpu *vcpu, bool set)\n{\n\treturn;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\n\nstatic void svm_set_virtual_x2apic_mode(struct kvm_vcpu *vcpu, bool set)\n{\n\treturn;\n}"
  },
  {
    "function_name": "update_cr8_intercept",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "4174-4189",
    "snippet": "static void update_cr8_intercept(struct kvm_vcpu *vcpu, int tpr, int irr)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (svm_nested_virtualize_tpr(vcpu) ||\n\t    kvm_vcpu_apicv_active(vcpu))\n\t\treturn;\n\n\tclr_cr_intercept(svm, INTERCEPT_CR8_WRITE);\n\n\tif (irr == -1)\n\t\treturn;\n\n\tif (tpr >= irr)\n\t\tset_cr_intercept(svm, INTERCEPT_CR8_WRITE);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_cr_intercept",
          "args": [
            "svm",
            "INTERCEPT_CR8_WRITE"
          ],
          "line": 4188
        },
        "resolved": true,
        "details": {
          "function_name": "set_cr_intercept",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "344-351",
          "snippet": "static inline void set_cr_intercept(struct vcpu_svm *svm, int bit)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept_cr |= (1U << bit);\n\n\trecalc_intercepts(svm);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic inline void set_cr_intercept(struct vcpu_svm *svm, int bit)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept_cr |= (1U << bit);\n\n\trecalc_intercepts(svm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clr_cr_intercept",
          "args": [
            "svm",
            "INTERCEPT_CR8_WRITE"
          ],
          "line": 4182
        },
        "resolved": true,
        "details": {
          "function_name": "clr_cr_intercept",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "353-360",
          "snippet": "static inline void clr_cr_intercept(struct vcpu_svm *svm, int bit)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept_cr &= ~(1U << bit);\n\n\trecalc_intercepts(svm);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic inline void clr_cr_intercept(struct vcpu_svm *svm, int bit)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept_cr &= ~(1U << bit);\n\n\trecalc_intercepts(svm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_apicv_active",
          "args": [
            "vcpu"
          ],
          "line": 4179
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_vcpu_apicv_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.h",
          "lines": "181-184",
          "snippet": "static inline bool kvm_vcpu_apicv_active(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.apic && vcpu->arch.apicv_active;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline bool kvm_vcpu_apicv_active(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.apic && vcpu->arch.apicv_active;\n}"
        }
      },
      {
        "call_info": {
          "callee": "svm_nested_virtualize_tpr",
          "args": [
            "vcpu"
          ],
          "line": 4178
        },
        "resolved": true,
        "details": {
          "function_name": "svm_nested_virtualize_tpr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "4169-4172",
          "snippet": "static inline bool svm_nested_virtualize_tpr(struct kvm_vcpu *vcpu)\n{\n\treturn is_guest_mode(vcpu) && (vcpu->arch.hflags & HF_VINTR_MASK);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\n\nstatic inline bool svm_nested_virtualize_tpr(struct kvm_vcpu *vcpu)\n{\n\treturn is_guest_mode(vcpu) && (vcpu->arch.hflags & HF_VINTR_MASK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 4176
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "294-297",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu, int tpr, int irr)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (svm_nested_virtualize_tpr(vcpu) ||\n\t    kvm_vcpu_apicv_active(vcpu))\n\t\treturn;\n\n\tclr_cr_intercept(svm, INTERCEPT_CR8_WRITE);\n\n\tif (irr == -1)\n\t\treturn;\n\n\tif (tpr >= irr)\n\t\tset_cr_intercept(svm, INTERCEPT_CR8_WRITE);\n}"
  },
  {
    "function_name": "svm_nested_virtualize_tpr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "4169-4172",
    "snippet": "static inline bool svm_nested_virtualize_tpr(struct kvm_vcpu *vcpu)\n{\n\treturn is_guest_mode(vcpu) && (vcpu->arch.hflags & HF_VINTR_MASK);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "is_guest_mode",
          "args": [
            "vcpu"
          ],
          "line": 4171
        },
        "resolved": true,
        "details": {
          "function_name": "is_guest_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "102-105",
          "snippet": "static inline bool is_guest_mode(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.hflags & HF_GUEST_MASK;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline bool is_guest_mode(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.hflags & HF_GUEST_MASK;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\n\nstatic inline bool svm_nested_virtualize_tpr(struct kvm_vcpu *vcpu)\n{\n\treturn is_guest_mode(vcpu) && (vcpu->arch.hflags & HF_VINTR_MASK);\n}"
  },
  {
    "function_name": "svm_set_irq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "4156-4167",
    "snippet": "static void svm_set_irq(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tBUG_ON(!(gif_set(svm)));\n\n\ttrace_kvm_inj_virq(vcpu->arch.interrupt.nr);\n\t++vcpu->stat.irq_injections;\n\n\tsvm->vmcb->control.event_inj = vcpu->arch.interrupt.nr |\n\t\tSVM_EVTINJ_VALID | SVM_EVTINJ_TYPE_INTR;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_kvm_inj_virq",
          "args": [
            "vcpu->arch.interrupt.nr"
          ],
          "line": 4162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!(gif_set(svm))"
          ],
          "line": 4160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gif_set",
          "args": [
            "svm"
          ],
          "line": 4160
        },
        "resolved": true,
        "details": {
          "function_name": "gif_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "448-451",
          "snippet": "static inline bool gif_set(struct vcpu_svm *svm)\n{\n\treturn !!(svm->vcpu.arch.hflags & HF_GIF_MASK);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic inline bool gif_set(struct vcpu_svm *svm)\n{\n\treturn !!(svm->vcpu.arch.hflags & HF_GIF_MASK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 4158
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "294-297",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic void svm_set_irq(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tBUG_ON(!(gif_set(svm)));\n\n\ttrace_kvm_inj_virq(vcpu->arch.interrupt.nr);\n\t++vcpu->stat.irq_injections;\n\n\tsvm->vmcb->control.event_inj = vcpu->arch.interrupt.nr |\n\t\tSVM_EVTINJ_VALID | SVM_EVTINJ_TYPE_INTR;\n}"
  },
  {
    "function_name": "svm_inject_irq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "4143-4154",
    "snippet": "static inline void svm_inject_irq(struct vcpu_svm *svm, int irq)\n{\n\tstruct vmcb_control_area *control;\n\n\t/* The following fields are ignored when AVIC is enabled */\n\tcontrol = &svm->vmcb->control;\n\tcontrol->int_vector = irq;\n\tcontrol->int_ctl &= ~V_INTR_PRIO_MASK;\n\tcontrol->int_ctl |= V_IRQ_MASK |\n\t\t((/*control->int_vector >> 4*/ 0xf) << V_INTR_PRIO_SHIFT);\n\tmark_dirty(svm->vmcb, VMCB_INTR);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_dirty",
          "args": [
            "svm->vmcb",
            "VMCB_INTR"
          ],
          "line": 4153
        },
        "resolved": true,
        "details": {
          "function_name": "mark_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "289-292",
          "snippet": "static inline void mark_dirty(struct vmcb *vmcb, int bit)\n{\n\tvmcb->control.clean &= ~(1 << bit);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic inline void mark_dirty(struct vmcb *vmcb, int bit)\n{\n\tvmcb->control.clean &= ~(1 << bit);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic inline void svm_inject_irq(struct vcpu_svm *svm, int irq)\n{\n\tstruct vmcb_control_area *control;\n\n\t/* The following fields are ignored when AVIC is enabled */\n\tcontrol = &svm->vmcb->control;\n\tcontrol->int_vector = irq;\n\tcontrol->int_ctl &= ~V_INTR_PRIO_MASK;\n\tcontrol->int_ctl |= V_IRQ_MASK |\n\t\t((/*control->int_vector >> 4*/ 0xf) << V_INTR_PRIO_SHIFT);\n\tmark_dirty(svm->vmcb, VMCB_INTR);\n}"
  },
  {
    "function_name": "svm_inject_nmi",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "4133-4141",
    "snippet": "static void svm_inject_nmi(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tsvm->vmcb->control.event_inj = SVM_EVTINJ_VALID | SVM_EVTINJ_TYPE_NMI;\n\tvcpu->arch.hflags |= HF_NMI_MASK;\n\tset_intercept(svm, INTERCEPT_IRET);\n\t++vcpu->stat.nmi_injections;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_intercept",
          "args": [
            "svm",
            "INTERCEPT_IRET"
          ],
          "line": 4139
        },
        "resolved": true,
        "details": {
          "function_name": "set_intercept",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "420-427",
          "snippet": "static inline void set_intercept(struct vcpu_svm *svm, int bit)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept |= (1ULL << bit);\n\n\trecalc_intercepts(svm);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic inline void set_intercept(struct vcpu_svm *svm, int bit)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept |= (1ULL << bit);\n\n\trecalc_intercepts(svm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 4135
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "294-297",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic void svm_inject_nmi(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tsvm->vmcb->control.event_inj = SVM_EVTINJ_VALID | SVM_EVTINJ_TYPE_NMI;\n\tvcpu->arch.hflags |= HF_NMI_MASK;\n\tset_intercept(svm, INTERCEPT_IRET);\n\t++vcpu->stat.nmi_injections;\n}"
  },
  {
    "function_name": "pre_svm_run",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "4122-4131",
    "snippet": "static void pre_svm_run(struct vcpu_svm *svm)\n{\n\tint cpu = raw_smp_processor_id();\n\n\tstruct svm_cpu_data *sd = per_cpu(svm_data, cpu);\n\n\t/* FIXME: handle wraparound of asid_generation */\n\tif (svm->asid_generation != sd->asid_generation)\n\t\tnew_asid(svm, sd);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);",
      "static DEFINE_PER_CPU(struct svm_cpu_data *, svm_data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "new_asid",
          "args": [
            "svm",
            "sd"
          ],
          "line": 4130
        },
        "resolved": true,
        "details": {
          "function_name": "new_asid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "1880-1892",
          "snippet": "static void new_asid(struct vcpu_svm *svm, struct svm_cpu_data *sd)\n{\n\tif (sd->next_asid > sd->max_asid) {\n\t\t++sd->asid_generation;\n\t\tsd->next_asid = 1;\n\t\tsvm->vmcb->control.tlb_ctl = TLB_CONTROL_FLUSH_ALL_ASID;\n\t}\n\n\tsvm->asid_generation = sd->asid_generation;\n\tsvm->vmcb->control.asid = sd->next_asid++;\n\n\tmark_dirty(svm->vmcb, VMCB_ASID);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic void new_asid(struct vcpu_svm *svm, struct svm_cpu_data *sd)\n{\n\tif (sd->next_asid > sd->max_asid) {\n\t\t++sd->asid_generation;\n\t\tsd->next_asid = 1;\n\t\tsvm->vmcb->control.tlb_ctl = TLB_CONTROL_FLUSH_ALL_ASID;\n\t}\n\n\tsvm->asid_generation = sd->asid_generation;\n\tsvm->vmcb->control.asid = sd->next_asid++;\n\n\tmark_dirty(svm->vmcb, VMCB_ASID);\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "svm_data",
            "cpu"
          ],
          "line": 4126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 4124
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\nstatic DEFINE_PER_CPU(struct svm_cpu_data *, svm_data);\n\nstatic void pre_svm_run(struct vcpu_svm *svm)\n{\n\tint cpu = raw_smp_processor_id();\n\n\tstruct svm_cpu_data *sd = per_cpu(svm_data, cpu);\n\n\t/* FIXME: handle wraparound of asid_generation */\n\tif (svm->asid_generation != sd->asid_generation)\n\t\tnew_asid(svm, sd);\n}"
  },
  {
    "function_name": "reload_tss",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "4113-4120",
    "snippet": "static void reload_tss(struct kvm_vcpu *vcpu)\n{\n\tint cpu = raw_smp_processor_id();\n\n\tstruct svm_cpu_data *sd = per_cpu(svm_data, cpu);\n\tsd->tss_desc->type = 9; /* available 32/64-bit TSS */\n\tload_TR_desc();\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
      "static DEFINE_PER_CPU(struct svm_cpu_data *, svm_data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "load_TR_desc",
          "args": [],
          "line": 4119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "svm_data",
            "cpu"
          ],
          "line": 4117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 4115
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic DEFINE_PER_CPU(struct svm_cpu_data *, svm_data);\n\nstatic void reload_tss(struct kvm_vcpu *vcpu)\n{\n\tint cpu = raw_smp_processor_id();\n\n\tstruct svm_cpu_data *sd = per_cpu(svm_data, cpu);\n\tsd->tss_desc->type = 9; /* available 32/64-bit TSS */\n\tload_TR_desc();\n}"
  },
  {
    "function_name": "handle_exit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "4044-4111",
    "snippet": "static int handle_exit(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tstruct kvm_run *kvm_run = vcpu->run;\n\tu32 exit_code = svm->vmcb->control.exit_code;\n\n\ttrace_kvm_exit(exit_code, vcpu, KVM_ISA_SVM);\n\n\tif (!is_cr_intercept(svm, INTERCEPT_CR0_WRITE))\n\t\tvcpu->arch.cr0 = svm->vmcb->save.cr0;\n\tif (npt_enabled)\n\t\tvcpu->arch.cr3 = svm->vmcb->save.cr3;\n\n\tif (unlikely(svm->nested.exit_required)) {\n\t\tnested_svm_vmexit(svm);\n\t\tsvm->nested.exit_required = false;\n\n\t\treturn 1;\n\t}\n\n\tif (is_guest_mode(vcpu)) {\n\t\tint vmexit;\n\n\t\ttrace_kvm_nested_vmexit(svm->vmcb->save.rip, exit_code,\n\t\t\t\t\tsvm->vmcb->control.exit_info_1,\n\t\t\t\t\tsvm->vmcb->control.exit_info_2,\n\t\t\t\t\tsvm->vmcb->control.exit_int_info,\n\t\t\t\t\tsvm->vmcb->control.exit_int_info_err,\n\t\t\t\t\tKVM_ISA_SVM);\n\n\t\tvmexit = nested_svm_exit_special(svm);\n\n\t\tif (vmexit == NESTED_EXIT_CONTINUE)\n\t\t\tvmexit = nested_svm_exit_handled(svm);\n\n\t\tif (vmexit == NESTED_EXIT_DONE)\n\t\t\treturn 1;\n\t}\n\n\tsvm_complete_interrupts(svm);\n\n\tif (svm->vmcb->control.exit_code == SVM_EXIT_ERR) {\n\t\tkvm_run->exit_reason = KVM_EXIT_FAIL_ENTRY;\n\t\tkvm_run->fail_entry.hardware_entry_failure_reason\n\t\t\t= svm->vmcb->control.exit_code;\n\t\tpr_err(\"KVM: FAILED VMRUN WITH VMCB:\\n\");\n\t\tdump_vmcb(vcpu);\n\t\treturn 0;\n\t}\n\n\tif (is_external_interrupt(svm->vmcb->control.exit_int_info) &&\n\t    exit_code != SVM_EXIT_EXCP_BASE + PF_VECTOR &&\n\t    exit_code != SVM_EXIT_NPF && exit_code != SVM_EXIT_TASK_SWITCH &&\n\t    exit_code != SVM_EXIT_INTR && exit_code != SVM_EXIT_NMI)\n\t\tprintk(KERN_ERR \"%s: unexpected exit_int_info 0x%x \"\n\t\t       \"exit_code 0x%x\\n\",\n\t\t       __func__, svm->vmcb->control.exit_int_info,\n\t\t       exit_code);\n\n\tif (exit_code >= ARRAY_SIZE(svm_exit_handlers)\n\t    || !svm_exit_handlers[exit_code]) {\n\t\tWARN_ONCE(1, \"svm: unexpected exit reason 0x%x\\n\", exit_code);\n\t\tkvm_queue_exception(vcpu, UD_VECTOR);\n\t\treturn 1;\n\t}\n\n\treturn svm_exit_handlers[exit_code](svm);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define NESTED_EXIT_CONTINUE\t2\t/* Further checks needed      */",
      "#define NESTED_EXIT_DONE\t1\t/* Exit caused nested vmexit  */"
    ],
    "globals_used": [
      "static int nested = true;",
      "static void svm_set_cr0(struct kvm_vcpu *vcpu, unsigned long cr0);",
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);",
      "static int (*const svm_exit_handlers[])(struct vcpu_svm *svm) = {\n\t[SVM_EXIT_READ_CR0]\t\t\t= cr_interception,\n\t[SVM_EXIT_READ_CR3]\t\t\t= cr_interception,\n\t[SVM_EXIT_READ_CR4]\t\t\t= cr_interception,\n\t[SVM_EXIT_READ_CR8]\t\t\t= cr_interception,\n\t[SVM_EXIT_CR0_SEL_WRITE]\t\t= cr_interception,\n\t[SVM_EXIT_WRITE_CR0]\t\t\t= cr_interception,\n\t[SVM_EXIT_WRITE_CR3]\t\t\t= cr_interception,\n\t[SVM_EXIT_WRITE_CR4]\t\t\t= cr_interception,\n\t[SVM_EXIT_WRITE_CR8]\t\t\t= cr8_write_interception,\n\t[SVM_EXIT_READ_DR0]\t\t\t= dr_interception,\n\t[SVM_EXIT_READ_DR1]\t\t\t= dr_interception,\n\t[SVM_EXIT_READ_DR2]\t\t\t= dr_interception,\n\t[SVM_EXIT_READ_DR3]\t\t\t= dr_interception,\n\t[SVM_EXIT_READ_DR4]\t\t\t= dr_interception,\n\t[SVM_EXIT_READ_DR5]\t\t\t= dr_interception,\n\t[SVM_EXIT_READ_DR6]\t\t\t= dr_interception,\n\t[SVM_EXIT_READ_DR7]\t\t\t= dr_interception,\n\t[SVM_EXIT_WRITE_DR0]\t\t\t= dr_interception,\n\t[SVM_EXIT_WRITE_DR1]\t\t\t= dr_interception,\n\t[SVM_EXIT_WRITE_DR2]\t\t\t= dr_interception,\n\t[SVM_EXIT_WRITE_DR3]\t\t\t= dr_interception,\n\t[SVM_EXIT_WRITE_DR4]\t\t\t= dr_interception,\n\t[SVM_EXIT_WRITE_DR5]\t\t\t= dr_interception,\n\t[SVM_EXIT_WRITE_DR6]\t\t\t= dr_interception,\n\t[SVM_EXIT_WRITE_DR7]\t\t\t= dr_interception,\n\t[SVM_EXIT_EXCP_BASE + DB_VECTOR]\t= db_interception,\n\t[SVM_EXIT_EXCP_BASE + BP_VECTOR]\t= bp_interception,\n\t[SVM_EXIT_EXCP_BASE + UD_VECTOR]\t= ud_interception,\n\t[SVM_EXIT_EXCP_BASE + PF_VECTOR]\t= pf_interception,\n\t[SVM_EXIT_EXCP_BASE + NM_VECTOR]\t= nm_interception,\n\t[SVM_EXIT_EXCP_BASE + MC_VECTOR]\t= mc_interception,\n\t[SVM_EXIT_EXCP_BASE + AC_VECTOR]\t= ac_interception,\n\t[SVM_EXIT_INTR]\t\t\t\t= intr_interception,\n\t[SVM_EXIT_NMI]\t\t\t\t= nmi_interception,\n\t[SVM_EXIT_SMI]\t\t\t\t= nop_on_interception,\n\t[SVM_EXIT_INIT]\t\t\t\t= nop_on_interception,\n\t[SVM_EXIT_VINTR]\t\t\t= interrupt_window_interception,\n\t[SVM_EXIT_RDPMC]\t\t\t= rdpmc_interception,\n\t[SVM_EXIT_CPUID]\t\t\t= cpuid_interception,\n\t[SVM_EXIT_IRET]                         = iret_interception,\n\t[SVM_EXIT_INVD]                         = emulate_on_interception,\n\t[SVM_EXIT_PAUSE]\t\t\t= pause_interception,\n\t[SVM_EXIT_HLT]\t\t\t\t= halt_interception,\n\t[SVM_EXIT_INVLPG]\t\t\t= invlpg_interception,\n\t[SVM_EXIT_INVLPGA]\t\t\t= invlpga_interception,\n\t[SVM_EXIT_IOIO]\t\t\t\t= io_interception,\n\t[SVM_EXIT_MSR]\t\t\t\t= msr_interception,\n\t[SVM_EXIT_TASK_SWITCH]\t\t\t= task_switch_interception,\n\t[SVM_EXIT_SHUTDOWN]\t\t\t= shutdown_interception,\n\t[SVM_EXIT_VMRUN]\t\t\t= vmrun_interception,\n\t[SVM_EXIT_VMMCALL]\t\t\t= vmmcall_interception,\n\t[SVM_EXIT_VMLOAD]\t\t\t= vmload_interception,\n\t[SVM_EXIT_VMSAVE]\t\t\t= vmsave_interception,\n\t[SVM_EXIT_STGI]\t\t\t\t= stgi_interception,\n\t[SVM_EXIT_CLGI]\t\t\t\t= clgi_interception,\n\t[SVM_EXIT_SKINIT]\t\t\t= skinit_interception,\n\t[SVM_EXIT_WBINVD]                       = wbinvd_interception,\n\t[SVM_EXIT_MONITOR]\t\t\t= monitor_interception,\n\t[SVM_EXIT_MWAIT]\t\t\t= mwait_interception,\n\t[SVM_EXIT_XSETBV]\t\t\t= xsetbv_interception,\n\t[SVM_EXIT_NPF]\t\t\t\t= pf_interception,\n\t[SVM_EXIT_RSM]                          = emulate_on_interception,\n\t[SVM_EXIT_AVIC_INCOMPLETE_IPI]\t\t= avic_incomplete_ipi_interception,\n\t[SVM_EXIT_AVIC_UNACCELERATED_ACCESS]\t= avic_unaccelerated_access_interception,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "svm_exit_handlers[exit_code]",
          "args": [
            "svm"
          ],
          "line": 4110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_queue_exception",
          "args": [
            "vcpu",
            "UD_VECTOR"
          ],
          "line": 4106
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_queue_exception",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "409-412",
          "snippet": "void kvm_queue_exception(struct kvm_vcpu *vcpu, unsigned nr)\n{\n\tkvm_multiple_exception(vcpu, nr, false, 0, false);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nvoid kvm_queue_exception(struct kvm_vcpu *vcpu, unsigned nr)\n{\n\tkvm_multiple_exception(vcpu, nr, false, 0, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ONCE",
          "args": [
            "1",
            "\"svm: unexpected exit reason 0x%x\\n\"",
            "exit_code"
          ],
          "line": 4105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "svm_exit_handlers"
          ],
          "line": 4103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"%s: unexpected exit_int_info 0x%x \"\n\t\t       \"exit_code 0x%x\\n\"",
            "__func__",
            "svm->vmcb->control.exit_int_info",
            "exit_code"
          ],
          "line": 4098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_external_interrupt",
          "args": [
            "svm->vmcb->control.exit_int_info"
          ],
          "line": 4094
        },
        "resolved": true,
        "details": {
          "function_name": "is_external_interrupt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "545-549",
          "snippet": "static int is_external_interrupt(u32 info)\n{\n\tinfo &= SVM_EVTINJ_TYPE_MASK | SVM_EVTINJ_VALID;\n\treturn info == (SVM_EVTINJ_VALID | SVM_EVTINJ_TYPE_INTR);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int is_external_interrupt(u32 info)\n{\n\tinfo &= SVM_EVTINJ_TYPE_MASK | SVM_EVTINJ_VALID;\n\treturn info == (SVM_EVTINJ_VALID | SVM_EVTINJ_TYPE_INTR);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dump_vmcb",
          "args": [
            "vcpu"
          ],
          "line": 4090
        },
        "resolved": true,
        "details": {
          "function_name": "dump_vmcb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "3927-4034",
          "snippet": "static void dump_vmcb(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tstruct vmcb_control_area *control = &svm->vmcb->control;\n\tstruct vmcb_save_area *save = &svm->vmcb->save;\n\n\tpr_err(\"VMCB Control Area:\\n\");\n\tpr_err(\"%-20s%04x\\n\", \"cr_read:\", control->intercept_cr & 0xffff);\n\tpr_err(\"%-20s%04x\\n\", \"cr_write:\", control->intercept_cr >> 16);\n\tpr_err(\"%-20s%04x\\n\", \"dr_read:\", control->intercept_dr & 0xffff);\n\tpr_err(\"%-20s%04x\\n\", \"dr_write:\", control->intercept_dr >> 16);\n\tpr_err(\"%-20s%08x\\n\", \"exceptions:\", control->intercept_exceptions);\n\tpr_err(\"%-20s%016llx\\n\", \"intercepts:\", control->intercept);\n\tpr_err(\"%-20s%d\\n\", \"pause filter count:\", control->pause_filter_count);\n\tpr_err(\"%-20s%016llx\\n\", \"iopm_base_pa:\", control->iopm_base_pa);\n\tpr_err(\"%-20s%016llx\\n\", \"msrpm_base_pa:\", control->msrpm_base_pa);\n\tpr_err(\"%-20s%016llx\\n\", \"tsc_offset:\", control->tsc_offset);\n\tpr_err(\"%-20s%d\\n\", \"asid:\", control->asid);\n\tpr_err(\"%-20s%d\\n\", \"tlb_ctl:\", control->tlb_ctl);\n\tpr_err(\"%-20s%08x\\n\", \"int_ctl:\", control->int_ctl);\n\tpr_err(\"%-20s%08x\\n\", \"int_vector:\", control->int_vector);\n\tpr_err(\"%-20s%08x\\n\", \"int_state:\", control->int_state);\n\tpr_err(\"%-20s%08x\\n\", \"exit_code:\", control->exit_code);\n\tpr_err(\"%-20s%016llx\\n\", \"exit_info1:\", control->exit_info_1);\n\tpr_err(\"%-20s%016llx\\n\", \"exit_info2:\", control->exit_info_2);\n\tpr_err(\"%-20s%08x\\n\", \"exit_int_info:\", control->exit_int_info);\n\tpr_err(\"%-20s%08x\\n\", \"exit_int_info_err:\", control->exit_int_info_err);\n\tpr_err(\"%-20s%lld\\n\", \"nested_ctl:\", control->nested_ctl);\n\tpr_err(\"%-20s%016llx\\n\", \"nested_cr3:\", control->nested_cr3);\n\tpr_err(\"%-20s%016llx\\n\", \"avic_vapic_bar:\", control->avic_vapic_bar);\n\tpr_err(\"%-20s%08x\\n\", \"event_inj:\", control->event_inj);\n\tpr_err(\"%-20s%08x\\n\", \"event_inj_err:\", control->event_inj_err);\n\tpr_err(\"%-20s%lld\\n\", \"lbr_ctl:\", control->lbr_ctl);\n\tpr_err(\"%-20s%016llx\\n\", \"next_rip:\", control->next_rip);\n\tpr_err(\"%-20s%016llx\\n\", \"avic_backing_page:\", control->avic_backing_page);\n\tpr_err(\"%-20s%016llx\\n\", \"avic_logical_id:\", control->avic_logical_id);\n\tpr_err(\"%-20s%016llx\\n\", \"avic_physical_id:\", control->avic_physical_id);\n\tpr_err(\"VMCB State Save Area:\\n\");\n\tpr_err(\"%-5s s: %04x a: %04x l: %08x b: %016llx\\n\",\n\t       \"es:\",\n\t       save->es.selector, save->es.attrib,\n\t       save->es.limit, save->es.base);\n\tpr_err(\"%-5s s: %04x a: %04x l: %08x b: %016llx\\n\",\n\t       \"cs:\",\n\t       save->cs.selector, save->cs.attrib,\n\t       save->cs.limit, save->cs.base);\n\tpr_err(\"%-5s s: %04x a: %04x l: %08x b: %016llx\\n\",\n\t       \"ss:\",\n\t       save->ss.selector, save->ss.attrib,\n\t       save->ss.limit, save->ss.base);\n\tpr_err(\"%-5s s: %04x a: %04x l: %08x b: %016llx\\n\",\n\t       \"ds:\",\n\t       save->ds.selector, save->ds.attrib,\n\t       save->ds.limit, save->ds.base);\n\tpr_err(\"%-5s s: %04x a: %04x l: %08x b: %016llx\\n\",\n\t       \"fs:\",\n\t       save->fs.selector, save->fs.attrib,\n\t       save->fs.limit, save->fs.base);\n\tpr_err(\"%-5s s: %04x a: %04x l: %08x b: %016llx\\n\",\n\t       \"gs:\",\n\t       save->gs.selector, save->gs.attrib,\n\t       save->gs.limit, save->gs.base);\n\tpr_err(\"%-5s s: %04x a: %04x l: %08x b: %016llx\\n\",\n\t       \"gdtr:\",\n\t       save->gdtr.selector, save->gdtr.attrib,\n\t       save->gdtr.limit, save->gdtr.base);\n\tpr_err(\"%-5s s: %04x a: %04x l: %08x b: %016llx\\n\",\n\t       \"ldtr:\",\n\t       save->ldtr.selector, save->ldtr.attrib,\n\t       save->ldtr.limit, save->ldtr.base);\n\tpr_err(\"%-5s s: %04x a: %04x l: %08x b: %016llx\\n\",\n\t       \"idtr:\",\n\t       save->idtr.selector, save->idtr.attrib,\n\t       save->idtr.limit, save->idtr.base);\n\tpr_err(\"%-5s s: %04x a: %04x l: %08x b: %016llx\\n\",\n\t       \"tr:\",\n\t       save->tr.selector, save->tr.attrib,\n\t       save->tr.limit, save->tr.base);\n\tpr_err(\"cpl:            %d                efer:         %016llx\\n\",\n\t\tsave->cpl, save->efer);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"cr0:\", save->cr0, \"cr2:\", save->cr2);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"cr3:\", save->cr3, \"cr4:\", save->cr4);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"dr6:\", save->dr6, \"dr7:\", save->dr7);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"rip:\", save->rip, \"rflags:\", save->rflags);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"rsp:\", save->rsp, \"rax:\", save->rax);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"star:\", save->star, \"lstar:\", save->lstar);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"cstar:\", save->cstar, \"sfmask:\", save->sfmask);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"kernel_gs_base:\", save->kernel_gs_base,\n\t       \"sysenter_cs:\", save->sysenter_cs);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"sysenter_esp:\", save->sysenter_esp,\n\t       \"sysenter_eip:\", save->sysenter_eip);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"gpat:\", save->g_pat, \"dbgctl:\", save->dbgctl);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"br_from:\", save->br_from, \"br_to:\", save->br_to);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"excp_from:\", save->last_excp_from,\n\t       \"excp_to:\", save->last_excp_to);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_set_cr0(struct kvm_vcpu *vcpu, unsigned long cr0);",
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_set_cr0(struct kvm_vcpu *vcpu, unsigned long cr0);\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic void dump_vmcb(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tstruct vmcb_control_area *control = &svm->vmcb->control;\n\tstruct vmcb_save_area *save = &svm->vmcb->save;\n\n\tpr_err(\"VMCB Control Area:\\n\");\n\tpr_err(\"%-20s%04x\\n\", \"cr_read:\", control->intercept_cr & 0xffff);\n\tpr_err(\"%-20s%04x\\n\", \"cr_write:\", control->intercept_cr >> 16);\n\tpr_err(\"%-20s%04x\\n\", \"dr_read:\", control->intercept_dr & 0xffff);\n\tpr_err(\"%-20s%04x\\n\", \"dr_write:\", control->intercept_dr >> 16);\n\tpr_err(\"%-20s%08x\\n\", \"exceptions:\", control->intercept_exceptions);\n\tpr_err(\"%-20s%016llx\\n\", \"intercepts:\", control->intercept);\n\tpr_err(\"%-20s%d\\n\", \"pause filter count:\", control->pause_filter_count);\n\tpr_err(\"%-20s%016llx\\n\", \"iopm_base_pa:\", control->iopm_base_pa);\n\tpr_err(\"%-20s%016llx\\n\", \"msrpm_base_pa:\", control->msrpm_base_pa);\n\tpr_err(\"%-20s%016llx\\n\", \"tsc_offset:\", control->tsc_offset);\n\tpr_err(\"%-20s%d\\n\", \"asid:\", control->asid);\n\tpr_err(\"%-20s%d\\n\", \"tlb_ctl:\", control->tlb_ctl);\n\tpr_err(\"%-20s%08x\\n\", \"int_ctl:\", control->int_ctl);\n\tpr_err(\"%-20s%08x\\n\", \"int_vector:\", control->int_vector);\n\tpr_err(\"%-20s%08x\\n\", \"int_state:\", control->int_state);\n\tpr_err(\"%-20s%08x\\n\", \"exit_code:\", control->exit_code);\n\tpr_err(\"%-20s%016llx\\n\", \"exit_info1:\", control->exit_info_1);\n\tpr_err(\"%-20s%016llx\\n\", \"exit_info2:\", control->exit_info_2);\n\tpr_err(\"%-20s%08x\\n\", \"exit_int_info:\", control->exit_int_info);\n\tpr_err(\"%-20s%08x\\n\", \"exit_int_info_err:\", control->exit_int_info_err);\n\tpr_err(\"%-20s%lld\\n\", \"nested_ctl:\", control->nested_ctl);\n\tpr_err(\"%-20s%016llx\\n\", \"nested_cr3:\", control->nested_cr3);\n\tpr_err(\"%-20s%016llx\\n\", \"avic_vapic_bar:\", control->avic_vapic_bar);\n\tpr_err(\"%-20s%08x\\n\", \"event_inj:\", control->event_inj);\n\tpr_err(\"%-20s%08x\\n\", \"event_inj_err:\", control->event_inj_err);\n\tpr_err(\"%-20s%lld\\n\", \"lbr_ctl:\", control->lbr_ctl);\n\tpr_err(\"%-20s%016llx\\n\", \"next_rip:\", control->next_rip);\n\tpr_err(\"%-20s%016llx\\n\", \"avic_backing_page:\", control->avic_backing_page);\n\tpr_err(\"%-20s%016llx\\n\", \"avic_logical_id:\", control->avic_logical_id);\n\tpr_err(\"%-20s%016llx\\n\", \"avic_physical_id:\", control->avic_physical_id);\n\tpr_err(\"VMCB State Save Area:\\n\");\n\tpr_err(\"%-5s s: %04x a: %04x l: %08x b: %016llx\\n\",\n\t       \"es:\",\n\t       save->es.selector, save->es.attrib,\n\t       save->es.limit, save->es.base);\n\tpr_err(\"%-5s s: %04x a: %04x l: %08x b: %016llx\\n\",\n\t       \"cs:\",\n\t       save->cs.selector, save->cs.attrib,\n\t       save->cs.limit, save->cs.base);\n\tpr_err(\"%-5s s: %04x a: %04x l: %08x b: %016llx\\n\",\n\t       \"ss:\",\n\t       save->ss.selector, save->ss.attrib,\n\t       save->ss.limit, save->ss.base);\n\tpr_err(\"%-5s s: %04x a: %04x l: %08x b: %016llx\\n\",\n\t       \"ds:\",\n\t       save->ds.selector, save->ds.attrib,\n\t       save->ds.limit, save->ds.base);\n\tpr_err(\"%-5s s: %04x a: %04x l: %08x b: %016llx\\n\",\n\t       \"fs:\",\n\t       save->fs.selector, save->fs.attrib,\n\t       save->fs.limit, save->fs.base);\n\tpr_err(\"%-5s s: %04x a: %04x l: %08x b: %016llx\\n\",\n\t       \"gs:\",\n\t       save->gs.selector, save->gs.attrib,\n\t       save->gs.limit, save->gs.base);\n\tpr_err(\"%-5s s: %04x a: %04x l: %08x b: %016llx\\n\",\n\t       \"gdtr:\",\n\t       save->gdtr.selector, save->gdtr.attrib,\n\t       save->gdtr.limit, save->gdtr.base);\n\tpr_err(\"%-5s s: %04x a: %04x l: %08x b: %016llx\\n\",\n\t       \"ldtr:\",\n\t       save->ldtr.selector, save->ldtr.attrib,\n\t       save->ldtr.limit, save->ldtr.base);\n\tpr_err(\"%-5s s: %04x a: %04x l: %08x b: %016llx\\n\",\n\t       \"idtr:\",\n\t       save->idtr.selector, save->idtr.attrib,\n\t       save->idtr.limit, save->idtr.base);\n\tpr_err(\"%-5s s: %04x a: %04x l: %08x b: %016llx\\n\",\n\t       \"tr:\",\n\t       save->tr.selector, save->tr.attrib,\n\t       save->tr.limit, save->tr.base);\n\tpr_err(\"cpl:            %d                efer:         %016llx\\n\",\n\t\tsave->cpl, save->efer);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"cr0:\", save->cr0, \"cr2:\", save->cr2);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"cr3:\", save->cr3, \"cr4:\", save->cr4);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"dr6:\", save->dr6, \"dr7:\", save->dr7);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"rip:\", save->rip, \"rflags:\", save->rflags);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"rsp:\", save->rsp, \"rax:\", save->rax);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"star:\", save->star, \"lstar:\", save->lstar);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"cstar:\", save->cstar, \"sfmask:\", save->sfmask);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"kernel_gs_base:\", save->kernel_gs_base,\n\t       \"sysenter_cs:\", save->sysenter_cs);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"sysenter_esp:\", save->sysenter_esp,\n\t       \"sysenter_eip:\", save->sysenter_eip);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"gpat:\", save->g_pat, \"dbgctl:\", save->dbgctl);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"br_from:\", save->br_from, \"br_to:\", save->br_to);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"excp_from:\", save->last_excp_from,\n\t       \"excp_to:\", save->last_excp_to);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"KVM: FAILED VMRUN WITH VMCB:\\n\""
          ],
          "line": 4089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svm_complete_interrupts",
          "args": [
            "svm"
          ],
          "line": 4083
        },
        "resolved": true,
        "details": {
          "function_name": "svm_complete_interrupts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "4375-4437",
          "snippet": "static void svm_complete_interrupts(struct vcpu_svm *svm)\n{\n\tu8 vector;\n\tint type;\n\tu32 exitintinfo = svm->vmcb->control.exit_int_info;\n\tunsigned int3_injected = svm->int3_injected;\n\n\tsvm->int3_injected = 0;\n\n\t/*\n\t * If we've made progress since setting HF_IRET_MASK, we've\n\t * executed an IRET and can allow NMI injection.\n\t */\n\tif ((svm->vcpu.arch.hflags & HF_IRET_MASK)\n\t    && kvm_rip_read(&svm->vcpu) != svm->nmi_iret_rip) {\n\t\tsvm->vcpu.arch.hflags &= ~(HF_NMI_MASK | HF_IRET_MASK);\n\t\tkvm_make_request(KVM_REQ_EVENT, &svm->vcpu);\n\t}\n\n\tsvm->vcpu.arch.nmi_injected = false;\n\tkvm_clear_exception_queue(&svm->vcpu);\n\tkvm_clear_interrupt_queue(&svm->vcpu);\n\n\tif (!(exitintinfo & SVM_EXITINTINFO_VALID))\n\t\treturn;\n\n\tkvm_make_request(KVM_REQ_EVENT, &svm->vcpu);\n\n\tvector = exitintinfo & SVM_EXITINTINFO_VEC_MASK;\n\ttype = exitintinfo & SVM_EXITINTINFO_TYPE_MASK;\n\n\tswitch (type) {\n\tcase SVM_EXITINTINFO_TYPE_NMI:\n\t\tsvm->vcpu.arch.nmi_injected = true;\n\t\tbreak;\n\tcase SVM_EXITINTINFO_TYPE_EXEPT:\n\t\t/*\n\t\t * In case of software exceptions, do not reinject the vector,\n\t\t * but re-execute the instruction instead. Rewind RIP first\n\t\t * if we emulated INT3 before.\n\t\t */\n\t\tif (kvm_exception_is_soft(vector)) {\n\t\t\tif (vector == BP_VECTOR && int3_injected &&\n\t\t\t    kvm_is_linear_rip(&svm->vcpu, svm->int3_rip))\n\t\t\t\tkvm_rip_write(&svm->vcpu,\n\t\t\t\t\t      kvm_rip_read(&svm->vcpu) -\n\t\t\t\t\t      int3_injected);\n\t\t\tbreak;\n\t\t}\n\t\tif (exitintinfo & SVM_EXITINTINFO_VALID_ERR) {\n\t\t\tu32 err = svm->vmcb->control.exit_int_info_err;\n\t\t\tkvm_requeue_exception_e(&svm->vcpu, vector, err);\n\n\t\t} else\n\t\t\tkvm_requeue_exception(&svm->vcpu, vector);\n\t\tbreak;\n\tcase SVM_EXITINTINFO_TYPE_INTR:\n\t\tkvm_queue_interrupt(&svm->vcpu, vector, false);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm)\n{\n\tu8 vector;\n\tint type;\n\tu32 exitintinfo = svm->vmcb->control.exit_int_info;\n\tunsigned int3_injected = svm->int3_injected;\n\n\tsvm->int3_injected = 0;\n\n\t/*\n\t * If we've made progress since setting HF_IRET_MASK, we've\n\t * executed an IRET and can allow NMI injection.\n\t */\n\tif ((svm->vcpu.arch.hflags & HF_IRET_MASK)\n\t    && kvm_rip_read(&svm->vcpu) != svm->nmi_iret_rip) {\n\t\tsvm->vcpu.arch.hflags &= ~(HF_NMI_MASK | HF_IRET_MASK);\n\t\tkvm_make_request(KVM_REQ_EVENT, &svm->vcpu);\n\t}\n\n\tsvm->vcpu.arch.nmi_injected = false;\n\tkvm_clear_exception_queue(&svm->vcpu);\n\tkvm_clear_interrupt_queue(&svm->vcpu);\n\n\tif (!(exitintinfo & SVM_EXITINTINFO_VALID))\n\t\treturn;\n\n\tkvm_make_request(KVM_REQ_EVENT, &svm->vcpu);\n\n\tvector = exitintinfo & SVM_EXITINTINFO_VEC_MASK;\n\ttype = exitintinfo & SVM_EXITINTINFO_TYPE_MASK;\n\n\tswitch (type) {\n\tcase SVM_EXITINTINFO_TYPE_NMI:\n\t\tsvm->vcpu.arch.nmi_injected = true;\n\t\tbreak;\n\tcase SVM_EXITINTINFO_TYPE_EXEPT:\n\t\t/*\n\t\t * In case of software exceptions, do not reinject the vector,\n\t\t * but re-execute the instruction instead. Rewind RIP first\n\t\t * if we emulated INT3 before.\n\t\t */\n\t\tif (kvm_exception_is_soft(vector)) {\n\t\t\tif (vector == BP_VECTOR && int3_injected &&\n\t\t\t    kvm_is_linear_rip(&svm->vcpu, svm->int3_rip))\n\t\t\t\tkvm_rip_write(&svm->vcpu,\n\t\t\t\t\t      kvm_rip_read(&svm->vcpu) -\n\t\t\t\t\t      int3_injected);\n\t\t\tbreak;\n\t\t}\n\t\tif (exitintinfo & SVM_EXITINTINFO_VALID_ERR) {\n\t\t\tu32 err = svm->vmcb->control.exit_int_info_err;\n\t\t\tkvm_requeue_exception_e(&svm->vcpu, vector, err);\n\n\t\t} else\n\t\t\tkvm_requeue_exception(&svm->vcpu, vector);\n\t\tbreak;\n\tcase SVM_EXITINTINFO_TYPE_INTR:\n\t\tkvm_queue_interrupt(&svm->vcpu, vector, false);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "nested_svm_exit_handled",
          "args": [
            "svm"
          ],
          "line": 4077
        },
        "resolved": true,
        "details": {
          "function_name": "nested_svm_exit_handled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "2492-2502",
          "snippet": "static int nested_svm_exit_handled(struct vcpu_svm *svm)\n{\n\tint vmexit;\n\n\tvmexit = nested_svm_intercept(svm);\n\n\tif (vmexit == NESTED_EXIT_DONE)\n\t\tnested_svm_vmexit(svm);\n\n\treturn vmexit;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define NESTED_EXIT_DONE\t1\t/* Exit caused nested vmexit  */"
          ],
          "globals_used": [
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define NESTED_EXIT_DONE\t1\t/* Exit caused nested vmexit  */\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm)\n{\n\tint vmexit;\n\n\tvmexit = nested_svm_intercept(svm);\n\n\tif (vmexit == NESTED_EXIT_DONE)\n\t\tnested_svm_vmexit(svm);\n\n\treturn vmexit;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nested_svm_exit_special",
          "args": [
            "svm"
          ],
          "line": 4074
        },
        "resolved": true,
        "details": {
          "function_name": "nested_svm_exit_special",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "2412-2439",
          "snippet": "static int nested_svm_exit_special(struct vcpu_svm *svm)\n{\n\tu32 exit_code = svm->vmcb->control.exit_code;\n\n\tswitch (exit_code) {\n\tcase SVM_EXIT_INTR:\n\tcase SVM_EXIT_NMI:\n\tcase SVM_EXIT_EXCP_BASE + MC_VECTOR:\n\t\treturn NESTED_EXIT_HOST;\n\tcase SVM_EXIT_NPF:\n\t\t/* For now we are always handling NPFs when using them */\n\t\tif (npt_enabled)\n\t\t\treturn NESTED_EXIT_HOST;\n\t\tbreak;\n\tcase SVM_EXIT_EXCP_BASE + PF_VECTOR:\n\t\t/* When we're shadowing, trap PFs, but not async PF */\n\t\tif (!npt_enabled && svm->apf_reason == 0)\n\t\t\treturn NESTED_EXIT_HOST;\n\t\tbreak;\n\tcase SVM_EXIT_EXCP_BASE + NM_VECTOR:\n\t\tnm_interception(svm);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn NESTED_EXIT_CONTINUE;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define NESTED_EXIT_CONTINUE\t2\t/* Further checks needed      */",
            "#define NESTED_EXIT_HOST\t0\t/* Exit handled on host level */"
          ],
          "globals_used": [
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define NESTED_EXIT_CONTINUE\t2\t/* Further checks needed      */\n#define NESTED_EXIT_HOST\t0\t/* Exit handled on host level */\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic int nested_svm_exit_special(struct vcpu_svm *svm)\n{\n\tu32 exit_code = svm->vmcb->control.exit_code;\n\n\tswitch (exit_code) {\n\tcase SVM_EXIT_INTR:\n\tcase SVM_EXIT_NMI:\n\tcase SVM_EXIT_EXCP_BASE + MC_VECTOR:\n\t\treturn NESTED_EXIT_HOST;\n\tcase SVM_EXIT_NPF:\n\t\t/* For now we are always handling NPFs when using them */\n\t\tif (npt_enabled)\n\t\t\treturn NESTED_EXIT_HOST;\n\t\tbreak;\n\tcase SVM_EXIT_EXCP_BASE + PF_VECTOR:\n\t\t/* When we're shadowing, trap PFs, but not async PF */\n\t\tif (!npt_enabled && svm->apf_reason == 0)\n\t\t\treturn NESTED_EXIT_HOST;\n\t\tbreak;\n\tcase SVM_EXIT_EXCP_BASE + NM_VECTOR:\n\t\tnm_interception(svm);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn NESTED_EXIT_CONTINUE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_kvm_nested_vmexit",
          "args": [
            "svm->vmcb->save.rip",
            "exit_code",
            "svm->vmcb->control.exit_info_1",
            "svm->vmcb->control.exit_info_2",
            "svm->vmcb->control.exit_int_info",
            "svm->vmcb->control.exit_int_info_err",
            "KVM_ISA_SVM"
          ],
          "line": 4067
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_guest_mode",
          "args": [
            "vcpu"
          ],
          "line": 4064
        },
        "resolved": true,
        "details": {
          "function_name": "is_guest_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "102-105",
          "snippet": "static inline bool is_guest_mode(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.hflags & HF_GUEST_MASK;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline bool is_guest_mode(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.hflags & HF_GUEST_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nested_svm_vmexit",
          "args": [
            "svm"
          ],
          "line": 4058
        },
        "resolved": true,
        "details": {
          "function_name": "nested_svm_vmexit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "2534-2655",
          "snippet": "static int nested_svm_vmexit(struct vcpu_svm *svm)\n{\n\tstruct vmcb *nested_vmcb;\n\tstruct vmcb *hsave = svm->nested.hsave;\n\tstruct vmcb *vmcb = svm->vmcb;\n\tstruct page *page;\n\n\ttrace_kvm_nested_vmexit_inject(vmcb->control.exit_code,\n\t\t\t\t       vmcb->control.exit_info_1,\n\t\t\t\t       vmcb->control.exit_info_2,\n\t\t\t\t       vmcb->control.exit_int_info,\n\t\t\t\t       vmcb->control.exit_int_info_err,\n\t\t\t\t       KVM_ISA_SVM);\n\n\tnested_vmcb = nested_svm_map(svm, svm->nested.vmcb, &page);\n\tif (!nested_vmcb)\n\t\treturn 1;\n\n\t/* Exit Guest-Mode */\n\tleave_guest_mode(&svm->vcpu);\n\tsvm->nested.vmcb = 0;\n\n\t/* Give the current vmcb to the guest */\n\tdisable_gif(svm);\n\n\tnested_vmcb->save.es     = vmcb->save.es;\n\tnested_vmcb->save.cs     = vmcb->save.cs;\n\tnested_vmcb->save.ss     = vmcb->save.ss;\n\tnested_vmcb->save.ds     = vmcb->save.ds;\n\tnested_vmcb->save.gdtr   = vmcb->save.gdtr;\n\tnested_vmcb->save.idtr   = vmcb->save.idtr;\n\tnested_vmcb->save.efer   = svm->vcpu.arch.efer;\n\tnested_vmcb->save.cr0    = kvm_read_cr0(&svm->vcpu);\n\tnested_vmcb->save.cr3    = kvm_read_cr3(&svm->vcpu);\n\tnested_vmcb->save.cr2    = vmcb->save.cr2;\n\tnested_vmcb->save.cr4    = svm->vcpu.arch.cr4;\n\tnested_vmcb->save.rflags = kvm_get_rflags(&svm->vcpu);\n\tnested_vmcb->save.rip    = vmcb->save.rip;\n\tnested_vmcb->save.rsp    = vmcb->save.rsp;\n\tnested_vmcb->save.rax    = vmcb->save.rax;\n\tnested_vmcb->save.dr7    = vmcb->save.dr7;\n\tnested_vmcb->save.dr6    = vmcb->save.dr6;\n\tnested_vmcb->save.cpl    = vmcb->save.cpl;\n\n\tnested_vmcb->control.int_ctl           = vmcb->control.int_ctl;\n\tnested_vmcb->control.int_vector        = vmcb->control.int_vector;\n\tnested_vmcb->control.int_state         = vmcb->control.int_state;\n\tnested_vmcb->control.exit_code         = vmcb->control.exit_code;\n\tnested_vmcb->control.exit_code_hi      = vmcb->control.exit_code_hi;\n\tnested_vmcb->control.exit_info_1       = vmcb->control.exit_info_1;\n\tnested_vmcb->control.exit_info_2       = vmcb->control.exit_info_2;\n\tnested_vmcb->control.exit_int_info     = vmcb->control.exit_int_info;\n\tnested_vmcb->control.exit_int_info_err = vmcb->control.exit_int_info_err;\n\n\tif (svm->nrips_enabled)\n\t\tnested_vmcb->control.next_rip  = vmcb->control.next_rip;\n\n\t/*\n\t * If we emulate a VMRUN/#VMEXIT in the same host #vmexit cycle we have\n\t * to make sure that we do not lose injected events. So check event_inj\n\t * here and copy it to exit_int_info if it is valid.\n\t * Exit_int_info and event_inj can't be both valid because the case\n\t * below only happens on a VMRUN instruction intercept which has\n\t * no valid exit_int_info set.\n\t */\n\tif (vmcb->control.event_inj & SVM_EVTINJ_VALID) {\n\t\tstruct vmcb_control_area *nc = &nested_vmcb->control;\n\n\t\tnc->exit_int_info     = vmcb->control.event_inj;\n\t\tnc->exit_int_info_err = vmcb->control.event_inj_err;\n\t}\n\n\tnested_vmcb->control.tlb_ctl           = 0;\n\tnested_vmcb->control.event_inj         = 0;\n\tnested_vmcb->control.event_inj_err     = 0;\n\n\t/* We always set V_INTR_MASKING and remember the old value in hflags */\n\tif (!(svm->vcpu.arch.hflags & HF_VINTR_MASK))\n\t\tnested_vmcb->control.int_ctl &= ~V_INTR_MASKING_MASK;\n\n\t/* Restore the original control entries */\n\tcopy_vmcb_control_area(vmcb, hsave);\n\n\tkvm_clear_exception_queue(&svm->vcpu);\n\tkvm_clear_interrupt_queue(&svm->vcpu);\n\n\tsvm->nested.nested_cr3 = 0;\n\n\t/* Restore selected save entries */\n\tsvm->vmcb->save.es = hsave->save.es;\n\tsvm->vmcb->save.cs = hsave->save.cs;\n\tsvm->vmcb->save.ss = hsave->save.ss;\n\tsvm->vmcb->save.ds = hsave->save.ds;\n\tsvm->vmcb->save.gdtr = hsave->save.gdtr;\n\tsvm->vmcb->save.idtr = hsave->save.idtr;\n\tkvm_set_rflags(&svm->vcpu, hsave->save.rflags);\n\tsvm_set_efer(&svm->vcpu, hsave->save.efer);\n\tsvm_set_cr0(&svm->vcpu, hsave->save.cr0 | X86_CR0_PE);\n\tsvm_set_cr4(&svm->vcpu, hsave->save.cr4);\n\tif (npt_enabled) {\n\t\tsvm->vmcb->save.cr3 = hsave->save.cr3;\n\t\tsvm->vcpu.arch.cr3 = hsave->save.cr3;\n\t} else {\n\t\t(void)kvm_set_cr3(&svm->vcpu, hsave->save.cr3);\n\t}\n\tkvm_register_write(&svm->vcpu, VCPU_REGS_RAX, hsave->save.rax);\n\tkvm_register_write(&svm->vcpu, VCPU_REGS_RSP, hsave->save.rsp);\n\tkvm_register_write(&svm->vcpu, VCPU_REGS_RIP, hsave->save.rip);\n\tsvm->vmcb->save.dr7 = 0;\n\tsvm->vmcb->save.cpl = 0;\n\tsvm->vmcb->control.exit_int_info = 0;\n\n\tmark_all_dirty(svm->vmcb);\n\n\tnested_svm_unmap(page);\n\n\tnested_svm_uninit_mmu_context(&svm->vcpu);\n\tkvm_mmu_reset_context(&svm->vcpu);\n\tkvm_mmu_load(&svm->vcpu);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nested = true;",
            "static void svm_set_cr0(struct kvm_vcpu *vcpu, unsigned long cr0);",
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int nested = true;\nstatic void svm_set_cr0(struct kvm_vcpu *vcpu, unsigned long cr0);\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic int nested_svm_vmexit(struct vcpu_svm *svm)\n{\n\tstruct vmcb *nested_vmcb;\n\tstruct vmcb *hsave = svm->nested.hsave;\n\tstruct vmcb *vmcb = svm->vmcb;\n\tstruct page *page;\n\n\ttrace_kvm_nested_vmexit_inject(vmcb->control.exit_code,\n\t\t\t\t       vmcb->control.exit_info_1,\n\t\t\t\t       vmcb->control.exit_info_2,\n\t\t\t\t       vmcb->control.exit_int_info,\n\t\t\t\t       vmcb->control.exit_int_info_err,\n\t\t\t\t       KVM_ISA_SVM);\n\n\tnested_vmcb = nested_svm_map(svm, svm->nested.vmcb, &page);\n\tif (!nested_vmcb)\n\t\treturn 1;\n\n\t/* Exit Guest-Mode */\n\tleave_guest_mode(&svm->vcpu);\n\tsvm->nested.vmcb = 0;\n\n\t/* Give the current vmcb to the guest */\n\tdisable_gif(svm);\n\n\tnested_vmcb->save.es     = vmcb->save.es;\n\tnested_vmcb->save.cs     = vmcb->save.cs;\n\tnested_vmcb->save.ss     = vmcb->save.ss;\n\tnested_vmcb->save.ds     = vmcb->save.ds;\n\tnested_vmcb->save.gdtr   = vmcb->save.gdtr;\n\tnested_vmcb->save.idtr   = vmcb->save.idtr;\n\tnested_vmcb->save.efer   = svm->vcpu.arch.efer;\n\tnested_vmcb->save.cr0    = kvm_read_cr0(&svm->vcpu);\n\tnested_vmcb->save.cr3    = kvm_read_cr3(&svm->vcpu);\n\tnested_vmcb->save.cr2    = vmcb->save.cr2;\n\tnested_vmcb->save.cr4    = svm->vcpu.arch.cr4;\n\tnested_vmcb->save.rflags = kvm_get_rflags(&svm->vcpu);\n\tnested_vmcb->save.rip    = vmcb->save.rip;\n\tnested_vmcb->save.rsp    = vmcb->save.rsp;\n\tnested_vmcb->save.rax    = vmcb->save.rax;\n\tnested_vmcb->save.dr7    = vmcb->save.dr7;\n\tnested_vmcb->save.dr6    = vmcb->save.dr6;\n\tnested_vmcb->save.cpl    = vmcb->save.cpl;\n\n\tnested_vmcb->control.int_ctl           = vmcb->control.int_ctl;\n\tnested_vmcb->control.int_vector        = vmcb->control.int_vector;\n\tnested_vmcb->control.int_state         = vmcb->control.int_state;\n\tnested_vmcb->control.exit_code         = vmcb->control.exit_code;\n\tnested_vmcb->control.exit_code_hi      = vmcb->control.exit_code_hi;\n\tnested_vmcb->control.exit_info_1       = vmcb->control.exit_info_1;\n\tnested_vmcb->control.exit_info_2       = vmcb->control.exit_info_2;\n\tnested_vmcb->control.exit_int_info     = vmcb->control.exit_int_info;\n\tnested_vmcb->control.exit_int_info_err = vmcb->control.exit_int_info_err;\n\n\tif (svm->nrips_enabled)\n\t\tnested_vmcb->control.next_rip  = vmcb->control.next_rip;\n\n\t/*\n\t * If we emulate a VMRUN/#VMEXIT in the same host #vmexit cycle we have\n\t * to make sure that we do not lose injected events. So check event_inj\n\t * here and copy it to exit_int_info if it is valid.\n\t * Exit_int_info and event_inj can't be both valid because the case\n\t * below only happens on a VMRUN instruction intercept which has\n\t * no valid exit_int_info set.\n\t */\n\tif (vmcb->control.event_inj & SVM_EVTINJ_VALID) {\n\t\tstruct vmcb_control_area *nc = &nested_vmcb->control;\n\n\t\tnc->exit_int_info     = vmcb->control.event_inj;\n\t\tnc->exit_int_info_err = vmcb->control.event_inj_err;\n\t}\n\n\tnested_vmcb->control.tlb_ctl           = 0;\n\tnested_vmcb->control.event_inj         = 0;\n\tnested_vmcb->control.event_inj_err     = 0;\n\n\t/* We always set V_INTR_MASKING and remember the old value in hflags */\n\tif (!(svm->vcpu.arch.hflags & HF_VINTR_MASK))\n\t\tnested_vmcb->control.int_ctl &= ~V_INTR_MASKING_MASK;\n\n\t/* Restore the original control entries */\n\tcopy_vmcb_control_area(vmcb, hsave);\n\n\tkvm_clear_exception_queue(&svm->vcpu);\n\tkvm_clear_interrupt_queue(&svm->vcpu);\n\n\tsvm->nested.nested_cr3 = 0;\n\n\t/* Restore selected save entries */\n\tsvm->vmcb->save.es = hsave->save.es;\n\tsvm->vmcb->save.cs = hsave->save.cs;\n\tsvm->vmcb->save.ss = hsave->save.ss;\n\tsvm->vmcb->save.ds = hsave->save.ds;\n\tsvm->vmcb->save.gdtr = hsave->save.gdtr;\n\tsvm->vmcb->save.idtr = hsave->save.idtr;\n\tkvm_set_rflags(&svm->vcpu, hsave->save.rflags);\n\tsvm_set_efer(&svm->vcpu, hsave->save.efer);\n\tsvm_set_cr0(&svm->vcpu, hsave->save.cr0 | X86_CR0_PE);\n\tsvm_set_cr4(&svm->vcpu, hsave->save.cr4);\n\tif (npt_enabled) {\n\t\tsvm->vmcb->save.cr3 = hsave->save.cr3;\n\t\tsvm->vcpu.arch.cr3 = hsave->save.cr3;\n\t} else {\n\t\t(void)kvm_set_cr3(&svm->vcpu, hsave->save.cr3);\n\t}\n\tkvm_register_write(&svm->vcpu, VCPU_REGS_RAX, hsave->save.rax);\n\tkvm_register_write(&svm->vcpu, VCPU_REGS_RSP, hsave->save.rsp);\n\tkvm_register_write(&svm->vcpu, VCPU_REGS_RIP, hsave->save.rip);\n\tsvm->vmcb->save.dr7 = 0;\n\tsvm->vmcb->save.cpl = 0;\n\tsvm->vmcb->control.exit_int_info = 0;\n\n\tmark_all_dirty(svm->vmcb);\n\n\tnested_svm_unmap(page);\n\n\tnested_svm_uninit_mmu_context(&svm->vcpu);\n\tkvm_mmu_reset_context(&svm->vcpu);\n\tkvm_mmu_load(&svm->vcpu);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "svm->nested.exit_required"
          ],
          "line": 4057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_cr_intercept",
          "args": [
            "svm",
            "INTERCEPT_CR0_WRITE"
          ],
          "line": 4052
        },
        "resolved": true,
        "details": {
          "function_name": "is_cr_intercept",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "362-367",
          "snippet": "static inline bool is_cr_intercept(struct vcpu_svm *svm, int bit)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\treturn vmcb->control.intercept_cr & (1U << bit);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic inline bool is_cr_intercept(struct vcpu_svm *svm, int bit)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\treturn vmcb->control.intercept_cr & (1U << bit);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_kvm_exit",
          "args": [
            "exit_code",
            "vcpu",
            "KVM_ISA_SVM"
          ],
          "line": 4050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 4046
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "294-297",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define NESTED_EXIT_CONTINUE\t2\t/* Further checks needed      */\n#define NESTED_EXIT_DONE\t1\t/* Exit caused nested vmexit  */\n\nstatic int nested = true;\nstatic void svm_set_cr0(struct kvm_vcpu *vcpu, unsigned long cr0);\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\nstatic int (*const svm_exit_handlers[])(struct vcpu_svm *svm) = {\n\t[SVM_EXIT_READ_CR0]\t\t\t= cr_interception,\n\t[SVM_EXIT_READ_CR3]\t\t\t= cr_interception,\n\t[SVM_EXIT_READ_CR4]\t\t\t= cr_interception,\n\t[SVM_EXIT_READ_CR8]\t\t\t= cr_interception,\n\t[SVM_EXIT_CR0_SEL_WRITE]\t\t= cr_interception,\n\t[SVM_EXIT_WRITE_CR0]\t\t\t= cr_interception,\n\t[SVM_EXIT_WRITE_CR3]\t\t\t= cr_interception,\n\t[SVM_EXIT_WRITE_CR4]\t\t\t= cr_interception,\n\t[SVM_EXIT_WRITE_CR8]\t\t\t= cr8_write_interception,\n\t[SVM_EXIT_READ_DR0]\t\t\t= dr_interception,\n\t[SVM_EXIT_READ_DR1]\t\t\t= dr_interception,\n\t[SVM_EXIT_READ_DR2]\t\t\t= dr_interception,\n\t[SVM_EXIT_READ_DR3]\t\t\t= dr_interception,\n\t[SVM_EXIT_READ_DR4]\t\t\t= dr_interception,\n\t[SVM_EXIT_READ_DR5]\t\t\t= dr_interception,\n\t[SVM_EXIT_READ_DR6]\t\t\t= dr_interception,\n\t[SVM_EXIT_READ_DR7]\t\t\t= dr_interception,\n\t[SVM_EXIT_WRITE_DR0]\t\t\t= dr_interception,\n\t[SVM_EXIT_WRITE_DR1]\t\t\t= dr_interception,\n\t[SVM_EXIT_WRITE_DR2]\t\t\t= dr_interception,\n\t[SVM_EXIT_WRITE_DR3]\t\t\t= dr_interception,\n\t[SVM_EXIT_WRITE_DR4]\t\t\t= dr_interception,\n\t[SVM_EXIT_WRITE_DR5]\t\t\t= dr_interception,\n\t[SVM_EXIT_WRITE_DR6]\t\t\t= dr_interception,\n\t[SVM_EXIT_WRITE_DR7]\t\t\t= dr_interception,\n\t[SVM_EXIT_EXCP_BASE + DB_VECTOR]\t= db_interception,\n\t[SVM_EXIT_EXCP_BASE + BP_VECTOR]\t= bp_interception,\n\t[SVM_EXIT_EXCP_BASE + UD_VECTOR]\t= ud_interception,\n\t[SVM_EXIT_EXCP_BASE + PF_VECTOR]\t= pf_interception,\n\t[SVM_EXIT_EXCP_BASE + NM_VECTOR]\t= nm_interception,\n\t[SVM_EXIT_EXCP_BASE + MC_VECTOR]\t= mc_interception,\n\t[SVM_EXIT_EXCP_BASE + AC_VECTOR]\t= ac_interception,\n\t[SVM_EXIT_INTR]\t\t\t\t= intr_interception,\n\t[SVM_EXIT_NMI]\t\t\t\t= nmi_interception,\n\t[SVM_EXIT_SMI]\t\t\t\t= nop_on_interception,\n\t[SVM_EXIT_INIT]\t\t\t\t= nop_on_interception,\n\t[SVM_EXIT_VINTR]\t\t\t= interrupt_window_interception,\n\t[SVM_EXIT_RDPMC]\t\t\t= rdpmc_interception,\n\t[SVM_EXIT_CPUID]\t\t\t= cpuid_interception,\n\t[SVM_EXIT_IRET]                         = iret_interception,\n\t[SVM_EXIT_INVD]                         = emulate_on_interception,\n\t[SVM_EXIT_PAUSE]\t\t\t= pause_interception,\n\t[SVM_EXIT_HLT]\t\t\t\t= halt_interception,\n\t[SVM_EXIT_INVLPG]\t\t\t= invlpg_interception,\n\t[SVM_EXIT_INVLPGA]\t\t\t= invlpga_interception,\n\t[SVM_EXIT_IOIO]\t\t\t\t= io_interception,\n\t[SVM_EXIT_MSR]\t\t\t\t= msr_interception,\n\t[SVM_EXIT_TASK_SWITCH]\t\t\t= task_switch_interception,\n\t[SVM_EXIT_SHUTDOWN]\t\t\t= shutdown_interception,\n\t[SVM_EXIT_VMRUN]\t\t\t= vmrun_interception,\n\t[SVM_EXIT_VMMCALL]\t\t\t= vmmcall_interception,\n\t[SVM_EXIT_VMLOAD]\t\t\t= vmload_interception,\n\t[SVM_EXIT_VMSAVE]\t\t\t= vmsave_interception,\n\t[SVM_EXIT_STGI]\t\t\t\t= stgi_interception,\n\t[SVM_EXIT_CLGI]\t\t\t\t= clgi_interception,\n\t[SVM_EXIT_SKINIT]\t\t\t= skinit_interception,\n\t[SVM_EXIT_WBINVD]                       = wbinvd_interception,\n\t[SVM_EXIT_MONITOR]\t\t\t= monitor_interception,\n\t[SVM_EXIT_MWAIT]\t\t\t= mwait_interception,\n\t[SVM_EXIT_XSETBV]\t\t\t= xsetbv_interception,\n\t[SVM_EXIT_NPF]\t\t\t\t= pf_interception,\n\t[SVM_EXIT_RSM]                          = emulate_on_interception,\n\t[SVM_EXIT_AVIC_INCOMPLETE_IPI]\t\t= avic_incomplete_ipi_interception,\n\t[SVM_EXIT_AVIC_UNACCELERATED_ACCESS]\t= avic_unaccelerated_access_interception,\n};\n\nstatic int handle_exit(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tstruct kvm_run *kvm_run = vcpu->run;\n\tu32 exit_code = svm->vmcb->control.exit_code;\n\n\ttrace_kvm_exit(exit_code, vcpu, KVM_ISA_SVM);\n\n\tif (!is_cr_intercept(svm, INTERCEPT_CR0_WRITE))\n\t\tvcpu->arch.cr0 = svm->vmcb->save.cr0;\n\tif (npt_enabled)\n\t\tvcpu->arch.cr3 = svm->vmcb->save.cr3;\n\n\tif (unlikely(svm->nested.exit_required)) {\n\t\tnested_svm_vmexit(svm);\n\t\tsvm->nested.exit_required = false;\n\n\t\treturn 1;\n\t}\n\n\tif (is_guest_mode(vcpu)) {\n\t\tint vmexit;\n\n\t\ttrace_kvm_nested_vmexit(svm->vmcb->save.rip, exit_code,\n\t\t\t\t\tsvm->vmcb->control.exit_info_1,\n\t\t\t\t\tsvm->vmcb->control.exit_info_2,\n\t\t\t\t\tsvm->vmcb->control.exit_int_info,\n\t\t\t\t\tsvm->vmcb->control.exit_int_info_err,\n\t\t\t\t\tKVM_ISA_SVM);\n\n\t\tvmexit = nested_svm_exit_special(svm);\n\n\t\tif (vmexit == NESTED_EXIT_CONTINUE)\n\t\t\tvmexit = nested_svm_exit_handled(svm);\n\n\t\tif (vmexit == NESTED_EXIT_DONE)\n\t\t\treturn 1;\n\t}\n\n\tsvm_complete_interrupts(svm);\n\n\tif (svm->vmcb->control.exit_code == SVM_EXIT_ERR) {\n\t\tkvm_run->exit_reason = KVM_EXIT_FAIL_ENTRY;\n\t\tkvm_run->fail_entry.hardware_entry_failure_reason\n\t\t\t= svm->vmcb->control.exit_code;\n\t\tpr_err(\"KVM: FAILED VMRUN WITH VMCB:\\n\");\n\t\tdump_vmcb(vcpu);\n\t\treturn 0;\n\t}\n\n\tif (is_external_interrupt(svm->vmcb->control.exit_int_info) &&\n\t    exit_code != SVM_EXIT_EXCP_BASE + PF_VECTOR &&\n\t    exit_code != SVM_EXIT_NPF && exit_code != SVM_EXIT_TASK_SWITCH &&\n\t    exit_code != SVM_EXIT_INTR && exit_code != SVM_EXIT_NMI)\n\t\tprintk(KERN_ERR \"%s: unexpected exit_int_info 0x%x \"\n\t\t       \"exit_code 0x%x\\n\",\n\t\t       __func__, svm->vmcb->control.exit_int_info,\n\t\t       exit_code);\n\n\tif (exit_code >= ARRAY_SIZE(svm_exit_handlers)\n\t    || !svm_exit_handlers[exit_code]) {\n\t\tWARN_ONCE(1, \"svm: unexpected exit reason 0x%x\\n\", exit_code);\n\t\tkvm_queue_exception(vcpu, UD_VECTOR);\n\t\treturn 1;\n\t}\n\n\treturn svm_exit_handlers[exit_code](svm);\n}"
  },
  {
    "function_name": "svm_get_exit_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "4036-4042",
    "snippet": "static void svm_get_exit_info(struct kvm_vcpu *vcpu, u64 *info1, u64 *info2)\n{\n\tstruct vmcb_control_area *control = &to_svm(vcpu)->vmcb->control;\n\n\t*info1 = control->exit_info_1;\n\t*info2 = control->exit_info_2;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 4038
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "294-297",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\n\nstatic void svm_get_exit_info(struct kvm_vcpu *vcpu, u64 *info1, u64 *info2)\n{\n\tstruct vmcb_control_area *control = &to_svm(vcpu)->vmcb->control;\n\n\t*info1 = control->exit_info_1;\n\t*info2 = control->exit_info_2;\n}"
  },
  {
    "function_name": "dump_vmcb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "3927-4034",
    "snippet": "static void dump_vmcb(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tstruct vmcb_control_area *control = &svm->vmcb->control;\n\tstruct vmcb_save_area *save = &svm->vmcb->save;\n\n\tpr_err(\"VMCB Control Area:\\n\");\n\tpr_err(\"%-20s%04x\\n\", \"cr_read:\", control->intercept_cr & 0xffff);\n\tpr_err(\"%-20s%04x\\n\", \"cr_write:\", control->intercept_cr >> 16);\n\tpr_err(\"%-20s%04x\\n\", \"dr_read:\", control->intercept_dr & 0xffff);\n\tpr_err(\"%-20s%04x\\n\", \"dr_write:\", control->intercept_dr >> 16);\n\tpr_err(\"%-20s%08x\\n\", \"exceptions:\", control->intercept_exceptions);\n\tpr_err(\"%-20s%016llx\\n\", \"intercepts:\", control->intercept);\n\tpr_err(\"%-20s%d\\n\", \"pause filter count:\", control->pause_filter_count);\n\tpr_err(\"%-20s%016llx\\n\", \"iopm_base_pa:\", control->iopm_base_pa);\n\tpr_err(\"%-20s%016llx\\n\", \"msrpm_base_pa:\", control->msrpm_base_pa);\n\tpr_err(\"%-20s%016llx\\n\", \"tsc_offset:\", control->tsc_offset);\n\tpr_err(\"%-20s%d\\n\", \"asid:\", control->asid);\n\tpr_err(\"%-20s%d\\n\", \"tlb_ctl:\", control->tlb_ctl);\n\tpr_err(\"%-20s%08x\\n\", \"int_ctl:\", control->int_ctl);\n\tpr_err(\"%-20s%08x\\n\", \"int_vector:\", control->int_vector);\n\tpr_err(\"%-20s%08x\\n\", \"int_state:\", control->int_state);\n\tpr_err(\"%-20s%08x\\n\", \"exit_code:\", control->exit_code);\n\tpr_err(\"%-20s%016llx\\n\", \"exit_info1:\", control->exit_info_1);\n\tpr_err(\"%-20s%016llx\\n\", \"exit_info2:\", control->exit_info_2);\n\tpr_err(\"%-20s%08x\\n\", \"exit_int_info:\", control->exit_int_info);\n\tpr_err(\"%-20s%08x\\n\", \"exit_int_info_err:\", control->exit_int_info_err);\n\tpr_err(\"%-20s%lld\\n\", \"nested_ctl:\", control->nested_ctl);\n\tpr_err(\"%-20s%016llx\\n\", \"nested_cr3:\", control->nested_cr3);\n\tpr_err(\"%-20s%016llx\\n\", \"avic_vapic_bar:\", control->avic_vapic_bar);\n\tpr_err(\"%-20s%08x\\n\", \"event_inj:\", control->event_inj);\n\tpr_err(\"%-20s%08x\\n\", \"event_inj_err:\", control->event_inj_err);\n\tpr_err(\"%-20s%lld\\n\", \"lbr_ctl:\", control->lbr_ctl);\n\tpr_err(\"%-20s%016llx\\n\", \"next_rip:\", control->next_rip);\n\tpr_err(\"%-20s%016llx\\n\", \"avic_backing_page:\", control->avic_backing_page);\n\tpr_err(\"%-20s%016llx\\n\", \"avic_logical_id:\", control->avic_logical_id);\n\tpr_err(\"%-20s%016llx\\n\", \"avic_physical_id:\", control->avic_physical_id);\n\tpr_err(\"VMCB State Save Area:\\n\");\n\tpr_err(\"%-5s s: %04x a: %04x l: %08x b: %016llx\\n\",\n\t       \"es:\",\n\t       save->es.selector, save->es.attrib,\n\t       save->es.limit, save->es.base);\n\tpr_err(\"%-5s s: %04x a: %04x l: %08x b: %016llx\\n\",\n\t       \"cs:\",\n\t       save->cs.selector, save->cs.attrib,\n\t       save->cs.limit, save->cs.base);\n\tpr_err(\"%-5s s: %04x a: %04x l: %08x b: %016llx\\n\",\n\t       \"ss:\",\n\t       save->ss.selector, save->ss.attrib,\n\t       save->ss.limit, save->ss.base);\n\tpr_err(\"%-5s s: %04x a: %04x l: %08x b: %016llx\\n\",\n\t       \"ds:\",\n\t       save->ds.selector, save->ds.attrib,\n\t       save->ds.limit, save->ds.base);\n\tpr_err(\"%-5s s: %04x a: %04x l: %08x b: %016llx\\n\",\n\t       \"fs:\",\n\t       save->fs.selector, save->fs.attrib,\n\t       save->fs.limit, save->fs.base);\n\tpr_err(\"%-5s s: %04x a: %04x l: %08x b: %016llx\\n\",\n\t       \"gs:\",\n\t       save->gs.selector, save->gs.attrib,\n\t       save->gs.limit, save->gs.base);\n\tpr_err(\"%-5s s: %04x a: %04x l: %08x b: %016llx\\n\",\n\t       \"gdtr:\",\n\t       save->gdtr.selector, save->gdtr.attrib,\n\t       save->gdtr.limit, save->gdtr.base);\n\tpr_err(\"%-5s s: %04x a: %04x l: %08x b: %016llx\\n\",\n\t       \"ldtr:\",\n\t       save->ldtr.selector, save->ldtr.attrib,\n\t       save->ldtr.limit, save->ldtr.base);\n\tpr_err(\"%-5s s: %04x a: %04x l: %08x b: %016llx\\n\",\n\t       \"idtr:\",\n\t       save->idtr.selector, save->idtr.attrib,\n\t       save->idtr.limit, save->idtr.base);\n\tpr_err(\"%-5s s: %04x a: %04x l: %08x b: %016llx\\n\",\n\t       \"tr:\",\n\t       save->tr.selector, save->tr.attrib,\n\t       save->tr.limit, save->tr.base);\n\tpr_err(\"cpl:            %d                efer:         %016llx\\n\",\n\t\tsave->cpl, save->efer);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"cr0:\", save->cr0, \"cr2:\", save->cr2);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"cr3:\", save->cr3, \"cr4:\", save->cr4);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"dr6:\", save->dr6, \"dr7:\", save->dr7);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"rip:\", save->rip, \"rflags:\", save->rflags);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"rsp:\", save->rsp, \"rax:\", save->rax);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"star:\", save->star, \"lstar:\", save->lstar);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"cstar:\", save->cstar, \"sfmask:\", save->sfmask);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"kernel_gs_base:\", save->kernel_gs_base,\n\t       \"sysenter_cs:\", save->sysenter_cs);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"sysenter_esp:\", save->sysenter_esp,\n\t       \"sysenter_eip:\", save->sysenter_eip);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"gpat:\", save->g_pat, \"dbgctl:\", save->dbgctl);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"br_from:\", save->br_from, \"br_to:\", save->br_to);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"excp_from:\", save->last_excp_from,\n\t       \"excp_to:\", save->last_excp_to);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_set_cr0(struct kvm_vcpu *vcpu, unsigned long cr0);",
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%-15s %016llx %-13s %016llx\\n\"",
            "\"excp_from:\"",
            "save->last_excp_from",
            "\"excp_to:\"",
            "save->last_excp_to"
          ],
          "line": 4031
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%-15s %016llx %-13s %016llx\\n\"",
            "\"br_from:\"",
            "save->br_from",
            "\"br_to:\"",
            "save->br_to"
          ],
          "line": 4029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%-15s %016llx %-13s %016llx\\n\"",
            "\"gpat:\"",
            "save->g_pat",
            "\"dbgctl:\"",
            "save->dbgctl"
          ],
          "line": 4027
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%-15s %016llx %-13s %016llx\\n\"",
            "\"sysenter_esp:\"",
            "save->sysenter_esp",
            "\"sysenter_eip:\"",
            "save->sysenter_eip"
          ],
          "line": 4024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%-15s %016llx %-13s %016llx\\n\"",
            "\"kernel_gs_base:\"",
            "save->kernel_gs_base",
            "\"sysenter_cs:\"",
            "save->sysenter_cs"
          ],
          "line": 4021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%-15s %016llx %-13s %016llx\\n\"",
            "\"cstar:\"",
            "save->cstar",
            "\"sfmask:\"",
            "save->sfmask"
          ],
          "line": 4019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%-15s %016llx %-13s %016llx\\n\"",
            "\"star:\"",
            "save->star",
            "\"lstar:\"",
            "save->lstar"
          ],
          "line": 4017
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%-15s %016llx %-13s %016llx\\n\"",
            "\"rsp:\"",
            "save->rsp",
            "\"rax:\"",
            "save->rax"
          ],
          "line": 4015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%-15s %016llx %-13s %016llx\\n\"",
            "\"rip:\"",
            "save->rip",
            "\"rflags:\"",
            "save->rflags"
          ],
          "line": 4013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%-15s %016llx %-13s %016llx\\n\"",
            "\"dr6:\"",
            "save->dr6",
            "\"dr7:\"",
            "save->dr7"
          ],
          "line": 4011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%-15s %016llx %-13s %016llx\\n\"",
            "\"cr3:\"",
            "save->cr3",
            "\"cr4:\"",
            "save->cr4"
          ],
          "line": 4009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%-15s %016llx %-13s %016llx\\n\"",
            "\"cr0:\"",
            "save->cr0",
            "\"cr2:\"",
            "save->cr2"
          ],
          "line": 4007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"cpl:            %d                efer:         %016llx\\n\"",
            "save->cpl",
            "save->efer"
          ],
          "line": 4005
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%-5s s: %04x a: %04x l: %08x b: %016llx\\n\"",
            "\"tr:\"",
            "save->tr.selector",
            "save->tr.attrib",
            "save->tr.limit",
            "save->tr.base"
          ],
          "line": 4001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%-5s s: %04x a: %04x l: %08x b: %016llx\\n\"",
            "\"idtr:\"",
            "save->idtr.selector",
            "save->idtr.attrib",
            "save->idtr.limit",
            "save->idtr.base"
          ],
          "line": 3997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%-5s s: %04x a: %04x l: %08x b: %016llx\\n\"",
            "\"ldtr:\"",
            "save->ldtr.selector",
            "save->ldtr.attrib",
            "save->ldtr.limit",
            "save->ldtr.base"
          ],
          "line": 3993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%-5s s: %04x a: %04x l: %08x b: %016llx\\n\"",
            "\"gdtr:\"",
            "save->gdtr.selector",
            "save->gdtr.attrib",
            "save->gdtr.limit",
            "save->gdtr.base"
          ],
          "line": 3989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%-5s s: %04x a: %04x l: %08x b: %016llx\\n\"",
            "\"gs:\"",
            "save->gs.selector",
            "save->gs.attrib",
            "save->gs.limit",
            "save->gs.base"
          ],
          "line": 3985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%-5s s: %04x a: %04x l: %08x b: %016llx\\n\"",
            "\"fs:\"",
            "save->fs.selector",
            "save->fs.attrib",
            "save->fs.limit",
            "save->fs.base"
          ],
          "line": 3981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%-5s s: %04x a: %04x l: %08x b: %016llx\\n\"",
            "\"ds:\"",
            "save->ds.selector",
            "save->ds.attrib",
            "save->ds.limit",
            "save->ds.base"
          ],
          "line": 3977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%-5s s: %04x a: %04x l: %08x b: %016llx\\n\"",
            "\"ss:\"",
            "save->ss.selector",
            "save->ss.attrib",
            "save->ss.limit",
            "save->ss.base"
          ],
          "line": 3973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%-5s s: %04x a: %04x l: %08x b: %016llx\\n\"",
            "\"cs:\"",
            "save->cs.selector",
            "save->cs.attrib",
            "save->cs.limit",
            "save->cs.base"
          ],
          "line": 3969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%-5s s: %04x a: %04x l: %08x b: %016llx\\n\"",
            "\"es:\"",
            "save->es.selector",
            "save->es.attrib",
            "save->es.limit",
            "save->es.base"
          ],
          "line": 3965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"VMCB State Save Area:\\n\""
          ],
          "line": 3964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%-20s%016llx\\n\"",
            "\"avic_physical_id:\"",
            "control->avic_physical_id"
          ],
          "line": 3963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%-20s%016llx\\n\"",
            "\"avic_logical_id:\"",
            "control->avic_logical_id"
          ],
          "line": 3962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%-20s%016llx\\n\"",
            "\"avic_backing_page:\"",
            "control->avic_backing_page"
          ],
          "line": 3961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%-20s%016llx\\n\"",
            "\"next_rip:\"",
            "control->next_rip"
          ],
          "line": 3960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%-20s%lld\\n\"",
            "\"lbr_ctl:\"",
            "control->lbr_ctl"
          ],
          "line": 3959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%-20s%08x\\n\"",
            "\"event_inj_err:\"",
            "control->event_inj_err"
          ],
          "line": 3958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%-20s%08x\\n\"",
            "\"event_inj:\"",
            "control->event_inj"
          ],
          "line": 3957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%-20s%016llx\\n\"",
            "\"avic_vapic_bar:\"",
            "control->avic_vapic_bar"
          ],
          "line": 3956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%-20s%016llx\\n\"",
            "\"nested_cr3:\"",
            "control->nested_cr3"
          ],
          "line": 3955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%-20s%lld\\n\"",
            "\"nested_ctl:\"",
            "control->nested_ctl"
          ],
          "line": 3954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%-20s%08x\\n\"",
            "\"exit_int_info_err:\"",
            "control->exit_int_info_err"
          ],
          "line": 3953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%-20s%08x\\n\"",
            "\"exit_int_info:\"",
            "control->exit_int_info"
          ],
          "line": 3952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%-20s%016llx\\n\"",
            "\"exit_info2:\"",
            "control->exit_info_2"
          ],
          "line": 3951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%-20s%016llx\\n\"",
            "\"exit_info1:\"",
            "control->exit_info_1"
          ],
          "line": 3950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%-20s%08x\\n\"",
            "\"exit_code:\"",
            "control->exit_code"
          ],
          "line": 3949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%-20s%08x\\n\"",
            "\"int_state:\"",
            "control->int_state"
          ],
          "line": 3948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%-20s%08x\\n\"",
            "\"int_vector:\"",
            "control->int_vector"
          ],
          "line": 3947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%-20s%08x\\n\"",
            "\"int_ctl:\"",
            "control->int_ctl"
          ],
          "line": 3946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%-20s%d\\n\"",
            "\"tlb_ctl:\"",
            "control->tlb_ctl"
          ],
          "line": 3945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%-20s%d\\n\"",
            "\"asid:\"",
            "control->asid"
          ],
          "line": 3944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%-20s%016llx\\n\"",
            "\"tsc_offset:\"",
            "control->tsc_offset"
          ],
          "line": 3943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%-20s%016llx\\n\"",
            "\"msrpm_base_pa:\"",
            "control->msrpm_base_pa"
          ],
          "line": 3942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%-20s%016llx\\n\"",
            "\"iopm_base_pa:\"",
            "control->iopm_base_pa"
          ],
          "line": 3941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%-20s%d\\n\"",
            "\"pause filter count:\"",
            "control->pause_filter_count"
          ],
          "line": 3940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%-20s%016llx\\n\"",
            "\"intercepts:\"",
            "control->intercept"
          ],
          "line": 3939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%-20s%08x\\n\"",
            "\"exceptions:\"",
            "control->intercept_exceptions"
          ],
          "line": 3938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%-20s%04x\\n\"",
            "\"dr_write:\"",
            "control->intercept_dr >> 16"
          ],
          "line": 3937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%-20s%04x\\n\"",
            "\"dr_read:\"",
            "control->intercept_dr & 0xffff"
          ],
          "line": 3936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%-20s%04x\\n\"",
            "\"cr_write:\"",
            "control->intercept_cr >> 16"
          ],
          "line": 3935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%-20s%04x\\n\"",
            "\"cr_read:\"",
            "control->intercept_cr & 0xffff"
          ],
          "line": 3934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"VMCB Control Area:\\n\""
          ],
          "line": 3933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 3929
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "294-297",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_set_cr0(struct kvm_vcpu *vcpu, unsigned long cr0);\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic void dump_vmcb(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tstruct vmcb_control_area *control = &svm->vmcb->control;\n\tstruct vmcb_save_area *save = &svm->vmcb->save;\n\n\tpr_err(\"VMCB Control Area:\\n\");\n\tpr_err(\"%-20s%04x\\n\", \"cr_read:\", control->intercept_cr & 0xffff);\n\tpr_err(\"%-20s%04x\\n\", \"cr_write:\", control->intercept_cr >> 16);\n\tpr_err(\"%-20s%04x\\n\", \"dr_read:\", control->intercept_dr & 0xffff);\n\tpr_err(\"%-20s%04x\\n\", \"dr_write:\", control->intercept_dr >> 16);\n\tpr_err(\"%-20s%08x\\n\", \"exceptions:\", control->intercept_exceptions);\n\tpr_err(\"%-20s%016llx\\n\", \"intercepts:\", control->intercept);\n\tpr_err(\"%-20s%d\\n\", \"pause filter count:\", control->pause_filter_count);\n\tpr_err(\"%-20s%016llx\\n\", \"iopm_base_pa:\", control->iopm_base_pa);\n\tpr_err(\"%-20s%016llx\\n\", \"msrpm_base_pa:\", control->msrpm_base_pa);\n\tpr_err(\"%-20s%016llx\\n\", \"tsc_offset:\", control->tsc_offset);\n\tpr_err(\"%-20s%d\\n\", \"asid:\", control->asid);\n\tpr_err(\"%-20s%d\\n\", \"tlb_ctl:\", control->tlb_ctl);\n\tpr_err(\"%-20s%08x\\n\", \"int_ctl:\", control->int_ctl);\n\tpr_err(\"%-20s%08x\\n\", \"int_vector:\", control->int_vector);\n\tpr_err(\"%-20s%08x\\n\", \"int_state:\", control->int_state);\n\tpr_err(\"%-20s%08x\\n\", \"exit_code:\", control->exit_code);\n\tpr_err(\"%-20s%016llx\\n\", \"exit_info1:\", control->exit_info_1);\n\tpr_err(\"%-20s%016llx\\n\", \"exit_info2:\", control->exit_info_2);\n\tpr_err(\"%-20s%08x\\n\", \"exit_int_info:\", control->exit_int_info);\n\tpr_err(\"%-20s%08x\\n\", \"exit_int_info_err:\", control->exit_int_info_err);\n\tpr_err(\"%-20s%lld\\n\", \"nested_ctl:\", control->nested_ctl);\n\tpr_err(\"%-20s%016llx\\n\", \"nested_cr3:\", control->nested_cr3);\n\tpr_err(\"%-20s%016llx\\n\", \"avic_vapic_bar:\", control->avic_vapic_bar);\n\tpr_err(\"%-20s%08x\\n\", \"event_inj:\", control->event_inj);\n\tpr_err(\"%-20s%08x\\n\", \"event_inj_err:\", control->event_inj_err);\n\tpr_err(\"%-20s%lld\\n\", \"lbr_ctl:\", control->lbr_ctl);\n\tpr_err(\"%-20s%016llx\\n\", \"next_rip:\", control->next_rip);\n\tpr_err(\"%-20s%016llx\\n\", \"avic_backing_page:\", control->avic_backing_page);\n\tpr_err(\"%-20s%016llx\\n\", \"avic_logical_id:\", control->avic_logical_id);\n\tpr_err(\"%-20s%016llx\\n\", \"avic_physical_id:\", control->avic_physical_id);\n\tpr_err(\"VMCB State Save Area:\\n\");\n\tpr_err(\"%-5s s: %04x a: %04x l: %08x b: %016llx\\n\",\n\t       \"es:\",\n\t       save->es.selector, save->es.attrib,\n\t       save->es.limit, save->es.base);\n\tpr_err(\"%-5s s: %04x a: %04x l: %08x b: %016llx\\n\",\n\t       \"cs:\",\n\t       save->cs.selector, save->cs.attrib,\n\t       save->cs.limit, save->cs.base);\n\tpr_err(\"%-5s s: %04x a: %04x l: %08x b: %016llx\\n\",\n\t       \"ss:\",\n\t       save->ss.selector, save->ss.attrib,\n\t       save->ss.limit, save->ss.base);\n\tpr_err(\"%-5s s: %04x a: %04x l: %08x b: %016llx\\n\",\n\t       \"ds:\",\n\t       save->ds.selector, save->ds.attrib,\n\t       save->ds.limit, save->ds.base);\n\tpr_err(\"%-5s s: %04x a: %04x l: %08x b: %016llx\\n\",\n\t       \"fs:\",\n\t       save->fs.selector, save->fs.attrib,\n\t       save->fs.limit, save->fs.base);\n\tpr_err(\"%-5s s: %04x a: %04x l: %08x b: %016llx\\n\",\n\t       \"gs:\",\n\t       save->gs.selector, save->gs.attrib,\n\t       save->gs.limit, save->gs.base);\n\tpr_err(\"%-5s s: %04x a: %04x l: %08x b: %016llx\\n\",\n\t       \"gdtr:\",\n\t       save->gdtr.selector, save->gdtr.attrib,\n\t       save->gdtr.limit, save->gdtr.base);\n\tpr_err(\"%-5s s: %04x a: %04x l: %08x b: %016llx\\n\",\n\t       \"ldtr:\",\n\t       save->ldtr.selector, save->ldtr.attrib,\n\t       save->ldtr.limit, save->ldtr.base);\n\tpr_err(\"%-5s s: %04x a: %04x l: %08x b: %016llx\\n\",\n\t       \"idtr:\",\n\t       save->idtr.selector, save->idtr.attrib,\n\t       save->idtr.limit, save->idtr.base);\n\tpr_err(\"%-5s s: %04x a: %04x l: %08x b: %016llx\\n\",\n\t       \"tr:\",\n\t       save->tr.selector, save->tr.attrib,\n\t       save->tr.limit, save->tr.base);\n\tpr_err(\"cpl:            %d                efer:         %016llx\\n\",\n\t\tsave->cpl, save->efer);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"cr0:\", save->cr0, \"cr2:\", save->cr2);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"cr3:\", save->cr3, \"cr4:\", save->cr4);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"dr6:\", save->dr6, \"dr7:\", save->dr7);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"rip:\", save->rip, \"rflags:\", save->rflags);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"rsp:\", save->rsp, \"rax:\", save->rax);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"star:\", save->star, \"lstar:\", save->lstar);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"cstar:\", save->cstar, \"sfmask:\", save->sfmask);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"kernel_gs_base:\", save->kernel_gs_base,\n\t       \"sysenter_cs:\", save->sysenter_cs);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"sysenter_esp:\", save->sysenter_esp,\n\t       \"sysenter_eip:\", save->sysenter_eip);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"gpat:\", save->g_pat, \"dbgctl:\", save->dbgctl);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"br_from:\", save->br_from, \"br_to:\", save->br_to);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"excp_from:\", save->last_excp_from,\n\t       \"excp_to:\", save->last_excp_to);\n}"
  },
  {
    "function_name": "avic_unaccelerated_access_interception",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "3835-3858",
    "snippet": "static int avic_unaccelerated_access_interception(struct vcpu_svm *svm)\n{\n\tint ret = 0;\n\tu32 offset = svm->vmcb->control.exit_info_1 &\n\t\t     AVIC_UNACCEL_ACCESS_OFFSET_MASK;\n\tu32 vector = svm->vmcb->control.exit_info_2 &\n\t\t     AVIC_UNACCEL_ACCESS_VECTOR_MASK;\n\tbool write = (svm->vmcb->control.exit_info_1 >> 32) &\n\t\t     AVIC_UNACCEL_ACCESS_WRITE_MASK;\n\tbool trap = is_avic_unaccelerated_access_trap(offset);\n\n\ttrace_kvm_avic_unaccelerated_access(svm->vcpu.vcpu_id, offset,\n\t\t\t\t\t    trap, write, vector);\n\tif (trap) {\n\t\t/* Handling Trap */\n\t\tWARN_ONCE(!write, \"svm: Handling trap read.\\n\");\n\t\tret = avic_unaccel_trap_write(svm);\n\t} else {\n\t\t/* Handling Fault */\n\t\tret = (emulate_instruction(&svm->vcpu, 0) == EMULATE_DONE);\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define AVIC_UNACCEL_ACCESS_VECTOR_MASK\t\t0xFFFFFFFF",
      "#define AVIC_UNACCEL_ACCESS_OFFSET_MASK\t\t0xFF0",
      "#define AVIC_UNACCEL_ACCESS_WRITE_MASK\t\t1"
    ],
    "globals_used": [
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "emulate_instruction",
          "args": [
            "&svm->vcpu",
            "0"
          ],
          "line": 3854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "avic_unaccel_trap_write",
          "args": [
            "svm"
          ],
          "line": 3851
        },
        "resolved": true,
        "details": {
          "function_name": "avic_unaccel_trap_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "3779-3804",
          "snippet": "static int avic_unaccel_trap_write(struct vcpu_svm *svm)\n{\n\tstruct kvm_lapic *apic = svm->vcpu.arch.apic;\n\tu32 offset = svm->vmcb->control.exit_info_1 &\n\t\t\t\tAVIC_UNACCEL_ACCESS_OFFSET_MASK;\n\n\tswitch (offset) {\n\tcase APIC_ID:\n\t\tif (avic_handle_apic_id_update(&svm->vcpu))\n\t\t\treturn 0;\n\t\tbreak;\n\tcase APIC_LDR:\n\t\tif (avic_handle_ldr_update(&svm->vcpu))\n\t\t\treturn 0;\n\t\tbreak;\n\tcase APIC_DFR:\n\t\tavic_handle_dfr_update(&svm->vcpu);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tkvm_lapic_reg_write(apic, offset, kvm_lapic_get_reg(apic, offset));\n\n\treturn 1;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define AVIC_UNACCEL_ACCESS_OFFSET_MASK\t\t0xFF0"
          ],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define AVIC_UNACCEL_ACCESS_OFFSET_MASK\t\t0xFF0\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic int avic_unaccel_trap_write(struct vcpu_svm *svm)\n{\n\tstruct kvm_lapic *apic = svm->vcpu.arch.apic;\n\tu32 offset = svm->vmcb->control.exit_info_1 &\n\t\t\t\tAVIC_UNACCEL_ACCESS_OFFSET_MASK;\n\n\tswitch (offset) {\n\tcase APIC_ID:\n\t\tif (avic_handle_apic_id_update(&svm->vcpu))\n\t\t\treturn 0;\n\t\tbreak;\n\tcase APIC_LDR:\n\t\tif (avic_handle_ldr_update(&svm->vcpu))\n\t\t\treturn 0;\n\t\tbreak;\n\tcase APIC_DFR:\n\t\tavic_handle_dfr_update(&svm->vcpu);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tkvm_lapic_reg_write(apic, offset, kvm_lapic_get_reg(apic, offset));\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ONCE",
          "args": [
            "!write",
            "\"svm: Handling trap read.\\n\""
          ],
          "line": 3850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_kvm_avic_unaccelerated_access",
          "args": [
            "svm->vcpu.vcpu_id",
            "offset",
            "trap",
            "write",
            "vector"
          ],
          "line": 3846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_avic_unaccelerated_access_trap",
          "args": [
            "offset"
          ],
          "line": 3844
        },
        "resolved": true,
        "details": {
          "function_name": "is_avic_unaccelerated_access_trap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "3806-3833",
          "snippet": "static bool is_avic_unaccelerated_access_trap(u32 offset)\n{\n\tbool ret = false;\n\n\tswitch (offset) {\n\tcase APIC_ID:\n\tcase APIC_EOI:\n\tcase APIC_RRR:\n\tcase APIC_LDR:\n\tcase APIC_DFR:\n\tcase APIC_SPIV:\n\tcase APIC_ESR:\n\tcase APIC_ICR:\n\tcase APIC_LVTT:\n\tcase APIC_LVTTHMR:\n\tcase APIC_LVTPC:\n\tcase APIC_LVT0:\n\tcase APIC_LVT1:\n\tcase APIC_LVTERR:\n\tcase APIC_TMICT:\n\tcase APIC_TDCR:\n\t\tret = true;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic bool is_avic_unaccelerated_access_trap(u32 offset)\n{\n\tbool ret = false;\n\n\tswitch (offset) {\n\tcase APIC_ID:\n\tcase APIC_EOI:\n\tcase APIC_RRR:\n\tcase APIC_LDR:\n\tcase APIC_DFR:\n\tcase APIC_SPIV:\n\tcase APIC_ESR:\n\tcase APIC_ICR:\n\tcase APIC_LVTT:\n\tcase APIC_LVTTHMR:\n\tcase APIC_LVTPC:\n\tcase APIC_LVT0:\n\tcase APIC_LVT1:\n\tcase APIC_LVTERR:\n\tcase APIC_TMICT:\n\tcase APIC_TDCR:\n\t\tret = true;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define AVIC_UNACCEL_ACCESS_VECTOR_MASK\t\t0xFFFFFFFF\n#define AVIC_UNACCEL_ACCESS_OFFSET_MASK\t\t0xFF0\n#define AVIC_UNACCEL_ACCESS_WRITE_MASK\t\t1\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic int avic_unaccelerated_access_interception(struct vcpu_svm *svm)\n{\n\tint ret = 0;\n\tu32 offset = svm->vmcb->control.exit_info_1 &\n\t\t     AVIC_UNACCEL_ACCESS_OFFSET_MASK;\n\tu32 vector = svm->vmcb->control.exit_info_2 &\n\t\t     AVIC_UNACCEL_ACCESS_VECTOR_MASK;\n\tbool write = (svm->vmcb->control.exit_info_1 >> 32) &\n\t\t     AVIC_UNACCEL_ACCESS_WRITE_MASK;\n\tbool trap = is_avic_unaccelerated_access_trap(offset);\n\n\ttrace_kvm_avic_unaccelerated_access(svm->vcpu.vcpu_id, offset,\n\t\t\t\t\t    trap, write, vector);\n\tif (trap) {\n\t\t/* Handling Trap */\n\t\tWARN_ONCE(!write, \"svm: Handling trap read.\\n\");\n\t\tret = avic_unaccel_trap_write(svm);\n\t} else {\n\t\t/* Handling Fault */\n\t\tret = (emulate_instruction(&svm->vcpu, 0) == EMULATE_DONE);\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "is_avic_unaccelerated_access_trap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "3806-3833",
    "snippet": "static bool is_avic_unaccelerated_access_trap(u32 offset)\n{\n\tbool ret = false;\n\n\tswitch (offset) {\n\tcase APIC_ID:\n\tcase APIC_EOI:\n\tcase APIC_RRR:\n\tcase APIC_LDR:\n\tcase APIC_DFR:\n\tcase APIC_SPIV:\n\tcase APIC_ESR:\n\tcase APIC_ICR:\n\tcase APIC_LVTT:\n\tcase APIC_LVTTHMR:\n\tcase APIC_LVTPC:\n\tcase APIC_LVT0:\n\tcase APIC_LVT1:\n\tcase APIC_LVTERR:\n\tcase APIC_TMICT:\n\tcase APIC_TDCR:\n\t\tret = true;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic bool is_avic_unaccelerated_access_trap(u32 offset)\n{\n\tbool ret = false;\n\n\tswitch (offset) {\n\tcase APIC_ID:\n\tcase APIC_EOI:\n\tcase APIC_RRR:\n\tcase APIC_LDR:\n\tcase APIC_DFR:\n\tcase APIC_SPIV:\n\tcase APIC_ESR:\n\tcase APIC_ICR:\n\tcase APIC_LVTT:\n\tcase APIC_LVTTHMR:\n\tcase APIC_LVTPC:\n\tcase APIC_LVT0:\n\tcase APIC_LVT1:\n\tcase APIC_LVTERR:\n\tcase APIC_TMICT:\n\tcase APIC_TDCR:\n\t\tret = true;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "avic_unaccel_trap_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "3779-3804",
    "snippet": "static int avic_unaccel_trap_write(struct vcpu_svm *svm)\n{\n\tstruct kvm_lapic *apic = svm->vcpu.arch.apic;\n\tu32 offset = svm->vmcb->control.exit_info_1 &\n\t\t\t\tAVIC_UNACCEL_ACCESS_OFFSET_MASK;\n\n\tswitch (offset) {\n\tcase APIC_ID:\n\t\tif (avic_handle_apic_id_update(&svm->vcpu))\n\t\t\treturn 0;\n\t\tbreak;\n\tcase APIC_LDR:\n\t\tif (avic_handle_ldr_update(&svm->vcpu))\n\t\t\treturn 0;\n\t\tbreak;\n\tcase APIC_DFR:\n\t\tavic_handle_dfr_update(&svm->vcpu);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tkvm_lapic_reg_write(apic, offset, kvm_lapic_get_reg(apic, offset));\n\n\treturn 1;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define AVIC_UNACCEL_ACCESS_OFFSET_MASK\t\t0xFF0"
    ],
    "globals_used": [
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_lapic_reg_write",
          "args": [
            "apic",
            "offset",
            "kvm_lapic_get_reg(apic, offset)"
          ],
          "line": 3801
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_reg_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "1406-1536",
          "snippet": "int kvm_lapic_reg_write(struct kvm_lapic *apic, u32 reg, u32 val)\n{\n\tint ret = 0;\n\n\ttrace_kvm_apic_write(reg, val);\n\n\tswitch (reg) {\n\tcase APIC_ID:\t\t/* Local APIC ID */\n\t\tif (!apic_x2apic_mode(apic))\n\t\t\tkvm_apic_set_id(apic, val >> 24);\n\t\telse\n\t\t\tret = 1;\n\t\tbreak;\n\n\tcase APIC_TASKPRI:\n\t\treport_tpr_access(apic, true);\n\t\tapic_set_tpr(apic, val & 0xff);\n\t\tbreak;\n\n\tcase APIC_EOI:\n\t\tapic_set_eoi(apic);\n\t\tbreak;\n\n\tcase APIC_LDR:\n\t\tif (!apic_x2apic_mode(apic))\n\t\t\tkvm_apic_set_ldr(apic, val & APIC_LDR_MASK);\n\t\telse\n\t\t\tret = 1;\n\t\tbreak;\n\n\tcase APIC_DFR:\n\t\tif (!apic_x2apic_mode(apic)) {\n\t\t\tkvm_lapic_set_reg(apic, APIC_DFR, val | 0x0FFFFFFF);\n\t\t\trecalculate_apic_map(apic->vcpu->kvm);\n\t\t} else\n\t\t\tret = 1;\n\t\tbreak;\n\n\tcase APIC_SPIV: {\n\t\tu32 mask = 0x3ff;\n\t\tif (kvm_lapic_get_reg(apic, APIC_LVR) & APIC_LVR_DIRECTED_EOI)\n\t\t\tmask |= APIC_SPIV_DIRECTED_EOI;\n\t\tapic_set_spiv(apic, val & mask);\n\t\tif (!(val & APIC_SPIV_APIC_ENABLED)) {\n\t\t\tint i;\n\t\t\tu32 lvt_val;\n\n\t\t\tfor (i = 0; i < KVM_APIC_LVT_NUM; i++) {\n\t\t\t\tlvt_val = kvm_lapic_get_reg(apic,\n\t\t\t\t\t\t       APIC_LVTT + 0x10 * i);\n\t\t\t\tkvm_lapic_set_reg(apic, APIC_LVTT + 0x10 * i,\n\t\t\t\t\t     lvt_val | APIC_LVT_MASKED);\n\t\t\t}\n\t\t\tapic_update_lvtt(apic);\n\t\t\tatomic_set(&apic->lapic_timer.pending, 0);\n\n\t\t}\n\t\tbreak;\n\t}\n\tcase APIC_ICR:\n\t\t/* No delay here, so we always clear the pending bit */\n\t\tkvm_lapic_set_reg(apic, APIC_ICR, val & ~(1 << 12));\n\t\tapic_send_ipi(apic);\n\t\tbreak;\n\n\tcase APIC_ICR2:\n\t\tif (!apic_x2apic_mode(apic))\n\t\t\tval &= 0xff000000;\n\t\tkvm_lapic_set_reg(apic, APIC_ICR2, val);\n\t\tbreak;\n\n\tcase APIC_LVT0:\n\t\tapic_manage_nmi_watchdog(apic, val);\n\tcase APIC_LVTTHMR:\n\tcase APIC_LVTPC:\n\tcase APIC_LVT1:\n\tcase APIC_LVTERR:\n\t\t/* TODO: Check vector */\n\t\tif (!kvm_apic_sw_enabled(apic))\n\t\t\tval |= APIC_LVT_MASKED;\n\n\t\tval &= apic_lvt_mask[(reg - APIC_LVTT) >> 4];\n\t\tkvm_lapic_set_reg(apic, reg, val);\n\n\t\tbreak;\n\n\tcase APIC_LVTT:\n\t\tif (!kvm_apic_sw_enabled(apic))\n\t\t\tval |= APIC_LVT_MASKED;\n\t\tval &= (apic_lvt_mask[0] | apic->lapic_timer.timer_mode_mask);\n\t\tkvm_lapic_set_reg(apic, APIC_LVTT, val);\n\t\tapic_update_lvtt(apic);\n\t\tbreak;\n\n\tcase APIC_TMICT:\n\t\tif (apic_lvtt_tscdeadline(apic))\n\t\t\tbreak;\n\n\t\thrtimer_cancel(&apic->lapic_timer.timer);\n\t\tkvm_lapic_set_reg(apic, APIC_TMICT, val);\n\t\tstart_apic_timer(apic);\n\t\tbreak;\n\n\tcase APIC_TDCR:\n\t\tif (val & 4)\n\t\t\tapic_debug(\"KVM_WRITE:TDCR %x\\n\", val);\n\t\tkvm_lapic_set_reg(apic, APIC_TDCR, val);\n\t\tupdate_divide_count(apic);\n\t\tbreak;\n\n\tcase APIC_ESR:\n\t\tif (apic_x2apic_mode(apic) && val != 0) {\n\t\t\tapic_debug(\"KVM_WRITE:ESR not zero %x\\n\", val);\n\t\t\tret = 1;\n\t\t}\n\t\tbreak;\n\n\tcase APIC_SELF_IPI:\n\t\tif (apic_x2apic_mode(apic)) {\n\t\t\tkvm_lapic_reg_write(apic, APIC_ICR, 0x40000 | (val & 0xff));\n\t\t} else\n\t\t\tret = 1;\n\t\tbreak;\n\tdefault:\n\t\tret = 1;\n\t\tbreak;\n\t}\n\tif (ret)\n\t\tapic_debug(\"Local APIC Write to read-only register %x\\n\", reg);\n\treturn ret;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int apic_lvt_mask[KVM_APIC_LVT_NUM] = {\n\tLVT_MASK ,      /* part LVTT mask, timer mode mask added at runtime */\n\tLVT_MASK | APIC_MODE_MASK,\t/* LVTTHMR */\n\tLVT_MASK | APIC_MODE_MASK,\t/* LVTPC */\n\tLINT_MASK, LINT_MASK,\t/* LVT0-1 */\n\tLVT_MASK\t\t/* LVTERR */\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic const unsigned int apic_lvt_mask[KVM_APIC_LVT_NUM] = {\n\tLVT_MASK ,      /* part LVTT mask, timer mode mask added at runtime */\n\tLVT_MASK | APIC_MODE_MASK,\t/* LVTTHMR */\n\tLVT_MASK | APIC_MODE_MASK,\t/* LVTPC */\n\tLINT_MASK, LINT_MASK,\t/* LVT0-1 */\n\tLVT_MASK\t\t/* LVTERR */\n};\n\nint kvm_lapic_reg_write(struct kvm_lapic *apic, u32 reg, u32 val)\n{\n\tint ret = 0;\n\n\ttrace_kvm_apic_write(reg, val);\n\n\tswitch (reg) {\n\tcase APIC_ID:\t\t/* Local APIC ID */\n\t\tif (!apic_x2apic_mode(apic))\n\t\t\tkvm_apic_set_id(apic, val >> 24);\n\t\telse\n\t\t\tret = 1;\n\t\tbreak;\n\n\tcase APIC_TASKPRI:\n\t\treport_tpr_access(apic, true);\n\t\tapic_set_tpr(apic, val & 0xff);\n\t\tbreak;\n\n\tcase APIC_EOI:\n\t\tapic_set_eoi(apic);\n\t\tbreak;\n\n\tcase APIC_LDR:\n\t\tif (!apic_x2apic_mode(apic))\n\t\t\tkvm_apic_set_ldr(apic, val & APIC_LDR_MASK);\n\t\telse\n\t\t\tret = 1;\n\t\tbreak;\n\n\tcase APIC_DFR:\n\t\tif (!apic_x2apic_mode(apic)) {\n\t\t\tkvm_lapic_set_reg(apic, APIC_DFR, val | 0x0FFFFFFF);\n\t\t\trecalculate_apic_map(apic->vcpu->kvm);\n\t\t} else\n\t\t\tret = 1;\n\t\tbreak;\n\n\tcase APIC_SPIV: {\n\t\tu32 mask = 0x3ff;\n\t\tif (kvm_lapic_get_reg(apic, APIC_LVR) & APIC_LVR_DIRECTED_EOI)\n\t\t\tmask |= APIC_SPIV_DIRECTED_EOI;\n\t\tapic_set_spiv(apic, val & mask);\n\t\tif (!(val & APIC_SPIV_APIC_ENABLED)) {\n\t\t\tint i;\n\t\t\tu32 lvt_val;\n\n\t\t\tfor (i = 0; i < KVM_APIC_LVT_NUM; i++) {\n\t\t\t\tlvt_val = kvm_lapic_get_reg(apic,\n\t\t\t\t\t\t       APIC_LVTT + 0x10 * i);\n\t\t\t\tkvm_lapic_set_reg(apic, APIC_LVTT + 0x10 * i,\n\t\t\t\t\t     lvt_val | APIC_LVT_MASKED);\n\t\t\t}\n\t\t\tapic_update_lvtt(apic);\n\t\t\tatomic_set(&apic->lapic_timer.pending, 0);\n\n\t\t}\n\t\tbreak;\n\t}\n\tcase APIC_ICR:\n\t\t/* No delay here, so we always clear the pending bit */\n\t\tkvm_lapic_set_reg(apic, APIC_ICR, val & ~(1 << 12));\n\t\tapic_send_ipi(apic);\n\t\tbreak;\n\n\tcase APIC_ICR2:\n\t\tif (!apic_x2apic_mode(apic))\n\t\t\tval &= 0xff000000;\n\t\tkvm_lapic_set_reg(apic, APIC_ICR2, val);\n\t\tbreak;\n\n\tcase APIC_LVT0:\n\t\tapic_manage_nmi_watchdog(apic, val);\n\tcase APIC_LVTTHMR:\n\tcase APIC_LVTPC:\n\tcase APIC_LVT1:\n\tcase APIC_LVTERR:\n\t\t/* TODO: Check vector */\n\t\tif (!kvm_apic_sw_enabled(apic))\n\t\t\tval |= APIC_LVT_MASKED;\n\n\t\tval &= apic_lvt_mask[(reg - APIC_LVTT) >> 4];\n\t\tkvm_lapic_set_reg(apic, reg, val);\n\n\t\tbreak;\n\n\tcase APIC_LVTT:\n\t\tif (!kvm_apic_sw_enabled(apic))\n\t\t\tval |= APIC_LVT_MASKED;\n\t\tval &= (apic_lvt_mask[0] | apic->lapic_timer.timer_mode_mask);\n\t\tkvm_lapic_set_reg(apic, APIC_LVTT, val);\n\t\tapic_update_lvtt(apic);\n\t\tbreak;\n\n\tcase APIC_TMICT:\n\t\tif (apic_lvtt_tscdeadline(apic))\n\t\t\tbreak;\n\n\t\thrtimer_cancel(&apic->lapic_timer.timer);\n\t\tkvm_lapic_set_reg(apic, APIC_TMICT, val);\n\t\tstart_apic_timer(apic);\n\t\tbreak;\n\n\tcase APIC_TDCR:\n\t\tif (val & 4)\n\t\t\tapic_debug(\"KVM_WRITE:TDCR %x\\n\", val);\n\t\tkvm_lapic_set_reg(apic, APIC_TDCR, val);\n\t\tupdate_divide_count(apic);\n\t\tbreak;\n\n\tcase APIC_ESR:\n\t\tif (apic_x2apic_mode(apic) && val != 0) {\n\t\t\tapic_debug(\"KVM_WRITE:ESR not zero %x\\n\", val);\n\t\t\tret = 1;\n\t\t}\n\t\tbreak;\n\n\tcase APIC_SELF_IPI:\n\t\tif (apic_x2apic_mode(apic)) {\n\t\t\tkvm_lapic_reg_write(apic, APIC_ICR, 0x40000 | (val & 0xff));\n\t\t} else\n\t\t\tret = 1;\n\t\tbreak;\n\tdefault:\n\t\tret = 1;\n\t\tbreak;\n\t}\n\tif (ret)\n\t\tapic_debug(\"Local APIC Write to read-only register %x\\n\", reg);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_lapic_get_reg",
          "args": [
            "apic",
            "offset"
          ],
          "line": 3801
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_get_reg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.h",
          "lines": "129-132",
          "snippet": "static inline u32 kvm_lapic_get_reg(struct kvm_lapic *apic, int reg_off)\n{\n\treturn *((u32 *) (apic->regs + reg_off));\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline u32 kvm_lapic_get_reg(struct kvm_lapic *apic, int reg_off)\n{\n\treturn *((u32 *) (apic->regs + reg_off));\n}"
        }
      },
      {
        "call_info": {
          "callee": "avic_handle_dfr_update",
          "args": [
            "&svm->vcpu"
          ],
          "line": 3795
        },
        "resolved": true,
        "details": {
          "function_name": "avic_handle_dfr_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "3756-3777",
          "snippet": "static int avic_handle_dfr_update(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tstruct kvm_arch *vm_data = &vcpu->kvm->arch;\n\tu32 dfr = kvm_lapic_get_reg(vcpu->arch.apic, APIC_DFR);\n\tu32 mod = (dfr >> 28) & 0xf;\n\n\t/*\n\t * We assume that all local APICs are using the same type.\n\t * If this changes, we need to flush the AVIC logical\n\t * APID id table.\n\t */\n\tif (vm_data->ldr_mode == mod)\n\t\treturn 0;\n\n\tclear_page(page_address(vm_data->avic_logical_id_table_page));\n\tvm_data->ldr_mode = mod;\n\n\tif (svm->ldr_reg)\n\t\tavic_handle_ldr_update(vcpu);\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic int avic_handle_dfr_update(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tstruct kvm_arch *vm_data = &vcpu->kvm->arch;\n\tu32 dfr = kvm_lapic_get_reg(vcpu->arch.apic, APIC_DFR);\n\tu32 mod = (dfr >> 28) & 0xf;\n\n\t/*\n\t * We assume that all local APICs are using the same type.\n\t * If this changes, we need to flush the AVIC logical\n\t * APID id table.\n\t */\n\tif (vm_data->ldr_mode == mod)\n\t\treturn 0;\n\n\tclear_page(page_address(vm_data->avic_logical_id_table_page));\n\tvm_data->ldr_mode = mod;\n\n\tif (svm->ldr_reg)\n\t\tavic_handle_ldr_update(vcpu);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "avic_handle_ldr_update",
          "args": [
            "&svm->vcpu"
          ],
          "line": 3791
        },
        "resolved": true,
        "details": {
          "function_name": "avic_handle_ldr_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "3707-3724",
          "snippet": "static int avic_handle_ldr_update(struct kvm_vcpu *vcpu)\n{\n\tint ret;\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tu32 ldr = kvm_lapic_get_reg(vcpu->arch.apic, APIC_LDR);\n\n\tif (!ldr)\n\t\treturn 1;\n\n\tret = avic_ldr_write(vcpu, vcpu->vcpu_id, ldr, true);\n\tif (ret && svm->ldr_reg) {\n\t\tavic_ldr_write(vcpu, 0, svm->ldr_reg, false);\n\t\tsvm->ldr_reg = 0;\n\t} else {\n\t\tsvm->ldr_reg = ldr;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic int avic_handle_ldr_update(struct kvm_vcpu *vcpu)\n{\n\tint ret;\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tu32 ldr = kvm_lapic_get_reg(vcpu->arch.apic, APIC_LDR);\n\n\tif (!ldr)\n\t\treturn 1;\n\n\tret = avic_ldr_write(vcpu, vcpu->vcpu_id, ldr, true);\n\tif (ret && svm->ldr_reg) {\n\t\tavic_ldr_write(vcpu, 0, svm->ldr_reg, false);\n\t\tsvm->ldr_reg = 0;\n\t} else {\n\t\tsvm->ldr_reg = ldr;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "avic_handle_apic_id_update",
          "args": [
            "&svm->vcpu"
          ],
          "line": 3787
        },
        "resolved": true,
        "details": {
          "function_name": "avic_handle_apic_id_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "3726-3754",
          "snippet": "static int avic_handle_apic_id_update(struct kvm_vcpu *vcpu)\n{\n\tu64 *old, *new;\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tu32 apic_id_reg = kvm_lapic_get_reg(vcpu->arch.apic, APIC_ID);\n\tu32 id = (apic_id_reg >> 24) & 0xff;\n\n\tif (vcpu->vcpu_id == id)\n\t\treturn 0;\n\n\told = avic_get_physical_id_entry(vcpu, vcpu->vcpu_id);\n\tnew = avic_get_physical_id_entry(vcpu, id);\n\tif (!new || !old)\n\t\treturn 1;\n\n\t/* We need to move physical_id_entry to new offset */\n\t*new = *old;\n\t*old = 0ULL;\n\tto_svm(vcpu)->avic_physical_id_cache = new;\n\n\t/*\n\t * Also update the guest physical APIC ID in the logical\n\t * APIC ID table entry if already setup the LDR.\n\t */\n\tif (svm->ldr_reg)\n\t\tavic_handle_ldr_update(vcpu);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic int avic_handle_apic_id_update(struct kvm_vcpu *vcpu)\n{\n\tu64 *old, *new;\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tu32 apic_id_reg = kvm_lapic_get_reg(vcpu->arch.apic, APIC_ID);\n\tu32 id = (apic_id_reg >> 24) & 0xff;\n\n\tif (vcpu->vcpu_id == id)\n\t\treturn 0;\n\n\told = avic_get_physical_id_entry(vcpu, vcpu->vcpu_id);\n\tnew = avic_get_physical_id_entry(vcpu, id);\n\tif (!new || !old)\n\t\treturn 1;\n\n\t/* We need to move physical_id_entry to new offset */\n\t*new = *old;\n\t*old = 0ULL;\n\tto_svm(vcpu)->avic_physical_id_cache = new;\n\n\t/*\n\t * Also update the guest physical APIC ID in the logical\n\t * APIC ID table entry if already setup the LDR.\n\t */\n\tif (svm->ldr_reg)\n\t\tavic_handle_ldr_update(vcpu);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define AVIC_UNACCEL_ACCESS_OFFSET_MASK\t\t0xFF0\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic int avic_unaccel_trap_write(struct vcpu_svm *svm)\n{\n\tstruct kvm_lapic *apic = svm->vcpu.arch.apic;\n\tu32 offset = svm->vmcb->control.exit_info_1 &\n\t\t\t\tAVIC_UNACCEL_ACCESS_OFFSET_MASK;\n\n\tswitch (offset) {\n\tcase APIC_ID:\n\t\tif (avic_handle_apic_id_update(&svm->vcpu))\n\t\t\treturn 0;\n\t\tbreak;\n\tcase APIC_LDR:\n\t\tif (avic_handle_ldr_update(&svm->vcpu))\n\t\t\treturn 0;\n\t\tbreak;\n\tcase APIC_DFR:\n\t\tavic_handle_dfr_update(&svm->vcpu);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tkvm_lapic_reg_write(apic, offset, kvm_lapic_get_reg(apic, offset));\n\n\treturn 1;\n}"
  },
  {
    "function_name": "avic_handle_dfr_update",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "3756-3777",
    "snippet": "static int avic_handle_dfr_update(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tstruct kvm_arch *vm_data = &vcpu->kvm->arch;\n\tu32 dfr = kvm_lapic_get_reg(vcpu->arch.apic, APIC_DFR);\n\tu32 mod = (dfr >> 28) & 0xf;\n\n\t/*\n\t * We assume that all local APICs are using the same type.\n\t * If this changes, we need to flush the AVIC logical\n\t * APID id table.\n\t */\n\tif (vm_data->ldr_mode == mod)\n\t\treturn 0;\n\n\tclear_page(page_address(vm_data->avic_logical_id_table_page));\n\tvm_data->ldr_mode = mod;\n\n\tif (svm->ldr_reg)\n\t\tavic_handle_ldr_update(vcpu);\n\treturn 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "avic_handle_ldr_update",
          "args": [
            "vcpu"
          ],
          "line": 3775
        },
        "resolved": true,
        "details": {
          "function_name": "avic_handle_ldr_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "3707-3724",
          "snippet": "static int avic_handle_ldr_update(struct kvm_vcpu *vcpu)\n{\n\tint ret;\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tu32 ldr = kvm_lapic_get_reg(vcpu->arch.apic, APIC_LDR);\n\n\tif (!ldr)\n\t\treturn 1;\n\n\tret = avic_ldr_write(vcpu, vcpu->vcpu_id, ldr, true);\n\tif (ret && svm->ldr_reg) {\n\t\tavic_ldr_write(vcpu, 0, svm->ldr_reg, false);\n\t\tsvm->ldr_reg = 0;\n\t} else {\n\t\tsvm->ldr_reg = ldr;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic int avic_handle_ldr_update(struct kvm_vcpu *vcpu)\n{\n\tint ret;\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tu32 ldr = kvm_lapic_get_reg(vcpu->arch.apic, APIC_LDR);\n\n\tif (!ldr)\n\t\treturn 1;\n\n\tret = avic_ldr_write(vcpu, vcpu->vcpu_id, ldr, true);\n\tif (ret && svm->ldr_reg) {\n\t\tavic_ldr_write(vcpu, 0, svm->ldr_reg, false);\n\t\tsvm->ldr_reg = 0;\n\t} else {\n\t\tsvm->ldr_reg = ldr;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_page",
          "args": [
            "page_address(vm_data->avic_logical_id_table_page)"
          ],
          "line": 3771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "vm_data->avic_logical_id_table_page"
          ],
          "line": 3771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_lapic_get_reg",
          "args": [
            "vcpu->arch.apic",
            "APIC_DFR"
          ],
          "line": 3760
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_get_reg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.h",
          "lines": "129-132",
          "snippet": "static inline u32 kvm_lapic_get_reg(struct kvm_lapic *apic, int reg_off)\n{\n\treturn *((u32 *) (apic->regs + reg_off));\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline u32 kvm_lapic_get_reg(struct kvm_lapic *apic, int reg_off)\n{\n\treturn *((u32 *) (apic->regs + reg_off));\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 3758
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "294-297",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic int avic_handle_dfr_update(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tstruct kvm_arch *vm_data = &vcpu->kvm->arch;\n\tu32 dfr = kvm_lapic_get_reg(vcpu->arch.apic, APIC_DFR);\n\tu32 mod = (dfr >> 28) & 0xf;\n\n\t/*\n\t * We assume that all local APICs are using the same type.\n\t * If this changes, we need to flush the AVIC logical\n\t * APID id table.\n\t */\n\tif (vm_data->ldr_mode == mod)\n\t\treturn 0;\n\n\tclear_page(page_address(vm_data->avic_logical_id_table_page));\n\tvm_data->ldr_mode = mod;\n\n\tif (svm->ldr_reg)\n\t\tavic_handle_ldr_update(vcpu);\n\treturn 0;\n}"
  },
  {
    "function_name": "avic_handle_apic_id_update",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "3726-3754",
    "snippet": "static int avic_handle_apic_id_update(struct kvm_vcpu *vcpu)\n{\n\tu64 *old, *new;\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tu32 apic_id_reg = kvm_lapic_get_reg(vcpu->arch.apic, APIC_ID);\n\tu32 id = (apic_id_reg >> 24) & 0xff;\n\n\tif (vcpu->vcpu_id == id)\n\t\treturn 0;\n\n\told = avic_get_physical_id_entry(vcpu, vcpu->vcpu_id);\n\tnew = avic_get_physical_id_entry(vcpu, id);\n\tif (!new || !old)\n\t\treturn 1;\n\n\t/* We need to move physical_id_entry to new offset */\n\t*new = *old;\n\t*old = 0ULL;\n\tto_svm(vcpu)->avic_physical_id_cache = new;\n\n\t/*\n\t * Also update the guest physical APIC ID in the logical\n\t * APIC ID table entry if already setup the LDR.\n\t */\n\tif (svm->ldr_reg)\n\t\tavic_handle_ldr_update(vcpu);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "avic_handle_ldr_update",
          "args": [
            "vcpu"
          ],
          "line": 3751
        },
        "resolved": true,
        "details": {
          "function_name": "avic_handle_ldr_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "3707-3724",
          "snippet": "static int avic_handle_ldr_update(struct kvm_vcpu *vcpu)\n{\n\tint ret;\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tu32 ldr = kvm_lapic_get_reg(vcpu->arch.apic, APIC_LDR);\n\n\tif (!ldr)\n\t\treturn 1;\n\n\tret = avic_ldr_write(vcpu, vcpu->vcpu_id, ldr, true);\n\tif (ret && svm->ldr_reg) {\n\t\tavic_ldr_write(vcpu, 0, svm->ldr_reg, false);\n\t\tsvm->ldr_reg = 0;\n\t} else {\n\t\tsvm->ldr_reg = ldr;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic int avic_handle_ldr_update(struct kvm_vcpu *vcpu)\n{\n\tint ret;\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tu32 ldr = kvm_lapic_get_reg(vcpu->arch.apic, APIC_LDR);\n\n\tif (!ldr)\n\t\treturn 1;\n\n\tret = avic_ldr_write(vcpu, vcpu->vcpu_id, ldr, true);\n\tif (ret && svm->ldr_reg) {\n\t\tavic_ldr_write(vcpu, 0, svm->ldr_reg, false);\n\t\tsvm->ldr_reg = 0;\n\t} else {\n\t\tsvm->ldr_reg = ldr;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 3744
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "294-297",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "avic_get_physical_id_entry",
          "args": [
            "vcpu",
            "id"
          ],
          "line": 3737
        },
        "resolved": true,
        "details": {
          "function_name": "avic_get_physical_id_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "1203-1214",
          "snippet": "static u64 *avic_get_physical_id_entry(struct kvm_vcpu *vcpu, int index)\n{\n\tu64 *avic_physical_id_table;\n\tstruct kvm_arch *vm_data = &vcpu->kvm->arch;\n\n\tif (index >= AVIC_MAX_PHYSICAL_ID_COUNT)\n\t\treturn NULL;\n\n\tavic_physical_id_table = page_address(vm_data->avic_physical_id_table_page);\n\n\treturn &avic_physical_id_table[index];\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define AVIC_MAX_PHYSICAL_ID_COUNT\t255"
          ],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define AVIC_MAX_PHYSICAL_ID_COUNT\t255\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\n\nstatic u64 *avic_get_physical_id_entry(struct kvm_vcpu *vcpu, int index)\n{\n\tu64 *avic_physical_id_table;\n\tstruct kvm_arch *vm_data = &vcpu->kvm->arch;\n\n\tif (index >= AVIC_MAX_PHYSICAL_ID_COUNT)\n\t\treturn NULL;\n\n\tavic_physical_id_table = page_address(vm_data->avic_physical_id_table_page);\n\n\treturn &avic_physical_id_table[index];\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_lapic_get_reg",
          "args": [
            "vcpu->arch.apic",
            "APIC_ID"
          ],
          "line": 3730
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_get_reg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.h",
          "lines": "129-132",
          "snippet": "static inline u32 kvm_lapic_get_reg(struct kvm_lapic *apic, int reg_off)\n{\n\treturn *((u32 *) (apic->regs + reg_off));\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline u32 kvm_lapic_get_reg(struct kvm_lapic *apic, int reg_off)\n{\n\treturn *((u32 *) (apic->regs + reg_off));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic int avic_handle_apic_id_update(struct kvm_vcpu *vcpu)\n{\n\tu64 *old, *new;\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tu32 apic_id_reg = kvm_lapic_get_reg(vcpu->arch.apic, APIC_ID);\n\tu32 id = (apic_id_reg >> 24) & 0xff;\n\n\tif (vcpu->vcpu_id == id)\n\t\treturn 0;\n\n\told = avic_get_physical_id_entry(vcpu, vcpu->vcpu_id);\n\tnew = avic_get_physical_id_entry(vcpu, id);\n\tif (!new || !old)\n\t\treturn 1;\n\n\t/* We need to move physical_id_entry to new offset */\n\t*new = *old;\n\t*old = 0ULL;\n\tto_svm(vcpu)->avic_physical_id_cache = new;\n\n\t/*\n\t * Also update the guest physical APIC ID in the logical\n\t * APIC ID table entry if already setup the LDR.\n\t */\n\tif (svm->ldr_reg)\n\t\tavic_handle_ldr_update(vcpu);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "avic_handle_ldr_update",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "3707-3724",
    "snippet": "static int avic_handle_ldr_update(struct kvm_vcpu *vcpu)\n{\n\tint ret;\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tu32 ldr = kvm_lapic_get_reg(vcpu->arch.apic, APIC_LDR);\n\n\tif (!ldr)\n\t\treturn 1;\n\n\tret = avic_ldr_write(vcpu, vcpu->vcpu_id, ldr, true);\n\tif (ret && svm->ldr_reg) {\n\t\tavic_ldr_write(vcpu, 0, svm->ldr_reg, false);\n\t\tsvm->ldr_reg = 0;\n\t} else {\n\t\tsvm->ldr_reg = ldr;\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "avic_ldr_write",
          "args": [
            "vcpu",
            "0",
            "svm->ldr_reg",
            "false"
          ],
          "line": 3718
        },
        "resolved": true,
        "details": {
          "function_name": "avic_ldr_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "3684-3705",
          "snippet": "static int avic_ldr_write(struct kvm_vcpu *vcpu, u8 g_physical_id, u32 ldr,\n\t\t\t  bool valid)\n{\n\tbool flat;\n\tu32 *entry, new_entry;\n\n\tflat = kvm_lapic_get_reg(vcpu->arch.apic, APIC_DFR) == APIC_DFR_FLAT;\n\tentry = avic_get_logical_id_entry(vcpu, ldr, flat);\n\tif (!entry)\n\t\treturn -EINVAL;\n\n\tnew_entry = READ_ONCE(*entry);\n\tnew_entry &= ~AVIC_LOGICAL_ID_ENTRY_GUEST_PHYSICAL_ID_MASK;\n\tnew_entry |= (g_physical_id & AVIC_LOGICAL_ID_ENTRY_GUEST_PHYSICAL_ID_MASK);\n\tif (valid)\n\t\tnew_entry |= AVIC_LOGICAL_ID_ENTRY_VALID_MASK;\n\telse\n\t\tnew_entry &= ~AVIC_LOGICAL_ID_ENTRY_VALID_MASK;\n\tWRITE_ONCE(*entry, new_entry);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define AVIC_LOGICAL_ID_ENTRY_VALID_MASK\t\t(1 << 31)",
            "#define AVIC_LOGICAL_ID_ENTRY_GUEST_PHYSICAL_ID_MASK\t(0xFF)"
          ],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define AVIC_LOGICAL_ID_ENTRY_VALID_MASK\t\t(1 << 31)\n#define AVIC_LOGICAL_ID_ENTRY_GUEST_PHYSICAL_ID_MASK\t(0xFF)\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\n\nstatic int avic_ldr_write(struct kvm_vcpu *vcpu, u8 g_physical_id, u32 ldr,\n\t\t\t  bool valid)\n{\n\tbool flat;\n\tu32 *entry, new_entry;\n\n\tflat = kvm_lapic_get_reg(vcpu->arch.apic, APIC_DFR) == APIC_DFR_FLAT;\n\tentry = avic_get_logical_id_entry(vcpu, ldr, flat);\n\tif (!entry)\n\t\treturn -EINVAL;\n\n\tnew_entry = READ_ONCE(*entry);\n\tnew_entry &= ~AVIC_LOGICAL_ID_ENTRY_GUEST_PHYSICAL_ID_MASK;\n\tnew_entry |= (g_physical_id & AVIC_LOGICAL_ID_ENTRY_GUEST_PHYSICAL_ID_MASK);\n\tif (valid)\n\t\tnew_entry |= AVIC_LOGICAL_ID_ENTRY_VALID_MASK;\n\telse\n\t\tnew_entry &= ~AVIC_LOGICAL_ID_ENTRY_VALID_MASK;\n\tWRITE_ONCE(*entry, new_entry);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_lapic_get_reg",
          "args": [
            "vcpu->arch.apic",
            "APIC_LDR"
          ],
          "line": 3711
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_get_reg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.h",
          "lines": "129-132",
          "snippet": "static inline u32 kvm_lapic_get_reg(struct kvm_lapic *apic, int reg_off)\n{\n\treturn *((u32 *) (apic->regs + reg_off));\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline u32 kvm_lapic_get_reg(struct kvm_lapic *apic, int reg_off)\n{\n\treturn *((u32 *) (apic->regs + reg_off));\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 3710
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "294-297",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic int avic_handle_ldr_update(struct kvm_vcpu *vcpu)\n{\n\tint ret;\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tu32 ldr = kvm_lapic_get_reg(vcpu->arch.apic, APIC_LDR);\n\n\tif (!ldr)\n\t\treturn 1;\n\n\tret = avic_ldr_write(vcpu, vcpu->vcpu_id, ldr, true);\n\tif (ret && svm->ldr_reg) {\n\t\tavic_ldr_write(vcpu, 0, svm->ldr_reg, false);\n\t\tsvm->ldr_reg = 0;\n\t} else {\n\t\tsvm->ldr_reg = ldr;\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "avic_ldr_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "3684-3705",
    "snippet": "static int avic_ldr_write(struct kvm_vcpu *vcpu, u8 g_physical_id, u32 ldr,\n\t\t\t  bool valid)\n{\n\tbool flat;\n\tu32 *entry, new_entry;\n\n\tflat = kvm_lapic_get_reg(vcpu->arch.apic, APIC_DFR) == APIC_DFR_FLAT;\n\tentry = avic_get_logical_id_entry(vcpu, ldr, flat);\n\tif (!entry)\n\t\treturn -EINVAL;\n\n\tnew_entry = READ_ONCE(*entry);\n\tnew_entry &= ~AVIC_LOGICAL_ID_ENTRY_GUEST_PHYSICAL_ID_MASK;\n\tnew_entry |= (g_physical_id & AVIC_LOGICAL_ID_ENTRY_GUEST_PHYSICAL_ID_MASK);\n\tif (valid)\n\t\tnew_entry |= AVIC_LOGICAL_ID_ENTRY_VALID_MASK;\n\telse\n\t\tnew_entry &= ~AVIC_LOGICAL_ID_ENTRY_VALID_MASK;\n\tWRITE_ONCE(*entry, new_entry);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define AVIC_LOGICAL_ID_ENTRY_VALID_MASK\t\t(1 << 31)",
      "#define AVIC_LOGICAL_ID_ENTRY_GUEST_PHYSICAL_ID_MASK\t(0xFF)"
    ],
    "globals_used": [
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "*entry",
            "new_entry"
          ],
          "line": 3702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "*entry"
          ],
          "line": 3695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "avic_get_logical_id_entry",
          "args": [
            "vcpu",
            "ldr",
            "flat"
          ],
          "line": 3691
        },
        "resolved": true,
        "details": {
          "function_name": "avic_get_logical_id_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "3655-3682",
          "snippet": "static u32 *avic_get_logical_id_entry(struct kvm_vcpu *vcpu, u32 ldr, bool flat)\n{\n\tstruct kvm_arch *vm_data = &vcpu->kvm->arch;\n\tint index;\n\tu32 *logical_apic_id_table;\n\tint dlid = GET_APIC_LOGICAL_ID(ldr);\n\n\tif (!dlid)\n\t\treturn NULL;\n\n\tif (flat) { /* flat */\n\t\tindex = ffs(dlid) - 1;\n\t\tif (index > 7)\n\t\t\treturn NULL;\n\t} else { /* cluster */\n\t\tint cluster = (dlid & 0xf0) >> 4;\n\t\tint apic = ffs(dlid & 0x0f) - 1;\n\n\t\tif ((apic < 0) || (apic > 7) ||\n\t\t    (cluster >= 0xf))\n\t\t\treturn NULL;\n\t\tindex = (cluster << 2) + apic;\n\t}\n\n\tlogical_apic_id_table = (u32 *) page_address(vm_data->avic_logical_id_table_page);\n\n\treturn &logical_apic_id_table[index];\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\n\nstatic u32 *avic_get_logical_id_entry(struct kvm_vcpu *vcpu, u32 ldr, bool flat)\n{\n\tstruct kvm_arch *vm_data = &vcpu->kvm->arch;\n\tint index;\n\tu32 *logical_apic_id_table;\n\tint dlid = GET_APIC_LOGICAL_ID(ldr);\n\n\tif (!dlid)\n\t\treturn NULL;\n\n\tif (flat) { /* flat */\n\t\tindex = ffs(dlid) - 1;\n\t\tif (index > 7)\n\t\t\treturn NULL;\n\t} else { /* cluster */\n\t\tint cluster = (dlid & 0xf0) >> 4;\n\t\tint apic = ffs(dlid & 0x0f) - 1;\n\n\t\tif ((apic < 0) || (apic > 7) ||\n\t\t    (cluster >= 0xf))\n\t\t\treturn NULL;\n\t\tindex = (cluster << 2) + apic;\n\t}\n\n\tlogical_apic_id_table = (u32 *) page_address(vm_data->avic_logical_id_table_page);\n\n\treturn &logical_apic_id_table[index];\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_lapic_get_reg",
          "args": [
            "vcpu->arch.apic",
            "APIC_DFR"
          ],
          "line": 3690
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_get_reg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.h",
          "lines": "129-132",
          "snippet": "static inline u32 kvm_lapic_get_reg(struct kvm_lapic *apic, int reg_off)\n{\n\treturn *((u32 *) (apic->regs + reg_off));\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline u32 kvm_lapic_get_reg(struct kvm_lapic *apic, int reg_off)\n{\n\treturn *((u32 *) (apic->regs + reg_off));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define AVIC_LOGICAL_ID_ENTRY_VALID_MASK\t\t(1 << 31)\n#define AVIC_LOGICAL_ID_ENTRY_GUEST_PHYSICAL_ID_MASK\t(0xFF)\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\n\nstatic int avic_ldr_write(struct kvm_vcpu *vcpu, u8 g_physical_id, u32 ldr,\n\t\t\t  bool valid)\n{\n\tbool flat;\n\tu32 *entry, new_entry;\n\n\tflat = kvm_lapic_get_reg(vcpu->arch.apic, APIC_DFR) == APIC_DFR_FLAT;\n\tentry = avic_get_logical_id_entry(vcpu, ldr, flat);\n\tif (!entry)\n\t\treturn -EINVAL;\n\n\tnew_entry = READ_ONCE(*entry);\n\tnew_entry &= ~AVIC_LOGICAL_ID_ENTRY_GUEST_PHYSICAL_ID_MASK;\n\tnew_entry |= (g_physical_id & AVIC_LOGICAL_ID_ENTRY_GUEST_PHYSICAL_ID_MASK);\n\tif (valid)\n\t\tnew_entry |= AVIC_LOGICAL_ID_ENTRY_VALID_MASK;\n\telse\n\t\tnew_entry &= ~AVIC_LOGICAL_ID_ENTRY_VALID_MASK;\n\tWRITE_ONCE(*entry, new_entry);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "avic_get_logical_id_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "3655-3682",
    "snippet": "static u32 *avic_get_logical_id_entry(struct kvm_vcpu *vcpu, u32 ldr, bool flat)\n{\n\tstruct kvm_arch *vm_data = &vcpu->kvm->arch;\n\tint index;\n\tu32 *logical_apic_id_table;\n\tint dlid = GET_APIC_LOGICAL_ID(ldr);\n\n\tif (!dlid)\n\t\treturn NULL;\n\n\tif (flat) { /* flat */\n\t\tindex = ffs(dlid) - 1;\n\t\tif (index > 7)\n\t\t\treturn NULL;\n\t} else { /* cluster */\n\t\tint cluster = (dlid & 0xf0) >> 4;\n\t\tint apic = ffs(dlid & 0x0f) - 1;\n\n\t\tif ((apic < 0) || (apic > 7) ||\n\t\t    (cluster >= 0xf))\n\t\t\treturn NULL;\n\t\tindex = (cluster << 2) + apic;\n\t}\n\n\tlogical_apic_id_table = (u32 *) page_address(vm_data->avic_logical_id_table_page);\n\n\treturn &logical_apic_id_table[index];\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "vm_data->avic_logical_id_table_page"
          ],
          "line": 3679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs",
          "args": [
            "dlid & 0x0f"
          ],
          "line": 3671
        },
        "resolved": true,
        "details": {
          "function_name": "svm_read_tsc_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "1026-1031",
          "snippet": "static u64 svm_read_tsc_offset(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\treturn svm->vmcb->control.tsc_offset;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic u64 svm_read_tsc_offset(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\treturn svm->vmcb->control.tsc_offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GET_APIC_LOGICAL_ID",
          "args": [
            "ldr"
          ],
          "line": 3660
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\n\nstatic u32 *avic_get_logical_id_entry(struct kvm_vcpu *vcpu, u32 ldr, bool flat)\n{\n\tstruct kvm_arch *vm_data = &vcpu->kvm->arch;\n\tint index;\n\tu32 *logical_apic_id_table;\n\tint dlid = GET_APIC_LOGICAL_ID(ldr);\n\n\tif (!dlid)\n\t\treturn NULL;\n\n\tif (flat) { /* flat */\n\t\tindex = ffs(dlid) - 1;\n\t\tif (index > 7)\n\t\t\treturn NULL;\n\t} else { /* cluster */\n\t\tint cluster = (dlid & 0xf0) >> 4;\n\t\tint apic = ffs(dlid & 0x0f) - 1;\n\n\t\tif ((apic < 0) || (apic > 7) ||\n\t\t    (cluster >= 0xf))\n\t\t\treturn NULL;\n\t\tindex = (cluster << 2) + apic;\n\t}\n\n\tlogical_apic_id_table = (u32 *) page_address(vm_data->avic_logical_id_table_page);\n\n\treturn &logical_apic_id_table[index];\n}"
  },
  {
    "function_name": "avic_incomplete_ipi_interception",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "3595-3653",
    "snippet": "static int avic_incomplete_ipi_interception(struct vcpu_svm *svm)\n{\n\tu32 icrh = svm->vmcb->control.exit_info_1 >> 32;\n\tu32 icrl = svm->vmcb->control.exit_info_1;\n\tu32 id = svm->vmcb->control.exit_info_2 >> 32;\n\tu32 index = svm->vmcb->control.exit_info_2 && 0xFF;\n\tstruct kvm_lapic *apic = svm->vcpu.arch.apic;\n\n\ttrace_kvm_avic_incomplete_ipi(svm->vcpu.vcpu_id, icrh, icrl, id, index);\n\n\tswitch (id) {\n\tcase AVIC_IPI_FAILURE_INVALID_INT_TYPE:\n\t\t/*\n\t\t * AVIC hardware handles the generation of\n\t\t * IPIs when the specified Message Type is Fixed\n\t\t * (also known as fixed delivery mode) and\n\t\t * the Trigger Mode is edge-triggered. The hardware\n\t\t * also supports self and broadcast delivery modes\n\t\t * specified via the Destination Shorthand(DSH)\n\t\t * field of the ICRL. Logical and physical APIC ID\n\t\t * formats are supported. All other IPI types cause\n\t\t * a #VMEXIT, which needs to emulated.\n\t\t */\n\t\tkvm_lapic_reg_write(apic, APIC_ICR2, icrh);\n\t\tkvm_lapic_reg_write(apic, APIC_ICR, icrl);\n\t\tbreak;\n\tcase AVIC_IPI_FAILURE_TARGET_NOT_RUNNING: {\n\t\tint i;\n\t\tstruct kvm_vcpu *vcpu;\n\t\tstruct kvm *kvm = svm->vcpu.kvm;\n\t\tstruct kvm_lapic *apic = svm->vcpu.arch.apic;\n\n\t\t/*\n\t\t * At this point, we expect that the AVIC HW has already\n\t\t * set the appropriate IRR bits on the valid target\n\t\t * vcpus. So, we just need to kick the appropriate vcpu.\n\t\t */\n\t\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\t\tbool m = kvm_apic_match_dest(vcpu, apic,\n\t\t\t\t\t\t     icrl & KVM_APIC_SHORT_MASK,\n\t\t\t\t\t\t     GET_APIC_DEST_FIELD(icrh),\n\t\t\t\t\t\t     icrl & KVM_APIC_DEST_MASK);\n\n\t\t\tif (m && !avic_vcpu_is_running(vcpu))\n\t\t\t\tkvm_vcpu_wake_up(vcpu);\n\t\t}\n\t\tbreak;\n\t}\n\tcase AVIC_IPI_FAILURE_INVALID_TARGET:\n\t\tbreak;\n\tcase AVIC_IPI_FAILURE_INVALID_BACKING_PAGE:\n\t\tWARN_ONCE(1, \"Invalid backing page\\n\");\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"Unknown IPI interception\\n\");\n\t}\n\n\treturn 1;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Unknown IPI interception\\n\""
          ],
          "line": 3649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ONCE",
          "args": [
            "1",
            "\"Invalid backing page\\n\""
          ],
          "line": 3646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_wake_up",
          "args": [
            "vcpu"
          ],
          "line": 3639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "avic_vcpu_is_running",
          "args": [
            "vcpu"
          ],
          "line": 3638
        },
        "resolved": true,
        "details": {
          "function_name": "avic_vcpu_is_running",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "305-314",
          "snippet": "static inline bool avic_vcpu_is_running(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tu64 *entry = svm->avic_physical_id_cache;\n\n\tif (!entry)\n\t\treturn false;\n\n\treturn (READ_ONCE(*entry) & AVIC_PHYSICAL_ID_ENTRY_IS_RUNNING_MASK);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define AVIC_PHYSICAL_ID_ENTRY_IS_RUNNING_MASK\t\t(1ULL << 62)"
          ],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define AVIC_PHYSICAL_ID_ENTRY_IS_RUNNING_MASK\t\t(1ULL << 62)\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic inline bool avic_vcpu_is_running(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tu64 *entry = svm->avic_physical_id_cache;\n\n\tif (!entry)\n\t\treturn false;\n\n\treturn (READ_ONCE(*entry) & AVIC_PHYSICAL_ID_ENTRY_IS_RUNNING_MASK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_apic_match_dest",
          "args": [
            "vcpu",
            "apic",
            "icrl & KVM_APIC_SHORT_MASK",
            "GET_APIC_DEST_FIELD(icrh)",
            "icrl & KVM_APIC_DEST_MASK"
          ],
          "line": 3633
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_match_dest",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "618-646",
          "snippet": "bool kvm_apic_match_dest(struct kvm_vcpu *vcpu, struct kvm_lapic *source,\n\t\t\t   int short_hand, unsigned int dest, int dest_mode)\n{\n\tstruct kvm_lapic *target = vcpu->arch.apic;\n\tu32 mda = kvm_apic_mda(dest, source, target);\n\n\tapic_debug(\"target %p, source %p, dest 0x%x, \"\n\t\t   \"dest_mode 0x%x, short_hand 0x%x\\n\",\n\t\t   target, source, dest, dest_mode, short_hand);\n\n\tASSERT(target);\n\tswitch (short_hand) {\n\tcase APIC_DEST_NOSHORT:\n\t\tif (dest_mode == APIC_DEST_PHYSICAL)\n\t\t\treturn kvm_apic_match_physical_addr(target, mda);\n\t\telse\n\t\t\treturn kvm_apic_match_logical_addr(target, mda);\n\tcase APIC_DEST_SELF:\n\t\treturn target == source;\n\tcase APIC_DEST_ALLINC:\n\t\treturn true;\n\tcase APIC_DEST_ALLBUT:\n\t\treturn target != source;\n\tdefault:\n\t\tapic_debug(\"kvm: apic: Bad dest shorthand value %x\\n\",\n\t\t\t   short_hand);\n\t\treturn false;\n\t}\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define APIC_DEST_NOSHORT\t\t0x0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\n#define APIC_DEST_NOSHORT\t\t0x0\n\nbool kvm_apic_match_dest(struct kvm_vcpu *vcpu, struct kvm_lapic *source,\n\t\t\t   int short_hand, unsigned int dest, int dest_mode)\n{\n\tstruct kvm_lapic *target = vcpu->arch.apic;\n\tu32 mda = kvm_apic_mda(dest, source, target);\n\n\tapic_debug(\"target %p, source %p, dest 0x%x, \"\n\t\t   \"dest_mode 0x%x, short_hand 0x%x\\n\",\n\t\t   target, source, dest, dest_mode, short_hand);\n\n\tASSERT(target);\n\tswitch (short_hand) {\n\tcase APIC_DEST_NOSHORT:\n\t\tif (dest_mode == APIC_DEST_PHYSICAL)\n\t\t\treturn kvm_apic_match_physical_addr(target, mda);\n\t\telse\n\t\t\treturn kvm_apic_match_logical_addr(target, mda);\n\tcase APIC_DEST_SELF:\n\t\treturn target == source;\n\tcase APIC_DEST_ALLINC:\n\t\treturn true;\n\tcase APIC_DEST_ALLBUT:\n\t\treturn target != source;\n\tdefault:\n\t\tapic_debug(\"kvm: apic: Bad dest shorthand value %x\\n\",\n\t\t\t   short_hand);\n\t\treturn false;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "GET_APIC_DEST_FIELD",
          "args": [
            "icrh"
          ],
          "line": 3635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_for_each_vcpu",
          "args": [
            "i",
            "vcpu",
            "kvm"
          ],
          "line": 3632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_lapic_reg_write",
          "args": [
            "apic",
            "APIC_ICR",
            "icrl"
          ],
          "line": 3619
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_reg_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "1406-1536",
          "snippet": "int kvm_lapic_reg_write(struct kvm_lapic *apic, u32 reg, u32 val)\n{\n\tint ret = 0;\n\n\ttrace_kvm_apic_write(reg, val);\n\n\tswitch (reg) {\n\tcase APIC_ID:\t\t/* Local APIC ID */\n\t\tif (!apic_x2apic_mode(apic))\n\t\t\tkvm_apic_set_id(apic, val >> 24);\n\t\telse\n\t\t\tret = 1;\n\t\tbreak;\n\n\tcase APIC_TASKPRI:\n\t\treport_tpr_access(apic, true);\n\t\tapic_set_tpr(apic, val & 0xff);\n\t\tbreak;\n\n\tcase APIC_EOI:\n\t\tapic_set_eoi(apic);\n\t\tbreak;\n\n\tcase APIC_LDR:\n\t\tif (!apic_x2apic_mode(apic))\n\t\t\tkvm_apic_set_ldr(apic, val & APIC_LDR_MASK);\n\t\telse\n\t\t\tret = 1;\n\t\tbreak;\n\n\tcase APIC_DFR:\n\t\tif (!apic_x2apic_mode(apic)) {\n\t\t\tkvm_lapic_set_reg(apic, APIC_DFR, val | 0x0FFFFFFF);\n\t\t\trecalculate_apic_map(apic->vcpu->kvm);\n\t\t} else\n\t\t\tret = 1;\n\t\tbreak;\n\n\tcase APIC_SPIV: {\n\t\tu32 mask = 0x3ff;\n\t\tif (kvm_lapic_get_reg(apic, APIC_LVR) & APIC_LVR_DIRECTED_EOI)\n\t\t\tmask |= APIC_SPIV_DIRECTED_EOI;\n\t\tapic_set_spiv(apic, val & mask);\n\t\tif (!(val & APIC_SPIV_APIC_ENABLED)) {\n\t\t\tint i;\n\t\t\tu32 lvt_val;\n\n\t\t\tfor (i = 0; i < KVM_APIC_LVT_NUM; i++) {\n\t\t\t\tlvt_val = kvm_lapic_get_reg(apic,\n\t\t\t\t\t\t       APIC_LVTT + 0x10 * i);\n\t\t\t\tkvm_lapic_set_reg(apic, APIC_LVTT + 0x10 * i,\n\t\t\t\t\t     lvt_val | APIC_LVT_MASKED);\n\t\t\t}\n\t\t\tapic_update_lvtt(apic);\n\t\t\tatomic_set(&apic->lapic_timer.pending, 0);\n\n\t\t}\n\t\tbreak;\n\t}\n\tcase APIC_ICR:\n\t\t/* No delay here, so we always clear the pending bit */\n\t\tkvm_lapic_set_reg(apic, APIC_ICR, val & ~(1 << 12));\n\t\tapic_send_ipi(apic);\n\t\tbreak;\n\n\tcase APIC_ICR2:\n\t\tif (!apic_x2apic_mode(apic))\n\t\t\tval &= 0xff000000;\n\t\tkvm_lapic_set_reg(apic, APIC_ICR2, val);\n\t\tbreak;\n\n\tcase APIC_LVT0:\n\t\tapic_manage_nmi_watchdog(apic, val);\n\tcase APIC_LVTTHMR:\n\tcase APIC_LVTPC:\n\tcase APIC_LVT1:\n\tcase APIC_LVTERR:\n\t\t/* TODO: Check vector */\n\t\tif (!kvm_apic_sw_enabled(apic))\n\t\t\tval |= APIC_LVT_MASKED;\n\n\t\tval &= apic_lvt_mask[(reg - APIC_LVTT) >> 4];\n\t\tkvm_lapic_set_reg(apic, reg, val);\n\n\t\tbreak;\n\n\tcase APIC_LVTT:\n\t\tif (!kvm_apic_sw_enabled(apic))\n\t\t\tval |= APIC_LVT_MASKED;\n\t\tval &= (apic_lvt_mask[0] | apic->lapic_timer.timer_mode_mask);\n\t\tkvm_lapic_set_reg(apic, APIC_LVTT, val);\n\t\tapic_update_lvtt(apic);\n\t\tbreak;\n\n\tcase APIC_TMICT:\n\t\tif (apic_lvtt_tscdeadline(apic))\n\t\t\tbreak;\n\n\t\thrtimer_cancel(&apic->lapic_timer.timer);\n\t\tkvm_lapic_set_reg(apic, APIC_TMICT, val);\n\t\tstart_apic_timer(apic);\n\t\tbreak;\n\n\tcase APIC_TDCR:\n\t\tif (val & 4)\n\t\t\tapic_debug(\"KVM_WRITE:TDCR %x\\n\", val);\n\t\tkvm_lapic_set_reg(apic, APIC_TDCR, val);\n\t\tupdate_divide_count(apic);\n\t\tbreak;\n\n\tcase APIC_ESR:\n\t\tif (apic_x2apic_mode(apic) && val != 0) {\n\t\t\tapic_debug(\"KVM_WRITE:ESR not zero %x\\n\", val);\n\t\t\tret = 1;\n\t\t}\n\t\tbreak;\n\n\tcase APIC_SELF_IPI:\n\t\tif (apic_x2apic_mode(apic)) {\n\t\t\tkvm_lapic_reg_write(apic, APIC_ICR, 0x40000 | (val & 0xff));\n\t\t} else\n\t\t\tret = 1;\n\t\tbreak;\n\tdefault:\n\t\tret = 1;\n\t\tbreak;\n\t}\n\tif (ret)\n\t\tapic_debug(\"Local APIC Write to read-only register %x\\n\", reg);\n\treturn ret;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int apic_lvt_mask[KVM_APIC_LVT_NUM] = {\n\tLVT_MASK ,      /* part LVTT mask, timer mode mask added at runtime */\n\tLVT_MASK | APIC_MODE_MASK,\t/* LVTTHMR */\n\tLVT_MASK | APIC_MODE_MASK,\t/* LVTPC */\n\tLINT_MASK, LINT_MASK,\t/* LVT0-1 */\n\tLVT_MASK\t\t/* LVTERR */\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic const unsigned int apic_lvt_mask[KVM_APIC_LVT_NUM] = {\n\tLVT_MASK ,      /* part LVTT mask, timer mode mask added at runtime */\n\tLVT_MASK | APIC_MODE_MASK,\t/* LVTTHMR */\n\tLVT_MASK | APIC_MODE_MASK,\t/* LVTPC */\n\tLINT_MASK, LINT_MASK,\t/* LVT0-1 */\n\tLVT_MASK\t\t/* LVTERR */\n};\n\nint kvm_lapic_reg_write(struct kvm_lapic *apic, u32 reg, u32 val)\n{\n\tint ret = 0;\n\n\ttrace_kvm_apic_write(reg, val);\n\n\tswitch (reg) {\n\tcase APIC_ID:\t\t/* Local APIC ID */\n\t\tif (!apic_x2apic_mode(apic))\n\t\t\tkvm_apic_set_id(apic, val >> 24);\n\t\telse\n\t\t\tret = 1;\n\t\tbreak;\n\n\tcase APIC_TASKPRI:\n\t\treport_tpr_access(apic, true);\n\t\tapic_set_tpr(apic, val & 0xff);\n\t\tbreak;\n\n\tcase APIC_EOI:\n\t\tapic_set_eoi(apic);\n\t\tbreak;\n\n\tcase APIC_LDR:\n\t\tif (!apic_x2apic_mode(apic))\n\t\t\tkvm_apic_set_ldr(apic, val & APIC_LDR_MASK);\n\t\telse\n\t\t\tret = 1;\n\t\tbreak;\n\n\tcase APIC_DFR:\n\t\tif (!apic_x2apic_mode(apic)) {\n\t\t\tkvm_lapic_set_reg(apic, APIC_DFR, val | 0x0FFFFFFF);\n\t\t\trecalculate_apic_map(apic->vcpu->kvm);\n\t\t} else\n\t\t\tret = 1;\n\t\tbreak;\n\n\tcase APIC_SPIV: {\n\t\tu32 mask = 0x3ff;\n\t\tif (kvm_lapic_get_reg(apic, APIC_LVR) & APIC_LVR_DIRECTED_EOI)\n\t\t\tmask |= APIC_SPIV_DIRECTED_EOI;\n\t\tapic_set_spiv(apic, val & mask);\n\t\tif (!(val & APIC_SPIV_APIC_ENABLED)) {\n\t\t\tint i;\n\t\t\tu32 lvt_val;\n\n\t\t\tfor (i = 0; i < KVM_APIC_LVT_NUM; i++) {\n\t\t\t\tlvt_val = kvm_lapic_get_reg(apic,\n\t\t\t\t\t\t       APIC_LVTT + 0x10 * i);\n\t\t\t\tkvm_lapic_set_reg(apic, APIC_LVTT + 0x10 * i,\n\t\t\t\t\t     lvt_val | APIC_LVT_MASKED);\n\t\t\t}\n\t\t\tapic_update_lvtt(apic);\n\t\t\tatomic_set(&apic->lapic_timer.pending, 0);\n\n\t\t}\n\t\tbreak;\n\t}\n\tcase APIC_ICR:\n\t\t/* No delay here, so we always clear the pending bit */\n\t\tkvm_lapic_set_reg(apic, APIC_ICR, val & ~(1 << 12));\n\t\tapic_send_ipi(apic);\n\t\tbreak;\n\n\tcase APIC_ICR2:\n\t\tif (!apic_x2apic_mode(apic))\n\t\t\tval &= 0xff000000;\n\t\tkvm_lapic_set_reg(apic, APIC_ICR2, val);\n\t\tbreak;\n\n\tcase APIC_LVT0:\n\t\tapic_manage_nmi_watchdog(apic, val);\n\tcase APIC_LVTTHMR:\n\tcase APIC_LVTPC:\n\tcase APIC_LVT1:\n\tcase APIC_LVTERR:\n\t\t/* TODO: Check vector */\n\t\tif (!kvm_apic_sw_enabled(apic))\n\t\t\tval |= APIC_LVT_MASKED;\n\n\t\tval &= apic_lvt_mask[(reg - APIC_LVTT) >> 4];\n\t\tkvm_lapic_set_reg(apic, reg, val);\n\n\t\tbreak;\n\n\tcase APIC_LVTT:\n\t\tif (!kvm_apic_sw_enabled(apic))\n\t\t\tval |= APIC_LVT_MASKED;\n\t\tval &= (apic_lvt_mask[0] | apic->lapic_timer.timer_mode_mask);\n\t\tkvm_lapic_set_reg(apic, APIC_LVTT, val);\n\t\tapic_update_lvtt(apic);\n\t\tbreak;\n\n\tcase APIC_TMICT:\n\t\tif (apic_lvtt_tscdeadline(apic))\n\t\t\tbreak;\n\n\t\thrtimer_cancel(&apic->lapic_timer.timer);\n\t\tkvm_lapic_set_reg(apic, APIC_TMICT, val);\n\t\tstart_apic_timer(apic);\n\t\tbreak;\n\n\tcase APIC_TDCR:\n\t\tif (val & 4)\n\t\t\tapic_debug(\"KVM_WRITE:TDCR %x\\n\", val);\n\t\tkvm_lapic_set_reg(apic, APIC_TDCR, val);\n\t\tupdate_divide_count(apic);\n\t\tbreak;\n\n\tcase APIC_ESR:\n\t\tif (apic_x2apic_mode(apic) && val != 0) {\n\t\t\tapic_debug(\"KVM_WRITE:ESR not zero %x\\n\", val);\n\t\t\tret = 1;\n\t\t}\n\t\tbreak;\n\n\tcase APIC_SELF_IPI:\n\t\tif (apic_x2apic_mode(apic)) {\n\t\t\tkvm_lapic_reg_write(apic, APIC_ICR, 0x40000 | (val & 0xff));\n\t\t} else\n\t\t\tret = 1;\n\t\tbreak;\n\tdefault:\n\t\tret = 1;\n\t\tbreak;\n\t}\n\tif (ret)\n\t\tapic_debug(\"Local APIC Write to read-only register %x\\n\", reg);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_kvm_avic_incomplete_ipi",
          "args": [
            "svm->vcpu.vcpu_id",
            "icrh",
            "icrl",
            "id",
            "index"
          ],
          "line": 3603
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic int avic_incomplete_ipi_interception(struct vcpu_svm *svm)\n{\n\tu32 icrh = svm->vmcb->control.exit_info_1 >> 32;\n\tu32 icrl = svm->vmcb->control.exit_info_1;\n\tu32 id = svm->vmcb->control.exit_info_2 >> 32;\n\tu32 index = svm->vmcb->control.exit_info_2 && 0xFF;\n\tstruct kvm_lapic *apic = svm->vcpu.arch.apic;\n\n\ttrace_kvm_avic_incomplete_ipi(svm->vcpu.vcpu_id, icrh, icrl, id, index);\n\n\tswitch (id) {\n\tcase AVIC_IPI_FAILURE_INVALID_INT_TYPE:\n\t\t/*\n\t\t * AVIC hardware handles the generation of\n\t\t * IPIs when the specified Message Type is Fixed\n\t\t * (also known as fixed delivery mode) and\n\t\t * the Trigger Mode is edge-triggered. The hardware\n\t\t * also supports self and broadcast delivery modes\n\t\t * specified via the Destination Shorthand(DSH)\n\t\t * field of the ICRL. Logical and physical APIC ID\n\t\t * formats are supported. All other IPI types cause\n\t\t * a #VMEXIT, which needs to emulated.\n\t\t */\n\t\tkvm_lapic_reg_write(apic, APIC_ICR2, icrh);\n\t\tkvm_lapic_reg_write(apic, APIC_ICR, icrl);\n\t\tbreak;\n\tcase AVIC_IPI_FAILURE_TARGET_NOT_RUNNING: {\n\t\tint i;\n\t\tstruct kvm_vcpu *vcpu;\n\t\tstruct kvm *kvm = svm->vcpu.kvm;\n\t\tstruct kvm_lapic *apic = svm->vcpu.arch.apic;\n\n\t\t/*\n\t\t * At this point, we expect that the AVIC HW has already\n\t\t * set the appropriate IRR bits on the valid target\n\t\t * vcpus. So, we just need to kick the appropriate vcpu.\n\t\t */\n\t\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\t\tbool m = kvm_apic_match_dest(vcpu, apic,\n\t\t\t\t\t\t     icrl & KVM_APIC_SHORT_MASK,\n\t\t\t\t\t\t     GET_APIC_DEST_FIELD(icrh),\n\t\t\t\t\t\t     icrl & KVM_APIC_DEST_MASK);\n\n\t\t\tif (m && !avic_vcpu_is_running(vcpu))\n\t\t\t\tkvm_vcpu_wake_up(vcpu);\n\t\t}\n\t\tbreak;\n\t}\n\tcase AVIC_IPI_FAILURE_INVALID_TARGET:\n\t\tbreak;\n\tcase AVIC_IPI_FAILURE_INVALID_BACKING_PAGE:\n\t\tWARN_ONCE(1, \"Invalid backing page\\n\");\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"Unknown IPI interception\\n\");\n\t}\n\n\treturn 1;\n}"
  },
  {
    "function_name": "mwait_interception",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "3582-3586",
    "snippet": "static int mwait_interception(struct vcpu_svm *svm)\n{\n\tprintk_once(KERN_WARNING \"kvm: MWAIT instruction emulated as NOP!\\n\");\n\treturn nop_interception(svm);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nop_interception",
          "args": [
            "svm"
          ],
          "line": 3585
        },
        "resolved": true,
        "details": {
          "function_name": "nop_interception",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "3570-3574",
          "snippet": "static int nop_interception(struct vcpu_svm *svm)\n{\n\tskip_emulated_instruction(&(svm->vcpu));\n\treturn 1;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic int nop_interception(struct vcpu_svm *svm)\n{\n\tskip_emulated_instruction(&(svm->vcpu));\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk_once",
          "args": [
            "KERN_WARNING \"kvm: MWAIT instruction emulated as NOP!\\n\""
          ],
          "line": 3584
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic int mwait_interception(struct vcpu_svm *svm)\n{\n\tprintk_once(KERN_WARNING \"kvm: MWAIT instruction emulated as NOP!\\n\");\n\treturn nop_interception(svm);\n}"
  },
  {
    "function_name": "monitor_interception",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "3576-3580",
    "snippet": "static int monitor_interception(struct vcpu_svm *svm)\n{\n\tprintk_once(KERN_WARNING \"kvm: MONITOR instruction emulated as NOP!\\n\");\n\treturn nop_interception(svm);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nop_interception",
          "args": [
            "svm"
          ],
          "line": 3579
        },
        "resolved": true,
        "details": {
          "function_name": "nop_interception",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "3570-3574",
          "snippet": "static int nop_interception(struct vcpu_svm *svm)\n{\n\tskip_emulated_instruction(&(svm->vcpu));\n\treturn 1;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic int nop_interception(struct vcpu_svm *svm)\n{\n\tskip_emulated_instruction(&(svm->vcpu));\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk_once",
          "args": [
            "KERN_WARNING \"kvm: MONITOR instruction emulated as NOP!\\n\""
          ],
          "line": 3578
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic int monitor_interception(struct vcpu_svm *svm)\n{\n\tprintk_once(KERN_WARNING \"kvm: MONITOR instruction emulated as NOP!\\n\");\n\treturn nop_interception(svm);\n}"
  },
  {
    "function_name": "nop_interception",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "3570-3574",
    "snippet": "static int nop_interception(struct vcpu_svm *svm)\n{\n\tskip_emulated_instruction(&(svm->vcpu));\n\treturn 1;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "skip_emulated_instruction",
          "args": [
            "&(svm->vcpu)"
          ],
          "line": 3572
        },
        "resolved": true,
        "details": {
          "function_name": "skip_emulated_instruction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "572-593",
          "snippet": "static void skip_emulated_instruction(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (svm->vmcb->control.next_rip != 0) {\n\t\tWARN_ON_ONCE(!static_cpu_has(X86_FEATURE_NRIPS));\n\t\tsvm->next_rip = svm->vmcb->control.next_rip;\n\t}\n\n\tif (!svm->next_rip) {\n\t\tif (emulate_instruction(vcpu, EMULTYPE_SKIP) !=\n\t\t\t\tEMULATE_DONE)\n\t\t\tprintk(KERN_DEBUG \"%s: NOP\\n\", __func__);\n\t\treturn;\n\t}\n\tif (svm->next_rip - kvm_rip_read(vcpu) > MAX_INST_SIZE)\n\t\tprintk(KERN_ERR \"%s: ip 0x%lx next 0x%llx\\n\",\n\t\t       __func__, kvm_rip_read(vcpu), svm->next_rip);\n\n\tkvm_rip_write(vcpu, svm->next_rip);\n\tsvm_set_interrupt_shadow(vcpu, 0);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define MAX_INST_SIZE 15"
          ],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define MAX_INST_SIZE 15\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic void skip_emulated_instruction(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (svm->vmcb->control.next_rip != 0) {\n\t\tWARN_ON_ONCE(!static_cpu_has(X86_FEATURE_NRIPS));\n\t\tsvm->next_rip = svm->vmcb->control.next_rip;\n\t}\n\n\tif (!svm->next_rip) {\n\t\tif (emulate_instruction(vcpu, EMULTYPE_SKIP) !=\n\t\t\t\tEMULATE_DONE)\n\t\t\tprintk(KERN_DEBUG \"%s: NOP\\n\", __func__);\n\t\treturn;\n\t}\n\tif (svm->next_rip - kvm_rip_read(vcpu) > MAX_INST_SIZE)\n\t\tprintk(KERN_ERR \"%s: ip 0x%lx next 0x%llx\\n\",\n\t\t       __func__, kvm_rip_read(vcpu), svm->next_rip);\n\n\tkvm_rip_write(vcpu, svm->next_rip);\n\tsvm_set_interrupt_shadow(vcpu, 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic int nop_interception(struct vcpu_svm *svm)\n{\n\tskip_emulated_instruction(&(svm->vcpu));\n\treturn 1;\n}"
  },
  {
    "function_name": "pause_interception",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "3564-3568",
    "snippet": "static int pause_interception(struct vcpu_svm *svm)\n{\n\tkvm_vcpu_on_spin(&(svm->vcpu));\n\treturn 1;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_vcpu_on_spin",
          "args": [
            "&(svm->vcpu)"
          ],
          "line": 3566
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic int pause_interception(struct vcpu_svm *svm)\n{\n\tkvm_vcpu_on_spin(&(svm->vcpu));\n\treturn 1;\n}"
  },
  {
    "function_name": "interrupt_window_interception",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "3554-3562",
    "snippet": "static int interrupt_window_interception(struct vcpu_svm *svm)\n{\n\tkvm_make_request(KVM_REQ_EVENT, &svm->vcpu);\n\tsvm_clear_vintr(svm);\n\tsvm->vmcb->control.int_ctl &= ~V_IRQ_MASK;\n\tmark_dirty(svm->vmcb, VMCB_INTR);\n\t++svm->vcpu.stat.irq_window_exits;\n\treturn 1;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_dirty",
          "args": [
            "svm->vmcb",
            "VMCB_INTR"
          ],
          "line": 3559
        },
        "resolved": true,
        "details": {
          "function_name": "mark_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "289-292",
          "snippet": "static inline void mark_dirty(struct vmcb *vmcb, int bit)\n{\n\tvmcb->control.clean &= ~(1 << bit);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic inline void mark_dirty(struct vmcb *vmcb, int bit)\n{\n\tvmcb->control.clean &= ~(1 << bit);\n}"
        }
      },
      {
        "call_info": {
          "callee": "svm_clear_vintr",
          "args": [
            "svm"
          ],
          "line": 3557
        },
        "resolved": true,
        "details": {
          "function_name": "svm_clear_vintr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "1604-1607",
          "snippet": "static void svm_clear_vintr(struct vcpu_svm *svm)\n{\n\tclr_intercept(svm, INTERCEPT_VINTR);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic void svm_clear_vintr(struct vcpu_svm *svm)\n{\n\tclr_intercept(svm, INTERCEPT_VINTR);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_make_request",
          "args": [
            "KVM_REQ_EVENT",
            "&svm->vcpu"
          ],
          "line": 3556
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic int interrupt_window_interception(struct vcpu_svm *svm)\n{\n\tkvm_make_request(KVM_REQ_EVENT, &svm->vcpu);\n\tsvm_clear_vintr(svm);\n\tsvm->vmcb->control.int_ctl &= ~V_IRQ_MASK;\n\tmark_dirty(svm->vmcb, VMCB_INTR);\n\t++svm->vcpu.stat.irq_window_exits;\n\treturn 1;\n}"
  },
  {
    "function_name": "msr_interception",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "3546-3552",
    "snippet": "static int msr_interception(struct vcpu_svm *svm)\n{\n\tif (svm->vmcb->control.exit_info_1)\n\t\treturn wrmsr_interception(svm);\n\telse\n\t\treturn rdmsr_interception(svm);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rdmsr_interception",
          "args": [
            "svm"
          ],
          "line": 3551
        },
        "resolved": true,
        "details": {
          "function_name": "rdmsr_interception",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "3393-3414",
          "snippet": "static int rdmsr_interception(struct vcpu_svm *svm)\n{\n\tu32 ecx = kvm_register_read(&svm->vcpu, VCPU_REGS_RCX);\n\tstruct msr_data msr_info;\n\n\tmsr_info.index = ecx;\n\tmsr_info.host_initiated = false;\n\tif (svm_get_msr(&svm->vcpu, &msr_info)) {\n\t\ttrace_kvm_msr_read_ex(ecx);\n\t\tkvm_inject_gp(&svm->vcpu, 0);\n\t} else {\n\t\ttrace_kvm_msr_read(ecx, msr_info.data);\n\n\t\tkvm_register_write(&svm->vcpu, VCPU_REGS_RAX,\n\t\t\t\t   msr_info.data & 0xffffffff);\n\t\tkvm_register_write(&svm->vcpu, VCPU_REGS_RDX,\n\t\t\t\t   msr_info.data >> 32);\n\t\tsvm->next_rip = kvm_rip_read(&svm->vcpu) + 2;\n\t\tskip_emulated_instruction(&svm->vcpu);\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic int rdmsr_interception(struct vcpu_svm *svm)\n{\n\tu32 ecx = kvm_register_read(&svm->vcpu, VCPU_REGS_RCX);\n\tstruct msr_data msr_info;\n\n\tmsr_info.index = ecx;\n\tmsr_info.host_initiated = false;\n\tif (svm_get_msr(&svm->vcpu, &msr_info)) {\n\t\ttrace_kvm_msr_read_ex(ecx);\n\t\tkvm_inject_gp(&svm->vcpu, 0);\n\t} else {\n\t\ttrace_kvm_msr_read(ecx, msr_info.data);\n\n\t\tkvm_register_write(&svm->vcpu, VCPU_REGS_RAX,\n\t\t\t\t   msr_info.data & 0xffffffff);\n\t\tkvm_register_write(&svm->vcpu, VCPU_REGS_RDX,\n\t\t\t\t   msr_info.data >> 32);\n\t\tsvm->next_rip = kvm_rip_read(&svm->vcpu) + 2;\n\t\tskip_emulated_instruction(&svm->vcpu);\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wrmsr_interception",
          "args": [
            "svm"
          ],
          "line": 3549
        },
        "resolved": true,
        "details": {
          "function_name": "wrmsr_interception",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "3525-3544",
          "snippet": "static int wrmsr_interception(struct vcpu_svm *svm)\n{\n\tstruct msr_data msr;\n\tu32 ecx = kvm_register_read(&svm->vcpu, VCPU_REGS_RCX);\n\tu64 data = kvm_read_edx_eax(&svm->vcpu);\n\n\tmsr.data = data;\n\tmsr.index = ecx;\n\tmsr.host_initiated = false;\n\n\tsvm->next_rip = kvm_rip_read(&svm->vcpu) + 2;\n\tif (kvm_set_msr(&svm->vcpu, &msr)) {\n\t\ttrace_kvm_msr_write_ex(ecx, data);\n\t\tkvm_inject_gp(&svm->vcpu, 0);\n\t} else {\n\t\ttrace_kvm_msr_write(ecx, data);\n\t\tskip_emulated_instruction(&svm->vcpu);\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic int wrmsr_interception(struct vcpu_svm *svm)\n{\n\tstruct msr_data msr;\n\tu32 ecx = kvm_register_read(&svm->vcpu, VCPU_REGS_RCX);\n\tu64 data = kvm_read_edx_eax(&svm->vcpu);\n\n\tmsr.data = data;\n\tmsr.index = ecx;\n\tmsr.host_initiated = false;\n\n\tsvm->next_rip = kvm_rip_read(&svm->vcpu) + 2;\n\tif (kvm_set_msr(&svm->vcpu, &msr)) {\n\t\ttrace_kvm_msr_write_ex(ecx, data);\n\t\tkvm_inject_gp(&svm->vcpu, 0);\n\t} else {\n\t\ttrace_kvm_msr_write(ecx, data);\n\t\tskip_emulated_instruction(&svm->vcpu);\n\t}\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic int msr_interception(struct vcpu_svm *svm)\n{\n\tif (svm->vmcb->control.exit_info_1)\n\t\treturn wrmsr_interception(svm);\n\telse\n\t\treturn rdmsr_interception(svm);\n}"
  },
  {
    "function_name": "wrmsr_interception",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "3525-3544",
    "snippet": "static int wrmsr_interception(struct vcpu_svm *svm)\n{\n\tstruct msr_data msr;\n\tu32 ecx = kvm_register_read(&svm->vcpu, VCPU_REGS_RCX);\n\tu64 data = kvm_read_edx_eax(&svm->vcpu);\n\n\tmsr.data = data;\n\tmsr.index = ecx;\n\tmsr.host_initiated = false;\n\n\tsvm->next_rip = kvm_rip_read(&svm->vcpu) + 2;\n\tif (kvm_set_msr(&svm->vcpu, &msr)) {\n\t\ttrace_kvm_msr_write_ex(ecx, data);\n\t\tkvm_inject_gp(&svm->vcpu, 0);\n\t} else {\n\t\ttrace_kvm_msr_write(ecx, data);\n\t\tskip_emulated_instruction(&svm->vcpu);\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "skip_emulated_instruction",
          "args": [
            "&svm->vcpu"
          ],
          "line": 3541
        },
        "resolved": true,
        "details": {
          "function_name": "skip_emulated_instruction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "572-593",
          "snippet": "static void skip_emulated_instruction(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (svm->vmcb->control.next_rip != 0) {\n\t\tWARN_ON_ONCE(!static_cpu_has(X86_FEATURE_NRIPS));\n\t\tsvm->next_rip = svm->vmcb->control.next_rip;\n\t}\n\n\tif (!svm->next_rip) {\n\t\tif (emulate_instruction(vcpu, EMULTYPE_SKIP) !=\n\t\t\t\tEMULATE_DONE)\n\t\t\tprintk(KERN_DEBUG \"%s: NOP\\n\", __func__);\n\t\treturn;\n\t}\n\tif (svm->next_rip - kvm_rip_read(vcpu) > MAX_INST_SIZE)\n\t\tprintk(KERN_ERR \"%s: ip 0x%lx next 0x%llx\\n\",\n\t\t       __func__, kvm_rip_read(vcpu), svm->next_rip);\n\n\tkvm_rip_write(vcpu, svm->next_rip);\n\tsvm_set_interrupt_shadow(vcpu, 0);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define MAX_INST_SIZE 15"
          ],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define MAX_INST_SIZE 15\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic void skip_emulated_instruction(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (svm->vmcb->control.next_rip != 0) {\n\t\tWARN_ON_ONCE(!static_cpu_has(X86_FEATURE_NRIPS));\n\t\tsvm->next_rip = svm->vmcb->control.next_rip;\n\t}\n\n\tif (!svm->next_rip) {\n\t\tif (emulate_instruction(vcpu, EMULTYPE_SKIP) !=\n\t\t\t\tEMULATE_DONE)\n\t\t\tprintk(KERN_DEBUG \"%s: NOP\\n\", __func__);\n\t\treturn;\n\t}\n\tif (svm->next_rip - kvm_rip_read(vcpu) > MAX_INST_SIZE)\n\t\tprintk(KERN_ERR \"%s: ip 0x%lx next 0x%llx\\n\",\n\t\t       __func__, kvm_rip_read(vcpu), svm->next_rip);\n\n\tkvm_rip_write(vcpu, svm->next_rip);\n\tsvm_set_interrupt_shadow(vcpu, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_kvm_msr_write",
          "args": [
            "ecx",
            "data"
          ],
          "line": 3540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_inject_gp",
          "args": [
            "&svm->vcpu",
            "0"
          ],
          "line": 3538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_kvm_msr_write_ex",
          "args": [
            "ecx",
            "data"
          ],
          "line": 3537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_set_msr",
          "args": [
            "&svm->vcpu",
            "&msr"
          ],
          "line": 3536
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_set_msr_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "2040-2248",
          "snippet": "int kvm_set_msr_common(struct kvm_vcpu *vcpu, struct msr_data *msr_info)\n{\n\tbool pr = false;\n\tu32 msr = msr_info->index;\n\tu64 data = msr_info->data;\n\n\tswitch (msr) {\n\tcase MSR_AMD64_NB_CFG:\n\tcase MSR_IA32_UCODE_REV:\n\tcase MSR_IA32_UCODE_WRITE:\n\tcase MSR_VM_HSAVE_PA:\n\tcase MSR_AMD64_PATCH_LOADER:\n\tcase MSR_AMD64_BU_CFG2:\n\t\tbreak;\n\n\tcase MSR_EFER:\n\t\treturn set_efer(vcpu, data);\n\tcase MSR_K7_HWCR:\n\t\tdata &= ~(u64)0x40;\t/* ignore flush filter disable */\n\t\tdata &= ~(u64)0x100;\t/* ignore ignne emulation enable */\n\t\tdata &= ~(u64)0x8;\t/* ignore TLB cache disable */\n\t\tdata &= ~(u64)0x40000;  /* ignore Mc status write enable */\n\t\tif (data != 0) {\n\t\t\tvcpu_unimpl(vcpu, \"unimplemented HWCR wrmsr: 0x%llx\\n\",\n\t\t\t\t    data);\n\t\t\treturn 1;\n\t\t}\n\t\tbreak;\n\tcase MSR_FAM10H_MMIO_CONF_BASE:\n\t\tif (data != 0) {\n\t\t\tvcpu_unimpl(vcpu, \"unimplemented MMIO_CONF_BASE wrmsr: \"\n\t\t\t\t    \"0x%llx\\n\", data);\n\t\t\treturn 1;\n\t\t}\n\t\tbreak;\n\tcase MSR_IA32_DEBUGCTLMSR:\n\t\tif (!data) {\n\t\t\t/* We support the non-activated case already */\n\t\t\tbreak;\n\t\t} else if (data & ~(DEBUGCTLMSR_LBR | DEBUGCTLMSR_BTF)) {\n\t\t\t/* Values other than LBR and BTF are vendor-specific,\n\t\t\t   thus reserved and should throw a #GP */\n\t\t\treturn 1;\n\t\t}\n\t\tvcpu_unimpl(vcpu, \"%s: MSR_IA32_DEBUGCTLMSR 0x%llx, nop\\n\",\n\t\t\t    __func__, data);\n\t\tbreak;\n\tcase 0x200 ... 0x2ff:\n\t\treturn kvm_mtrr_set_msr(vcpu, msr, data);\n\tcase MSR_IA32_APICBASE:\n\t\treturn kvm_set_apic_base(vcpu, msr_info);\n\tcase APIC_BASE_MSR ... APIC_BASE_MSR + 0x3ff:\n\t\treturn kvm_x2apic_msr_write(vcpu, msr, data);\n\tcase MSR_IA32_TSCDEADLINE:\n\t\tkvm_set_lapic_tscdeadline_msr(vcpu, data);\n\t\tbreak;\n\tcase MSR_IA32_TSC_ADJUST:\n\t\tif (guest_cpuid_has_tsc_adjust(vcpu)) {\n\t\t\tif (!msr_info->host_initiated) {\n\t\t\t\ts64 adj = data - vcpu->arch.ia32_tsc_adjust_msr;\n\t\t\t\tadjust_tsc_offset_guest(vcpu, adj);\n\t\t\t}\n\t\t\tvcpu->arch.ia32_tsc_adjust_msr = data;\n\t\t}\n\t\tbreak;\n\tcase MSR_IA32_MISC_ENABLE:\n\t\tvcpu->arch.ia32_misc_enable_msr = data;\n\t\tbreak;\n\tcase MSR_IA32_SMBASE:\n\t\tif (!msr_info->host_initiated)\n\t\t\treturn 1;\n\t\tvcpu->arch.smbase = data;\n\t\tbreak;\n\tcase MSR_KVM_WALL_CLOCK_NEW:\n\tcase MSR_KVM_WALL_CLOCK:\n\t\tvcpu->kvm->arch.wall_clock = data;\n\t\tkvm_write_wall_clock(vcpu->kvm, data);\n\t\tbreak;\n\tcase MSR_KVM_SYSTEM_TIME_NEW:\n\tcase MSR_KVM_SYSTEM_TIME: {\n\t\tu64 gpa_offset;\n\t\tstruct kvm_arch *ka = &vcpu->kvm->arch;\n\n\t\tkvmclock_reset(vcpu);\n\n\t\tif (vcpu->vcpu_id == 0 && !msr_info->host_initiated) {\n\t\t\tbool tmp = (msr == MSR_KVM_SYSTEM_TIME);\n\n\t\t\tif (ka->boot_vcpu_runs_old_kvmclock != tmp)\n\t\t\t\tset_bit(KVM_REQ_MASTERCLOCK_UPDATE,\n\t\t\t\t\t&vcpu->requests);\n\n\t\t\tka->boot_vcpu_runs_old_kvmclock = tmp;\n\t\t}\n\n\t\tvcpu->arch.time = data;\n\t\tkvm_make_request(KVM_REQ_GLOBAL_CLOCK_UPDATE, vcpu);\n\n\t\t/* we verify if the enable bit is set... */\n\t\tif (!(data & 1))\n\t\t\tbreak;\n\n\t\tgpa_offset = data & ~(PAGE_MASK | 1);\n\n\t\tif (kvm_gfn_to_hva_cache_init(vcpu->kvm,\n\t\t     &vcpu->arch.pv_time, data & ~1ULL,\n\t\t     sizeof(struct pvclock_vcpu_time_info)))\n\t\t\tvcpu->arch.pv_time_enabled = false;\n\t\telse\n\t\t\tvcpu->arch.pv_time_enabled = true;\n\n\t\tbreak;\n\t}\n\tcase MSR_KVM_ASYNC_PF_EN:\n\t\tif (kvm_pv_enable_async_pf(vcpu, data))\n\t\t\treturn 1;\n\t\tbreak;\n\tcase MSR_KVM_STEAL_TIME:\n\n\t\tif (unlikely(!sched_info_on()))\n\t\t\treturn 1;\n\n\t\tif (data & KVM_STEAL_RESERVED_MASK)\n\t\t\treturn 1;\n\n\t\tif (kvm_gfn_to_hva_cache_init(vcpu->kvm, &vcpu->arch.st.stime,\n\t\t\t\t\t\tdata & KVM_STEAL_VALID_BITS,\n\t\t\t\t\t\tsizeof(struct kvm_steal_time)))\n\t\t\treturn 1;\n\n\t\tvcpu->arch.st.msr_val = data;\n\n\t\tif (!(data & KVM_MSR_ENABLED))\n\t\t\tbreak;\n\n\t\tkvm_make_request(KVM_REQ_STEAL_UPDATE, vcpu);\n\n\t\tbreak;\n\tcase MSR_KVM_PV_EOI_EN:\n\t\tif (kvm_lapic_enable_pv_eoi(vcpu, data))\n\t\t\treturn 1;\n\t\tbreak;\n\n\tcase MSR_IA32_MCG_CTL:\n\tcase MSR_IA32_MCG_STATUS:\n\tcase MSR_IA32_MC0_CTL ... MSR_IA32_MCx_CTL(KVM_MAX_MCE_BANKS) - 1:\n\t\treturn set_msr_mce(vcpu, msr, data);\n\n\tcase MSR_K7_PERFCTR0 ... MSR_K7_PERFCTR3:\n\tcase MSR_P6_PERFCTR0 ... MSR_P6_PERFCTR1:\n\t\tpr = true; /* fall through */\n\tcase MSR_K7_EVNTSEL0 ... MSR_K7_EVNTSEL3:\n\tcase MSR_P6_EVNTSEL0 ... MSR_P6_EVNTSEL1:\n\t\tif (kvm_pmu_is_valid_msr(vcpu, msr))\n\t\t\treturn kvm_pmu_set_msr(vcpu, msr_info);\n\n\t\tif (pr || data != 0)\n\t\t\tvcpu_unimpl(vcpu, \"disabled perfctr wrmsr: \"\n\t\t\t\t    \"0x%x data 0x%llx\\n\", msr, data);\n\t\tbreak;\n\tcase MSR_K7_CLK_CTL:\n\t\t/*\n\t\t * Ignore all writes to this no longer documented MSR.\n\t\t * Writes are only relevant for old K7 processors,\n\t\t * all pre-dating SVM, but a recommended workaround from\n\t\t * AMD for these chips. It is possible to specify the\n\t\t * affected processor models on the command line, hence\n\t\t * the need to ignore the workaround.\n\t\t */\n\t\tbreak;\n\tcase HV_X64_MSR_GUEST_OS_ID ... HV_X64_MSR_SINT15:\n\tcase HV_X64_MSR_CRASH_P0 ... HV_X64_MSR_CRASH_P4:\n\tcase HV_X64_MSR_CRASH_CTL:\n\tcase HV_X64_MSR_STIMER0_CONFIG ... HV_X64_MSR_STIMER3_COUNT:\n\t\treturn kvm_hv_set_msr_common(vcpu, msr, data,\n\t\t\t\t\t     msr_info->host_initiated);\n\tcase MSR_IA32_BBL_CR_CTL3:\n\t\t/* Drop writes to this legacy MSR -- see rdmsr\n\t\t * counterpart for further detail.\n\t\t */\n\t\tvcpu_unimpl(vcpu, \"ignored wrmsr: 0x%x data %llx\\n\", msr, data);\n\t\tbreak;\n\tcase MSR_AMD64_OSVW_ID_LENGTH:\n\t\tif (!guest_cpuid_has_osvw(vcpu))\n\t\t\treturn 1;\n\t\tvcpu->arch.osvw.length = data;\n\t\tbreak;\n\tcase MSR_AMD64_OSVW_STATUS:\n\t\tif (!guest_cpuid_has_osvw(vcpu))\n\t\t\treturn 1;\n\t\tvcpu->arch.osvw.status = data;\n\t\tbreak;\n\tdefault:\n\t\tif (msr && (msr == vcpu->kvm->arch.xen_hvm_config.msr))\n\t\t\treturn xen_hvm_config(vcpu, data);\n\t\tif (kvm_pmu_is_valid_msr(vcpu, msr))\n\t\t\treturn kvm_pmu_set_msr(vcpu, msr_info);\n\t\tif (!ignore_msrs) {\n\t\t\tvcpu_unimpl(vcpu, \"unhandled wrmsr: 0x%x data %llx\\n\",\n\t\t\t\t    msr, data);\n\t\t\treturn 1;\n\t\t} else {\n\t\t\tvcpu_unimpl(vcpu, \"ignored wrmsr: 0x%x data %llx\\n\",\n\t\t\t\t    msr, data);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define KVM_MAX_MCE_BANKS 32"
          ],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define KVM_MAX_MCE_BANKS 32\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nint kvm_set_msr_common(struct kvm_vcpu *vcpu, struct msr_data *msr_info)\n{\n\tbool pr = false;\n\tu32 msr = msr_info->index;\n\tu64 data = msr_info->data;\n\n\tswitch (msr) {\n\tcase MSR_AMD64_NB_CFG:\n\tcase MSR_IA32_UCODE_REV:\n\tcase MSR_IA32_UCODE_WRITE:\n\tcase MSR_VM_HSAVE_PA:\n\tcase MSR_AMD64_PATCH_LOADER:\n\tcase MSR_AMD64_BU_CFG2:\n\t\tbreak;\n\n\tcase MSR_EFER:\n\t\treturn set_efer(vcpu, data);\n\tcase MSR_K7_HWCR:\n\t\tdata &= ~(u64)0x40;\t/* ignore flush filter disable */\n\t\tdata &= ~(u64)0x100;\t/* ignore ignne emulation enable */\n\t\tdata &= ~(u64)0x8;\t/* ignore TLB cache disable */\n\t\tdata &= ~(u64)0x40000;  /* ignore Mc status write enable */\n\t\tif (data != 0) {\n\t\t\tvcpu_unimpl(vcpu, \"unimplemented HWCR wrmsr: 0x%llx\\n\",\n\t\t\t\t    data);\n\t\t\treturn 1;\n\t\t}\n\t\tbreak;\n\tcase MSR_FAM10H_MMIO_CONF_BASE:\n\t\tif (data != 0) {\n\t\t\tvcpu_unimpl(vcpu, \"unimplemented MMIO_CONF_BASE wrmsr: \"\n\t\t\t\t    \"0x%llx\\n\", data);\n\t\t\treturn 1;\n\t\t}\n\t\tbreak;\n\tcase MSR_IA32_DEBUGCTLMSR:\n\t\tif (!data) {\n\t\t\t/* We support the non-activated case already */\n\t\t\tbreak;\n\t\t} else if (data & ~(DEBUGCTLMSR_LBR | DEBUGCTLMSR_BTF)) {\n\t\t\t/* Values other than LBR and BTF are vendor-specific,\n\t\t\t   thus reserved and should throw a #GP */\n\t\t\treturn 1;\n\t\t}\n\t\tvcpu_unimpl(vcpu, \"%s: MSR_IA32_DEBUGCTLMSR 0x%llx, nop\\n\",\n\t\t\t    __func__, data);\n\t\tbreak;\n\tcase 0x200 ... 0x2ff:\n\t\treturn kvm_mtrr_set_msr(vcpu, msr, data);\n\tcase MSR_IA32_APICBASE:\n\t\treturn kvm_set_apic_base(vcpu, msr_info);\n\tcase APIC_BASE_MSR ... APIC_BASE_MSR + 0x3ff:\n\t\treturn kvm_x2apic_msr_write(vcpu, msr, data);\n\tcase MSR_IA32_TSCDEADLINE:\n\t\tkvm_set_lapic_tscdeadline_msr(vcpu, data);\n\t\tbreak;\n\tcase MSR_IA32_TSC_ADJUST:\n\t\tif (guest_cpuid_has_tsc_adjust(vcpu)) {\n\t\t\tif (!msr_info->host_initiated) {\n\t\t\t\ts64 adj = data - vcpu->arch.ia32_tsc_adjust_msr;\n\t\t\t\tadjust_tsc_offset_guest(vcpu, adj);\n\t\t\t}\n\t\t\tvcpu->arch.ia32_tsc_adjust_msr = data;\n\t\t}\n\t\tbreak;\n\tcase MSR_IA32_MISC_ENABLE:\n\t\tvcpu->arch.ia32_misc_enable_msr = data;\n\t\tbreak;\n\tcase MSR_IA32_SMBASE:\n\t\tif (!msr_info->host_initiated)\n\t\t\treturn 1;\n\t\tvcpu->arch.smbase = data;\n\t\tbreak;\n\tcase MSR_KVM_WALL_CLOCK_NEW:\n\tcase MSR_KVM_WALL_CLOCK:\n\t\tvcpu->kvm->arch.wall_clock = data;\n\t\tkvm_write_wall_clock(vcpu->kvm, data);\n\t\tbreak;\n\tcase MSR_KVM_SYSTEM_TIME_NEW:\n\tcase MSR_KVM_SYSTEM_TIME: {\n\t\tu64 gpa_offset;\n\t\tstruct kvm_arch *ka = &vcpu->kvm->arch;\n\n\t\tkvmclock_reset(vcpu);\n\n\t\tif (vcpu->vcpu_id == 0 && !msr_info->host_initiated) {\n\t\t\tbool tmp = (msr == MSR_KVM_SYSTEM_TIME);\n\n\t\t\tif (ka->boot_vcpu_runs_old_kvmclock != tmp)\n\t\t\t\tset_bit(KVM_REQ_MASTERCLOCK_UPDATE,\n\t\t\t\t\t&vcpu->requests);\n\n\t\t\tka->boot_vcpu_runs_old_kvmclock = tmp;\n\t\t}\n\n\t\tvcpu->arch.time = data;\n\t\tkvm_make_request(KVM_REQ_GLOBAL_CLOCK_UPDATE, vcpu);\n\n\t\t/* we verify if the enable bit is set... */\n\t\tif (!(data & 1))\n\t\t\tbreak;\n\n\t\tgpa_offset = data & ~(PAGE_MASK | 1);\n\n\t\tif (kvm_gfn_to_hva_cache_init(vcpu->kvm,\n\t\t     &vcpu->arch.pv_time, data & ~1ULL,\n\t\t     sizeof(struct pvclock_vcpu_time_info)))\n\t\t\tvcpu->arch.pv_time_enabled = false;\n\t\telse\n\t\t\tvcpu->arch.pv_time_enabled = true;\n\n\t\tbreak;\n\t}\n\tcase MSR_KVM_ASYNC_PF_EN:\n\t\tif (kvm_pv_enable_async_pf(vcpu, data))\n\t\t\treturn 1;\n\t\tbreak;\n\tcase MSR_KVM_STEAL_TIME:\n\n\t\tif (unlikely(!sched_info_on()))\n\t\t\treturn 1;\n\n\t\tif (data & KVM_STEAL_RESERVED_MASK)\n\t\t\treturn 1;\n\n\t\tif (kvm_gfn_to_hva_cache_init(vcpu->kvm, &vcpu->arch.st.stime,\n\t\t\t\t\t\tdata & KVM_STEAL_VALID_BITS,\n\t\t\t\t\t\tsizeof(struct kvm_steal_time)))\n\t\t\treturn 1;\n\n\t\tvcpu->arch.st.msr_val = data;\n\n\t\tif (!(data & KVM_MSR_ENABLED))\n\t\t\tbreak;\n\n\t\tkvm_make_request(KVM_REQ_STEAL_UPDATE, vcpu);\n\n\t\tbreak;\n\tcase MSR_KVM_PV_EOI_EN:\n\t\tif (kvm_lapic_enable_pv_eoi(vcpu, data))\n\t\t\treturn 1;\n\t\tbreak;\n\n\tcase MSR_IA32_MCG_CTL:\n\tcase MSR_IA32_MCG_STATUS:\n\tcase MSR_IA32_MC0_CTL ... MSR_IA32_MCx_CTL(KVM_MAX_MCE_BANKS) - 1:\n\t\treturn set_msr_mce(vcpu, msr, data);\n\n\tcase MSR_K7_PERFCTR0 ... MSR_K7_PERFCTR3:\n\tcase MSR_P6_PERFCTR0 ... MSR_P6_PERFCTR1:\n\t\tpr = true; /* fall through */\n\tcase MSR_K7_EVNTSEL0 ... MSR_K7_EVNTSEL3:\n\tcase MSR_P6_EVNTSEL0 ... MSR_P6_EVNTSEL1:\n\t\tif (kvm_pmu_is_valid_msr(vcpu, msr))\n\t\t\treturn kvm_pmu_set_msr(vcpu, msr_info);\n\n\t\tif (pr || data != 0)\n\t\t\tvcpu_unimpl(vcpu, \"disabled perfctr wrmsr: \"\n\t\t\t\t    \"0x%x data 0x%llx\\n\", msr, data);\n\t\tbreak;\n\tcase MSR_K7_CLK_CTL:\n\t\t/*\n\t\t * Ignore all writes to this no longer documented MSR.\n\t\t * Writes are only relevant for old K7 processors,\n\t\t * all pre-dating SVM, but a recommended workaround from\n\t\t * AMD for these chips. It is possible to specify the\n\t\t * affected processor models on the command line, hence\n\t\t * the need to ignore the workaround.\n\t\t */\n\t\tbreak;\n\tcase HV_X64_MSR_GUEST_OS_ID ... HV_X64_MSR_SINT15:\n\tcase HV_X64_MSR_CRASH_P0 ... HV_X64_MSR_CRASH_P4:\n\tcase HV_X64_MSR_CRASH_CTL:\n\tcase HV_X64_MSR_STIMER0_CONFIG ... HV_X64_MSR_STIMER3_COUNT:\n\t\treturn kvm_hv_set_msr_common(vcpu, msr, data,\n\t\t\t\t\t     msr_info->host_initiated);\n\tcase MSR_IA32_BBL_CR_CTL3:\n\t\t/* Drop writes to this legacy MSR -- see rdmsr\n\t\t * counterpart for further detail.\n\t\t */\n\t\tvcpu_unimpl(vcpu, \"ignored wrmsr: 0x%x data %llx\\n\", msr, data);\n\t\tbreak;\n\tcase MSR_AMD64_OSVW_ID_LENGTH:\n\t\tif (!guest_cpuid_has_osvw(vcpu))\n\t\t\treturn 1;\n\t\tvcpu->arch.osvw.length = data;\n\t\tbreak;\n\tcase MSR_AMD64_OSVW_STATUS:\n\t\tif (!guest_cpuid_has_osvw(vcpu))\n\t\t\treturn 1;\n\t\tvcpu->arch.osvw.status = data;\n\t\tbreak;\n\tdefault:\n\t\tif (msr && (msr == vcpu->kvm->arch.xen_hvm_config.msr))\n\t\t\treturn xen_hvm_config(vcpu, data);\n\t\tif (kvm_pmu_is_valid_msr(vcpu, msr))\n\t\t\treturn kvm_pmu_set_msr(vcpu, msr_info);\n\t\tif (!ignore_msrs) {\n\t\t\tvcpu_unimpl(vcpu, \"unhandled wrmsr: 0x%x data %llx\\n\",\n\t\t\t\t    msr, data);\n\t\t\treturn 1;\n\t\t} else {\n\t\t\tvcpu_unimpl(vcpu, \"ignored wrmsr: 0x%x data %llx\\n\",\n\t\t\t\t    msr, data);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_rip_read",
          "args": [
            "&svm->vcpu"
          ],
          "line": 3535
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_rip_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "27-30",
          "snippet": "static inline unsigned long kvm_rip_read(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_register_read(vcpu, VCPU_REGS_RIP);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline unsigned long kvm_rip_read(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_register_read(vcpu, VCPU_REGS_RIP);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_read_edx_eax",
          "args": [
            "&svm->vcpu"
          ],
          "line": 3529
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_read_edx_eax",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "81-85",
          "snippet": "static inline u64 kvm_read_edx_eax(struct kvm_vcpu *vcpu)\n{\n\treturn (kvm_register_read(vcpu, VCPU_REGS_RAX) & -1u)\n\t\t| ((u64)(kvm_register_read(vcpu, VCPU_REGS_RDX) & -1u) << 32);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline u64 kvm_read_edx_eax(struct kvm_vcpu *vcpu)\n{\n\treturn (kvm_register_read(vcpu, VCPU_REGS_RAX) & -1u)\n\t\t| ((u64)(kvm_register_read(vcpu, VCPU_REGS_RDX) & -1u) << 32);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_register_read",
          "args": [
            "&svm->vcpu",
            "VCPU_REGS_RCX"
          ],
          "line": 3528
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_register_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "9-16",
          "snippet": "static inline unsigned long kvm_register_read(struct kvm_vcpu *vcpu,\n\t\t\t\t\t      enum kvm_reg reg)\n{\n\tif (!test_bit(reg, (unsigned long *)&vcpu->arch.regs_avail))\n\t\tkvm_x86_ops->cache_reg(vcpu, reg);\n\n\treturn vcpu->arch.regs[reg];\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline unsigned long kvm_register_read(struct kvm_vcpu *vcpu,\n\t\t\t\t\t      enum kvm_reg reg)\n{\n\tif (!test_bit(reg, (unsigned long *)&vcpu->arch.regs_avail))\n\t\tkvm_x86_ops->cache_reg(vcpu, reg);\n\n\treturn vcpu->arch.regs[reg];\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic int wrmsr_interception(struct vcpu_svm *svm)\n{\n\tstruct msr_data msr;\n\tu32 ecx = kvm_register_read(&svm->vcpu, VCPU_REGS_RCX);\n\tu64 data = kvm_read_edx_eax(&svm->vcpu);\n\n\tmsr.data = data;\n\tmsr.index = ecx;\n\tmsr.host_initiated = false;\n\n\tsvm->next_rip = kvm_rip_read(&svm->vcpu) + 2;\n\tif (kvm_set_msr(&svm->vcpu, &msr)) {\n\t\ttrace_kvm_msr_write_ex(ecx, data);\n\t\tkvm_inject_gp(&svm->vcpu, 0);\n\t} else {\n\t\ttrace_kvm_msr_write(ecx, data);\n\t\tskip_emulated_instruction(&svm->vcpu);\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "svm_set_msr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "3441-3523",
    "snippet": "static int svm_set_msr(struct kvm_vcpu *vcpu, struct msr_data *msr)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tu32 ecx = msr->index;\n\tu64 data = msr->data;\n\tswitch (ecx) {\n\tcase MSR_IA32_TSC:\n\t\tkvm_write_tsc(vcpu, msr);\n\t\tbreak;\n\tcase MSR_STAR:\n\t\tsvm->vmcb->save.star = data;\n\t\tbreak;\n#ifdef CONFIG_X86_64\n\tcase MSR_LSTAR:\n\t\tsvm->vmcb->save.lstar = data;\n\t\tbreak;\n\tcase MSR_CSTAR:\n\t\tsvm->vmcb->save.cstar = data;\n\t\tbreak;\n\tcase MSR_KERNEL_GS_BASE:\n\t\tsvm->vmcb->save.kernel_gs_base = data;\n\t\tbreak;\n\tcase MSR_SYSCALL_MASK:\n\t\tsvm->vmcb->save.sfmask = data;\n\t\tbreak;\n#endif\n\tcase MSR_IA32_SYSENTER_CS:\n\t\tsvm->vmcb->save.sysenter_cs = data;\n\t\tbreak;\n\tcase MSR_IA32_SYSENTER_EIP:\n\t\tsvm->sysenter_eip = data;\n\t\tsvm->vmcb->save.sysenter_eip = data;\n\t\tbreak;\n\tcase MSR_IA32_SYSENTER_ESP:\n\t\tsvm->sysenter_esp = data;\n\t\tsvm->vmcb->save.sysenter_esp = data;\n\t\tbreak;\n\tcase MSR_TSC_AUX:\n\t\tif (!boot_cpu_has(X86_FEATURE_RDTSCP))\n\t\t\treturn 1;\n\n\t\t/*\n\t\t * This is rare, so we update the MSR here instead of using\n\t\t * direct_access_msrs.  Doing that would require a rdmsr in\n\t\t * svm_vcpu_put.\n\t\t */\n\t\tsvm->tsc_aux = data;\n\t\twrmsrl(MSR_TSC_AUX, svm->tsc_aux);\n\t\tbreak;\n\tcase MSR_IA32_DEBUGCTLMSR:\n\t\tif (!boot_cpu_has(X86_FEATURE_LBRV)) {\n\t\t\tvcpu_unimpl(vcpu, \"%s: MSR_IA32_DEBUGCTL 0x%llx, nop\\n\",\n\t\t\t\t    __func__, data);\n\t\t\tbreak;\n\t\t}\n\t\tif (data & DEBUGCTL_RESERVED_BITS)\n\t\t\treturn 1;\n\n\t\tsvm->vmcb->save.dbgctl = data;\n\t\tmark_dirty(svm->vmcb, VMCB_LBR);\n\t\tif (data & (1ULL<<0))\n\t\t\tsvm_enable_lbrv(svm);\n\t\telse\n\t\t\tsvm_disable_lbrv(svm);\n\t\tbreak;\n\tcase MSR_VM_HSAVE_PA:\n\t\tsvm->nested.hsave_msr = data;\n\t\tbreak;\n\tcase MSR_VM_CR:\n\t\treturn svm_set_vm_cr(vcpu, data);\n\tcase MSR_VM_IGNNE:\n\t\tvcpu_unimpl(vcpu, \"unimplemented wrmsr: 0x%x data 0x%llx\\n\", ecx, data);\n\t\tbreak;\n\tcase MSR_IA32_APICBASE:\n\t\tif (kvm_vcpu_apicv_active(vcpu))\n\t\t\tavic_update_vapic_bar(to_svm(vcpu), data);\n\t\t/* Follow through */\n\tdefault:\n\t\treturn kvm_set_msr_common(vcpu, msr);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define DEBUGCTL_RESERVED_BITS (~(0x3fULL))"
    ],
    "globals_used": [
      "static const struct svm_direct_access_msrs {\n\tu32 index;   /* Index of the MSR */\n\tbool always; /* True if intercept is always on */\n} direct_access_msrs[] = {\n\t{ .index = MSR_STAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_IA32_SYSENTER_CS,\t\t.always = true  },\n#ifdef CONFIG_X86_64\n\t{ .index = MSR_GS_BASE,\t\t\t\t.always = true  },\n\t{ .index = MSR_FS_BASE,\t\t\t\t.always = true  },\n\t{ .index = MSR_KERNEL_GS_BASE,\t\t\t.always = true  },\n\t{ .index = MSR_LSTAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_CSTAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_SYSCALL_MASK,\t\t\t.always = true  },\n#endif\n\t{ .index = MSR_IA32_LASTBRANCHFROMIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTBRANCHTOIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTINTFROMIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTINTTOIP,\t\t.always = false },\n\t{ .index = MSR_INVALID,\t\t\t\t.always = false },\n};",
      "static int nested = true;",
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_set_msr_common",
          "args": [
            "vcpu",
            "msr"
          ],
          "line": 3520
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_set_msr_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "2040-2248",
          "snippet": "int kvm_set_msr_common(struct kvm_vcpu *vcpu, struct msr_data *msr_info)\n{\n\tbool pr = false;\n\tu32 msr = msr_info->index;\n\tu64 data = msr_info->data;\n\n\tswitch (msr) {\n\tcase MSR_AMD64_NB_CFG:\n\tcase MSR_IA32_UCODE_REV:\n\tcase MSR_IA32_UCODE_WRITE:\n\tcase MSR_VM_HSAVE_PA:\n\tcase MSR_AMD64_PATCH_LOADER:\n\tcase MSR_AMD64_BU_CFG2:\n\t\tbreak;\n\n\tcase MSR_EFER:\n\t\treturn set_efer(vcpu, data);\n\tcase MSR_K7_HWCR:\n\t\tdata &= ~(u64)0x40;\t/* ignore flush filter disable */\n\t\tdata &= ~(u64)0x100;\t/* ignore ignne emulation enable */\n\t\tdata &= ~(u64)0x8;\t/* ignore TLB cache disable */\n\t\tdata &= ~(u64)0x40000;  /* ignore Mc status write enable */\n\t\tif (data != 0) {\n\t\t\tvcpu_unimpl(vcpu, \"unimplemented HWCR wrmsr: 0x%llx\\n\",\n\t\t\t\t    data);\n\t\t\treturn 1;\n\t\t}\n\t\tbreak;\n\tcase MSR_FAM10H_MMIO_CONF_BASE:\n\t\tif (data != 0) {\n\t\t\tvcpu_unimpl(vcpu, \"unimplemented MMIO_CONF_BASE wrmsr: \"\n\t\t\t\t    \"0x%llx\\n\", data);\n\t\t\treturn 1;\n\t\t}\n\t\tbreak;\n\tcase MSR_IA32_DEBUGCTLMSR:\n\t\tif (!data) {\n\t\t\t/* We support the non-activated case already */\n\t\t\tbreak;\n\t\t} else if (data & ~(DEBUGCTLMSR_LBR | DEBUGCTLMSR_BTF)) {\n\t\t\t/* Values other than LBR and BTF are vendor-specific,\n\t\t\t   thus reserved and should throw a #GP */\n\t\t\treturn 1;\n\t\t}\n\t\tvcpu_unimpl(vcpu, \"%s: MSR_IA32_DEBUGCTLMSR 0x%llx, nop\\n\",\n\t\t\t    __func__, data);\n\t\tbreak;\n\tcase 0x200 ... 0x2ff:\n\t\treturn kvm_mtrr_set_msr(vcpu, msr, data);\n\tcase MSR_IA32_APICBASE:\n\t\treturn kvm_set_apic_base(vcpu, msr_info);\n\tcase APIC_BASE_MSR ... APIC_BASE_MSR + 0x3ff:\n\t\treturn kvm_x2apic_msr_write(vcpu, msr, data);\n\tcase MSR_IA32_TSCDEADLINE:\n\t\tkvm_set_lapic_tscdeadline_msr(vcpu, data);\n\t\tbreak;\n\tcase MSR_IA32_TSC_ADJUST:\n\t\tif (guest_cpuid_has_tsc_adjust(vcpu)) {\n\t\t\tif (!msr_info->host_initiated) {\n\t\t\t\ts64 adj = data - vcpu->arch.ia32_tsc_adjust_msr;\n\t\t\t\tadjust_tsc_offset_guest(vcpu, adj);\n\t\t\t}\n\t\t\tvcpu->arch.ia32_tsc_adjust_msr = data;\n\t\t}\n\t\tbreak;\n\tcase MSR_IA32_MISC_ENABLE:\n\t\tvcpu->arch.ia32_misc_enable_msr = data;\n\t\tbreak;\n\tcase MSR_IA32_SMBASE:\n\t\tif (!msr_info->host_initiated)\n\t\t\treturn 1;\n\t\tvcpu->arch.smbase = data;\n\t\tbreak;\n\tcase MSR_KVM_WALL_CLOCK_NEW:\n\tcase MSR_KVM_WALL_CLOCK:\n\t\tvcpu->kvm->arch.wall_clock = data;\n\t\tkvm_write_wall_clock(vcpu->kvm, data);\n\t\tbreak;\n\tcase MSR_KVM_SYSTEM_TIME_NEW:\n\tcase MSR_KVM_SYSTEM_TIME: {\n\t\tu64 gpa_offset;\n\t\tstruct kvm_arch *ka = &vcpu->kvm->arch;\n\n\t\tkvmclock_reset(vcpu);\n\n\t\tif (vcpu->vcpu_id == 0 && !msr_info->host_initiated) {\n\t\t\tbool tmp = (msr == MSR_KVM_SYSTEM_TIME);\n\n\t\t\tif (ka->boot_vcpu_runs_old_kvmclock != tmp)\n\t\t\t\tset_bit(KVM_REQ_MASTERCLOCK_UPDATE,\n\t\t\t\t\t&vcpu->requests);\n\n\t\t\tka->boot_vcpu_runs_old_kvmclock = tmp;\n\t\t}\n\n\t\tvcpu->arch.time = data;\n\t\tkvm_make_request(KVM_REQ_GLOBAL_CLOCK_UPDATE, vcpu);\n\n\t\t/* we verify if the enable bit is set... */\n\t\tif (!(data & 1))\n\t\t\tbreak;\n\n\t\tgpa_offset = data & ~(PAGE_MASK | 1);\n\n\t\tif (kvm_gfn_to_hva_cache_init(vcpu->kvm,\n\t\t     &vcpu->arch.pv_time, data & ~1ULL,\n\t\t     sizeof(struct pvclock_vcpu_time_info)))\n\t\t\tvcpu->arch.pv_time_enabled = false;\n\t\telse\n\t\t\tvcpu->arch.pv_time_enabled = true;\n\n\t\tbreak;\n\t}\n\tcase MSR_KVM_ASYNC_PF_EN:\n\t\tif (kvm_pv_enable_async_pf(vcpu, data))\n\t\t\treturn 1;\n\t\tbreak;\n\tcase MSR_KVM_STEAL_TIME:\n\n\t\tif (unlikely(!sched_info_on()))\n\t\t\treturn 1;\n\n\t\tif (data & KVM_STEAL_RESERVED_MASK)\n\t\t\treturn 1;\n\n\t\tif (kvm_gfn_to_hva_cache_init(vcpu->kvm, &vcpu->arch.st.stime,\n\t\t\t\t\t\tdata & KVM_STEAL_VALID_BITS,\n\t\t\t\t\t\tsizeof(struct kvm_steal_time)))\n\t\t\treturn 1;\n\n\t\tvcpu->arch.st.msr_val = data;\n\n\t\tif (!(data & KVM_MSR_ENABLED))\n\t\t\tbreak;\n\n\t\tkvm_make_request(KVM_REQ_STEAL_UPDATE, vcpu);\n\n\t\tbreak;\n\tcase MSR_KVM_PV_EOI_EN:\n\t\tif (kvm_lapic_enable_pv_eoi(vcpu, data))\n\t\t\treturn 1;\n\t\tbreak;\n\n\tcase MSR_IA32_MCG_CTL:\n\tcase MSR_IA32_MCG_STATUS:\n\tcase MSR_IA32_MC0_CTL ... MSR_IA32_MCx_CTL(KVM_MAX_MCE_BANKS) - 1:\n\t\treturn set_msr_mce(vcpu, msr, data);\n\n\tcase MSR_K7_PERFCTR0 ... MSR_K7_PERFCTR3:\n\tcase MSR_P6_PERFCTR0 ... MSR_P6_PERFCTR1:\n\t\tpr = true; /* fall through */\n\tcase MSR_K7_EVNTSEL0 ... MSR_K7_EVNTSEL3:\n\tcase MSR_P6_EVNTSEL0 ... MSR_P6_EVNTSEL1:\n\t\tif (kvm_pmu_is_valid_msr(vcpu, msr))\n\t\t\treturn kvm_pmu_set_msr(vcpu, msr_info);\n\n\t\tif (pr || data != 0)\n\t\t\tvcpu_unimpl(vcpu, \"disabled perfctr wrmsr: \"\n\t\t\t\t    \"0x%x data 0x%llx\\n\", msr, data);\n\t\tbreak;\n\tcase MSR_K7_CLK_CTL:\n\t\t/*\n\t\t * Ignore all writes to this no longer documented MSR.\n\t\t * Writes are only relevant for old K7 processors,\n\t\t * all pre-dating SVM, but a recommended workaround from\n\t\t * AMD for these chips. It is possible to specify the\n\t\t * affected processor models on the command line, hence\n\t\t * the need to ignore the workaround.\n\t\t */\n\t\tbreak;\n\tcase HV_X64_MSR_GUEST_OS_ID ... HV_X64_MSR_SINT15:\n\tcase HV_X64_MSR_CRASH_P0 ... HV_X64_MSR_CRASH_P4:\n\tcase HV_X64_MSR_CRASH_CTL:\n\tcase HV_X64_MSR_STIMER0_CONFIG ... HV_X64_MSR_STIMER3_COUNT:\n\t\treturn kvm_hv_set_msr_common(vcpu, msr, data,\n\t\t\t\t\t     msr_info->host_initiated);\n\tcase MSR_IA32_BBL_CR_CTL3:\n\t\t/* Drop writes to this legacy MSR -- see rdmsr\n\t\t * counterpart for further detail.\n\t\t */\n\t\tvcpu_unimpl(vcpu, \"ignored wrmsr: 0x%x data %llx\\n\", msr, data);\n\t\tbreak;\n\tcase MSR_AMD64_OSVW_ID_LENGTH:\n\t\tif (!guest_cpuid_has_osvw(vcpu))\n\t\t\treturn 1;\n\t\tvcpu->arch.osvw.length = data;\n\t\tbreak;\n\tcase MSR_AMD64_OSVW_STATUS:\n\t\tif (!guest_cpuid_has_osvw(vcpu))\n\t\t\treturn 1;\n\t\tvcpu->arch.osvw.status = data;\n\t\tbreak;\n\tdefault:\n\t\tif (msr && (msr == vcpu->kvm->arch.xen_hvm_config.msr))\n\t\t\treturn xen_hvm_config(vcpu, data);\n\t\tif (kvm_pmu_is_valid_msr(vcpu, msr))\n\t\t\treturn kvm_pmu_set_msr(vcpu, msr_info);\n\t\tif (!ignore_msrs) {\n\t\t\tvcpu_unimpl(vcpu, \"unhandled wrmsr: 0x%x data %llx\\n\",\n\t\t\t\t    msr, data);\n\t\t\treturn 1;\n\t\t} else {\n\t\t\tvcpu_unimpl(vcpu, \"ignored wrmsr: 0x%x data %llx\\n\",\n\t\t\t\t    msr, data);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define KVM_MAX_MCE_BANKS 32"
          ],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define KVM_MAX_MCE_BANKS 32\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nint kvm_set_msr_common(struct kvm_vcpu *vcpu, struct msr_data *msr_info)\n{\n\tbool pr = false;\n\tu32 msr = msr_info->index;\n\tu64 data = msr_info->data;\n\n\tswitch (msr) {\n\tcase MSR_AMD64_NB_CFG:\n\tcase MSR_IA32_UCODE_REV:\n\tcase MSR_IA32_UCODE_WRITE:\n\tcase MSR_VM_HSAVE_PA:\n\tcase MSR_AMD64_PATCH_LOADER:\n\tcase MSR_AMD64_BU_CFG2:\n\t\tbreak;\n\n\tcase MSR_EFER:\n\t\treturn set_efer(vcpu, data);\n\tcase MSR_K7_HWCR:\n\t\tdata &= ~(u64)0x40;\t/* ignore flush filter disable */\n\t\tdata &= ~(u64)0x100;\t/* ignore ignne emulation enable */\n\t\tdata &= ~(u64)0x8;\t/* ignore TLB cache disable */\n\t\tdata &= ~(u64)0x40000;  /* ignore Mc status write enable */\n\t\tif (data != 0) {\n\t\t\tvcpu_unimpl(vcpu, \"unimplemented HWCR wrmsr: 0x%llx\\n\",\n\t\t\t\t    data);\n\t\t\treturn 1;\n\t\t}\n\t\tbreak;\n\tcase MSR_FAM10H_MMIO_CONF_BASE:\n\t\tif (data != 0) {\n\t\t\tvcpu_unimpl(vcpu, \"unimplemented MMIO_CONF_BASE wrmsr: \"\n\t\t\t\t    \"0x%llx\\n\", data);\n\t\t\treturn 1;\n\t\t}\n\t\tbreak;\n\tcase MSR_IA32_DEBUGCTLMSR:\n\t\tif (!data) {\n\t\t\t/* We support the non-activated case already */\n\t\t\tbreak;\n\t\t} else if (data & ~(DEBUGCTLMSR_LBR | DEBUGCTLMSR_BTF)) {\n\t\t\t/* Values other than LBR and BTF are vendor-specific,\n\t\t\t   thus reserved and should throw a #GP */\n\t\t\treturn 1;\n\t\t}\n\t\tvcpu_unimpl(vcpu, \"%s: MSR_IA32_DEBUGCTLMSR 0x%llx, nop\\n\",\n\t\t\t    __func__, data);\n\t\tbreak;\n\tcase 0x200 ... 0x2ff:\n\t\treturn kvm_mtrr_set_msr(vcpu, msr, data);\n\tcase MSR_IA32_APICBASE:\n\t\treturn kvm_set_apic_base(vcpu, msr_info);\n\tcase APIC_BASE_MSR ... APIC_BASE_MSR + 0x3ff:\n\t\treturn kvm_x2apic_msr_write(vcpu, msr, data);\n\tcase MSR_IA32_TSCDEADLINE:\n\t\tkvm_set_lapic_tscdeadline_msr(vcpu, data);\n\t\tbreak;\n\tcase MSR_IA32_TSC_ADJUST:\n\t\tif (guest_cpuid_has_tsc_adjust(vcpu)) {\n\t\t\tif (!msr_info->host_initiated) {\n\t\t\t\ts64 adj = data - vcpu->arch.ia32_tsc_adjust_msr;\n\t\t\t\tadjust_tsc_offset_guest(vcpu, adj);\n\t\t\t}\n\t\t\tvcpu->arch.ia32_tsc_adjust_msr = data;\n\t\t}\n\t\tbreak;\n\tcase MSR_IA32_MISC_ENABLE:\n\t\tvcpu->arch.ia32_misc_enable_msr = data;\n\t\tbreak;\n\tcase MSR_IA32_SMBASE:\n\t\tif (!msr_info->host_initiated)\n\t\t\treturn 1;\n\t\tvcpu->arch.smbase = data;\n\t\tbreak;\n\tcase MSR_KVM_WALL_CLOCK_NEW:\n\tcase MSR_KVM_WALL_CLOCK:\n\t\tvcpu->kvm->arch.wall_clock = data;\n\t\tkvm_write_wall_clock(vcpu->kvm, data);\n\t\tbreak;\n\tcase MSR_KVM_SYSTEM_TIME_NEW:\n\tcase MSR_KVM_SYSTEM_TIME: {\n\t\tu64 gpa_offset;\n\t\tstruct kvm_arch *ka = &vcpu->kvm->arch;\n\n\t\tkvmclock_reset(vcpu);\n\n\t\tif (vcpu->vcpu_id == 0 && !msr_info->host_initiated) {\n\t\t\tbool tmp = (msr == MSR_KVM_SYSTEM_TIME);\n\n\t\t\tif (ka->boot_vcpu_runs_old_kvmclock != tmp)\n\t\t\t\tset_bit(KVM_REQ_MASTERCLOCK_UPDATE,\n\t\t\t\t\t&vcpu->requests);\n\n\t\t\tka->boot_vcpu_runs_old_kvmclock = tmp;\n\t\t}\n\n\t\tvcpu->arch.time = data;\n\t\tkvm_make_request(KVM_REQ_GLOBAL_CLOCK_UPDATE, vcpu);\n\n\t\t/* we verify if the enable bit is set... */\n\t\tif (!(data & 1))\n\t\t\tbreak;\n\n\t\tgpa_offset = data & ~(PAGE_MASK | 1);\n\n\t\tif (kvm_gfn_to_hva_cache_init(vcpu->kvm,\n\t\t     &vcpu->arch.pv_time, data & ~1ULL,\n\t\t     sizeof(struct pvclock_vcpu_time_info)))\n\t\t\tvcpu->arch.pv_time_enabled = false;\n\t\telse\n\t\t\tvcpu->arch.pv_time_enabled = true;\n\n\t\tbreak;\n\t}\n\tcase MSR_KVM_ASYNC_PF_EN:\n\t\tif (kvm_pv_enable_async_pf(vcpu, data))\n\t\t\treturn 1;\n\t\tbreak;\n\tcase MSR_KVM_STEAL_TIME:\n\n\t\tif (unlikely(!sched_info_on()))\n\t\t\treturn 1;\n\n\t\tif (data & KVM_STEAL_RESERVED_MASK)\n\t\t\treturn 1;\n\n\t\tif (kvm_gfn_to_hva_cache_init(vcpu->kvm, &vcpu->arch.st.stime,\n\t\t\t\t\t\tdata & KVM_STEAL_VALID_BITS,\n\t\t\t\t\t\tsizeof(struct kvm_steal_time)))\n\t\t\treturn 1;\n\n\t\tvcpu->arch.st.msr_val = data;\n\n\t\tif (!(data & KVM_MSR_ENABLED))\n\t\t\tbreak;\n\n\t\tkvm_make_request(KVM_REQ_STEAL_UPDATE, vcpu);\n\n\t\tbreak;\n\tcase MSR_KVM_PV_EOI_EN:\n\t\tif (kvm_lapic_enable_pv_eoi(vcpu, data))\n\t\t\treturn 1;\n\t\tbreak;\n\n\tcase MSR_IA32_MCG_CTL:\n\tcase MSR_IA32_MCG_STATUS:\n\tcase MSR_IA32_MC0_CTL ... MSR_IA32_MCx_CTL(KVM_MAX_MCE_BANKS) - 1:\n\t\treturn set_msr_mce(vcpu, msr, data);\n\n\tcase MSR_K7_PERFCTR0 ... MSR_K7_PERFCTR3:\n\tcase MSR_P6_PERFCTR0 ... MSR_P6_PERFCTR1:\n\t\tpr = true; /* fall through */\n\tcase MSR_K7_EVNTSEL0 ... MSR_K7_EVNTSEL3:\n\tcase MSR_P6_EVNTSEL0 ... MSR_P6_EVNTSEL1:\n\t\tif (kvm_pmu_is_valid_msr(vcpu, msr))\n\t\t\treturn kvm_pmu_set_msr(vcpu, msr_info);\n\n\t\tif (pr || data != 0)\n\t\t\tvcpu_unimpl(vcpu, \"disabled perfctr wrmsr: \"\n\t\t\t\t    \"0x%x data 0x%llx\\n\", msr, data);\n\t\tbreak;\n\tcase MSR_K7_CLK_CTL:\n\t\t/*\n\t\t * Ignore all writes to this no longer documented MSR.\n\t\t * Writes are only relevant for old K7 processors,\n\t\t * all pre-dating SVM, but a recommended workaround from\n\t\t * AMD for these chips. It is possible to specify the\n\t\t * affected processor models on the command line, hence\n\t\t * the need to ignore the workaround.\n\t\t */\n\t\tbreak;\n\tcase HV_X64_MSR_GUEST_OS_ID ... HV_X64_MSR_SINT15:\n\tcase HV_X64_MSR_CRASH_P0 ... HV_X64_MSR_CRASH_P4:\n\tcase HV_X64_MSR_CRASH_CTL:\n\tcase HV_X64_MSR_STIMER0_CONFIG ... HV_X64_MSR_STIMER3_COUNT:\n\t\treturn kvm_hv_set_msr_common(vcpu, msr, data,\n\t\t\t\t\t     msr_info->host_initiated);\n\tcase MSR_IA32_BBL_CR_CTL3:\n\t\t/* Drop writes to this legacy MSR -- see rdmsr\n\t\t * counterpart for further detail.\n\t\t */\n\t\tvcpu_unimpl(vcpu, \"ignored wrmsr: 0x%x data %llx\\n\", msr, data);\n\t\tbreak;\n\tcase MSR_AMD64_OSVW_ID_LENGTH:\n\t\tif (!guest_cpuid_has_osvw(vcpu))\n\t\t\treturn 1;\n\t\tvcpu->arch.osvw.length = data;\n\t\tbreak;\n\tcase MSR_AMD64_OSVW_STATUS:\n\t\tif (!guest_cpuid_has_osvw(vcpu))\n\t\t\treturn 1;\n\t\tvcpu->arch.osvw.status = data;\n\t\tbreak;\n\tdefault:\n\t\tif (msr && (msr == vcpu->kvm->arch.xen_hvm_config.msr))\n\t\t\treturn xen_hvm_config(vcpu, data);\n\t\tif (kvm_pmu_is_valid_msr(vcpu, msr))\n\t\t\treturn kvm_pmu_set_msr(vcpu, msr_info);\n\t\tif (!ignore_msrs) {\n\t\t\tvcpu_unimpl(vcpu, \"unhandled wrmsr: 0x%x data %llx\\n\",\n\t\t\t\t    msr, data);\n\t\t\treturn 1;\n\t\t} else {\n\t\t\tvcpu_unimpl(vcpu, \"ignored wrmsr: 0x%x data %llx\\n\",\n\t\t\t\t    msr, data);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "avic_update_vapic_bar",
          "args": [
            "to_svm(vcpu)",
            "data"
          ],
          "line": 3517
        },
        "resolved": true,
        "details": {
          "function_name": "avic_update_vapic_bar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "299-303",
          "snippet": "static inline void avic_update_vapic_bar(struct vcpu_svm *svm, u64 data)\n{\n\tsvm->vmcb->control.avic_vapic_bar = data & VMCB_AVIC_APIC_BAR_MASK;\n\tmark_dirty(svm->vmcb, VMCB_AVIC);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define VMCB_AVIC_APIC_BAR_MASK\t\t0xFFFFFFFFFF000ULL"
          ],
          "globals_used": [
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define VMCB_AVIC_APIC_BAR_MASK\t\t0xFFFFFFFFFF000ULL\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic inline void avic_update_vapic_bar(struct vcpu_svm *svm, u64 data)\n{\n\tsvm->vmcb->control.avic_vapic_bar = data & VMCB_AVIC_APIC_BAR_MASK;\n\tmark_dirty(svm->vmcb, VMCB_AVIC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 3517
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "294-297",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_apicv_active",
          "args": [
            "vcpu"
          ],
          "line": 3516
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_vcpu_apicv_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.h",
          "lines": "181-184",
          "snippet": "static inline bool kvm_vcpu_apicv_active(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.apic && vcpu->arch.apicv_active;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline bool kvm_vcpu_apicv_active(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.apic && vcpu->arch.apicv_active;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vcpu_unimpl",
          "args": [
            "vcpu",
            "\"unimplemented wrmsr: 0x%x data 0x%llx\\n\"",
            "ecx",
            "data"
          ],
          "line": 3513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svm_set_vm_cr",
          "args": [
            "vcpu",
            "data"
          ],
          "line": 3511
        },
        "resolved": true,
        "details": {
          "function_name": "svm_set_vm_cr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "3416-3439",
          "snippet": "static int svm_set_vm_cr(struct kvm_vcpu *vcpu, u64 data)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tint svm_dis, chg_mask;\n\n\tif (data & ~SVM_VM_CR_VALID_MASK)\n\t\treturn 1;\n\n\tchg_mask = SVM_VM_CR_VALID_MASK;\n\n\tif (svm->nested.vm_cr_msr & SVM_VM_CR_SVM_DIS_MASK)\n\t\tchg_mask &= ~(SVM_VM_CR_SVM_LOCK_MASK | SVM_VM_CR_SVM_DIS_MASK);\n\n\tsvm->nested.vm_cr_msr &= ~chg_mask;\n\tsvm->nested.vm_cr_msr |= (data & chg_mask);\n\n\tsvm_dis = svm->nested.vm_cr_msr & SVM_VM_CR_SVM_DIS_MASK;\n\n\t/* check for svm_disable while efer.svme is set */\n\tif (svm_dis && (vcpu->arch.efer & EFER_SVME))\n\t\treturn 1;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nested = true;",
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int nested = true;\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic int svm_set_vm_cr(struct kvm_vcpu *vcpu, u64 data)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tint svm_dis, chg_mask;\n\n\tif (data & ~SVM_VM_CR_VALID_MASK)\n\t\treturn 1;\n\n\tchg_mask = SVM_VM_CR_VALID_MASK;\n\n\tif (svm->nested.vm_cr_msr & SVM_VM_CR_SVM_DIS_MASK)\n\t\tchg_mask &= ~(SVM_VM_CR_SVM_LOCK_MASK | SVM_VM_CR_SVM_DIS_MASK);\n\n\tsvm->nested.vm_cr_msr &= ~chg_mask;\n\tsvm->nested.vm_cr_msr |= (data & chg_mask);\n\n\tsvm_dis = svm->nested.vm_cr_msr & SVM_VM_CR_SVM_DIS_MASK;\n\n\t/* check for svm_disable while efer.svme is set */\n\tif (svm_dis && (vcpu->arch.efer & EFER_SVME))\n\t\treturn 1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "svm_disable_lbrv",
          "args": [
            "svm"
          ],
          "line": 3505
        },
        "resolved": true,
        "details": {
          "function_name": "svm_disable_lbrv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "918-927",
          "snippet": "static void svm_disable_lbrv(struct vcpu_svm *svm)\n{\n\tu32 *msrpm = svm->msrpm;\n\n\tsvm->vmcb->control.lbr_ctl = 0;\n\tset_msr_interception(msrpm, MSR_IA32_LASTBRANCHFROMIP, 0, 0);\n\tset_msr_interception(msrpm, MSR_IA32_LASTBRANCHTOIP, 0, 0);\n\tset_msr_interception(msrpm, MSR_IA32_LASTINTFROMIP, 0, 0);\n\tset_msr_interception(msrpm, MSR_IA32_LASTINTTOIP, 0, 0);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic void svm_disable_lbrv(struct vcpu_svm *svm)\n{\n\tu32 *msrpm = svm->msrpm;\n\n\tsvm->vmcb->control.lbr_ctl = 0;\n\tset_msr_interception(msrpm, MSR_IA32_LASTBRANCHFROMIP, 0, 0);\n\tset_msr_interception(msrpm, MSR_IA32_LASTBRANCHTOIP, 0, 0);\n\tset_msr_interception(msrpm, MSR_IA32_LASTINTFROMIP, 0, 0);\n\tset_msr_interception(msrpm, MSR_IA32_LASTINTTOIP, 0, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "svm_enable_lbrv",
          "args": [
            "svm"
          ],
          "line": 3503
        },
        "resolved": true,
        "details": {
          "function_name": "svm_enable_lbrv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "907-916",
          "snippet": "static void svm_enable_lbrv(struct vcpu_svm *svm)\n{\n\tu32 *msrpm = svm->msrpm;\n\n\tsvm->vmcb->control.lbr_ctl = 1;\n\tset_msr_interception(msrpm, MSR_IA32_LASTBRANCHFROMIP, 1, 1);\n\tset_msr_interception(msrpm, MSR_IA32_LASTBRANCHTOIP, 1, 1);\n\tset_msr_interception(msrpm, MSR_IA32_LASTINTFROMIP, 1, 1);\n\tset_msr_interception(msrpm, MSR_IA32_LASTINTTOIP, 1, 1);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic void svm_enable_lbrv(struct vcpu_svm *svm)\n{\n\tu32 *msrpm = svm->msrpm;\n\n\tsvm->vmcb->control.lbr_ctl = 1;\n\tset_msr_interception(msrpm, MSR_IA32_LASTBRANCHFROMIP, 1, 1);\n\tset_msr_interception(msrpm, MSR_IA32_LASTBRANCHTOIP, 1, 1);\n\tset_msr_interception(msrpm, MSR_IA32_LASTINTFROMIP, 1, 1);\n\tset_msr_interception(msrpm, MSR_IA32_LASTINTTOIP, 1, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_dirty",
          "args": [
            "svm->vmcb",
            "VMCB_LBR"
          ],
          "line": 3501
        },
        "resolved": true,
        "details": {
          "function_name": "mark_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "289-292",
          "snippet": "static inline void mark_dirty(struct vmcb *vmcb, int bit)\n{\n\tvmcb->control.clean &= ~(1 << bit);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic inline void mark_dirty(struct vmcb *vmcb, int bit)\n{\n\tvmcb->control.clean &= ~(1 << bit);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vcpu_unimpl",
          "args": [
            "vcpu",
            "\"%s: MSR_IA32_DEBUGCTL 0x%llx, nop\\n\"",
            "__func__",
            "data"
          ],
          "line": 3493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "boot_cpu_has",
          "args": [
            "X86_FEATURE_LBRV"
          ],
          "line": 3492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wrmsrl",
          "args": [
            "MSR_TSC_AUX",
            "svm->tsc_aux"
          ],
          "line": 3489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "boot_cpu_has",
          "args": [
            "X86_FEATURE_RDTSCP"
          ],
          "line": 3480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_write_tsc",
          "args": [
            "vcpu",
            "msr"
          ],
          "line": 3449
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define DEBUGCTL_RESERVED_BITS (~(0x3fULL))\n\nstatic const struct svm_direct_access_msrs {\n\tu32 index;   /* Index of the MSR */\n\tbool always; /* True if intercept is always on */\n} direct_access_msrs[] = {\n\t{ .index = MSR_STAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_IA32_SYSENTER_CS,\t\t.always = true  },\n#ifdef CONFIG_X86_64\n\t{ .index = MSR_GS_BASE,\t\t\t\t.always = true  },\n\t{ .index = MSR_FS_BASE,\t\t\t\t.always = true  },\n\t{ .index = MSR_KERNEL_GS_BASE,\t\t\t.always = true  },\n\t{ .index = MSR_LSTAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_CSTAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_SYSCALL_MASK,\t\t\t.always = true  },\n#endif\n\t{ .index = MSR_IA32_LASTBRANCHFROMIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTBRANCHTOIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTINTFROMIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTINTTOIP,\t\t.always = false },\n\t{ .index = MSR_INVALID,\t\t\t\t.always = false },\n};\nstatic int nested = true;\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic int svm_set_msr(struct kvm_vcpu *vcpu, struct msr_data *msr)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tu32 ecx = msr->index;\n\tu64 data = msr->data;\n\tswitch (ecx) {\n\tcase MSR_IA32_TSC:\n\t\tkvm_write_tsc(vcpu, msr);\n\t\tbreak;\n\tcase MSR_STAR:\n\t\tsvm->vmcb->save.star = data;\n\t\tbreak;\n#ifdef CONFIG_X86_64\n\tcase MSR_LSTAR:\n\t\tsvm->vmcb->save.lstar = data;\n\t\tbreak;\n\tcase MSR_CSTAR:\n\t\tsvm->vmcb->save.cstar = data;\n\t\tbreak;\n\tcase MSR_KERNEL_GS_BASE:\n\t\tsvm->vmcb->save.kernel_gs_base = data;\n\t\tbreak;\n\tcase MSR_SYSCALL_MASK:\n\t\tsvm->vmcb->save.sfmask = data;\n\t\tbreak;\n#endif\n\tcase MSR_IA32_SYSENTER_CS:\n\t\tsvm->vmcb->save.sysenter_cs = data;\n\t\tbreak;\n\tcase MSR_IA32_SYSENTER_EIP:\n\t\tsvm->sysenter_eip = data;\n\t\tsvm->vmcb->save.sysenter_eip = data;\n\t\tbreak;\n\tcase MSR_IA32_SYSENTER_ESP:\n\t\tsvm->sysenter_esp = data;\n\t\tsvm->vmcb->save.sysenter_esp = data;\n\t\tbreak;\n\tcase MSR_TSC_AUX:\n\t\tif (!boot_cpu_has(X86_FEATURE_RDTSCP))\n\t\t\treturn 1;\n\n\t\t/*\n\t\t * This is rare, so we update the MSR here instead of using\n\t\t * direct_access_msrs.  Doing that would require a rdmsr in\n\t\t * svm_vcpu_put.\n\t\t */\n\t\tsvm->tsc_aux = data;\n\t\twrmsrl(MSR_TSC_AUX, svm->tsc_aux);\n\t\tbreak;\n\tcase MSR_IA32_DEBUGCTLMSR:\n\t\tif (!boot_cpu_has(X86_FEATURE_LBRV)) {\n\t\t\tvcpu_unimpl(vcpu, \"%s: MSR_IA32_DEBUGCTL 0x%llx, nop\\n\",\n\t\t\t\t    __func__, data);\n\t\t\tbreak;\n\t\t}\n\t\tif (data & DEBUGCTL_RESERVED_BITS)\n\t\t\treturn 1;\n\n\t\tsvm->vmcb->save.dbgctl = data;\n\t\tmark_dirty(svm->vmcb, VMCB_LBR);\n\t\tif (data & (1ULL<<0))\n\t\t\tsvm_enable_lbrv(svm);\n\t\telse\n\t\t\tsvm_disable_lbrv(svm);\n\t\tbreak;\n\tcase MSR_VM_HSAVE_PA:\n\t\tsvm->nested.hsave_msr = data;\n\t\tbreak;\n\tcase MSR_VM_CR:\n\t\treturn svm_set_vm_cr(vcpu, data);\n\tcase MSR_VM_IGNNE:\n\t\tvcpu_unimpl(vcpu, \"unimplemented wrmsr: 0x%x data 0x%llx\\n\", ecx, data);\n\t\tbreak;\n\tcase MSR_IA32_APICBASE:\n\t\tif (kvm_vcpu_apicv_active(vcpu))\n\t\t\tavic_update_vapic_bar(to_svm(vcpu), data);\n\t\t/* Follow through */\n\tdefault:\n\t\treturn kvm_set_msr_common(vcpu, msr);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "svm_set_vm_cr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "3416-3439",
    "snippet": "static int svm_set_vm_cr(struct kvm_vcpu *vcpu, u64 data)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tint svm_dis, chg_mask;\n\n\tif (data & ~SVM_VM_CR_VALID_MASK)\n\t\treturn 1;\n\n\tchg_mask = SVM_VM_CR_VALID_MASK;\n\n\tif (svm->nested.vm_cr_msr & SVM_VM_CR_SVM_DIS_MASK)\n\t\tchg_mask &= ~(SVM_VM_CR_SVM_LOCK_MASK | SVM_VM_CR_SVM_DIS_MASK);\n\n\tsvm->nested.vm_cr_msr &= ~chg_mask;\n\tsvm->nested.vm_cr_msr |= (data & chg_mask);\n\n\tsvm_dis = svm->nested.vm_cr_msr & SVM_VM_CR_SVM_DIS_MASK;\n\n\t/* check for svm_disable while efer.svme is set */\n\tif (svm_dis && (vcpu->arch.efer & EFER_SVME))\n\t\treturn 1;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int nested = true;",
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 3418
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "294-297",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int nested = true;\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic int svm_set_vm_cr(struct kvm_vcpu *vcpu, u64 data)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tint svm_dis, chg_mask;\n\n\tif (data & ~SVM_VM_CR_VALID_MASK)\n\t\treturn 1;\n\n\tchg_mask = SVM_VM_CR_VALID_MASK;\n\n\tif (svm->nested.vm_cr_msr & SVM_VM_CR_SVM_DIS_MASK)\n\t\tchg_mask &= ~(SVM_VM_CR_SVM_LOCK_MASK | SVM_VM_CR_SVM_DIS_MASK);\n\n\tsvm->nested.vm_cr_msr &= ~chg_mask;\n\tsvm->nested.vm_cr_msr |= (data & chg_mask);\n\n\tsvm_dis = svm->nested.vm_cr_msr & SVM_VM_CR_SVM_DIS_MASK;\n\n\t/* check for svm_disable while efer.svme is set */\n\tif (svm_dis && (vcpu->arch.efer & EFER_SVME))\n\t\treturn 1;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "rdmsr_interception",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "3393-3414",
    "snippet": "static int rdmsr_interception(struct vcpu_svm *svm)\n{\n\tu32 ecx = kvm_register_read(&svm->vcpu, VCPU_REGS_RCX);\n\tstruct msr_data msr_info;\n\n\tmsr_info.index = ecx;\n\tmsr_info.host_initiated = false;\n\tif (svm_get_msr(&svm->vcpu, &msr_info)) {\n\t\ttrace_kvm_msr_read_ex(ecx);\n\t\tkvm_inject_gp(&svm->vcpu, 0);\n\t} else {\n\t\ttrace_kvm_msr_read(ecx, msr_info.data);\n\n\t\tkvm_register_write(&svm->vcpu, VCPU_REGS_RAX,\n\t\t\t\t   msr_info.data & 0xffffffff);\n\t\tkvm_register_write(&svm->vcpu, VCPU_REGS_RDX,\n\t\t\t\t   msr_info.data >> 32);\n\t\tsvm->next_rip = kvm_rip_read(&svm->vcpu) + 2;\n\t\tskip_emulated_instruction(&svm->vcpu);\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "skip_emulated_instruction",
          "args": [
            "&svm->vcpu"
          ],
          "line": 3411
        },
        "resolved": true,
        "details": {
          "function_name": "skip_emulated_instruction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "572-593",
          "snippet": "static void skip_emulated_instruction(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (svm->vmcb->control.next_rip != 0) {\n\t\tWARN_ON_ONCE(!static_cpu_has(X86_FEATURE_NRIPS));\n\t\tsvm->next_rip = svm->vmcb->control.next_rip;\n\t}\n\n\tif (!svm->next_rip) {\n\t\tif (emulate_instruction(vcpu, EMULTYPE_SKIP) !=\n\t\t\t\tEMULATE_DONE)\n\t\t\tprintk(KERN_DEBUG \"%s: NOP\\n\", __func__);\n\t\treturn;\n\t}\n\tif (svm->next_rip - kvm_rip_read(vcpu) > MAX_INST_SIZE)\n\t\tprintk(KERN_ERR \"%s: ip 0x%lx next 0x%llx\\n\",\n\t\t       __func__, kvm_rip_read(vcpu), svm->next_rip);\n\n\tkvm_rip_write(vcpu, svm->next_rip);\n\tsvm_set_interrupt_shadow(vcpu, 0);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define MAX_INST_SIZE 15"
          ],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define MAX_INST_SIZE 15\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic void skip_emulated_instruction(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (svm->vmcb->control.next_rip != 0) {\n\t\tWARN_ON_ONCE(!static_cpu_has(X86_FEATURE_NRIPS));\n\t\tsvm->next_rip = svm->vmcb->control.next_rip;\n\t}\n\n\tif (!svm->next_rip) {\n\t\tif (emulate_instruction(vcpu, EMULTYPE_SKIP) !=\n\t\t\t\tEMULATE_DONE)\n\t\t\tprintk(KERN_DEBUG \"%s: NOP\\n\", __func__);\n\t\treturn;\n\t}\n\tif (svm->next_rip - kvm_rip_read(vcpu) > MAX_INST_SIZE)\n\t\tprintk(KERN_ERR \"%s: ip 0x%lx next 0x%llx\\n\",\n\t\t       __func__, kvm_rip_read(vcpu), svm->next_rip);\n\n\tkvm_rip_write(vcpu, svm->next_rip);\n\tsvm_set_interrupt_shadow(vcpu, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_rip_read",
          "args": [
            "&svm->vcpu"
          ],
          "line": 3410
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_rip_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "27-30",
          "snippet": "static inline unsigned long kvm_rip_read(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_register_read(vcpu, VCPU_REGS_RIP);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline unsigned long kvm_rip_read(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_register_read(vcpu, VCPU_REGS_RIP);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_register_write",
          "args": [
            "&svm->vcpu",
            "VCPU_REGS_RDX",
            "msr_info.data >> 32"
          ],
          "line": 3408
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_register_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "18-25",
          "snippet": "static inline void kvm_register_write(struct kvm_vcpu *vcpu,\n\t\t\t\t      enum kvm_reg reg,\n\t\t\t\t      unsigned long val)\n{\n\tvcpu->arch.regs[reg] = val;\n\t__set_bit(reg, (unsigned long *)&vcpu->arch.regs_dirty);\n\t__set_bit(reg, (unsigned long *)&vcpu->arch.regs_avail);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void kvm_register_write(struct kvm_vcpu *vcpu,\n\t\t\t\t      enum kvm_reg reg,\n\t\t\t\t      unsigned long val)\n{\n\tvcpu->arch.regs[reg] = val;\n\t__set_bit(reg, (unsigned long *)&vcpu->arch.regs_dirty);\n\t__set_bit(reg, (unsigned long *)&vcpu->arch.regs_avail);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_kvm_msr_read",
          "args": [
            "ecx",
            "msr_info.data"
          ],
          "line": 3404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_inject_gp",
          "args": [
            "&svm->vcpu",
            "0"
          ],
          "line": 3402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_kvm_msr_read_ex",
          "args": [
            "ecx"
          ],
          "line": 3401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svm_get_msr",
          "args": [
            "&svm->vcpu",
            "&msr_info"
          ],
          "line": 3400
        },
        "resolved": true,
        "details": {
          "function_name": "svm_get_msr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "3299-3391",
          "snippet": "static int svm_get_msr(struct kvm_vcpu *vcpu, struct msr_data *msr_info)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tswitch (msr_info->index) {\n\tcase MSR_IA32_TSC: {\n\t\tmsr_info->data = svm->vmcb->control.tsc_offset +\n\t\t\tkvm_scale_tsc(vcpu, rdtsc());\n\n\t\tbreak;\n\t}\n\tcase MSR_STAR:\n\t\tmsr_info->data = svm->vmcb->save.star;\n\t\tbreak;\n#ifdef CONFIG_X86_64\n\tcase MSR_LSTAR:\n\t\tmsr_info->data = svm->vmcb->save.lstar;\n\t\tbreak;\n\tcase MSR_CSTAR:\n\t\tmsr_info->data = svm->vmcb->save.cstar;\n\t\tbreak;\n\tcase MSR_KERNEL_GS_BASE:\n\t\tmsr_info->data = svm->vmcb->save.kernel_gs_base;\n\t\tbreak;\n\tcase MSR_SYSCALL_MASK:\n\t\tmsr_info->data = svm->vmcb->save.sfmask;\n\t\tbreak;\n#endif\n\tcase MSR_IA32_SYSENTER_CS:\n\t\tmsr_info->data = svm->vmcb->save.sysenter_cs;\n\t\tbreak;\n\tcase MSR_IA32_SYSENTER_EIP:\n\t\tmsr_info->data = svm->sysenter_eip;\n\t\tbreak;\n\tcase MSR_IA32_SYSENTER_ESP:\n\t\tmsr_info->data = svm->sysenter_esp;\n\t\tbreak;\n\tcase MSR_TSC_AUX:\n\t\tif (!boot_cpu_has(X86_FEATURE_RDTSCP))\n\t\t\treturn 1;\n\t\tmsr_info->data = svm->tsc_aux;\n\t\tbreak;\n\t/*\n\t * Nobody will change the following 5 values in the VMCB so we can\n\t * safely return them on rdmsr. They will always be 0 until LBRV is\n\t * implemented.\n\t */\n\tcase MSR_IA32_DEBUGCTLMSR:\n\t\tmsr_info->data = svm->vmcb->save.dbgctl;\n\t\tbreak;\n\tcase MSR_IA32_LASTBRANCHFROMIP:\n\t\tmsr_info->data = svm->vmcb->save.br_from;\n\t\tbreak;\n\tcase MSR_IA32_LASTBRANCHTOIP:\n\t\tmsr_info->data = svm->vmcb->save.br_to;\n\t\tbreak;\n\tcase MSR_IA32_LASTINTFROMIP:\n\t\tmsr_info->data = svm->vmcb->save.last_excp_from;\n\t\tbreak;\n\tcase MSR_IA32_LASTINTTOIP:\n\t\tmsr_info->data = svm->vmcb->save.last_excp_to;\n\t\tbreak;\n\tcase MSR_VM_HSAVE_PA:\n\t\tmsr_info->data = svm->nested.hsave_msr;\n\t\tbreak;\n\tcase MSR_VM_CR:\n\t\tmsr_info->data = svm->nested.vm_cr_msr;\n\t\tbreak;\n\tcase MSR_IA32_UCODE_REV:\n\t\tmsr_info->data = 0x01000065;\n\t\tbreak;\n\tcase MSR_F15H_IC_CFG: {\n\n\t\tint family, model;\n\n\t\tfamily = guest_cpuid_family(vcpu);\n\t\tmodel  = guest_cpuid_model(vcpu);\n\n\t\tif (family < 0 || model < 0)\n\t\t\treturn kvm_get_msr_common(vcpu, msr_info);\n\n\t\tmsr_info->data = 0;\n\n\t\tif (family == 0x15 &&\n\t\t    (model >= 0x2 && model < 0x20))\n\t\t\tmsr_info->data = 0x1E;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn kvm_get_msr_common(vcpu, msr_info);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nested = true;",
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int nested = true;\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic int svm_get_msr(struct kvm_vcpu *vcpu, struct msr_data *msr_info)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tswitch (msr_info->index) {\n\tcase MSR_IA32_TSC: {\n\t\tmsr_info->data = svm->vmcb->control.tsc_offset +\n\t\t\tkvm_scale_tsc(vcpu, rdtsc());\n\n\t\tbreak;\n\t}\n\tcase MSR_STAR:\n\t\tmsr_info->data = svm->vmcb->save.star;\n\t\tbreak;\n#ifdef CONFIG_X86_64\n\tcase MSR_LSTAR:\n\t\tmsr_info->data = svm->vmcb->save.lstar;\n\t\tbreak;\n\tcase MSR_CSTAR:\n\t\tmsr_info->data = svm->vmcb->save.cstar;\n\t\tbreak;\n\tcase MSR_KERNEL_GS_BASE:\n\t\tmsr_info->data = svm->vmcb->save.kernel_gs_base;\n\t\tbreak;\n\tcase MSR_SYSCALL_MASK:\n\t\tmsr_info->data = svm->vmcb->save.sfmask;\n\t\tbreak;\n#endif\n\tcase MSR_IA32_SYSENTER_CS:\n\t\tmsr_info->data = svm->vmcb->save.sysenter_cs;\n\t\tbreak;\n\tcase MSR_IA32_SYSENTER_EIP:\n\t\tmsr_info->data = svm->sysenter_eip;\n\t\tbreak;\n\tcase MSR_IA32_SYSENTER_ESP:\n\t\tmsr_info->data = svm->sysenter_esp;\n\t\tbreak;\n\tcase MSR_TSC_AUX:\n\t\tif (!boot_cpu_has(X86_FEATURE_RDTSCP))\n\t\t\treturn 1;\n\t\tmsr_info->data = svm->tsc_aux;\n\t\tbreak;\n\t/*\n\t * Nobody will change the following 5 values in the VMCB so we can\n\t * safely return them on rdmsr. They will always be 0 until LBRV is\n\t * implemented.\n\t */\n\tcase MSR_IA32_DEBUGCTLMSR:\n\t\tmsr_info->data = svm->vmcb->save.dbgctl;\n\t\tbreak;\n\tcase MSR_IA32_LASTBRANCHFROMIP:\n\t\tmsr_info->data = svm->vmcb->save.br_from;\n\t\tbreak;\n\tcase MSR_IA32_LASTBRANCHTOIP:\n\t\tmsr_info->data = svm->vmcb->save.br_to;\n\t\tbreak;\n\tcase MSR_IA32_LASTINTFROMIP:\n\t\tmsr_info->data = svm->vmcb->save.last_excp_from;\n\t\tbreak;\n\tcase MSR_IA32_LASTINTTOIP:\n\t\tmsr_info->data = svm->vmcb->save.last_excp_to;\n\t\tbreak;\n\tcase MSR_VM_HSAVE_PA:\n\t\tmsr_info->data = svm->nested.hsave_msr;\n\t\tbreak;\n\tcase MSR_VM_CR:\n\t\tmsr_info->data = svm->nested.vm_cr_msr;\n\t\tbreak;\n\tcase MSR_IA32_UCODE_REV:\n\t\tmsr_info->data = 0x01000065;\n\t\tbreak;\n\tcase MSR_F15H_IC_CFG: {\n\n\t\tint family, model;\n\n\t\tfamily = guest_cpuid_family(vcpu);\n\t\tmodel  = guest_cpuid_model(vcpu);\n\n\t\tif (family < 0 || model < 0)\n\t\t\treturn kvm_get_msr_common(vcpu, msr_info);\n\n\t\tmsr_info->data = 0;\n\n\t\tif (family == 0x15 &&\n\t\t    (model >= 0x2 && model < 0x20))\n\t\t\tmsr_info->data = 0x1E;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn kvm_get_msr_common(vcpu, msr_info);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_register_read",
          "args": [
            "&svm->vcpu",
            "VCPU_REGS_RCX"
          ],
          "line": 3395
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_register_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "9-16",
          "snippet": "static inline unsigned long kvm_register_read(struct kvm_vcpu *vcpu,\n\t\t\t\t\t      enum kvm_reg reg)\n{\n\tif (!test_bit(reg, (unsigned long *)&vcpu->arch.regs_avail))\n\t\tkvm_x86_ops->cache_reg(vcpu, reg);\n\n\treturn vcpu->arch.regs[reg];\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline unsigned long kvm_register_read(struct kvm_vcpu *vcpu,\n\t\t\t\t\t      enum kvm_reg reg)\n{\n\tif (!test_bit(reg, (unsigned long *)&vcpu->arch.regs_avail))\n\t\tkvm_x86_ops->cache_reg(vcpu, reg);\n\n\treturn vcpu->arch.regs[reg];\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic int rdmsr_interception(struct vcpu_svm *svm)\n{\n\tu32 ecx = kvm_register_read(&svm->vcpu, VCPU_REGS_RCX);\n\tstruct msr_data msr_info;\n\n\tmsr_info.index = ecx;\n\tmsr_info.host_initiated = false;\n\tif (svm_get_msr(&svm->vcpu, &msr_info)) {\n\t\ttrace_kvm_msr_read_ex(ecx);\n\t\tkvm_inject_gp(&svm->vcpu, 0);\n\t} else {\n\t\ttrace_kvm_msr_read(ecx, msr_info.data);\n\n\t\tkvm_register_write(&svm->vcpu, VCPU_REGS_RAX,\n\t\t\t\t   msr_info.data & 0xffffffff);\n\t\tkvm_register_write(&svm->vcpu, VCPU_REGS_RDX,\n\t\t\t\t   msr_info.data >> 32);\n\t\tsvm->next_rip = kvm_rip_read(&svm->vcpu) + 2;\n\t\tskip_emulated_instruction(&svm->vcpu);\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "svm_get_msr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "3299-3391",
    "snippet": "static int svm_get_msr(struct kvm_vcpu *vcpu, struct msr_data *msr_info)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tswitch (msr_info->index) {\n\tcase MSR_IA32_TSC: {\n\t\tmsr_info->data = svm->vmcb->control.tsc_offset +\n\t\t\tkvm_scale_tsc(vcpu, rdtsc());\n\n\t\tbreak;\n\t}\n\tcase MSR_STAR:\n\t\tmsr_info->data = svm->vmcb->save.star;\n\t\tbreak;\n#ifdef CONFIG_X86_64\n\tcase MSR_LSTAR:\n\t\tmsr_info->data = svm->vmcb->save.lstar;\n\t\tbreak;\n\tcase MSR_CSTAR:\n\t\tmsr_info->data = svm->vmcb->save.cstar;\n\t\tbreak;\n\tcase MSR_KERNEL_GS_BASE:\n\t\tmsr_info->data = svm->vmcb->save.kernel_gs_base;\n\t\tbreak;\n\tcase MSR_SYSCALL_MASK:\n\t\tmsr_info->data = svm->vmcb->save.sfmask;\n\t\tbreak;\n#endif\n\tcase MSR_IA32_SYSENTER_CS:\n\t\tmsr_info->data = svm->vmcb->save.sysenter_cs;\n\t\tbreak;\n\tcase MSR_IA32_SYSENTER_EIP:\n\t\tmsr_info->data = svm->sysenter_eip;\n\t\tbreak;\n\tcase MSR_IA32_SYSENTER_ESP:\n\t\tmsr_info->data = svm->sysenter_esp;\n\t\tbreak;\n\tcase MSR_TSC_AUX:\n\t\tif (!boot_cpu_has(X86_FEATURE_RDTSCP))\n\t\t\treturn 1;\n\t\tmsr_info->data = svm->tsc_aux;\n\t\tbreak;\n\t/*\n\t * Nobody will change the following 5 values in the VMCB so we can\n\t * safely return them on rdmsr. They will always be 0 until LBRV is\n\t * implemented.\n\t */\n\tcase MSR_IA32_DEBUGCTLMSR:\n\t\tmsr_info->data = svm->vmcb->save.dbgctl;\n\t\tbreak;\n\tcase MSR_IA32_LASTBRANCHFROMIP:\n\t\tmsr_info->data = svm->vmcb->save.br_from;\n\t\tbreak;\n\tcase MSR_IA32_LASTBRANCHTOIP:\n\t\tmsr_info->data = svm->vmcb->save.br_to;\n\t\tbreak;\n\tcase MSR_IA32_LASTINTFROMIP:\n\t\tmsr_info->data = svm->vmcb->save.last_excp_from;\n\t\tbreak;\n\tcase MSR_IA32_LASTINTTOIP:\n\t\tmsr_info->data = svm->vmcb->save.last_excp_to;\n\t\tbreak;\n\tcase MSR_VM_HSAVE_PA:\n\t\tmsr_info->data = svm->nested.hsave_msr;\n\t\tbreak;\n\tcase MSR_VM_CR:\n\t\tmsr_info->data = svm->nested.vm_cr_msr;\n\t\tbreak;\n\tcase MSR_IA32_UCODE_REV:\n\t\tmsr_info->data = 0x01000065;\n\t\tbreak;\n\tcase MSR_F15H_IC_CFG: {\n\n\t\tint family, model;\n\n\t\tfamily = guest_cpuid_family(vcpu);\n\t\tmodel  = guest_cpuid_model(vcpu);\n\n\t\tif (family < 0 || model < 0)\n\t\t\treturn kvm_get_msr_common(vcpu, msr_info);\n\n\t\tmsr_info->data = 0;\n\n\t\tif (family == 0x15 &&\n\t\t    (model >= 0x2 && model < 0x20))\n\t\t\tmsr_info->data = 0x1E;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn kvm_get_msr_common(vcpu, msr_info);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int nested = true;",
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_get_msr_common",
          "args": [
            "vcpu",
            "msr_info"
          ],
          "line": 3388
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_get_msr_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "2298-2458",
          "snippet": "int kvm_get_msr_common(struct kvm_vcpu *vcpu, struct msr_data *msr_info)\n{\n\tswitch (msr_info->index) {\n\tcase MSR_IA32_PLATFORM_ID:\n\tcase MSR_IA32_EBL_CR_POWERON:\n\tcase MSR_IA32_DEBUGCTLMSR:\n\tcase MSR_IA32_LASTBRANCHFROMIP:\n\tcase MSR_IA32_LASTBRANCHTOIP:\n\tcase MSR_IA32_LASTINTFROMIP:\n\tcase MSR_IA32_LASTINTTOIP:\n\tcase MSR_K8_SYSCFG:\n\tcase MSR_K8_TSEG_ADDR:\n\tcase MSR_K8_TSEG_MASK:\n\tcase MSR_K7_HWCR:\n\tcase MSR_VM_HSAVE_PA:\n\tcase MSR_K8_INT_PENDING_MSG:\n\tcase MSR_AMD64_NB_CFG:\n\tcase MSR_FAM10H_MMIO_CONF_BASE:\n\tcase MSR_AMD64_BU_CFG2:\n\t\tmsr_info->data = 0;\n\t\tbreak;\n\tcase MSR_K7_EVNTSEL0 ... MSR_K7_EVNTSEL3:\n\tcase MSR_K7_PERFCTR0 ... MSR_K7_PERFCTR3:\n\tcase MSR_P6_PERFCTR0 ... MSR_P6_PERFCTR1:\n\tcase MSR_P6_EVNTSEL0 ... MSR_P6_EVNTSEL1:\n\t\tif (kvm_pmu_is_valid_msr(vcpu, msr_info->index))\n\t\t\treturn kvm_pmu_get_msr(vcpu, msr_info->index, &msr_info->data);\n\t\tmsr_info->data = 0;\n\t\tbreak;\n\tcase MSR_IA32_UCODE_REV:\n\t\tmsr_info->data = 0x100000000ULL;\n\t\tbreak;\n\tcase MSR_MTRRcap:\n\tcase 0x200 ... 0x2ff:\n\t\treturn kvm_mtrr_get_msr(vcpu, msr_info->index, &msr_info->data);\n\tcase 0xcd: /* fsb frequency */\n\t\tmsr_info->data = 3;\n\t\tbreak;\n\t\t/*\n\t\t * MSR_EBC_FREQUENCY_ID\n\t\t * Conservative value valid for even the basic CPU models.\n\t\t * Models 0,1: 000 in bits 23:21 indicating a bus speed of\n\t\t * 100MHz, model 2 000 in bits 18:16 indicating 100MHz,\n\t\t * and 266MHz for model 3, or 4. Set Core Clock\n\t\t * Frequency to System Bus Frequency Ratio to 1 (bits\n\t\t * 31:24) even though these are only valid for CPU\n\t\t * models > 2, however guests may end up dividing or\n\t\t * multiplying by zero otherwise.\n\t\t */\n\tcase MSR_EBC_FREQUENCY_ID:\n\t\tmsr_info->data = 1 << 24;\n\t\tbreak;\n\tcase MSR_IA32_APICBASE:\n\t\tmsr_info->data = kvm_get_apic_base(vcpu);\n\t\tbreak;\n\tcase APIC_BASE_MSR ... APIC_BASE_MSR + 0x3ff:\n\t\treturn kvm_x2apic_msr_read(vcpu, msr_info->index, &msr_info->data);\n\t\tbreak;\n\tcase MSR_IA32_TSCDEADLINE:\n\t\tmsr_info->data = kvm_get_lapic_tscdeadline_msr(vcpu);\n\t\tbreak;\n\tcase MSR_IA32_TSC_ADJUST:\n\t\tmsr_info->data = (u64)vcpu->arch.ia32_tsc_adjust_msr;\n\t\tbreak;\n\tcase MSR_IA32_MISC_ENABLE:\n\t\tmsr_info->data = vcpu->arch.ia32_misc_enable_msr;\n\t\tbreak;\n\tcase MSR_IA32_SMBASE:\n\t\tif (!msr_info->host_initiated)\n\t\t\treturn 1;\n\t\tmsr_info->data = vcpu->arch.smbase;\n\t\tbreak;\n\tcase MSR_IA32_PERF_STATUS:\n\t\t/* TSC increment by tick */\n\t\tmsr_info->data = 1000ULL;\n\t\t/* CPU multiplier */\n\t\tmsr_info->data |= (((uint64_t)4ULL) << 40);\n\t\tbreak;\n\tcase MSR_EFER:\n\t\tmsr_info->data = vcpu->arch.efer;\n\t\tbreak;\n\tcase MSR_KVM_WALL_CLOCK:\n\tcase MSR_KVM_WALL_CLOCK_NEW:\n\t\tmsr_info->data = vcpu->kvm->arch.wall_clock;\n\t\tbreak;\n\tcase MSR_KVM_SYSTEM_TIME:\n\tcase MSR_KVM_SYSTEM_TIME_NEW:\n\t\tmsr_info->data = vcpu->arch.time;\n\t\tbreak;\n\tcase MSR_KVM_ASYNC_PF_EN:\n\t\tmsr_info->data = vcpu->arch.apf.msr_val;\n\t\tbreak;\n\tcase MSR_KVM_STEAL_TIME:\n\t\tmsr_info->data = vcpu->arch.st.msr_val;\n\t\tbreak;\n\tcase MSR_KVM_PV_EOI_EN:\n\t\tmsr_info->data = vcpu->arch.pv_eoi.msr_val;\n\t\tbreak;\n\tcase MSR_IA32_P5_MC_ADDR:\n\tcase MSR_IA32_P5_MC_TYPE:\n\tcase MSR_IA32_MCG_CAP:\n\tcase MSR_IA32_MCG_CTL:\n\tcase MSR_IA32_MCG_STATUS:\n\tcase MSR_IA32_MC0_CTL ... MSR_IA32_MCx_CTL(KVM_MAX_MCE_BANKS) - 1:\n\t\treturn get_msr_mce(vcpu, msr_info->index, &msr_info->data);\n\tcase MSR_K7_CLK_CTL:\n\t\t/*\n\t\t * Provide expected ramp-up count for K7. All other\n\t\t * are set to zero, indicating minimum divisors for\n\t\t * every field.\n\t\t *\n\t\t * This prevents guest kernels on AMD host with CPU\n\t\t * type 6, model 8 and higher from exploding due to\n\t\t * the rdmsr failing.\n\t\t */\n\t\tmsr_info->data = 0x20000000;\n\t\tbreak;\n\tcase HV_X64_MSR_GUEST_OS_ID ... HV_X64_MSR_SINT15:\n\tcase HV_X64_MSR_CRASH_P0 ... HV_X64_MSR_CRASH_P4:\n\tcase HV_X64_MSR_CRASH_CTL:\n\tcase HV_X64_MSR_STIMER0_CONFIG ... HV_X64_MSR_STIMER3_COUNT:\n\t\treturn kvm_hv_get_msr_common(vcpu,\n\t\t\t\t\t     msr_info->index, &msr_info->data);\n\t\tbreak;\n\tcase MSR_IA32_BBL_CR_CTL3:\n\t\t/* This legacy MSR exists but isn't fully documented in current\n\t\t * silicon.  It is however accessed by winxp in very narrow\n\t\t * scenarios where it sets bit #19, itself documented as\n\t\t * a \"reserved\" bit.  Best effort attempt to source coherent\n\t\t * read data here should the balance of the register be\n\t\t * interpreted by the guest:\n\t\t *\n\t\t * L2 cache control register 3: 64GB range, 256KB size,\n\t\t * enabled, latency 0x1, configured\n\t\t */\n\t\tmsr_info->data = 0xbe702111;\n\t\tbreak;\n\tcase MSR_AMD64_OSVW_ID_LENGTH:\n\t\tif (!guest_cpuid_has_osvw(vcpu))\n\t\t\treturn 1;\n\t\tmsr_info->data = vcpu->arch.osvw.length;\n\t\tbreak;\n\tcase MSR_AMD64_OSVW_STATUS:\n\t\tif (!guest_cpuid_has_osvw(vcpu))\n\t\t\treturn 1;\n\t\tmsr_info->data = vcpu->arch.osvw.status;\n\t\tbreak;\n\tdefault:\n\t\tif (kvm_pmu_is_valid_msr(vcpu, msr_info->index))\n\t\t\treturn kvm_pmu_get_msr(vcpu, msr_info->index, &msr_info->data);\n\t\tif (!ignore_msrs) {\n\t\t\tvcpu_unimpl(vcpu, \"unhandled rdmsr: 0x%x\\n\", msr_info->index);\n\t\t\treturn 1;\n\t\t} else {\n\t\t\tvcpu_unimpl(vcpu, \"ignored rdmsr: 0x%x\\n\", msr_info->index);\n\t\t\tmsr_info->data = 0;\n\t\t}\n\t\tbreak;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define KVM_MAX_MCE_BANKS 32"
          ],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define KVM_MAX_MCE_BANKS 32\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nint kvm_get_msr_common(struct kvm_vcpu *vcpu, struct msr_data *msr_info)\n{\n\tswitch (msr_info->index) {\n\tcase MSR_IA32_PLATFORM_ID:\n\tcase MSR_IA32_EBL_CR_POWERON:\n\tcase MSR_IA32_DEBUGCTLMSR:\n\tcase MSR_IA32_LASTBRANCHFROMIP:\n\tcase MSR_IA32_LASTBRANCHTOIP:\n\tcase MSR_IA32_LASTINTFROMIP:\n\tcase MSR_IA32_LASTINTTOIP:\n\tcase MSR_K8_SYSCFG:\n\tcase MSR_K8_TSEG_ADDR:\n\tcase MSR_K8_TSEG_MASK:\n\tcase MSR_K7_HWCR:\n\tcase MSR_VM_HSAVE_PA:\n\tcase MSR_K8_INT_PENDING_MSG:\n\tcase MSR_AMD64_NB_CFG:\n\tcase MSR_FAM10H_MMIO_CONF_BASE:\n\tcase MSR_AMD64_BU_CFG2:\n\t\tmsr_info->data = 0;\n\t\tbreak;\n\tcase MSR_K7_EVNTSEL0 ... MSR_K7_EVNTSEL3:\n\tcase MSR_K7_PERFCTR0 ... MSR_K7_PERFCTR3:\n\tcase MSR_P6_PERFCTR0 ... MSR_P6_PERFCTR1:\n\tcase MSR_P6_EVNTSEL0 ... MSR_P6_EVNTSEL1:\n\t\tif (kvm_pmu_is_valid_msr(vcpu, msr_info->index))\n\t\t\treturn kvm_pmu_get_msr(vcpu, msr_info->index, &msr_info->data);\n\t\tmsr_info->data = 0;\n\t\tbreak;\n\tcase MSR_IA32_UCODE_REV:\n\t\tmsr_info->data = 0x100000000ULL;\n\t\tbreak;\n\tcase MSR_MTRRcap:\n\tcase 0x200 ... 0x2ff:\n\t\treturn kvm_mtrr_get_msr(vcpu, msr_info->index, &msr_info->data);\n\tcase 0xcd: /* fsb frequency */\n\t\tmsr_info->data = 3;\n\t\tbreak;\n\t\t/*\n\t\t * MSR_EBC_FREQUENCY_ID\n\t\t * Conservative value valid for even the basic CPU models.\n\t\t * Models 0,1: 000 in bits 23:21 indicating a bus speed of\n\t\t * 100MHz, model 2 000 in bits 18:16 indicating 100MHz,\n\t\t * and 266MHz for model 3, or 4. Set Core Clock\n\t\t * Frequency to System Bus Frequency Ratio to 1 (bits\n\t\t * 31:24) even though these are only valid for CPU\n\t\t * models > 2, however guests may end up dividing or\n\t\t * multiplying by zero otherwise.\n\t\t */\n\tcase MSR_EBC_FREQUENCY_ID:\n\t\tmsr_info->data = 1 << 24;\n\t\tbreak;\n\tcase MSR_IA32_APICBASE:\n\t\tmsr_info->data = kvm_get_apic_base(vcpu);\n\t\tbreak;\n\tcase APIC_BASE_MSR ... APIC_BASE_MSR + 0x3ff:\n\t\treturn kvm_x2apic_msr_read(vcpu, msr_info->index, &msr_info->data);\n\t\tbreak;\n\tcase MSR_IA32_TSCDEADLINE:\n\t\tmsr_info->data = kvm_get_lapic_tscdeadline_msr(vcpu);\n\t\tbreak;\n\tcase MSR_IA32_TSC_ADJUST:\n\t\tmsr_info->data = (u64)vcpu->arch.ia32_tsc_adjust_msr;\n\t\tbreak;\n\tcase MSR_IA32_MISC_ENABLE:\n\t\tmsr_info->data = vcpu->arch.ia32_misc_enable_msr;\n\t\tbreak;\n\tcase MSR_IA32_SMBASE:\n\t\tif (!msr_info->host_initiated)\n\t\t\treturn 1;\n\t\tmsr_info->data = vcpu->arch.smbase;\n\t\tbreak;\n\tcase MSR_IA32_PERF_STATUS:\n\t\t/* TSC increment by tick */\n\t\tmsr_info->data = 1000ULL;\n\t\t/* CPU multiplier */\n\t\tmsr_info->data |= (((uint64_t)4ULL) << 40);\n\t\tbreak;\n\tcase MSR_EFER:\n\t\tmsr_info->data = vcpu->arch.efer;\n\t\tbreak;\n\tcase MSR_KVM_WALL_CLOCK:\n\tcase MSR_KVM_WALL_CLOCK_NEW:\n\t\tmsr_info->data = vcpu->kvm->arch.wall_clock;\n\t\tbreak;\n\tcase MSR_KVM_SYSTEM_TIME:\n\tcase MSR_KVM_SYSTEM_TIME_NEW:\n\t\tmsr_info->data = vcpu->arch.time;\n\t\tbreak;\n\tcase MSR_KVM_ASYNC_PF_EN:\n\t\tmsr_info->data = vcpu->arch.apf.msr_val;\n\t\tbreak;\n\tcase MSR_KVM_STEAL_TIME:\n\t\tmsr_info->data = vcpu->arch.st.msr_val;\n\t\tbreak;\n\tcase MSR_KVM_PV_EOI_EN:\n\t\tmsr_info->data = vcpu->arch.pv_eoi.msr_val;\n\t\tbreak;\n\tcase MSR_IA32_P5_MC_ADDR:\n\tcase MSR_IA32_P5_MC_TYPE:\n\tcase MSR_IA32_MCG_CAP:\n\tcase MSR_IA32_MCG_CTL:\n\tcase MSR_IA32_MCG_STATUS:\n\tcase MSR_IA32_MC0_CTL ... MSR_IA32_MCx_CTL(KVM_MAX_MCE_BANKS) - 1:\n\t\treturn get_msr_mce(vcpu, msr_info->index, &msr_info->data);\n\tcase MSR_K7_CLK_CTL:\n\t\t/*\n\t\t * Provide expected ramp-up count for K7. All other\n\t\t * are set to zero, indicating minimum divisors for\n\t\t * every field.\n\t\t *\n\t\t * This prevents guest kernels on AMD host with CPU\n\t\t * type 6, model 8 and higher from exploding due to\n\t\t * the rdmsr failing.\n\t\t */\n\t\tmsr_info->data = 0x20000000;\n\t\tbreak;\n\tcase HV_X64_MSR_GUEST_OS_ID ... HV_X64_MSR_SINT15:\n\tcase HV_X64_MSR_CRASH_P0 ... HV_X64_MSR_CRASH_P4:\n\tcase HV_X64_MSR_CRASH_CTL:\n\tcase HV_X64_MSR_STIMER0_CONFIG ... HV_X64_MSR_STIMER3_COUNT:\n\t\treturn kvm_hv_get_msr_common(vcpu,\n\t\t\t\t\t     msr_info->index, &msr_info->data);\n\t\tbreak;\n\tcase MSR_IA32_BBL_CR_CTL3:\n\t\t/* This legacy MSR exists but isn't fully documented in current\n\t\t * silicon.  It is however accessed by winxp in very narrow\n\t\t * scenarios where it sets bit #19, itself documented as\n\t\t * a \"reserved\" bit.  Best effort attempt to source coherent\n\t\t * read data here should the balance of the register be\n\t\t * interpreted by the guest:\n\t\t *\n\t\t * L2 cache control register 3: 64GB range, 256KB size,\n\t\t * enabled, latency 0x1, configured\n\t\t */\n\t\tmsr_info->data = 0xbe702111;\n\t\tbreak;\n\tcase MSR_AMD64_OSVW_ID_LENGTH:\n\t\tif (!guest_cpuid_has_osvw(vcpu))\n\t\t\treturn 1;\n\t\tmsr_info->data = vcpu->arch.osvw.length;\n\t\tbreak;\n\tcase MSR_AMD64_OSVW_STATUS:\n\t\tif (!guest_cpuid_has_osvw(vcpu))\n\t\t\treturn 1;\n\t\tmsr_info->data = vcpu->arch.osvw.status;\n\t\tbreak;\n\tdefault:\n\t\tif (kvm_pmu_is_valid_msr(vcpu, msr_info->index))\n\t\t\treturn kvm_pmu_get_msr(vcpu, msr_info->index, &msr_info->data);\n\t\tif (!ignore_msrs) {\n\t\t\tvcpu_unimpl(vcpu, \"unhandled rdmsr: 0x%x\\n\", msr_info->index);\n\t\t\treturn 1;\n\t\t} else {\n\t\t\tvcpu_unimpl(vcpu, \"ignored rdmsr: 0x%x\\n\", msr_info->index);\n\t\t\tmsr_info->data = 0;\n\t\t}\n\t\tbreak;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "guest_cpuid_model",
          "args": [
            "vcpu"
          ],
          "line": 3375
        },
        "resolved": true,
        "details": {
          "function_name": "guest_cpuid_model",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/cpuid.h",
          "lines": "194-203",
          "snippet": "static inline int guest_cpuid_model(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_cpuid_entry2 *best;\n\n\tbest = kvm_find_cpuid_entry(vcpu, 0x1, 0);\n\tif (!best)\n\t\treturn -1;\n\n\treturn x86_model(best->eax);\n}",
          "includes": [
            "#include <asm/cpu.h>",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpu.h>\n#include \"x86.h\"\n\nstatic inline int guest_cpuid_model(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_cpuid_entry2 *best;\n\n\tbest = kvm_find_cpuid_entry(vcpu, 0x1, 0);\n\tif (!best)\n\t\treturn -1;\n\n\treturn x86_model(best->eax);\n}"
        }
      },
      {
        "call_info": {
          "callee": "guest_cpuid_family",
          "args": [
            "vcpu"
          ],
          "line": 3374
        },
        "resolved": true,
        "details": {
          "function_name": "guest_cpuid_family",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/cpuid.h",
          "lines": "183-192",
          "snippet": "static inline int guest_cpuid_family(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_cpuid_entry2 *best;\n\n\tbest = kvm_find_cpuid_entry(vcpu, 0x1, 0);\n\tif (!best)\n\t\treturn -1;\n\n\treturn x86_family(best->eax);\n}",
          "includes": [
            "#include <asm/cpu.h>",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpu.h>\n#include \"x86.h\"\n\nstatic inline int guest_cpuid_family(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_cpuid_entry2 *best;\n\n\tbest = kvm_find_cpuid_entry(vcpu, 0x1, 0);\n\tif (!best)\n\t\treturn -1;\n\n\treturn x86_family(best->eax);\n}"
        }
      },
      {
        "call_info": {
          "callee": "boot_cpu_has",
          "args": [
            "X86_FEATURE_RDTSCP"
          ],
          "line": 3337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_scale_tsc",
          "args": [
            "vcpu",
            "rdtsc()"
          ],
          "line": 3306
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_scale_tsc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "1387-1396",
          "snippet": "u64 kvm_scale_tsc(struct kvm_vcpu *vcpu, u64 tsc)\n{\n\tu64 _tsc = tsc;\n\tu64 ratio = vcpu->arch.tsc_scaling_ratio;\n\n\tif (ratio != kvm_default_tsc_scaling_ratio)\n\t\t_tsc = __scale_tsc(ratio, tsc);\n\n\treturn _tsc;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nu64 kvm_scale_tsc(struct kvm_vcpu *vcpu, u64 tsc)\n{\n\tu64 _tsc = tsc;\n\tu64 ratio = vcpu->arch.tsc_scaling_ratio;\n\n\tif (ratio != kvm_default_tsc_scaling_ratio)\n\t\t_tsc = __scale_tsc(ratio, tsc);\n\n\treturn _tsc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rdtsc",
          "args": [],
          "line": 3306
        },
        "resolved": true,
        "details": {
          "function_name": "svm_rdtscp_supported",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "4719-4722",
          "snippet": "static bool svm_rdtscp_supported(void)\n{\n\treturn boot_cpu_has(X86_FEATURE_RDTSCP);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic bool svm_rdtscp_supported(void)\n{\n\treturn boot_cpu_has(X86_FEATURE_RDTSCP);\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 3301
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "294-297",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int nested = true;\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic int svm_get_msr(struct kvm_vcpu *vcpu, struct msr_data *msr_info)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tswitch (msr_info->index) {\n\tcase MSR_IA32_TSC: {\n\t\tmsr_info->data = svm->vmcb->control.tsc_offset +\n\t\t\tkvm_scale_tsc(vcpu, rdtsc());\n\n\t\tbreak;\n\t}\n\tcase MSR_STAR:\n\t\tmsr_info->data = svm->vmcb->save.star;\n\t\tbreak;\n#ifdef CONFIG_X86_64\n\tcase MSR_LSTAR:\n\t\tmsr_info->data = svm->vmcb->save.lstar;\n\t\tbreak;\n\tcase MSR_CSTAR:\n\t\tmsr_info->data = svm->vmcb->save.cstar;\n\t\tbreak;\n\tcase MSR_KERNEL_GS_BASE:\n\t\tmsr_info->data = svm->vmcb->save.kernel_gs_base;\n\t\tbreak;\n\tcase MSR_SYSCALL_MASK:\n\t\tmsr_info->data = svm->vmcb->save.sfmask;\n\t\tbreak;\n#endif\n\tcase MSR_IA32_SYSENTER_CS:\n\t\tmsr_info->data = svm->vmcb->save.sysenter_cs;\n\t\tbreak;\n\tcase MSR_IA32_SYSENTER_EIP:\n\t\tmsr_info->data = svm->sysenter_eip;\n\t\tbreak;\n\tcase MSR_IA32_SYSENTER_ESP:\n\t\tmsr_info->data = svm->sysenter_esp;\n\t\tbreak;\n\tcase MSR_TSC_AUX:\n\t\tif (!boot_cpu_has(X86_FEATURE_RDTSCP))\n\t\t\treturn 1;\n\t\tmsr_info->data = svm->tsc_aux;\n\t\tbreak;\n\t/*\n\t * Nobody will change the following 5 values in the VMCB so we can\n\t * safely return them on rdmsr. They will always be 0 until LBRV is\n\t * implemented.\n\t */\n\tcase MSR_IA32_DEBUGCTLMSR:\n\t\tmsr_info->data = svm->vmcb->save.dbgctl;\n\t\tbreak;\n\tcase MSR_IA32_LASTBRANCHFROMIP:\n\t\tmsr_info->data = svm->vmcb->save.br_from;\n\t\tbreak;\n\tcase MSR_IA32_LASTBRANCHTOIP:\n\t\tmsr_info->data = svm->vmcb->save.br_to;\n\t\tbreak;\n\tcase MSR_IA32_LASTINTFROMIP:\n\t\tmsr_info->data = svm->vmcb->save.last_excp_from;\n\t\tbreak;\n\tcase MSR_IA32_LASTINTTOIP:\n\t\tmsr_info->data = svm->vmcb->save.last_excp_to;\n\t\tbreak;\n\tcase MSR_VM_HSAVE_PA:\n\t\tmsr_info->data = svm->nested.hsave_msr;\n\t\tbreak;\n\tcase MSR_VM_CR:\n\t\tmsr_info->data = svm->nested.vm_cr_msr;\n\t\tbreak;\n\tcase MSR_IA32_UCODE_REV:\n\t\tmsr_info->data = 0x01000065;\n\t\tbreak;\n\tcase MSR_F15H_IC_CFG: {\n\n\t\tint family, model;\n\n\t\tfamily = guest_cpuid_family(vcpu);\n\t\tmodel  = guest_cpuid_model(vcpu);\n\n\t\tif (family < 0 || model < 0)\n\t\t\treturn kvm_get_msr_common(vcpu, msr_info);\n\n\t\tmsr_info->data = 0;\n\n\t\tif (family == 0x15 &&\n\t\t    (model >= 0x2 && model < 0x20))\n\t\t\tmsr_info->data = 0x1E;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn kvm_get_msr_common(vcpu, msr_info);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "svm_read_l1_tsc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "3293-3297",
    "snippet": "static u64 svm_read_l1_tsc(struct kvm_vcpu *vcpu, u64 host_tsc)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(to_svm(vcpu));\n\treturn vmcb->control.tsc_offset + host_tsc;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_host_vmcb",
          "args": [
            "to_svm(vcpu)"
          ],
          "line": 3295
        },
        "resolved": true,
        "details": {
          "function_name": "get_host_vmcb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "336-342",
          "snippet": "static inline struct vmcb *get_host_vmcb(struct vcpu_svm *svm)\n{\n\tif (is_guest_mode(&svm->vcpu))\n\t\treturn svm->nested.hsave;\n\telse\n\t\treturn svm->vmcb;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nested = true;",
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int nested = true;\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic inline struct vmcb *get_host_vmcb(struct vcpu_svm *svm)\n{\n\tif (is_guest_mode(&svm->vcpu))\n\t\treturn svm->nested.hsave;\n\telse\n\t\treturn svm->vmcb;\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 3295
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "294-297",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\n\nstatic u64 svm_read_l1_tsc(struct kvm_vcpu *vcpu, u64 host_tsc)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(to_svm(vcpu));\n\treturn vmcb->control.tsc_offset + host_tsc;\n}"
  },
  {
    "function_name": "cr8_write_interception",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "3277-3291",
    "snippet": "static int cr8_write_interception(struct vcpu_svm *svm)\n{\n\tstruct kvm_run *kvm_run = svm->vcpu.run;\n\tint r;\n\n\tu8 cr8_prev = kvm_get_cr8(&svm->vcpu);\n\t/* instruction emulation calls kvm_set_cr8() */\n\tr = cr_interception(svm);\n\tif (lapic_in_kernel(&svm->vcpu))\n\t\treturn r;\n\tif (cr8_prev <= kvm_get_cr8(&svm->vcpu))\n\t\treturn r;\n\tkvm_run->exit_reason = KVM_EXIT_SET_TPR;\n\treturn 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_get_cr8",
          "args": [
            "&svm->vcpu"
          ],
          "line": 3287
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_get_cr8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "816-822",
          "snippet": "unsigned long kvm_get_cr8(struct kvm_vcpu *vcpu)\n{\n\tif (lapic_in_kernel(vcpu))\n\t\treturn kvm_lapic_get_cr8(vcpu);\n\telse\n\t\treturn vcpu->arch.cr8;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nunsigned long kvm_get_cr8(struct kvm_vcpu *vcpu)\n{\n\tif (lapic_in_kernel(vcpu))\n\t\treturn kvm_lapic_get_cr8(vcpu);\n\telse\n\t\treturn vcpu->arch.cr8;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lapic_in_kernel",
          "args": [
            "&svm->vcpu"
          ],
          "line": 3285
        },
        "resolved": true,
        "details": {
          "function_name": "lapic_in_kernel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.h",
          "lines": "141-146",
          "snippet": "static inline bool lapic_in_kernel(struct kvm_vcpu *vcpu)\n{\n\tif (static_key_false(&kvm_no_apic_vcpu))\n\t\treturn vcpu->arch.apic;\n\treturn true;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline bool lapic_in_kernel(struct kvm_vcpu *vcpu)\n{\n\tif (static_key_false(&kvm_no_apic_vcpu))\n\t\treturn vcpu->arch.apic;\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cr_interception",
          "args": [
            "svm"
          ],
          "line": 3284
        },
        "resolved": true,
        "details": {
          "function_name": "cr_interception",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "3165-3236",
          "snippet": "static int cr_interception(struct vcpu_svm *svm)\n{\n\tint reg, cr;\n\tunsigned long val;\n\tint err;\n\n\tif (!static_cpu_has(X86_FEATURE_DECODEASSISTS))\n\t\treturn emulate_on_interception(svm);\n\n\tif (unlikely((svm->vmcb->control.exit_info_1 & CR_VALID) == 0))\n\t\treturn emulate_on_interception(svm);\n\n\treg = svm->vmcb->control.exit_info_1 & SVM_EXITINFO_REG_MASK;\n\tif (svm->vmcb->control.exit_code == SVM_EXIT_CR0_SEL_WRITE)\n\t\tcr = SVM_EXIT_WRITE_CR0 - SVM_EXIT_READ_CR0;\n\telse\n\t\tcr = svm->vmcb->control.exit_code - SVM_EXIT_READ_CR0;\n\n\terr = 0;\n\tif (cr >= 16) { /* mov to cr */\n\t\tcr -= 16;\n\t\tval = kvm_register_read(&svm->vcpu, reg);\n\t\tswitch (cr) {\n\t\tcase 0:\n\t\t\tif (!check_selective_cr0_intercepted(svm, val))\n\t\t\t\terr = kvm_set_cr0(&svm->vcpu, val);\n\t\t\telse\n\t\t\t\treturn 1;\n\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\terr = kvm_set_cr3(&svm->vcpu, val);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\terr = kvm_set_cr4(&svm->vcpu, val);\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\terr = kvm_set_cr8(&svm->vcpu, val);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tWARN(1, \"unhandled write to CR%d\", cr);\n\t\t\tkvm_queue_exception(&svm->vcpu, UD_VECTOR);\n\t\t\treturn 1;\n\t\t}\n\t} else { /* mov from cr */\n\t\tswitch (cr) {\n\t\tcase 0:\n\t\t\tval = kvm_read_cr0(&svm->vcpu);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tval = svm->vcpu.arch.cr2;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tval = kvm_read_cr3(&svm->vcpu);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tval = kvm_read_cr4(&svm->vcpu);\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tval = kvm_get_cr8(&svm->vcpu);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tWARN(1, \"unhandled read from CR%d\", cr);\n\t\t\tkvm_queue_exception(&svm->vcpu, UD_VECTOR);\n\t\t\treturn 1;\n\t\t}\n\t\tkvm_register_write(&svm->vcpu, reg, val);\n\t}\n\tkvm_complete_insn_gp(&svm->vcpu, err);\n\n\treturn 1;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define CR_VALID (1ULL << 63)"
          ],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define CR_VALID (1ULL << 63)\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic int cr_interception(struct vcpu_svm *svm)\n{\n\tint reg, cr;\n\tunsigned long val;\n\tint err;\n\n\tif (!static_cpu_has(X86_FEATURE_DECODEASSISTS))\n\t\treturn emulate_on_interception(svm);\n\n\tif (unlikely((svm->vmcb->control.exit_info_1 & CR_VALID) == 0))\n\t\treturn emulate_on_interception(svm);\n\n\treg = svm->vmcb->control.exit_info_1 & SVM_EXITINFO_REG_MASK;\n\tif (svm->vmcb->control.exit_code == SVM_EXIT_CR0_SEL_WRITE)\n\t\tcr = SVM_EXIT_WRITE_CR0 - SVM_EXIT_READ_CR0;\n\telse\n\t\tcr = svm->vmcb->control.exit_code - SVM_EXIT_READ_CR0;\n\n\terr = 0;\n\tif (cr >= 16) { /* mov to cr */\n\t\tcr -= 16;\n\t\tval = kvm_register_read(&svm->vcpu, reg);\n\t\tswitch (cr) {\n\t\tcase 0:\n\t\t\tif (!check_selective_cr0_intercepted(svm, val))\n\t\t\t\terr = kvm_set_cr0(&svm->vcpu, val);\n\t\t\telse\n\t\t\t\treturn 1;\n\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\terr = kvm_set_cr3(&svm->vcpu, val);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\terr = kvm_set_cr4(&svm->vcpu, val);\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\terr = kvm_set_cr8(&svm->vcpu, val);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tWARN(1, \"unhandled write to CR%d\", cr);\n\t\t\tkvm_queue_exception(&svm->vcpu, UD_VECTOR);\n\t\t\treturn 1;\n\t\t}\n\t} else { /* mov from cr */\n\t\tswitch (cr) {\n\t\tcase 0:\n\t\t\tval = kvm_read_cr0(&svm->vcpu);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tval = svm->vcpu.arch.cr2;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tval = kvm_read_cr3(&svm->vcpu);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tval = kvm_read_cr4(&svm->vcpu);\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tval = kvm_get_cr8(&svm->vcpu);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tWARN(1, \"unhandled read from CR%d\", cr);\n\t\t\tkvm_queue_exception(&svm->vcpu, UD_VECTOR);\n\t\t\treturn 1;\n\t\t}\n\t\tkvm_register_write(&svm->vcpu, reg, val);\n\t}\n\tkvm_complete_insn_gp(&svm->vcpu, err);\n\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic int cr8_write_interception(struct vcpu_svm *svm)\n{\n\tstruct kvm_run *kvm_run = svm->vcpu.run;\n\tint r;\n\n\tu8 cr8_prev = kvm_get_cr8(&svm->vcpu);\n\t/* instruction emulation calls kvm_set_cr8() */\n\tr = cr_interception(svm);\n\tif (lapic_in_kernel(&svm->vcpu))\n\t\treturn r;\n\tif (cr8_prev <= kvm_get_cr8(&svm->vcpu))\n\t\treturn r;\n\tkvm_run->exit_reason = KVM_EXIT_SET_TPR;\n\treturn 0;\n}"
  },
  {
    "function_name": "dr_interception",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "3238-3275",
    "snippet": "static int dr_interception(struct vcpu_svm *svm)\n{\n\tint reg, dr;\n\tunsigned long val;\n\n\tif (svm->vcpu.guest_debug == 0) {\n\t\t/*\n\t\t * No more DR vmexits; force a reload of the debug registers\n\t\t * and reenter on this instruction.  The next vmexit will\n\t\t * retrieve the full state of the debug registers.\n\t\t */\n\t\tclr_dr_intercepts(svm);\n\t\tsvm->vcpu.arch.switch_db_regs |= KVM_DEBUGREG_WONT_EXIT;\n\t\treturn 1;\n\t}\n\n\tif (!boot_cpu_has(X86_FEATURE_DECODEASSISTS))\n\t\treturn emulate_on_interception(svm);\n\n\treg = svm->vmcb->control.exit_info_1 & SVM_EXITINFO_REG_MASK;\n\tdr = svm->vmcb->control.exit_code - SVM_EXIT_READ_DR0;\n\n\tif (dr >= 16) { /* mov to DRn */\n\t\tif (!kvm_require_dr(&svm->vcpu, dr - 16))\n\t\t\treturn 1;\n\t\tval = kvm_register_read(&svm->vcpu, reg);\n\t\tkvm_set_dr(&svm->vcpu, dr - 16, val);\n\t} else {\n\t\tif (!kvm_require_dr(&svm->vcpu, dr))\n\t\t\treturn 1;\n\t\tkvm_get_dr(&svm->vcpu, dr, &val);\n\t\tkvm_register_write(&svm->vcpu, reg, val);\n\t}\n\n\tskip_emulated_instruction(&svm->vcpu);\n\n\treturn 1;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "skip_emulated_instruction",
          "args": [
            "&svm->vcpu"
          ],
          "line": 3272
        },
        "resolved": true,
        "details": {
          "function_name": "skip_emulated_instruction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "572-593",
          "snippet": "static void skip_emulated_instruction(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (svm->vmcb->control.next_rip != 0) {\n\t\tWARN_ON_ONCE(!static_cpu_has(X86_FEATURE_NRIPS));\n\t\tsvm->next_rip = svm->vmcb->control.next_rip;\n\t}\n\n\tif (!svm->next_rip) {\n\t\tif (emulate_instruction(vcpu, EMULTYPE_SKIP) !=\n\t\t\t\tEMULATE_DONE)\n\t\t\tprintk(KERN_DEBUG \"%s: NOP\\n\", __func__);\n\t\treturn;\n\t}\n\tif (svm->next_rip - kvm_rip_read(vcpu) > MAX_INST_SIZE)\n\t\tprintk(KERN_ERR \"%s: ip 0x%lx next 0x%llx\\n\",\n\t\t       __func__, kvm_rip_read(vcpu), svm->next_rip);\n\n\tkvm_rip_write(vcpu, svm->next_rip);\n\tsvm_set_interrupt_shadow(vcpu, 0);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define MAX_INST_SIZE 15"
          ],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define MAX_INST_SIZE 15\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic void skip_emulated_instruction(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (svm->vmcb->control.next_rip != 0) {\n\t\tWARN_ON_ONCE(!static_cpu_has(X86_FEATURE_NRIPS));\n\t\tsvm->next_rip = svm->vmcb->control.next_rip;\n\t}\n\n\tif (!svm->next_rip) {\n\t\tif (emulate_instruction(vcpu, EMULTYPE_SKIP) !=\n\t\t\t\tEMULATE_DONE)\n\t\t\tprintk(KERN_DEBUG \"%s: NOP\\n\", __func__);\n\t\treturn;\n\t}\n\tif (svm->next_rip - kvm_rip_read(vcpu) > MAX_INST_SIZE)\n\t\tprintk(KERN_ERR \"%s: ip 0x%lx next 0x%llx\\n\",\n\t\t       __func__, kvm_rip_read(vcpu), svm->next_rip);\n\n\tkvm_rip_write(vcpu, svm->next_rip);\n\tsvm_set_interrupt_shadow(vcpu, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_register_write",
          "args": [
            "&svm->vcpu",
            "reg",
            "val"
          ],
          "line": 3269
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_register_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "18-25",
          "snippet": "static inline void kvm_register_write(struct kvm_vcpu *vcpu,\n\t\t\t\t      enum kvm_reg reg,\n\t\t\t\t      unsigned long val)\n{\n\tvcpu->arch.regs[reg] = val;\n\t__set_bit(reg, (unsigned long *)&vcpu->arch.regs_dirty);\n\t__set_bit(reg, (unsigned long *)&vcpu->arch.regs_avail);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void kvm_register_write(struct kvm_vcpu *vcpu,\n\t\t\t\t      enum kvm_reg reg,\n\t\t\t\t      unsigned long val)\n{\n\tvcpu->arch.regs[reg] = val;\n\t__set_bit(reg, (unsigned long *)&vcpu->arch.regs_dirty);\n\t__set_bit(reg, (unsigned long *)&vcpu->arch.regs_avail);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_get_dr",
          "args": [
            "&svm->vcpu",
            "dr",
            "&val"
          ],
          "line": 3268
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_get_dr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "904-925",
          "snippet": "int kvm_get_dr(struct kvm_vcpu *vcpu, int dr, unsigned long *val)\n{\n\tswitch (dr) {\n\tcase 0 ... 3:\n\t\t*val = vcpu->arch.db[dr];\n\t\tbreak;\n\tcase 4:\n\t\t/* fall through */\n\tcase 6:\n\t\tif (vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP)\n\t\t\t*val = vcpu->arch.dr6;\n\t\telse\n\t\t\t*val = kvm_x86_ops->get_dr6(vcpu);\n\t\tbreak;\n\tcase 5:\n\t\t/* fall through */\n\tdefault: /* 7 */\n\t\t*val = vcpu->arch.dr7;\n\t\tbreak;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "struct kvm_x86_ops *kvm_x86_ops"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nint kvm_get_dr(struct kvm_vcpu *vcpu, int dr, unsigned long *val)\n{\n\tswitch (dr) {\n\tcase 0 ... 3:\n\t\t*val = vcpu->arch.db[dr];\n\t\tbreak;\n\tcase 4:\n\t\t/* fall through */\n\tcase 6:\n\t\tif (vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP)\n\t\t\t*val = vcpu->arch.dr6;\n\t\telse\n\t\t\t*val = kvm_x86_ops->get_dr6(vcpu);\n\t\tbreak;\n\tcase 5:\n\t\t/* fall through */\n\tdefault: /* 7 */\n\t\t*val = vcpu->arch.dr7;\n\t\tbreak;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_require_dr",
          "args": [
            "&svm->vcpu",
            "dr"
          ],
          "line": 3266
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_require_dr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "480-487",
          "snippet": "bool kvm_require_dr(struct kvm_vcpu *vcpu, int dr)\n{\n\tif ((dr != 4 && dr != 5) || !kvm_read_cr4_bits(vcpu, X86_CR4_DE))\n\t\treturn true;\n\n\tkvm_queue_exception(vcpu, UD_VECTOR);\n\treturn false;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nbool kvm_require_dr(struct kvm_vcpu *vcpu, int dr)\n{\n\tif ((dr != 4 && dr != 5) || !kvm_read_cr4_bits(vcpu, X86_CR4_DE))\n\t\treturn true;\n\n\tkvm_queue_exception(vcpu, UD_VECTOR);\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_set_dr",
          "args": [
            "&svm->vcpu",
            "dr - 16",
            "val"
          ],
          "line": 3264
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_set_dr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "894-901",
          "snippet": "int kvm_set_dr(struct kvm_vcpu *vcpu, int dr, unsigned long val)\n{\n\tif (__kvm_set_dr(vcpu, dr, val)) {\n\t\tkvm_inject_gp(vcpu, 0);\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nint kvm_set_dr(struct kvm_vcpu *vcpu, int dr, unsigned long val)\n{\n\tif (__kvm_set_dr(vcpu, dr, val)) {\n\t\tkvm_inject_gp(vcpu, 0);\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_register_read",
          "args": [
            "&svm->vcpu",
            "reg"
          ],
          "line": 3263
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_register_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "9-16",
          "snippet": "static inline unsigned long kvm_register_read(struct kvm_vcpu *vcpu,\n\t\t\t\t\t      enum kvm_reg reg)\n{\n\tif (!test_bit(reg, (unsigned long *)&vcpu->arch.regs_avail))\n\t\tkvm_x86_ops->cache_reg(vcpu, reg);\n\n\treturn vcpu->arch.regs[reg];\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline unsigned long kvm_register_read(struct kvm_vcpu *vcpu,\n\t\t\t\t\t      enum kvm_reg reg)\n{\n\tif (!test_bit(reg, (unsigned long *)&vcpu->arch.regs_avail))\n\t\tkvm_x86_ops->cache_reg(vcpu, reg);\n\n\treturn vcpu->arch.regs[reg];\n}"
        }
      },
      {
        "call_info": {
          "callee": "emulate_on_interception",
          "args": [
            "svm"
          ],
          "line": 3255
        },
        "resolved": true,
        "details": {
          "function_name": "emulate_on_interception",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "3121-3124",
          "snippet": "static int emulate_on_interception(struct vcpu_svm *svm)\n{\n\treturn emulate_instruction(&svm->vcpu, 0) == EMULATE_DONE;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic int emulate_on_interception(struct vcpu_svm *svm)\n{\n\treturn emulate_instruction(&svm->vcpu, 0) == EMULATE_DONE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "boot_cpu_has",
          "args": [
            "X86_FEATURE_DECODEASSISTS"
          ],
          "line": 3254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clr_dr_intercepts",
          "args": [
            "svm"
          ],
          "line": 3249
        },
        "resolved": true,
        "details": {
          "function_name": "clr_dr_intercepts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "393-400",
          "snippet": "static inline void clr_dr_intercepts(struct vcpu_svm *svm)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept_dr = 0;\n\n\trecalc_intercepts(svm);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic inline void clr_dr_intercepts(struct vcpu_svm *svm)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept_dr = 0;\n\n\trecalc_intercepts(svm);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic int dr_interception(struct vcpu_svm *svm)\n{\n\tint reg, dr;\n\tunsigned long val;\n\n\tif (svm->vcpu.guest_debug == 0) {\n\t\t/*\n\t\t * No more DR vmexits; force a reload of the debug registers\n\t\t * and reenter on this instruction.  The next vmexit will\n\t\t * retrieve the full state of the debug registers.\n\t\t */\n\t\tclr_dr_intercepts(svm);\n\t\tsvm->vcpu.arch.switch_db_regs |= KVM_DEBUGREG_WONT_EXIT;\n\t\treturn 1;\n\t}\n\n\tif (!boot_cpu_has(X86_FEATURE_DECODEASSISTS))\n\t\treturn emulate_on_interception(svm);\n\n\treg = svm->vmcb->control.exit_info_1 & SVM_EXITINFO_REG_MASK;\n\tdr = svm->vmcb->control.exit_code - SVM_EXIT_READ_DR0;\n\n\tif (dr >= 16) { /* mov to DRn */\n\t\tif (!kvm_require_dr(&svm->vcpu, dr - 16))\n\t\t\treturn 1;\n\t\tval = kvm_register_read(&svm->vcpu, reg);\n\t\tkvm_set_dr(&svm->vcpu, dr - 16, val);\n\t} else {\n\t\tif (!kvm_require_dr(&svm->vcpu, dr))\n\t\t\treturn 1;\n\t\tkvm_get_dr(&svm->vcpu, dr, &val);\n\t\tkvm_register_write(&svm->vcpu, reg, val);\n\t}\n\n\tskip_emulated_instruction(&svm->vcpu);\n\n\treturn 1;\n}"
  },
  {
    "function_name": "cr_interception",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "3165-3236",
    "snippet": "static int cr_interception(struct vcpu_svm *svm)\n{\n\tint reg, cr;\n\tunsigned long val;\n\tint err;\n\n\tif (!static_cpu_has(X86_FEATURE_DECODEASSISTS))\n\t\treturn emulate_on_interception(svm);\n\n\tif (unlikely((svm->vmcb->control.exit_info_1 & CR_VALID) == 0))\n\t\treturn emulate_on_interception(svm);\n\n\treg = svm->vmcb->control.exit_info_1 & SVM_EXITINFO_REG_MASK;\n\tif (svm->vmcb->control.exit_code == SVM_EXIT_CR0_SEL_WRITE)\n\t\tcr = SVM_EXIT_WRITE_CR0 - SVM_EXIT_READ_CR0;\n\telse\n\t\tcr = svm->vmcb->control.exit_code - SVM_EXIT_READ_CR0;\n\n\terr = 0;\n\tif (cr >= 16) { /* mov to cr */\n\t\tcr -= 16;\n\t\tval = kvm_register_read(&svm->vcpu, reg);\n\t\tswitch (cr) {\n\t\tcase 0:\n\t\t\tif (!check_selective_cr0_intercepted(svm, val))\n\t\t\t\terr = kvm_set_cr0(&svm->vcpu, val);\n\t\t\telse\n\t\t\t\treturn 1;\n\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\terr = kvm_set_cr3(&svm->vcpu, val);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\terr = kvm_set_cr4(&svm->vcpu, val);\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\terr = kvm_set_cr8(&svm->vcpu, val);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tWARN(1, \"unhandled write to CR%d\", cr);\n\t\t\tkvm_queue_exception(&svm->vcpu, UD_VECTOR);\n\t\t\treturn 1;\n\t\t}\n\t} else { /* mov from cr */\n\t\tswitch (cr) {\n\t\tcase 0:\n\t\t\tval = kvm_read_cr0(&svm->vcpu);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tval = svm->vcpu.arch.cr2;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tval = kvm_read_cr3(&svm->vcpu);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tval = kvm_read_cr4(&svm->vcpu);\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tval = kvm_get_cr8(&svm->vcpu);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tWARN(1, \"unhandled read from CR%d\", cr);\n\t\t\tkvm_queue_exception(&svm->vcpu, UD_VECTOR);\n\t\t\treturn 1;\n\t\t}\n\t\tkvm_register_write(&svm->vcpu, reg, val);\n\t}\n\tkvm_complete_insn_gp(&svm->vcpu, err);\n\n\treturn 1;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define CR_VALID (1ULL << 63)"
    ],
    "globals_used": [
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_complete_insn_gp",
          "args": [
            "&svm->vcpu",
            "err"
          ],
          "line": 3233
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_complete_insn_gp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "421-427",
          "snippet": "void kvm_complete_insn_gp(struct kvm_vcpu *vcpu, int err)\n{\n\tif (err)\n\t\tkvm_inject_gp(vcpu, 0);\n\telse\n\t\tkvm_x86_ops->skip_emulated_instruction(vcpu);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "struct kvm_x86_ops *kvm_x86_ops"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nvoid kvm_complete_insn_gp(struct kvm_vcpu *vcpu, int err)\n{\n\tif (err)\n\t\tkvm_inject_gp(vcpu, 0);\n\telse\n\t\tkvm_x86_ops->skip_emulated_instruction(vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_register_write",
          "args": [
            "&svm->vcpu",
            "reg",
            "val"
          ],
          "line": 3231
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_register_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "18-25",
          "snippet": "static inline void kvm_register_write(struct kvm_vcpu *vcpu,\n\t\t\t\t      enum kvm_reg reg,\n\t\t\t\t      unsigned long val)\n{\n\tvcpu->arch.regs[reg] = val;\n\t__set_bit(reg, (unsigned long *)&vcpu->arch.regs_dirty);\n\t__set_bit(reg, (unsigned long *)&vcpu->arch.regs_avail);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void kvm_register_write(struct kvm_vcpu *vcpu,\n\t\t\t\t      enum kvm_reg reg,\n\t\t\t\t      unsigned long val)\n{\n\tvcpu->arch.regs[reg] = val;\n\t__set_bit(reg, (unsigned long *)&vcpu->arch.regs_dirty);\n\t__set_bit(reg, (unsigned long *)&vcpu->arch.regs_avail);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_queue_exception",
          "args": [
            "&svm->vcpu",
            "UD_VECTOR"
          ],
          "line": 3228
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_queue_exception",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "409-412",
          "snippet": "void kvm_queue_exception(struct kvm_vcpu *vcpu, unsigned nr)\n{\n\tkvm_multiple_exception(vcpu, nr, false, 0, false);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nvoid kvm_queue_exception(struct kvm_vcpu *vcpu, unsigned nr)\n{\n\tkvm_multiple_exception(vcpu, nr, false, 0, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "1",
            "\"unhandled read from CR%d\"",
            "cr"
          ],
          "line": 3227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_get_cr8",
          "args": [
            "&svm->vcpu"
          ],
          "line": 3224
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_get_cr8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "816-822",
          "snippet": "unsigned long kvm_get_cr8(struct kvm_vcpu *vcpu)\n{\n\tif (lapic_in_kernel(vcpu))\n\t\treturn kvm_lapic_get_cr8(vcpu);\n\telse\n\t\treturn vcpu->arch.cr8;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nunsigned long kvm_get_cr8(struct kvm_vcpu *vcpu)\n{\n\tif (lapic_in_kernel(vcpu))\n\t\treturn kvm_lapic_get_cr8(vcpu);\n\telse\n\t\treturn vcpu->arch.cr8;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_read_cr4",
          "args": [
            "&svm->vcpu"
          ],
          "line": 3221
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_read_cr4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "76-79",
          "snippet": "static inline ulong kvm_read_cr4(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_read_cr4_bits(vcpu, ~0UL);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline ulong kvm_read_cr4(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_read_cr4_bits(vcpu, ~0UL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_read_cr3",
          "args": [
            "&svm->vcpu"
          ],
          "line": 3218
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_read_cr3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "69-74",
          "snippet": "static inline ulong kvm_read_cr3(struct kvm_vcpu *vcpu)\n{\n\tif (!test_bit(VCPU_EXREG_CR3, (ulong *)&vcpu->arch.regs_avail))\n\t\tkvm_x86_ops->decache_cr3(vcpu);\n\treturn vcpu->arch.cr3;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline ulong kvm_read_cr3(struct kvm_vcpu *vcpu)\n{\n\tif (!test_bit(VCPU_EXREG_CR3, (ulong *)&vcpu->arch.regs_avail))\n\t\tkvm_x86_ops->decache_cr3(vcpu);\n\treturn vcpu->arch.cr3;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_read_cr0",
          "args": [
            "&svm->vcpu"
          ],
          "line": 3212
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_read_cr0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "56-59",
          "snippet": "static inline ulong kvm_read_cr0(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_read_cr0_bits(vcpu, ~0UL);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline ulong kvm_read_cr0(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_read_cr0_bits(vcpu, ~0UL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "1",
            "\"unhandled write to CR%d\"",
            "cr"
          ],
          "line": 3205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_set_cr8",
          "args": [
            "&svm->vcpu",
            "val"
          ],
          "line": 3202
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_set_cr8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "804-813",
          "snippet": "int kvm_set_cr8(struct kvm_vcpu *vcpu, unsigned long cr8)\n{\n\tif (cr8 & CR8_RESERVED_BITS)\n\t\treturn 1;\n\tif (lapic_in_kernel(vcpu))\n\t\tkvm_lapic_set_tpr(vcpu, cr8);\n\telse\n\t\tvcpu->arch.cr8 = cr8;\n\treturn 0;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nint kvm_set_cr8(struct kvm_vcpu *vcpu, unsigned long cr8)\n{\n\tif (cr8 & CR8_RESERVED_BITS)\n\t\treturn 1;\n\tif (lapic_in_kernel(vcpu))\n\t\tkvm_lapic_set_tpr(vcpu, cr8);\n\telse\n\t\tvcpu->arch.cr8 = cr8;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_set_cr4",
          "args": [
            "&svm->vcpu",
            "val"
          ],
          "line": 3199
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_set_cr4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "722-775",
          "snippet": "int kvm_set_cr4(struct kvm_vcpu *vcpu, unsigned long cr4)\n{\n\tunsigned long old_cr4 = kvm_read_cr4(vcpu);\n\tunsigned long pdptr_bits = X86_CR4_PGE | X86_CR4_PSE | X86_CR4_PAE |\n\t\t\t\t   X86_CR4_SMEP | X86_CR4_SMAP | X86_CR4_PKE;\n\n\tif (cr4 & CR4_RESERVED_BITS)\n\t\treturn 1;\n\n\tif (!guest_cpuid_has_xsave(vcpu) && (cr4 & X86_CR4_OSXSAVE))\n\t\treturn 1;\n\n\tif (!guest_cpuid_has_smep(vcpu) && (cr4 & X86_CR4_SMEP))\n\t\treturn 1;\n\n\tif (!guest_cpuid_has_smap(vcpu) && (cr4 & X86_CR4_SMAP))\n\t\treturn 1;\n\n\tif (!guest_cpuid_has_fsgsbase(vcpu) && (cr4 & X86_CR4_FSGSBASE))\n\t\treturn 1;\n\n\tif (!guest_cpuid_has_pku(vcpu) && (cr4 & X86_CR4_PKE))\n\t\treturn 1;\n\n\tif (is_long_mode(vcpu)) {\n\t\tif (!(cr4 & X86_CR4_PAE))\n\t\t\treturn 1;\n\t} else if (is_paging(vcpu) && (cr4 & X86_CR4_PAE)\n\t\t   && ((cr4 ^ old_cr4) & pdptr_bits)\n\t\t   && !load_pdptrs(vcpu, vcpu->arch.walk_mmu,\n\t\t\t\t   kvm_read_cr3(vcpu)))\n\t\treturn 1;\n\n\tif ((cr4 & X86_CR4_PCIDE) && !(old_cr4 & X86_CR4_PCIDE)) {\n\t\tif (!guest_cpuid_has_pcid(vcpu))\n\t\t\treturn 1;\n\n\t\t/* PCID can not be enabled when cr3[11:0]!=000H or EFER.LMA=0 */\n\t\tif ((kvm_read_cr3(vcpu) & X86_CR3_PCID_MASK) || !is_long_mode(vcpu))\n\t\t\treturn 1;\n\t}\n\n\tif (kvm_x86_ops->set_cr4(vcpu, cr4))\n\t\treturn 1;\n\n\tif (((cr4 ^ old_cr4) & pdptr_bits) ||\n\t    (!(cr4 & X86_CR4_PCIDE) && (old_cr4 & X86_CR4_PCIDE)))\n\t\tkvm_mmu_reset_context(vcpu);\n\n\tif ((cr4 ^ old_cr4) & (X86_CR4_OSXSAVE | X86_CR4_PKE))\n\t\tkvm_update_cpuid(vcpu);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "struct kvm_x86_ops *kvm_x86_ops"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nint kvm_set_cr4(struct kvm_vcpu *vcpu, unsigned long cr4)\n{\n\tunsigned long old_cr4 = kvm_read_cr4(vcpu);\n\tunsigned long pdptr_bits = X86_CR4_PGE | X86_CR4_PSE | X86_CR4_PAE |\n\t\t\t\t   X86_CR4_SMEP | X86_CR4_SMAP | X86_CR4_PKE;\n\n\tif (cr4 & CR4_RESERVED_BITS)\n\t\treturn 1;\n\n\tif (!guest_cpuid_has_xsave(vcpu) && (cr4 & X86_CR4_OSXSAVE))\n\t\treturn 1;\n\n\tif (!guest_cpuid_has_smep(vcpu) && (cr4 & X86_CR4_SMEP))\n\t\treturn 1;\n\n\tif (!guest_cpuid_has_smap(vcpu) && (cr4 & X86_CR4_SMAP))\n\t\treturn 1;\n\n\tif (!guest_cpuid_has_fsgsbase(vcpu) && (cr4 & X86_CR4_FSGSBASE))\n\t\treturn 1;\n\n\tif (!guest_cpuid_has_pku(vcpu) && (cr4 & X86_CR4_PKE))\n\t\treturn 1;\n\n\tif (is_long_mode(vcpu)) {\n\t\tif (!(cr4 & X86_CR4_PAE))\n\t\t\treturn 1;\n\t} else if (is_paging(vcpu) && (cr4 & X86_CR4_PAE)\n\t\t   && ((cr4 ^ old_cr4) & pdptr_bits)\n\t\t   && !load_pdptrs(vcpu, vcpu->arch.walk_mmu,\n\t\t\t\t   kvm_read_cr3(vcpu)))\n\t\treturn 1;\n\n\tif ((cr4 & X86_CR4_PCIDE) && !(old_cr4 & X86_CR4_PCIDE)) {\n\t\tif (!guest_cpuid_has_pcid(vcpu))\n\t\t\treturn 1;\n\n\t\t/* PCID can not be enabled when cr3[11:0]!=000H or EFER.LMA=0 */\n\t\tif ((kvm_read_cr3(vcpu) & X86_CR3_PCID_MASK) || !is_long_mode(vcpu))\n\t\t\treturn 1;\n\t}\n\n\tif (kvm_x86_ops->set_cr4(vcpu, cr4))\n\t\treturn 1;\n\n\tif (((cr4 ^ old_cr4) & pdptr_bits) ||\n\t    (!(cr4 & X86_CR4_PCIDE) && (old_cr4 & X86_CR4_PCIDE)))\n\t\tkvm_mmu_reset_context(vcpu);\n\n\tif ((cr4 ^ old_cr4) & (X86_CR4_OSXSAVE | X86_CR4_PKE))\n\t\tkvm_update_cpuid(vcpu);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_set_cr3",
          "args": [
            "&svm->vcpu",
            "val"
          ],
          "line": 3196
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_set_cr3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "778-801",
          "snippet": "int kvm_set_cr3(struct kvm_vcpu *vcpu, unsigned long cr3)\n{\n#ifdef CONFIG_X86_64\n\tcr3 &= ~CR3_PCID_INVD;\n#endif\n\n\tif (cr3 == kvm_read_cr3(vcpu) && !pdptrs_changed(vcpu)) {\n\t\tkvm_mmu_sync_roots(vcpu);\n\t\tkvm_make_request(KVM_REQ_TLB_FLUSH, vcpu);\n\t\treturn 0;\n\t}\n\n\tif (is_long_mode(vcpu)) {\n\t\tif (cr3 & CR3_L_MODE_RESERVED_BITS)\n\t\t\treturn 1;\n\t} else if (is_pae(vcpu) && is_paging(vcpu) &&\n\t\t   !load_pdptrs(vcpu, vcpu->arch.walk_mmu, cr3))\n\t\treturn 1;\n\n\tvcpu->arch.cr3 = cr3;\n\t__set_bit(VCPU_EXREG_CR3, (ulong *)&vcpu->arch.regs_avail);\n\tkvm_mmu_new_cr3(vcpu);\n\treturn 0;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nint kvm_set_cr3(struct kvm_vcpu *vcpu, unsigned long cr3)\n{\n#ifdef CONFIG_X86_64\n\tcr3 &= ~CR3_PCID_INVD;\n#endif\n\n\tif (cr3 == kvm_read_cr3(vcpu) && !pdptrs_changed(vcpu)) {\n\t\tkvm_mmu_sync_roots(vcpu);\n\t\tkvm_make_request(KVM_REQ_TLB_FLUSH, vcpu);\n\t\treturn 0;\n\t}\n\n\tif (is_long_mode(vcpu)) {\n\t\tif (cr3 & CR3_L_MODE_RESERVED_BITS)\n\t\t\treturn 1;\n\t} else if (is_pae(vcpu) && is_paging(vcpu) &&\n\t\t   !load_pdptrs(vcpu, vcpu->arch.walk_mmu, cr3))\n\t\treturn 1;\n\n\tvcpu->arch.cr3 = cr3;\n\t__set_bit(VCPU_EXREG_CR3, (ulong *)&vcpu->arch.regs_avail);\n\tkvm_mmu_new_cr3(vcpu);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_set_cr0",
          "args": [
            "&svm->vcpu",
            "val"
          ],
          "line": 3190
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_set_cr0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "587-643",
          "snippet": "int kvm_set_cr0(struct kvm_vcpu *vcpu, unsigned long cr0)\n{\n\tunsigned long old_cr0 = kvm_read_cr0(vcpu);\n\tunsigned long update_bits = X86_CR0_PG | X86_CR0_WP;\n\n\tcr0 |= X86_CR0_ET;\n\n#ifdef CONFIG_X86_64\n\tif (cr0 & 0xffffffff00000000UL)\n\t\treturn 1;\n#endif\n\n\tcr0 &= ~CR0_RESERVED_BITS;\n\n\tif ((cr0 & X86_CR0_NW) && !(cr0 & X86_CR0_CD))\n\t\treturn 1;\n\n\tif ((cr0 & X86_CR0_PG) && !(cr0 & X86_CR0_PE))\n\t\treturn 1;\n\n\tif (!is_paging(vcpu) && (cr0 & X86_CR0_PG)) {\n#ifdef CONFIG_X86_64\n\t\tif ((vcpu->arch.efer & EFER_LME)) {\n\t\t\tint cs_db, cs_l;\n\n\t\t\tif (!is_pae(vcpu))\n\t\t\t\treturn 1;\n\t\t\tkvm_x86_ops->get_cs_db_l_bits(vcpu, &cs_db, &cs_l);\n\t\t\tif (cs_l)\n\t\t\t\treturn 1;\n\t\t} else\n#endif\n\t\tif (is_pae(vcpu) && !load_pdptrs(vcpu, vcpu->arch.walk_mmu,\n\t\t\t\t\t\t kvm_read_cr3(vcpu)))\n\t\t\treturn 1;\n\t}\n\n\tif (!(cr0 & X86_CR0_PG) && kvm_read_cr4_bits(vcpu, X86_CR4_PCIDE))\n\t\treturn 1;\n\n\tkvm_x86_ops->set_cr0(vcpu, cr0);\n\n\tif ((cr0 ^ old_cr0) & X86_CR0_PG) {\n\t\tkvm_clear_async_pf_completion_queue(vcpu);\n\t\tkvm_async_pf_hash_reset(vcpu);\n\t}\n\n\tif ((cr0 ^ old_cr0) & update_bits)\n\t\tkvm_mmu_reset_context(vcpu);\n\n\tif (((cr0 ^ old_cr0) & X86_CR0_CD) &&\n\t    kvm_arch_has_noncoherent_dma(vcpu->kvm) &&\n\t    !kvm_check_has_quirk(vcpu->kvm, KVM_X86_QUIRK_CD_NW_CLEARED))\n\t\tkvm_zap_gfn_range(vcpu->kvm, 0, ~0ULL);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "struct kvm_x86_ops *kvm_x86_ops"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nint kvm_set_cr0(struct kvm_vcpu *vcpu, unsigned long cr0)\n{\n\tunsigned long old_cr0 = kvm_read_cr0(vcpu);\n\tunsigned long update_bits = X86_CR0_PG | X86_CR0_WP;\n\n\tcr0 |= X86_CR0_ET;\n\n#ifdef CONFIG_X86_64\n\tif (cr0 & 0xffffffff00000000UL)\n\t\treturn 1;\n#endif\n\n\tcr0 &= ~CR0_RESERVED_BITS;\n\n\tif ((cr0 & X86_CR0_NW) && !(cr0 & X86_CR0_CD))\n\t\treturn 1;\n\n\tif ((cr0 & X86_CR0_PG) && !(cr0 & X86_CR0_PE))\n\t\treturn 1;\n\n\tif (!is_paging(vcpu) && (cr0 & X86_CR0_PG)) {\n#ifdef CONFIG_X86_64\n\t\tif ((vcpu->arch.efer & EFER_LME)) {\n\t\t\tint cs_db, cs_l;\n\n\t\t\tif (!is_pae(vcpu))\n\t\t\t\treturn 1;\n\t\t\tkvm_x86_ops->get_cs_db_l_bits(vcpu, &cs_db, &cs_l);\n\t\t\tif (cs_l)\n\t\t\t\treturn 1;\n\t\t} else\n#endif\n\t\tif (is_pae(vcpu) && !load_pdptrs(vcpu, vcpu->arch.walk_mmu,\n\t\t\t\t\t\t kvm_read_cr3(vcpu)))\n\t\t\treturn 1;\n\t}\n\n\tif (!(cr0 & X86_CR0_PG) && kvm_read_cr4_bits(vcpu, X86_CR4_PCIDE))\n\t\treturn 1;\n\n\tkvm_x86_ops->set_cr0(vcpu, cr0);\n\n\tif ((cr0 ^ old_cr0) & X86_CR0_PG) {\n\t\tkvm_clear_async_pf_completion_queue(vcpu);\n\t\tkvm_async_pf_hash_reset(vcpu);\n\t}\n\n\tif ((cr0 ^ old_cr0) & update_bits)\n\t\tkvm_mmu_reset_context(vcpu);\n\n\tif (((cr0 ^ old_cr0) & X86_CR0_CD) &&\n\t    kvm_arch_has_noncoherent_dma(vcpu->kvm) &&\n\t    !kvm_check_has_quirk(vcpu->kvm, KVM_X86_QUIRK_CD_NW_CLEARED))\n\t\tkvm_zap_gfn_range(vcpu->kvm, 0, ~0ULL);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_selective_cr0_intercepted",
          "args": [
            "svm",
            "val"
          ],
          "line": 3189
        },
        "resolved": true,
        "details": {
          "function_name": "check_selective_cr0_intercepted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "3139-3161",
          "snippet": "static bool check_selective_cr0_intercepted(struct vcpu_svm *svm,\n\t\t\t\t\t    unsigned long val)\n{\n\tunsigned long cr0 = svm->vcpu.arch.cr0;\n\tbool ret = false;\n\tu64 intercept;\n\n\tintercept = svm->nested.intercept;\n\n\tif (!is_guest_mode(&svm->vcpu) ||\n\t    (!(intercept & (1ULL << INTERCEPT_SELECTIVE_CR0))))\n\t\treturn false;\n\n\tcr0 &= ~SVM_CR0_SELECTIVE_MASK;\n\tval &= ~SVM_CR0_SELECTIVE_MASK;\n\n\tif (cr0 ^ val) {\n\t\tsvm->vmcb->control.exit_code = SVM_EXIT_CR0_SEL_WRITE;\n\t\tret = (nested_svm_exit_handled(svm) == NESTED_EXIT_DONE);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define NESTED_EXIT_DONE\t1\t/* Exit caused nested vmexit  */"
          ],
          "globals_used": [
            "static int nested = true;",
            "static void svm_set_cr0(struct kvm_vcpu *vcpu, unsigned long cr0);",
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define NESTED_EXIT_DONE\t1\t/* Exit caused nested vmexit  */\n\nstatic int nested = true;\nstatic void svm_set_cr0(struct kvm_vcpu *vcpu, unsigned long cr0);\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic bool check_selective_cr0_intercepted(struct vcpu_svm *svm,\n\t\t\t\t\t    unsigned long val)\n{\n\tunsigned long cr0 = svm->vcpu.arch.cr0;\n\tbool ret = false;\n\tu64 intercept;\n\n\tintercept = svm->nested.intercept;\n\n\tif (!is_guest_mode(&svm->vcpu) ||\n\t    (!(intercept & (1ULL << INTERCEPT_SELECTIVE_CR0))))\n\t\treturn false;\n\n\tcr0 &= ~SVM_CR0_SELECTIVE_MASK;\n\tval &= ~SVM_CR0_SELECTIVE_MASK;\n\n\tif (cr0 ^ val) {\n\t\tsvm->vmcb->control.exit_code = SVM_EXIT_CR0_SEL_WRITE;\n\t\tret = (nested_svm_exit_handled(svm) == NESTED_EXIT_DONE);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_register_read",
          "args": [
            "&svm->vcpu",
            "reg"
          ],
          "line": 3186
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_register_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "9-16",
          "snippet": "static inline unsigned long kvm_register_read(struct kvm_vcpu *vcpu,\n\t\t\t\t\t      enum kvm_reg reg)\n{\n\tif (!test_bit(reg, (unsigned long *)&vcpu->arch.regs_avail))\n\t\tkvm_x86_ops->cache_reg(vcpu, reg);\n\n\treturn vcpu->arch.regs[reg];\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline unsigned long kvm_register_read(struct kvm_vcpu *vcpu,\n\t\t\t\t\t      enum kvm_reg reg)\n{\n\tif (!test_bit(reg, (unsigned long *)&vcpu->arch.regs_avail))\n\t\tkvm_x86_ops->cache_reg(vcpu, reg);\n\n\treturn vcpu->arch.regs[reg];\n}"
        }
      },
      {
        "call_info": {
          "callee": "emulate_on_interception",
          "args": [
            "svm"
          ],
          "line": 3175
        },
        "resolved": true,
        "details": {
          "function_name": "emulate_on_interception",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "3121-3124",
          "snippet": "static int emulate_on_interception(struct vcpu_svm *svm)\n{\n\treturn emulate_instruction(&svm->vcpu, 0) == EMULATE_DONE;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic int emulate_on_interception(struct vcpu_svm *svm)\n{\n\treturn emulate_instruction(&svm->vcpu, 0) == EMULATE_DONE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "(svm->vmcb->control.exit_info_1 & CR_VALID) == 0"
          ],
          "line": 3174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_cpu_has",
          "args": [
            "X86_FEATURE_DECODEASSISTS"
          ],
          "line": 3171
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define CR_VALID (1ULL << 63)\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic int cr_interception(struct vcpu_svm *svm)\n{\n\tint reg, cr;\n\tunsigned long val;\n\tint err;\n\n\tif (!static_cpu_has(X86_FEATURE_DECODEASSISTS))\n\t\treturn emulate_on_interception(svm);\n\n\tif (unlikely((svm->vmcb->control.exit_info_1 & CR_VALID) == 0))\n\t\treturn emulate_on_interception(svm);\n\n\treg = svm->vmcb->control.exit_info_1 & SVM_EXITINFO_REG_MASK;\n\tif (svm->vmcb->control.exit_code == SVM_EXIT_CR0_SEL_WRITE)\n\t\tcr = SVM_EXIT_WRITE_CR0 - SVM_EXIT_READ_CR0;\n\telse\n\t\tcr = svm->vmcb->control.exit_code - SVM_EXIT_READ_CR0;\n\n\terr = 0;\n\tif (cr >= 16) { /* mov to cr */\n\t\tcr -= 16;\n\t\tval = kvm_register_read(&svm->vcpu, reg);\n\t\tswitch (cr) {\n\t\tcase 0:\n\t\t\tif (!check_selective_cr0_intercepted(svm, val))\n\t\t\t\terr = kvm_set_cr0(&svm->vcpu, val);\n\t\t\telse\n\t\t\t\treturn 1;\n\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\terr = kvm_set_cr3(&svm->vcpu, val);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\terr = kvm_set_cr4(&svm->vcpu, val);\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\terr = kvm_set_cr8(&svm->vcpu, val);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tWARN(1, \"unhandled write to CR%d\", cr);\n\t\t\tkvm_queue_exception(&svm->vcpu, UD_VECTOR);\n\t\t\treturn 1;\n\t\t}\n\t} else { /* mov from cr */\n\t\tswitch (cr) {\n\t\tcase 0:\n\t\t\tval = kvm_read_cr0(&svm->vcpu);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tval = svm->vcpu.arch.cr2;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tval = kvm_read_cr3(&svm->vcpu);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tval = kvm_read_cr4(&svm->vcpu);\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tval = kvm_get_cr8(&svm->vcpu);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tWARN(1, \"unhandled read from CR%d\", cr);\n\t\t\tkvm_queue_exception(&svm->vcpu, UD_VECTOR);\n\t\t\treturn 1;\n\t\t}\n\t\tkvm_register_write(&svm->vcpu, reg, val);\n\t}\n\tkvm_complete_insn_gp(&svm->vcpu, err);\n\n\treturn 1;\n}"
  },
  {
    "function_name": "check_selective_cr0_intercepted",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "3139-3161",
    "snippet": "static bool check_selective_cr0_intercepted(struct vcpu_svm *svm,\n\t\t\t\t\t    unsigned long val)\n{\n\tunsigned long cr0 = svm->vcpu.arch.cr0;\n\tbool ret = false;\n\tu64 intercept;\n\n\tintercept = svm->nested.intercept;\n\n\tif (!is_guest_mode(&svm->vcpu) ||\n\t    (!(intercept & (1ULL << INTERCEPT_SELECTIVE_CR0))))\n\t\treturn false;\n\n\tcr0 &= ~SVM_CR0_SELECTIVE_MASK;\n\tval &= ~SVM_CR0_SELECTIVE_MASK;\n\n\tif (cr0 ^ val) {\n\t\tsvm->vmcb->control.exit_code = SVM_EXIT_CR0_SEL_WRITE;\n\t\tret = (nested_svm_exit_handled(svm) == NESTED_EXIT_DONE);\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define NESTED_EXIT_DONE\t1\t/* Exit caused nested vmexit  */"
    ],
    "globals_used": [
      "static int nested = true;",
      "static void svm_set_cr0(struct kvm_vcpu *vcpu, unsigned long cr0);",
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nested_svm_exit_handled",
          "args": [
            "svm"
          ],
          "line": 3157
        },
        "resolved": true,
        "details": {
          "function_name": "nested_svm_exit_handled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "2492-2502",
          "snippet": "static int nested_svm_exit_handled(struct vcpu_svm *svm)\n{\n\tint vmexit;\n\n\tvmexit = nested_svm_intercept(svm);\n\n\tif (vmexit == NESTED_EXIT_DONE)\n\t\tnested_svm_vmexit(svm);\n\n\treturn vmexit;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define NESTED_EXIT_DONE\t1\t/* Exit caused nested vmexit  */"
          ],
          "globals_used": [
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define NESTED_EXIT_DONE\t1\t/* Exit caused nested vmexit  */\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm)\n{\n\tint vmexit;\n\n\tvmexit = nested_svm_intercept(svm);\n\n\tif (vmexit == NESTED_EXIT_DONE)\n\t\tnested_svm_vmexit(svm);\n\n\treturn vmexit;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_guest_mode",
          "args": [
            "&svm->vcpu"
          ],
          "line": 3148
        },
        "resolved": true,
        "details": {
          "function_name": "is_guest_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "102-105",
          "snippet": "static inline bool is_guest_mode(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.hflags & HF_GUEST_MASK;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline bool is_guest_mode(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.hflags & HF_GUEST_MASK;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define NESTED_EXIT_DONE\t1\t/* Exit caused nested vmexit  */\n\nstatic int nested = true;\nstatic void svm_set_cr0(struct kvm_vcpu *vcpu, unsigned long cr0);\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic bool check_selective_cr0_intercepted(struct vcpu_svm *svm,\n\t\t\t\t\t    unsigned long val)\n{\n\tunsigned long cr0 = svm->vcpu.arch.cr0;\n\tbool ret = false;\n\tu64 intercept;\n\n\tintercept = svm->nested.intercept;\n\n\tif (!is_guest_mode(&svm->vcpu) ||\n\t    (!(intercept & (1ULL << INTERCEPT_SELECTIVE_CR0))))\n\t\treturn false;\n\n\tcr0 &= ~SVM_CR0_SELECTIVE_MASK;\n\tval &= ~SVM_CR0_SELECTIVE_MASK;\n\n\tif (cr0 ^ val) {\n\t\tsvm->vmcb->control.exit_code = SVM_EXIT_CR0_SEL_WRITE;\n\t\tret = (nested_svm_exit_handled(svm) == NESTED_EXIT_DONE);\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "rdpmc_interception",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "3126-3137",
    "snippet": "static int rdpmc_interception(struct vcpu_svm *svm)\n{\n\tint err;\n\n\tif (!static_cpu_has(X86_FEATURE_NRIPS))\n\t\treturn emulate_on_interception(svm);\n\n\terr = kvm_rdpmc(&svm->vcpu);\n\tkvm_complete_insn_gp(&svm->vcpu, err);\n\n\treturn 1;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_complete_insn_gp",
          "args": [
            "&svm->vcpu",
            "err"
          ],
          "line": 3134
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_complete_insn_gp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "421-427",
          "snippet": "void kvm_complete_insn_gp(struct kvm_vcpu *vcpu, int err)\n{\n\tif (err)\n\t\tkvm_inject_gp(vcpu, 0);\n\telse\n\t\tkvm_x86_ops->skip_emulated_instruction(vcpu);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "struct kvm_x86_ops *kvm_x86_ops"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nvoid kvm_complete_insn_gp(struct kvm_vcpu *vcpu, int err)\n{\n\tif (err)\n\t\tkvm_inject_gp(vcpu, 0);\n\telse\n\t\tkvm_x86_ops->skip_emulated_instruction(vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_rdpmc",
          "args": [
            "&svm->vcpu"
          ],
          "line": 3133
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_rdpmc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "928-940",
          "snippet": "bool kvm_rdpmc(struct kvm_vcpu *vcpu)\n{\n\tu32 ecx = kvm_register_read(vcpu, VCPU_REGS_RCX);\n\tu64 data;\n\tint err;\n\n\terr = kvm_pmu_rdpmc(vcpu, ecx, &data);\n\tif (err)\n\t\treturn err;\n\tkvm_register_write(vcpu, VCPU_REGS_RAX, (u32)data);\n\tkvm_register_write(vcpu, VCPU_REGS_RDX, data >> 32);\n\treturn err;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nbool kvm_rdpmc(struct kvm_vcpu *vcpu)\n{\n\tu32 ecx = kvm_register_read(vcpu, VCPU_REGS_RCX);\n\tu64 data;\n\tint err;\n\n\terr = kvm_pmu_rdpmc(vcpu, ecx, &data);\n\tif (err)\n\t\treturn err;\n\tkvm_register_write(vcpu, VCPU_REGS_RAX, (u32)data);\n\tkvm_register_write(vcpu, VCPU_REGS_RDX, data >> 32);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "emulate_on_interception",
          "args": [
            "svm"
          ],
          "line": 3131
        },
        "resolved": true,
        "details": {
          "function_name": "emulate_on_interception",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "3121-3124",
          "snippet": "static int emulate_on_interception(struct vcpu_svm *svm)\n{\n\treturn emulate_instruction(&svm->vcpu, 0) == EMULATE_DONE;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic int emulate_on_interception(struct vcpu_svm *svm)\n{\n\treturn emulate_instruction(&svm->vcpu, 0) == EMULATE_DONE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_cpu_has",
          "args": [
            "X86_FEATURE_NRIPS"
          ],
          "line": 3130
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic int rdpmc_interception(struct vcpu_svm *svm)\n{\n\tint err;\n\n\tif (!static_cpu_has(X86_FEATURE_NRIPS))\n\t\treturn emulate_on_interception(svm);\n\n\terr = kvm_rdpmc(&svm->vcpu);\n\tkvm_complete_insn_gp(&svm->vcpu, err);\n\n\treturn 1;\n}"
  },
  {
    "function_name": "emulate_on_interception",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "3121-3124",
    "snippet": "static int emulate_on_interception(struct vcpu_svm *svm)\n{\n\treturn emulate_instruction(&svm->vcpu, 0) == EMULATE_DONE;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "emulate_instruction",
          "args": [
            "&svm->vcpu",
            "0"
          ],
          "line": 3123
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic int emulate_on_interception(struct vcpu_svm *svm)\n{\n\treturn emulate_instruction(&svm->vcpu, 0) == EMULATE_DONE;\n}"
  },
  {
    "function_name": "invlpg_interception",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "3111-3119",
    "snippet": "static int invlpg_interception(struct vcpu_svm *svm)\n{\n\tif (!static_cpu_has(X86_FEATURE_DECODEASSISTS))\n\t\treturn emulate_instruction(&svm->vcpu, 0) == EMULATE_DONE;\n\n\tkvm_mmu_invlpg(&svm->vcpu, svm->vmcb->control.exit_info_1);\n\tskip_emulated_instruction(&svm->vcpu);\n\treturn 1;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "skip_emulated_instruction",
          "args": [
            "&svm->vcpu"
          ],
          "line": 3117
        },
        "resolved": true,
        "details": {
          "function_name": "skip_emulated_instruction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "572-593",
          "snippet": "static void skip_emulated_instruction(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (svm->vmcb->control.next_rip != 0) {\n\t\tWARN_ON_ONCE(!static_cpu_has(X86_FEATURE_NRIPS));\n\t\tsvm->next_rip = svm->vmcb->control.next_rip;\n\t}\n\n\tif (!svm->next_rip) {\n\t\tif (emulate_instruction(vcpu, EMULTYPE_SKIP) !=\n\t\t\t\tEMULATE_DONE)\n\t\t\tprintk(KERN_DEBUG \"%s: NOP\\n\", __func__);\n\t\treturn;\n\t}\n\tif (svm->next_rip - kvm_rip_read(vcpu) > MAX_INST_SIZE)\n\t\tprintk(KERN_ERR \"%s: ip 0x%lx next 0x%llx\\n\",\n\t\t       __func__, kvm_rip_read(vcpu), svm->next_rip);\n\n\tkvm_rip_write(vcpu, svm->next_rip);\n\tsvm_set_interrupt_shadow(vcpu, 0);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define MAX_INST_SIZE 15"
          ],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define MAX_INST_SIZE 15\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic void skip_emulated_instruction(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (svm->vmcb->control.next_rip != 0) {\n\t\tWARN_ON_ONCE(!static_cpu_has(X86_FEATURE_NRIPS));\n\t\tsvm->next_rip = svm->vmcb->control.next_rip;\n\t}\n\n\tif (!svm->next_rip) {\n\t\tif (emulate_instruction(vcpu, EMULTYPE_SKIP) !=\n\t\t\t\tEMULATE_DONE)\n\t\t\tprintk(KERN_DEBUG \"%s: NOP\\n\", __func__);\n\t\treturn;\n\t}\n\tif (svm->next_rip - kvm_rip_read(vcpu) > MAX_INST_SIZE)\n\t\tprintk(KERN_ERR \"%s: ip 0x%lx next 0x%llx\\n\",\n\t\t       __func__, kvm_rip_read(vcpu), svm->next_rip);\n\n\tkvm_rip_write(vcpu, svm->next_rip);\n\tsvm_set_interrupt_shadow(vcpu, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_mmu_invlpg",
          "args": [
            "&svm->vcpu",
            "svm->vmcb->control.exit_info_1"
          ],
          "line": 3116
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_invlpg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "4548-4553",
          "snippet": "void kvm_mmu_invlpg(struct kvm_vcpu *vcpu, gva_t gva)\n{\n\tvcpu->arch.mmu.invlpg(vcpu, gva);\n\tkvm_make_request(KVM_REQ_TLB_FLUSH, vcpu);\n\t++vcpu->stat.invlpg;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nvoid kvm_mmu_invlpg(struct kvm_vcpu *vcpu, gva_t gva)\n{\n\tvcpu->arch.mmu.invlpg(vcpu, gva);\n\tkvm_make_request(KVM_REQ_TLB_FLUSH, vcpu);\n\t++vcpu->stat.invlpg;\n}"
        }
      },
      {
        "call_info": {
          "callee": "emulate_instruction",
          "args": [
            "&svm->vcpu",
            "0"
          ],
          "line": 3114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_cpu_has",
          "args": [
            "X86_FEATURE_DECODEASSISTS"
          ],
          "line": 3113
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic int invlpg_interception(struct vcpu_svm *svm)\n{\n\tif (!static_cpu_has(X86_FEATURE_DECODEASSISTS))\n\t\treturn emulate_instruction(&svm->vcpu, 0) == EMULATE_DONE;\n\n\tkvm_mmu_invlpg(&svm->vcpu, svm->vmcb->control.exit_info_1);\n\tskip_emulated_instruction(&svm->vcpu);\n\treturn 1;\n}"
  },
  {
    "function_name": "iret_interception",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "3101-3109",
    "snippet": "static int iret_interception(struct vcpu_svm *svm)\n{\n\t++svm->vcpu.stat.nmi_window_exits;\n\tclr_intercept(svm, INTERCEPT_IRET);\n\tsvm->vcpu.arch.hflags |= HF_IRET_MASK;\n\tsvm->nmi_iret_rip = kvm_rip_read(&svm->vcpu);\n\tkvm_make_request(KVM_REQ_EVENT, &svm->vcpu);\n\treturn 1;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_make_request",
          "args": [
            "KVM_REQ_EVENT",
            "&svm->vcpu"
          ],
          "line": 3107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_rip_read",
          "args": [
            "&svm->vcpu"
          ],
          "line": 3106
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_rip_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "27-30",
          "snippet": "static inline unsigned long kvm_rip_read(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_register_read(vcpu, VCPU_REGS_RIP);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline unsigned long kvm_rip_read(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_register_read(vcpu, VCPU_REGS_RIP);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clr_intercept",
          "args": [
            "svm",
            "INTERCEPT_IRET"
          ],
          "line": 3104
        },
        "resolved": true,
        "details": {
          "function_name": "clr_intercept",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "429-436",
          "snippet": "static inline void clr_intercept(struct vcpu_svm *svm, int bit)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept &= ~(1ULL << bit);\n\n\trecalc_intercepts(svm);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic inline void clr_intercept(struct vcpu_svm *svm, int bit)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept &= ~(1ULL << bit);\n\n\trecalc_intercepts(svm);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic int iret_interception(struct vcpu_svm *svm)\n{\n\t++svm->vcpu.stat.nmi_window_exits;\n\tclr_intercept(svm, INTERCEPT_IRET);\n\tsvm->vcpu.arch.hflags |= HF_IRET_MASK;\n\tsvm->nmi_iret_rip = kvm_rip_read(&svm->vcpu);\n\tkvm_make_request(KVM_REQ_EVENT, &svm->vcpu);\n\treturn 1;\n}"
  },
  {
    "function_name": "cpuid_interception",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "3094-3099",
    "snippet": "static int cpuid_interception(struct vcpu_svm *svm)\n{\n\tsvm->next_rip = kvm_rip_read(&svm->vcpu) + 2;\n\tkvm_emulate_cpuid(&svm->vcpu);\n\treturn 1;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_emulate_cpuid",
          "args": [
            "&svm->vcpu"
          ],
          "line": 3097
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_emulate_cpuid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/cpuid.c",
          "lines": "863-875",
          "snippet": "void kvm_emulate_cpuid(struct kvm_vcpu *vcpu)\n{\n\tu32 function, eax, ebx, ecx, edx;\n\n\tfunction = eax = kvm_register_read(vcpu, VCPU_REGS_RAX);\n\tecx = kvm_register_read(vcpu, VCPU_REGS_RCX);\n\tkvm_cpuid(vcpu, &eax, &ebx, &ecx, &edx);\n\tkvm_register_write(vcpu, VCPU_REGS_RAX, eax);\n\tkvm_register_write(vcpu, VCPU_REGS_RBX, ebx);\n\tkvm_register_write(vcpu, VCPU_REGS_RCX, ecx);\n\tkvm_register_write(vcpu, VCPU_REGS_RDX, edx);\n\tkvm_x86_ops->skip_emulated_instruction(vcpu);\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"trace.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"cpuid.h\"",
            "#include <asm/fpu/xstate.h>",
            "#include <asm/user.h>",
            "#include <asm/fpu/internal.h> /* For use_eager_fpu.  Ugh! */",
            "#include <linux/uaccess.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"trace.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include <asm/fpu/xstate.h>\n#include <asm/user.h>\n#include <asm/fpu/internal.h> /* For use_eager_fpu.  Ugh! */\n#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n\nvoid kvm_emulate_cpuid(struct kvm_vcpu *vcpu)\n{\n\tu32 function, eax, ebx, ecx, edx;\n\n\tfunction = eax = kvm_register_read(vcpu, VCPU_REGS_RAX);\n\tecx = kvm_register_read(vcpu, VCPU_REGS_RCX);\n\tkvm_cpuid(vcpu, &eax, &ebx, &ecx, &edx);\n\tkvm_register_write(vcpu, VCPU_REGS_RAX, eax);\n\tkvm_register_write(vcpu, VCPU_REGS_RBX, ebx);\n\tkvm_register_write(vcpu, VCPU_REGS_RCX, ecx);\n\tkvm_register_write(vcpu, VCPU_REGS_RDX, edx);\n\tkvm_x86_ops->skip_emulated_instruction(vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_rip_read",
          "args": [
            "&svm->vcpu"
          ],
          "line": 3096
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_rip_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "27-30",
          "snippet": "static inline unsigned long kvm_rip_read(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_register_read(vcpu, VCPU_REGS_RIP);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline unsigned long kvm_rip_read(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_register_read(vcpu, VCPU_REGS_RIP);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic int cpuid_interception(struct vcpu_svm *svm)\n{\n\tsvm->next_rip = kvm_rip_read(&svm->vcpu) + 2;\n\tkvm_emulate_cpuid(&svm->vcpu);\n\treturn 1;\n}"
  },
  {
    "function_name": "task_switch_interception",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "3026-3092",
    "snippet": "static int task_switch_interception(struct vcpu_svm *svm)\n{\n\tu16 tss_selector;\n\tint reason;\n\tint int_type = svm->vmcb->control.exit_int_info &\n\t\tSVM_EXITINTINFO_TYPE_MASK;\n\tint int_vec = svm->vmcb->control.exit_int_info & SVM_EVTINJ_VEC_MASK;\n\tuint32_t type =\n\t\tsvm->vmcb->control.exit_int_info & SVM_EXITINTINFO_TYPE_MASK;\n\tuint32_t idt_v =\n\t\tsvm->vmcb->control.exit_int_info & SVM_EXITINTINFO_VALID;\n\tbool has_error_code = false;\n\tu32 error_code = 0;\n\n\ttss_selector = (u16)svm->vmcb->control.exit_info_1;\n\n\tif (svm->vmcb->control.exit_info_2 &\n\t    (1ULL << SVM_EXITINFOSHIFT_TS_REASON_IRET))\n\t\treason = TASK_SWITCH_IRET;\n\telse if (svm->vmcb->control.exit_info_2 &\n\t\t (1ULL << SVM_EXITINFOSHIFT_TS_REASON_JMP))\n\t\treason = TASK_SWITCH_JMP;\n\telse if (idt_v)\n\t\treason = TASK_SWITCH_GATE;\n\telse\n\t\treason = TASK_SWITCH_CALL;\n\n\tif (reason == TASK_SWITCH_GATE) {\n\t\tswitch (type) {\n\t\tcase SVM_EXITINTINFO_TYPE_NMI:\n\t\t\tsvm->vcpu.arch.nmi_injected = false;\n\t\t\tbreak;\n\t\tcase SVM_EXITINTINFO_TYPE_EXEPT:\n\t\t\tif (svm->vmcb->control.exit_info_2 &\n\t\t\t    (1ULL << SVM_EXITINFOSHIFT_TS_HAS_ERROR_CODE)) {\n\t\t\t\thas_error_code = true;\n\t\t\t\terror_code =\n\t\t\t\t\t(u32)svm->vmcb->control.exit_info_2;\n\t\t\t}\n\t\t\tkvm_clear_exception_queue(&svm->vcpu);\n\t\t\tbreak;\n\t\tcase SVM_EXITINTINFO_TYPE_INTR:\n\t\t\tkvm_clear_interrupt_queue(&svm->vcpu);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (reason != TASK_SWITCH_GATE ||\n\t    int_type == SVM_EXITINTINFO_TYPE_SOFT ||\n\t    (int_type == SVM_EXITINTINFO_TYPE_EXEPT &&\n\t     (int_vec == OF_VECTOR || int_vec == BP_VECTOR)))\n\t\tskip_emulated_instruction(&svm->vcpu);\n\n\tif (int_type != SVM_EXITINTINFO_TYPE_SOFT)\n\t\tint_vec = -1;\n\n\tif (kvm_task_switch(&svm->vcpu, tss_selector, int_vec, reason,\n\t\t\t\thas_error_code, error_code) == EMULATE_FAIL) {\n\t\tsvm->vcpu.run->exit_reason = KVM_EXIT_INTERNAL_ERROR;\n\t\tsvm->vcpu.run->internal.suberror = KVM_INTERNAL_ERROR_EMULATION;\n\t\tsvm->vcpu.run->internal.ndata = 0;\n\t\treturn 0;\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);",
      "static int nested_svm_check_exception(struct vcpu_svm *svm, unsigned nr,\n\t\t\t\t      bool has_error_code, u32 error_code);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_task_switch",
          "args": [
            "&svm->vcpu",
            "tss_selector",
            "int_vec",
            "reason",
            "has_error_code",
            "error_code"
          ],
          "line": 3084
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_task_switch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "7085-7103",
          "snippet": "int kvm_task_switch(struct kvm_vcpu *vcpu, u16 tss_selector, int idt_index,\n\t\t    int reason, bool has_error_code, u32 error_code)\n{\n\tstruct x86_emulate_ctxt *ctxt = &vcpu->arch.emulate_ctxt;\n\tint ret;\n\n\tinit_emulate_ctxt(vcpu);\n\n\tret = emulator_task_switch(ctxt, tss_selector, idt_index, reason,\n\t\t\t\t   has_error_code, error_code);\n\n\tif (ret)\n\t\treturn EMULATE_FAIL;\n\n\tkvm_rip_write(vcpu, ctxt->eip);\n\tkvm_set_rflags(vcpu, ctxt->eflags);\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\treturn EMULATE_DONE;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);\n\nint kvm_task_switch(struct kvm_vcpu *vcpu, u16 tss_selector, int idt_index,\n\t\t    int reason, bool has_error_code, u32 error_code)\n{\n\tstruct x86_emulate_ctxt *ctxt = &vcpu->arch.emulate_ctxt;\n\tint ret;\n\n\tinit_emulate_ctxt(vcpu);\n\n\tret = emulator_task_switch(ctxt, tss_selector, idt_index, reason,\n\t\t\t\t   has_error_code, error_code);\n\n\tif (ret)\n\t\treturn EMULATE_FAIL;\n\n\tkvm_rip_write(vcpu, ctxt->eip);\n\tkvm_set_rflags(vcpu, ctxt->eflags);\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\treturn EMULATE_DONE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "skip_emulated_instruction",
          "args": [
            "&svm->vcpu"
          ],
          "line": 3079
        },
        "resolved": true,
        "details": {
          "function_name": "skip_emulated_instruction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "572-593",
          "snippet": "static void skip_emulated_instruction(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (svm->vmcb->control.next_rip != 0) {\n\t\tWARN_ON_ONCE(!static_cpu_has(X86_FEATURE_NRIPS));\n\t\tsvm->next_rip = svm->vmcb->control.next_rip;\n\t}\n\n\tif (!svm->next_rip) {\n\t\tif (emulate_instruction(vcpu, EMULTYPE_SKIP) !=\n\t\t\t\tEMULATE_DONE)\n\t\t\tprintk(KERN_DEBUG \"%s: NOP\\n\", __func__);\n\t\treturn;\n\t}\n\tif (svm->next_rip - kvm_rip_read(vcpu) > MAX_INST_SIZE)\n\t\tprintk(KERN_ERR \"%s: ip 0x%lx next 0x%llx\\n\",\n\t\t       __func__, kvm_rip_read(vcpu), svm->next_rip);\n\n\tkvm_rip_write(vcpu, svm->next_rip);\n\tsvm_set_interrupt_shadow(vcpu, 0);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define MAX_INST_SIZE 15"
          ],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define MAX_INST_SIZE 15\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic void skip_emulated_instruction(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (svm->vmcb->control.next_rip != 0) {\n\t\tWARN_ON_ONCE(!static_cpu_has(X86_FEATURE_NRIPS));\n\t\tsvm->next_rip = svm->vmcb->control.next_rip;\n\t}\n\n\tif (!svm->next_rip) {\n\t\tif (emulate_instruction(vcpu, EMULTYPE_SKIP) !=\n\t\t\t\tEMULATE_DONE)\n\t\t\tprintk(KERN_DEBUG \"%s: NOP\\n\", __func__);\n\t\treturn;\n\t}\n\tif (svm->next_rip - kvm_rip_read(vcpu) > MAX_INST_SIZE)\n\t\tprintk(KERN_ERR \"%s: ip 0x%lx next 0x%llx\\n\",\n\t\t       __func__, kvm_rip_read(vcpu), svm->next_rip);\n\n\tkvm_rip_write(vcpu, svm->next_rip);\n\tsvm_set_interrupt_shadow(vcpu, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_clear_interrupt_queue",
          "args": [
            "&svm->vcpu"
          ],
          "line": 3068
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_clear_interrupt_queue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.h",
          "lines": "22-25",
          "snippet": "static inline void kvm_clear_interrupt_queue(struct kvm_vcpu *vcpu)\n{\n\tvcpu->arch.interrupt.pending = false;\n}",
          "includes": [
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline void kvm_clear_interrupt_queue(struct kvm_vcpu *vcpu)\n{\n\tvcpu->arch.interrupt.pending = false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_clear_exception_queue",
          "args": [
            "&svm->vcpu"
          ],
          "line": 3065
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_clear_exception_queue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.h",
          "lines": "9-12",
          "snippet": "static inline void kvm_clear_exception_queue(struct kvm_vcpu *vcpu)\n{\n\tvcpu->arch.exception.pending = false;\n}",
          "includes": [
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline void kvm_clear_exception_queue(struct kvm_vcpu *vcpu)\n{\n\tvcpu->arch.exception.pending = false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\nstatic int nested_svm_check_exception(struct vcpu_svm *svm, unsigned nr,\n\t\t\t\t      bool has_error_code, u32 error_code);\n\nstatic int task_switch_interception(struct vcpu_svm *svm)\n{\n\tu16 tss_selector;\n\tint reason;\n\tint int_type = svm->vmcb->control.exit_int_info &\n\t\tSVM_EXITINTINFO_TYPE_MASK;\n\tint int_vec = svm->vmcb->control.exit_int_info & SVM_EVTINJ_VEC_MASK;\n\tuint32_t type =\n\t\tsvm->vmcb->control.exit_int_info & SVM_EXITINTINFO_TYPE_MASK;\n\tuint32_t idt_v =\n\t\tsvm->vmcb->control.exit_int_info & SVM_EXITINTINFO_VALID;\n\tbool has_error_code = false;\n\tu32 error_code = 0;\n\n\ttss_selector = (u16)svm->vmcb->control.exit_info_1;\n\n\tif (svm->vmcb->control.exit_info_2 &\n\t    (1ULL << SVM_EXITINFOSHIFT_TS_REASON_IRET))\n\t\treason = TASK_SWITCH_IRET;\n\telse if (svm->vmcb->control.exit_info_2 &\n\t\t (1ULL << SVM_EXITINFOSHIFT_TS_REASON_JMP))\n\t\treason = TASK_SWITCH_JMP;\n\telse if (idt_v)\n\t\treason = TASK_SWITCH_GATE;\n\telse\n\t\treason = TASK_SWITCH_CALL;\n\n\tif (reason == TASK_SWITCH_GATE) {\n\t\tswitch (type) {\n\t\tcase SVM_EXITINTINFO_TYPE_NMI:\n\t\t\tsvm->vcpu.arch.nmi_injected = false;\n\t\t\tbreak;\n\t\tcase SVM_EXITINTINFO_TYPE_EXEPT:\n\t\t\tif (svm->vmcb->control.exit_info_2 &\n\t\t\t    (1ULL << SVM_EXITINFOSHIFT_TS_HAS_ERROR_CODE)) {\n\t\t\t\thas_error_code = true;\n\t\t\t\terror_code =\n\t\t\t\t\t(u32)svm->vmcb->control.exit_info_2;\n\t\t\t}\n\t\t\tkvm_clear_exception_queue(&svm->vcpu);\n\t\t\tbreak;\n\t\tcase SVM_EXITINTINFO_TYPE_INTR:\n\t\t\tkvm_clear_interrupt_queue(&svm->vcpu);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (reason != TASK_SWITCH_GATE ||\n\t    int_type == SVM_EXITINTINFO_TYPE_SOFT ||\n\t    (int_type == SVM_EXITINTINFO_TYPE_EXEPT &&\n\t     (int_vec == OF_VECTOR || int_vec == BP_VECTOR)))\n\t\tskip_emulated_instruction(&svm->vcpu);\n\n\tif (int_type != SVM_EXITINTINFO_TYPE_SOFT)\n\t\tint_vec = -1;\n\n\tif (kvm_task_switch(&svm->vcpu, tss_selector, int_vec, reason,\n\t\t\t\thas_error_code, error_code) == EMULATE_FAIL) {\n\t\tsvm->vcpu.run->exit_reason = KVM_EXIT_INTERNAL_ERROR;\n\t\tsvm->vcpu.run->internal.suberror = KVM_INTERNAL_ERROR_EMULATION;\n\t\tsvm->vcpu.run->internal.ndata = 0;\n\t\treturn 0;\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "xsetbv_interception",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "3013-3024",
    "snippet": "static int xsetbv_interception(struct vcpu_svm *svm)\n{\n\tu64 new_bv = kvm_read_edx_eax(&svm->vcpu);\n\tu32 index = kvm_register_read(&svm->vcpu, VCPU_REGS_RCX);\n\n\tif (kvm_set_xcr(&svm->vcpu, index, new_bv) == 0) {\n\t\tsvm->next_rip = kvm_rip_read(&svm->vcpu) + 3;\n\t\tskip_emulated_instruction(&svm->vcpu);\n\t}\n\n\treturn 1;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "skip_emulated_instruction",
          "args": [
            "&svm->vcpu"
          ],
          "line": 3020
        },
        "resolved": true,
        "details": {
          "function_name": "skip_emulated_instruction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "572-593",
          "snippet": "static void skip_emulated_instruction(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (svm->vmcb->control.next_rip != 0) {\n\t\tWARN_ON_ONCE(!static_cpu_has(X86_FEATURE_NRIPS));\n\t\tsvm->next_rip = svm->vmcb->control.next_rip;\n\t}\n\n\tif (!svm->next_rip) {\n\t\tif (emulate_instruction(vcpu, EMULTYPE_SKIP) !=\n\t\t\t\tEMULATE_DONE)\n\t\t\tprintk(KERN_DEBUG \"%s: NOP\\n\", __func__);\n\t\treturn;\n\t}\n\tif (svm->next_rip - kvm_rip_read(vcpu) > MAX_INST_SIZE)\n\t\tprintk(KERN_ERR \"%s: ip 0x%lx next 0x%llx\\n\",\n\t\t       __func__, kvm_rip_read(vcpu), svm->next_rip);\n\n\tkvm_rip_write(vcpu, svm->next_rip);\n\tsvm_set_interrupt_shadow(vcpu, 0);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define MAX_INST_SIZE 15"
          ],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define MAX_INST_SIZE 15\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic void skip_emulated_instruction(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (svm->vmcb->control.next_rip != 0) {\n\t\tWARN_ON_ONCE(!static_cpu_has(X86_FEATURE_NRIPS));\n\t\tsvm->next_rip = svm->vmcb->control.next_rip;\n\t}\n\n\tif (!svm->next_rip) {\n\t\tif (emulate_instruction(vcpu, EMULTYPE_SKIP) !=\n\t\t\t\tEMULATE_DONE)\n\t\t\tprintk(KERN_DEBUG \"%s: NOP\\n\", __func__);\n\t\treturn;\n\t}\n\tif (svm->next_rip - kvm_rip_read(vcpu) > MAX_INST_SIZE)\n\t\tprintk(KERN_ERR \"%s: ip 0x%lx next 0x%llx\\n\",\n\t\t       __func__, kvm_rip_read(vcpu), svm->next_rip);\n\n\tkvm_rip_write(vcpu, svm->next_rip);\n\tsvm_set_interrupt_shadow(vcpu, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_rip_read",
          "args": [
            "&svm->vcpu"
          ],
          "line": 3019
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_rip_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "27-30",
          "snippet": "static inline unsigned long kvm_rip_read(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_register_read(vcpu, VCPU_REGS_RIP);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline unsigned long kvm_rip_read(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_register_read(vcpu, VCPU_REGS_RIP);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_set_xcr",
          "args": [
            "&svm->vcpu",
            "index",
            "new_bv"
          ],
          "line": 3018
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_set_xcr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "711-719",
          "snippet": "int kvm_set_xcr(struct kvm_vcpu *vcpu, u32 index, u64 xcr)\n{\n\tif (kvm_x86_ops->get_cpl(vcpu) != 0 ||\n\t    __kvm_set_xcr(vcpu, index, xcr)) {\n\t\tkvm_inject_gp(vcpu, 0);\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "struct kvm_x86_ops *kvm_x86_ops"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nint kvm_set_xcr(struct kvm_vcpu *vcpu, u32 index, u64 xcr)\n{\n\tif (kvm_x86_ops->get_cpl(vcpu) != 0 ||\n\t    __kvm_set_xcr(vcpu, index, xcr)) {\n\t\tkvm_inject_gp(vcpu, 0);\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_register_read",
          "args": [
            "&svm->vcpu",
            "VCPU_REGS_RCX"
          ],
          "line": 3016
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_register_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "9-16",
          "snippet": "static inline unsigned long kvm_register_read(struct kvm_vcpu *vcpu,\n\t\t\t\t\t      enum kvm_reg reg)\n{\n\tif (!test_bit(reg, (unsigned long *)&vcpu->arch.regs_avail))\n\t\tkvm_x86_ops->cache_reg(vcpu, reg);\n\n\treturn vcpu->arch.regs[reg];\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline unsigned long kvm_register_read(struct kvm_vcpu *vcpu,\n\t\t\t\t\t      enum kvm_reg reg)\n{\n\tif (!test_bit(reg, (unsigned long *)&vcpu->arch.regs_avail))\n\t\tkvm_x86_ops->cache_reg(vcpu, reg);\n\n\treturn vcpu->arch.regs[reg];\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_read_edx_eax",
          "args": [
            "&svm->vcpu"
          ],
          "line": 3015
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_read_edx_eax",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "81-85",
          "snippet": "static inline u64 kvm_read_edx_eax(struct kvm_vcpu *vcpu)\n{\n\treturn (kvm_register_read(vcpu, VCPU_REGS_RAX) & -1u)\n\t\t| ((u64)(kvm_register_read(vcpu, VCPU_REGS_RDX) & -1u) << 32);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline u64 kvm_read_edx_eax(struct kvm_vcpu *vcpu)\n{\n\treturn (kvm_register_read(vcpu, VCPU_REGS_RAX) & -1u)\n\t\t| ((u64)(kvm_register_read(vcpu, VCPU_REGS_RDX) & -1u) << 32);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic int xsetbv_interception(struct vcpu_svm *svm)\n{\n\tu64 new_bv = kvm_read_edx_eax(&svm->vcpu);\n\tu32 index = kvm_register_read(&svm->vcpu, VCPU_REGS_RCX);\n\n\tif (kvm_set_xcr(&svm->vcpu, index, new_bv) == 0) {\n\t\tsvm->next_rip = kvm_rip_read(&svm->vcpu) + 3;\n\t\tskip_emulated_instruction(&svm->vcpu);\n\t}\n\n\treturn 1;\n}"
  },
  {
    "function_name": "wbinvd_interception",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "3007-3011",
    "snippet": "static int wbinvd_interception(struct vcpu_svm *svm)\n{\n\tkvm_emulate_wbinvd(&svm->vcpu);\n\treturn 1;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_emulate_wbinvd",
          "args": [
            "&svm->vcpu"
          ],
          "line": 3009
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_emulate_wbinvd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "4742-4746",
          "snippet": "int kvm_emulate_wbinvd(struct kvm_vcpu *vcpu)\n{\n\tkvm_x86_ops->skip_emulated_instruction(vcpu);\n\treturn kvm_emulate_wbinvd_noskip(vcpu);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "struct kvm_x86_ops *kvm_x86_ops"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nint kvm_emulate_wbinvd(struct kvm_vcpu *vcpu)\n{\n\tkvm_x86_ops->skip_emulated_instruction(vcpu);\n\treturn kvm_emulate_wbinvd_noskip(vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic int wbinvd_interception(struct vcpu_svm *svm)\n{\n\tkvm_emulate_wbinvd(&svm->vcpu);\n\treturn 1;\n}"
  },
  {
    "function_name": "skinit_interception",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "2999-3005",
    "snippet": "static int skinit_interception(struct vcpu_svm *svm)\n{\n\ttrace_kvm_skinit(svm->vmcb->save.rip, kvm_register_read(&svm->vcpu, VCPU_REGS_RAX));\n\n\tkvm_queue_exception(&svm->vcpu, UD_VECTOR);\n\treturn 1;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_queue_exception",
          "args": [
            "&svm->vcpu",
            "UD_VECTOR"
          ],
          "line": 3003
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_queue_exception",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "409-412",
          "snippet": "void kvm_queue_exception(struct kvm_vcpu *vcpu, unsigned nr)\n{\n\tkvm_multiple_exception(vcpu, nr, false, 0, false);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nvoid kvm_queue_exception(struct kvm_vcpu *vcpu, unsigned nr)\n{\n\tkvm_multiple_exception(vcpu, nr, false, 0, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_kvm_skinit",
          "args": [
            "svm->vmcb->save.rip",
            "kvm_register_read(&svm->vcpu, VCPU_REGS_RAX)"
          ],
          "line": 3001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_register_read",
          "args": [
            "&svm->vcpu",
            "VCPU_REGS_RAX"
          ],
          "line": 3001
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_register_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "9-16",
          "snippet": "static inline unsigned long kvm_register_read(struct kvm_vcpu *vcpu,\n\t\t\t\t\t      enum kvm_reg reg)\n{\n\tif (!test_bit(reg, (unsigned long *)&vcpu->arch.regs_avail))\n\t\tkvm_x86_ops->cache_reg(vcpu, reg);\n\n\treturn vcpu->arch.regs[reg];\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline unsigned long kvm_register_read(struct kvm_vcpu *vcpu,\n\t\t\t\t\t      enum kvm_reg reg)\n{\n\tif (!test_bit(reg, (unsigned long *)&vcpu->arch.regs_avail))\n\t\tkvm_x86_ops->cache_reg(vcpu, reg);\n\n\treturn vcpu->arch.regs[reg];\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic int skinit_interception(struct vcpu_svm *svm)\n{\n\ttrace_kvm_skinit(svm->vmcb->save.rip, kvm_register_read(&svm->vcpu, VCPU_REGS_RAX));\n\n\tkvm_queue_exception(&svm->vcpu, UD_VECTOR);\n\treturn 1;\n}"
  },
  {
    "function_name": "invlpga_interception",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "2984-2997",
    "snippet": "static int invlpga_interception(struct vcpu_svm *svm)\n{\n\tstruct kvm_vcpu *vcpu = &svm->vcpu;\n\n\ttrace_kvm_invlpga(svm->vmcb->save.rip, kvm_register_read(&svm->vcpu, VCPU_REGS_RCX),\n\t\t\t  kvm_register_read(&svm->vcpu, VCPU_REGS_RAX));\n\n\t/* Let's treat INVLPGA the same as INVLPG (can be optimized!) */\n\tkvm_mmu_invlpg(vcpu, kvm_register_read(&svm->vcpu, VCPU_REGS_RAX));\n\n\tsvm->next_rip = kvm_rip_read(&svm->vcpu) + 3;\n\tskip_emulated_instruction(&svm->vcpu);\n\treturn 1;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "skip_emulated_instruction",
          "args": [
            "&svm->vcpu"
          ],
          "line": 2995
        },
        "resolved": true,
        "details": {
          "function_name": "skip_emulated_instruction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "572-593",
          "snippet": "static void skip_emulated_instruction(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (svm->vmcb->control.next_rip != 0) {\n\t\tWARN_ON_ONCE(!static_cpu_has(X86_FEATURE_NRIPS));\n\t\tsvm->next_rip = svm->vmcb->control.next_rip;\n\t}\n\n\tif (!svm->next_rip) {\n\t\tif (emulate_instruction(vcpu, EMULTYPE_SKIP) !=\n\t\t\t\tEMULATE_DONE)\n\t\t\tprintk(KERN_DEBUG \"%s: NOP\\n\", __func__);\n\t\treturn;\n\t}\n\tif (svm->next_rip - kvm_rip_read(vcpu) > MAX_INST_SIZE)\n\t\tprintk(KERN_ERR \"%s: ip 0x%lx next 0x%llx\\n\",\n\t\t       __func__, kvm_rip_read(vcpu), svm->next_rip);\n\n\tkvm_rip_write(vcpu, svm->next_rip);\n\tsvm_set_interrupt_shadow(vcpu, 0);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define MAX_INST_SIZE 15"
          ],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define MAX_INST_SIZE 15\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic void skip_emulated_instruction(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (svm->vmcb->control.next_rip != 0) {\n\t\tWARN_ON_ONCE(!static_cpu_has(X86_FEATURE_NRIPS));\n\t\tsvm->next_rip = svm->vmcb->control.next_rip;\n\t}\n\n\tif (!svm->next_rip) {\n\t\tif (emulate_instruction(vcpu, EMULTYPE_SKIP) !=\n\t\t\t\tEMULATE_DONE)\n\t\t\tprintk(KERN_DEBUG \"%s: NOP\\n\", __func__);\n\t\treturn;\n\t}\n\tif (svm->next_rip - kvm_rip_read(vcpu) > MAX_INST_SIZE)\n\t\tprintk(KERN_ERR \"%s: ip 0x%lx next 0x%llx\\n\",\n\t\t       __func__, kvm_rip_read(vcpu), svm->next_rip);\n\n\tkvm_rip_write(vcpu, svm->next_rip);\n\tsvm_set_interrupt_shadow(vcpu, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_rip_read",
          "args": [
            "&svm->vcpu"
          ],
          "line": 2994
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_rip_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "27-30",
          "snippet": "static inline unsigned long kvm_rip_read(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_register_read(vcpu, VCPU_REGS_RIP);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline unsigned long kvm_rip_read(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_register_read(vcpu, VCPU_REGS_RIP);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_mmu_invlpg",
          "args": [
            "vcpu",
            "kvm_register_read(&svm->vcpu, VCPU_REGS_RAX)"
          ],
          "line": 2992
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_invlpg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "4548-4553",
          "snippet": "void kvm_mmu_invlpg(struct kvm_vcpu *vcpu, gva_t gva)\n{\n\tvcpu->arch.mmu.invlpg(vcpu, gva);\n\tkvm_make_request(KVM_REQ_TLB_FLUSH, vcpu);\n\t++vcpu->stat.invlpg;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nvoid kvm_mmu_invlpg(struct kvm_vcpu *vcpu, gva_t gva)\n{\n\tvcpu->arch.mmu.invlpg(vcpu, gva);\n\tkvm_make_request(KVM_REQ_TLB_FLUSH, vcpu);\n\t++vcpu->stat.invlpg;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_register_read",
          "args": [
            "&svm->vcpu",
            "VCPU_REGS_RAX"
          ],
          "line": 2992
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_register_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "9-16",
          "snippet": "static inline unsigned long kvm_register_read(struct kvm_vcpu *vcpu,\n\t\t\t\t\t      enum kvm_reg reg)\n{\n\tif (!test_bit(reg, (unsigned long *)&vcpu->arch.regs_avail))\n\t\tkvm_x86_ops->cache_reg(vcpu, reg);\n\n\treturn vcpu->arch.regs[reg];\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline unsigned long kvm_register_read(struct kvm_vcpu *vcpu,\n\t\t\t\t\t      enum kvm_reg reg)\n{\n\tif (!test_bit(reg, (unsigned long *)&vcpu->arch.regs_avail))\n\t\tkvm_x86_ops->cache_reg(vcpu, reg);\n\n\treturn vcpu->arch.regs[reg];\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_kvm_invlpga",
          "args": [
            "svm->vmcb->save.rip",
            "kvm_register_read(&svm->vcpu, VCPU_REGS_RCX)",
            "kvm_register_read(&svm->vcpu, VCPU_REGS_RAX)"
          ],
          "line": 2988
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic int invlpga_interception(struct vcpu_svm *svm)\n{\n\tstruct kvm_vcpu *vcpu = &svm->vcpu;\n\n\ttrace_kvm_invlpga(svm->vmcb->save.rip, kvm_register_read(&svm->vcpu, VCPU_REGS_RCX),\n\t\t\t  kvm_register_read(&svm->vcpu, VCPU_REGS_RAX));\n\n\t/* Let's treat INVLPGA the same as INVLPG (can be optimized!) */\n\tkvm_mmu_invlpg(vcpu, kvm_register_read(&svm->vcpu, VCPU_REGS_RAX));\n\n\tsvm->next_rip = kvm_rip_read(&svm->vcpu) + 3;\n\tskip_emulated_instruction(&svm->vcpu);\n\treturn 1;\n}"
  },
  {
    "function_name": "clgi_interception",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "2964-2982",
    "snippet": "static int clgi_interception(struct vcpu_svm *svm)\n{\n\tif (nested_svm_check_permissions(svm))\n\t\treturn 1;\n\n\tsvm->next_rip = kvm_rip_read(&svm->vcpu) + 3;\n\tskip_emulated_instruction(&svm->vcpu);\n\n\tdisable_gif(svm);\n\n\t/* After a CLGI no interrupts should come */\n\tif (!kvm_vcpu_apicv_active(&svm->vcpu)) {\n\t\tsvm_clear_vintr(svm);\n\t\tsvm->vmcb->control.int_ctl &= ~V_IRQ_MASK;\n\t\tmark_dirty(svm->vmcb, VMCB_INTR);\n\t}\n\n\treturn 1;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_dirty",
          "args": [
            "svm->vmcb",
            "VMCB_INTR"
          ],
          "line": 2978
        },
        "resolved": true,
        "details": {
          "function_name": "mark_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "289-292",
          "snippet": "static inline void mark_dirty(struct vmcb *vmcb, int bit)\n{\n\tvmcb->control.clean &= ~(1 << bit);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic inline void mark_dirty(struct vmcb *vmcb, int bit)\n{\n\tvmcb->control.clean &= ~(1 << bit);\n}"
        }
      },
      {
        "call_info": {
          "callee": "svm_clear_vintr",
          "args": [
            "svm"
          ],
          "line": 2976
        },
        "resolved": true,
        "details": {
          "function_name": "svm_clear_vintr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "1604-1607",
          "snippet": "static void svm_clear_vintr(struct vcpu_svm *svm)\n{\n\tclr_intercept(svm, INTERCEPT_VINTR);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic void svm_clear_vintr(struct vcpu_svm *svm)\n{\n\tclr_intercept(svm, INTERCEPT_VINTR);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_apicv_active",
          "args": [
            "&svm->vcpu"
          ],
          "line": 2975
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_vcpu_apicv_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.h",
          "lines": "181-184",
          "snippet": "static inline bool kvm_vcpu_apicv_active(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.apic && vcpu->arch.apicv_active;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline bool kvm_vcpu_apicv_active(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.apic && vcpu->arch.apicv_active;\n}"
        }
      },
      {
        "call_info": {
          "callee": "disable_gif",
          "args": [
            "svm"
          ],
          "line": 2972
        },
        "resolved": true,
        "details": {
          "function_name": "disable_gif",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "443-446",
          "snippet": "static inline void disable_gif(struct vcpu_svm *svm)\n{\n\tsvm->vcpu.arch.hflags &= ~HF_GIF_MASK;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic inline void disable_gif(struct vcpu_svm *svm)\n{\n\tsvm->vcpu.arch.hflags &= ~HF_GIF_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "skip_emulated_instruction",
          "args": [
            "&svm->vcpu"
          ],
          "line": 2970
        },
        "resolved": true,
        "details": {
          "function_name": "skip_emulated_instruction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "572-593",
          "snippet": "static void skip_emulated_instruction(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (svm->vmcb->control.next_rip != 0) {\n\t\tWARN_ON_ONCE(!static_cpu_has(X86_FEATURE_NRIPS));\n\t\tsvm->next_rip = svm->vmcb->control.next_rip;\n\t}\n\n\tif (!svm->next_rip) {\n\t\tif (emulate_instruction(vcpu, EMULTYPE_SKIP) !=\n\t\t\t\tEMULATE_DONE)\n\t\t\tprintk(KERN_DEBUG \"%s: NOP\\n\", __func__);\n\t\treturn;\n\t}\n\tif (svm->next_rip - kvm_rip_read(vcpu) > MAX_INST_SIZE)\n\t\tprintk(KERN_ERR \"%s: ip 0x%lx next 0x%llx\\n\",\n\t\t       __func__, kvm_rip_read(vcpu), svm->next_rip);\n\n\tkvm_rip_write(vcpu, svm->next_rip);\n\tsvm_set_interrupt_shadow(vcpu, 0);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define MAX_INST_SIZE 15"
          ],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define MAX_INST_SIZE 15\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic void skip_emulated_instruction(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (svm->vmcb->control.next_rip != 0) {\n\t\tWARN_ON_ONCE(!static_cpu_has(X86_FEATURE_NRIPS));\n\t\tsvm->next_rip = svm->vmcb->control.next_rip;\n\t}\n\n\tif (!svm->next_rip) {\n\t\tif (emulate_instruction(vcpu, EMULTYPE_SKIP) !=\n\t\t\t\tEMULATE_DONE)\n\t\t\tprintk(KERN_DEBUG \"%s: NOP\\n\", __func__);\n\t\treturn;\n\t}\n\tif (svm->next_rip - kvm_rip_read(vcpu) > MAX_INST_SIZE)\n\t\tprintk(KERN_ERR \"%s: ip 0x%lx next 0x%llx\\n\",\n\t\t       __func__, kvm_rip_read(vcpu), svm->next_rip);\n\n\tkvm_rip_write(vcpu, svm->next_rip);\n\tsvm_set_interrupt_shadow(vcpu, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_rip_read",
          "args": [
            "&svm->vcpu"
          ],
          "line": 2969
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_rip_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "27-30",
          "snippet": "static inline unsigned long kvm_rip_read(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_register_read(vcpu, VCPU_REGS_RIP);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline unsigned long kvm_rip_read(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_register_read(vcpu, VCPU_REGS_RIP);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nested_svm_check_permissions",
          "args": [
            "svm"
          ],
          "line": 2966
        },
        "resolved": true,
        "details": {
          "function_name": "nested_svm_check_permissions",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "2246-2260",
          "snippet": "static int nested_svm_check_permissions(struct vcpu_svm *svm)\n{\n\tif (!(svm->vcpu.arch.efer & EFER_SVME)\n\t    || !is_paging(&svm->vcpu)) {\n\t\tkvm_queue_exception(&svm->vcpu, UD_VECTOR);\n\t\treturn 1;\n\t}\n\n\tif (svm->vmcb->save.cpl) {\n\t\tkvm_inject_gp(&svm->vcpu, 0);\n\t\treturn 1;\n\t}\n\n       return 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic int nested_svm_check_permissions(struct vcpu_svm *svm)\n{\n\tif (!(svm->vcpu.arch.efer & EFER_SVME)\n\t    || !is_paging(&svm->vcpu)) {\n\t\tkvm_queue_exception(&svm->vcpu, UD_VECTOR);\n\t\treturn 1;\n\t}\n\n\tif (svm->vmcb->save.cpl) {\n\t\tkvm_inject_gp(&svm->vcpu, 0);\n\t\treturn 1;\n\t}\n\n       return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic int clgi_interception(struct vcpu_svm *svm)\n{\n\tif (nested_svm_check_permissions(svm))\n\t\treturn 1;\n\n\tsvm->next_rip = kvm_rip_read(&svm->vcpu) + 3;\n\tskip_emulated_instruction(&svm->vcpu);\n\n\tdisable_gif(svm);\n\n\t/* After a CLGI no interrupts should come */\n\tif (!kvm_vcpu_apicv_active(&svm->vcpu)) {\n\t\tsvm_clear_vintr(svm);\n\t\tsvm->vmcb->control.int_ctl &= ~V_IRQ_MASK;\n\t\tmark_dirty(svm->vmcb, VMCB_INTR);\n\t}\n\n\treturn 1;\n}"
  },
  {
    "function_name": "stgi_interception",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "2950-2962",
    "snippet": "static int stgi_interception(struct vcpu_svm *svm)\n{\n\tif (nested_svm_check_permissions(svm))\n\t\treturn 1;\n\n\tsvm->next_rip = kvm_rip_read(&svm->vcpu) + 3;\n\tskip_emulated_instruction(&svm->vcpu);\n\tkvm_make_request(KVM_REQ_EVENT, &svm->vcpu);\n\n\tenable_gif(svm);\n\n\treturn 1;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "enable_gif",
          "args": [
            "svm"
          ],
          "line": 2959
        },
        "resolved": true,
        "details": {
          "function_name": "enable_gif",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "438-441",
          "snippet": "static inline void enable_gif(struct vcpu_svm *svm)\n{\n\tsvm->vcpu.arch.hflags |= HF_GIF_MASK;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic inline void enable_gif(struct vcpu_svm *svm)\n{\n\tsvm->vcpu.arch.hflags |= HF_GIF_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_make_request",
          "args": [
            "KVM_REQ_EVENT",
            "&svm->vcpu"
          ],
          "line": 2957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "skip_emulated_instruction",
          "args": [
            "&svm->vcpu"
          ],
          "line": 2956
        },
        "resolved": true,
        "details": {
          "function_name": "skip_emulated_instruction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "572-593",
          "snippet": "static void skip_emulated_instruction(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (svm->vmcb->control.next_rip != 0) {\n\t\tWARN_ON_ONCE(!static_cpu_has(X86_FEATURE_NRIPS));\n\t\tsvm->next_rip = svm->vmcb->control.next_rip;\n\t}\n\n\tif (!svm->next_rip) {\n\t\tif (emulate_instruction(vcpu, EMULTYPE_SKIP) !=\n\t\t\t\tEMULATE_DONE)\n\t\t\tprintk(KERN_DEBUG \"%s: NOP\\n\", __func__);\n\t\treturn;\n\t}\n\tif (svm->next_rip - kvm_rip_read(vcpu) > MAX_INST_SIZE)\n\t\tprintk(KERN_ERR \"%s: ip 0x%lx next 0x%llx\\n\",\n\t\t       __func__, kvm_rip_read(vcpu), svm->next_rip);\n\n\tkvm_rip_write(vcpu, svm->next_rip);\n\tsvm_set_interrupt_shadow(vcpu, 0);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define MAX_INST_SIZE 15"
          ],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define MAX_INST_SIZE 15\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic void skip_emulated_instruction(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (svm->vmcb->control.next_rip != 0) {\n\t\tWARN_ON_ONCE(!static_cpu_has(X86_FEATURE_NRIPS));\n\t\tsvm->next_rip = svm->vmcb->control.next_rip;\n\t}\n\n\tif (!svm->next_rip) {\n\t\tif (emulate_instruction(vcpu, EMULTYPE_SKIP) !=\n\t\t\t\tEMULATE_DONE)\n\t\t\tprintk(KERN_DEBUG \"%s: NOP\\n\", __func__);\n\t\treturn;\n\t}\n\tif (svm->next_rip - kvm_rip_read(vcpu) > MAX_INST_SIZE)\n\t\tprintk(KERN_ERR \"%s: ip 0x%lx next 0x%llx\\n\",\n\t\t       __func__, kvm_rip_read(vcpu), svm->next_rip);\n\n\tkvm_rip_write(vcpu, svm->next_rip);\n\tsvm_set_interrupt_shadow(vcpu, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_rip_read",
          "args": [
            "&svm->vcpu"
          ],
          "line": 2955
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_rip_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "27-30",
          "snippet": "static inline unsigned long kvm_rip_read(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_register_read(vcpu, VCPU_REGS_RIP);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline unsigned long kvm_rip_read(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_register_read(vcpu, VCPU_REGS_RIP);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nested_svm_check_permissions",
          "args": [
            "svm"
          ],
          "line": 2952
        },
        "resolved": true,
        "details": {
          "function_name": "nested_svm_check_permissions",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "2246-2260",
          "snippet": "static int nested_svm_check_permissions(struct vcpu_svm *svm)\n{\n\tif (!(svm->vcpu.arch.efer & EFER_SVME)\n\t    || !is_paging(&svm->vcpu)) {\n\t\tkvm_queue_exception(&svm->vcpu, UD_VECTOR);\n\t\treturn 1;\n\t}\n\n\tif (svm->vmcb->save.cpl) {\n\t\tkvm_inject_gp(&svm->vcpu, 0);\n\t\treturn 1;\n\t}\n\n       return 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic int nested_svm_check_permissions(struct vcpu_svm *svm)\n{\n\tif (!(svm->vcpu.arch.efer & EFER_SVME)\n\t    || !is_paging(&svm->vcpu)) {\n\t\tkvm_queue_exception(&svm->vcpu, UD_VECTOR);\n\t\treturn 1;\n\t}\n\n\tif (svm->vmcb->save.cpl) {\n\t\tkvm_inject_gp(&svm->vcpu, 0);\n\t\treturn 1;\n\t}\n\n       return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic int stgi_interception(struct vcpu_svm *svm)\n{\n\tif (nested_svm_check_permissions(svm))\n\t\treturn 1;\n\n\tsvm->next_rip = kvm_rip_read(&svm->vcpu) + 3;\n\tskip_emulated_instruction(&svm->vcpu);\n\tkvm_make_request(KVM_REQ_EVENT, &svm->vcpu);\n\n\tenable_gif(svm);\n\n\treturn 1;\n}"
  },
  {
    "function_name": "vmrun_interception",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "2922-2948",
    "snippet": "static int vmrun_interception(struct vcpu_svm *svm)\n{\n\tif (nested_svm_check_permissions(svm))\n\t\treturn 1;\n\n\t/* Save rip after vmrun instruction */\n\tkvm_rip_write(&svm->vcpu, kvm_rip_read(&svm->vcpu) + 3);\n\n\tif (!nested_svm_vmrun(svm))\n\t\treturn 1;\n\n\tif (!nested_svm_vmrun_msrpm(svm))\n\t\tgoto failed;\n\n\treturn 1;\n\nfailed:\n\n\tsvm->vmcb->control.exit_code    = SVM_EXIT_ERR;\n\tsvm->vmcb->control.exit_code_hi = 0;\n\tsvm->vmcb->control.exit_info_1  = 0;\n\tsvm->vmcb->control.exit_info_2  = 0;\n\n\tnested_svm_vmexit(svm);\n\n\treturn 1;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nested_svm_vmexit",
          "args": [
            "svm"
          ],
          "line": 2945
        },
        "resolved": true,
        "details": {
          "function_name": "nested_svm_vmexit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "2534-2655",
          "snippet": "static int nested_svm_vmexit(struct vcpu_svm *svm)\n{\n\tstruct vmcb *nested_vmcb;\n\tstruct vmcb *hsave = svm->nested.hsave;\n\tstruct vmcb *vmcb = svm->vmcb;\n\tstruct page *page;\n\n\ttrace_kvm_nested_vmexit_inject(vmcb->control.exit_code,\n\t\t\t\t       vmcb->control.exit_info_1,\n\t\t\t\t       vmcb->control.exit_info_2,\n\t\t\t\t       vmcb->control.exit_int_info,\n\t\t\t\t       vmcb->control.exit_int_info_err,\n\t\t\t\t       KVM_ISA_SVM);\n\n\tnested_vmcb = nested_svm_map(svm, svm->nested.vmcb, &page);\n\tif (!nested_vmcb)\n\t\treturn 1;\n\n\t/* Exit Guest-Mode */\n\tleave_guest_mode(&svm->vcpu);\n\tsvm->nested.vmcb = 0;\n\n\t/* Give the current vmcb to the guest */\n\tdisable_gif(svm);\n\n\tnested_vmcb->save.es     = vmcb->save.es;\n\tnested_vmcb->save.cs     = vmcb->save.cs;\n\tnested_vmcb->save.ss     = vmcb->save.ss;\n\tnested_vmcb->save.ds     = vmcb->save.ds;\n\tnested_vmcb->save.gdtr   = vmcb->save.gdtr;\n\tnested_vmcb->save.idtr   = vmcb->save.idtr;\n\tnested_vmcb->save.efer   = svm->vcpu.arch.efer;\n\tnested_vmcb->save.cr0    = kvm_read_cr0(&svm->vcpu);\n\tnested_vmcb->save.cr3    = kvm_read_cr3(&svm->vcpu);\n\tnested_vmcb->save.cr2    = vmcb->save.cr2;\n\tnested_vmcb->save.cr4    = svm->vcpu.arch.cr4;\n\tnested_vmcb->save.rflags = kvm_get_rflags(&svm->vcpu);\n\tnested_vmcb->save.rip    = vmcb->save.rip;\n\tnested_vmcb->save.rsp    = vmcb->save.rsp;\n\tnested_vmcb->save.rax    = vmcb->save.rax;\n\tnested_vmcb->save.dr7    = vmcb->save.dr7;\n\tnested_vmcb->save.dr6    = vmcb->save.dr6;\n\tnested_vmcb->save.cpl    = vmcb->save.cpl;\n\n\tnested_vmcb->control.int_ctl           = vmcb->control.int_ctl;\n\tnested_vmcb->control.int_vector        = vmcb->control.int_vector;\n\tnested_vmcb->control.int_state         = vmcb->control.int_state;\n\tnested_vmcb->control.exit_code         = vmcb->control.exit_code;\n\tnested_vmcb->control.exit_code_hi      = vmcb->control.exit_code_hi;\n\tnested_vmcb->control.exit_info_1       = vmcb->control.exit_info_1;\n\tnested_vmcb->control.exit_info_2       = vmcb->control.exit_info_2;\n\tnested_vmcb->control.exit_int_info     = vmcb->control.exit_int_info;\n\tnested_vmcb->control.exit_int_info_err = vmcb->control.exit_int_info_err;\n\n\tif (svm->nrips_enabled)\n\t\tnested_vmcb->control.next_rip  = vmcb->control.next_rip;\n\n\t/*\n\t * If we emulate a VMRUN/#VMEXIT in the same host #vmexit cycle we have\n\t * to make sure that we do not lose injected events. So check event_inj\n\t * here and copy it to exit_int_info if it is valid.\n\t * Exit_int_info and event_inj can't be both valid because the case\n\t * below only happens on a VMRUN instruction intercept which has\n\t * no valid exit_int_info set.\n\t */\n\tif (vmcb->control.event_inj & SVM_EVTINJ_VALID) {\n\t\tstruct vmcb_control_area *nc = &nested_vmcb->control;\n\n\t\tnc->exit_int_info     = vmcb->control.event_inj;\n\t\tnc->exit_int_info_err = vmcb->control.event_inj_err;\n\t}\n\n\tnested_vmcb->control.tlb_ctl           = 0;\n\tnested_vmcb->control.event_inj         = 0;\n\tnested_vmcb->control.event_inj_err     = 0;\n\n\t/* We always set V_INTR_MASKING and remember the old value in hflags */\n\tif (!(svm->vcpu.arch.hflags & HF_VINTR_MASK))\n\t\tnested_vmcb->control.int_ctl &= ~V_INTR_MASKING_MASK;\n\n\t/* Restore the original control entries */\n\tcopy_vmcb_control_area(vmcb, hsave);\n\n\tkvm_clear_exception_queue(&svm->vcpu);\n\tkvm_clear_interrupt_queue(&svm->vcpu);\n\n\tsvm->nested.nested_cr3 = 0;\n\n\t/* Restore selected save entries */\n\tsvm->vmcb->save.es = hsave->save.es;\n\tsvm->vmcb->save.cs = hsave->save.cs;\n\tsvm->vmcb->save.ss = hsave->save.ss;\n\tsvm->vmcb->save.ds = hsave->save.ds;\n\tsvm->vmcb->save.gdtr = hsave->save.gdtr;\n\tsvm->vmcb->save.idtr = hsave->save.idtr;\n\tkvm_set_rflags(&svm->vcpu, hsave->save.rflags);\n\tsvm_set_efer(&svm->vcpu, hsave->save.efer);\n\tsvm_set_cr0(&svm->vcpu, hsave->save.cr0 | X86_CR0_PE);\n\tsvm_set_cr4(&svm->vcpu, hsave->save.cr4);\n\tif (npt_enabled) {\n\t\tsvm->vmcb->save.cr3 = hsave->save.cr3;\n\t\tsvm->vcpu.arch.cr3 = hsave->save.cr3;\n\t} else {\n\t\t(void)kvm_set_cr3(&svm->vcpu, hsave->save.cr3);\n\t}\n\tkvm_register_write(&svm->vcpu, VCPU_REGS_RAX, hsave->save.rax);\n\tkvm_register_write(&svm->vcpu, VCPU_REGS_RSP, hsave->save.rsp);\n\tkvm_register_write(&svm->vcpu, VCPU_REGS_RIP, hsave->save.rip);\n\tsvm->vmcb->save.dr7 = 0;\n\tsvm->vmcb->save.cpl = 0;\n\tsvm->vmcb->control.exit_int_info = 0;\n\n\tmark_all_dirty(svm->vmcb);\n\n\tnested_svm_unmap(page);\n\n\tnested_svm_uninit_mmu_context(&svm->vcpu);\n\tkvm_mmu_reset_context(&svm->vcpu);\n\tkvm_mmu_load(&svm->vcpu);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nested = true;",
            "static void svm_set_cr0(struct kvm_vcpu *vcpu, unsigned long cr0);",
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int nested = true;\nstatic void svm_set_cr0(struct kvm_vcpu *vcpu, unsigned long cr0);\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic int nested_svm_vmexit(struct vcpu_svm *svm)\n{\n\tstruct vmcb *nested_vmcb;\n\tstruct vmcb *hsave = svm->nested.hsave;\n\tstruct vmcb *vmcb = svm->vmcb;\n\tstruct page *page;\n\n\ttrace_kvm_nested_vmexit_inject(vmcb->control.exit_code,\n\t\t\t\t       vmcb->control.exit_info_1,\n\t\t\t\t       vmcb->control.exit_info_2,\n\t\t\t\t       vmcb->control.exit_int_info,\n\t\t\t\t       vmcb->control.exit_int_info_err,\n\t\t\t\t       KVM_ISA_SVM);\n\n\tnested_vmcb = nested_svm_map(svm, svm->nested.vmcb, &page);\n\tif (!nested_vmcb)\n\t\treturn 1;\n\n\t/* Exit Guest-Mode */\n\tleave_guest_mode(&svm->vcpu);\n\tsvm->nested.vmcb = 0;\n\n\t/* Give the current vmcb to the guest */\n\tdisable_gif(svm);\n\n\tnested_vmcb->save.es     = vmcb->save.es;\n\tnested_vmcb->save.cs     = vmcb->save.cs;\n\tnested_vmcb->save.ss     = vmcb->save.ss;\n\tnested_vmcb->save.ds     = vmcb->save.ds;\n\tnested_vmcb->save.gdtr   = vmcb->save.gdtr;\n\tnested_vmcb->save.idtr   = vmcb->save.idtr;\n\tnested_vmcb->save.efer   = svm->vcpu.arch.efer;\n\tnested_vmcb->save.cr0    = kvm_read_cr0(&svm->vcpu);\n\tnested_vmcb->save.cr3    = kvm_read_cr3(&svm->vcpu);\n\tnested_vmcb->save.cr2    = vmcb->save.cr2;\n\tnested_vmcb->save.cr4    = svm->vcpu.arch.cr4;\n\tnested_vmcb->save.rflags = kvm_get_rflags(&svm->vcpu);\n\tnested_vmcb->save.rip    = vmcb->save.rip;\n\tnested_vmcb->save.rsp    = vmcb->save.rsp;\n\tnested_vmcb->save.rax    = vmcb->save.rax;\n\tnested_vmcb->save.dr7    = vmcb->save.dr7;\n\tnested_vmcb->save.dr6    = vmcb->save.dr6;\n\tnested_vmcb->save.cpl    = vmcb->save.cpl;\n\n\tnested_vmcb->control.int_ctl           = vmcb->control.int_ctl;\n\tnested_vmcb->control.int_vector        = vmcb->control.int_vector;\n\tnested_vmcb->control.int_state         = vmcb->control.int_state;\n\tnested_vmcb->control.exit_code         = vmcb->control.exit_code;\n\tnested_vmcb->control.exit_code_hi      = vmcb->control.exit_code_hi;\n\tnested_vmcb->control.exit_info_1       = vmcb->control.exit_info_1;\n\tnested_vmcb->control.exit_info_2       = vmcb->control.exit_info_2;\n\tnested_vmcb->control.exit_int_info     = vmcb->control.exit_int_info;\n\tnested_vmcb->control.exit_int_info_err = vmcb->control.exit_int_info_err;\n\n\tif (svm->nrips_enabled)\n\t\tnested_vmcb->control.next_rip  = vmcb->control.next_rip;\n\n\t/*\n\t * If we emulate a VMRUN/#VMEXIT in the same host #vmexit cycle we have\n\t * to make sure that we do not lose injected events. So check event_inj\n\t * here and copy it to exit_int_info if it is valid.\n\t * Exit_int_info and event_inj can't be both valid because the case\n\t * below only happens on a VMRUN instruction intercept which has\n\t * no valid exit_int_info set.\n\t */\n\tif (vmcb->control.event_inj & SVM_EVTINJ_VALID) {\n\t\tstruct vmcb_control_area *nc = &nested_vmcb->control;\n\n\t\tnc->exit_int_info     = vmcb->control.event_inj;\n\t\tnc->exit_int_info_err = vmcb->control.event_inj_err;\n\t}\n\n\tnested_vmcb->control.tlb_ctl           = 0;\n\tnested_vmcb->control.event_inj         = 0;\n\tnested_vmcb->control.event_inj_err     = 0;\n\n\t/* We always set V_INTR_MASKING and remember the old value in hflags */\n\tif (!(svm->vcpu.arch.hflags & HF_VINTR_MASK))\n\t\tnested_vmcb->control.int_ctl &= ~V_INTR_MASKING_MASK;\n\n\t/* Restore the original control entries */\n\tcopy_vmcb_control_area(vmcb, hsave);\n\n\tkvm_clear_exception_queue(&svm->vcpu);\n\tkvm_clear_interrupt_queue(&svm->vcpu);\n\n\tsvm->nested.nested_cr3 = 0;\n\n\t/* Restore selected save entries */\n\tsvm->vmcb->save.es = hsave->save.es;\n\tsvm->vmcb->save.cs = hsave->save.cs;\n\tsvm->vmcb->save.ss = hsave->save.ss;\n\tsvm->vmcb->save.ds = hsave->save.ds;\n\tsvm->vmcb->save.gdtr = hsave->save.gdtr;\n\tsvm->vmcb->save.idtr = hsave->save.idtr;\n\tkvm_set_rflags(&svm->vcpu, hsave->save.rflags);\n\tsvm_set_efer(&svm->vcpu, hsave->save.efer);\n\tsvm_set_cr0(&svm->vcpu, hsave->save.cr0 | X86_CR0_PE);\n\tsvm_set_cr4(&svm->vcpu, hsave->save.cr4);\n\tif (npt_enabled) {\n\t\tsvm->vmcb->save.cr3 = hsave->save.cr3;\n\t\tsvm->vcpu.arch.cr3 = hsave->save.cr3;\n\t} else {\n\t\t(void)kvm_set_cr3(&svm->vcpu, hsave->save.cr3);\n\t}\n\tkvm_register_write(&svm->vcpu, VCPU_REGS_RAX, hsave->save.rax);\n\tkvm_register_write(&svm->vcpu, VCPU_REGS_RSP, hsave->save.rsp);\n\tkvm_register_write(&svm->vcpu, VCPU_REGS_RIP, hsave->save.rip);\n\tsvm->vmcb->save.dr7 = 0;\n\tsvm->vmcb->save.cpl = 0;\n\tsvm->vmcb->control.exit_int_info = 0;\n\n\tmark_all_dirty(svm->vmcb);\n\n\tnested_svm_unmap(page);\n\n\tnested_svm_uninit_mmu_context(&svm->vcpu);\n\tkvm_mmu_reset_context(&svm->vcpu);\n\tkvm_mmu_load(&svm->vcpu);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nested_svm_vmrun_msrpm",
          "args": [
            "svm"
          ],
          "line": 2933
        },
        "resolved": true,
        "details": {
          "function_name": "nested_svm_vmrun_msrpm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "2657-2688",
          "snippet": "static bool nested_svm_vmrun_msrpm(struct vcpu_svm *svm)\n{\n\t/*\n\t * This function merges the msr permission bitmaps of kvm and the\n\t * nested vmcb. It is optimized in that it only merges the parts where\n\t * the kvm msr permission bitmap may contain zero bits\n\t */\n\tint i;\n\n\tif (!(svm->nested.intercept & (1ULL << INTERCEPT_MSR_PROT)))\n\t\treturn true;\n\n\tfor (i = 0; i < MSRPM_OFFSETS; i++) {\n\t\tu32 value, p;\n\t\tu64 offset;\n\n\t\tif (msrpm_offsets[i] == 0xffffffff)\n\t\t\tbreak;\n\n\t\tp      = msrpm_offsets[i];\n\t\toffset = svm->nested.vmcb_msrpm + (p * 4);\n\n\t\tif (kvm_vcpu_read_guest(&svm->vcpu, offset, &value, 4))\n\t\t\treturn false;\n\n\t\tsvm->nested.msrpm[p] = svm->msrpm[p] | value;\n\t}\n\n\tsvm->vmcb->control.msrpm_base_pa = __pa(svm->nested.msrpm);\n\n\treturn true;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define MSRPM_OFFSETS\t16"
          ],
          "globals_used": [
            "static u32 msrpm_offsets[MSRPM_OFFSETS]",
            "static int nested = true;",
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define MSRPM_OFFSETS\t16\n\nstatic u32 msrpm_offsets[MSRPM_OFFSETS];\nstatic int nested = true;\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic bool nested_svm_vmrun_msrpm(struct vcpu_svm *svm)\n{\n\t/*\n\t * This function merges the msr permission bitmaps of kvm and the\n\t * nested vmcb. It is optimized in that it only merges the parts where\n\t * the kvm msr permission bitmap may contain zero bits\n\t */\n\tint i;\n\n\tif (!(svm->nested.intercept & (1ULL << INTERCEPT_MSR_PROT)))\n\t\treturn true;\n\n\tfor (i = 0; i < MSRPM_OFFSETS; i++) {\n\t\tu32 value, p;\n\t\tu64 offset;\n\n\t\tif (msrpm_offsets[i] == 0xffffffff)\n\t\t\tbreak;\n\n\t\tp      = msrpm_offsets[i];\n\t\toffset = svm->nested.vmcb_msrpm + (p * 4);\n\n\t\tif (kvm_vcpu_read_guest(&svm->vcpu, offset, &value, 4))\n\t\t\treturn false;\n\n\t\tsvm->nested.msrpm[p] = svm->msrpm[p] | value;\n\t}\n\n\tsvm->vmcb->control.msrpm_base_pa = __pa(svm->nested.msrpm);\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nested_svm_vmrun",
          "args": [
            "svm"
          ],
          "line": 2930
        },
        "resolved": true,
        "details": {
          "function_name": "nested_svm_vmrun",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "2704-2862",
          "snippet": "static bool nested_svm_vmrun(struct vcpu_svm *svm)\n{\n\tstruct vmcb *nested_vmcb;\n\tstruct vmcb *hsave = svm->nested.hsave;\n\tstruct vmcb *vmcb = svm->vmcb;\n\tstruct page *page;\n\tu64 vmcb_gpa;\n\n\tvmcb_gpa = svm->vmcb->save.rax;\n\n\tnested_vmcb = nested_svm_map(svm, svm->vmcb->save.rax, &page);\n\tif (!nested_vmcb)\n\t\treturn false;\n\n\tif (!nested_vmcb_checks(nested_vmcb)) {\n\t\tnested_vmcb->control.exit_code    = SVM_EXIT_ERR;\n\t\tnested_vmcb->control.exit_code_hi = 0;\n\t\tnested_vmcb->control.exit_info_1  = 0;\n\t\tnested_vmcb->control.exit_info_2  = 0;\n\n\t\tnested_svm_unmap(page);\n\n\t\treturn false;\n\t}\n\n\ttrace_kvm_nested_vmrun(svm->vmcb->save.rip, vmcb_gpa,\n\t\t\t       nested_vmcb->save.rip,\n\t\t\t       nested_vmcb->control.int_ctl,\n\t\t\t       nested_vmcb->control.event_inj,\n\t\t\t       nested_vmcb->control.nested_ctl);\n\n\ttrace_kvm_nested_intercepts(nested_vmcb->control.intercept_cr & 0xffff,\n\t\t\t\t    nested_vmcb->control.intercept_cr >> 16,\n\t\t\t\t    nested_vmcb->control.intercept_exceptions,\n\t\t\t\t    nested_vmcb->control.intercept);\n\n\t/* Clear internal status */\n\tkvm_clear_exception_queue(&svm->vcpu);\n\tkvm_clear_interrupt_queue(&svm->vcpu);\n\n\t/*\n\t * Save the old vmcb, so we don't need to pick what we save, but can\n\t * restore everything when a VMEXIT occurs\n\t */\n\thsave->save.es     = vmcb->save.es;\n\thsave->save.cs     = vmcb->save.cs;\n\thsave->save.ss     = vmcb->save.ss;\n\thsave->save.ds     = vmcb->save.ds;\n\thsave->save.gdtr   = vmcb->save.gdtr;\n\thsave->save.idtr   = vmcb->save.idtr;\n\thsave->save.efer   = svm->vcpu.arch.efer;\n\thsave->save.cr0    = kvm_read_cr0(&svm->vcpu);\n\thsave->save.cr4    = svm->vcpu.arch.cr4;\n\thsave->save.rflags = kvm_get_rflags(&svm->vcpu);\n\thsave->save.rip    = kvm_rip_read(&svm->vcpu);\n\thsave->save.rsp    = vmcb->save.rsp;\n\thsave->save.rax    = vmcb->save.rax;\n\tif (npt_enabled)\n\t\thsave->save.cr3    = vmcb->save.cr3;\n\telse\n\t\thsave->save.cr3    = kvm_read_cr3(&svm->vcpu);\n\n\tcopy_vmcb_control_area(hsave, vmcb);\n\n\tif (kvm_get_rflags(&svm->vcpu) & X86_EFLAGS_IF)\n\t\tsvm->vcpu.arch.hflags |= HF_HIF_MASK;\n\telse\n\t\tsvm->vcpu.arch.hflags &= ~HF_HIF_MASK;\n\n\tif (nested_vmcb->control.nested_ctl) {\n\t\tkvm_mmu_unload(&svm->vcpu);\n\t\tsvm->nested.nested_cr3 = nested_vmcb->control.nested_cr3;\n\t\tnested_svm_init_mmu_context(&svm->vcpu);\n\t}\n\n\t/* Load the nested guest state */\n\tsvm->vmcb->save.es = nested_vmcb->save.es;\n\tsvm->vmcb->save.cs = nested_vmcb->save.cs;\n\tsvm->vmcb->save.ss = nested_vmcb->save.ss;\n\tsvm->vmcb->save.ds = nested_vmcb->save.ds;\n\tsvm->vmcb->save.gdtr = nested_vmcb->save.gdtr;\n\tsvm->vmcb->save.idtr = nested_vmcb->save.idtr;\n\tkvm_set_rflags(&svm->vcpu, nested_vmcb->save.rflags);\n\tsvm_set_efer(&svm->vcpu, nested_vmcb->save.efer);\n\tsvm_set_cr0(&svm->vcpu, nested_vmcb->save.cr0);\n\tsvm_set_cr4(&svm->vcpu, nested_vmcb->save.cr4);\n\tif (npt_enabled) {\n\t\tsvm->vmcb->save.cr3 = nested_vmcb->save.cr3;\n\t\tsvm->vcpu.arch.cr3 = nested_vmcb->save.cr3;\n\t} else\n\t\t(void)kvm_set_cr3(&svm->vcpu, nested_vmcb->save.cr3);\n\n\t/* Guest paging mode is active - reset mmu */\n\tkvm_mmu_reset_context(&svm->vcpu);\n\n\tsvm->vmcb->save.cr2 = svm->vcpu.arch.cr2 = nested_vmcb->save.cr2;\n\tkvm_register_write(&svm->vcpu, VCPU_REGS_RAX, nested_vmcb->save.rax);\n\tkvm_register_write(&svm->vcpu, VCPU_REGS_RSP, nested_vmcb->save.rsp);\n\tkvm_register_write(&svm->vcpu, VCPU_REGS_RIP, nested_vmcb->save.rip);\n\n\t/* In case we don't even reach vcpu_run, the fields are not updated */\n\tsvm->vmcb->save.rax = nested_vmcb->save.rax;\n\tsvm->vmcb->save.rsp = nested_vmcb->save.rsp;\n\tsvm->vmcb->save.rip = nested_vmcb->save.rip;\n\tsvm->vmcb->save.dr7 = nested_vmcb->save.dr7;\n\tsvm->vmcb->save.dr6 = nested_vmcb->save.dr6;\n\tsvm->vmcb->save.cpl = nested_vmcb->save.cpl;\n\n\tsvm->nested.vmcb_msrpm = nested_vmcb->control.msrpm_base_pa & ~0x0fffULL;\n\tsvm->nested.vmcb_iopm  = nested_vmcb->control.iopm_base_pa  & ~0x0fffULL;\n\n\t/* cache intercepts */\n\tsvm->nested.intercept_cr         = nested_vmcb->control.intercept_cr;\n\tsvm->nested.intercept_dr         = nested_vmcb->control.intercept_dr;\n\tsvm->nested.intercept_exceptions = nested_vmcb->control.intercept_exceptions;\n\tsvm->nested.intercept            = nested_vmcb->control.intercept;\n\n\tsvm_flush_tlb(&svm->vcpu);\n\tsvm->vmcb->control.int_ctl = nested_vmcb->control.int_ctl | V_INTR_MASKING_MASK;\n\tif (nested_vmcb->control.int_ctl & V_INTR_MASKING_MASK)\n\t\tsvm->vcpu.arch.hflags |= HF_VINTR_MASK;\n\telse\n\t\tsvm->vcpu.arch.hflags &= ~HF_VINTR_MASK;\n\n\tif (svm->vcpu.arch.hflags & HF_VINTR_MASK) {\n\t\t/* We only want the cr8 intercept bits of the guest */\n\t\tclr_cr_intercept(svm, INTERCEPT_CR8_READ);\n\t\tclr_cr_intercept(svm, INTERCEPT_CR8_WRITE);\n\t}\n\n\t/* We don't want to see VMMCALLs from a nested guest */\n\tclr_intercept(svm, INTERCEPT_VMMCALL);\n\n\tsvm->vmcb->control.lbr_ctl = nested_vmcb->control.lbr_ctl;\n\tsvm->vmcb->control.int_vector = nested_vmcb->control.int_vector;\n\tsvm->vmcb->control.int_state = nested_vmcb->control.int_state;\n\tsvm->vmcb->control.tsc_offset += nested_vmcb->control.tsc_offset;\n\tsvm->vmcb->control.event_inj = nested_vmcb->control.event_inj;\n\tsvm->vmcb->control.event_inj_err = nested_vmcb->control.event_inj_err;\n\n\tnested_svm_unmap(page);\n\n\t/* Enter Guest-Mode */\n\tenter_guest_mode(&svm->vcpu);\n\n\t/*\n\t * Merge guest and host intercepts - must be called  with vcpu in\n\t * guest-mode to take affect here\n\t */\n\trecalc_intercepts(svm);\n\n\tsvm->nested.vmcb = vmcb_gpa;\n\n\tenable_gif(svm);\n\n\tmark_all_dirty(svm->vmcb);\n\n\treturn true;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nested = true;",
            "static void svm_set_cr0(struct kvm_vcpu *vcpu, unsigned long cr0);",
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int nested = true;\nstatic void svm_set_cr0(struct kvm_vcpu *vcpu, unsigned long cr0);\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic bool nested_svm_vmrun(struct vcpu_svm *svm)\n{\n\tstruct vmcb *nested_vmcb;\n\tstruct vmcb *hsave = svm->nested.hsave;\n\tstruct vmcb *vmcb = svm->vmcb;\n\tstruct page *page;\n\tu64 vmcb_gpa;\n\n\tvmcb_gpa = svm->vmcb->save.rax;\n\n\tnested_vmcb = nested_svm_map(svm, svm->vmcb->save.rax, &page);\n\tif (!nested_vmcb)\n\t\treturn false;\n\n\tif (!nested_vmcb_checks(nested_vmcb)) {\n\t\tnested_vmcb->control.exit_code    = SVM_EXIT_ERR;\n\t\tnested_vmcb->control.exit_code_hi = 0;\n\t\tnested_vmcb->control.exit_info_1  = 0;\n\t\tnested_vmcb->control.exit_info_2  = 0;\n\n\t\tnested_svm_unmap(page);\n\n\t\treturn false;\n\t}\n\n\ttrace_kvm_nested_vmrun(svm->vmcb->save.rip, vmcb_gpa,\n\t\t\t       nested_vmcb->save.rip,\n\t\t\t       nested_vmcb->control.int_ctl,\n\t\t\t       nested_vmcb->control.event_inj,\n\t\t\t       nested_vmcb->control.nested_ctl);\n\n\ttrace_kvm_nested_intercepts(nested_vmcb->control.intercept_cr & 0xffff,\n\t\t\t\t    nested_vmcb->control.intercept_cr >> 16,\n\t\t\t\t    nested_vmcb->control.intercept_exceptions,\n\t\t\t\t    nested_vmcb->control.intercept);\n\n\t/* Clear internal status */\n\tkvm_clear_exception_queue(&svm->vcpu);\n\tkvm_clear_interrupt_queue(&svm->vcpu);\n\n\t/*\n\t * Save the old vmcb, so we don't need to pick what we save, but can\n\t * restore everything when a VMEXIT occurs\n\t */\n\thsave->save.es     = vmcb->save.es;\n\thsave->save.cs     = vmcb->save.cs;\n\thsave->save.ss     = vmcb->save.ss;\n\thsave->save.ds     = vmcb->save.ds;\n\thsave->save.gdtr   = vmcb->save.gdtr;\n\thsave->save.idtr   = vmcb->save.idtr;\n\thsave->save.efer   = svm->vcpu.arch.efer;\n\thsave->save.cr0    = kvm_read_cr0(&svm->vcpu);\n\thsave->save.cr4    = svm->vcpu.arch.cr4;\n\thsave->save.rflags = kvm_get_rflags(&svm->vcpu);\n\thsave->save.rip    = kvm_rip_read(&svm->vcpu);\n\thsave->save.rsp    = vmcb->save.rsp;\n\thsave->save.rax    = vmcb->save.rax;\n\tif (npt_enabled)\n\t\thsave->save.cr3    = vmcb->save.cr3;\n\telse\n\t\thsave->save.cr3    = kvm_read_cr3(&svm->vcpu);\n\n\tcopy_vmcb_control_area(hsave, vmcb);\n\n\tif (kvm_get_rflags(&svm->vcpu) & X86_EFLAGS_IF)\n\t\tsvm->vcpu.arch.hflags |= HF_HIF_MASK;\n\telse\n\t\tsvm->vcpu.arch.hflags &= ~HF_HIF_MASK;\n\n\tif (nested_vmcb->control.nested_ctl) {\n\t\tkvm_mmu_unload(&svm->vcpu);\n\t\tsvm->nested.nested_cr3 = nested_vmcb->control.nested_cr3;\n\t\tnested_svm_init_mmu_context(&svm->vcpu);\n\t}\n\n\t/* Load the nested guest state */\n\tsvm->vmcb->save.es = nested_vmcb->save.es;\n\tsvm->vmcb->save.cs = nested_vmcb->save.cs;\n\tsvm->vmcb->save.ss = nested_vmcb->save.ss;\n\tsvm->vmcb->save.ds = nested_vmcb->save.ds;\n\tsvm->vmcb->save.gdtr = nested_vmcb->save.gdtr;\n\tsvm->vmcb->save.idtr = nested_vmcb->save.idtr;\n\tkvm_set_rflags(&svm->vcpu, nested_vmcb->save.rflags);\n\tsvm_set_efer(&svm->vcpu, nested_vmcb->save.efer);\n\tsvm_set_cr0(&svm->vcpu, nested_vmcb->save.cr0);\n\tsvm_set_cr4(&svm->vcpu, nested_vmcb->save.cr4);\n\tif (npt_enabled) {\n\t\tsvm->vmcb->save.cr3 = nested_vmcb->save.cr3;\n\t\tsvm->vcpu.arch.cr3 = nested_vmcb->save.cr3;\n\t} else\n\t\t(void)kvm_set_cr3(&svm->vcpu, nested_vmcb->save.cr3);\n\n\t/* Guest paging mode is active - reset mmu */\n\tkvm_mmu_reset_context(&svm->vcpu);\n\n\tsvm->vmcb->save.cr2 = svm->vcpu.arch.cr2 = nested_vmcb->save.cr2;\n\tkvm_register_write(&svm->vcpu, VCPU_REGS_RAX, nested_vmcb->save.rax);\n\tkvm_register_write(&svm->vcpu, VCPU_REGS_RSP, nested_vmcb->save.rsp);\n\tkvm_register_write(&svm->vcpu, VCPU_REGS_RIP, nested_vmcb->save.rip);\n\n\t/* In case we don't even reach vcpu_run, the fields are not updated */\n\tsvm->vmcb->save.rax = nested_vmcb->save.rax;\n\tsvm->vmcb->save.rsp = nested_vmcb->save.rsp;\n\tsvm->vmcb->save.rip = nested_vmcb->save.rip;\n\tsvm->vmcb->save.dr7 = nested_vmcb->save.dr7;\n\tsvm->vmcb->save.dr6 = nested_vmcb->save.dr6;\n\tsvm->vmcb->save.cpl = nested_vmcb->save.cpl;\n\n\tsvm->nested.vmcb_msrpm = nested_vmcb->control.msrpm_base_pa & ~0x0fffULL;\n\tsvm->nested.vmcb_iopm  = nested_vmcb->control.iopm_base_pa  & ~0x0fffULL;\n\n\t/* cache intercepts */\n\tsvm->nested.intercept_cr         = nested_vmcb->control.intercept_cr;\n\tsvm->nested.intercept_dr         = nested_vmcb->control.intercept_dr;\n\tsvm->nested.intercept_exceptions = nested_vmcb->control.intercept_exceptions;\n\tsvm->nested.intercept            = nested_vmcb->control.intercept;\n\n\tsvm_flush_tlb(&svm->vcpu);\n\tsvm->vmcb->control.int_ctl = nested_vmcb->control.int_ctl | V_INTR_MASKING_MASK;\n\tif (nested_vmcb->control.int_ctl & V_INTR_MASKING_MASK)\n\t\tsvm->vcpu.arch.hflags |= HF_VINTR_MASK;\n\telse\n\t\tsvm->vcpu.arch.hflags &= ~HF_VINTR_MASK;\n\n\tif (svm->vcpu.arch.hflags & HF_VINTR_MASK) {\n\t\t/* We only want the cr8 intercept bits of the guest */\n\t\tclr_cr_intercept(svm, INTERCEPT_CR8_READ);\n\t\tclr_cr_intercept(svm, INTERCEPT_CR8_WRITE);\n\t}\n\n\t/* We don't want to see VMMCALLs from a nested guest */\n\tclr_intercept(svm, INTERCEPT_VMMCALL);\n\n\tsvm->vmcb->control.lbr_ctl = nested_vmcb->control.lbr_ctl;\n\tsvm->vmcb->control.int_vector = nested_vmcb->control.int_vector;\n\tsvm->vmcb->control.int_state = nested_vmcb->control.int_state;\n\tsvm->vmcb->control.tsc_offset += nested_vmcb->control.tsc_offset;\n\tsvm->vmcb->control.event_inj = nested_vmcb->control.event_inj;\n\tsvm->vmcb->control.event_inj_err = nested_vmcb->control.event_inj_err;\n\n\tnested_svm_unmap(page);\n\n\t/* Enter Guest-Mode */\n\tenter_guest_mode(&svm->vcpu);\n\n\t/*\n\t * Merge guest and host intercepts - must be called  with vcpu in\n\t * guest-mode to take affect here\n\t */\n\trecalc_intercepts(svm);\n\n\tsvm->nested.vmcb = vmcb_gpa;\n\n\tenable_gif(svm);\n\n\tmark_all_dirty(svm->vmcb);\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_rip_write",
          "args": [
            "&svm->vcpu",
            "kvm_rip_read(&svm->vcpu) + 3"
          ],
          "line": 2928
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_rip_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "32-35",
          "snippet": "static inline void kvm_rip_write(struct kvm_vcpu *vcpu, unsigned long val)\n{\n\tkvm_register_write(vcpu, VCPU_REGS_RIP, val);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void kvm_rip_write(struct kvm_vcpu *vcpu, unsigned long val)\n{\n\tkvm_register_write(vcpu, VCPU_REGS_RIP, val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_rip_read",
          "args": [
            "&svm->vcpu"
          ],
          "line": 2928
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_rip_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "27-30",
          "snippet": "static inline unsigned long kvm_rip_read(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_register_read(vcpu, VCPU_REGS_RIP);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline unsigned long kvm_rip_read(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_register_read(vcpu, VCPU_REGS_RIP);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nested_svm_check_permissions",
          "args": [
            "svm"
          ],
          "line": 2924
        },
        "resolved": true,
        "details": {
          "function_name": "nested_svm_check_permissions",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "2246-2260",
          "snippet": "static int nested_svm_check_permissions(struct vcpu_svm *svm)\n{\n\tif (!(svm->vcpu.arch.efer & EFER_SVME)\n\t    || !is_paging(&svm->vcpu)) {\n\t\tkvm_queue_exception(&svm->vcpu, UD_VECTOR);\n\t\treturn 1;\n\t}\n\n\tif (svm->vmcb->save.cpl) {\n\t\tkvm_inject_gp(&svm->vcpu, 0);\n\t\treturn 1;\n\t}\n\n       return 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic int nested_svm_check_permissions(struct vcpu_svm *svm)\n{\n\tif (!(svm->vcpu.arch.efer & EFER_SVME)\n\t    || !is_paging(&svm->vcpu)) {\n\t\tkvm_queue_exception(&svm->vcpu, UD_VECTOR);\n\t\treturn 1;\n\t}\n\n\tif (svm->vmcb->save.cpl) {\n\t\tkvm_inject_gp(&svm->vcpu, 0);\n\t\treturn 1;\n\t}\n\n       return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic int vmrun_interception(struct vcpu_svm *svm)\n{\n\tif (nested_svm_check_permissions(svm))\n\t\treturn 1;\n\n\t/* Save rip after vmrun instruction */\n\tkvm_rip_write(&svm->vcpu, kvm_rip_read(&svm->vcpu) + 3);\n\n\tif (!nested_svm_vmrun(svm))\n\t\treturn 1;\n\n\tif (!nested_svm_vmrun_msrpm(svm))\n\t\tgoto failed;\n\n\treturn 1;\n\nfailed:\n\n\tsvm->vmcb->control.exit_code    = SVM_EXIT_ERR;\n\tsvm->vmcb->control.exit_code_hi = 0;\n\tsvm->vmcb->control.exit_info_1  = 0;\n\tsvm->vmcb->control.exit_info_2  = 0;\n\n\tnested_svm_vmexit(svm);\n\n\treturn 1;\n}"
  },
  {
    "function_name": "vmsave_interception",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "2901-2920",
    "snippet": "static int vmsave_interception(struct vcpu_svm *svm)\n{\n\tstruct vmcb *nested_vmcb;\n\tstruct page *page;\n\n\tif (nested_svm_check_permissions(svm))\n\t\treturn 1;\n\n\tnested_vmcb = nested_svm_map(svm, svm->vmcb->save.rax, &page);\n\tif (!nested_vmcb)\n\t\treturn 1;\n\n\tsvm->next_rip = kvm_rip_read(&svm->vcpu) + 3;\n\tskip_emulated_instruction(&svm->vcpu);\n\n\tnested_svm_vmloadsave(svm->vmcb, nested_vmcb);\n\tnested_svm_unmap(page);\n\n\treturn 1;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nested_svm_unmap",
          "args": [
            "page"
          ],
          "line": 2917
        },
        "resolved": true,
        "details": {
          "function_name": "nested_svm_unmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "2356-2360",
          "snippet": "static void nested_svm_unmap(struct page *page)\n{\n\tkunmap(page);\n\tkvm_release_page_dirty(page);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void nested_svm_unmap(struct page *page)\n{\n\tkunmap(page);\n\tkvm_release_page_dirty(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nested_svm_vmloadsave",
          "args": [
            "svm->vmcb",
            "nested_vmcb"
          ],
          "line": 2916
        },
        "resolved": true,
        "details": {
          "function_name": "nested_svm_vmloadsave",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "2864-2878",
          "snippet": "static void nested_svm_vmloadsave(struct vmcb *from_vmcb, struct vmcb *to_vmcb)\n{\n\tto_vmcb->save.fs = from_vmcb->save.fs;\n\tto_vmcb->save.gs = from_vmcb->save.gs;\n\tto_vmcb->save.tr = from_vmcb->save.tr;\n\tto_vmcb->save.ldtr = from_vmcb->save.ldtr;\n\tto_vmcb->save.kernel_gs_base = from_vmcb->save.kernel_gs_base;\n\tto_vmcb->save.star = from_vmcb->save.star;\n\tto_vmcb->save.lstar = from_vmcb->save.lstar;\n\tto_vmcb->save.cstar = from_vmcb->save.cstar;\n\tto_vmcb->save.sfmask = from_vmcb->save.sfmask;\n\tto_vmcb->save.sysenter_cs = from_vmcb->save.sysenter_cs;\n\tto_vmcb->save.sysenter_esp = from_vmcb->save.sysenter_esp;\n\tto_vmcb->save.sysenter_eip = from_vmcb->save.sysenter_eip;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void nested_svm_vmloadsave(struct vmcb *from_vmcb, struct vmcb *to_vmcb)\n{\n\tto_vmcb->save.fs = from_vmcb->save.fs;\n\tto_vmcb->save.gs = from_vmcb->save.gs;\n\tto_vmcb->save.tr = from_vmcb->save.tr;\n\tto_vmcb->save.ldtr = from_vmcb->save.ldtr;\n\tto_vmcb->save.kernel_gs_base = from_vmcb->save.kernel_gs_base;\n\tto_vmcb->save.star = from_vmcb->save.star;\n\tto_vmcb->save.lstar = from_vmcb->save.lstar;\n\tto_vmcb->save.cstar = from_vmcb->save.cstar;\n\tto_vmcb->save.sfmask = from_vmcb->save.sfmask;\n\tto_vmcb->save.sysenter_cs = from_vmcb->save.sysenter_cs;\n\tto_vmcb->save.sysenter_esp = from_vmcb->save.sysenter_esp;\n\tto_vmcb->save.sysenter_eip = from_vmcb->save.sysenter_eip;\n}"
        }
      },
      {
        "call_info": {
          "callee": "skip_emulated_instruction",
          "args": [
            "&svm->vcpu"
          ],
          "line": 2914
        },
        "resolved": true,
        "details": {
          "function_name": "skip_emulated_instruction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "572-593",
          "snippet": "static void skip_emulated_instruction(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (svm->vmcb->control.next_rip != 0) {\n\t\tWARN_ON_ONCE(!static_cpu_has(X86_FEATURE_NRIPS));\n\t\tsvm->next_rip = svm->vmcb->control.next_rip;\n\t}\n\n\tif (!svm->next_rip) {\n\t\tif (emulate_instruction(vcpu, EMULTYPE_SKIP) !=\n\t\t\t\tEMULATE_DONE)\n\t\t\tprintk(KERN_DEBUG \"%s: NOP\\n\", __func__);\n\t\treturn;\n\t}\n\tif (svm->next_rip - kvm_rip_read(vcpu) > MAX_INST_SIZE)\n\t\tprintk(KERN_ERR \"%s: ip 0x%lx next 0x%llx\\n\",\n\t\t       __func__, kvm_rip_read(vcpu), svm->next_rip);\n\n\tkvm_rip_write(vcpu, svm->next_rip);\n\tsvm_set_interrupt_shadow(vcpu, 0);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define MAX_INST_SIZE 15"
          ],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define MAX_INST_SIZE 15\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic void skip_emulated_instruction(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (svm->vmcb->control.next_rip != 0) {\n\t\tWARN_ON_ONCE(!static_cpu_has(X86_FEATURE_NRIPS));\n\t\tsvm->next_rip = svm->vmcb->control.next_rip;\n\t}\n\n\tif (!svm->next_rip) {\n\t\tif (emulate_instruction(vcpu, EMULTYPE_SKIP) !=\n\t\t\t\tEMULATE_DONE)\n\t\t\tprintk(KERN_DEBUG \"%s: NOP\\n\", __func__);\n\t\treturn;\n\t}\n\tif (svm->next_rip - kvm_rip_read(vcpu) > MAX_INST_SIZE)\n\t\tprintk(KERN_ERR \"%s: ip 0x%lx next 0x%llx\\n\",\n\t\t       __func__, kvm_rip_read(vcpu), svm->next_rip);\n\n\tkvm_rip_write(vcpu, svm->next_rip);\n\tsvm_set_interrupt_shadow(vcpu, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_rip_read",
          "args": [
            "&svm->vcpu"
          ],
          "line": 2913
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_rip_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "27-30",
          "snippet": "static inline unsigned long kvm_rip_read(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_register_read(vcpu, VCPU_REGS_RIP);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline unsigned long kvm_rip_read(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_register_read(vcpu, VCPU_REGS_RIP);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nested_svm_map",
          "args": [
            "svm",
            "svm->vmcb->save.rax",
            "&page"
          ],
          "line": 2909
        },
        "resolved": true,
        "details": {
          "function_name": "nested_svm_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "2336-2354",
          "snippet": "static void *nested_svm_map(struct vcpu_svm *svm, u64 gpa, struct page **_page)\n{\n\tstruct page *page;\n\n\tmight_sleep();\n\n\tpage = kvm_vcpu_gfn_to_page(&svm->vcpu, gpa >> PAGE_SHIFT);\n\tif (is_error_page(page))\n\t\tgoto error;\n\n\t*_page = page;\n\n\treturn kmap(page);\n\nerror:\n\tkvm_inject_gp(&svm->vcpu, 0);\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic void *nested_svm_map(struct vcpu_svm *svm, u64 gpa, struct page **_page)\n{\n\tstruct page *page;\n\n\tmight_sleep();\n\n\tpage = kvm_vcpu_gfn_to_page(&svm->vcpu, gpa >> PAGE_SHIFT);\n\tif (is_error_page(page))\n\t\tgoto error;\n\n\t*_page = page;\n\n\treturn kmap(page);\n\nerror:\n\tkvm_inject_gp(&svm->vcpu, 0);\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nested_svm_check_permissions",
          "args": [
            "svm"
          ],
          "line": 2906
        },
        "resolved": true,
        "details": {
          "function_name": "nested_svm_check_permissions",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "2246-2260",
          "snippet": "static int nested_svm_check_permissions(struct vcpu_svm *svm)\n{\n\tif (!(svm->vcpu.arch.efer & EFER_SVME)\n\t    || !is_paging(&svm->vcpu)) {\n\t\tkvm_queue_exception(&svm->vcpu, UD_VECTOR);\n\t\treturn 1;\n\t}\n\n\tif (svm->vmcb->save.cpl) {\n\t\tkvm_inject_gp(&svm->vcpu, 0);\n\t\treturn 1;\n\t}\n\n       return 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic int nested_svm_check_permissions(struct vcpu_svm *svm)\n{\n\tif (!(svm->vcpu.arch.efer & EFER_SVME)\n\t    || !is_paging(&svm->vcpu)) {\n\t\tkvm_queue_exception(&svm->vcpu, UD_VECTOR);\n\t\treturn 1;\n\t}\n\n\tif (svm->vmcb->save.cpl) {\n\t\tkvm_inject_gp(&svm->vcpu, 0);\n\t\treturn 1;\n\t}\n\n       return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic int vmsave_interception(struct vcpu_svm *svm)\n{\n\tstruct vmcb *nested_vmcb;\n\tstruct page *page;\n\n\tif (nested_svm_check_permissions(svm))\n\t\treturn 1;\n\n\tnested_vmcb = nested_svm_map(svm, svm->vmcb->save.rax, &page);\n\tif (!nested_vmcb)\n\t\treturn 1;\n\n\tsvm->next_rip = kvm_rip_read(&svm->vcpu) + 3;\n\tskip_emulated_instruction(&svm->vcpu);\n\n\tnested_svm_vmloadsave(svm->vmcb, nested_vmcb);\n\tnested_svm_unmap(page);\n\n\treturn 1;\n}"
  },
  {
    "function_name": "vmload_interception",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "2880-2899",
    "snippet": "static int vmload_interception(struct vcpu_svm *svm)\n{\n\tstruct vmcb *nested_vmcb;\n\tstruct page *page;\n\n\tif (nested_svm_check_permissions(svm))\n\t\treturn 1;\n\n\tnested_vmcb = nested_svm_map(svm, svm->vmcb->save.rax, &page);\n\tif (!nested_vmcb)\n\t\treturn 1;\n\n\tsvm->next_rip = kvm_rip_read(&svm->vcpu) + 3;\n\tskip_emulated_instruction(&svm->vcpu);\n\n\tnested_svm_vmloadsave(nested_vmcb, svm->vmcb);\n\tnested_svm_unmap(page);\n\n\treturn 1;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nested_svm_unmap",
          "args": [
            "page"
          ],
          "line": 2896
        },
        "resolved": true,
        "details": {
          "function_name": "nested_svm_unmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "2356-2360",
          "snippet": "static void nested_svm_unmap(struct page *page)\n{\n\tkunmap(page);\n\tkvm_release_page_dirty(page);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void nested_svm_unmap(struct page *page)\n{\n\tkunmap(page);\n\tkvm_release_page_dirty(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nested_svm_vmloadsave",
          "args": [
            "nested_vmcb",
            "svm->vmcb"
          ],
          "line": 2895
        },
        "resolved": true,
        "details": {
          "function_name": "nested_svm_vmloadsave",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "2864-2878",
          "snippet": "static void nested_svm_vmloadsave(struct vmcb *from_vmcb, struct vmcb *to_vmcb)\n{\n\tto_vmcb->save.fs = from_vmcb->save.fs;\n\tto_vmcb->save.gs = from_vmcb->save.gs;\n\tto_vmcb->save.tr = from_vmcb->save.tr;\n\tto_vmcb->save.ldtr = from_vmcb->save.ldtr;\n\tto_vmcb->save.kernel_gs_base = from_vmcb->save.kernel_gs_base;\n\tto_vmcb->save.star = from_vmcb->save.star;\n\tto_vmcb->save.lstar = from_vmcb->save.lstar;\n\tto_vmcb->save.cstar = from_vmcb->save.cstar;\n\tto_vmcb->save.sfmask = from_vmcb->save.sfmask;\n\tto_vmcb->save.sysenter_cs = from_vmcb->save.sysenter_cs;\n\tto_vmcb->save.sysenter_esp = from_vmcb->save.sysenter_esp;\n\tto_vmcb->save.sysenter_eip = from_vmcb->save.sysenter_eip;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void nested_svm_vmloadsave(struct vmcb *from_vmcb, struct vmcb *to_vmcb)\n{\n\tto_vmcb->save.fs = from_vmcb->save.fs;\n\tto_vmcb->save.gs = from_vmcb->save.gs;\n\tto_vmcb->save.tr = from_vmcb->save.tr;\n\tto_vmcb->save.ldtr = from_vmcb->save.ldtr;\n\tto_vmcb->save.kernel_gs_base = from_vmcb->save.kernel_gs_base;\n\tto_vmcb->save.star = from_vmcb->save.star;\n\tto_vmcb->save.lstar = from_vmcb->save.lstar;\n\tto_vmcb->save.cstar = from_vmcb->save.cstar;\n\tto_vmcb->save.sfmask = from_vmcb->save.sfmask;\n\tto_vmcb->save.sysenter_cs = from_vmcb->save.sysenter_cs;\n\tto_vmcb->save.sysenter_esp = from_vmcb->save.sysenter_esp;\n\tto_vmcb->save.sysenter_eip = from_vmcb->save.sysenter_eip;\n}"
        }
      },
      {
        "call_info": {
          "callee": "skip_emulated_instruction",
          "args": [
            "&svm->vcpu"
          ],
          "line": 2893
        },
        "resolved": true,
        "details": {
          "function_name": "skip_emulated_instruction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "572-593",
          "snippet": "static void skip_emulated_instruction(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (svm->vmcb->control.next_rip != 0) {\n\t\tWARN_ON_ONCE(!static_cpu_has(X86_FEATURE_NRIPS));\n\t\tsvm->next_rip = svm->vmcb->control.next_rip;\n\t}\n\n\tif (!svm->next_rip) {\n\t\tif (emulate_instruction(vcpu, EMULTYPE_SKIP) !=\n\t\t\t\tEMULATE_DONE)\n\t\t\tprintk(KERN_DEBUG \"%s: NOP\\n\", __func__);\n\t\treturn;\n\t}\n\tif (svm->next_rip - kvm_rip_read(vcpu) > MAX_INST_SIZE)\n\t\tprintk(KERN_ERR \"%s: ip 0x%lx next 0x%llx\\n\",\n\t\t       __func__, kvm_rip_read(vcpu), svm->next_rip);\n\n\tkvm_rip_write(vcpu, svm->next_rip);\n\tsvm_set_interrupt_shadow(vcpu, 0);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define MAX_INST_SIZE 15"
          ],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define MAX_INST_SIZE 15\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic void skip_emulated_instruction(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (svm->vmcb->control.next_rip != 0) {\n\t\tWARN_ON_ONCE(!static_cpu_has(X86_FEATURE_NRIPS));\n\t\tsvm->next_rip = svm->vmcb->control.next_rip;\n\t}\n\n\tif (!svm->next_rip) {\n\t\tif (emulate_instruction(vcpu, EMULTYPE_SKIP) !=\n\t\t\t\tEMULATE_DONE)\n\t\t\tprintk(KERN_DEBUG \"%s: NOP\\n\", __func__);\n\t\treturn;\n\t}\n\tif (svm->next_rip - kvm_rip_read(vcpu) > MAX_INST_SIZE)\n\t\tprintk(KERN_ERR \"%s: ip 0x%lx next 0x%llx\\n\",\n\t\t       __func__, kvm_rip_read(vcpu), svm->next_rip);\n\n\tkvm_rip_write(vcpu, svm->next_rip);\n\tsvm_set_interrupt_shadow(vcpu, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_rip_read",
          "args": [
            "&svm->vcpu"
          ],
          "line": 2892
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_rip_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "27-30",
          "snippet": "static inline unsigned long kvm_rip_read(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_register_read(vcpu, VCPU_REGS_RIP);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline unsigned long kvm_rip_read(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_register_read(vcpu, VCPU_REGS_RIP);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nested_svm_map",
          "args": [
            "svm",
            "svm->vmcb->save.rax",
            "&page"
          ],
          "line": 2888
        },
        "resolved": true,
        "details": {
          "function_name": "nested_svm_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "2336-2354",
          "snippet": "static void *nested_svm_map(struct vcpu_svm *svm, u64 gpa, struct page **_page)\n{\n\tstruct page *page;\n\n\tmight_sleep();\n\n\tpage = kvm_vcpu_gfn_to_page(&svm->vcpu, gpa >> PAGE_SHIFT);\n\tif (is_error_page(page))\n\t\tgoto error;\n\n\t*_page = page;\n\n\treturn kmap(page);\n\nerror:\n\tkvm_inject_gp(&svm->vcpu, 0);\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic void *nested_svm_map(struct vcpu_svm *svm, u64 gpa, struct page **_page)\n{\n\tstruct page *page;\n\n\tmight_sleep();\n\n\tpage = kvm_vcpu_gfn_to_page(&svm->vcpu, gpa >> PAGE_SHIFT);\n\tif (is_error_page(page))\n\t\tgoto error;\n\n\t*_page = page;\n\n\treturn kmap(page);\n\nerror:\n\tkvm_inject_gp(&svm->vcpu, 0);\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nested_svm_check_permissions",
          "args": [
            "svm"
          ],
          "line": 2885
        },
        "resolved": true,
        "details": {
          "function_name": "nested_svm_check_permissions",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "2246-2260",
          "snippet": "static int nested_svm_check_permissions(struct vcpu_svm *svm)\n{\n\tif (!(svm->vcpu.arch.efer & EFER_SVME)\n\t    || !is_paging(&svm->vcpu)) {\n\t\tkvm_queue_exception(&svm->vcpu, UD_VECTOR);\n\t\treturn 1;\n\t}\n\n\tif (svm->vmcb->save.cpl) {\n\t\tkvm_inject_gp(&svm->vcpu, 0);\n\t\treturn 1;\n\t}\n\n       return 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic int nested_svm_check_permissions(struct vcpu_svm *svm)\n{\n\tif (!(svm->vcpu.arch.efer & EFER_SVME)\n\t    || !is_paging(&svm->vcpu)) {\n\t\tkvm_queue_exception(&svm->vcpu, UD_VECTOR);\n\t\treturn 1;\n\t}\n\n\tif (svm->vmcb->save.cpl) {\n\t\tkvm_inject_gp(&svm->vcpu, 0);\n\t\treturn 1;\n\t}\n\n       return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic int vmload_interception(struct vcpu_svm *svm)\n{\n\tstruct vmcb *nested_vmcb;\n\tstruct page *page;\n\n\tif (nested_svm_check_permissions(svm))\n\t\treturn 1;\n\n\tnested_vmcb = nested_svm_map(svm, svm->vmcb->save.rax, &page);\n\tif (!nested_vmcb)\n\t\treturn 1;\n\n\tsvm->next_rip = kvm_rip_read(&svm->vcpu) + 3;\n\tskip_emulated_instruction(&svm->vcpu);\n\n\tnested_svm_vmloadsave(nested_vmcb, svm->vmcb);\n\tnested_svm_unmap(page);\n\n\treturn 1;\n}"
  },
  {
    "function_name": "nested_svm_vmloadsave",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "2864-2878",
    "snippet": "static void nested_svm_vmloadsave(struct vmcb *from_vmcb, struct vmcb *to_vmcb)\n{\n\tto_vmcb->save.fs = from_vmcb->save.fs;\n\tto_vmcb->save.gs = from_vmcb->save.gs;\n\tto_vmcb->save.tr = from_vmcb->save.tr;\n\tto_vmcb->save.ldtr = from_vmcb->save.ldtr;\n\tto_vmcb->save.kernel_gs_base = from_vmcb->save.kernel_gs_base;\n\tto_vmcb->save.star = from_vmcb->save.star;\n\tto_vmcb->save.lstar = from_vmcb->save.lstar;\n\tto_vmcb->save.cstar = from_vmcb->save.cstar;\n\tto_vmcb->save.sfmask = from_vmcb->save.sfmask;\n\tto_vmcb->save.sysenter_cs = from_vmcb->save.sysenter_cs;\n\tto_vmcb->save.sysenter_esp = from_vmcb->save.sysenter_esp;\n\tto_vmcb->save.sysenter_eip = from_vmcb->save.sysenter_eip;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void nested_svm_vmloadsave(struct vmcb *from_vmcb, struct vmcb *to_vmcb)\n{\n\tto_vmcb->save.fs = from_vmcb->save.fs;\n\tto_vmcb->save.gs = from_vmcb->save.gs;\n\tto_vmcb->save.tr = from_vmcb->save.tr;\n\tto_vmcb->save.ldtr = from_vmcb->save.ldtr;\n\tto_vmcb->save.kernel_gs_base = from_vmcb->save.kernel_gs_base;\n\tto_vmcb->save.star = from_vmcb->save.star;\n\tto_vmcb->save.lstar = from_vmcb->save.lstar;\n\tto_vmcb->save.cstar = from_vmcb->save.cstar;\n\tto_vmcb->save.sfmask = from_vmcb->save.sfmask;\n\tto_vmcb->save.sysenter_cs = from_vmcb->save.sysenter_cs;\n\tto_vmcb->save.sysenter_esp = from_vmcb->save.sysenter_esp;\n\tto_vmcb->save.sysenter_eip = from_vmcb->save.sysenter_eip;\n}"
  },
  {
    "function_name": "nested_svm_vmrun",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "2704-2862",
    "snippet": "static bool nested_svm_vmrun(struct vcpu_svm *svm)\n{\n\tstruct vmcb *nested_vmcb;\n\tstruct vmcb *hsave = svm->nested.hsave;\n\tstruct vmcb *vmcb = svm->vmcb;\n\tstruct page *page;\n\tu64 vmcb_gpa;\n\n\tvmcb_gpa = svm->vmcb->save.rax;\n\n\tnested_vmcb = nested_svm_map(svm, svm->vmcb->save.rax, &page);\n\tif (!nested_vmcb)\n\t\treturn false;\n\n\tif (!nested_vmcb_checks(nested_vmcb)) {\n\t\tnested_vmcb->control.exit_code    = SVM_EXIT_ERR;\n\t\tnested_vmcb->control.exit_code_hi = 0;\n\t\tnested_vmcb->control.exit_info_1  = 0;\n\t\tnested_vmcb->control.exit_info_2  = 0;\n\n\t\tnested_svm_unmap(page);\n\n\t\treturn false;\n\t}\n\n\ttrace_kvm_nested_vmrun(svm->vmcb->save.rip, vmcb_gpa,\n\t\t\t       nested_vmcb->save.rip,\n\t\t\t       nested_vmcb->control.int_ctl,\n\t\t\t       nested_vmcb->control.event_inj,\n\t\t\t       nested_vmcb->control.nested_ctl);\n\n\ttrace_kvm_nested_intercepts(nested_vmcb->control.intercept_cr & 0xffff,\n\t\t\t\t    nested_vmcb->control.intercept_cr >> 16,\n\t\t\t\t    nested_vmcb->control.intercept_exceptions,\n\t\t\t\t    nested_vmcb->control.intercept);\n\n\t/* Clear internal status */\n\tkvm_clear_exception_queue(&svm->vcpu);\n\tkvm_clear_interrupt_queue(&svm->vcpu);\n\n\t/*\n\t * Save the old vmcb, so we don't need to pick what we save, but can\n\t * restore everything when a VMEXIT occurs\n\t */\n\thsave->save.es     = vmcb->save.es;\n\thsave->save.cs     = vmcb->save.cs;\n\thsave->save.ss     = vmcb->save.ss;\n\thsave->save.ds     = vmcb->save.ds;\n\thsave->save.gdtr   = vmcb->save.gdtr;\n\thsave->save.idtr   = vmcb->save.idtr;\n\thsave->save.efer   = svm->vcpu.arch.efer;\n\thsave->save.cr0    = kvm_read_cr0(&svm->vcpu);\n\thsave->save.cr4    = svm->vcpu.arch.cr4;\n\thsave->save.rflags = kvm_get_rflags(&svm->vcpu);\n\thsave->save.rip    = kvm_rip_read(&svm->vcpu);\n\thsave->save.rsp    = vmcb->save.rsp;\n\thsave->save.rax    = vmcb->save.rax;\n\tif (npt_enabled)\n\t\thsave->save.cr3    = vmcb->save.cr3;\n\telse\n\t\thsave->save.cr3    = kvm_read_cr3(&svm->vcpu);\n\n\tcopy_vmcb_control_area(hsave, vmcb);\n\n\tif (kvm_get_rflags(&svm->vcpu) & X86_EFLAGS_IF)\n\t\tsvm->vcpu.arch.hflags |= HF_HIF_MASK;\n\telse\n\t\tsvm->vcpu.arch.hflags &= ~HF_HIF_MASK;\n\n\tif (nested_vmcb->control.nested_ctl) {\n\t\tkvm_mmu_unload(&svm->vcpu);\n\t\tsvm->nested.nested_cr3 = nested_vmcb->control.nested_cr3;\n\t\tnested_svm_init_mmu_context(&svm->vcpu);\n\t}\n\n\t/* Load the nested guest state */\n\tsvm->vmcb->save.es = nested_vmcb->save.es;\n\tsvm->vmcb->save.cs = nested_vmcb->save.cs;\n\tsvm->vmcb->save.ss = nested_vmcb->save.ss;\n\tsvm->vmcb->save.ds = nested_vmcb->save.ds;\n\tsvm->vmcb->save.gdtr = nested_vmcb->save.gdtr;\n\tsvm->vmcb->save.idtr = nested_vmcb->save.idtr;\n\tkvm_set_rflags(&svm->vcpu, nested_vmcb->save.rflags);\n\tsvm_set_efer(&svm->vcpu, nested_vmcb->save.efer);\n\tsvm_set_cr0(&svm->vcpu, nested_vmcb->save.cr0);\n\tsvm_set_cr4(&svm->vcpu, nested_vmcb->save.cr4);\n\tif (npt_enabled) {\n\t\tsvm->vmcb->save.cr3 = nested_vmcb->save.cr3;\n\t\tsvm->vcpu.arch.cr3 = nested_vmcb->save.cr3;\n\t} else\n\t\t(void)kvm_set_cr3(&svm->vcpu, nested_vmcb->save.cr3);\n\n\t/* Guest paging mode is active - reset mmu */\n\tkvm_mmu_reset_context(&svm->vcpu);\n\n\tsvm->vmcb->save.cr2 = svm->vcpu.arch.cr2 = nested_vmcb->save.cr2;\n\tkvm_register_write(&svm->vcpu, VCPU_REGS_RAX, nested_vmcb->save.rax);\n\tkvm_register_write(&svm->vcpu, VCPU_REGS_RSP, nested_vmcb->save.rsp);\n\tkvm_register_write(&svm->vcpu, VCPU_REGS_RIP, nested_vmcb->save.rip);\n\n\t/* In case we don't even reach vcpu_run, the fields are not updated */\n\tsvm->vmcb->save.rax = nested_vmcb->save.rax;\n\tsvm->vmcb->save.rsp = nested_vmcb->save.rsp;\n\tsvm->vmcb->save.rip = nested_vmcb->save.rip;\n\tsvm->vmcb->save.dr7 = nested_vmcb->save.dr7;\n\tsvm->vmcb->save.dr6 = nested_vmcb->save.dr6;\n\tsvm->vmcb->save.cpl = nested_vmcb->save.cpl;\n\n\tsvm->nested.vmcb_msrpm = nested_vmcb->control.msrpm_base_pa & ~0x0fffULL;\n\tsvm->nested.vmcb_iopm  = nested_vmcb->control.iopm_base_pa  & ~0x0fffULL;\n\n\t/* cache intercepts */\n\tsvm->nested.intercept_cr         = nested_vmcb->control.intercept_cr;\n\tsvm->nested.intercept_dr         = nested_vmcb->control.intercept_dr;\n\tsvm->nested.intercept_exceptions = nested_vmcb->control.intercept_exceptions;\n\tsvm->nested.intercept            = nested_vmcb->control.intercept;\n\n\tsvm_flush_tlb(&svm->vcpu);\n\tsvm->vmcb->control.int_ctl = nested_vmcb->control.int_ctl | V_INTR_MASKING_MASK;\n\tif (nested_vmcb->control.int_ctl & V_INTR_MASKING_MASK)\n\t\tsvm->vcpu.arch.hflags |= HF_VINTR_MASK;\n\telse\n\t\tsvm->vcpu.arch.hflags &= ~HF_VINTR_MASK;\n\n\tif (svm->vcpu.arch.hflags & HF_VINTR_MASK) {\n\t\t/* We only want the cr8 intercept bits of the guest */\n\t\tclr_cr_intercept(svm, INTERCEPT_CR8_READ);\n\t\tclr_cr_intercept(svm, INTERCEPT_CR8_WRITE);\n\t}\n\n\t/* We don't want to see VMMCALLs from a nested guest */\n\tclr_intercept(svm, INTERCEPT_VMMCALL);\n\n\tsvm->vmcb->control.lbr_ctl = nested_vmcb->control.lbr_ctl;\n\tsvm->vmcb->control.int_vector = nested_vmcb->control.int_vector;\n\tsvm->vmcb->control.int_state = nested_vmcb->control.int_state;\n\tsvm->vmcb->control.tsc_offset += nested_vmcb->control.tsc_offset;\n\tsvm->vmcb->control.event_inj = nested_vmcb->control.event_inj;\n\tsvm->vmcb->control.event_inj_err = nested_vmcb->control.event_inj_err;\n\n\tnested_svm_unmap(page);\n\n\t/* Enter Guest-Mode */\n\tenter_guest_mode(&svm->vcpu);\n\n\t/*\n\t * Merge guest and host intercepts - must be called  with vcpu in\n\t * guest-mode to take affect here\n\t */\n\trecalc_intercepts(svm);\n\n\tsvm->nested.vmcb = vmcb_gpa;\n\n\tenable_gif(svm);\n\n\tmark_all_dirty(svm->vmcb);\n\n\treturn true;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int nested = true;",
      "static void svm_set_cr0(struct kvm_vcpu *vcpu, unsigned long cr0);",
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_all_dirty",
          "args": [
            "svm->vmcb"
          ],
          "line": 2859
        },
        "resolved": true,
        "details": {
          "function_name": "mark_all_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "278-281",
          "snippet": "static inline void mark_all_dirty(struct vmcb *vmcb)\n{\n\tvmcb->control.clean = 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic inline void mark_all_dirty(struct vmcb *vmcb)\n{\n\tvmcb->control.clean = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "enable_gif",
          "args": [
            "svm"
          ],
          "line": 2857
        },
        "resolved": true,
        "details": {
          "function_name": "enable_gif",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "438-441",
          "snippet": "static inline void enable_gif(struct vcpu_svm *svm)\n{\n\tsvm->vcpu.arch.hflags |= HF_GIF_MASK;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic inline void enable_gif(struct vcpu_svm *svm)\n{\n\tsvm->vcpu.arch.hflags |= HF_GIF_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "recalc_intercepts",
          "args": [
            "svm"
          ],
          "line": 2853
        },
        "resolved": true,
        "details": {
          "function_name": "recalc_intercepts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "316-334",
          "snippet": "static void recalc_intercepts(struct vcpu_svm *svm)\n{\n\tstruct vmcb_control_area *c, *h;\n\tstruct nested_state *g;\n\n\tmark_dirty(svm->vmcb, VMCB_INTERCEPTS);\n\n\tif (!is_guest_mode(&svm->vcpu))\n\t\treturn;\n\n\tc = &svm->vmcb->control;\n\th = &svm->nested.hsave->control;\n\tg = &svm->nested;\n\n\tc->intercept_cr = h->intercept_cr | g->intercept_cr;\n\tc->intercept_dr = h->intercept_dr | g->intercept_dr;\n\tc->intercept_exceptions = h->intercept_exceptions | g->intercept_exceptions;\n\tc->intercept = h->intercept | g->intercept;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nested = true;",
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int nested = true;\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic void recalc_intercepts(struct vcpu_svm *svm)\n{\n\tstruct vmcb_control_area *c, *h;\n\tstruct nested_state *g;\n\n\tmark_dirty(svm->vmcb, VMCB_INTERCEPTS);\n\n\tif (!is_guest_mode(&svm->vcpu))\n\t\treturn;\n\n\tc = &svm->vmcb->control;\n\th = &svm->nested.hsave->control;\n\tg = &svm->nested;\n\n\tc->intercept_cr = h->intercept_cr | g->intercept_cr;\n\tc->intercept_dr = h->intercept_dr | g->intercept_dr;\n\tc->intercept_exceptions = h->intercept_exceptions | g->intercept_exceptions;\n\tc->intercept = h->intercept | g->intercept;\n}"
        }
      },
      {
        "call_info": {
          "callee": "enter_guest_mode",
          "args": [
            "&svm->vcpu"
          ],
          "line": 2847
        },
        "resolved": true,
        "details": {
          "function_name": "enter_guest_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "92-95",
          "snippet": "static inline void enter_guest_mode(struct kvm_vcpu *vcpu)\n{\n\tvcpu->arch.hflags |= HF_GUEST_MASK;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void enter_guest_mode(struct kvm_vcpu *vcpu)\n{\n\tvcpu->arch.hflags |= HF_GUEST_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nested_svm_unmap",
          "args": [
            "page"
          ],
          "line": 2844
        },
        "resolved": true,
        "details": {
          "function_name": "nested_svm_unmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "2356-2360",
          "snippet": "static void nested_svm_unmap(struct page *page)\n{\n\tkunmap(page);\n\tkvm_release_page_dirty(page);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void nested_svm_unmap(struct page *page)\n{\n\tkunmap(page);\n\tkvm_release_page_dirty(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clr_intercept",
          "args": [
            "svm",
            "INTERCEPT_VMMCALL"
          ],
          "line": 2835
        },
        "resolved": true,
        "details": {
          "function_name": "clr_intercept",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "429-436",
          "snippet": "static inline void clr_intercept(struct vcpu_svm *svm, int bit)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept &= ~(1ULL << bit);\n\n\trecalc_intercepts(svm);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic inline void clr_intercept(struct vcpu_svm *svm, int bit)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept &= ~(1ULL << bit);\n\n\trecalc_intercepts(svm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clr_cr_intercept",
          "args": [
            "svm",
            "INTERCEPT_CR8_WRITE"
          ],
          "line": 2831
        },
        "resolved": true,
        "details": {
          "function_name": "clr_cr_intercept",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "353-360",
          "snippet": "static inline void clr_cr_intercept(struct vcpu_svm *svm, int bit)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept_cr &= ~(1U << bit);\n\n\trecalc_intercepts(svm);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic inline void clr_cr_intercept(struct vcpu_svm *svm, int bit)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept_cr &= ~(1U << bit);\n\n\trecalc_intercepts(svm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "svm_flush_tlb",
          "args": [
            "&svm->vcpu"
          ],
          "line": 2821
        },
        "resolved": true,
        "details": {
          "function_name": "svm_flush_tlb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "4334-4342",
          "snippet": "static void svm_flush_tlb(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (static_cpu_has(X86_FEATURE_FLUSHBYASID))\n\t\tsvm->vmcb->control.tlb_ctl = TLB_CONTROL_FLUSH_ASID;\n\telse\n\t\tsvm->asid_generation--;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (static_cpu_has(X86_FEATURE_FLUSHBYASID))\n\t\tsvm->vmcb->control.tlb_ctl = TLB_CONTROL_FLUSH_ASID;\n\telse\n\t\tsvm->asid_generation--;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_register_write",
          "args": [
            "&svm->vcpu",
            "VCPU_REGS_RIP",
            "nested_vmcb->save.rip"
          ],
          "line": 2802
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_register_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "18-25",
          "snippet": "static inline void kvm_register_write(struct kvm_vcpu *vcpu,\n\t\t\t\t      enum kvm_reg reg,\n\t\t\t\t      unsigned long val)\n{\n\tvcpu->arch.regs[reg] = val;\n\t__set_bit(reg, (unsigned long *)&vcpu->arch.regs_dirty);\n\t__set_bit(reg, (unsigned long *)&vcpu->arch.regs_avail);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void kvm_register_write(struct kvm_vcpu *vcpu,\n\t\t\t\t      enum kvm_reg reg,\n\t\t\t\t      unsigned long val)\n{\n\tvcpu->arch.regs[reg] = val;\n\t__set_bit(reg, (unsigned long *)&vcpu->arch.regs_dirty);\n\t__set_bit(reg, (unsigned long *)&vcpu->arch.regs_avail);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_mmu_reset_context",
          "args": [
            "&svm->vcpu"
          ],
          "line": 2797
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_reset_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "4230-4234",
          "snippet": "void kvm_mmu_reset_context(struct kvm_vcpu *vcpu)\n{\n\tkvm_mmu_unload(vcpu);\n\tinit_kvm_mmu(vcpu);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nvoid kvm_mmu_reset_context(struct kvm_vcpu *vcpu)\n{\n\tkvm_mmu_unload(vcpu);\n\tinit_kvm_mmu(vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_set_cr3",
          "args": [
            "&svm->vcpu",
            "nested_vmcb->save.cr3"
          ],
          "line": 2794
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_set_cr3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "778-801",
          "snippet": "int kvm_set_cr3(struct kvm_vcpu *vcpu, unsigned long cr3)\n{\n#ifdef CONFIG_X86_64\n\tcr3 &= ~CR3_PCID_INVD;\n#endif\n\n\tif (cr3 == kvm_read_cr3(vcpu) && !pdptrs_changed(vcpu)) {\n\t\tkvm_mmu_sync_roots(vcpu);\n\t\tkvm_make_request(KVM_REQ_TLB_FLUSH, vcpu);\n\t\treturn 0;\n\t}\n\n\tif (is_long_mode(vcpu)) {\n\t\tif (cr3 & CR3_L_MODE_RESERVED_BITS)\n\t\t\treturn 1;\n\t} else if (is_pae(vcpu) && is_paging(vcpu) &&\n\t\t   !load_pdptrs(vcpu, vcpu->arch.walk_mmu, cr3))\n\t\treturn 1;\n\n\tvcpu->arch.cr3 = cr3;\n\t__set_bit(VCPU_EXREG_CR3, (ulong *)&vcpu->arch.regs_avail);\n\tkvm_mmu_new_cr3(vcpu);\n\treturn 0;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nint kvm_set_cr3(struct kvm_vcpu *vcpu, unsigned long cr3)\n{\n#ifdef CONFIG_X86_64\n\tcr3 &= ~CR3_PCID_INVD;\n#endif\n\n\tif (cr3 == kvm_read_cr3(vcpu) && !pdptrs_changed(vcpu)) {\n\t\tkvm_mmu_sync_roots(vcpu);\n\t\tkvm_make_request(KVM_REQ_TLB_FLUSH, vcpu);\n\t\treturn 0;\n\t}\n\n\tif (is_long_mode(vcpu)) {\n\t\tif (cr3 & CR3_L_MODE_RESERVED_BITS)\n\t\t\treturn 1;\n\t} else if (is_pae(vcpu) && is_paging(vcpu) &&\n\t\t   !load_pdptrs(vcpu, vcpu->arch.walk_mmu, cr3))\n\t\treturn 1;\n\n\tvcpu->arch.cr3 = cr3;\n\t__set_bit(VCPU_EXREG_CR3, (ulong *)&vcpu->arch.regs_avail);\n\tkvm_mmu_new_cr3(vcpu);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "svm_set_cr4",
          "args": [
            "&svm->vcpu",
            "nested_vmcb->save.cr4"
          ],
          "line": 2789
        },
        "resolved": true,
        "details": {
          "function_name": "svm_set_cr4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "1813-1831",
          "snippet": "static int svm_set_cr4(struct kvm_vcpu *vcpu, unsigned long cr4)\n{\n\tunsigned long host_cr4_mce = cr4_read_shadow() & X86_CR4_MCE;\n\tunsigned long old_cr4 = to_svm(vcpu)->vmcb->save.cr4;\n\n\tif (cr4 & X86_CR4_VMXE)\n\t\treturn 1;\n\n\tif (npt_enabled && ((old_cr4 ^ cr4) & X86_CR4_PGE))\n\t\tsvm_flush_tlb(vcpu);\n\n\tvcpu->arch.cr4 = cr4;\n\tif (!npt_enabled)\n\t\tcr4 |= X86_CR4_PAE;\n\tcr4 |= host_cr4_mce;\n\tto_svm(vcpu)->vmcb->save.cr4 = cr4;\n\tmark_dirty(to_svm(vcpu)->vmcb, VMCB_CR);\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\n\nstatic int svm_set_cr4(struct kvm_vcpu *vcpu, unsigned long cr4)\n{\n\tunsigned long host_cr4_mce = cr4_read_shadow() & X86_CR4_MCE;\n\tunsigned long old_cr4 = to_svm(vcpu)->vmcb->save.cr4;\n\n\tif (cr4 & X86_CR4_VMXE)\n\t\treturn 1;\n\n\tif (npt_enabled && ((old_cr4 ^ cr4) & X86_CR4_PGE))\n\t\tsvm_flush_tlb(vcpu);\n\n\tvcpu->arch.cr4 = cr4;\n\tif (!npt_enabled)\n\t\tcr4 |= X86_CR4_PAE;\n\tcr4 |= host_cr4_mce;\n\tto_svm(vcpu)->vmcb->save.cr4 = cr4;\n\tmark_dirty(to_svm(vcpu)->vmcb, VMCB_CR);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "svm_set_cr0",
          "args": [
            "&svm->vcpu",
            "nested_vmcb->save.cr0"
          ],
          "line": 2788
        },
        "resolved": true,
        "details": {
          "function_name": "svm_set_cr0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "1777-1811",
          "snippet": "static void svm_set_cr0(struct kvm_vcpu *vcpu, unsigned long cr0)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n#ifdef CONFIG_X86_64\n\tif (vcpu->arch.efer & EFER_LME) {\n\t\tif (!is_paging(vcpu) && (cr0 & X86_CR0_PG)) {\n\t\t\tvcpu->arch.efer |= EFER_LMA;\n\t\t\tsvm->vmcb->save.efer |= EFER_LMA | EFER_LME;\n\t\t}\n\n\t\tif (is_paging(vcpu) && !(cr0 & X86_CR0_PG)) {\n\t\t\tvcpu->arch.efer &= ~EFER_LMA;\n\t\t\tsvm->vmcb->save.efer &= ~(EFER_LMA | EFER_LME);\n\t\t}\n\t}\n#endif\n\tvcpu->arch.cr0 = cr0;\n\n\tif (!npt_enabled)\n\t\tcr0 |= X86_CR0_PG | X86_CR0_WP;\n\n\tif (!vcpu->fpu_active)\n\t\tcr0 |= X86_CR0_TS;\n\t/*\n\t * re-enable caching here because the QEMU bios\n\t * does not do it - this results in some delay at\n\t * reboot\n\t */\n\tif (kvm_check_has_quirk(vcpu->kvm, KVM_X86_QUIRK_CD_NW_CLEARED))\n\t\tcr0 &= ~(X86_CR0_CD | X86_CR0_NW);\n\tsvm->vmcb->save.cr0 = cr0;\n\tmark_dirty(svm->vmcb, VMCB_CR);\n\tupdate_cr0_intercept(svm);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_set_cr0(struct kvm_vcpu *vcpu, unsigned long cr0);",
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_set_cr0(struct kvm_vcpu *vcpu, unsigned long cr0);\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic void svm_set_cr0(struct kvm_vcpu *vcpu, unsigned long cr0)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n#ifdef CONFIG_X86_64\n\tif (vcpu->arch.efer & EFER_LME) {\n\t\tif (!is_paging(vcpu) && (cr0 & X86_CR0_PG)) {\n\t\t\tvcpu->arch.efer |= EFER_LMA;\n\t\t\tsvm->vmcb->save.efer |= EFER_LMA | EFER_LME;\n\t\t}\n\n\t\tif (is_paging(vcpu) && !(cr0 & X86_CR0_PG)) {\n\t\t\tvcpu->arch.efer &= ~EFER_LMA;\n\t\t\tsvm->vmcb->save.efer &= ~(EFER_LMA | EFER_LME);\n\t\t}\n\t}\n#endif\n\tvcpu->arch.cr0 = cr0;\n\n\tif (!npt_enabled)\n\t\tcr0 |= X86_CR0_PG | X86_CR0_WP;\n\n\tif (!vcpu->fpu_active)\n\t\tcr0 |= X86_CR0_TS;\n\t/*\n\t * re-enable caching here because the QEMU bios\n\t * does not do it - this results in some delay at\n\t * reboot\n\t */\n\tif (kvm_check_has_quirk(vcpu->kvm, KVM_X86_QUIRK_CD_NW_CLEARED))\n\t\tcr0 &= ~(X86_CR0_CD | X86_CR0_NW);\n\tsvm->vmcb->save.cr0 = cr0;\n\tmark_dirty(svm->vmcb, VMCB_CR);\n\tupdate_cr0_intercept(svm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "svm_set_efer",
          "args": [
            "&svm->vcpu",
            "nested_vmcb->save.efer"
          ],
          "line": 2787
        },
        "resolved": true,
        "details": {
          "function_name": "svm_set_efer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "535-543",
          "snippet": "static void svm_set_efer(struct kvm_vcpu *vcpu, u64 efer)\n{\n\tvcpu->arch.efer = efer;\n\tif (!npt_enabled && !(efer & EFER_LMA))\n\t\tefer &= ~EFER_LME;\n\n\tto_svm(vcpu)->vmcb->save.efer = efer | EFER_SVME;\n\tmark_dirty(to_svm(vcpu)->vmcb, VMCB_CR);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\n\nstatic void svm_set_efer(struct kvm_vcpu *vcpu, u64 efer)\n{\n\tvcpu->arch.efer = efer;\n\tif (!npt_enabled && !(efer & EFER_LMA))\n\t\tefer &= ~EFER_LME;\n\n\tto_svm(vcpu)->vmcb->save.efer = efer | EFER_SVME;\n\tmark_dirty(to_svm(vcpu)->vmcb, VMCB_CR);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_set_rflags",
          "args": [
            "&svm->vcpu",
            "nested_vmcb->save.rflags"
          ],
          "line": 2786
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_set_rflags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "8182-8186",
          "snippet": "void kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags)\n{\n\t__kvm_set_rflags(vcpu, rflags);\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void __kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void __kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags);\n\nvoid kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags)\n{\n\t__kvm_set_rflags(vcpu, rflags);\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nested_svm_init_mmu_context",
          "args": [
            "&svm->vcpu"
          ],
          "line": 2776
        },
        "resolved": true,
        "details": {
          "function_name": "nested_svm_init_mmu_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "2228-2239",
          "snippet": "static void nested_svm_init_mmu_context(struct kvm_vcpu *vcpu)\n{\n\tWARN_ON(mmu_is_nested(vcpu));\n\tkvm_init_shadow_mmu(vcpu);\n\tvcpu->arch.mmu.set_cr3           = nested_svm_set_tdp_cr3;\n\tvcpu->arch.mmu.get_cr3           = nested_svm_get_tdp_cr3;\n\tvcpu->arch.mmu.get_pdptr         = nested_svm_get_tdp_pdptr;\n\tvcpu->arch.mmu.inject_page_fault = nested_svm_inject_npf_exit;\n\tvcpu->arch.mmu.shadow_root_level = get_npt_level();\n\treset_shadow_zero_bits_mask(vcpu, &vcpu->arch.mmu);\n\tvcpu->arch.walk_mmu              = &vcpu->arch.nested_mmu;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\n\nstatic void nested_svm_init_mmu_context(struct kvm_vcpu *vcpu)\n{\n\tWARN_ON(mmu_is_nested(vcpu));\n\tkvm_init_shadow_mmu(vcpu);\n\tvcpu->arch.mmu.set_cr3           = nested_svm_set_tdp_cr3;\n\tvcpu->arch.mmu.get_cr3           = nested_svm_get_tdp_cr3;\n\tvcpu->arch.mmu.get_pdptr         = nested_svm_get_tdp_pdptr;\n\tvcpu->arch.mmu.inject_page_fault = nested_svm_inject_npf_exit;\n\tvcpu->arch.mmu.shadow_root_level = get_npt_level();\n\treset_shadow_zero_bits_mask(vcpu, &vcpu->arch.mmu);\n\tvcpu->arch.walk_mmu              = &vcpu->arch.nested_mmu;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_mmu_unload",
          "args": [
            "&svm->vcpu"
          ],
          "line": 2774
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_unload",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "4255-4259",
          "snippet": "void kvm_mmu_unload(struct kvm_vcpu *vcpu)\n{\n\tmmu_free_roots(vcpu);\n\tWARN_ON(VALID_PAGE(vcpu->arch.mmu.root_hpa));\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nvoid kvm_mmu_unload(struct kvm_vcpu *vcpu)\n{\n\tmmu_free_roots(vcpu);\n\tWARN_ON(VALID_PAGE(vcpu->arch.mmu.root_hpa));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_get_rflags",
          "args": [
            "&svm->vcpu"
          ],
          "line": 2768
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_get_rflags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "8163-8171",
          "snippet": "unsigned long kvm_get_rflags(struct kvm_vcpu *vcpu)\n{\n\tunsigned long rflags;\n\n\trflags = kvm_x86_ops->get_rflags(vcpu);\n\tif (vcpu->guest_debug & KVM_GUESTDBG_SINGLESTEP)\n\t\trflags &= ~X86_EFLAGS_TF;\n\treturn rflags;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void __kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags);",
            "struct kvm_x86_ops *kvm_x86_ops"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void __kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nunsigned long kvm_get_rflags(struct kvm_vcpu *vcpu)\n{\n\tunsigned long rflags;\n\n\trflags = kvm_x86_ops->get_rflags(vcpu);\n\tif (vcpu->guest_debug & KVM_GUESTDBG_SINGLESTEP)\n\t\trflags &= ~X86_EFLAGS_TF;\n\treturn rflags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_vmcb_control_area",
          "args": [
            "hsave",
            "vmcb"
          ],
          "line": 2766
        },
        "resolved": true,
        "details": {
          "function_name": "copy_vmcb_control_area",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "2504-2532",
          "snippet": "static inline void copy_vmcb_control_area(struct vmcb *dst_vmcb, struct vmcb *from_vmcb)\n{\n\tstruct vmcb_control_area *dst  = &dst_vmcb->control;\n\tstruct vmcb_control_area *from = &from_vmcb->control;\n\n\tdst->intercept_cr         = from->intercept_cr;\n\tdst->intercept_dr         = from->intercept_dr;\n\tdst->intercept_exceptions = from->intercept_exceptions;\n\tdst->intercept            = from->intercept;\n\tdst->iopm_base_pa         = from->iopm_base_pa;\n\tdst->msrpm_base_pa        = from->msrpm_base_pa;\n\tdst->tsc_offset           = from->tsc_offset;\n\tdst->asid                 = from->asid;\n\tdst->tlb_ctl              = from->tlb_ctl;\n\tdst->int_ctl              = from->int_ctl;\n\tdst->int_vector           = from->int_vector;\n\tdst->int_state            = from->int_state;\n\tdst->exit_code            = from->exit_code;\n\tdst->exit_code_hi         = from->exit_code_hi;\n\tdst->exit_info_1          = from->exit_info_1;\n\tdst->exit_info_2          = from->exit_info_2;\n\tdst->exit_int_info        = from->exit_int_info;\n\tdst->exit_int_info_err    = from->exit_int_info_err;\n\tdst->nested_ctl           = from->nested_ctl;\n\tdst->event_inj            = from->event_inj;\n\tdst->event_inj_err        = from->event_inj_err;\n\tdst->nested_cr3           = from->nested_cr3;\n\tdst->lbr_ctl              = from->lbr_ctl;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic inline void copy_vmcb_control_area(struct vmcb *dst_vmcb, struct vmcb *from_vmcb)\n{\n\tstruct vmcb_control_area *dst  = &dst_vmcb->control;\n\tstruct vmcb_control_area *from = &from_vmcb->control;\n\n\tdst->intercept_cr         = from->intercept_cr;\n\tdst->intercept_dr         = from->intercept_dr;\n\tdst->intercept_exceptions = from->intercept_exceptions;\n\tdst->intercept            = from->intercept;\n\tdst->iopm_base_pa         = from->iopm_base_pa;\n\tdst->msrpm_base_pa        = from->msrpm_base_pa;\n\tdst->tsc_offset           = from->tsc_offset;\n\tdst->asid                 = from->asid;\n\tdst->tlb_ctl              = from->tlb_ctl;\n\tdst->int_ctl              = from->int_ctl;\n\tdst->int_vector           = from->int_vector;\n\tdst->int_state            = from->int_state;\n\tdst->exit_code            = from->exit_code;\n\tdst->exit_code_hi         = from->exit_code_hi;\n\tdst->exit_info_1          = from->exit_info_1;\n\tdst->exit_info_2          = from->exit_info_2;\n\tdst->exit_int_info        = from->exit_int_info;\n\tdst->exit_int_info_err    = from->exit_int_info_err;\n\tdst->nested_ctl           = from->nested_ctl;\n\tdst->event_inj            = from->event_inj;\n\tdst->event_inj_err        = from->event_inj_err;\n\tdst->nested_cr3           = from->nested_cr3;\n\tdst->lbr_ctl              = from->lbr_ctl;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_read_cr3",
          "args": [
            "&svm->vcpu"
          ],
          "line": 2764
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_read_cr3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "69-74",
          "snippet": "static inline ulong kvm_read_cr3(struct kvm_vcpu *vcpu)\n{\n\tif (!test_bit(VCPU_EXREG_CR3, (ulong *)&vcpu->arch.regs_avail))\n\t\tkvm_x86_ops->decache_cr3(vcpu);\n\treturn vcpu->arch.cr3;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline ulong kvm_read_cr3(struct kvm_vcpu *vcpu)\n{\n\tif (!test_bit(VCPU_EXREG_CR3, (ulong *)&vcpu->arch.regs_avail))\n\t\tkvm_x86_ops->decache_cr3(vcpu);\n\treturn vcpu->arch.cr3;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_rip_read",
          "args": [
            "&svm->vcpu"
          ],
          "line": 2758
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_rip_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "27-30",
          "snippet": "static inline unsigned long kvm_rip_read(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_register_read(vcpu, VCPU_REGS_RIP);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline unsigned long kvm_rip_read(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_register_read(vcpu, VCPU_REGS_RIP);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_read_cr0",
          "args": [
            "&svm->vcpu"
          ],
          "line": 2755
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_read_cr0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "56-59",
          "snippet": "static inline ulong kvm_read_cr0(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_read_cr0_bits(vcpu, ~0UL);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline ulong kvm_read_cr0(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_read_cr0_bits(vcpu, ~0UL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_clear_interrupt_queue",
          "args": [
            "&svm->vcpu"
          ],
          "line": 2742
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_clear_interrupt_queue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.h",
          "lines": "22-25",
          "snippet": "static inline void kvm_clear_interrupt_queue(struct kvm_vcpu *vcpu)\n{\n\tvcpu->arch.interrupt.pending = false;\n}",
          "includes": [
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline void kvm_clear_interrupt_queue(struct kvm_vcpu *vcpu)\n{\n\tvcpu->arch.interrupt.pending = false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_clear_exception_queue",
          "args": [
            "&svm->vcpu"
          ],
          "line": 2741
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_clear_exception_queue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.h",
          "lines": "9-12",
          "snippet": "static inline void kvm_clear_exception_queue(struct kvm_vcpu *vcpu)\n{\n\tvcpu->arch.exception.pending = false;\n}",
          "includes": [
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline void kvm_clear_exception_queue(struct kvm_vcpu *vcpu)\n{\n\tvcpu->arch.exception.pending = false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_kvm_nested_intercepts",
          "args": [
            "nested_vmcb->control.intercept_cr & 0xffff",
            "nested_vmcb->control.intercept_cr >> 16",
            "nested_vmcb->control.intercept_exceptions",
            "nested_vmcb->control.intercept"
          ],
          "line": 2735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_kvm_nested_vmrun",
          "args": [
            "svm->vmcb->save.rip",
            "vmcb_gpa",
            "nested_vmcb->save.rip",
            "nested_vmcb->control.int_ctl",
            "nested_vmcb->control.event_inj",
            "nested_vmcb->control.nested_ctl"
          ],
          "line": 2729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nested_vmcb_checks",
          "args": [
            "nested_vmcb"
          ],
          "line": 2718
        },
        "resolved": true,
        "details": {
          "function_name": "nested_vmcb_checks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "2690-2702",
          "snippet": "static bool nested_vmcb_checks(struct vmcb *vmcb)\n{\n\tif ((vmcb->control.intercept & (1ULL << INTERCEPT_VMRUN)) == 0)\n\t\treturn false;\n\n\tif (vmcb->control.asid == 0)\n\t\treturn false;\n\n\tif (vmcb->control.nested_ctl && !npt_enabled)\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic bool nested_vmcb_checks(struct vmcb *vmcb)\n{\n\tif ((vmcb->control.intercept & (1ULL << INTERCEPT_VMRUN)) == 0)\n\t\treturn false;\n\n\tif (vmcb->control.asid == 0)\n\t\treturn false;\n\n\tif (vmcb->control.nested_ctl && !npt_enabled)\n\t\treturn false;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nested_svm_map",
          "args": [
            "svm",
            "svm->vmcb->save.rax",
            "&page"
          ],
          "line": 2714
        },
        "resolved": true,
        "details": {
          "function_name": "nested_svm_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "2336-2354",
          "snippet": "static void *nested_svm_map(struct vcpu_svm *svm, u64 gpa, struct page **_page)\n{\n\tstruct page *page;\n\n\tmight_sleep();\n\n\tpage = kvm_vcpu_gfn_to_page(&svm->vcpu, gpa >> PAGE_SHIFT);\n\tif (is_error_page(page))\n\t\tgoto error;\n\n\t*_page = page;\n\n\treturn kmap(page);\n\nerror:\n\tkvm_inject_gp(&svm->vcpu, 0);\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic void *nested_svm_map(struct vcpu_svm *svm, u64 gpa, struct page **_page)\n{\n\tstruct page *page;\n\n\tmight_sleep();\n\n\tpage = kvm_vcpu_gfn_to_page(&svm->vcpu, gpa >> PAGE_SHIFT);\n\tif (is_error_page(page))\n\t\tgoto error;\n\n\t*_page = page;\n\n\treturn kmap(page);\n\nerror:\n\tkvm_inject_gp(&svm->vcpu, 0);\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int nested = true;\nstatic void svm_set_cr0(struct kvm_vcpu *vcpu, unsigned long cr0);\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic bool nested_svm_vmrun(struct vcpu_svm *svm)\n{\n\tstruct vmcb *nested_vmcb;\n\tstruct vmcb *hsave = svm->nested.hsave;\n\tstruct vmcb *vmcb = svm->vmcb;\n\tstruct page *page;\n\tu64 vmcb_gpa;\n\n\tvmcb_gpa = svm->vmcb->save.rax;\n\n\tnested_vmcb = nested_svm_map(svm, svm->vmcb->save.rax, &page);\n\tif (!nested_vmcb)\n\t\treturn false;\n\n\tif (!nested_vmcb_checks(nested_vmcb)) {\n\t\tnested_vmcb->control.exit_code    = SVM_EXIT_ERR;\n\t\tnested_vmcb->control.exit_code_hi = 0;\n\t\tnested_vmcb->control.exit_info_1  = 0;\n\t\tnested_vmcb->control.exit_info_2  = 0;\n\n\t\tnested_svm_unmap(page);\n\n\t\treturn false;\n\t}\n\n\ttrace_kvm_nested_vmrun(svm->vmcb->save.rip, vmcb_gpa,\n\t\t\t       nested_vmcb->save.rip,\n\t\t\t       nested_vmcb->control.int_ctl,\n\t\t\t       nested_vmcb->control.event_inj,\n\t\t\t       nested_vmcb->control.nested_ctl);\n\n\ttrace_kvm_nested_intercepts(nested_vmcb->control.intercept_cr & 0xffff,\n\t\t\t\t    nested_vmcb->control.intercept_cr >> 16,\n\t\t\t\t    nested_vmcb->control.intercept_exceptions,\n\t\t\t\t    nested_vmcb->control.intercept);\n\n\t/* Clear internal status */\n\tkvm_clear_exception_queue(&svm->vcpu);\n\tkvm_clear_interrupt_queue(&svm->vcpu);\n\n\t/*\n\t * Save the old vmcb, so we don't need to pick what we save, but can\n\t * restore everything when a VMEXIT occurs\n\t */\n\thsave->save.es     = vmcb->save.es;\n\thsave->save.cs     = vmcb->save.cs;\n\thsave->save.ss     = vmcb->save.ss;\n\thsave->save.ds     = vmcb->save.ds;\n\thsave->save.gdtr   = vmcb->save.gdtr;\n\thsave->save.idtr   = vmcb->save.idtr;\n\thsave->save.efer   = svm->vcpu.arch.efer;\n\thsave->save.cr0    = kvm_read_cr0(&svm->vcpu);\n\thsave->save.cr4    = svm->vcpu.arch.cr4;\n\thsave->save.rflags = kvm_get_rflags(&svm->vcpu);\n\thsave->save.rip    = kvm_rip_read(&svm->vcpu);\n\thsave->save.rsp    = vmcb->save.rsp;\n\thsave->save.rax    = vmcb->save.rax;\n\tif (npt_enabled)\n\t\thsave->save.cr3    = vmcb->save.cr3;\n\telse\n\t\thsave->save.cr3    = kvm_read_cr3(&svm->vcpu);\n\n\tcopy_vmcb_control_area(hsave, vmcb);\n\n\tif (kvm_get_rflags(&svm->vcpu) & X86_EFLAGS_IF)\n\t\tsvm->vcpu.arch.hflags |= HF_HIF_MASK;\n\telse\n\t\tsvm->vcpu.arch.hflags &= ~HF_HIF_MASK;\n\n\tif (nested_vmcb->control.nested_ctl) {\n\t\tkvm_mmu_unload(&svm->vcpu);\n\t\tsvm->nested.nested_cr3 = nested_vmcb->control.nested_cr3;\n\t\tnested_svm_init_mmu_context(&svm->vcpu);\n\t}\n\n\t/* Load the nested guest state */\n\tsvm->vmcb->save.es = nested_vmcb->save.es;\n\tsvm->vmcb->save.cs = nested_vmcb->save.cs;\n\tsvm->vmcb->save.ss = nested_vmcb->save.ss;\n\tsvm->vmcb->save.ds = nested_vmcb->save.ds;\n\tsvm->vmcb->save.gdtr = nested_vmcb->save.gdtr;\n\tsvm->vmcb->save.idtr = nested_vmcb->save.idtr;\n\tkvm_set_rflags(&svm->vcpu, nested_vmcb->save.rflags);\n\tsvm_set_efer(&svm->vcpu, nested_vmcb->save.efer);\n\tsvm_set_cr0(&svm->vcpu, nested_vmcb->save.cr0);\n\tsvm_set_cr4(&svm->vcpu, nested_vmcb->save.cr4);\n\tif (npt_enabled) {\n\t\tsvm->vmcb->save.cr3 = nested_vmcb->save.cr3;\n\t\tsvm->vcpu.arch.cr3 = nested_vmcb->save.cr3;\n\t} else\n\t\t(void)kvm_set_cr3(&svm->vcpu, nested_vmcb->save.cr3);\n\n\t/* Guest paging mode is active - reset mmu */\n\tkvm_mmu_reset_context(&svm->vcpu);\n\n\tsvm->vmcb->save.cr2 = svm->vcpu.arch.cr2 = nested_vmcb->save.cr2;\n\tkvm_register_write(&svm->vcpu, VCPU_REGS_RAX, nested_vmcb->save.rax);\n\tkvm_register_write(&svm->vcpu, VCPU_REGS_RSP, nested_vmcb->save.rsp);\n\tkvm_register_write(&svm->vcpu, VCPU_REGS_RIP, nested_vmcb->save.rip);\n\n\t/* In case we don't even reach vcpu_run, the fields are not updated */\n\tsvm->vmcb->save.rax = nested_vmcb->save.rax;\n\tsvm->vmcb->save.rsp = nested_vmcb->save.rsp;\n\tsvm->vmcb->save.rip = nested_vmcb->save.rip;\n\tsvm->vmcb->save.dr7 = nested_vmcb->save.dr7;\n\tsvm->vmcb->save.dr6 = nested_vmcb->save.dr6;\n\tsvm->vmcb->save.cpl = nested_vmcb->save.cpl;\n\n\tsvm->nested.vmcb_msrpm = nested_vmcb->control.msrpm_base_pa & ~0x0fffULL;\n\tsvm->nested.vmcb_iopm  = nested_vmcb->control.iopm_base_pa  & ~0x0fffULL;\n\n\t/* cache intercepts */\n\tsvm->nested.intercept_cr         = nested_vmcb->control.intercept_cr;\n\tsvm->nested.intercept_dr         = nested_vmcb->control.intercept_dr;\n\tsvm->nested.intercept_exceptions = nested_vmcb->control.intercept_exceptions;\n\tsvm->nested.intercept            = nested_vmcb->control.intercept;\n\n\tsvm_flush_tlb(&svm->vcpu);\n\tsvm->vmcb->control.int_ctl = nested_vmcb->control.int_ctl | V_INTR_MASKING_MASK;\n\tif (nested_vmcb->control.int_ctl & V_INTR_MASKING_MASK)\n\t\tsvm->vcpu.arch.hflags |= HF_VINTR_MASK;\n\telse\n\t\tsvm->vcpu.arch.hflags &= ~HF_VINTR_MASK;\n\n\tif (svm->vcpu.arch.hflags & HF_VINTR_MASK) {\n\t\t/* We only want the cr8 intercept bits of the guest */\n\t\tclr_cr_intercept(svm, INTERCEPT_CR8_READ);\n\t\tclr_cr_intercept(svm, INTERCEPT_CR8_WRITE);\n\t}\n\n\t/* We don't want to see VMMCALLs from a nested guest */\n\tclr_intercept(svm, INTERCEPT_VMMCALL);\n\n\tsvm->vmcb->control.lbr_ctl = nested_vmcb->control.lbr_ctl;\n\tsvm->vmcb->control.int_vector = nested_vmcb->control.int_vector;\n\tsvm->vmcb->control.int_state = nested_vmcb->control.int_state;\n\tsvm->vmcb->control.tsc_offset += nested_vmcb->control.tsc_offset;\n\tsvm->vmcb->control.event_inj = nested_vmcb->control.event_inj;\n\tsvm->vmcb->control.event_inj_err = nested_vmcb->control.event_inj_err;\n\n\tnested_svm_unmap(page);\n\n\t/* Enter Guest-Mode */\n\tenter_guest_mode(&svm->vcpu);\n\n\t/*\n\t * Merge guest and host intercepts - must be called  with vcpu in\n\t * guest-mode to take affect here\n\t */\n\trecalc_intercepts(svm);\n\n\tsvm->nested.vmcb = vmcb_gpa;\n\n\tenable_gif(svm);\n\n\tmark_all_dirty(svm->vmcb);\n\n\treturn true;\n}"
  },
  {
    "function_name": "nested_vmcb_checks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "2690-2702",
    "snippet": "static bool nested_vmcb_checks(struct vmcb *vmcb)\n{\n\tif ((vmcb->control.intercept & (1ULL << INTERCEPT_VMRUN)) == 0)\n\t\treturn false;\n\n\tif (vmcb->control.asid == 0)\n\t\treturn false;\n\n\tif (vmcb->control.nested_ctl && !npt_enabled)\n\t\treturn false;\n\n\treturn true;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic bool nested_vmcb_checks(struct vmcb *vmcb)\n{\n\tif ((vmcb->control.intercept & (1ULL << INTERCEPT_VMRUN)) == 0)\n\t\treturn false;\n\n\tif (vmcb->control.asid == 0)\n\t\treturn false;\n\n\tif (vmcb->control.nested_ctl && !npt_enabled)\n\t\treturn false;\n\n\treturn true;\n}"
  },
  {
    "function_name": "nested_svm_vmrun_msrpm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "2657-2688",
    "snippet": "static bool nested_svm_vmrun_msrpm(struct vcpu_svm *svm)\n{\n\t/*\n\t * This function merges the msr permission bitmaps of kvm and the\n\t * nested vmcb. It is optimized in that it only merges the parts where\n\t * the kvm msr permission bitmap may contain zero bits\n\t */\n\tint i;\n\n\tif (!(svm->nested.intercept & (1ULL << INTERCEPT_MSR_PROT)))\n\t\treturn true;\n\n\tfor (i = 0; i < MSRPM_OFFSETS; i++) {\n\t\tu32 value, p;\n\t\tu64 offset;\n\n\t\tif (msrpm_offsets[i] == 0xffffffff)\n\t\t\tbreak;\n\n\t\tp      = msrpm_offsets[i];\n\t\toffset = svm->nested.vmcb_msrpm + (p * 4);\n\n\t\tif (kvm_vcpu_read_guest(&svm->vcpu, offset, &value, 4))\n\t\t\treturn false;\n\n\t\tsvm->nested.msrpm[p] = svm->msrpm[p] | value;\n\t}\n\n\tsvm->vmcb->control.msrpm_base_pa = __pa(svm->nested.msrpm);\n\n\treturn true;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define MSRPM_OFFSETS\t16"
    ],
    "globals_used": [
      "static u32 msrpm_offsets[MSRPM_OFFSETS]",
      "static int nested = true;",
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__pa",
          "args": [
            "svm->nested.msrpm"
          ],
          "line": 2685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_read_guest",
          "args": [
            "&svm->vcpu",
            "offset",
            "&value",
            "4"
          ],
          "line": 2679
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define MSRPM_OFFSETS\t16\n\nstatic u32 msrpm_offsets[MSRPM_OFFSETS];\nstatic int nested = true;\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic bool nested_svm_vmrun_msrpm(struct vcpu_svm *svm)\n{\n\t/*\n\t * This function merges the msr permission bitmaps of kvm and the\n\t * nested vmcb. It is optimized in that it only merges the parts where\n\t * the kvm msr permission bitmap may contain zero bits\n\t */\n\tint i;\n\n\tif (!(svm->nested.intercept & (1ULL << INTERCEPT_MSR_PROT)))\n\t\treturn true;\n\n\tfor (i = 0; i < MSRPM_OFFSETS; i++) {\n\t\tu32 value, p;\n\t\tu64 offset;\n\n\t\tif (msrpm_offsets[i] == 0xffffffff)\n\t\t\tbreak;\n\n\t\tp      = msrpm_offsets[i];\n\t\toffset = svm->nested.vmcb_msrpm + (p * 4);\n\n\t\tif (kvm_vcpu_read_guest(&svm->vcpu, offset, &value, 4))\n\t\t\treturn false;\n\n\t\tsvm->nested.msrpm[p] = svm->msrpm[p] | value;\n\t}\n\n\tsvm->vmcb->control.msrpm_base_pa = __pa(svm->nested.msrpm);\n\n\treturn true;\n}"
  },
  {
    "function_name": "nested_svm_vmexit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "2534-2655",
    "snippet": "static int nested_svm_vmexit(struct vcpu_svm *svm)\n{\n\tstruct vmcb *nested_vmcb;\n\tstruct vmcb *hsave = svm->nested.hsave;\n\tstruct vmcb *vmcb = svm->vmcb;\n\tstruct page *page;\n\n\ttrace_kvm_nested_vmexit_inject(vmcb->control.exit_code,\n\t\t\t\t       vmcb->control.exit_info_1,\n\t\t\t\t       vmcb->control.exit_info_2,\n\t\t\t\t       vmcb->control.exit_int_info,\n\t\t\t\t       vmcb->control.exit_int_info_err,\n\t\t\t\t       KVM_ISA_SVM);\n\n\tnested_vmcb = nested_svm_map(svm, svm->nested.vmcb, &page);\n\tif (!nested_vmcb)\n\t\treturn 1;\n\n\t/* Exit Guest-Mode */\n\tleave_guest_mode(&svm->vcpu);\n\tsvm->nested.vmcb = 0;\n\n\t/* Give the current vmcb to the guest */\n\tdisable_gif(svm);\n\n\tnested_vmcb->save.es     = vmcb->save.es;\n\tnested_vmcb->save.cs     = vmcb->save.cs;\n\tnested_vmcb->save.ss     = vmcb->save.ss;\n\tnested_vmcb->save.ds     = vmcb->save.ds;\n\tnested_vmcb->save.gdtr   = vmcb->save.gdtr;\n\tnested_vmcb->save.idtr   = vmcb->save.idtr;\n\tnested_vmcb->save.efer   = svm->vcpu.arch.efer;\n\tnested_vmcb->save.cr0    = kvm_read_cr0(&svm->vcpu);\n\tnested_vmcb->save.cr3    = kvm_read_cr3(&svm->vcpu);\n\tnested_vmcb->save.cr2    = vmcb->save.cr2;\n\tnested_vmcb->save.cr4    = svm->vcpu.arch.cr4;\n\tnested_vmcb->save.rflags = kvm_get_rflags(&svm->vcpu);\n\tnested_vmcb->save.rip    = vmcb->save.rip;\n\tnested_vmcb->save.rsp    = vmcb->save.rsp;\n\tnested_vmcb->save.rax    = vmcb->save.rax;\n\tnested_vmcb->save.dr7    = vmcb->save.dr7;\n\tnested_vmcb->save.dr6    = vmcb->save.dr6;\n\tnested_vmcb->save.cpl    = vmcb->save.cpl;\n\n\tnested_vmcb->control.int_ctl           = vmcb->control.int_ctl;\n\tnested_vmcb->control.int_vector        = vmcb->control.int_vector;\n\tnested_vmcb->control.int_state         = vmcb->control.int_state;\n\tnested_vmcb->control.exit_code         = vmcb->control.exit_code;\n\tnested_vmcb->control.exit_code_hi      = vmcb->control.exit_code_hi;\n\tnested_vmcb->control.exit_info_1       = vmcb->control.exit_info_1;\n\tnested_vmcb->control.exit_info_2       = vmcb->control.exit_info_2;\n\tnested_vmcb->control.exit_int_info     = vmcb->control.exit_int_info;\n\tnested_vmcb->control.exit_int_info_err = vmcb->control.exit_int_info_err;\n\n\tif (svm->nrips_enabled)\n\t\tnested_vmcb->control.next_rip  = vmcb->control.next_rip;\n\n\t/*\n\t * If we emulate a VMRUN/#VMEXIT in the same host #vmexit cycle we have\n\t * to make sure that we do not lose injected events. So check event_inj\n\t * here and copy it to exit_int_info if it is valid.\n\t * Exit_int_info and event_inj can't be both valid because the case\n\t * below only happens on a VMRUN instruction intercept which has\n\t * no valid exit_int_info set.\n\t */\n\tif (vmcb->control.event_inj & SVM_EVTINJ_VALID) {\n\t\tstruct vmcb_control_area *nc = &nested_vmcb->control;\n\n\t\tnc->exit_int_info     = vmcb->control.event_inj;\n\t\tnc->exit_int_info_err = vmcb->control.event_inj_err;\n\t}\n\n\tnested_vmcb->control.tlb_ctl           = 0;\n\tnested_vmcb->control.event_inj         = 0;\n\tnested_vmcb->control.event_inj_err     = 0;\n\n\t/* We always set V_INTR_MASKING and remember the old value in hflags */\n\tif (!(svm->vcpu.arch.hflags & HF_VINTR_MASK))\n\t\tnested_vmcb->control.int_ctl &= ~V_INTR_MASKING_MASK;\n\n\t/* Restore the original control entries */\n\tcopy_vmcb_control_area(vmcb, hsave);\n\n\tkvm_clear_exception_queue(&svm->vcpu);\n\tkvm_clear_interrupt_queue(&svm->vcpu);\n\n\tsvm->nested.nested_cr3 = 0;\n\n\t/* Restore selected save entries */\n\tsvm->vmcb->save.es = hsave->save.es;\n\tsvm->vmcb->save.cs = hsave->save.cs;\n\tsvm->vmcb->save.ss = hsave->save.ss;\n\tsvm->vmcb->save.ds = hsave->save.ds;\n\tsvm->vmcb->save.gdtr = hsave->save.gdtr;\n\tsvm->vmcb->save.idtr = hsave->save.idtr;\n\tkvm_set_rflags(&svm->vcpu, hsave->save.rflags);\n\tsvm_set_efer(&svm->vcpu, hsave->save.efer);\n\tsvm_set_cr0(&svm->vcpu, hsave->save.cr0 | X86_CR0_PE);\n\tsvm_set_cr4(&svm->vcpu, hsave->save.cr4);\n\tif (npt_enabled) {\n\t\tsvm->vmcb->save.cr3 = hsave->save.cr3;\n\t\tsvm->vcpu.arch.cr3 = hsave->save.cr3;\n\t} else {\n\t\t(void)kvm_set_cr3(&svm->vcpu, hsave->save.cr3);\n\t}\n\tkvm_register_write(&svm->vcpu, VCPU_REGS_RAX, hsave->save.rax);\n\tkvm_register_write(&svm->vcpu, VCPU_REGS_RSP, hsave->save.rsp);\n\tkvm_register_write(&svm->vcpu, VCPU_REGS_RIP, hsave->save.rip);\n\tsvm->vmcb->save.dr7 = 0;\n\tsvm->vmcb->save.cpl = 0;\n\tsvm->vmcb->control.exit_int_info = 0;\n\n\tmark_all_dirty(svm->vmcb);\n\n\tnested_svm_unmap(page);\n\n\tnested_svm_uninit_mmu_context(&svm->vcpu);\n\tkvm_mmu_reset_context(&svm->vcpu);\n\tkvm_mmu_load(&svm->vcpu);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int nested = true;",
      "static void svm_set_cr0(struct kvm_vcpu *vcpu, unsigned long cr0);",
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_mmu_load",
          "args": [
            "&svm->vcpu"
          ],
          "line": 2652
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_load",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "4237-4252",
          "snippet": "int kvm_mmu_load(struct kvm_vcpu *vcpu)\n{\n\tint r;\n\n\tr = mmu_topup_memory_caches(vcpu);\n\tif (r)\n\t\tgoto out;\n\tr = mmu_alloc_roots(vcpu);\n\tkvm_mmu_sync_roots(vcpu);\n\tif (r)\n\t\tgoto out;\n\t/* set_cr3() should ensure TLB has been flushed */\n\tvcpu->arch.mmu.set_cr3(vcpu, vcpu->arch.mmu.root_hpa);\nout:\n\treturn r;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nint kvm_mmu_load(struct kvm_vcpu *vcpu)\n{\n\tint r;\n\n\tr = mmu_topup_memory_caches(vcpu);\n\tif (r)\n\t\tgoto out;\n\tr = mmu_alloc_roots(vcpu);\n\tkvm_mmu_sync_roots(vcpu);\n\tif (r)\n\t\tgoto out;\n\t/* set_cr3() should ensure TLB has been flushed */\n\tvcpu->arch.mmu.set_cr3(vcpu, vcpu->arch.mmu.root_hpa);\nout:\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_mmu_reset_context",
          "args": [
            "&svm->vcpu"
          ],
          "line": 2651
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_reset_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "4230-4234",
          "snippet": "void kvm_mmu_reset_context(struct kvm_vcpu *vcpu)\n{\n\tkvm_mmu_unload(vcpu);\n\tinit_kvm_mmu(vcpu);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nvoid kvm_mmu_reset_context(struct kvm_vcpu *vcpu)\n{\n\tkvm_mmu_unload(vcpu);\n\tinit_kvm_mmu(vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nested_svm_uninit_mmu_context",
          "args": [
            "&svm->vcpu"
          ],
          "line": 2650
        },
        "resolved": true,
        "details": {
          "function_name": "nested_svm_uninit_mmu_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "2241-2244",
          "snippet": "static void nested_svm_uninit_mmu_context(struct kvm_vcpu *vcpu)\n{\n\tvcpu->arch.walk_mmu = &vcpu->arch.mmu;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\n\nstatic void nested_svm_uninit_mmu_context(struct kvm_vcpu *vcpu)\n{\n\tvcpu->arch.walk_mmu = &vcpu->arch.mmu;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nested_svm_unmap",
          "args": [
            "page"
          ],
          "line": 2648
        },
        "resolved": true,
        "details": {
          "function_name": "nested_svm_unmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "2356-2360",
          "snippet": "static void nested_svm_unmap(struct page *page)\n{\n\tkunmap(page);\n\tkvm_release_page_dirty(page);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void nested_svm_unmap(struct page *page)\n{\n\tkunmap(page);\n\tkvm_release_page_dirty(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_all_dirty",
          "args": [
            "svm->vmcb"
          ],
          "line": 2646
        },
        "resolved": true,
        "details": {
          "function_name": "mark_all_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "278-281",
          "snippet": "static inline void mark_all_dirty(struct vmcb *vmcb)\n{\n\tvmcb->control.clean = 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic inline void mark_all_dirty(struct vmcb *vmcb)\n{\n\tvmcb->control.clean = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_register_write",
          "args": [
            "&svm->vcpu",
            "VCPU_REGS_RIP",
            "hsave->save.rip"
          ],
          "line": 2641
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_register_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "18-25",
          "snippet": "static inline void kvm_register_write(struct kvm_vcpu *vcpu,\n\t\t\t\t      enum kvm_reg reg,\n\t\t\t\t      unsigned long val)\n{\n\tvcpu->arch.regs[reg] = val;\n\t__set_bit(reg, (unsigned long *)&vcpu->arch.regs_dirty);\n\t__set_bit(reg, (unsigned long *)&vcpu->arch.regs_avail);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void kvm_register_write(struct kvm_vcpu *vcpu,\n\t\t\t\t      enum kvm_reg reg,\n\t\t\t\t      unsigned long val)\n{\n\tvcpu->arch.regs[reg] = val;\n\t__set_bit(reg, (unsigned long *)&vcpu->arch.regs_dirty);\n\t__set_bit(reg, (unsigned long *)&vcpu->arch.regs_avail);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_set_cr3",
          "args": [
            "&svm->vcpu",
            "hsave->save.cr3"
          ],
          "line": 2637
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_set_cr3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "778-801",
          "snippet": "int kvm_set_cr3(struct kvm_vcpu *vcpu, unsigned long cr3)\n{\n#ifdef CONFIG_X86_64\n\tcr3 &= ~CR3_PCID_INVD;\n#endif\n\n\tif (cr3 == kvm_read_cr3(vcpu) && !pdptrs_changed(vcpu)) {\n\t\tkvm_mmu_sync_roots(vcpu);\n\t\tkvm_make_request(KVM_REQ_TLB_FLUSH, vcpu);\n\t\treturn 0;\n\t}\n\n\tif (is_long_mode(vcpu)) {\n\t\tif (cr3 & CR3_L_MODE_RESERVED_BITS)\n\t\t\treturn 1;\n\t} else if (is_pae(vcpu) && is_paging(vcpu) &&\n\t\t   !load_pdptrs(vcpu, vcpu->arch.walk_mmu, cr3))\n\t\treturn 1;\n\n\tvcpu->arch.cr3 = cr3;\n\t__set_bit(VCPU_EXREG_CR3, (ulong *)&vcpu->arch.regs_avail);\n\tkvm_mmu_new_cr3(vcpu);\n\treturn 0;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nint kvm_set_cr3(struct kvm_vcpu *vcpu, unsigned long cr3)\n{\n#ifdef CONFIG_X86_64\n\tcr3 &= ~CR3_PCID_INVD;\n#endif\n\n\tif (cr3 == kvm_read_cr3(vcpu) && !pdptrs_changed(vcpu)) {\n\t\tkvm_mmu_sync_roots(vcpu);\n\t\tkvm_make_request(KVM_REQ_TLB_FLUSH, vcpu);\n\t\treturn 0;\n\t}\n\n\tif (is_long_mode(vcpu)) {\n\t\tif (cr3 & CR3_L_MODE_RESERVED_BITS)\n\t\t\treturn 1;\n\t} else if (is_pae(vcpu) && is_paging(vcpu) &&\n\t\t   !load_pdptrs(vcpu, vcpu->arch.walk_mmu, cr3))\n\t\treturn 1;\n\n\tvcpu->arch.cr3 = cr3;\n\t__set_bit(VCPU_EXREG_CR3, (ulong *)&vcpu->arch.regs_avail);\n\tkvm_mmu_new_cr3(vcpu);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "svm_set_cr4",
          "args": [
            "&svm->vcpu",
            "hsave->save.cr4"
          ],
          "line": 2632
        },
        "resolved": true,
        "details": {
          "function_name": "svm_set_cr4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "1813-1831",
          "snippet": "static int svm_set_cr4(struct kvm_vcpu *vcpu, unsigned long cr4)\n{\n\tunsigned long host_cr4_mce = cr4_read_shadow() & X86_CR4_MCE;\n\tunsigned long old_cr4 = to_svm(vcpu)->vmcb->save.cr4;\n\n\tif (cr4 & X86_CR4_VMXE)\n\t\treturn 1;\n\n\tif (npt_enabled && ((old_cr4 ^ cr4) & X86_CR4_PGE))\n\t\tsvm_flush_tlb(vcpu);\n\n\tvcpu->arch.cr4 = cr4;\n\tif (!npt_enabled)\n\t\tcr4 |= X86_CR4_PAE;\n\tcr4 |= host_cr4_mce;\n\tto_svm(vcpu)->vmcb->save.cr4 = cr4;\n\tmark_dirty(to_svm(vcpu)->vmcb, VMCB_CR);\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\n\nstatic int svm_set_cr4(struct kvm_vcpu *vcpu, unsigned long cr4)\n{\n\tunsigned long host_cr4_mce = cr4_read_shadow() & X86_CR4_MCE;\n\tunsigned long old_cr4 = to_svm(vcpu)->vmcb->save.cr4;\n\n\tif (cr4 & X86_CR4_VMXE)\n\t\treturn 1;\n\n\tif (npt_enabled && ((old_cr4 ^ cr4) & X86_CR4_PGE))\n\t\tsvm_flush_tlb(vcpu);\n\n\tvcpu->arch.cr4 = cr4;\n\tif (!npt_enabled)\n\t\tcr4 |= X86_CR4_PAE;\n\tcr4 |= host_cr4_mce;\n\tto_svm(vcpu)->vmcb->save.cr4 = cr4;\n\tmark_dirty(to_svm(vcpu)->vmcb, VMCB_CR);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "svm_set_cr0",
          "args": [
            "&svm->vcpu",
            "hsave->save.cr0 | X86_CR0_PE"
          ],
          "line": 2631
        },
        "resolved": true,
        "details": {
          "function_name": "svm_set_cr0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "1777-1811",
          "snippet": "static void svm_set_cr0(struct kvm_vcpu *vcpu, unsigned long cr0)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n#ifdef CONFIG_X86_64\n\tif (vcpu->arch.efer & EFER_LME) {\n\t\tif (!is_paging(vcpu) && (cr0 & X86_CR0_PG)) {\n\t\t\tvcpu->arch.efer |= EFER_LMA;\n\t\t\tsvm->vmcb->save.efer |= EFER_LMA | EFER_LME;\n\t\t}\n\n\t\tif (is_paging(vcpu) && !(cr0 & X86_CR0_PG)) {\n\t\t\tvcpu->arch.efer &= ~EFER_LMA;\n\t\t\tsvm->vmcb->save.efer &= ~(EFER_LMA | EFER_LME);\n\t\t}\n\t}\n#endif\n\tvcpu->arch.cr0 = cr0;\n\n\tif (!npt_enabled)\n\t\tcr0 |= X86_CR0_PG | X86_CR0_WP;\n\n\tif (!vcpu->fpu_active)\n\t\tcr0 |= X86_CR0_TS;\n\t/*\n\t * re-enable caching here because the QEMU bios\n\t * does not do it - this results in some delay at\n\t * reboot\n\t */\n\tif (kvm_check_has_quirk(vcpu->kvm, KVM_X86_QUIRK_CD_NW_CLEARED))\n\t\tcr0 &= ~(X86_CR0_CD | X86_CR0_NW);\n\tsvm->vmcb->save.cr0 = cr0;\n\tmark_dirty(svm->vmcb, VMCB_CR);\n\tupdate_cr0_intercept(svm);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_set_cr0(struct kvm_vcpu *vcpu, unsigned long cr0);",
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_set_cr0(struct kvm_vcpu *vcpu, unsigned long cr0);\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic void svm_set_cr0(struct kvm_vcpu *vcpu, unsigned long cr0)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n#ifdef CONFIG_X86_64\n\tif (vcpu->arch.efer & EFER_LME) {\n\t\tif (!is_paging(vcpu) && (cr0 & X86_CR0_PG)) {\n\t\t\tvcpu->arch.efer |= EFER_LMA;\n\t\t\tsvm->vmcb->save.efer |= EFER_LMA | EFER_LME;\n\t\t}\n\n\t\tif (is_paging(vcpu) && !(cr0 & X86_CR0_PG)) {\n\t\t\tvcpu->arch.efer &= ~EFER_LMA;\n\t\t\tsvm->vmcb->save.efer &= ~(EFER_LMA | EFER_LME);\n\t\t}\n\t}\n#endif\n\tvcpu->arch.cr0 = cr0;\n\n\tif (!npt_enabled)\n\t\tcr0 |= X86_CR0_PG | X86_CR0_WP;\n\n\tif (!vcpu->fpu_active)\n\t\tcr0 |= X86_CR0_TS;\n\t/*\n\t * re-enable caching here because the QEMU bios\n\t * does not do it - this results in some delay at\n\t * reboot\n\t */\n\tif (kvm_check_has_quirk(vcpu->kvm, KVM_X86_QUIRK_CD_NW_CLEARED))\n\t\tcr0 &= ~(X86_CR0_CD | X86_CR0_NW);\n\tsvm->vmcb->save.cr0 = cr0;\n\tmark_dirty(svm->vmcb, VMCB_CR);\n\tupdate_cr0_intercept(svm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "svm_set_efer",
          "args": [
            "&svm->vcpu",
            "hsave->save.efer"
          ],
          "line": 2630
        },
        "resolved": true,
        "details": {
          "function_name": "svm_set_efer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "535-543",
          "snippet": "static void svm_set_efer(struct kvm_vcpu *vcpu, u64 efer)\n{\n\tvcpu->arch.efer = efer;\n\tif (!npt_enabled && !(efer & EFER_LMA))\n\t\tefer &= ~EFER_LME;\n\n\tto_svm(vcpu)->vmcb->save.efer = efer | EFER_SVME;\n\tmark_dirty(to_svm(vcpu)->vmcb, VMCB_CR);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\n\nstatic void svm_set_efer(struct kvm_vcpu *vcpu, u64 efer)\n{\n\tvcpu->arch.efer = efer;\n\tif (!npt_enabled && !(efer & EFER_LMA))\n\t\tefer &= ~EFER_LME;\n\n\tto_svm(vcpu)->vmcb->save.efer = efer | EFER_SVME;\n\tmark_dirty(to_svm(vcpu)->vmcb, VMCB_CR);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_set_rflags",
          "args": [
            "&svm->vcpu",
            "hsave->save.rflags"
          ],
          "line": 2629
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_set_rflags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "8182-8186",
          "snippet": "void kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags)\n{\n\t__kvm_set_rflags(vcpu, rflags);\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void __kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void __kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags);\n\nvoid kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags)\n{\n\t__kvm_set_rflags(vcpu, rflags);\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_clear_interrupt_queue",
          "args": [
            "&svm->vcpu"
          ],
          "line": 2618
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_clear_interrupt_queue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.h",
          "lines": "22-25",
          "snippet": "static inline void kvm_clear_interrupt_queue(struct kvm_vcpu *vcpu)\n{\n\tvcpu->arch.interrupt.pending = false;\n}",
          "includes": [
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline void kvm_clear_interrupt_queue(struct kvm_vcpu *vcpu)\n{\n\tvcpu->arch.interrupt.pending = false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_clear_exception_queue",
          "args": [
            "&svm->vcpu"
          ],
          "line": 2617
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_clear_exception_queue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.h",
          "lines": "9-12",
          "snippet": "static inline void kvm_clear_exception_queue(struct kvm_vcpu *vcpu)\n{\n\tvcpu->arch.exception.pending = false;\n}",
          "includes": [
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline void kvm_clear_exception_queue(struct kvm_vcpu *vcpu)\n{\n\tvcpu->arch.exception.pending = false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_vmcb_control_area",
          "args": [
            "vmcb",
            "hsave"
          ],
          "line": 2615
        },
        "resolved": true,
        "details": {
          "function_name": "copy_vmcb_control_area",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "2504-2532",
          "snippet": "static inline void copy_vmcb_control_area(struct vmcb *dst_vmcb, struct vmcb *from_vmcb)\n{\n\tstruct vmcb_control_area *dst  = &dst_vmcb->control;\n\tstruct vmcb_control_area *from = &from_vmcb->control;\n\n\tdst->intercept_cr         = from->intercept_cr;\n\tdst->intercept_dr         = from->intercept_dr;\n\tdst->intercept_exceptions = from->intercept_exceptions;\n\tdst->intercept            = from->intercept;\n\tdst->iopm_base_pa         = from->iopm_base_pa;\n\tdst->msrpm_base_pa        = from->msrpm_base_pa;\n\tdst->tsc_offset           = from->tsc_offset;\n\tdst->asid                 = from->asid;\n\tdst->tlb_ctl              = from->tlb_ctl;\n\tdst->int_ctl              = from->int_ctl;\n\tdst->int_vector           = from->int_vector;\n\tdst->int_state            = from->int_state;\n\tdst->exit_code            = from->exit_code;\n\tdst->exit_code_hi         = from->exit_code_hi;\n\tdst->exit_info_1          = from->exit_info_1;\n\tdst->exit_info_2          = from->exit_info_2;\n\tdst->exit_int_info        = from->exit_int_info;\n\tdst->exit_int_info_err    = from->exit_int_info_err;\n\tdst->nested_ctl           = from->nested_ctl;\n\tdst->event_inj            = from->event_inj;\n\tdst->event_inj_err        = from->event_inj_err;\n\tdst->nested_cr3           = from->nested_cr3;\n\tdst->lbr_ctl              = from->lbr_ctl;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic inline void copy_vmcb_control_area(struct vmcb *dst_vmcb, struct vmcb *from_vmcb)\n{\n\tstruct vmcb_control_area *dst  = &dst_vmcb->control;\n\tstruct vmcb_control_area *from = &from_vmcb->control;\n\n\tdst->intercept_cr         = from->intercept_cr;\n\tdst->intercept_dr         = from->intercept_dr;\n\tdst->intercept_exceptions = from->intercept_exceptions;\n\tdst->intercept            = from->intercept;\n\tdst->iopm_base_pa         = from->iopm_base_pa;\n\tdst->msrpm_base_pa        = from->msrpm_base_pa;\n\tdst->tsc_offset           = from->tsc_offset;\n\tdst->asid                 = from->asid;\n\tdst->tlb_ctl              = from->tlb_ctl;\n\tdst->int_ctl              = from->int_ctl;\n\tdst->int_vector           = from->int_vector;\n\tdst->int_state            = from->int_state;\n\tdst->exit_code            = from->exit_code;\n\tdst->exit_code_hi         = from->exit_code_hi;\n\tdst->exit_info_1          = from->exit_info_1;\n\tdst->exit_info_2          = from->exit_info_2;\n\tdst->exit_int_info        = from->exit_int_info;\n\tdst->exit_int_info_err    = from->exit_int_info_err;\n\tdst->nested_ctl           = from->nested_ctl;\n\tdst->event_inj            = from->event_inj;\n\tdst->event_inj_err        = from->event_inj_err;\n\tdst->nested_cr3           = from->nested_cr3;\n\tdst->lbr_ctl              = from->lbr_ctl;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_get_rflags",
          "args": [
            "&svm->vcpu"
          ],
          "line": 2570
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_get_rflags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "8163-8171",
          "snippet": "unsigned long kvm_get_rflags(struct kvm_vcpu *vcpu)\n{\n\tunsigned long rflags;\n\n\trflags = kvm_x86_ops->get_rflags(vcpu);\n\tif (vcpu->guest_debug & KVM_GUESTDBG_SINGLESTEP)\n\t\trflags &= ~X86_EFLAGS_TF;\n\treturn rflags;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void __kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags);",
            "struct kvm_x86_ops *kvm_x86_ops"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void __kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nunsigned long kvm_get_rflags(struct kvm_vcpu *vcpu)\n{\n\tunsigned long rflags;\n\n\trflags = kvm_x86_ops->get_rflags(vcpu);\n\tif (vcpu->guest_debug & KVM_GUESTDBG_SINGLESTEP)\n\t\trflags &= ~X86_EFLAGS_TF;\n\treturn rflags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_read_cr3",
          "args": [
            "&svm->vcpu"
          ],
          "line": 2567
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_read_cr3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "69-74",
          "snippet": "static inline ulong kvm_read_cr3(struct kvm_vcpu *vcpu)\n{\n\tif (!test_bit(VCPU_EXREG_CR3, (ulong *)&vcpu->arch.regs_avail))\n\t\tkvm_x86_ops->decache_cr3(vcpu);\n\treturn vcpu->arch.cr3;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline ulong kvm_read_cr3(struct kvm_vcpu *vcpu)\n{\n\tif (!test_bit(VCPU_EXREG_CR3, (ulong *)&vcpu->arch.regs_avail))\n\t\tkvm_x86_ops->decache_cr3(vcpu);\n\treturn vcpu->arch.cr3;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_read_cr0",
          "args": [
            "&svm->vcpu"
          ],
          "line": 2566
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_read_cr0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "56-59",
          "snippet": "static inline ulong kvm_read_cr0(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_read_cr0_bits(vcpu, ~0UL);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline ulong kvm_read_cr0(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_read_cr0_bits(vcpu, ~0UL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "disable_gif",
          "args": [
            "svm"
          ],
          "line": 2557
        },
        "resolved": true,
        "details": {
          "function_name": "disable_gif",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "443-446",
          "snippet": "static inline void disable_gif(struct vcpu_svm *svm)\n{\n\tsvm->vcpu.arch.hflags &= ~HF_GIF_MASK;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic inline void disable_gif(struct vcpu_svm *svm)\n{\n\tsvm->vcpu.arch.hflags &= ~HF_GIF_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "leave_guest_mode",
          "args": [
            "&svm->vcpu"
          ],
          "line": 2553
        },
        "resolved": true,
        "details": {
          "function_name": "leave_guest_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "97-100",
          "snippet": "static inline void leave_guest_mode(struct kvm_vcpu *vcpu)\n{\n\tvcpu->arch.hflags &= ~HF_GUEST_MASK;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void leave_guest_mode(struct kvm_vcpu *vcpu)\n{\n\tvcpu->arch.hflags &= ~HF_GUEST_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nested_svm_map",
          "args": [
            "svm",
            "svm->nested.vmcb",
            "&page"
          ],
          "line": 2548
        },
        "resolved": true,
        "details": {
          "function_name": "nested_svm_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "2336-2354",
          "snippet": "static void *nested_svm_map(struct vcpu_svm *svm, u64 gpa, struct page **_page)\n{\n\tstruct page *page;\n\n\tmight_sleep();\n\n\tpage = kvm_vcpu_gfn_to_page(&svm->vcpu, gpa >> PAGE_SHIFT);\n\tif (is_error_page(page))\n\t\tgoto error;\n\n\t*_page = page;\n\n\treturn kmap(page);\n\nerror:\n\tkvm_inject_gp(&svm->vcpu, 0);\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic void *nested_svm_map(struct vcpu_svm *svm, u64 gpa, struct page **_page)\n{\n\tstruct page *page;\n\n\tmight_sleep();\n\n\tpage = kvm_vcpu_gfn_to_page(&svm->vcpu, gpa >> PAGE_SHIFT);\n\tif (is_error_page(page))\n\t\tgoto error;\n\n\t*_page = page;\n\n\treturn kmap(page);\n\nerror:\n\tkvm_inject_gp(&svm->vcpu, 0);\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_kvm_nested_vmexit_inject",
          "args": [
            "vmcb->control.exit_code",
            "vmcb->control.exit_info_1",
            "vmcb->control.exit_info_2",
            "vmcb->control.exit_int_info",
            "vmcb->control.exit_int_info_err",
            "KVM_ISA_SVM"
          ],
          "line": 2541
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int nested = true;\nstatic void svm_set_cr0(struct kvm_vcpu *vcpu, unsigned long cr0);\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic int nested_svm_vmexit(struct vcpu_svm *svm)\n{\n\tstruct vmcb *nested_vmcb;\n\tstruct vmcb *hsave = svm->nested.hsave;\n\tstruct vmcb *vmcb = svm->vmcb;\n\tstruct page *page;\n\n\ttrace_kvm_nested_vmexit_inject(vmcb->control.exit_code,\n\t\t\t\t       vmcb->control.exit_info_1,\n\t\t\t\t       vmcb->control.exit_info_2,\n\t\t\t\t       vmcb->control.exit_int_info,\n\t\t\t\t       vmcb->control.exit_int_info_err,\n\t\t\t\t       KVM_ISA_SVM);\n\n\tnested_vmcb = nested_svm_map(svm, svm->nested.vmcb, &page);\n\tif (!nested_vmcb)\n\t\treturn 1;\n\n\t/* Exit Guest-Mode */\n\tleave_guest_mode(&svm->vcpu);\n\tsvm->nested.vmcb = 0;\n\n\t/* Give the current vmcb to the guest */\n\tdisable_gif(svm);\n\n\tnested_vmcb->save.es     = vmcb->save.es;\n\tnested_vmcb->save.cs     = vmcb->save.cs;\n\tnested_vmcb->save.ss     = vmcb->save.ss;\n\tnested_vmcb->save.ds     = vmcb->save.ds;\n\tnested_vmcb->save.gdtr   = vmcb->save.gdtr;\n\tnested_vmcb->save.idtr   = vmcb->save.idtr;\n\tnested_vmcb->save.efer   = svm->vcpu.arch.efer;\n\tnested_vmcb->save.cr0    = kvm_read_cr0(&svm->vcpu);\n\tnested_vmcb->save.cr3    = kvm_read_cr3(&svm->vcpu);\n\tnested_vmcb->save.cr2    = vmcb->save.cr2;\n\tnested_vmcb->save.cr4    = svm->vcpu.arch.cr4;\n\tnested_vmcb->save.rflags = kvm_get_rflags(&svm->vcpu);\n\tnested_vmcb->save.rip    = vmcb->save.rip;\n\tnested_vmcb->save.rsp    = vmcb->save.rsp;\n\tnested_vmcb->save.rax    = vmcb->save.rax;\n\tnested_vmcb->save.dr7    = vmcb->save.dr7;\n\tnested_vmcb->save.dr6    = vmcb->save.dr6;\n\tnested_vmcb->save.cpl    = vmcb->save.cpl;\n\n\tnested_vmcb->control.int_ctl           = vmcb->control.int_ctl;\n\tnested_vmcb->control.int_vector        = vmcb->control.int_vector;\n\tnested_vmcb->control.int_state         = vmcb->control.int_state;\n\tnested_vmcb->control.exit_code         = vmcb->control.exit_code;\n\tnested_vmcb->control.exit_code_hi      = vmcb->control.exit_code_hi;\n\tnested_vmcb->control.exit_info_1       = vmcb->control.exit_info_1;\n\tnested_vmcb->control.exit_info_2       = vmcb->control.exit_info_2;\n\tnested_vmcb->control.exit_int_info     = vmcb->control.exit_int_info;\n\tnested_vmcb->control.exit_int_info_err = vmcb->control.exit_int_info_err;\n\n\tif (svm->nrips_enabled)\n\t\tnested_vmcb->control.next_rip  = vmcb->control.next_rip;\n\n\t/*\n\t * If we emulate a VMRUN/#VMEXIT in the same host #vmexit cycle we have\n\t * to make sure that we do not lose injected events. So check event_inj\n\t * here and copy it to exit_int_info if it is valid.\n\t * Exit_int_info and event_inj can't be both valid because the case\n\t * below only happens on a VMRUN instruction intercept which has\n\t * no valid exit_int_info set.\n\t */\n\tif (vmcb->control.event_inj & SVM_EVTINJ_VALID) {\n\t\tstruct vmcb_control_area *nc = &nested_vmcb->control;\n\n\t\tnc->exit_int_info     = vmcb->control.event_inj;\n\t\tnc->exit_int_info_err = vmcb->control.event_inj_err;\n\t}\n\n\tnested_vmcb->control.tlb_ctl           = 0;\n\tnested_vmcb->control.event_inj         = 0;\n\tnested_vmcb->control.event_inj_err     = 0;\n\n\t/* We always set V_INTR_MASKING and remember the old value in hflags */\n\tif (!(svm->vcpu.arch.hflags & HF_VINTR_MASK))\n\t\tnested_vmcb->control.int_ctl &= ~V_INTR_MASKING_MASK;\n\n\t/* Restore the original control entries */\n\tcopy_vmcb_control_area(vmcb, hsave);\n\n\tkvm_clear_exception_queue(&svm->vcpu);\n\tkvm_clear_interrupt_queue(&svm->vcpu);\n\n\tsvm->nested.nested_cr3 = 0;\n\n\t/* Restore selected save entries */\n\tsvm->vmcb->save.es = hsave->save.es;\n\tsvm->vmcb->save.cs = hsave->save.cs;\n\tsvm->vmcb->save.ss = hsave->save.ss;\n\tsvm->vmcb->save.ds = hsave->save.ds;\n\tsvm->vmcb->save.gdtr = hsave->save.gdtr;\n\tsvm->vmcb->save.idtr = hsave->save.idtr;\n\tkvm_set_rflags(&svm->vcpu, hsave->save.rflags);\n\tsvm_set_efer(&svm->vcpu, hsave->save.efer);\n\tsvm_set_cr0(&svm->vcpu, hsave->save.cr0 | X86_CR0_PE);\n\tsvm_set_cr4(&svm->vcpu, hsave->save.cr4);\n\tif (npt_enabled) {\n\t\tsvm->vmcb->save.cr3 = hsave->save.cr3;\n\t\tsvm->vcpu.arch.cr3 = hsave->save.cr3;\n\t} else {\n\t\t(void)kvm_set_cr3(&svm->vcpu, hsave->save.cr3);\n\t}\n\tkvm_register_write(&svm->vcpu, VCPU_REGS_RAX, hsave->save.rax);\n\tkvm_register_write(&svm->vcpu, VCPU_REGS_RSP, hsave->save.rsp);\n\tkvm_register_write(&svm->vcpu, VCPU_REGS_RIP, hsave->save.rip);\n\tsvm->vmcb->save.dr7 = 0;\n\tsvm->vmcb->save.cpl = 0;\n\tsvm->vmcb->control.exit_int_info = 0;\n\n\tmark_all_dirty(svm->vmcb);\n\n\tnested_svm_unmap(page);\n\n\tnested_svm_uninit_mmu_context(&svm->vcpu);\n\tkvm_mmu_reset_context(&svm->vcpu);\n\tkvm_mmu_load(&svm->vcpu);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "copy_vmcb_control_area",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "2504-2532",
    "snippet": "static inline void copy_vmcb_control_area(struct vmcb *dst_vmcb, struct vmcb *from_vmcb)\n{\n\tstruct vmcb_control_area *dst  = &dst_vmcb->control;\n\tstruct vmcb_control_area *from = &from_vmcb->control;\n\n\tdst->intercept_cr         = from->intercept_cr;\n\tdst->intercept_dr         = from->intercept_dr;\n\tdst->intercept_exceptions = from->intercept_exceptions;\n\tdst->intercept            = from->intercept;\n\tdst->iopm_base_pa         = from->iopm_base_pa;\n\tdst->msrpm_base_pa        = from->msrpm_base_pa;\n\tdst->tsc_offset           = from->tsc_offset;\n\tdst->asid                 = from->asid;\n\tdst->tlb_ctl              = from->tlb_ctl;\n\tdst->int_ctl              = from->int_ctl;\n\tdst->int_vector           = from->int_vector;\n\tdst->int_state            = from->int_state;\n\tdst->exit_code            = from->exit_code;\n\tdst->exit_code_hi         = from->exit_code_hi;\n\tdst->exit_info_1          = from->exit_info_1;\n\tdst->exit_info_2          = from->exit_info_2;\n\tdst->exit_int_info        = from->exit_int_info;\n\tdst->exit_int_info_err    = from->exit_int_info_err;\n\tdst->nested_ctl           = from->nested_ctl;\n\tdst->event_inj            = from->event_inj;\n\tdst->event_inj_err        = from->event_inj_err;\n\tdst->nested_cr3           = from->nested_cr3;\n\tdst->lbr_ctl              = from->lbr_ctl;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic inline void copy_vmcb_control_area(struct vmcb *dst_vmcb, struct vmcb *from_vmcb)\n{\n\tstruct vmcb_control_area *dst  = &dst_vmcb->control;\n\tstruct vmcb_control_area *from = &from_vmcb->control;\n\n\tdst->intercept_cr         = from->intercept_cr;\n\tdst->intercept_dr         = from->intercept_dr;\n\tdst->intercept_exceptions = from->intercept_exceptions;\n\tdst->intercept            = from->intercept;\n\tdst->iopm_base_pa         = from->iopm_base_pa;\n\tdst->msrpm_base_pa        = from->msrpm_base_pa;\n\tdst->tsc_offset           = from->tsc_offset;\n\tdst->asid                 = from->asid;\n\tdst->tlb_ctl              = from->tlb_ctl;\n\tdst->int_ctl              = from->int_ctl;\n\tdst->int_vector           = from->int_vector;\n\tdst->int_state            = from->int_state;\n\tdst->exit_code            = from->exit_code;\n\tdst->exit_code_hi         = from->exit_code_hi;\n\tdst->exit_info_1          = from->exit_info_1;\n\tdst->exit_info_2          = from->exit_info_2;\n\tdst->exit_int_info        = from->exit_int_info;\n\tdst->exit_int_info_err    = from->exit_int_info_err;\n\tdst->nested_ctl           = from->nested_ctl;\n\tdst->event_inj            = from->event_inj;\n\tdst->event_inj_err        = from->event_inj_err;\n\tdst->nested_cr3           = from->nested_cr3;\n\tdst->lbr_ctl              = from->lbr_ctl;\n}"
  },
  {
    "function_name": "nested_svm_exit_handled",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "2492-2502",
    "snippet": "static int nested_svm_exit_handled(struct vcpu_svm *svm)\n{\n\tint vmexit;\n\n\tvmexit = nested_svm_intercept(svm);\n\n\tif (vmexit == NESTED_EXIT_DONE)\n\t\tnested_svm_vmexit(svm);\n\n\treturn vmexit;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define NESTED_EXIT_DONE\t1\t/* Exit caused nested vmexit  */"
    ],
    "globals_used": [
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nested_svm_vmexit",
          "args": [
            "svm"
          ],
          "line": 2499
        },
        "resolved": true,
        "details": {
          "function_name": "nested_svm_vmexit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "2534-2655",
          "snippet": "static int nested_svm_vmexit(struct vcpu_svm *svm)\n{\n\tstruct vmcb *nested_vmcb;\n\tstruct vmcb *hsave = svm->nested.hsave;\n\tstruct vmcb *vmcb = svm->vmcb;\n\tstruct page *page;\n\n\ttrace_kvm_nested_vmexit_inject(vmcb->control.exit_code,\n\t\t\t\t       vmcb->control.exit_info_1,\n\t\t\t\t       vmcb->control.exit_info_2,\n\t\t\t\t       vmcb->control.exit_int_info,\n\t\t\t\t       vmcb->control.exit_int_info_err,\n\t\t\t\t       KVM_ISA_SVM);\n\n\tnested_vmcb = nested_svm_map(svm, svm->nested.vmcb, &page);\n\tif (!nested_vmcb)\n\t\treturn 1;\n\n\t/* Exit Guest-Mode */\n\tleave_guest_mode(&svm->vcpu);\n\tsvm->nested.vmcb = 0;\n\n\t/* Give the current vmcb to the guest */\n\tdisable_gif(svm);\n\n\tnested_vmcb->save.es     = vmcb->save.es;\n\tnested_vmcb->save.cs     = vmcb->save.cs;\n\tnested_vmcb->save.ss     = vmcb->save.ss;\n\tnested_vmcb->save.ds     = vmcb->save.ds;\n\tnested_vmcb->save.gdtr   = vmcb->save.gdtr;\n\tnested_vmcb->save.idtr   = vmcb->save.idtr;\n\tnested_vmcb->save.efer   = svm->vcpu.arch.efer;\n\tnested_vmcb->save.cr0    = kvm_read_cr0(&svm->vcpu);\n\tnested_vmcb->save.cr3    = kvm_read_cr3(&svm->vcpu);\n\tnested_vmcb->save.cr2    = vmcb->save.cr2;\n\tnested_vmcb->save.cr4    = svm->vcpu.arch.cr4;\n\tnested_vmcb->save.rflags = kvm_get_rflags(&svm->vcpu);\n\tnested_vmcb->save.rip    = vmcb->save.rip;\n\tnested_vmcb->save.rsp    = vmcb->save.rsp;\n\tnested_vmcb->save.rax    = vmcb->save.rax;\n\tnested_vmcb->save.dr7    = vmcb->save.dr7;\n\tnested_vmcb->save.dr6    = vmcb->save.dr6;\n\tnested_vmcb->save.cpl    = vmcb->save.cpl;\n\n\tnested_vmcb->control.int_ctl           = vmcb->control.int_ctl;\n\tnested_vmcb->control.int_vector        = vmcb->control.int_vector;\n\tnested_vmcb->control.int_state         = vmcb->control.int_state;\n\tnested_vmcb->control.exit_code         = vmcb->control.exit_code;\n\tnested_vmcb->control.exit_code_hi      = vmcb->control.exit_code_hi;\n\tnested_vmcb->control.exit_info_1       = vmcb->control.exit_info_1;\n\tnested_vmcb->control.exit_info_2       = vmcb->control.exit_info_2;\n\tnested_vmcb->control.exit_int_info     = vmcb->control.exit_int_info;\n\tnested_vmcb->control.exit_int_info_err = vmcb->control.exit_int_info_err;\n\n\tif (svm->nrips_enabled)\n\t\tnested_vmcb->control.next_rip  = vmcb->control.next_rip;\n\n\t/*\n\t * If we emulate a VMRUN/#VMEXIT in the same host #vmexit cycle we have\n\t * to make sure that we do not lose injected events. So check event_inj\n\t * here and copy it to exit_int_info if it is valid.\n\t * Exit_int_info and event_inj can't be both valid because the case\n\t * below only happens on a VMRUN instruction intercept which has\n\t * no valid exit_int_info set.\n\t */\n\tif (vmcb->control.event_inj & SVM_EVTINJ_VALID) {\n\t\tstruct vmcb_control_area *nc = &nested_vmcb->control;\n\n\t\tnc->exit_int_info     = vmcb->control.event_inj;\n\t\tnc->exit_int_info_err = vmcb->control.event_inj_err;\n\t}\n\n\tnested_vmcb->control.tlb_ctl           = 0;\n\tnested_vmcb->control.event_inj         = 0;\n\tnested_vmcb->control.event_inj_err     = 0;\n\n\t/* We always set V_INTR_MASKING and remember the old value in hflags */\n\tif (!(svm->vcpu.arch.hflags & HF_VINTR_MASK))\n\t\tnested_vmcb->control.int_ctl &= ~V_INTR_MASKING_MASK;\n\n\t/* Restore the original control entries */\n\tcopy_vmcb_control_area(vmcb, hsave);\n\n\tkvm_clear_exception_queue(&svm->vcpu);\n\tkvm_clear_interrupt_queue(&svm->vcpu);\n\n\tsvm->nested.nested_cr3 = 0;\n\n\t/* Restore selected save entries */\n\tsvm->vmcb->save.es = hsave->save.es;\n\tsvm->vmcb->save.cs = hsave->save.cs;\n\tsvm->vmcb->save.ss = hsave->save.ss;\n\tsvm->vmcb->save.ds = hsave->save.ds;\n\tsvm->vmcb->save.gdtr = hsave->save.gdtr;\n\tsvm->vmcb->save.idtr = hsave->save.idtr;\n\tkvm_set_rflags(&svm->vcpu, hsave->save.rflags);\n\tsvm_set_efer(&svm->vcpu, hsave->save.efer);\n\tsvm_set_cr0(&svm->vcpu, hsave->save.cr0 | X86_CR0_PE);\n\tsvm_set_cr4(&svm->vcpu, hsave->save.cr4);\n\tif (npt_enabled) {\n\t\tsvm->vmcb->save.cr3 = hsave->save.cr3;\n\t\tsvm->vcpu.arch.cr3 = hsave->save.cr3;\n\t} else {\n\t\t(void)kvm_set_cr3(&svm->vcpu, hsave->save.cr3);\n\t}\n\tkvm_register_write(&svm->vcpu, VCPU_REGS_RAX, hsave->save.rax);\n\tkvm_register_write(&svm->vcpu, VCPU_REGS_RSP, hsave->save.rsp);\n\tkvm_register_write(&svm->vcpu, VCPU_REGS_RIP, hsave->save.rip);\n\tsvm->vmcb->save.dr7 = 0;\n\tsvm->vmcb->save.cpl = 0;\n\tsvm->vmcb->control.exit_int_info = 0;\n\n\tmark_all_dirty(svm->vmcb);\n\n\tnested_svm_unmap(page);\n\n\tnested_svm_uninit_mmu_context(&svm->vcpu);\n\tkvm_mmu_reset_context(&svm->vcpu);\n\tkvm_mmu_load(&svm->vcpu);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nested = true;",
            "static void svm_set_cr0(struct kvm_vcpu *vcpu, unsigned long cr0);",
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int nested = true;\nstatic void svm_set_cr0(struct kvm_vcpu *vcpu, unsigned long cr0);\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic int nested_svm_vmexit(struct vcpu_svm *svm)\n{\n\tstruct vmcb *nested_vmcb;\n\tstruct vmcb *hsave = svm->nested.hsave;\n\tstruct vmcb *vmcb = svm->vmcb;\n\tstruct page *page;\n\n\ttrace_kvm_nested_vmexit_inject(vmcb->control.exit_code,\n\t\t\t\t       vmcb->control.exit_info_1,\n\t\t\t\t       vmcb->control.exit_info_2,\n\t\t\t\t       vmcb->control.exit_int_info,\n\t\t\t\t       vmcb->control.exit_int_info_err,\n\t\t\t\t       KVM_ISA_SVM);\n\n\tnested_vmcb = nested_svm_map(svm, svm->nested.vmcb, &page);\n\tif (!nested_vmcb)\n\t\treturn 1;\n\n\t/* Exit Guest-Mode */\n\tleave_guest_mode(&svm->vcpu);\n\tsvm->nested.vmcb = 0;\n\n\t/* Give the current vmcb to the guest */\n\tdisable_gif(svm);\n\n\tnested_vmcb->save.es     = vmcb->save.es;\n\tnested_vmcb->save.cs     = vmcb->save.cs;\n\tnested_vmcb->save.ss     = vmcb->save.ss;\n\tnested_vmcb->save.ds     = vmcb->save.ds;\n\tnested_vmcb->save.gdtr   = vmcb->save.gdtr;\n\tnested_vmcb->save.idtr   = vmcb->save.idtr;\n\tnested_vmcb->save.efer   = svm->vcpu.arch.efer;\n\tnested_vmcb->save.cr0    = kvm_read_cr0(&svm->vcpu);\n\tnested_vmcb->save.cr3    = kvm_read_cr3(&svm->vcpu);\n\tnested_vmcb->save.cr2    = vmcb->save.cr2;\n\tnested_vmcb->save.cr4    = svm->vcpu.arch.cr4;\n\tnested_vmcb->save.rflags = kvm_get_rflags(&svm->vcpu);\n\tnested_vmcb->save.rip    = vmcb->save.rip;\n\tnested_vmcb->save.rsp    = vmcb->save.rsp;\n\tnested_vmcb->save.rax    = vmcb->save.rax;\n\tnested_vmcb->save.dr7    = vmcb->save.dr7;\n\tnested_vmcb->save.dr6    = vmcb->save.dr6;\n\tnested_vmcb->save.cpl    = vmcb->save.cpl;\n\n\tnested_vmcb->control.int_ctl           = vmcb->control.int_ctl;\n\tnested_vmcb->control.int_vector        = vmcb->control.int_vector;\n\tnested_vmcb->control.int_state         = vmcb->control.int_state;\n\tnested_vmcb->control.exit_code         = vmcb->control.exit_code;\n\tnested_vmcb->control.exit_code_hi      = vmcb->control.exit_code_hi;\n\tnested_vmcb->control.exit_info_1       = vmcb->control.exit_info_1;\n\tnested_vmcb->control.exit_info_2       = vmcb->control.exit_info_2;\n\tnested_vmcb->control.exit_int_info     = vmcb->control.exit_int_info;\n\tnested_vmcb->control.exit_int_info_err = vmcb->control.exit_int_info_err;\n\n\tif (svm->nrips_enabled)\n\t\tnested_vmcb->control.next_rip  = vmcb->control.next_rip;\n\n\t/*\n\t * If we emulate a VMRUN/#VMEXIT in the same host #vmexit cycle we have\n\t * to make sure that we do not lose injected events. So check event_inj\n\t * here and copy it to exit_int_info if it is valid.\n\t * Exit_int_info and event_inj can't be both valid because the case\n\t * below only happens on a VMRUN instruction intercept which has\n\t * no valid exit_int_info set.\n\t */\n\tif (vmcb->control.event_inj & SVM_EVTINJ_VALID) {\n\t\tstruct vmcb_control_area *nc = &nested_vmcb->control;\n\n\t\tnc->exit_int_info     = vmcb->control.event_inj;\n\t\tnc->exit_int_info_err = vmcb->control.event_inj_err;\n\t}\n\n\tnested_vmcb->control.tlb_ctl           = 0;\n\tnested_vmcb->control.event_inj         = 0;\n\tnested_vmcb->control.event_inj_err     = 0;\n\n\t/* We always set V_INTR_MASKING and remember the old value in hflags */\n\tif (!(svm->vcpu.arch.hflags & HF_VINTR_MASK))\n\t\tnested_vmcb->control.int_ctl &= ~V_INTR_MASKING_MASK;\n\n\t/* Restore the original control entries */\n\tcopy_vmcb_control_area(vmcb, hsave);\n\n\tkvm_clear_exception_queue(&svm->vcpu);\n\tkvm_clear_interrupt_queue(&svm->vcpu);\n\n\tsvm->nested.nested_cr3 = 0;\n\n\t/* Restore selected save entries */\n\tsvm->vmcb->save.es = hsave->save.es;\n\tsvm->vmcb->save.cs = hsave->save.cs;\n\tsvm->vmcb->save.ss = hsave->save.ss;\n\tsvm->vmcb->save.ds = hsave->save.ds;\n\tsvm->vmcb->save.gdtr = hsave->save.gdtr;\n\tsvm->vmcb->save.idtr = hsave->save.idtr;\n\tkvm_set_rflags(&svm->vcpu, hsave->save.rflags);\n\tsvm_set_efer(&svm->vcpu, hsave->save.efer);\n\tsvm_set_cr0(&svm->vcpu, hsave->save.cr0 | X86_CR0_PE);\n\tsvm_set_cr4(&svm->vcpu, hsave->save.cr4);\n\tif (npt_enabled) {\n\t\tsvm->vmcb->save.cr3 = hsave->save.cr3;\n\t\tsvm->vcpu.arch.cr3 = hsave->save.cr3;\n\t} else {\n\t\t(void)kvm_set_cr3(&svm->vcpu, hsave->save.cr3);\n\t}\n\tkvm_register_write(&svm->vcpu, VCPU_REGS_RAX, hsave->save.rax);\n\tkvm_register_write(&svm->vcpu, VCPU_REGS_RSP, hsave->save.rsp);\n\tkvm_register_write(&svm->vcpu, VCPU_REGS_RIP, hsave->save.rip);\n\tsvm->vmcb->save.dr7 = 0;\n\tsvm->vmcb->save.cpl = 0;\n\tsvm->vmcb->control.exit_int_info = 0;\n\n\tmark_all_dirty(svm->vmcb);\n\n\tnested_svm_unmap(page);\n\n\tnested_svm_uninit_mmu_context(&svm->vcpu);\n\tkvm_mmu_reset_context(&svm->vcpu);\n\tkvm_mmu_load(&svm->vcpu);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nested_svm_intercept",
          "args": [
            "svm"
          ],
          "line": 2496
        },
        "resolved": true,
        "details": {
          "function_name": "nested_svm_intercept",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "2444-2490",
          "snippet": "static int nested_svm_intercept(struct vcpu_svm *svm)\n{\n\tu32 exit_code = svm->vmcb->control.exit_code;\n\tint vmexit = NESTED_EXIT_HOST;\n\n\tswitch (exit_code) {\n\tcase SVM_EXIT_MSR:\n\t\tvmexit = nested_svm_exit_handled_msr(svm);\n\t\tbreak;\n\tcase SVM_EXIT_IOIO:\n\t\tvmexit = nested_svm_intercept_ioio(svm);\n\t\tbreak;\n\tcase SVM_EXIT_READ_CR0 ... SVM_EXIT_WRITE_CR8: {\n\t\tu32 bit = 1U << (exit_code - SVM_EXIT_READ_CR0);\n\t\tif (svm->nested.intercept_cr & bit)\n\t\t\tvmexit = NESTED_EXIT_DONE;\n\t\tbreak;\n\t}\n\tcase SVM_EXIT_READ_DR0 ... SVM_EXIT_WRITE_DR7: {\n\t\tu32 bit = 1U << (exit_code - SVM_EXIT_READ_DR0);\n\t\tif (svm->nested.intercept_dr & bit)\n\t\t\tvmexit = NESTED_EXIT_DONE;\n\t\tbreak;\n\t}\n\tcase SVM_EXIT_EXCP_BASE ... SVM_EXIT_EXCP_BASE + 0x1f: {\n\t\tu32 excp_bits = 1 << (exit_code - SVM_EXIT_EXCP_BASE);\n\t\tif (svm->nested.intercept_exceptions & excp_bits)\n\t\t\tvmexit = NESTED_EXIT_DONE;\n\t\t/* async page fault always cause vmexit */\n\t\telse if ((exit_code == SVM_EXIT_EXCP_BASE + PF_VECTOR) &&\n\t\t\t svm->apf_reason != 0)\n\t\t\tvmexit = NESTED_EXIT_DONE;\n\t\tbreak;\n\t}\n\tcase SVM_EXIT_ERR: {\n\t\tvmexit = NESTED_EXIT_DONE;\n\t\tbreak;\n\t}\n\tdefault: {\n\t\tu64 exit_bits = 1ULL << (exit_code - SVM_EXIT_INTR);\n\t\tif (svm->nested.intercept & exit_bits)\n\t\t\tvmexit = NESTED_EXIT_DONE;\n\t}\n\t}\n\n\treturn vmexit;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define NESTED_EXIT_DONE\t1\t/* Exit caused nested vmexit  */",
            "#define NESTED_EXIT_HOST\t0\t/* Exit handled on host level */"
          ],
          "globals_used": [
            "static int nested = true;",
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define NESTED_EXIT_DONE\t1\t/* Exit caused nested vmexit  */\n#define NESTED_EXIT_HOST\t0\t/* Exit handled on host level */\n\nstatic int nested = true;\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic int nested_svm_intercept(struct vcpu_svm *svm)\n{\n\tu32 exit_code = svm->vmcb->control.exit_code;\n\tint vmexit = NESTED_EXIT_HOST;\n\n\tswitch (exit_code) {\n\tcase SVM_EXIT_MSR:\n\t\tvmexit = nested_svm_exit_handled_msr(svm);\n\t\tbreak;\n\tcase SVM_EXIT_IOIO:\n\t\tvmexit = nested_svm_intercept_ioio(svm);\n\t\tbreak;\n\tcase SVM_EXIT_READ_CR0 ... SVM_EXIT_WRITE_CR8: {\n\t\tu32 bit = 1U << (exit_code - SVM_EXIT_READ_CR0);\n\t\tif (svm->nested.intercept_cr & bit)\n\t\t\tvmexit = NESTED_EXIT_DONE;\n\t\tbreak;\n\t}\n\tcase SVM_EXIT_READ_DR0 ... SVM_EXIT_WRITE_DR7: {\n\t\tu32 bit = 1U << (exit_code - SVM_EXIT_READ_DR0);\n\t\tif (svm->nested.intercept_dr & bit)\n\t\t\tvmexit = NESTED_EXIT_DONE;\n\t\tbreak;\n\t}\n\tcase SVM_EXIT_EXCP_BASE ... SVM_EXIT_EXCP_BASE + 0x1f: {\n\t\tu32 excp_bits = 1 << (exit_code - SVM_EXIT_EXCP_BASE);\n\t\tif (svm->nested.intercept_exceptions & excp_bits)\n\t\t\tvmexit = NESTED_EXIT_DONE;\n\t\t/* async page fault always cause vmexit */\n\t\telse if ((exit_code == SVM_EXIT_EXCP_BASE + PF_VECTOR) &&\n\t\t\t svm->apf_reason != 0)\n\t\t\tvmexit = NESTED_EXIT_DONE;\n\t\tbreak;\n\t}\n\tcase SVM_EXIT_ERR: {\n\t\tvmexit = NESTED_EXIT_DONE;\n\t\tbreak;\n\t}\n\tdefault: {\n\t\tu64 exit_bits = 1ULL << (exit_code - SVM_EXIT_INTR);\n\t\tif (svm->nested.intercept & exit_bits)\n\t\t\tvmexit = NESTED_EXIT_DONE;\n\t}\n\t}\n\n\treturn vmexit;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define NESTED_EXIT_DONE\t1\t/* Exit caused nested vmexit  */\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm)\n{\n\tint vmexit;\n\n\tvmexit = nested_svm_intercept(svm);\n\n\tif (vmexit == NESTED_EXIT_DONE)\n\t\tnested_svm_vmexit(svm);\n\n\treturn vmexit;\n}"
  },
  {
    "function_name": "nested_svm_intercept",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "2444-2490",
    "snippet": "static int nested_svm_intercept(struct vcpu_svm *svm)\n{\n\tu32 exit_code = svm->vmcb->control.exit_code;\n\tint vmexit = NESTED_EXIT_HOST;\n\n\tswitch (exit_code) {\n\tcase SVM_EXIT_MSR:\n\t\tvmexit = nested_svm_exit_handled_msr(svm);\n\t\tbreak;\n\tcase SVM_EXIT_IOIO:\n\t\tvmexit = nested_svm_intercept_ioio(svm);\n\t\tbreak;\n\tcase SVM_EXIT_READ_CR0 ... SVM_EXIT_WRITE_CR8: {\n\t\tu32 bit = 1U << (exit_code - SVM_EXIT_READ_CR0);\n\t\tif (svm->nested.intercept_cr & bit)\n\t\t\tvmexit = NESTED_EXIT_DONE;\n\t\tbreak;\n\t}\n\tcase SVM_EXIT_READ_DR0 ... SVM_EXIT_WRITE_DR7: {\n\t\tu32 bit = 1U << (exit_code - SVM_EXIT_READ_DR0);\n\t\tif (svm->nested.intercept_dr & bit)\n\t\t\tvmexit = NESTED_EXIT_DONE;\n\t\tbreak;\n\t}\n\tcase SVM_EXIT_EXCP_BASE ... SVM_EXIT_EXCP_BASE + 0x1f: {\n\t\tu32 excp_bits = 1 << (exit_code - SVM_EXIT_EXCP_BASE);\n\t\tif (svm->nested.intercept_exceptions & excp_bits)\n\t\t\tvmexit = NESTED_EXIT_DONE;\n\t\t/* async page fault always cause vmexit */\n\t\telse if ((exit_code == SVM_EXIT_EXCP_BASE + PF_VECTOR) &&\n\t\t\t svm->apf_reason != 0)\n\t\t\tvmexit = NESTED_EXIT_DONE;\n\t\tbreak;\n\t}\n\tcase SVM_EXIT_ERR: {\n\t\tvmexit = NESTED_EXIT_DONE;\n\t\tbreak;\n\t}\n\tdefault: {\n\t\tu64 exit_bits = 1ULL << (exit_code - SVM_EXIT_INTR);\n\t\tif (svm->nested.intercept & exit_bits)\n\t\t\tvmexit = NESTED_EXIT_DONE;\n\t}\n\t}\n\n\treturn vmexit;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define NESTED_EXIT_DONE\t1\t/* Exit caused nested vmexit  */",
      "#define NESTED_EXIT_HOST\t0\t/* Exit handled on host level */"
    ],
    "globals_used": [
      "static int nested = true;",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nested_svm_intercept_ioio",
          "args": [
            "svm"
          ],
          "line": 2454
        },
        "resolved": true,
        "details": {
          "function_name": "nested_svm_intercept_ioio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "2362-2385",
          "snippet": "static int nested_svm_intercept_ioio(struct vcpu_svm *svm)\n{\n\tunsigned port, size, iopm_len;\n\tu16 val, mask;\n\tu8 start_bit;\n\tu64 gpa;\n\n\tif (!(svm->nested.intercept & (1ULL << INTERCEPT_IOIO_PROT)))\n\t\treturn NESTED_EXIT_HOST;\n\n\tport = svm->vmcb->control.exit_info_1 >> 16;\n\tsize = (svm->vmcb->control.exit_info_1 & SVM_IOIO_SIZE_MASK) >>\n\t\tSVM_IOIO_SIZE_SHIFT;\n\tgpa  = svm->nested.vmcb_iopm + (port / 8);\n\tstart_bit = port % 8;\n\tiopm_len = (start_bit + size > 8) ? 2 : 1;\n\tmask = (0xf >> (4 - size)) << start_bit;\n\tval = 0;\n\n\tif (kvm_vcpu_read_guest(&svm->vcpu, gpa, &val, iopm_len))\n\t\treturn NESTED_EXIT_DONE;\n\n\treturn (val & mask) ? NESTED_EXIT_DONE : NESTED_EXIT_HOST;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define NESTED_EXIT_DONE\t1\t/* Exit caused nested vmexit  */",
            "#define NESTED_EXIT_HOST\t0\t/* Exit handled on host level */"
          ],
          "globals_used": [
            "static int nested = true;",
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define NESTED_EXIT_DONE\t1\t/* Exit caused nested vmexit  */\n#define NESTED_EXIT_HOST\t0\t/* Exit handled on host level */\n\nstatic int nested = true;\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic int nested_svm_intercept_ioio(struct vcpu_svm *svm)\n{\n\tunsigned port, size, iopm_len;\n\tu16 val, mask;\n\tu8 start_bit;\n\tu64 gpa;\n\n\tif (!(svm->nested.intercept & (1ULL << INTERCEPT_IOIO_PROT)))\n\t\treturn NESTED_EXIT_HOST;\n\n\tport = svm->vmcb->control.exit_info_1 >> 16;\n\tsize = (svm->vmcb->control.exit_info_1 & SVM_IOIO_SIZE_MASK) >>\n\t\tSVM_IOIO_SIZE_SHIFT;\n\tgpa  = svm->nested.vmcb_iopm + (port / 8);\n\tstart_bit = port % 8;\n\tiopm_len = (start_bit + size > 8) ? 2 : 1;\n\tmask = (0xf >> (4 - size)) << start_bit;\n\tval = 0;\n\n\tif (kvm_vcpu_read_guest(&svm->vcpu, gpa, &val, iopm_len))\n\t\treturn NESTED_EXIT_DONE;\n\n\treturn (val & mask) ? NESTED_EXIT_DONE : NESTED_EXIT_HOST;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nested_svm_exit_handled_msr",
          "args": [
            "svm"
          ],
          "line": 2451
        },
        "resolved": true,
        "details": {
          "function_name": "nested_svm_exit_handled_msr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "2387-2410",
          "snippet": "static int nested_svm_exit_handled_msr(struct vcpu_svm *svm)\n{\n\tu32 offset, msr, value;\n\tint write, mask;\n\n\tif (!(svm->nested.intercept & (1ULL << INTERCEPT_MSR_PROT)))\n\t\treturn NESTED_EXIT_HOST;\n\n\tmsr    = svm->vcpu.arch.regs[VCPU_REGS_RCX];\n\toffset = svm_msrpm_offset(msr);\n\twrite  = svm->vmcb->control.exit_info_1 & 1;\n\tmask   = 1 << ((2 * (msr & 0xf)) + write);\n\n\tif (offset == MSR_INVALID)\n\t\treturn NESTED_EXIT_DONE;\n\n\t/* Offset is in 32 bit units but need in 8 bit units */\n\toffset *= 4;\n\n\tif (kvm_vcpu_read_guest(&svm->vcpu, svm->nested.vmcb_msrpm + offset, &value, 4))\n\t\treturn NESTED_EXIT_DONE;\n\n\treturn (value & mask) ? NESTED_EXIT_DONE : NESTED_EXIT_HOST;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define MSR_INVALID\t\t\t0xffffffffU",
            "#define NESTED_EXIT_DONE\t1\t/* Exit caused nested vmexit  */",
            "#define NESTED_EXIT_HOST\t0\t/* Exit handled on host level */"
          ],
          "globals_used": [
            "static int nested = true;",
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define MSR_INVALID\t\t\t0xffffffffU\n#define NESTED_EXIT_DONE\t1\t/* Exit caused nested vmexit  */\n#define NESTED_EXIT_HOST\t0\t/* Exit handled on host level */\n\nstatic int nested = true;\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic int nested_svm_exit_handled_msr(struct vcpu_svm *svm)\n{\n\tu32 offset, msr, value;\n\tint write, mask;\n\n\tif (!(svm->nested.intercept & (1ULL << INTERCEPT_MSR_PROT)))\n\t\treturn NESTED_EXIT_HOST;\n\n\tmsr    = svm->vcpu.arch.regs[VCPU_REGS_RCX];\n\toffset = svm_msrpm_offset(msr);\n\twrite  = svm->vmcb->control.exit_info_1 & 1;\n\tmask   = 1 << ((2 * (msr & 0xf)) + write);\n\n\tif (offset == MSR_INVALID)\n\t\treturn NESTED_EXIT_DONE;\n\n\t/* Offset is in 32 bit units but need in 8 bit units */\n\toffset *= 4;\n\n\tif (kvm_vcpu_read_guest(&svm->vcpu, svm->nested.vmcb_msrpm + offset, &value, 4))\n\t\treturn NESTED_EXIT_DONE;\n\n\treturn (value & mask) ? NESTED_EXIT_DONE : NESTED_EXIT_HOST;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define NESTED_EXIT_DONE\t1\t/* Exit caused nested vmexit  */\n#define NESTED_EXIT_HOST\t0\t/* Exit handled on host level */\n\nstatic int nested = true;\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic int nested_svm_intercept(struct vcpu_svm *svm)\n{\n\tu32 exit_code = svm->vmcb->control.exit_code;\n\tint vmexit = NESTED_EXIT_HOST;\n\n\tswitch (exit_code) {\n\tcase SVM_EXIT_MSR:\n\t\tvmexit = nested_svm_exit_handled_msr(svm);\n\t\tbreak;\n\tcase SVM_EXIT_IOIO:\n\t\tvmexit = nested_svm_intercept_ioio(svm);\n\t\tbreak;\n\tcase SVM_EXIT_READ_CR0 ... SVM_EXIT_WRITE_CR8: {\n\t\tu32 bit = 1U << (exit_code - SVM_EXIT_READ_CR0);\n\t\tif (svm->nested.intercept_cr & bit)\n\t\t\tvmexit = NESTED_EXIT_DONE;\n\t\tbreak;\n\t}\n\tcase SVM_EXIT_READ_DR0 ... SVM_EXIT_WRITE_DR7: {\n\t\tu32 bit = 1U << (exit_code - SVM_EXIT_READ_DR0);\n\t\tif (svm->nested.intercept_dr & bit)\n\t\t\tvmexit = NESTED_EXIT_DONE;\n\t\tbreak;\n\t}\n\tcase SVM_EXIT_EXCP_BASE ... SVM_EXIT_EXCP_BASE + 0x1f: {\n\t\tu32 excp_bits = 1 << (exit_code - SVM_EXIT_EXCP_BASE);\n\t\tif (svm->nested.intercept_exceptions & excp_bits)\n\t\t\tvmexit = NESTED_EXIT_DONE;\n\t\t/* async page fault always cause vmexit */\n\t\telse if ((exit_code == SVM_EXIT_EXCP_BASE + PF_VECTOR) &&\n\t\t\t svm->apf_reason != 0)\n\t\t\tvmexit = NESTED_EXIT_DONE;\n\t\tbreak;\n\t}\n\tcase SVM_EXIT_ERR: {\n\t\tvmexit = NESTED_EXIT_DONE;\n\t\tbreak;\n\t}\n\tdefault: {\n\t\tu64 exit_bits = 1ULL << (exit_code - SVM_EXIT_INTR);\n\t\tif (svm->nested.intercept & exit_bits)\n\t\t\tvmexit = NESTED_EXIT_DONE;\n\t}\n\t}\n\n\treturn vmexit;\n}"
  },
  {
    "function_name": "nested_svm_exit_special",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "2412-2439",
    "snippet": "static int nested_svm_exit_special(struct vcpu_svm *svm)\n{\n\tu32 exit_code = svm->vmcb->control.exit_code;\n\n\tswitch (exit_code) {\n\tcase SVM_EXIT_INTR:\n\tcase SVM_EXIT_NMI:\n\tcase SVM_EXIT_EXCP_BASE + MC_VECTOR:\n\t\treturn NESTED_EXIT_HOST;\n\tcase SVM_EXIT_NPF:\n\t\t/* For now we are always handling NPFs when using them */\n\t\tif (npt_enabled)\n\t\t\treturn NESTED_EXIT_HOST;\n\t\tbreak;\n\tcase SVM_EXIT_EXCP_BASE + PF_VECTOR:\n\t\t/* When we're shadowing, trap PFs, but not async PF */\n\t\tif (!npt_enabled && svm->apf_reason == 0)\n\t\t\treturn NESTED_EXIT_HOST;\n\t\tbreak;\n\tcase SVM_EXIT_EXCP_BASE + NM_VECTOR:\n\t\tnm_interception(svm);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn NESTED_EXIT_CONTINUE;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define NESTED_EXIT_CONTINUE\t2\t/* Further checks needed      */",
      "#define NESTED_EXIT_HOST\t0\t/* Exit handled on host level */"
    ],
    "globals_used": [
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nm_interception",
          "args": [
            "svm"
          ],
          "line": 2432
        },
        "resolved": true,
        "details": {
          "function_name": "nm_interception",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "2029-2033",
          "snippet": "static int nm_interception(struct vcpu_svm *svm)\n{\n\tsvm_fpu_activate(&svm->vcpu);\n\treturn 1;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic int nm_interception(struct vcpu_svm *svm)\n{\n\tsvm_fpu_activate(&svm->vcpu);\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define NESTED_EXIT_CONTINUE\t2\t/* Further checks needed      */\n#define NESTED_EXIT_HOST\t0\t/* Exit handled on host level */\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic int nested_svm_exit_special(struct vcpu_svm *svm)\n{\n\tu32 exit_code = svm->vmcb->control.exit_code;\n\n\tswitch (exit_code) {\n\tcase SVM_EXIT_INTR:\n\tcase SVM_EXIT_NMI:\n\tcase SVM_EXIT_EXCP_BASE + MC_VECTOR:\n\t\treturn NESTED_EXIT_HOST;\n\tcase SVM_EXIT_NPF:\n\t\t/* For now we are always handling NPFs when using them */\n\t\tif (npt_enabled)\n\t\t\treturn NESTED_EXIT_HOST;\n\t\tbreak;\n\tcase SVM_EXIT_EXCP_BASE + PF_VECTOR:\n\t\t/* When we're shadowing, trap PFs, but not async PF */\n\t\tif (!npt_enabled && svm->apf_reason == 0)\n\t\t\treturn NESTED_EXIT_HOST;\n\t\tbreak;\n\tcase SVM_EXIT_EXCP_BASE + NM_VECTOR:\n\t\tnm_interception(svm);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn NESTED_EXIT_CONTINUE;\n}"
  },
  {
    "function_name": "nested_svm_exit_handled_msr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "2387-2410",
    "snippet": "static int nested_svm_exit_handled_msr(struct vcpu_svm *svm)\n{\n\tu32 offset, msr, value;\n\tint write, mask;\n\n\tif (!(svm->nested.intercept & (1ULL << INTERCEPT_MSR_PROT)))\n\t\treturn NESTED_EXIT_HOST;\n\n\tmsr    = svm->vcpu.arch.regs[VCPU_REGS_RCX];\n\toffset = svm_msrpm_offset(msr);\n\twrite  = svm->vmcb->control.exit_info_1 & 1;\n\tmask   = 1 << ((2 * (msr & 0xf)) + write);\n\n\tif (offset == MSR_INVALID)\n\t\treturn NESTED_EXIT_DONE;\n\n\t/* Offset is in 32 bit units but need in 8 bit units */\n\toffset *= 4;\n\n\tif (kvm_vcpu_read_guest(&svm->vcpu, svm->nested.vmcb_msrpm + offset, &value, 4))\n\t\treturn NESTED_EXIT_DONE;\n\n\treturn (value & mask) ? NESTED_EXIT_DONE : NESTED_EXIT_HOST;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define MSR_INVALID\t\t\t0xffffffffU",
      "#define NESTED_EXIT_DONE\t1\t/* Exit caused nested vmexit  */",
      "#define NESTED_EXIT_HOST\t0\t/* Exit handled on host level */"
    ],
    "globals_used": [
      "static int nested = true;",
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_vcpu_read_guest",
          "args": [
            "&svm->vcpu",
            "svm->nested.vmcb_msrpm + offset",
            "&value",
            "4"
          ],
          "line": 2406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svm_msrpm_offset",
          "args": [
            "msr"
          ],
          "line": 2396
        },
        "resolved": true,
        "details": {
          "function_name": "svm_msrpm_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "488-507",
          "snippet": "static u32 svm_msrpm_offset(u32 msr)\n{\n\tu32 offset;\n\tint i;\n\n\tfor (i = 0; i < NUM_MSR_MAPS; i++) {\n\t\tif (msr < msrpm_ranges[i] ||\n\t\t    msr >= msrpm_ranges[i] + MSRS_IN_RANGE)\n\t\t\tcontinue;\n\n\t\toffset  = (msr - msrpm_ranges[i]) / 4; /* 4 msrs per u8 */\n\t\toffset += (i * MSRS_RANGE_SIZE);       /* add range offset */\n\n\t\t/* Now we have the u8 offset - but need the u32 offset */\n\t\treturn offset / 4;\n\t}\n\n\t/* MSR not in any range */\n\treturn MSR_INVALID;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define MSRS_IN_RANGE (MSRS_RANGE_SIZE * 8 / 2)",
            "#define MSRS_RANGE_SIZE 2048",
            "#define NUM_MSR_MAPS ARRAY_SIZE(msrpm_ranges)",
            "#define MSR_INVALID\t\t\t0xffffffffU"
          ],
          "globals_used": [
            "static const u32 msrpm_ranges[] = {0, 0xc0000000, 0xc0010000};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define MSRS_IN_RANGE (MSRS_RANGE_SIZE * 8 / 2)\n#define MSRS_RANGE_SIZE 2048\n#define NUM_MSR_MAPS ARRAY_SIZE(msrpm_ranges)\n#define MSR_INVALID\t\t\t0xffffffffU\n\nstatic const u32 msrpm_ranges[] = {0, 0xc0000000, 0xc0010000};\n\nstatic u32 svm_msrpm_offset(u32 msr)\n{\n\tu32 offset;\n\tint i;\n\n\tfor (i = 0; i < NUM_MSR_MAPS; i++) {\n\t\tif (msr < msrpm_ranges[i] ||\n\t\t    msr >= msrpm_ranges[i] + MSRS_IN_RANGE)\n\t\t\tcontinue;\n\n\t\toffset  = (msr - msrpm_ranges[i]) / 4; /* 4 msrs per u8 */\n\t\toffset += (i * MSRS_RANGE_SIZE);       /* add range offset */\n\n\t\t/* Now we have the u8 offset - but need the u32 offset */\n\t\treturn offset / 4;\n\t}\n\n\t/* MSR not in any range */\n\treturn MSR_INVALID;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define MSR_INVALID\t\t\t0xffffffffU\n#define NESTED_EXIT_DONE\t1\t/* Exit caused nested vmexit  */\n#define NESTED_EXIT_HOST\t0\t/* Exit handled on host level */\n\nstatic int nested = true;\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic int nested_svm_exit_handled_msr(struct vcpu_svm *svm)\n{\n\tu32 offset, msr, value;\n\tint write, mask;\n\n\tif (!(svm->nested.intercept & (1ULL << INTERCEPT_MSR_PROT)))\n\t\treturn NESTED_EXIT_HOST;\n\n\tmsr    = svm->vcpu.arch.regs[VCPU_REGS_RCX];\n\toffset = svm_msrpm_offset(msr);\n\twrite  = svm->vmcb->control.exit_info_1 & 1;\n\tmask   = 1 << ((2 * (msr & 0xf)) + write);\n\n\tif (offset == MSR_INVALID)\n\t\treturn NESTED_EXIT_DONE;\n\n\t/* Offset is in 32 bit units but need in 8 bit units */\n\toffset *= 4;\n\n\tif (kvm_vcpu_read_guest(&svm->vcpu, svm->nested.vmcb_msrpm + offset, &value, 4))\n\t\treturn NESTED_EXIT_DONE;\n\n\treturn (value & mask) ? NESTED_EXIT_DONE : NESTED_EXIT_HOST;\n}"
  },
  {
    "function_name": "nested_svm_intercept_ioio",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "2362-2385",
    "snippet": "static int nested_svm_intercept_ioio(struct vcpu_svm *svm)\n{\n\tunsigned port, size, iopm_len;\n\tu16 val, mask;\n\tu8 start_bit;\n\tu64 gpa;\n\n\tif (!(svm->nested.intercept & (1ULL << INTERCEPT_IOIO_PROT)))\n\t\treturn NESTED_EXIT_HOST;\n\n\tport = svm->vmcb->control.exit_info_1 >> 16;\n\tsize = (svm->vmcb->control.exit_info_1 & SVM_IOIO_SIZE_MASK) >>\n\t\tSVM_IOIO_SIZE_SHIFT;\n\tgpa  = svm->nested.vmcb_iopm + (port / 8);\n\tstart_bit = port % 8;\n\tiopm_len = (start_bit + size > 8) ? 2 : 1;\n\tmask = (0xf >> (4 - size)) << start_bit;\n\tval = 0;\n\n\tif (kvm_vcpu_read_guest(&svm->vcpu, gpa, &val, iopm_len))\n\t\treturn NESTED_EXIT_DONE;\n\n\treturn (val & mask) ? NESTED_EXIT_DONE : NESTED_EXIT_HOST;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define NESTED_EXIT_DONE\t1\t/* Exit caused nested vmexit  */",
      "#define NESTED_EXIT_HOST\t0\t/* Exit handled on host level */"
    ],
    "globals_used": [
      "static int nested = true;",
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_vcpu_read_guest",
          "args": [
            "&svm->vcpu",
            "gpa",
            "&val",
            "iopm_len"
          ],
          "line": 2381
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define NESTED_EXIT_DONE\t1\t/* Exit caused nested vmexit  */\n#define NESTED_EXIT_HOST\t0\t/* Exit handled on host level */\n\nstatic int nested = true;\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic int nested_svm_intercept_ioio(struct vcpu_svm *svm)\n{\n\tunsigned port, size, iopm_len;\n\tu16 val, mask;\n\tu8 start_bit;\n\tu64 gpa;\n\n\tif (!(svm->nested.intercept & (1ULL << INTERCEPT_IOIO_PROT)))\n\t\treturn NESTED_EXIT_HOST;\n\n\tport = svm->vmcb->control.exit_info_1 >> 16;\n\tsize = (svm->vmcb->control.exit_info_1 & SVM_IOIO_SIZE_MASK) >>\n\t\tSVM_IOIO_SIZE_SHIFT;\n\tgpa  = svm->nested.vmcb_iopm + (port / 8);\n\tstart_bit = port % 8;\n\tiopm_len = (start_bit + size > 8) ? 2 : 1;\n\tmask = (0xf >> (4 - size)) << start_bit;\n\tval = 0;\n\n\tif (kvm_vcpu_read_guest(&svm->vcpu, gpa, &val, iopm_len))\n\t\treturn NESTED_EXIT_DONE;\n\n\treturn (val & mask) ? NESTED_EXIT_DONE : NESTED_EXIT_HOST;\n}"
  },
  {
    "function_name": "nested_svm_unmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "2356-2360",
    "snippet": "static void nested_svm_unmap(struct page *page)\n{\n\tkunmap(page);\n\tkvm_release_page_dirty(page);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_release_page_dirty",
          "args": [
            "page"
          ],
          "line": 2359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "page"
          ],
          "line": 2358
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void nested_svm_unmap(struct page *page)\n{\n\tkunmap(page);\n\tkvm_release_page_dirty(page);\n}"
  },
  {
    "function_name": "nested_svm_map",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "2336-2354",
    "snippet": "static void *nested_svm_map(struct vcpu_svm *svm, u64 gpa, struct page **_page)\n{\n\tstruct page *page;\n\n\tmight_sleep();\n\n\tpage = kvm_vcpu_gfn_to_page(&svm->vcpu, gpa >> PAGE_SHIFT);\n\tif (is_error_page(page))\n\t\tgoto error;\n\n\t*_page = page;\n\n\treturn kmap(page);\n\nerror:\n\tkvm_inject_gp(&svm->vcpu, 0);\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_inject_gp",
          "args": [
            "&svm->vcpu",
            "0"
          ],
          "line": 2351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap",
          "args": [
            "page"
          ],
          "line": 2348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_error_page",
          "args": [
            "page"
          ],
          "line": 2343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_gfn_to_page",
          "args": [
            "&svm->vcpu",
            "gpa >> PAGE_SHIFT"
          ],
          "line": 2342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "might_sleep",
          "args": [],
          "line": 2340
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic void *nested_svm_map(struct vcpu_svm *svm, u64 gpa, struct page **_page)\n{\n\tstruct page *page;\n\n\tmight_sleep();\n\n\tpage = kvm_vcpu_gfn_to_page(&svm->vcpu, gpa >> PAGE_SHIFT);\n\tif (is_error_page(page))\n\t\tgoto error;\n\n\t*_page = page;\n\n\treturn kmap(page);\n\nerror:\n\tkvm_inject_gp(&svm->vcpu, 0);\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "nested_svm_nmi",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "2322-2334",
    "snippet": "static inline bool nested_svm_nmi(struct vcpu_svm *svm)\n{\n\tif (!is_guest_mode(&svm->vcpu))\n\t\treturn true;\n\n\tif (!(svm->nested.intercept & (1ULL << INTERCEPT_NMI)))\n\t\treturn true;\n\n\tsvm->vmcb->control.exit_code = SVM_EXIT_NMI;\n\tsvm->nested.exit_required = true;\n\n\treturn false;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int nested = true;",
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "is_guest_mode",
          "args": [
            "&svm->vcpu"
          ],
          "line": 2324
        },
        "resolved": true,
        "details": {
          "function_name": "is_guest_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "102-105",
          "snippet": "static inline bool is_guest_mode(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.hflags & HF_GUEST_MASK;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline bool is_guest_mode(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.hflags & HF_GUEST_MASK;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int nested = true;\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic inline bool nested_svm_nmi(struct vcpu_svm *svm)\n{\n\tif (!is_guest_mode(&svm->vcpu))\n\t\treturn true;\n\n\tif (!(svm->nested.intercept & (1ULL << INTERCEPT_NMI)))\n\t\treturn true;\n\n\tsvm->vmcb->control.exit_code = SVM_EXIT_NMI;\n\tsvm->nested.exit_required = true;\n\n\treturn false;\n}"
  },
  {
    "function_name": "nested_svm_intr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "2283-2319",
    "snippet": "static inline bool nested_svm_intr(struct vcpu_svm *svm)\n{\n\tif (!is_guest_mode(&svm->vcpu))\n\t\treturn true;\n\n\tif (!(svm->vcpu.arch.hflags & HF_VINTR_MASK))\n\t\treturn true;\n\n\tif (!(svm->vcpu.arch.hflags & HF_HIF_MASK))\n\t\treturn false;\n\n\t/*\n\t * if vmexit was already requested (by intercepted exception\n\t * for instance) do not overwrite it with \"external interrupt\"\n\t * vmexit.\n\t */\n\tif (svm->nested.exit_required)\n\t\treturn false;\n\n\tsvm->vmcb->control.exit_code   = SVM_EXIT_INTR;\n\tsvm->vmcb->control.exit_info_1 = 0;\n\tsvm->vmcb->control.exit_info_2 = 0;\n\n\tif (svm->nested.intercept & 1ULL) {\n\t\t/*\n\t\t * The #vmexit can't be emulated here directly because this\n\t\t * code path runs with irqs and preemption disabled. A\n\t\t * #vmexit emulation might sleep. Only signal request for\n\t\t * the #vmexit here.\n\t\t */\n\t\tsvm->nested.exit_required = true;\n\t\ttrace_kvm_nested_intr_vmexit(svm->vmcb->save.rip);\n\t\treturn false;\n\t}\n\n\treturn true;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int nested = true;",
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_kvm_nested_intr_vmexit",
          "args": [
            "svm->vmcb->save.rip"
          ],
          "line": 2314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_guest_mode",
          "args": [
            "&svm->vcpu"
          ],
          "line": 2285
        },
        "resolved": true,
        "details": {
          "function_name": "is_guest_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "102-105",
          "snippet": "static inline bool is_guest_mode(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.hflags & HF_GUEST_MASK;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline bool is_guest_mode(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.hflags & HF_GUEST_MASK;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int nested = true;\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic inline bool nested_svm_intr(struct vcpu_svm *svm)\n{\n\tif (!is_guest_mode(&svm->vcpu))\n\t\treturn true;\n\n\tif (!(svm->vcpu.arch.hflags & HF_VINTR_MASK))\n\t\treturn true;\n\n\tif (!(svm->vcpu.arch.hflags & HF_HIF_MASK))\n\t\treturn false;\n\n\t/*\n\t * if vmexit was already requested (by intercepted exception\n\t * for instance) do not overwrite it with \"external interrupt\"\n\t * vmexit.\n\t */\n\tif (svm->nested.exit_required)\n\t\treturn false;\n\n\tsvm->vmcb->control.exit_code   = SVM_EXIT_INTR;\n\tsvm->vmcb->control.exit_info_1 = 0;\n\tsvm->vmcb->control.exit_info_2 = 0;\n\n\tif (svm->nested.intercept & 1ULL) {\n\t\t/*\n\t\t * The #vmexit can't be emulated here directly because this\n\t\t * code path runs with irqs and preemption disabled. A\n\t\t * #vmexit emulation might sleep. Only signal request for\n\t\t * the #vmexit here.\n\t\t */\n\t\tsvm->nested.exit_required = true;\n\t\ttrace_kvm_nested_intr_vmexit(svm->vmcb->save.rip);\n\t\treturn false;\n\t}\n\n\treturn true;\n}"
  },
  {
    "function_name": "nested_svm_check_exception",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "2262-2280",
    "snippet": "static int nested_svm_check_exception(struct vcpu_svm *svm, unsigned nr,\n\t\t\t\t      bool has_error_code, u32 error_code)\n{\n\tint vmexit;\n\n\tif (!is_guest_mode(&svm->vcpu))\n\t\treturn 0;\n\n\tsvm->vmcb->control.exit_code = SVM_EXIT_EXCP_BASE + nr;\n\tsvm->vmcb->control.exit_code_hi = 0;\n\tsvm->vmcb->control.exit_info_1 = error_code;\n\tsvm->vmcb->control.exit_info_2 = svm->vcpu.arch.cr2;\n\n\tvmexit = nested_svm_intercept(svm);\n\tif (vmexit == NESTED_EXIT_DONE)\n\t\tsvm->nested.exit_required = true;\n\n\treturn vmexit;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define NESTED_EXIT_DONE\t1\t/* Exit caused nested vmexit  */"
    ],
    "globals_used": [
      "static int nested = true;",
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);",
      "static int nested_svm_check_exception(struct vcpu_svm *svm, unsigned nr,\n\t\t\t\t      bool has_error_code, u32 error_code);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nested_svm_intercept",
          "args": [
            "svm"
          ],
          "line": 2275
        },
        "resolved": true,
        "details": {
          "function_name": "nested_svm_intercept",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "2444-2490",
          "snippet": "static int nested_svm_intercept(struct vcpu_svm *svm)\n{\n\tu32 exit_code = svm->vmcb->control.exit_code;\n\tint vmexit = NESTED_EXIT_HOST;\n\n\tswitch (exit_code) {\n\tcase SVM_EXIT_MSR:\n\t\tvmexit = nested_svm_exit_handled_msr(svm);\n\t\tbreak;\n\tcase SVM_EXIT_IOIO:\n\t\tvmexit = nested_svm_intercept_ioio(svm);\n\t\tbreak;\n\tcase SVM_EXIT_READ_CR0 ... SVM_EXIT_WRITE_CR8: {\n\t\tu32 bit = 1U << (exit_code - SVM_EXIT_READ_CR0);\n\t\tif (svm->nested.intercept_cr & bit)\n\t\t\tvmexit = NESTED_EXIT_DONE;\n\t\tbreak;\n\t}\n\tcase SVM_EXIT_READ_DR0 ... SVM_EXIT_WRITE_DR7: {\n\t\tu32 bit = 1U << (exit_code - SVM_EXIT_READ_DR0);\n\t\tif (svm->nested.intercept_dr & bit)\n\t\t\tvmexit = NESTED_EXIT_DONE;\n\t\tbreak;\n\t}\n\tcase SVM_EXIT_EXCP_BASE ... SVM_EXIT_EXCP_BASE + 0x1f: {\n\t\tu32 excp_bits = 1 << (exit_code - SVM_EXIT_EXCP_BASE);\n\t\tif (svm->nested.intercept_exceptions & excp_bits)\n\t\t\tvmexit = NESTED_EXIT_DONE;\n\t\t/* async page fault always cause vmexit */\n\t\telse if ((exit_code == SVM_EXIT_EXCP_BASE + PF_VECTOR) &&\n\t\t\t svm->apf_reason != 0)\n\t\t\tvmexit = NESTED_EXIT_DONE;\n\t\tbreak;\n\t}\n\tcase SVM_EXIT_ERR: {\n\t\tvmexit = NESTED_EXIT_DONE;\n\t\tbreak;\n\t}\n\tdefault: {\n\t\tu64 exit_bits = 1ULL << (exit_code - SVM_EXIT_INTR);\n\t\tif (svm->nested.intercept & exit_bits)\n\t\t\tvmexit = NESTED_EXIT_DONE;\n\t}\n\t}\n\n\treturn vmexit;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define NESTED_EXIT_DONE\t1\t/* Exit caused nested vmexit  */",
            "#define NESTED_EXIT_HOST\t0\t/* Exit handled on host level */"
          ],
          "globals_used": [
            "static int nested = true;",
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define NESTED_EXIT_DONE\t1\t/* Exit caused nested vmexit  */\n#define NESTED_EXIT_HOST\t0\t/* Exit handled on host level */\n\nstatic int nested = true;\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic int nested_svm_intercept(struct vcpu_svm *svm)\n{\n\tu32 exit_code = svm->vmcb->control.exit_code;\n\tint vmexit = NESTED_EXIT_HOST;\n\n\tswitch (exit_code) {\n\tcase SVM_EXIT_MSR:\n\t\tvmexit = nested_svm_exit_handled_msr(svm);\n\t\tbreak;\n\tcase SVM_EXIT_IOIO:\n\t\tvmexit = nested_svm_intercept_ioio(svm);\n\t\tbreak;\n\tcase SVM_EXIT_READ_CR0 ... SVM_EXIT_WRITE_CR8: {\n\t\tu32 bit = 1U << (exit_code - SVM_EXIT_READ_CR0);\n\t\tif (svm->nested.intercept_cr & bit)\n\t\t\tvmexit = NESTED_EXIT_DONE;\n\t\tbreak;\n\t}\n\tcase SVM_EXIT_READ_DR0 ... SVM_EXIT_WRITE_DR7: {\n\t\tu32 bit = 1U << (exit_code - SVM_EXIT_READ_DR0);\n\t\tif (svm->nested.intercept_dr & bit)\n\t\t\tvmexit = NESTED_EXIT_DONE;\n\t\tbreak;\n\t}\n\tcase SVM_EXIT_EXCP_BASE ... SVM_EXIT_EXCP_BASE + 0x1f: {\n\t\tu32 excp_bits = 1 << (exit_code - SVM_EXIT_EXCP_BASE);\n\t\tif (svm->nested.intercept_exceptions & excp_bits)\n\t\t\tvmexit = NESTED_EXIT_DONE;\n\t\t/* async page fault always cause vmexit */\n\t\telse if ((exit_code == SVM_EXIT_EXCP_BASE + PF_VECTOR) &&\n\t\t\t svm->apf_reason != 0)\n\t\t\tvmexit = NESTED_EXIT_DONE;\n\t\tbreak;\n\t}\n\tcase SVM_EXIT_ERR: {\n\t\tvmexit = NESTED_EXIT_DONE;\n\t\tbreak;\n\t}\n\tdefault: {\n\t\tu64 exit_bits = 1ULL << (exit_code - SVM_EXIT_INTR);\n\t\tif (svm->nested.intercept & exit_bits)\n\t\t\tvmexit = NESTED_EXIT_DONE;\n\t}\n\t}\n\n\treturn vmexit;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_guest_mode",
          "args": [
            "&svm->vcpu"
          ],
          "line": 2267
        },
        "resolved": true,
        "details": {
          "function_name": "is_guest_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "102-105",
          "snippet": "static inline bool is_guest_mode(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.hflags & HF_GUEST_MASK;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline bool is_guest_mode(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.hflags & HF_GUEST_MASK;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define NESTED_EXIT_DONE\t1\t/* Exit caused nested vmexit  */\n\nstatic int nested = true;\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\nstatic int nested_svm_check_exception(struct vcpu_svm *svm, unsigned nr,\n\t\t\t\t      bool has_error_code, u32 error_code);\n\nstatic int nested_svm_check_exception(struct vcpu_svm *svm, unsigned nr,\n\t\t\t\t      bool has_error_code, u32 error_code)\n{\n\tint vmexit;\n\n\tif (!is_guest_mode(&svm->vcpu))\n\t\treturn 0;\n\n\tsvm->vmcb->control.exit_code = SVM_EXIT_EXCP_BASE + nr;\n\tsvm->vmcb->control.exit_code_hi = 0;\n\tsvm->vmcb->control.exit_info_1 = error_code;\n\tsvm->vmcb->control.exit_info_2 = svm->vcpu.arch.cr2;\n\n\tvmexit = nested_svm_intercept(svm);\n\tif (vmexit == NESTED_EXIT_DONE)\n\t\tsvm->nested.exit_required = true;\n\n\treturn vmexit;\n}"
  },
  {
    "function_name": "nested_svm_check_permissions",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "2246-2260",
    "snippet": "static int nested_svm_check_permissions(struct vcpu_svm *svm)\n{\n\tif (!(svm->vcpu.arch.efer & EFER_SVME)\n\t    || !is_paging(&svm->vcpu)) {\n\t\tkvm_queue_exception(&svm->vcpu, UD_VECTOR);\n\t\treturn 1;\n\t}\n\n\tif (svm->vmcb->save.cpl) {\n\t\tkvm_inject_gp(&svm->vcpu, 0);\n\t\treturn 1;\n\t}\n\n       return 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_inject_gp",
          "args": [
            "&svm->vcpu",
            "0"
          ],
          "line": 2255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_queue_exception",
          "args": [
            "&svm->vcpu",
            "UD_VECTOR"
          ],
          "line": 2250
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_queue_exception",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "409-412",
          "snippet": "void kvm_queue_exception(struct kvm_vcpu *vcpu, unsigned nr)\n{\n\tkvm_multiple_exception(vcpu, nr, false, 0, false);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nvoid kvm_queue_exception(struct kvm_vcpu *vcpu, unsigned nr)\n{\n\tkvm_multiple_exception(vcpu, nr, false, 0, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_paging",
          "args": [
            "&svm->vcpu"
          ],
          "line": 2249
        },
        "resolved": true,
        "details": {
          "function_name": "is_paging",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.h",
          "lines": "77-80",
          "snippet": "static inline int is_paging(struct kvm_vcpu *vcpu)\n{\n\treturn likely(kvm_read_cr0_bits(vcpu, X86_CR0_PG));\n}",
          "includes": [
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline int is_paging(struct kvm_vcpu *vcpu)\n{\n\treturn likely(kvm_read_cr0_bits(vcpu, X86_CR0_PG));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic int nested_svm_check_permissions(struct vcpu_svm *svm)\n{\n\tif (!(svm->vcpu.arch.efer & EFER_SVME)\n\t    || !is_paging(&svm->vcpu)) {\n\t\tkvm_queue_exception(&svm->vcpu, UD_VECTOR);\n\t\treturn 1;\n\t}\n\n\tif (svm->vmcb->save.cpl) {\n\t\tkvm_inject_gp(&svm->vcpu, 0);\n\t\treturn 1;\n\t}\n\n       return 0;\n}"
  },
  {
    "function_name": "nested_svm_uninit_mmu_context",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "2241-2244",
    "snippet": "static void nested_svm_uninit_mmu_context(struct kvm_vcpu *vcpu)\n{\n\tvcpu->arch.walk_mmu = &vcpu->arch.mmu;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\n\nstatic void nested_svm_uninit_mmu_context(struct kvm_vcpu *vcpu)\n{\n\tvcpu->arch.walk_mmu = &vcpu->arch.mmu;\n}"
  },
  {
    "function_name": "nested_svm_init_mmu_context",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "2228-2239",
    "snippet": "static void nested_svm_init_mmu_context(struct kvm_vcpu *vcpu)\n{\n\tWARN_ON(mmu_is_nested(vcpu));\n\tkvm_init_shadow_mmu(vcpu);\n\tvcpu->arch.mmu.set_cr3           = nested_svm_set_tdp_cr3;\n\tvcpu->arch.mmu.get_cr3           = nested_svm_get_tdp_cr3;\n\tvcpu->arch.mmu.get_pdptr         = nested_svm_get_tdp_pdptr;\n\tvcpu->arch.mmu.inject_page_fault = nested_svm_inject_npf_exit;\n\tvcpu->arch.mmu.shadow_root_level = get_npt_level();\n\treset_shadow_zero_bits_mask(vcpu, &vcpu->arch.mmu);\n\tvcpu->arch.walk_mmu              = &vcpu->arch.nested_mmu;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "reset_shadow_zero_bits_mask",
          "args": [
            "vcpu",
            "&vcpu->arch.mmu"
          ],
          "line": 2237
        },
        "resolved": true,
        "details": {
          "function_name": "reset_shadow_zero_bits_mask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "3808-3822",
          "snippet": "void\nreset_shadow_zero_bits_mask(struct kvm_vcpu *vcpu, struct kvm_mmu *context)\n{\n\tbool uses_nx = context->nx || context->base_role.smep_andnot_wp;\n\n\t/*\n\t * Passing \"true\" to the last argument is okay; it adds a check\n\t * on bit 8 of the SPTEs which KVM doesn't use anyway.\n\t */\n\t__reset_rsvds_bits_mask(vcpu, &context->shadow_zero_check,\n\t\t\t\tboot_cpu_data.x86_phys_bits,\n\t\t\t\tcontext->shadow_root_level, uses_nx,\n\t\t\t\tguest_cpuid_has_gbpages(vcpu), is_pse(vcpu),\n\t\t\t\ttrue);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nvoid\nreset_shadow_zero_bits_mask(struct kvm_vcpu *vcpu, struct kvm_mmu *context)\n{\n\tbool uses_nx = context->nx || context->base_role.smep_andnot_wp;\n\n\t/*\n\t * Passing \"true\" to the last argument is okay; it adds a check\n\t * on bit 8 of the SPTEs which KVM doesn't use anyway.\n\t */\n\t__reset_rsvds_bits_mask(vcpu, &context->shadow_zero_check,\n\t\t\t\tboot_cpu_data.x86_phys_bits,\n\t\t\t\tcontext->shadow_root_level, uses_nx,\n\t\t\t\tguest_cpuid_has_gbpages(vcpu), is_pse(vcpu),\n\t\t\t\ttrue);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_npt_level",
          "args": [],
          "line": 2236
        },
        "resolved": true,
        "details": {
          "function_name": "get_npt_level",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "526-533",
          "snippet": "static int get_npt_level(void)\n{\n#ifdef CONFIG_X86_64\n\treturn PT64_ROOT_LEVEL;\n#else\n\treturn PT32E_ROOT_LEVEL;\n#endif\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int get_npt_level(void)\n{\n#ifdef CONFIG_X86_64\n\treturn PT64_ROOT_LEVEL;\n#else\n\treturn PT32E_ROOT_LEVEL;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_init_shadow_mmu",
          "args": [
            "vcpu"
          ],
          "line": 2231
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_init_shadow_mmu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "4113-4139",
          "snippet": "void kvm_init_shadow_mmu(struct kvm_vcpu *vcpu)\n{\n\tbool smep = kvm_read_cr4_bits(vcpu, X86_CR4_SMEP);\n\tbool smap = kvm_read_cr4_bits(vcpu, X86_CR4_SMAP);\n\tstruct kvm_mmu *context = &vcpu->arch.mmu;\n\n\tMMU_WARN_ON(VALID_PAGE(context->root_hpa));\n\n\tif (!is_paging(vcpu))\n\t\tnonpaging_init_context(vcpu, context);\n\telse if (is_long_mode(vcpu))\n\t\tpaging64_init_context(vcpu, context);\n\telse if (is_pae(vcpu))\n\t\tpaging32E_init_context(vcpu, context);\n\telse\n\t\tpaging32_init_context(vcpu, context);\n\n\tcontext->base_role.nxe = is_nx(vcpu);\n\tcontext->base_role.cr4_pae = !!is_pae(vcpu);\n\tcontext->base_role.cr0_wp  = is_write_protection(vcpu);\n\tcontext->base_role.smep_andnot_wp\n\t\t= smep && !is_write_protection(vcpu);\n\tcontext->base_role.smap_andnot_wp\n\t\t= smap && !is_write_protection(vcpu);\n\tcontext->base_role.smm = is_smm(vcpu);\n\treset_shadow_zero_bits_mask(vcpu, context);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nvoid kvm_init_shadow_mmu(struct kvm_vcpu *vcpu)\n{\n\tbool smep = kvm_read_cr4_bits(vcpu, X86_CR4_SMEP);\n\tbool smap = kvm_read_cr4_bits(vcpu, X86_CR4_SMAP);\n\tstruct kvm_mmu *context = &vcpu->arch.mmu;\n\n\tMMU_WARN_ON(VALID_PAGE(context->root_hpa));\n\n\tif (!is_paging(vcpu))\n\t\tnonpaging_init_context(vcpu, context);\n\telse if (is_long_mode(vcpu))\n\t\tpaging64_init_context(vcpu, context);\n\telse if (is_pae(vcpu))\n\t\tpaging32E_init_context(vcpu, context);\n\telse\n\t\tpaging32_init_context(vcpu, context);\n\n\tcontext->base_role.nxe = is_nx(vcpu);\n\tcontext->base_role.cr4_pae = !!is_pae(vcpu);\n\tcontext->base_role.cr0_wp  = is_write_protection(vcpu);\n\tcontext->base_role.smep_andnot_wp\n\t\t= smep && !is_write_protection(vcpu);\n\tcontext->base_role.smap_andnot_wp\n\t\t= smap && !is_write_protection(vcpu);\n\tcontext->base_role.smm = is_smm(vcpu);\n\treset_shadow_zero_bits_mask(vcpu, context);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "mmu_is_nested(vcpu)"
          ],
          "line": 2230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmu_is_nested",
          "args": [
            "vcpu"
          ],
          "line": 2230
        },
        "resolved": true,
        "details": {
          "function_name": "mmu_is_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.h",
          "lines": "62-65",
          "snippet": "static inline bool mmu_is_nested(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.walk_mmu == &vcpu->arch.nested_mmu;\n}",
          "includes": [
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline bool mmu_is_nested(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.walk_mmu == &vcpu->arch.nested_mmu;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\n\nstatic void nested_svm_init_mmu_context(struct kvm_vcpu *vcpu)\n{\n\tWARN_ON(mmu_is_nested(vcpu));\n\tkvm_init_shadow_mmu(vcpu);\n\tvcpu->arch.mmu.set_cr3           = nested_svm_set_tdp_cr3;\n\tvcpu->arch.mmu.get_cr3           = nested_svm_get_tdp_cr3;\n\tvcpu->arch.mmu.get_pdptr         = nested_svm_get_tdp_pdptr;\n\tvcpu->arch.mmu.inject_page_fault = nested_svm_inject_npf_exit;\n\tvcpu->arch.mmu.shadow_root_level = get_npt_level();\n\treset_shadow_zero_bits_mask(vcpu, &vcpu->arch.mmu);\n\tvcpu->arch.walk_mmu              = &vcpu->arch.nested_mmu;\n}"
  },
  {
    "function_name": "nested_svm_inject_npf_exit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "2199-2226",
    "snippet": "static void nested_svm_inject_npf_exit(struct kvm_vcpu *vcpu,\n\t\t\t\t       struct x86_exception *fault)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (svm->vmcb->control.exit_code != SVM_EXIT_NPF) {\n\t\t/*\n\t\t * TODO: track the cause of the nested page fault, and\n\t\t * correctly fill in the high bits of exit_info_1.\n\t\t */\n\t\tsvm->vmcb->control.exit_code = SVM_EXIT_NPF;\n\t\tsvm->vmcb->control.exit_code_hi = 0;\n\t\tsvm->vmcb->control.exit_info_1 = (1ULL << 32);\n\t\tsvm->vmcb->control.exit_info_2 = fault->address;\n\t}\n\n\tsvm->vmcb->control.exit_info_1 &= ~0xffffffffULL;\n\tsvm->vmcb->control.exit_info_1 |= fault->error_code;\n\n\t/*\n\t * The present bit is always zero for page structure faults on real\n\t * hardware.\n\t */\n\tif (svm->vmcb->control.exit_info_1 & (2ULL << 32))\n\t\tsvm->vmcb->control.exit_info_1 &= ~1;\n\n\tnested_svm_vmexit(svm);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int nested = true;",
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);",
      "static int nested_svm_check_exception(struct vcpu_svm *svm, unsigned nr,\n\t\t\t\t      bool has_error_code, u32 error_code);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nested_svm_vmexit",
          "args": [
            "svm"
          ],
          "line": 2225
        },
        "resolved": true,
        "details": {
          "function_name": "nested_svm_vmexit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "2534-2655",
          "snippet": "static int nested_svm_vmexit(struct vcpu_svm *svm)\n{\n\tstruct vmcb *nested_vmcb;\n\tstruct vmcb *hsave = svm->nested.hsave;\n\tstruct vmcb *vmcb = svm->vmcb;\n\tstruct page *page;\n\n\ttrace_kvm_nested_vmexit_inject(vmcb->control.exit_code,\n\t\t\t\t       vmcb->control.exit_info_1,\n\t\t\t\t       vmcb->control.exit_info_2,\n\t\t\t\t       vmcb->control.exit_int_info,\n\t\t\t\t       vmcb->control.exit_int_info_err,\n\t\t\t\t       KVM_ISA_SVM);\n\n\tnested_vmcb = nested_svm_map(svm, svm->nested.vmcb, &page);\n\tif (!nested_vmcb)\n\t\treturn 1;\n\n\t/* Exit Guest-Mode */\n\tleave_guest_mode(&svm->vcpu);\n\tsvm->nested.vmcb = 0;\n\n\t/* Give the current vmcb to the guest */\n\tdisable_gif(svm);\n\n\tnested_vmcb->save.es     = vmcb->save.es;\n\tnested_vmcb->save.cs     = vmcb->save.cs;\n\tnested_vmcb->save.ss     = vmcb->save.ss;\n\tnested_vmcb->save.ds     = vmcb->save.ds;\n\tnested_vmcb->save.gdtr   = vmcb->save.gdtr;\n\tnested_vmcb->save.idtr   = vmcb->save.idtr;\n\tnested_vmcb->save.efer   = svm->vcpu.arch.efer;\n\tnested_vmcb->save.cr0    = kvm_read_cr0(&svm->vcpu);\n\tnested_vmcb->save.cr3    = kvm_read_cr3(&svm->vcpu);\n\tnested_vmcb->save.cr2    = vmcb->save.cr2;\n\tnested_vmcb->save.cr4    = svm->vcpu.arch.cr4;\n\tnested_vmcb->save.rflags = kvm_get_rflags(&svm->vcpu);\n\tnested_vmcb->save.rip    = vmcb->save.rip;\n\tnested_vmcb->save.rsp    = vmcb->save.rsp;\n\tnested_vmcb->save.rax    = vmcb->save.rax;\n\tnested_vmcb->save.dr7    = vmcb->save.dr7;\n\tnested_vmcb->save.dr6    = vmcb->save.dr6;\n\tnested_vmcb->save.cpl    = vmcb->save.cpl;\n\n\tnested_vmcb->control.int_ctl           = vmcb->control.int_ctl;\n\tnested_vmcb->control.int_vector        = vmcb->control.int_vector;\n\tnested_vmcb->control.int_state         = vmcb->control.int_state;\n\tnested_vmcb->control.exit_code         = vmcb->control.exit_code;\n\tnested_vmcb->control.exit_code_hi      = vmcb->control.exit_code_hi;\n\tnested_vmcb->control.exit_info_1       = vmcb->control.exit_info_1;\n\tnested_vmcb->control.exit_info_2       = vmcb->control.exit_info_2;\n\tnested_vmcb->control.exit_int_info     = vmcb->control.exit_int_info;\n\tnested_vmcb->control.exit_int_info_err = vmcb->control.exit_int_info_err;\n\n\tif (svm->nrips_enabled)\n\t\tnested_vmcb->control.next_rip  = vmcb->control.next_rip;\n\n\t/*\n\t * If we emulate a VMRUN/#VMEXIT in the same host #vmexit cycle we have\n\t * to make sure that we do not lose injected events. So check event_inj\n\t * here and copy it to exit_int_info if it is valid.\n\t * Exit_int_info and event_inj can't be both valid because the case\n\t * below only happens on a VMRUN instruction intercept which has\n\t * no valid exit_int_info set.\n\t */\n\tif (vmcb->control.event_inj & SVM_EVTINJ_VALID) {\n\t\tstruct vmcb_control_area *nc = &nested_vmcb->control;\n\n\t\tnc->exit_int_info     = vmcb->control.event_inj;\n\t\tnc->exit_int_info_err = vmcb->control.event_inj_err;\n\t}\n\n\tnested_vmcb->control.tlb_ctl           = 0;\n\tnested_vmcb->control.event_inj         = 0;\n\tnested_vmcb->control.event_inj_err     = 0;\n\n\t/* We always set V_INTR_MASKING and remember the old value in hflags */\n\tif (!(svm->vcpu.arch.hflags & HF_VINTR_MASK))\n\t\tnested_vmcb->control.int_ctl &= ~V_INTR_MASKING_MASK;\n\n\t/* Restore the original control entries */\n\tcopy_vmcb_control_area(vmcb, hsave);\n\n\tkvm_clear_exception_queue(&svm->vcpu);\n\tkvm_clear_interrupt_queue(&svm->vcpu);\n\n\tsvm->nested.nested_cr3 = 0;\n\n\t/* Restore selected save entries */\n\tsvm->vmcb->save.es = hsave->save.es;\n\tsvm->vmcb->save.cs = hsave->save.cs;\n\tsvm->vmcb->save.ss = hsave->save.ss;\n\tsvm->vmcb->save.ds = hsave->save.ds;\n\tsvm->vmcb->save.gdtr = hsave->save.gdtr;\n\tsvm->vmcb->save.idtr = hsave->save.idtr;\n\tkvm_set_rflags(&svm->vcpu, hsave->save.rflags);\n\tsvm_set_efer(&svm->vcpu, hsave->save.efer);\n\tsvm_set_cr0(&svm->vcpu, hsave->save.cr0 | X86_CR0_PE);\n\tsvm_set_cr4(&svm->vcpu, hsave->save.cr4);\n\tif (npt_enabled) {\n\t\tsvm->vmcb->save.cr3 = hsave->save.cr3;\n\t\tsvm->vcpu.arch.cr3 = hsave->save.cr3;\n\t} else {\n\t\t(void)kvm_set_cr3(&svm->vcpu, hsave->save.cr3);\n\t}\n\tkvm_register_write(&svm->vcpu, VCPU_REGS_RAX, hsave->save.rax);\n\tkvm_register_write(&svm->vcpu, VCPU_REGS_RSP, hsave->save.rsp);\n\tkvm_register_write(&svm->vcpu, VCPU_REGS_RIP, hsave->save.rip);\n\tsvm->vmcb->save.dr7 = 0;\n\tsvm->vmcb->save.cpl = 0;\n\tsvm->vmcb->control.exit_int_info = 0;\n\n\tmark_all_dirty(svm->vmcb);\n\n\tnested_svm_unmap(page);\n\n\tnested_svm_uninit_mmu_context(&svm->vcpu);\n\tkvm_mmu_reset_context(&svm->vcpu);\n\tkvm_mmu_load(&svm->vcpu);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nested = true;",
            "static void svm_set_cr0(struct kvm_vcpu *vcpu, unsigned long cr0);",
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int nested = true;\nstatic void svm_set_cr0(struct kvm_vcpu *vcpu, unsigned long cr0);\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic int nested_svm_vmexit(struct vcpu_svm *svm)\n{\n\tstruct vmcb *nested_vmcb;\n\tstruct vmcb *hsave = svm->nested.hsave;\n\tstruct vmcb *vmcb = svm->vmcb;\n\tstruct page *page;\n\n\ttrace_kvm_nested_vmexit_inject(vmcb->control.exit_code,\n\t\t\t\t       vmcb->control.exit_info_1,\n\t\t\t\t       vmcb->control.exit_info_2,\n\t\t\t\t       vmcb->control.exit_int_info,\n\t\t\t\t       vmcb->control.exit_int_info_err,\n\t\t\t\t       KVM_ISA_SVM);\n\n\tnested_vmcb = nested_svm_map(svm, svm->nested.vmcb, &page);\n\tif (!nested_vmcb)\n\t\treturn 1;\n\n\t/* Exit Guest-Mode */\n\tleave_guest_mode(&svm->vcpu);\n\tsvm->nested.vmcb = 0;\n\n\t/* Give the current vmcb to the guest */\n\tdisable_gif(svm);\n\n\tnested_vmcb->save.es     = vmcb->save.es;\n\tnested_vmcb->save.cs     = vmcb->save.cs;\n\tnested_vmcb->save.ss     = vmcb->save.ss;\n\tnested_vmcb->save.ds     = vmcb->save.ds;\n\tnested_vmcb->save.gdtr   = vmcb->save.gdtr;\n\tnested_vmcb->save.idtr   = vmcb->save.idtr;\n\tnested_vmcb->save.efer   = svm->vcpu.arch.efer;\n\tnested_vmcb->save.cr0    = kvm_read_cr0(&svm->vcpu);\n\tnested_vmcb->save.cr3    = kvm_read_cr3(&svm->vcpu);\n\tnested_vmcb->save.cr2    = vmcb->save.cr2;\n\tnested_vmcb->save.cr4    = svm->vcpu.arch.cr4;\n\tnested_vmcb->save.rflags = kvm_get_rflags(&svm->vcpu);\n\tnested_vmcb->save.rip    = vmcb->save.rip;\n\tnested_vmcb->save.rsp    = vmcb->save.rsp;\n\tnested_vmcb->save.rax    = vmcb->save.rax;\n\tnested_vmcb->save.dr7    = vmcb->save.dr7;\n\tnested_vmcb->save.dr6    = vmcb->save.dr6;\n\tnested_vmcb->save.cpl    = vmcb->save.cpl;\n\n\tnested_vmcb->control.int_ctl           = vmcb->control.int_ctl;\n\tnested_vmcb->control.int_vector        = vmcb->control.int_vector;\n\tnested_vmcb->control.int_state         = vmcb->control.int_state;\n\tnested_vmcb->control.exit_code         = vmcb->control.exit_code;\n\tnested_vmcb->control.exit_code_hi      = vmcb->control.exit_code_hi;\n\tnested_vmcb->control.exit_info_1       = vmcb->control.exit_info_1;\n\tnested_vmcb->control.exit_info_2       = vmcb->control.exit_info_2;\n\tnested_vmcb->control.exit_int_info     = vmcb->control.exit_int_info;\n\tnested_vmcb->control.exit_int_info_err = vmcb->control.exit_int_info_err;\n\n\tif (svm->nrips_enabled)\n\t\tnested_vmcb->control.next_rip  = vmcb->control.next_rip;\n\n\t/*\n\t * If we emulate a VMRUN/#VMEXIT in the same host #vmexit cycle we have\n\t * to make sure that we do not lose injected events. So check event_inj\n\t * here and copy it to exit_int_info if it is valid.\n\t * Exit_int_info and event_inj can't be both valid because the case\n\t * below only happens on a VMRUN instruction intercept which has\n\t * no valid exit_int_info set.\n\t */\n\tif (vmcb->control.event_inj & SVM_EVTINJ_VALID) {\n\t\tstruct vmcb_control_area *nc = &nested_vmcb->control;\n\n\t\tnc->exit_int_info     = vmcb->control.event_inj;\n\t\tnc->exit_int_info_err = vmcb->control.event_inj_err;\n\t}\n\n\tnested_vmcb->control.tlb_ctl           = 0;\n\tnested_vmcb->control.event_inj         = 0;\n\tnested_vmcb->control.event_inj_err     = 0;\n\n\t/* We always set V_INTR_MASKING and remember the old value in hflags */\n\tif (!(svm->vcpu.arch.hflags & HF_VINTR_MASK))\n\t\tnested_vmcb->control.int_ctl &= ~V_INTR_MASKING_MASK;\n\n\t/* Restore the original control entries */\n\tcopy_vmcb_control_area(vmcb, hsave);\n\n\tkvm_clear_exception_queue(&svm->vcpu);\n\tkvm_clear_interrupt_queue(&svm->vcpu);\n\n\tsvm->nested.nested_cr3 = 0;\n\n\t/* Restore selected save entries */\n\tsvm->vmcb->save.es = hsave->save.es;\n\tsvm->vmcb->save.cs = hsave->save.cs;\n\tsvm->vmcb->save.ss = hsave->save.ss;\n\tsvm->vmcb->save.ds = hsave->save.ds;\n\tsvm->vmcb->save.gdtr = hsave->save.gdtr;\n\tsvm->vmcb->save.idtr = hsave->save.idtr;\n\tkvm_set_rflags(&svm->vcpu, hsave->save.rflags);\n\tsvm_set_efer(&svm->vcpu, hsave->save.efer);\n\tsvm_set_cr0(&svm->vcpu, hsave->save.cr0 | X86_CR0_PE);\n\tsvm_set_cr4(&svm->vcpu, hsave->save.cr4);\n\tif (npt_enabled) {\n\t\tsvm->vmcb->save.cr3 = hsave->save.cr3;\n\t\tsvm->vcpu.arch.cr3 = hsave->save.cr3;\n\t} else {\n\t\t(void)kvm_set_cr3(&svm->vcpu, hsave->save.cr3);\n\t}\n\tkvm_register_write(&svm->vcpu, VCPU_REGS_RAX, hsave->save.rax);\n\tkvm_register_write(&svm->vcpu, VCPU_REGS_RSP, hsave->save.rsp);\n\tkvm_register_write(&svm->vcpu, VCPU_REGS_RIP, hsave->save.rip);\n\tsvm->vmcb->save.dr7 = 0;\n\tsvm->vmcb->save.cpl = 0;\n\tsvm->vmcb->control.exit_int_info = 0;\n\n\tmark_all_dirty(svm->vmcb);\n\n\tnested_svm_unmap(page);\n\n\tnested_svm_uninit_mmu_context(&svm->vcpu);\n\tkvm_mmu_reset_context(&svm->vcpu);\n\tkvm_mmu_load(&svm->vcpu);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 2202
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "294-297",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int nested = true;\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\nstatic int nested_svm_check_exception(struct vcpu_svm *svm, unsigned nr,\n\t\t\t\t      bool has_error_code, u32 error_code);\n\nstatic void nested_svm_inject_npf_exit(struct kvm_vcpu *vcpu,\n\t\t\t\t       struct x86_exception *fault)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (svm->vmcb->control.exit_code != SVM_EXIT_NPF) {\n\t\t/*\n\t\t * TODO: track the cause of the nested page fault, and\n\t\t * correctly fill in the high bits of exit_info_1.\n\t\t */\n\t\tsvm->vmcb->control.exit_code = SVM_EXIT_NPF;\n\t\tsvm->vmcb->control.exit_code_hi = 0;\n\t\tsvm->vmcb->control.exit_info_1 = (1ULL << 32);\n\t\tsvm->vmcb->control.exit_info_2 = fault->address;\n\t}\n\n\tsvm->vmcb->control.exit_info_1 &= ~0xffffffffULL;\n\tsvm->vmcb->control.exit_info_1 |= fault->error_code;\n\n\t/*\n\t * The present bit is always zero for page structure faults on real\n\t * hardware.\n\t */\n\tif (svm->vmcb->control.exit_info_1 & (2ULL << 32))\n\t\tsvm->vmcb->control.exit_info_1 &= ~1;\n\n\tnested_svm_vmexit(svm);\n}"
  },
  {
    "function_name": "nested_svm_set_tdp_cr3",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "2189-2197",
    "snippet": "static void nested_svm_set_tdp_cr3(struct kvm_vcpu *vcpu,\n\t\t\t\t   unsigned long root)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tsvm->vmcb->control.nested_cr3 = root;\n\tmark_dirty(svm->vmcb, VMCB_NPT);\n\tsvm_flush_tlb(vcpu);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "svm_flush_tlb",
          "args": [
            "vcpu"
          ],
          "line": 2196
        },
        "resolved": true,
        "details": {
          "function_name": "svm_flush_tlb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "4334-4342",
          "snippet": "static void svm_flush_tlb(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (static_cpu_has(X86_FEATURE_FLUSHBYASID))\n\t\tsvm->vmcb->control.tlb_ctl = TLB_CONTROL_FLUSH_ASID;\n\telse\n\t\tsvm->asid_generation--;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (static_cpu_has(X86_FEATURE_FLUSHBYASID))\n\t\tsvm->vmcb->control.tlb_ctl = TLB_CONTROL_FLUSH_ASID;\n\telse\n\t\tsvm->asid_generation--;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_dirty",
          "args": [
            "svm->vmcb",
            "VMCB_NPT"
          ],
          "line": 2195
        },
        "resolved": true,
        "details": {
          "function_name": "mark_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "289-292",
          "snippet": "static inline void mark_dirty(struct vmcb *vmcb, int bit)\n{\n\tvmcb->control.clean &= ~(1 << bit);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic inline void mark_dirty(struct vmcb *vmcb, int bit)\n{\n\tvmcb->control.clean &= ~(1 << bit);\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 2192
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "294-297",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic void nested_svm_set_tdp_cr3(struct kvm_vcpu *vcpu,\n\t\t\t\t   unsigned long root)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tsvm->vmcb->control.nested_cr3 = root;\n\tmark_dirty(svm->vmcb, VMCB_NPT);\n\tsvm_flush_tlb(vcpu);\n}"
  },
  {
    "function_name": "nested_svm_get_tdp_pdptr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "2175-2187",
    "snippet": "static u64 nested_svm_get_tdp_pdptr(struct kvm_vcpu *vcpu, int index)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tu64 cr3 = svm->nested.nested_cr3;\n\tu64 pdpte;\n\tint ret;\n\n\tret = kvm_vcpu_read_guest_page(vcpu, gpa_to_gfn(cr3), &pdpte,\n\t\t\t\t       offset_in_page(cr3) + index * 8, 8);\n\tif (ret)\n\t\treturn 0;\n\treturn pdpte;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int nested = true;",
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_vcpu_read_guest_page",
          "args": [
            "vcpu",
            "gpa_to_gfn(cr3)",
            "&pdpte",
            "offset_in_page(cr3) + index * 8",
            "8"
          ],
          "line": 2182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "offset_in_page",
          "args": [
            "cr3"
          ],
          "line": 2183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gpa_to_gfn",
          "args": [
            "cr3"
          ],
          "line": 2182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 2177
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "294-297",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int nested = true;\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic u64 nested_svm_get_tdp_pdptr(struct kvm_vcpu *vcpu, int index)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tu64 cr3 = svm->nested.nested_cr3;\n\tu64 pdpte;\n\tint ret;\n\n\tret = kvm_vcpu_read_guest_page(vcpu, gpa_to_gfn(cr3), &pdpte,\n\t\t\t\t       offset_in_page(cr3) + index * 8, 8);\n\tif (ret)\n\t\treturn 0;\n\treturn pdpte;\n}"
  },
  {
    "function_name": "nested_svm_get_tdp_cr3",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "2168-2173",
    "snippet": "static unsigned long nested_svm_get_tdp_cr3(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\treturn svm->nested.nested_cr3;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int nested = true;",
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 2170
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "294-297",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int nested = true;\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic unsigned long nested_svm_get_tdp_cr3(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\treturn svm->nested.nested_cr3;\n}"
  },
  {
    "function_name": "vmmcall_interception",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "2162-2166",
    "snippet": "static int vmmcall_interception(struct vcpu_svm *svm)\n{\n\tsvm->next_rip = kvm_rip_read(&svm->vcpu) + 3;\n\treturn kvm_emulate_hypercall(&svm->vcpu);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_emulate_hypercall",
          "args": [
            "&svm->vcpu"
          ],
          "line": 2165
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_emulate_hypercall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "5948-5998",
          "snippet": "int kvm_emulate_hypercall(struct kvm_vcpu *vcpu)\n{\n\tunsigned long nr, a0, a1, a2, a3, ret;\n\tint op_64_bit, r = 1;\n\n\tkvm_x86_ops->skip_emulated_instruction(vcpu);\n\n\tif (kvm_hv_hypercall_enabled(vcpu->kvm))\n\t\treturn kvm_hv_hypercall(vcpu);\n\n\tnr = kvm_register_read(vcpu, VCPU_REGS_RAX);\n\ta0 = kvm_register_read(vcpu, VCPU_REGS_RBX);\n\ta1 = kvm_register_read(vcpu, VCPU_REGS_RCX);\n\ta2 = kvm_register_read(vcpu, VCPU_REGS_RDX);\n\ta3 = kvm_register_read(vcpu, VCPU_REGS_RSI);\n\n\ttrace_kvm_hypercall(nr, a0, a1, a2, a3);\n\n\top_64_bit = is_64_bit_mode(vcpu);\n\tif (!op_64_bit) {\n\t\tnr &= 0xFFFFFFFF;\n\t\ta0 &= 0xFFFFFFFF;\n\t\ta1 &= 0xFFFFFFFF;\n\t\ta2 &= 0xFFFFFFFF;\n\t\ta3 &= 0xFFFFFFFF;\n\t}\n\n\tif (kvm_x86_ops->get_cpl(vcpu) != 0) {\n\t\tret = -KVM_EPERM;\n\t\tgoto out;\n\t}\n\n\tswitch (nr) {\n\tcase KVM_HC_VAPIC_POLL_IRQ:\n\t\tret = 0;\n\t\tbreak;\n\tcase KVM_HC_KICK_CPU:\n\t\tkvm_pv_kick_cpu_op(vcpu->kvm, a0, a1);\n\t\tret = 0;\n\t\tbreak;\n\tdefault:\n\t\tret = -KVM_ENOSYS;\n\t\tbreak;\n\t}\nout:\n\tif (!op_64_bit)\n\t\tret = (u32)ret;\n\tkvm_register_write(vcpu, VCPU_REGS_RAX, ret);\n\t++vcpu->stat.hypercalls;\n\treturn r;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "struct kvm_x86_ops *kvm_x86_ops"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nint kvm_emulate_hypercall(struct kvm_vcpu *vcpu)\n{\n\tunsigned long nr, a0, a1, a2, a3, ret;\n\tint op_64_bit, r = 1;\n\n\tkvm_x86_ops->skip_emulated_instruction(vcpu);\n\n\tif (kvm_hv_hypercall_enabled(vcpu->kvm))\n\t\treturn kvm_hv_hypercall(vcpu);\n\n\tnr = kvm_register_read(vcpu, VCPU_REGS_RAX);\n\ta0 = kvm_register_read(vcpu, VCPU_REGS_RBX);\n\ta1 = kvm_register_read(vcpu, VCPU_REGS_RCX);\n\ta2 = kvm_register_read(vcpu, VCPU_REGS_RDX);\n\ta3 = kvm_register_read(vcpu, VCPU_REGS_RSI);\n\n\ttrace_kvm_hypercall(nr, a0, a1, a2, a3);\n\n\top_64_bit = is_64_bit_mode(vcpu);\n\tif (!op_64_bit) {\n\t\tnr &= 0xFFFFFFFF;\n\t\ta0 &= 0xFFFFFFFF;\n\t\ta1 &= 0xFFFFFFFF;\n\t\ta2 &= 0xFFFFFFFF;\n\t\ta3 &= 0xFFFFFFFF;\n\t}\n\n\tif (kvm_x86_ops->get_cpl(vcpu) != 0) {\n\t\tret = -KVM_EPERM;\n\t\tgoto out;\n\t}\n\n\tswitch (nr) {\n\tcase KVM_HC_VAPIC_POLL_IRQ:\n\t\tret = 0;\n\t\tbreak;\n\tcase KVM_HC_KICK_CPU:\n\t\tkvm_pv_kick_cpu_op(vcpu->kvm, a0, a1);\n\t\tret = 0;\n\t\tbreak;\n\tdefault:\n\t\tret = -KVM_ENOSYS;\n\t\tbreak;\n\t}\nout:\n\tif (!op_64_bit)\n\t\tret = (u32)ret;\n\tkvm_register_write(vcpu, VCPU_REGS_RAX, ret);\n\t++vcpu->stat.hypercalls;\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_rip_read",
          "args": [
            "&svm->vcpu"
          ],
          "line": 2164
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_rip_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "27-30",
          "snippet": "static inline unsigned long kvm_rip_read(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_register_read(vcpu, VCPU_REGS_RIP);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline unsigned long kvm_rip_read(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_register_read(vcpu, VCPU_REGS_RIP);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic int vmmcall_interception(struct vcpu_svm *svm)\n{\n\tsvm->next_rip = kvm_rip_read(&svm->vcpu) + 3;\n\treturn kvm_emulate_hypercall(&svm->vcpu);\n}"
  },
  {
    "function_name": "halt_interception",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "2156-2160",
    "snippet": "static int halt_interception(struct vcpu_svm *svm)\n{\n\tsvm->next_rip = kvm_rip_read(&svm->vcpu) + 1;\n\treturn kvm_emulate_halt(&svm->vcpu);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_emulate_halt",
          "args": [
            "&svm->vcpu"
          ],
          "line": 2159
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_emulate_halt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "5917-5921",
          "snippet": "int kvm_emulate_halt(struct kvm_vcpu *vcpu)\n{\n\tkvm_x86_ops->skip_emulated_instruction(vcpu);\n\treturn kvm_vcpu_halt(vcpu);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "struct kvm_x86_ops *kvm_x86_ops"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nint kvm_emulate_halt(struct kvm_vcpu *vcpu)\n{\n\tkvm_x86_ops->skip_emulated_instruction(vcpu);\n\treturn kvm_vcpu_halt(vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_rip_read",
          "args": [
            "&svm->vcpu"
          ],
          "line": 2158
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_rip_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "27-30",
          "snippet": "static inline unsigned long kvm_rip_read(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_register_read(vcpu, VCPU_REGS_RIP);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline unsigned long kvm_rip_read(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_register_read(vcpu, VCPU_REGS_RIP);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic int halt_interception(struct vcpu_svm *svm)\n{\n\tsvm->next_rip = kvm_rip_read(&svm->vcpu) + 1;\n\treturn kvm_emulate_halt(&svm->vcpu);\n}"
  },
  {
    "function_name": "nop_on_interception",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "2151-2154",
    "snippet": "static int nop_on_interception(struct vcpu_svm *svm)\n{\n\treturn 1;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic int nop_on_interception(struct vcpu_svm *svm)\n{\n\treturn 1;\n}"
  },
  {
    "function_name": "intr_interception",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "2145-2149",
    "snippet": "static int intr_interception(struct vcpu_svm *svm)\n{\n\t++svm->vcpu.stat.irq_exits;\n\treturn 1;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic int intr_interception(struct vcpu_svm *svm)\n{\n\t++svm->vcpu.stat.irq_exits;\n\treturn 1;\n}"
  },
  {
    "function_name": "nmi_interception",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "2140-2143",
    "snippet": "static int nmi_interception(struct vcpu_svm *svm)\n{\n\treturn 1;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic int nmi_interception(struct vcpu_svm *svm)\n{\n\treturn 1;\n}"
  },
  {
    "function_name": "io_interception",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "2119-2138",
    "snippet": "static int io_interception(struct vcpu_svm *svm)\n{\n\tstruct kvm_vcpu *vcpu = &svm->vcpu;\n\tu32 io_info = svm->vmcb->control.exit_info_1; /* address size bug? */\n\tint size, in, string;\n\tunsigned port;\n\n\t++svm->vcpu.stat.io_exits;\n\tstring = (io_info & SVM_IOIO_STR_MASK) != 0;\n\tin = (io_info & SVM_IOIO_TYPE_MASK) != 0;\n\tif (string || in)\n\t\treturn emulate_instruction(vcpu, 0) == EMULATE_DONE;\n\n\tport = io_info >> 16;\n\tsize = (io_info & SVM_IOIO_SIZE_MASK) >> SVM_IOIO_SIZE_SHIFT;\n\tsvm->next_rip = svm->vmcb->control.exit_info_2;\n\tskip_emulated_instruction(&svm->vcpu);\n\n\treturn kvm_fast_pio_out(vcpu, size, port);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_fast_pio_out",
          "args": [
            "vcpu",
            "size",
            "port"
          ],
          "line": 2137
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_fast_pio_out",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "5540-5548",
          "snippet": "int kvm_fast_pio_out(struct kvm_vcpu *vcpu, int size, unsigned short port)\n{\n\tunsigned long val = kvm_register_read(vcpu, VCPU_REGS_RAX);\n\tint ret = emulator_pio_out_emulated(&vcpu->arch.emulate_ctxt,\n\t\t\t\t\t    size, port, &val, 1);\n\t/* do not return to emulator after return from userspace */\n\tvcpu->arch.pio.count = 0;\n\treturn ret;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nint kvm_fast_pio_out(struct kvm_vcpu *vcpu, int size, unsigned short port)\n{\n\tunsigned long val = kvm_register_read(vcpu, VCPU_REGS_RAX);\n\tint ret = emulator_pio_out_emulated(&vcpu->arch.emulate_ctxt,\n\t\t\t\t\t    size, port, &val, 1);\n\t/* do not return to emulator after return from userspace */\n\tvcpu->arch.pio.count = 0;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "skip_emulated_instruction",
          "args": [
            "&svm->vcpu"
          ],
          "line": 2135
        },
        "resolved": true,
        "details": {
          "function_name": "skip_emulated_instruction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "572-593",
          "snippet": "static void skip_emulated_instruction(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (svm->vmcb->control.next_rip != 0) {\n\t\tWARN_ON_ONCE(!static_cpu_has(X86_FEATURE_NRIPS));\n\t\tsvm->next_rip = svm->vmcb->control.next_rip;\n\t}\n\n\tif (!svm->next_rip) {\n\t\tif (emulate_instruction(vcpu, EMULTYPE_SKIP) !=\n\t\t\t\tEMULATE_DONE)\n\t\t\tprintk(KERN_DEBUG \"%s: NOP\\n\", __func__);\n\t\treturn;\n\t}\n\tif (svm->next_rip - kvm_rip_read(vcpu) > MAX_INST_SIZE)\n\t\tprintk(KERN_ERR \"%s: ip 0x%lx next 0x%llx\\n\",\n\t\t       __func__, kvm_rip_read(vcpu), svm->next_rip);\n\n\tkvm_rip_write(vcpu, svm->next_rip);\n\tsvm_set_interrupt_shadow(vcpu, 0);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define MAX_INST_SIZE 15"
          ],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define MAX_INST_SIZE 15\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic void skip_emulated_instruction(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (svm->vmcb->control.next_rip != 0) {\n\t\tWARN_ON_ONCE(!static_cpu_has(X86_FEATURE_NRIPS));\n\t\tsvm->next_rip = svm->vmcb->control.next_rip;\n\t}\n\n\tif (!svm->next_rip) {\n\t\tif (emulate_instruction(vcpu, EMULTYPE_SKIP) !=\n\t\t\t\tEMULATE_DONE)\n\t\t\tprintk(KERN_DEBUG \"%s: NOP\\n\", __func__);\n\t\treturn;\n\t}\n\tif (svm->next_rip - kvm_rip_read(vcpu) > MAX_INST_SIZE)\n\t\tprintk(KERN_ERR \"%s: ip 0x%lx next 0x%llx\\n\",\n\t\t       __func__, kvm_rip_read(vcpu), svm->next_rip);\n\n\tkvm_rip_write(vcpu, svm->next_rip);\n\tsvm_set_interrupt_shadow(vcpu, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "emulate_instruction",
          "args": [
            "vcpu",
            "0"
          ],
          "line": 2130
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic int io_interception(struct vcpu_svm *svm)\n{\n\tstruct kvm_vcpu *vcpu = &svm->vcpu;\n\tu32 io_info = svm->vmcb->control.exit_info_1; /* address size bug? */\n\tint size, in, string;\n\tunsigned port;\n\n\t++svm->vcpu.stat.io_exits;\n\tstring = (io_info & SVM_IOIO_STR_MASK) != 0;\n\tin = (io_info & SVM_IOIO_TYPE_MASK) != 0;\n\tif (string || in)\n\t\treturn emulate_instruction(vcpu, 0) == EMULATE_DONE;\n\n\tport = io_info >> 16;\n\tsize = (io_info & SVM_IOIO_SIZE_MASK) >> SVM_IOIO_SIZE_SHIFT;\n\tsvm->next_rip = svm->vmcb->control.exit_info_2;\n\tskip_emulated_instruction(&svm->vcpu);\n\n\treturn kvm_fast_pio_out(vcpu, size, port);\n}"
  },
  {
    "function_name": "shutdown_interception",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "2104-2117",
    "snippet": "static int shutdown_interception(struct vcpu_svm *svm)\n{\n\tstruct kvm_run *kvm_run = svm->vcpu.run;\n\n\t/*\n\t * VMCB is undefined after a SHUTDOWN intercept\n\t * so reinitialize it.\n\t */\n\tclear_page(svm->vmcb);\n\tinit_vmcb(svm);\n\n\tkvm_run->exit_reason = KVM_EXIT_SHUTDOWN;\n\treturn 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "init_vmcb",
          "args": [
            "svm"
          ],
          "line": 2113
        },
        "resolved": true,
        "details": {
          "function_name": "init_vmcb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "1083-1201",
          "snippet": "static void init_vmcb(struct vcpu_svm *svm)\n{\n\tstruct vmcb_control_area *control = &svm->vmcb->control;\n\tstruct vmcb_save_area *save = &svm->vmcb->save;\n\n\tsvm->vcpu.fpu_active = 1;\n\tsvm->vcpu.arch.hflags = 0;\n\n\tset_cr_intercept(svm, INTERCEPT_CR0_READ);\n\tset_cr_intercept(svm, INTERCEPT_CR3_READ);\n\tset_cr_intercept(svm, INTERCEPT_CR4_READ);\n\tset_cr_intercept(svm, INTERCEPT_CR0_WRITE);\n\tset_cr_intercept(svm, INTERCEPT_CR3_WRITE);\n\tset_cr_intercept(svm, INTERCEPT_CR4_WRITE);\n\tif (!kvm_vcpu_apicv_active(&svm->vcpu))\n\t\tset_cr_intercept(svm, INTERCEPT_CR8_WRITE);\n\n\tset_dr_intercepts(svm);\n\n\tset_exception_intercept(svm, PF_VECTOR);\n\tset_exception_intercept(svm, UD_VECTOR);\n\tset_exception_intercept(svm, MC_VECTOR);\n\tset_exception_intercept(svm, AC_VECTOR);\n\tset_exception_intercept(svm, DB_VECTOR);\n\n\tset_intercept(svm, INTERCEPT_INTR);\n\tset_intercept(svm, INTERCEPT_NMI);\n\tset_intercept(svm, INTERCEPT_SMI);\n\tset_intercept(svm, INTERCEPT_SELECTIVE_CR0);\n\tset_intercept(svm, INTERCEPT_RDPMC);\n\tset_intercept(svm, INTERCEPT_CPUID);\n\tset_intercept(svm, INTERCEPT_INVD);\n\tset_intercept(svm, INTERCEPT_HLT);\n\tset_intercept(svm, INTERCEPT_INVLPG);\n\tset_intercept(svm, INTERCEPT_INVLPGA);\n\tset_intercept(svm, INTERCEPT_IOIO_PROT);\n\tset_intercept(svm, INTERCEPT_MSR_PROT);\n\tset_intercept(svm, INTERCEPT_TASK_SWITCH);\n\tset_intercept(svm, INTERCEPT_SHUTDOWN);\n\tset_intercept(svm, INTERCEPT_VMRUN);\n\tset_intercept(svm, INTERCEPT_VMMCALL);\n\tset_intercept(svm, INTERCEPT_VMLOAD);\n\tset_intercept(svm, INTERCEPT_VMSAVE);\n\tset_intercept(svm, INTERCEPT_STGI);\n\tset_intercept(svm, INTERCEPT_CLGI);\n\tset_intercept(svm, INTERCEPT_SKINIT);\n\tset_intercept(svm, INTERCEPT_WBINVD);\n\tset_intercept(svm, INTERCEPT_MONITOR);\n\tset_intercept(svm, INTERCEPT_MWAIT);\n\tset_intercept(svm, INTERCEPT_XSETBV);\n\n\tcontrol->iopm_base_pa = iopm_base;\n\tcontrol->msrpm_base_pa = __pa(svm->msrpm);\n\tcontrol->int_ctl = V_INTR_MASKING_MASK;\n\n\tinit_seg(&save->es);\n\tinit_seg(&save->ss);\n\tinit_seg(&save->ds);\n\tinit_seg(&save->fs);\n\tinit_seg(&save->gs);\n\n\tsave->cs.selector = 0xf000;\n\tsave->cs.base = 0xffff0000;\n\t/* Executable/Readable Code Segment */\n\tsave->cs.attrib = SVM_SELECTOR_READ_MASK | SVM_SELECTOR_P_MASK |\n\t\tSVM_SELECTOR_S_MASK | SVM_SELECTOR_CODE_MASK;\n\tsave->cs.limit = 0xffff;\n\n\tsave->gdtr.limit = 0xffff;\n\tsave->idtr.limit = 0xffff;\n\n\tinit_sys_seg(&save->ldtr, SEG_TYPE_LDT);\n\tinit_sys_seg(&save->tr, SEG_TYPE_BUSY_TSS16);\n\n\tsvm_set_efer(&svm->vcpu, 0);\n\tsave->dr6 = 0xffff0ff0;\n\tkvm_set_rflags(&svm->vcpu, 2);\n\tsave->rip = 0x0000fff0;\n\tsvm->vcpu.arch.regs[VCPU_REGS_RIP] = save->rip;\n\n\t/*\n\t * svm_set_cr0() sets PG and WP and clears NW and CD on save->cr0.\n\t * It also updates the guest-visible cr0 value.\n\t */\n\tsvm_set_cr0(&svm->vcpu, X86_CR0_NW | X86_CR0_CD | X86_CR0_ET);\n\tkvm_mmu_reset_context(&svm->vcpu);\n\n\tsave->cr4 = X86_CR4_PAE;\n\t/* rdx = ?? */\n\n\tif (npt_enabled) {\n\t\t/* Setup VMCB for Nested Paging */\n\t\tcontrol->nested_ctl = 1;\n\t\tclr_intercept(svm, INTERCEPT_INVLPG);\n\t\tclr_exception_intercept(svm, PF_VECTOR);\n\t\tclr_cr_intercept(svm, INTERCEPT_CR3_READ);\n\t\tclr_cr_intercept(svm, INTERCEPT_CR3_WRITE);\n\t\tsave->g_pat = svm->vcpu.arch.pat;\n\t\tsave->cr3 = 0;\n\t\tsave->cr4 = 0;\n\t}\n\tsvm->asid_generation = 0;\n\n\tsvm->nested.vmcb = 0;\n\tsvm->vcpu.arch.hflags = 0;\n\n\tif (boot_cpu_has(X86_FEATURE_PAUSEFILTER)) {\n\t\tcontrol->pause_filter_count = 3000;\n\t\tset_intercept(svm, INTERCEPT_PAUSE);\n\t}\n\n\tif (avic)\n\t\tavic_init_vmcb(svm);\n\n\tmark_all_dirty(svm->vmcb);\n\n\tenable_gif(svm);\n\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define SEG_TYPE_BUSY_TSS16 3",
            "#define SEG_TYPE_LDT 2"
          ],
          "globals_used": [
            "static int nested = true;",
            "static int avic;",
            "static void svm_set_cr0(struct kvm_vcpu *vcpu, unsigned long cr0);",
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);",
            "static unsigned long iopm_base;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define SEG_TYPE_BUSY_TSS16 3\n#define SEG_TYPE_LDT 2\n\nstatic int nested = true;\nstatic int avic;\nstatic void svm_set_cr0(struct kvm_vcpu *vcpu, unsigned long cr0);\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\nstatic unsigned long iopm_base;\n\nstatic void init_vmcb(struct vcpu_svm *svm)\n{\n\tstruct vmcb_control_area *control = &svm->vmcb->control;\n\tstruct vmcb_save_area *save = &svm->vmcb->save;\n\n\tsvm->vcpu.fpu_active = 1;\n\tsvm->vcpu.arch.hflags = 0;\n\n\tset_cr_intercept(svm, INTERCEPT_CR0_READ);\n\tset_cr_intercept(svm, INTERCEPT_CR3_READ);\n\tset_cr_intercept(svm, INTERCEPT_CR4_READ);\n\tset_cr_intercept(svm, INTERCEPT_CR0_WRITE);\n\tset_cr_intercept(svm, INTERCEPT_CR3_WRITE);\n\tset_cr_intercept(svm, INTERCEPT_CR4_WRITE);\n\tif (!kvm_vcpu_apicv_active(&svm->vcpu))\n\t\tset_cr_intercept(svm, INTERCEPT_CR8_WRITE);\n\n\tset_dr_intercepts(svm);\n\n\tset_exception_intercept(svm, PF_VECTOR);\n\tset_exception_intercept(svm, UD_VECTOR);\n\tset_exception_intercept(svm, MC_VECTOR);\n\tset_exception_intercept(svm, AC_VECTOR);\n\tset_exception_intercept(svm, DB_VECTOR);\n\n\tset_intercept(svm, INTERCEPT_INTR);\n\tset_intercept(svm, INTERCEPT_NMI);\n\tset_intercept(svm, INTERCEPT_SMI);\n\tset_intercept(svm, INTERCEPT_SELECTIVE_CR0);\n\tset_intercept(svm, INTERCEPT_RDPMC);\n\tset_intercept(svm, INTERCEPT_CPUID);\n\tset_intercept(svm, INTERCEPT_INVD);\n\tset_intercept(svm, INTERCEPT_HLT);\n\tset_intercept(svm, INTERCEPT_INVLPG);\n\tset_intercept(svm, INTERCEPT_INVLPGA);\n\tset_intercept(svm, INTERCEPT_IOIO_PROT);\n\tset_intercept(svm, INTERCEPT_MSR_PROT);\n\tset_intercept(svm, INTERCEPT_TASK_SWITCH);\n\tset_intercept(svm, INTERCEPT_SHUTDOWN);\n\tset_intercept(svm, INTERCEPT_VMRUN);\n\tset_intercept(svm, INTERCEPT_VMMCALL);\n\tset_intercept(svm, INTERCEPT_VMLOAD);\n\tset_intercept(svm, INTERCEPT_VMSAVE);\n\tset_intercept(svm, INTERCEPT_STGI);\n\tset_intercept(svm, INTERCEPT_CLGI);\n\tset_intercept(svm, INTERCEPT_SKINIT);\n\tset_intercept(svm, INTERCEPT_WBINVD);\n\tset_intercept(svm, INTERCEPT_MONITOR);\n\tset_intercept(svm, INTERCEPT_MWAIT);\n\tset_intercept(svm, INTERCEPT_XSETBV);\n\n\tcontrol->iopm_base_pa = iopm_base;\n\tcontrol->msrpm_base_pa = __pa(svm->msrpm);\n\tcontrol->int_ctl = V_INTR_MASKING_MASK;\n\n\tinit_seg(&save->es);\n\tinit_seg(&save->ss);\n\tinit_seg(&save->ds);\n\tinit_seg(&save->fs);\n\tinit_seg(&save->gs);\n\n\tsave->cs.selector = 0xf000;\n\tsave->cs.base = 0xffff0000;\n\t/* Executable/Readable Code Segment */\n\tsave->cs.attrib = SVM_SELECTOR_READ_MASK | SVM_SELECTOR_P_MASK |\n\t\tSVM_SELECTOR_S_MASK | SVM_SELECTOR_CODE_MASK;\n\tsave->cs.limit = 0xffff;\n\n\tsave->gdtr.limit = 0xffff;\n\tsave->idtr.limit = 0xffff;\n\n\tinit_sys_seg(&save->ldtr, SEG_TYPE_LDT);\n\tinit_sys_seg(&save->tr, SEG_TYPE_BUSY_TSS16);\n\n\tsvm_set_efer(&svm->vcpu, 0);\n\tsave->dr6 = 0xffff0ff0;\n\tkvm_set_rflags(&svm->vcpu, 2);\n\tsave->rip = 0x0000fff0;\n\tsvm->vcpu.arch.regs[VCPU_REGS_RIP] = save->rip;\n\n\t/*\n\t * svm_set_cr0() sets PG and WP and clears NW and CD on save->cr0.\n\t * It also updates the guest-visible cr0 value.\n\t */\n\tsvm_set_cr0(&svm->vcpu, X86_CR0_NW | X86_CR0_CD | X86_CR0_ET);\n\tkvm_mmu_reset_context(&svm->vcpu);\n\n\tsave->cr4 = X86_CR4_PAE;\n\t/* rdx = ?? */\n\n\tif (npt_enabled) {\n\t\t/* Setup VMCB for Nested Paging */\n\t\tcontrol->nested_ctl = 1;\n\t\tclr_intercept(svm, INTERCEPT_INVLPG);\n\t\tclr_exception_intercept(svm, PF_VECTOR);\n\t\tclr_cr_intercept(svm, INTERCEPT_CR3_READ);\n\t\tclr_cr_intercept(svm, INTERCEPT_CR3_WRITE);\n\t\tsave->g_pat = svm->vcpu.arch.pat;\n\t\tsave->cr3 = 0;\n\t\tsave->cr4 = 0;\n\t}\n\tsvm->asid_generation = 0;\n\n\tsvm->nested.vmcb = 0;\n\tsvm->vcpu.arch.hflags = 0;\n\n\tif (boot_cpu_has(X86_FEATURE_PAUSEFILTER)) {\n\t\tcontrol->pause_filter_count = 3000;\n\t\tset_intercept(svm, INTERCEPT_PAUSE);\n\t}\n\n\tif (avic)\n\t\tavic_init_vmcb(svm);\n\n\tmark_all_dirty(svm->vmcb);\n\n\tenable_gif(svm);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_page",
          "args": [
            "svm->vmcb"
          ],
          "line": 2112
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic int shutdown_interception(struct vcpu_svm *svm)\n{\n\tstruct kvm_run *kvm_run = svm->vcpu.run;\n\n\t/*\n\t * VMCB is undefined after a SHUTDOWN intercept\n\t * so reinitialize it.\n\t */\n\tclear_page(svm->vmcb);\n\tinit_vmcb(svm);\n\n\tkvm_run->exit_reason = KVM_EXIT_SHUTDOWN;\n\treturn 0;\n}"
  },
  {
    "function_name": "mc_interception",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "2099-2102",
    "snippet": "static int mc_interception(struct vcpu_svm *svm)\n{\n\treturn 1;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic int mc_interception(struct vcpu_svm *svm)\n{\n\treturn 1;\n}"
  },
  {
    "function_name": "svm_handle_mce",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "2074-2097",
    "snippet": "static void svm_handle_mce(struct vcpu_svm *svm)\n{\n\tif (is_erratum_383()) {\n\t\t/*\n\t\t * Erratum 383 triggered. Guest state is corrupt so kill the\n\t\t * guest.\n\t\t */\n\t\tpr_err(\"KVM: Guest triggered AMD Erratum 383\\n\");\n\n\t\tkvm_make_request(KVM_REQ_TRIPLE_FAULT, &svm->vcpu);\n\n\t\treturn;\n\t}\n\n\t/*\n\t * On an #MC intercept the MCE handler is not called automatically in\n\t * the host. So do it by hand here.\n\t */\n\tasm volatile (\n\t\t\"int $0x12\\n\");\n\t/* not sure if we ever come back to this point */\n\n\treturn;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_make_request",
          "args": [
            "KVM_REQ_TRIPLE_FAULT",
            "&svm->vcpu"
          ],
          "line": 2083
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"KVM: Guest triggered AMD Erratum 383\\n\""
          ],
          "line": 2081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_erratum_383",
          "args": [],
          "line": 2076
        },
        "resolved": true,
        "details": {
          "function_name": "is_erratum_383",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "2035-2072",
          "snippet": "static bool is_erratum_383(void)\n{\n\tint err, i;\n\tu64 value;\n\n\tif (!erratum_383_found)\n\t\treturn false;\n\n\tvalue = native_read_msr_safe(MSR_IA32_MC0_STATUS, &err);\n\tif (err)\n\t\treturn false;\n\n\t/* Bit 62 may or may not be set for this mce */\n\tvalue &= ~(1ULL << 62);\n\n\tif (value != 0xb600000000010015ULL)\n\t\treturn false;\n\n\t/* Clear MCi_STATUS registers */\n\tfor (i = 0; i < 6; ++i)\n\t\tnative_write_msr_safe(MSR_IA32_MCx_STATUS(i), 0, 0);\n\n\tvalue = native_read_msr_safe(MSR_IA32_MCG_STATUS, &err);\n\tif (!err) {\n\t\tu32 low, high;\n\n\t\tvalue &= ~(1ULL << 2);\n\t\tlow    = lower_32_bits(value);\n\t\thigh   = upper_32_bits(value);\n\n\t\tnative_write_msr_safe(MSR_IA32_MCG_STATUS, low, high);\n\t}\n\n\t/* Flush tlb to evict multi-match entries */\n\t__flush_tlb_all();\n\n\treturn true;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool erratum_383_found"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic bool erratum_383_found;\n\nstatic bool is_erratum_383(void)\n{\n\tint err, i;\n\tu64 value;\n\n\tif (!erratum_383_found)\n\t\treturn false;\n\n\tvalue = native_read_msr_safe(MSR_IA32_MC0_STATUS, &err);\n\tif (err)\n\t\treturn false;\n\n\t/* Bit 62 may or may not be set for this mce */\n\tvalue &= ~(1ULL << 62);\n\n\tif (value != 0xb600000000010015ULL)\n\t\treturn false;\n\n\t/* Clear MCi_STATUS registers */\n\tfor (i = 0; i < 6; ++i)\n\t\tnative_write_msr_safe(MSR_IA32_MCx_STATUS(i), 0, 0);\n\n\tvalue = native_read_msr_safe(MSR_IA32_MCG_STATUS, &err);\n\tif (!err) {\n\t\tu32 low, high;\n\n\t\tvalue &= ~(1ULL << 2);\n\t\tlow    = lower_32_bits(value);\n\t\thigh   = upper_32_bits(value);\n\n\t\tnative_write_msr_safe(MSR_IA32_MCG_STATUS, low, high);\n\t}\n\n\t/* Flush tlb to evict multi-match entries */\n\t__flush_tlb_all();\n\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic void svm_handle_mce(struct vcpu_svm *svm)\n{\n\tif (is_erratum_383()) {\n\t\t/*\n\t\t * Erratum 383 triggered. Guest state is corrupt so kill the\n\t\t * guest.\n\t\t */\n\t\tpr_err(\"KVM: Guest triggered AMD Erratum 383\\n\");\n\n\t\tkvm_make_request(KVM_REQ_TRIPLE_FAULT, &svm->vcpu);\n\n\t\treturn;\n\t}\n\n\t/*\n\t * On an #MC intercept the MCE handler is not called automatically in\n\t * the host. So do it by hand here.\n\t */\n\tasm volatile (\n\t\t\"int $0x12\\n\");\n\t/* not sure if we ever come back to this point */\n\n\treturn;\n}"
  },
  {
    "function_name": "is_erratum_383",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "2035-2072",
    "snippet": "static bool is_erratum_383(void)\n{\n\tint err, i;\n\tu64 value;\n\n\tif (!erratum_383_found)\n\t\treturn false;\n\n\tvalue = native_read_msr_safe(MSR_IA32_MC0_STATUS, &err);\n\tif (err)\n\t\treturn false;\n\n\t/* Bit 62 may or may not be set for this mce */\n\tvalue &= ~(1ULL << 62);\n\n\tif (value != 0xb600000000010015ULL)\n\t\treturn false;\n\n\t/* Clear MCi_STATUS registers */\n\tfor (i = 0; i < 6; ++i)\n\t\tnative_write_msr_safe(MSR_IA32_MCx_STATUS(i), 0, 0);\n\n\tvalue = native_read_msr_safe(MSR_IA32_MCG_STATUS, &err);\n\tif (!err) {\n\t\tu32 low, high;\n\n\t\tvalue &= ~(1ULL << 2);\n\t\tlow    = lower_32_bits(value);\n\t\thigh   = upper_32_bits(value);\n\n\t\tnative_write_msr_safe(MSR_IA32_MCG_STATUS, low, high);\n\t}\n\n\t/* Flush tlb to evict multi-match entries */\n\t__flush_tlb_all();\n\n\treturn true;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool erratum_383_found"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__flush_tlb_all",
          "args": [],
          "line": 2069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "native_write_msr_safe",
          "args": [
            "MSR_IA32_MCG_STATUS",
            "low",
            "high"
          ],
          "line": 2065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "upper_32_bits",
          "args": [
            "value"
          ],
          "line": 2063
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lower_32_bits",
          "args": [
            "value"
          ],
          "line": 2062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "native_read_msr_safe",
          "args": [
            "MSR_IA32_MCG_STATUS",
            "&err"
          ],
          "line": 2057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "native_write_msr_safe",
          "args": [
            "MSR_IA32_MCx_STATUS(i)",
            "0",
            "0"
          ],
          "line": 2055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MSR_IA32_MCx_STATUS",
          "args": [
            "i"
          ],
          "line": 2055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "native_read_msr_safe",
          "args": [
            "MSR_IA32_MC0_STATUS",
            "&err"
          ],
          "line": 2043
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic bool erratum_383_found;\n\nstatic bool is_erratum_383(void)\n{\n\tint err, i;\n\tu64 value;\n\n\tif (!erratum_383_found)\n\t\treturn false;\n\n\tvalue = native_read_msr_safe(MSR_IA32_MC0_STATUS, &err);\n\tif (err)\n\t\treturn false;\n\n\t/* Bit 62 may or may not be set for this mce */\n\tvalue &= ~(1ULL << 62);\n\n\tif (value != 0xb600000000010015ULL)\n\t\treturn false;\n\n\t/* Clear MCi_STATUS registers */\n\tfor (i = 0; i < 6; ++i)\n\t\tnative_write_msr_safe(MSR_IA32_MCx_STATUS(i), 0, 0);\n\n\tvalue = native_read_msr_safe(MSR_IA32_MCG_STATUS, &err);\n\tif (!err) {\n\t\tu32 low, high;\n\n\t\tvalue &= ~(1ULL << 2);\n\t\tlow    = lower_32_bits(value);\n\t\thigh   = upper_32_bits(value);\n\n\t\tnative_write_msr_safe(MSR_IA32_MCG_STATUS, low, high);\n\t}\n\n\t/* Flush tlb to evict multi-match entries */\n\t__flush_tlb_all();\n\n\treturn true;\n}"
  },
  {
    "function_name": "nm_interception",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "2029-2033",
    "snippet": "static int nm_interception(struct vcpu_svm *svm)\n{\n\tsvm_fpu_activate(&svm->vcpu);\n\treturn 1;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "svm_fpu_activate",
          "args": [
            "&svm->vcpu"
          ],
          "line": 2031
        },
        "resolved": true,
        "details": {
          "function_name": "svm_fpu_activate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "2019-2027",
          "snippet": "static void svm_fpu_activate(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tclr_exception_intercept(svm, NM_VECTOR);\n\n\tsvm->vcpu.fpu_active = 1;\n\tupdate_cr0_intercept(svm);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic void svm_fpu_activate(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tclr_exception_intercept(svm, NM_VECTOR);\n\n\tsvm->vcpu.fpu_active = 1;\n\tupdate_cr0_intercept(svm);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic int nm_interception(struct vcpu_svm *svm)\n{\n\tsvm_fpu_activate(&svm->vcpu);\n\treturn 1;\n}"
  },
  {
    "function_name": "svm_fpu_activate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "2019-2027",
    "snippet": "static void svm_fpu_activate(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tclr_exception_intercept(svm, NM_VECTOR);\n\n\tsvm->vcpu.fpu_active = 1;\n\tupdate_cr0_intercept(svm);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "update_cr0_intercept",
          "args": [
            "svm"
          ],
          "line": 2026
        },
        "resolved": true,
        "details": {
          "function_name": "update_cr0_intercept",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "1755-1775",
          "snippet": "static void update_cr0_intercept(struct vcpu_svm *svm)\n{\n\tulong gcr0 = svm->vcpu.arch.cr0;\n\tu64 *hcr0 = &svm->vmcb->save.cr0;\n\n\tif (!svm->vcpu.fpu_active)\n\t\t*hcr0 |= SVM_CR0_SELECTIVE_MASK;\n\telse\n\t\t*hcr0 = (*hcr0 & ~SVM_CR0_SELECTIVE_MASK)\n\t\t\t| (gcr0 & SVM_CR0_SELECTIVE_MASK);\n\n\tmark_dirty(svm->vmcb, VMCB_CR);\n\n\tif (gcr0 == *hcr0 && svm->vcpu.fpu_active) {\n\t\tclr_cr_intercept(svm, INTERCEPT_CR0_READ);\n\t\tclr_cr_intercept(svm, INTERCEPT_CR0_WRITE);\n\t} else {\n\t\tset_cr_intercept(svm, INTERCEPT_CR0_READ);\n\t\tset_cr_intercept(svm, INTERCEPT_CR0_WRITE);\n\t}\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_set_cr0(struct kvm_vcpu *vcpu, unsigned long cr0);",
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_set_cr0(struct kvm_vcpu *vcpu, unsigned long cr0);\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic void update_cr0_intercept(struct vcpu_svm *svm)\n{\n\tulong gcr0 = svm->vcpu.arch.cr0;\n\tu64 *hcr0 = &svm->vmcb->save.cr0;\n\n\tif (!svm->vcpu.fpu_active)\n\t\t*hcr0 |= SVM_CR0_SELECTIVE_MASK;\n\telse\n\t\t*hcr0 = (*hcr0 & ~SVM_CR0_SELECTIVE_MASK)\n\t\t\t| (gcr0 & SVM_CR0_SELECTIVE_MASK);\n\n\tmark_dirty(svm->vmcb, VMCB_CR);\n\n\tif (gcr0 == *hcr0 && svm->vcpu.fpu_active) {\n\t\tclr_cr_intercept(svm, INTERCEPT_CR0_READ);\n\t\tclr_cr_intercept(svm, INTERCEPT_CR0_WRITE);\n\t} else {\n\t\tset_cr_intercept(svm, INTERCEPT_CR0_READ);\n\t\tset_cr_intercept(svm, INTERCEPT_CR0_WRITE);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "clr_exception_intercept",
          "args": [
            "svm",
            "NM_VECTOR"
          ],
          "line": 2023
        },
        "resolved": true,
        "details": {
          "function_name": "clr_exception_intercept",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "411-418",
          "snippet": "static inline void clr_exception_intercept(struct vcpu_svm *svm, int bit)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept_exceptions &= ~(1U << bit);\n\n\trecalc_intercepts(svm);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic inline void clr_exception_intercept(struct vcpu_svm *svm, int bit)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept_exceptions &= ~(1U << bit);\n\n\trecalc_intercepts(svm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 2021
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "294-297",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic void svm_fpu_activate(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tclr_exception_intercept(svm, NM_VECTOR);\n\n\tsvm->vcpu.fpu_active = 1;\n\tupdate_cr0_intercept(svm);\n}"
  },
  {
    "function_name": "ac_interception",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "2013-2017",
    "snippet": "static int ac_interception(struct vcpu_svm *svm)\n{\n\tkvm_queue_exception_e(&svm->vcpu, AC_VECTOR, 0);\n\treturn 1;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_queue_exception_e",
          "args": [
            "&svm->vcpu",
            "AC_VECTOR",
            "0"
          ],
          "line": 2015
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_queue_exception_e",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "455-458",
          "snippet": "void kvm_queue_exception_e(struct kvm_vcpu *vcpu, unsigned nr, u32 error_code)\n{\n\tkvm_multiple_exception(vcpu, nr, true, error_code, false);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nvoid kvm_queue_exception_e(struct kvm_vcpu *vcpu, unsigned nr, u32 error_code)\n{\n\tkvm_multiple_exception(vcpu, nr, true, error_code, false);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic int ac_interception(struct vcpu_svm *svm)\n{\n\tkvm_queue_exception_e(&svm->vcpu, AC_VECTOR, 0);\n\treturn 1;\n}"
  },
  {
    "function_name": "ud_interception",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "2003-2011",
    "snippet": "static int ud_interception(struct vcpu_svm *svm)\n{\n\tint er;\n\n\ter = emulate_instruction(&svm->vcpu, EMULTYPE_TRAP_UD);\n\tif (er != EMULATE_DONE)\n\t\tkvm_queue_exception(&svm->vcpu, UD_VECTOR);\n\treturn 1;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_queue_exception",
          "args": [
            "&svm->vcpu",
            "UD_VECTOR"
          ],
          "line": 2009
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_queue_exception",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "409-412",
          "snippet": "void kvm_queue_exception(struct kvm_vcpu *vcpu, unsigned nr)\n{\n\tkvm_multiple_exception(vcpu, nr, false, 0, false);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nvoid kvm_queue_exception(struct kvm_vcpu *vcpu, unsigned nr)\n{\n\tkvm_multiple_exception(vcpu, nr, false, 0, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "emulate_instruction",
          "args": [
            "&svm->vcpu",
            "EMULTYPE_TRAP_UD"
          ],
          "line": 2007
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic int ud_interception(struct vcpu_svm *svm)\n{\n\tint er;\n\n\ter = emulate_instruction(&svm->vcpu, EMULTYPE_TRAP_UD);\n\tif (er != EMULATE_DONE)\n\t\tkvm_queue_exception(&svm->vcpu, UD_VECTOR);\n\treturn 1;\n}"
  },
  {
    "function_name": "bp_interception",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "1993-2001",
    "snippet": "static int bp_interception(struct vcpu_svm *svm)\n{\n\tstruct kvm_run *kvm_run = svm->vcpu.run;\n\n\tkvm_run->exit_reason = KVM_EXIT_DEBUG;\n\tkvm_run->debug.arch.pc = svm->vmcb->save.cs.base + svm->vmcb->save.rip;\n\tkvm_run->debug.arch.exception = BP_VECTOR;\n\treturn 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic int bp_interception(struct vcpu_svm *svm)\n{\n\tstruct kvm_run *kvm_run = svm->vcpu.run;\n\n\tkvm_run->exit_reason = KVM_EXIT_DEBUG;\n\tkvm_run->debug.arch.pc = svm->vmcb->save.cs.base + svm->vmcb->save.rip;\n\tkvm_run->debug.arch.exception = BP_VECTOR;\n\treturn 0;\n}"
  },
  {
    "function_name": "db_interception",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "1963-1991",
    "snippet": "static int db_interception(struct vcpu_svm *svm)\n{\n\tstruct kvm_run *kvm_run = svm->vcpu.run;\n\n\tif (!(svm->vcpu.guest_debug &\n\t      (KVM_GUESTDBG_SINGLESTEP | KVM_GUESTDBG_USE_HW_BP)) &&\n\t\t!svm->nmi_singlestep) {\n\t\tkvm_queue_exception(&svm->vcpu, DB_VECTOR);\n\t\treturn 1;\n\t}\n\n\tif (svm->nmi_singlestep) {\n\t\tsvm->nmi_singlestep = false;\n\t\tif (!(svm->vcpu.guest_debug & KVM_GUESTDBG_SINGLESTEP))\n\t\t\tsvm->vmcb->save.rflags &=\n\t\t\t\t~(X86_EFLAGS_TF | X86_EFLAGS_RF);\n\t}\n\n\tif (svm->vcpu.guest_debug &\n\t    (KVM_GUESTDBG_SINGLESTEP | KVM_GUESTDBG_USE_HW_BP)) {\n\t\tkvm_run->exit_reason = KVM_EXIT_DEBUG;\n\t\tkvm_run->debug.arch.pc =\n\t\t\tsvm->vmcb->save.cs.base + svm->vmcb->save.rip;\n\t\tkvm_run->debug.arch.exception = DB_VECTOR;\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_queue_exception",
          "args": [
            "&svm->vcpu",
            "DB_VECTOR"
          ],
          "line": 1970
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_queue_exception",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "409-412",
          "snippet": "void kvm_queue_exception(struct kvm_vcpu *vcpu, unsigned nr)\n{\n\tkvm_multiple_exception(vcpu, nr, false, 0, false);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nvoid kvm_queue_exception(struct kvm_vcpu *vcpu, unsigned nr)\n{\n\tkvm_multiple_exception(vcpu, nr, false, 0, false);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic int db_interception(struct vcpu_svm *svm)\n{\n\tstruct kvm_run *kvm_run = svm->vcpu.run;\n\n\tif (!(svm->vcpu.guest_debug &\n\t      (KVM_GUESTDBG_SINGLESTEP | KVM_GUESTDBG_USE_HW_BP)) &&\n\t\t!svm->nmi_singlestep) {\n\t\tkvm_queue_exception(&svm->vcpu, DB_VECTOR);\n\t\treturn 1;\n\t}\n\n\tif (svm->nmi_singlestep) {\n\t\tsvm->nmi_singlestep = false;\n\t\tif (!(svm->vcpu.guest_debug & KVM_GUESTDBG_SINGLESTEP))\n\t\t\tsvm->vmcb->save.rflags &=\n\t\t\t\t~(X86_EFLAGS_TF | X86_EFLAGS_RF);\n\t}\n\n\tif (svm->vcpu.guest_debug &\n\t    (KVM_GUESTDBG_SINGLESTEP | KVM_GUESTDBG_USE_HW_BP)) {\n\t\tkvm_run->exit_reason = KVM_EXIT_DEBUG;\n\t\tkvm_run->debug.arch.pc =\n\t\t\tsvm->vmcb->save.cs.base + svm->vmcb->save.rip;\n\t\tkvm_run->debug.arch.exception = DB_VECTOR;\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}"
  },
  {
    "function_name": "pf_interception",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "1930-1961",
    "snippet": "static int pf_interception(struct vcpu_svm *svm)\n{\n\tu64 fault_address = svm->vmcb->control.exit_info_2;\n\tu32 error_code;\n\tint r = 1;\n\n\tswitch (svm->apf_reason) {\n\tdefault:\n\t\terror_code = svm->vmcb->control.exit_info_1;\n\n\t\ttrace_kvm_page_fault(fault_address, error_code);\n\t\tif (!npt_enabled && kvm_event_needs_reinjection(&svm->vcpu))\n\t\t\tkvm_mmu_unprotect_page_virt(&svm->vcpu, fault_address);\n\t\tr = kvm_mmu_page_fault(&svm->vcpu, fault_address, error_code,\n\t\t\tsvm->vmcb->control.insn_bytes,\n\t\t\tsvm->vmcb->control.insn_len);\n\t\tbreak;\n\tcase KVM_PV_REASON_PAGE_NOT_PRESENT:\n\t\tsvm->apf_reason = 0;\n\t\tlocal_irq_disable();\n\t\tkvm_async_pf_task_wait(fault_address);\n\t\tlocal_irq_enable();\n\t\tbreak;\n\tcase KVM_PV_REASON_PAGE_READY:\n\t\tsvm->apf_reason = 0;\n\t\tlocal_irq_disable();\n\t\tkvm_async_pf_task_wake(fault_address);\n\t\tlocal_irq_enable();\n\t\tbreak;\n\t}\n\treturn r;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);",
      "static int nested_svm_check_exception(struct vcpu_svm *svm, unsigned nr,\n\t\t\t\t      bool has_error_code, u32 error_code);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_enable",
          "args": [],
          "line": 1957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_async_pf_task_wake",
          "args": [
            "fault_address"
          ],
          "line": 1956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_disable",
          "args": [],
          "line": 1955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_enable",
          "args": [],
          "line": 1951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_async_pf_task_wait",
          "args": [
            "fault_address"
          ],
          "line": 1950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_disable",
          "args": [],
          "line": 1949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_mmu_page_fault",
          "args": [
            "&svm->vcpu",
            "fault_address",
            "error_code",
            "svm->vmcb->control.insn_bytes",
            "svm->vmcb->control.insn_len"
          ],
          "line": 1943
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_page_fault",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "4504-4545",
          "snippet": "int kvm_mmu_page_fault(struct kvm_vcpu *vcpu, gva_t cr2, u32 error_code,\n\t\t       void *insn, int insn_len)\n{\n\tint r, emulation_type = EMULTYPE_RETRY;\n\tenum emulation_result er;\n\tbool direct = vcpu->arch.mmu.direct_map || mmu_is_nested(vcpu);\n\n\tif (unlikely(error_code & PFERR_RSVD_MASK)) {\n\t\tr = handle_mmio_page_fault(vcpu, cr2, direct);\n\t\tif (r == RET_MMIO_PF_EMULATE) {\n\t\t\temulation_type = 0;\n\t\t\tgoto emulate;\n\t\t}\n\t\tif (r == RET_MMIO_PF_RETRY)\n\t\t\treturn 1;\n\t\tif (r < 0)\n\t\t\treturn r;\n\t}\n\n\tr = vcpu->arch.mmu.page_fault(vcpu, cr2, error_code, false);\n\tif (r < 0)\n\t\treturn r;\n\tif (!r)\n\t\treturn 1;\n\n\tif (mmio_info_in_cache(vcpu, cr2, direct))\n\t\temulation_type = 0;\nemulate:\n\ter = x86_emulate_instruction(vcpu, cr2, emulation_type, insn, insn_len);\n\n\tswitch (er) {\n\tcase EMULATE_DONE:\n\t\treturn 1;\n\tcase EMULATE_USER_EXIT:\n\t\t++vcpu->stat.mmio_exits;\n\t\t/* fall through */\n\tcase EMULATE_FAIL:\n\t\treturn 0;\n\tdefault:\n\t\tBUG();\n\t}\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nint kvm_mmu_page_fault(struct kvm_vcpu *vcpu, gva_t cr2, u32 error_code,\n\t\t       void *insn, int insn_len)\n{\n\tint r, emulation_type = EMULTYPE_RETRY;\n\tenum emulation_result er;\n\tbool direct = vcpu->arch.mmu.direct_map || mmu_is_nested(vcpu);\n\n\tif (unlikely(error_code & PFERR_RSVD_MASK)) {\n\t\tr = handle_mmio_page_fault(vcpu, cr2, direct);\n\t\tif (r == RET_MMIO_PF_EMULATE) {\n\t\t\temulation_type = 0;\n\t\t\tgoto emulate;\n\t\t}\n\t\tif (r == RET_MMIO_PF_RETRY)\n\t\t\treturn 1;\n\t\tif (r < 0)\n\t\t\treturn r;\n\t}\n\n\tr = vcpu->arch.mmu.page_fault(vcpu, cr2, error_code, false);\n\tif (r < 0)\n\t\treturn r;\n\tif (!r)\n\t\treturn 1;\n\n\tif (mmio_info_in_cache(vcpu, cr2, direct))\n\t\temulation_type = 0;\nemulate:\n\ter = x86_emulate_instruction(vcpu, cr2, emulation_type, insn, insn_len);\n\n\tswitch (er) {\n\tcase EMULATE_DONE:\n\t\treturn 1;\n\tcase EMULATE_USER_EXIT:\n\t\t++vcpu->stat.mmio_exits;\n\t\t/* fall through */\n\tcase EMULATE_FAIL:\n\t\treturn 0;\n\tdefault:\n\t\tBUG();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_mmu_unprotect_page_virt",
          "args": [
            "&svm->vcpu",
            "fault_address"
          ],
          "line": 1942
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_unprotect_page_virt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "4472-4485",
          "snippet": "int kvm_mmu_unprotect_page_virt(struct kvm_vcpu *vcpu, gva_t gva)\n{\n\tgpa_t gpa;\n\tint r;\n\n\tif (vcpu->arch.mmu.direct_map)\n\t\treturn 0;\n\n\tgpa = kvm_mmu_gva_to_gpa_read(vcpu, gva, NULL);\n\n\tr = kvm_mmu_unprotect_page(vcpu->kvm, gpa >> PAGE_SHIFT);\n\n\treturn r;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nint kvm_mmu_unprotect_page_virt(struct kvm_vcpu *vcpu, gva_t gva)\n{\n\tgpa_t gpa;\n\tint r;\n\n\tif (vcpu->arch.mmu.direct_map)\n\t\treturn 0;\n\n\tgpa = kvm_mmu_gva_to_gpa_read(vcpu, gva, NULL);\n\n\tr = kvm_mmu_unprotect_page(vcpu->kvm, gpa >> PAGE_SHIFT);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_event_needs_reinjection",
          "args": [
            "&svm->vcpu"
          ],
          "line": 1941
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_event_needs_reinjection",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.h",
          "lines": "27-31",
          "snippet": "static inline bool kvm_event_needs_reinjection(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.exception.pending || vcpu->arch.interrupt.pending ||\n\t\tvcpu->arch.nmi_injected;\n}",
          "includes": [
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline bool kvm_event_needs_reinjection(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.exception.pending || vcpu->arch.interrupt.pending ||\n\t\tvcpu->arch.nmi_injected;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_kvm_page_fault",
          "args": [
            "fault_address",
            "error_code"
          ],
          "line": 1940
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\nstatic int nested_svm_check_exception(struct vcpu_svm *svm, unsigned nr,\n\t\t\t\t      bool has_error_code, u32 error_code);\n\nstatic int pf_interception(struct vcpu_svm *svm)\n{\n\tu64 fault_address = svm->vmcb->control.exit_info_2;\n\tu32 error_code;\n\tint r = 1;\n\n\tswitch (svm->apf_reason) {\n\tdefault:\n\t\terror_code = svm->vmcb->control.exit_info_1;\n\n\t\ttrace_kvm_page_fault(fault_address, error_code);\n\t\tif (!npt_enabled && kvm_event_needs_reinjection(&svm->vcpu))\n\t\t\tkvm_mmu_unprotect_page_virt(&svm->vcpu, fault_address);\n\t\tr = kvm_mmu_page_fault(&svm->vcpu, fault_address, error_code,\n\t\t\tsvm->vmcb->control.insn_bytes,\n\t\t\tsvm->vmcb->control.insn_len);\n\t\tbreak;\n\tcase KVM_PV_REASON_PAGE_NOT_PRESENT:\n\t\tsvm->apf_reason = 0;\n\t\tlocal_irq_disable();\n\t\tkvm_async_pf_task_wait(fault_address);\n\t\tlocal_irq_enable();\n\t\tbreak;\n\tcase KVM_PV_REASON_PAGE_READY:\n\t\tsvm->apf_reason = 0;\n\t\tlocal_irq_disable();\n\t\tkvm_async_pf_task_wake(fault_address);\n\t\tlocal_irq_enable();\n\t\tbreak;\n\t}\n\treturn r;\n}"
  },
  {
    "function_name": "svm_set_dr7",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "1922-1928",
    "snippet": "static void svm_set_dr7(struct kvm_vcpu *vcpu, unsigned long value)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tsvm->vmcb->save.dr7 = value;\n\tmark_dirty(svm->vmcb, VMCB_DR);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_dirty",
          "args": [
            "svm->vmcb",
            "VMCB_DR"
          ],
          "line": 1927
        },
        "resolved": true,
        "details": {
          "function_name": "mark_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "289-292",
          "snippet": "static inline void mark_dirty(struct vmcb *vmcb, int bit)\n{\n\tvmcb->control.clean &= ~(1 << bit);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic inline void mark_dirty(struct vmcb *vmcb, int bit)\n{\n\tvmcb->control.clean &= ~(1 << bit);\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 1924
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "294-297",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic void svm_set_dr7(struct kvm_vcpu *vcpu, unsigned long value)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tsvm->vmcb->save.dr7 = value;\n\tmark_dirty(svm->vmcb, VMCB_DR);\n}"
  },
  {
    "function_name": "svm_sync_dirty_debug_regs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "1907-1920",
    "snippet": "static void svm_sync_dirty_debug_regs(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tget_debugreg(vcpu->arch.db[0], 0);\n\tget_debugreg(vcpu->arch.db[1], 1);\n\tget_debugreg(vcpu->arch.db[2], 2);\n\tget_debugreg(vcpu->arch.db[3], 3);\n\tvcpu->arch.dr6 = svm_get_dr6(vcpu);\n\tvcpu->arch.dr7 = svm->vmcb->save.dr7;\n\n\tvcpu->arch.switch_db_regs &= ~KVM_DEBUGREG_WONT_EXIT;\n\tset_dr_intercepts(svm);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_dr_intercepts",
          "args": [
            "svm"
          ],
          "line": 1919
        },
        "resolved": true,
        "details": {
          "function_name": "set_dr_intercepts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "369-391",
          "snippet": "static inline void set_dr_intercepts(struct vcpu_svm *svm)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept_dr = (1 << INTERCEPT_DR0_READ)\n\t\t| (1 << INTERCEPT_DR1_READ)\n\t\t| (1 << INTERCEPT_DR2_READ)\n\t\t| (1 << INTERCEPT_DR3_READ)\n\t\t| (1 << INTERCEPT_DR4_READ)\n\t\t| (1 << INTERCEPT_DR5_READ)\n\t\t| (1 << INTERCEPT_DR6_READ)\n\t\t| (1 << INTERCEPT_DR7_READ)\n\t\t| (1 << INTERCEPT_DR0_WRITE)\n\t\t| (1 << INTERCEPT_DR1_WRITE)\n\t\t| (1 << INTERCEPT_DR2_WRITE)\n\t\t| (1 << INTERCEPT_DR3_WRITE)\n\t\t| (1 << INTERCEPT_DR4_WRITE)\n\t\t| (1 << INTERCEPT_DR5_WRITE)\n\t\t| (1 << INTERCEPT_DR6_WRITE)\n\t\t| (1 << INTERCEPT_DR7_WRITE);\n\n\trecalc_intercepts(svm);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic inline void set_dr_intercepts(struct vcpu_svm *svm)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept_dr = (1 << INTERCEPT_DR0_READ)\n\t\t| (1 << INTERCEPT_DR1_READ)\n\t\t| (1 << INTERCEPT_DR2_READ)\n\t\t| (1 << INTERCEPT_DR3_READ)\n\t\t| (1 << INTERCEPT_DR4_READ)\n\t\t| (1 << INTERCEPT_DR5_READ)\n\t\t| (1 << INTERCEPT_DR6_READ)\n\t\t| (1 << INTERCEPT_DR7_READ)\n\t\t| (1 << INTERCEPT_DR0_WRITE)\n\t\t| (1 << INTERCEPT_DR1_WRITE)\n\t\t| (1 << INTERCEPT_DR2_WRITE)\n\t\t| (1 << INTERCEPT_DR3_WRITE)\n\t\t| (1 << INTERCEPT_DR4_WRITE)\n\t\t| (1 << INTERCEPT_DR5_WRITE)\n\t\t| (1 << INTERCEPT_DR6_WRITE)\n\t\t| (1 << INTERCEPT_DR7_WRITE);\n\n\trecalc_intercepts(svm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "svm_get_dr6",
          "args": [
            "vcpu"
          ],
          "line": 1915
        },
        "resolved": true,
        "details": {
          "function_name": "svm_get_dr6",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "1894-1897",
          "snippet": "static u64 svm_get_dr6(struct kvm_vcpu *vcpu)\n{\n\treturn to_svm(vcpu)->vmcb->save.dr6;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\n\nstatic u64 svm_get_dr6(struct kvm_vcpu *vcpu)\n{\n\treturn to_svm(vcpu)->vmcb->save.dr6;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_debugreg",
          "args": [
            "vcpu->arch.db[3]",
            "3"
          ],
          "line": 1914
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_vcpu_ioctl_x86_get_debugregs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "3020-3031",
          "snippet": "static void kvm_vcpu_ioctl_x86_get_debugregs(struct kvm_vcpu *vcpu,\n\t\t\t\t\t     struct kvm_debugregs *dbgregs)\n{\n\tunsigned long val;\n\n\tmemcpy(dbgregs->db, vcpu->arch.db, sizeof(vcpu->arch.db));\n\tkvm_get_dr(vcpu, 6, &val);\n\tdbgregs->dr6 = val;\n\tdbgregs->dr7 = vcpu->arch.dr7;\n\tdbgregs->flags = 0;\n\tmemset(&dbgregs->reserved, 0, sizeof(dbgregs->reserved));\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic void kvm_vcpu_ioctl_x86_get_debugregs(struct kvm_vcpu *vcpu,\n\t\t\t\t\t     struct kvm_debugregs *dbgregs)\n{\n\tunsigned long val;\n\n\tmemcpy(dbgregs->db, vcpu->arch.db, sizeof(vcpu->arch.db));\n\tkvm_get_dr(vcpu, 6, &val);\n\tdbgregs->dr6 = val;\n\tdbgregs->dr7 = vcpu->arch.dr7;\n\tdbgregs->flags = 0;\n\tmemset(&dbgregs->reserved, 0, sizeof(dbgregs->reserved));\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 1909
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "294-297",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic void svm_sync_dirty_debug_regs(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tget_debugreg(vcpu->arch.db[0], 0);\n\tget_debugreg(vcpu->arch.db[1], 1);\n\tget_debugreg(vcpu->arch.db[2], 2);\n\tget_debugreg(vcpu->arch.db[3], 3);\n\tvcpu->arch.dr6 = svm_get_dr6(vcpu);\n\tvcpu->arch.dr7 = svm->vmcb->save.dr7;\n\n\tvcpu->arch.switch_db_regs &= ~KVM_DEBUGREG_WONT_EXIT;\n\tset_dr_intercepts(svm);\n}"
  },
  {
    "function_name": "svm_set_dr6",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "1899-1905",
    "snippet": "static void svm_set_dr6(struct kvm_vcpu *vcpu, unsigned long value)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tsvm->vmcb->save.dr6 = value;\n\tmark_dirty(svm->vmcb, VMCB_DR);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_dirty",
          "args": [
            "svm->vmcb",
            "VMCB_DR"
          ],
          "line": 1904
        },
        "resolved": true,
        "details": {
          "function_name": "mark_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "289-292",
          "snippet": "static inline void mark_dirty(struct vmcb *vmcb, int bit)\n{\n\tvmcb->control.clean &= ~(1 << bit);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic inline void mark_dirty(struct vmcb *vmcb, int bit)\n{\n\tvmcb->control.clean &= ~(1 << bit);\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 1901
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "294-297",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic void svm_set_dr6(struct kvm_vcpu *vcpu, unsigned long value)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tsvm->vmcb->save.dr6 = value;\n\tmark_dirty(svm->vmcb, VMCB_DR);\n}"
  },
  {
    "function_name": "svm_get_dr6",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "1894-1897",
    "snippet": "static u64 svm_get_dr6(struct kvm_vcpu *vcpu)\n{\n\treturn to_svm(vcpu)->vmcb->save.dr6;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 1896
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "294-297",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\n\nstatic u64 svm_get_dr6(struct kvm_vcpu *vcpu)\n{\n\treturn to_svm(vcpu)->vmcb->save.dr6;\n}"
  },
  {
    "function_name": "new_asid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "1880-1892",
    "snippet": "static void new_asid(struct vcpu_svm *svm, struct svm_cpu_data *sd)\n{\n\tif (sd->next_asid > sd->max_asid) {\n\t\t++sd->asid_generation;\n\t\tsd->next_asid = 1;\n\t\tsvm->vmcb->control.tlb_ctl = TLB_CONTROL_FLUSH_ALL_ASID;\n\t}\n\n\tsvm->asid_generation = sd->asid_generation;\n\tsvm->vmcb->control.asid = sd->next_asid++;\n\n\tmark_dirty(svm->vmcb, VMCB_ASID);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_dirty",
          "args": [
            "svm->vmcb",
            "VMCB_ASID"
          ],
          "line": 1891
        },
        "resolved": true,
        "details": {
          "function_name": "mark_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "289-292",
          "snippet": "static inline void mark_dirty(struct vmcb *vmcb, int bit)\n{\n\tvmcb->control.clean &= ~(1 << bit);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic inline void mark_dirty(struct vmcb *vmcb, int bit)\n{\n\tvmcb->control.clean &= ~(1 << bit);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic void new_asid(struct vcpu_svm *svm, struct svm_cpu_data *sd)\n{\n\tif (sd->next_asid > sd->max_asid) {\n\t\t++sd->asid_generation;\n\t\tsd->next_asid = 1;\n\t\tsvm->vmcb->control.tlb_ctl = TLB_CONTROL_FLUSH_ALL_ASID;\n\t}\n\n\tsvm->asid_generation = sd->asid_generation;\n\tsvm->vmcb->control.asid = sd->next_asid++;\n\n\tmark_dirty(svm->vmcb, VMCB_ASID);\n}"
  },
  {
    "function_name": "update_bp_intercept",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "1867-1878",
    "snippet": "static void update_bp_intercept(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tclr_exception_intercept(svm, BP_VECTOR);\n\n\tif (vcpu->guest_debug & KVM_GUESTDBG_ENABLE) {\n\t\tif (vcpu->guest_debug & KVM_GUESTDBG_USE_SW_BP)\n\t\t\tset_exception_intercept(svm, BP_VECTOR);\n\t} else\n\t\tvcpu->guest_debug = 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_exception_intercept",
          "args": [
            "svm",
            "BP_VECTOR"
          ],
          "line": 1875
        },
        "resolved": true,
        "details": {
          "function_name": "set_exception_intercept",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "402-409",
          "snippet": "static inline void set_exception_intercept(struct vcpu_svm *svm, int bit)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept_exceptions |= (1U << bit);\n\n\trecalc_intercepts(svm);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic inline void set_exception_intercept(struct vcpu_svm *svm, int bit)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept_exceptions |= (1U << bit);\n\n\trecalc_intercepts(svm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clr_exception_intercept",
          "args": [
            "svm",
            "BP_VECTOR"
          ],
          "line": 1871
        },
        "resolved": true,
        "details": {
          "function_name": "clr_exception_intercept",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "411-418",
          "snippet": "static inline void clr_exception_intercept(struct vcpu_svm *svm, int bit)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept_exceptions &= ~(1U << bit);\n\n\trecalc_intercepts(svm);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic inline void clr_exception_intercept(struct vcpu_svm *svm, int bit)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept_exceptions &= ~(1U << bit);\n\n\trecalc_intercepts(svm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 1869
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "294-297",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic void update_bp_intercept(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tclr_exception_intercept(svm, BP_VECTOR);\n\n\tif (vcpu->guest_debug & KVM_GUESTDBG_ENABLE) {\n\t\tif (vcpu->guest_debug & KVM_GUESTDBG_USE_SW_BP)\n\t\t\tset_exception_intercept(svm, BP_VECTOR);\n\t} else\n\t\tvcpu->guest_debug = 0;\n}"
  },
  {
    "function_name": "svm_set_segment",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "1833-1865",
    "snippet": "static void svm_set_segment(struct kvm_vcpu *vcpu,\n\t\t\t    struct kvm_segment *var, int seg)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tstruct vmcb_seg *s = svm_seg(vcpu, seg);\n\n\ts->base = var->base;\n\ts->limit = var->limit;\n\ts->selector = var->selector;\n\tif (var->unusable)\n\t\ts->attrib = 0;\n\telse {\n\t\ts->attrib = (var->type & SVM_SELECTOR_TYPE_MASK);\n\t\ts->attrib |= (var->s & 1) << SVM_SELECTOR_S_SHIFT;\n\t\ts->attrib |= (var->dpl & 3) << SVM_SELECTOR_DPL_SHIFT;\n\t\ts->attrib |= (var->present & 1) << SVM_SELECTOR_P_SHIFT;\n\t\ts->attrib |= (var->avl & 1) << SVM_SELECTOR_AVL_SHIFT;\n\t\ts->attrib |= (var->l & 1) << SVM_SELECTOR_L_SHIFT;\n\t\ts->attrib |= (var->db & 1) << SVM_SELECTOR_DB_SHIFT;\n\t\ts->attrib |= (var->g & 1) << SVM_SELECTOR_G_SHIFT;\n\t}\n\n\t/*\n\t * This is always accurate, except if SYSRET returned to a segment\n\t * with SS.DPL != 3.  Intel does not have this quirk, and always\n\t * forces SS.DPL to 3 on sysret, so we ignore that case; fixing it\n\t * would entail passing the CPL to userspace and back.\n\t */\n\tif (seg == VCPU_SREG_SS)\n\t\tsvm->vmcb->save.cpl = (s->attrib >> SVM_SELECTOR_DPL_SHIFT) & 3;\n\n\tmark_dirty(svm->vmcb, VMCB_SEG);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_dirty",
          "args": [
            "svm->vmcb",
            "VMCB_SEG"
          ],
          "line": 1864
        },
        "resolved": true,
        "details": {
          "function_name": "mark_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "289-292",
          "snippet": "static inline void mark_dirty(struct vmcb *vmcb, int bit)\n{\n\tvmcb->control.clean &= ~(1 << bit);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic inline void mark_dirty(struct vmcb *vmcb, int bit)\n{\n\tvmcb->control.clean &= ~(1 << bit);\n}"
        }
      },
      {
        "call_info": {
          "callee": "svm_seg",
          "args": [
            "vcpu",
            "seg"
          ],
          "line": 1837
        },
        "resolved": true,
        "details": {
          "function_name": "svm_seg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "1609-1625",
          "snippet": "static struct vmcb_seg *svm_seg(struct kvm_vcpu *vcpu, int seg)\n{\n\tstruct vmcb_save_area *save = &to_svm(vcpu)->vmcb->save;\n\n\tswitch (seg) {\n\tcase VCPU_SREG_CS: return &save->cs;\n\tcase VCPU_SREG_DS: return &save->ds;\n\tcase VCPU_SREG_ES: return &save->es;\n\tcase VCPU_SREG_FS: return &save->fs;\n\tcase VCPU_SREG_GS: return &save->gs;\n\tcase VCPU_SREG_SS: return &save->ss;\n\tcase VCPU_SREG_TR: return &save->tr;\n\tcase VCPU_SREG_LDTR: return &save->ldtr;\n\t}\n\tBUG();\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\n\nstatic struct vmcb_seg *svm_seg(struct kvm_vcpu *vcpu, int seg)\n{\n\tstruct vmcb_save_area *save = &to_svm(vcpu)->vmcb->save;\n\n\tswitch (seg) {\n\tcase VCPU_SREG_CS: return &save->cs;\n\tcase VCPU_SREG_DS: return &save->ds;\n\tcase VCPU_SREG_ES: return &save->es;\n\tcase VCPU_SREG_FS: return &save->fs;\n\tcase VCPU_SREG_GS: return &save->gs;\n\tcase VCPU_SREG_SS: return &save->ss;\n\tcase VCPU_SREG_TR: return &save->tr;\n\tcase VCPU_SREG_LDTR: return &save->ldtr;\n\t}\n\tBUG();\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 1836
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "294-297",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic void svm_set_segment(struct kvm_vcpu *vcpu,\n\t\t\t    struct kvm_segment *var, int seg)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tstruct vmcb_seg *s = svm_seg(vcpu, seg);\n\n\ts->base = var->base;\n\ts->limit = var->limit;\n\ts->selector = var->selector;\n\tif (var->unusable)\n\t\ts->attrib = 0;\n\telse {\n\t\ts->attrib = (var->type & SVM_SELECTOR_TYPE_MASK);\n\t\ts->attrib |= (var->s & 1) << SVM_SELECTOR_S_SHIFT;\n\t\ts->attrib |= (var->dpl & 3) << SVM_SELECTOR_DPL_SHIFT;\n\t\ts->attrib |= (var->present & 1) << SVM_SELECTOR_P_SHIFT;\n\t\ts->attrib |= (var->avl & 1) << SVM_SELECTOR_AVL_SHIFT;\n\t\ts->attrib |= (var->l & 1) << SVM_SELECTOR_L_SHIFT;\n\t\ts->attrib |= (var->db & 1) << SVM_SELECTOR_DB_SHIFT;\n\t\ts->attrib |= (var->g & 1) << SVM_SELECTOR_G_SHIFT;\n\t}\n\n\t/*\n\t * This is always accurate, except if SYSRET returned to a segment\n\t * with SS.DPL != 3.  Intel does not have this quirk, and always\n\t * forces SS.DPL to 3 on sysret, so we ignore that case; fixing it\n\t * would entail passing the CPL to userspace and back.\n\t */\n\tif (seg == VCPU_SREG_SS)\n\t\tsvm->vmcb->save.cpl = (s->attrib >> SVM_SELECTOR_DPL_SHIFT) & 3;\n\n\tmark_dirty(svm->vmcb, VMCB_SEG);\n}"
  },
  {
    "function_name": "svm_set_cr4",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "1813-1831",
    "snippet": "static int svm_set_cr4(struct kvm_vcpu *vcpu, unsigned long cr4)\n{\n\tunsigned long host_cr4_mce = cr4_read_shadow() & X86_CR4_MCE;\n\tunsigned long old_cr4 = to_svm(vcpu)->vmcb->save.cr4;\n\n\tif (cr4 & X86_CR4_VMXE)\n\t\treturn 1;\n\n\tif (npt_enabled && ((old_cr4 ^ cr4) & X86_CR4_PGE))\n\t\tsvm_flush_tlb(vcpu);\n\n\tvcpu->arch.cr4 = cr4;\n\tif (!npt_enabled)\n\t\tcr4 |= X86_CR4_PAE;\n\tcr4 |= host_cr4_mce;\n\tto_svm(vcpu)->vmcb->save.cr4 = cr4;\n\tmark_dirty(to_svm(vcpu)->vmcb, VMCB_CR);\n\treturn 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_dirty",
          "args": [
            "to_svm(vcpu)->vmcb",
            "VMCB_CR"
          ],
          "line": 1829
        },
        "resolved": true,
        "details": {
          "function_name": "mark_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "289-292",
          "snippet": "static inline void mark_dirty(struct vmcb *vmcb, int bit)\n{\n\tvmcb->control.clean &= ~(1 << bit);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic inline void mark_dirty(struct vmcb *vmcb, int bit)\n{\n\tvmcb->control.clean &= ~(1 << bit);\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 1829
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "294-297",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "svm_flush_tlb",
          "args": [
            "vcpu"
          ],
          "line": 1822
        },
        "resolved": true,
        "details": {
          "function_name": "svm_flush_tlb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "4334-4342",
          "snippet": "static void svm_flush_tlb(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (static_cpu_has(X86_FEATURE_FLUSHBYASID))\n\t\tsvm->vmcb->control.tlb_ctl = TLB_CONTROL_FLUSH_ASID;\n\telse\n\t\tsvm->asid_generation--;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (static_cpu_has(X86_FEATURE_FLUSHBYASID))\n\t\tsvm->vmcb->control.tlb_ctl = TLB_CONTROL_FLUSH_ASID;\n\telse\n\t\tsvm->asid_generation--;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cr4_read_shadow",
          "args": [],
          "line": 1815
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\n\nstatic int svm_set_cr4(struct kvm_vcpu *vcpu, unsigned long cr4)\n{\n\tunsigned long host_cr4_mce = cr4_read_shadow() & X86_CR4_MCE;\n\tunsigned long old_cr4 = to_svm(vcpu)->vmcb->save.cr4;\n\n\tif (cr4 & X86_CR4_VMXE)\n\t\treturn 1;\n\n\tif (npt_enabled && ((old_cr4 ^ cr4) & X86_CR4_PGE))\n\t\tsvm_flush_tlb(vcpu);\n\n\tvcpu->arch.cr4 = cr4;\n\tif (!npt_enabled)\n\t\tcr4 |= X86_CR4_PAE;\n\tcr4 |= host_cr4_mce;\n\tto_svm(vcpu)->vmcb->save.cr4 = cr4;\n\tmark_dirty(to_svm(vcpu)->vmcb, VMCB_CR);\n\treturn 0;\n}"
  },
  {
    "function_name": "svm_set_cr0",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "1777-1811",
    "snippet": "static void svm_set_cr0(struct kvm_vcpu *vcpu, unsigned long cr0)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n#ifdef CONFIG_X86_64\n\tif (vcpu->arch.efer & EFER_LME) {\n\t\tif (!is_paging(vcpu) && (cr0 & X86_CR0_PG)) {\n\t\t\tvcpu->arch.efer |= EFER_LMA;\n\t\t\tsvm->vmcb->save.efer |= EFER_LMA | EFER_LME;\n\t\t}\n\n\t\tif (is_paging(vcpu) && !(cr0 & X86_CR0_PG)) {\n\t\t\tvcpu->arch.efer &= ~EFER_LMA;\n\t\t\tsvm->vmcb->save.efer &= ~(EFER_LMA | EFER_LME);\n\t\t}\n\t}\n#endif\n\tvcpu->arch.cr0 = cr0;\n\n\tif (!npt_enabled)\n\t\tcr0 |= X86_CR0_PG | X86_CR0_WP;\n\n\tif (!vcpu->fpu_active)\n\t\tcr0 |= X86_CR0_TS;\n\t/*\n\t * re-enable caching here because the QEMU bios\n\t * does not do it - this results in some delay at\n\t * reboot\n\t */\n\tif (kvm_check_has_quirk(vcpu->kvm, KVM_X86_QUIRK_CD_NW_CLEARED))\n\t\tcr0 &= ~(X86_CR0_CD | X86_CR0_NW);\n\tsvm->vmcb->save.cr0 = cr0;\n\tmark_dirty(svm->vmcb, VMCB_CR);\n\tupdate_cr0_intercept(svm);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_set_cr0(struct kvm_vcpu *vcpu, unsigned long cr0);",
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "update_cr0_intercept",
          "args": [
            "svm"
          ],
          "line": 1810
        },
        "resolved": true,
        "details": {
          "function_name": "update_cr0_intercept",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "1755-1775",
          "snippet": "static void update_cr0_intercept(struct vcpu_svm *svm)\n{\n\tulong gcr0 = svm->vcpu.arch.cr0;\n\tu64 *hcr0 = &svm->vmcb->save.cr0;\n\n\tif (!svm->vcpu.fpu_active)\n\t\t*hcr0 |= SVM_CR0_SELECTIVE_MASK;\n\telse\n\t\t*hcr0 = (*hcr0 & ~SVM_CR0_SELECTIVE_MASK)\n\t\t\t| (gcr0 & SVM_CR0_SELECTIVE_MASK);\n\n\tmark_dirty(svm->vmcb, VMCB_CR);\n\n\tif (gcr0 == *hcr0 && svm->vcpu.fpu_active) {\n\t\tclr_cr_intercept(svm, INTERCEPT_CR0_READ);\n\t\tclr_cr_intercept(svm, INTERCEPT_CR0_WRITE);\n\t} else {\n\t\tset_cr_intercept(svm, INTERCEPT_CR0_READ);\n\t\tset_cr_intercept(svm, INTERCEPT_CR0_WRITE);\n\t}\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_set_cr0(struct kvm_vcpu *vcpu, unsigned long cr0);",
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_set_cr0(struct kvm_vcpu *vcpu, unsigned long cr0);\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic void update_cr0_intercept(struct vcpu_svm *svm)\n{\n\tulong gcr0 = svm->vcpu.arch.cr0;\n\tu64 *hcr0 = &svm->vmcb->save.cr0;\n\n\tif (!svm->vcpu.fpu_active)\n\t\t*hcr0 |= SVM_CR0_SELECTIVE_MASK;\n\telse\n\t\t*hcr0 = (*hcr0 & ~SVM_CR0_SELECTIVE_MASK)\n\t\t\t| (gcr0 & SVM_CR0_SELECTIVE_MASK);\n\n\tmark_dirty(svm->vmcb, VMCB_CR);\n\n\tif (gcr0 == *hcr0 && svm->vcpu.fpu_active) {\n\t\tclr_cr_intercept(svm, INTERCEPT_CR0_READ);\n\t\tclr_cr_intercept(svm, INTERCEPT_CR0_WRITE);\n\t} else {\n\t\tset_cr_intercept(svm, INTERCEPT_CR0_READ);\n\t\tset_cr_intercept(svm, INTERCEPT_CR0_WRITE);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_dirty",
          "args": [
            "svm->vmcb",
            "VMCB_CR"
          ],
          "line": 1809
        },
        "resolved": true,
        "details": {
          "function_name": "mark_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "289-292",
          "snippet": "static inline void mark_dirty(struct vmcb *vmcb, int bit)\n{\n\tvmcb->control.clean &= ~(1 << bit);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic inline void mark_dirty(struct vmcb *vmcb, int bit)\n{\n\tvmcb->control.clean &= ~(1 << bit);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_check_has_quirk",
          "args": [
            "vcpu->kvm",
            "KVM_X86_QUIRK_CD_NW_CLEARED"
          ],
          "line": 1806
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_check_has_quirk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.h",
          "lines": "155-158",
          "snippet": "static inline bool kvm_check_has_quirk(struct kvm *kvm, u64 quirk)\n{\n\treturn !(kvm->arch.disabled_quirks & quirk);\n}",
          "includes": [
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline bool kvm_check_has_quirk(struct kvm *kvm, u64 quirk)\n{\n\treturn !(kvm->arch.disabled_quirks & quirk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_paging",
          "args": [
            "vcpu"
          ],
          "line": 1788
        },
        "resolved": true,
        "details": {
          "function_name": "is_paging",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.h",
          "lines": "77-80",
          "snippet": "static inline int is_paging(struct kvm_vcpu *vcpu)\n{\n\treturn likely(kvm_read_cr0_bits(vcpu, X86_CR0_PG));\n}",
          "includes": [
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline int is_paging(struct kvm_vcpu *vcpu)\n{\n\treturn likely(kvm_read_cr0_bits(vcpu, X86_CR0_PG));\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 1779
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "294-297",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_set_cr0(struct kvm_vcpu *vcpu, unsigned long cr0);\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic void svm_set_cr0(struct kvm_vcpu *vcpu, unsigned long cr0)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n#ifdef CONFIG_X86_64\n\tif (vcpu->arch.efer & EFER_LME) {\n\t\tif (!is_paging(vcpu) && (cr0 & X86_CR0_PG)) {\n\t\t\tvcpu->arch.efer |= EFER_LMA;\n\t\t\tsvm->vmcb->save.efer |= EFER_LMA | EFER_LME;\n\t\t}\n\n\t\tif (is_paging(vcpu) && !(cr0 & X86_CR0_PG)) {\n\t\t\tvcpu->arch.efer &= ~EFER_LMA;\n\t\t\tsvm->vmcb->save.efer &= ~(EFER_LMA | EFER_LME);\n\t\t}\n\t}\n#endif\n\tvcpu->arch.cr0 = cr0;\n\n\tif (!npt_enabled)\n\t\tcr0 |= X86_CR0_PG | X86_CR0_WP;\n\n\tif (!vcpu->fpu_active)\n\t\tcr0 |= X86_CR0_TS;\n\t/*\n\t * re-enable caching here because the QEMU bios\n\t * does not do it - this results in some delay at\n\t * reboot\n\t */\n\tif (kvm_check_has_quirk(vcpu->kvm, KVM_X86_QUIRK_CD_NW_CLEARED))\n\t\tcr0 &= ~(X86_CR0_CD | X86_CR0_NW);\n\tsvm->vmcb->save.cr0 = cr0;\n\tmark_dirty(svm->vmcb, VMCB_CR);\n\tupdate_cr0_intercept(svm);\n}"
  },
  {
    "function_name": "update_cr0_intercept",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "1755-1775",
    "snippet": "static void update_cr0_intercept(struct vcpu_svm *svm)\n{\n\tulong gcr0 = svm->vcpu.arch.cr0;\n\tu64 *hcr0 = &svm->vmcb->save.cr0;\n\n\tif (!svm->vcpu.fpu_active)\n\t\t*hcr0 |= SVM_CR0_SELECTIVE_MASK;\n\telse\n\t\t*hcr0 = (*hcr0 & ~SVM_CR0_SELECTIVE_MASK)\n\t\t\t| (gcr0 & SVM_CR0_SELECTIVE_MASK);\n\n\tmark_dirty(svm->vmcb, VMCB_CR);\n\n\tif (gcr0 == *hcr0 && svm->vcpu.fpu_active) {\n\t\tclr_cr_intercept(svm, INTERCEPT_CR0_READ);\n\t\tclr_cr_intercept(svm, INTERCEPT_CR0_WRITE);\n\t} else {\n\t\tset_cr_intercept(svm, INTERCEPT_CR0_READ);\n\t\tset_cr_intercept(svm, INTERCEPT_CR0_WRITE);\n\t}\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_set_cr0(struct kvm_vcpu *vcpu, unsigned long cr0);",
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_cr_intercept",
          "args": [
            "svm",
            "INTERCEPT_CR0_WRITE"
          ],
          "line": 1773
        },
        "resolved": true,
        "details": {
          "function_name": "set_cr_intercept",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "344-351",
          "snippet": "static inline void set_cr_intercept(struct vcpu_svm *svm, int bit)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept_cr |= (1U << bit);\n\n\trecalc_intercepts(svm);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic inline void set_cr_intercept(struct vcpu_svm *svm, int bit)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept_cr |= (1U << bit);\n\n\trecalc_intercepts(svm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clr_cr_intercept",
          "args": [
            "svm",
            "INTERCEPT_CR0_WRITE"
          ],
          "line": 1770
        },
        "resolved": true,
        "details": {
          "function_name": "clr_cr_intercept",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "353-360",
          "snippet": "static inline void clr_cr_intercept(struct vcpu_svm *svm, int bit)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept_cr &= ~(1U << bit);\n\n\trecalc_intercepts(svm);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic inline void clr_cr_intercept(struct vcpu_svm *svm, int bit)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept_cr &= ~(1U << bit);\n\n\trecalc_intercepts(svm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_dirty",
          "args": [
            "svm->vmcb",
            "VMCB_CR"
          ],
          "line": 1766
        },
        "resolved": true,
        "details": {
          "function_name": "mark_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "289-292",
          "snippet": "static inline void mark_dirty(struct vmcb *vmcb, int bit)\n{\n\tvmcb->control.clean &= ~(1 << bit);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic inline void mark_dirty(struct vmcb *vmcb, int bit)\n{\n\tvmcb->control.clean &= ~(1 << bit);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_set_cr0(struct kvm_vcpu *vcpu, unsigned long cr0);\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic void update_cr0_intercept(struct vcpu_svm *svm)\n{\n\tulong gcr0 = svm->vcpu.arch.cr0;\n\tu64 *hcr0 = &svm->vmcb->save.cr0;\n\n\tif (!svm->vcpu.fpu_active)\n\t\t*hcr0 |= SVM_CR0_SELECTIVE_MASK;\n\telse\n\t\t*hcr0 = (*hcr0 & ~SVM_CR0_SELECTIVE_MASK)\n\t\t\t| (gcr0 & SVM_CR0_SELECTIVE_MASK);\n\n\tmark_dirty(svm->vmcb, VMCB_CR);\n\n\tif (gcr0 == *hcr0 && svm->vcpu.fpu_active) {\n\t\tclr_cr_intercept(svm, INTERCEPT_CR0_READ);\n\t\tclr_cr_intercept(svm, INTERCEPT_CR0_WRITE);\n\t} else {\n\t\tset_cr_intercept(svm, INTERCEPT_CR0_READ);\n\t\tset_cr_intercept(svm, INTERCEPT_CR0_WRITE);\n\t}\n}"
  },
  {
    "function_name": "svm_decache_cr4_guest_bits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "1751-1753",
    "snippet": "static void svm_decache_cr4_guest_bits(struct kvm_vcpu *vcpu)\n{\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\n\nstatic void svm_decache_cr4_guest_bits(struct kvm_vcpu *vcpu)\n{\n}"
  },
  {
    "function_name": "svm_decache_cr3",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "1747-1749",
    "snippet": "static void svm_decache_cr3(struct kvm_vcpu *vcpu)\n{\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\n\nstatic void svm_decache_cr3(struct kvm_vcpu *vcpu)\n{\n}"
  },
  {
    "function_name": "svm_decache_cr0_guest_bits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "1743-1745",
    "snippet": "static void svm_decache_cr0_guest_bits(struct kvm_vcpu *vcpu)\n{\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\n\nstatic void svm_decache_cr0_guest_bits(struct kvm_vcpu *vcpu)\n{\n}"
  },
  {
    "function_name": "svm_set_gdt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "1734-1741",
    "snippet": "static void svm_set_gdt(struct kvm_vcpu *vcpu, struct desc_ptr *dt)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tsvm->vmcb->save.gdtr.limit = dt->size;\n\tsvm->vmcb->save.gdtr.base = dt->address ;\n\tmark_dirty(svm->vmcb, VMCB_DT);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_dirty",
          "args": [
            "svm->vmcb",
            "VMCB_DT"
          ],
          "line": 1740
        },
        "resolved": true,
        "details": {
          "function_name": "mark_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "289-292",
          "snippet": "static inline void mark_dirty(struct vmcb *vmcb, int bit)\n{\n\tvmcb->control.clean &= ~(1 << bit);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic inline void mark_dirty(struct vmcb *vmcb, int bit)\n{\n\tvmcb->control.clean &= ~(1 << bit);\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 1736
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "294-297",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic void svm_set_gdt(struct kvm_vcpu *vcpu, struct desc_ptr *dt)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tsvm->vmcb->save.gdtr.limit = dt->size;\n\tsvm->vmcb->save.gdtr.base = dt->address ;\n\tmark_dirty(svm->vmcb, VMCB_DT);\n}"
  },
  {
    "function_name": "svm_get_gdt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "1726-1732",
    "snippet": "static void svm_get_gdt(struct kvm_vcpu *vcpu, struct desc_ptr *dt)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tdt->size = svm->vmcb->save.gdtr.limit;\n\tdt->address = svm->vmcb->save.gdtr.base;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 1728
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "294-297",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic void svm_get_gdt(struct kvm_vcpu *vcpu, struct desc_ptr *dt)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tdt->size = svm->vmcb->save.gdtr.limit;\n\tdt->address = svm->vmcb->save.gdtr.base;\n}"
  },
  {
    "function_name": "svm_set_idt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "1717-1724",
    "snippet": "static void svm_set_idt(struct kvm_vcpu *vcpu, struct desc_ptr *dt)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tsvm->vmcb->save.idtr.limit = dt->size;\n\tsvm->vmcb->save.idtr.base = dt->address ;\n\tmark_dirty(svm->vmcb, VMCB_DT);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_dirty",
          "args": [
            "svm->vmcb",
            "VMCB_DT"
          ],
          "line": 1723
        },
        "resolved": true,
        "details": {
          "function_name": "mark_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "289-292",
          "snippet": "static inline void mark_dirty(struct vmcb *vmcb, int bit)\n{\n\tvmcb->control.clean &= ~(1 << bit);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic inline void mark_dirty(struct vmcb *vmcb, int bit)\n{\n\tvmcb->control.clean &= ~(1 << bit);\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 1719
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "294-297",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic void svm_set_idt(struct kvm_vcpu *vcpu, struct desc_ptr *dt)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tsvm->vmcb->save.idtr.limit = dt->size;\n\tsvm->vmcb->save.idtr.base = dt->address ;\n\tmark_dirty(svm->vmcb, VMCB_DT);\n}"
  },
  {
    "function_name": "svm_get_idt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "1709-1715",
    "snippet": "static void svm_get_idt(struct kvm_vcpu *vcpu, struct desc_ptr *dt)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tdt->size = svm->vmcb->save.idtr.limit;\n\tdt->address = svm->vmcb->save.idtr.base;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 1711
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "294-297",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic void svm_get_idt(struct kvm_vcpu *vcpu, struct desc_ptr *dt)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tdt->size = svm->vmcb->save.idtr.limit;\n\tdt->address = svm->vmcb->save.idtr.base;\n}"
  },
  {
    "function_name": "svm_get_cpl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "1702-1707",
    "snippet": "static int svm_get_cpl(struct kvm_vcpu *vcpu)\n{\n\tstruct vmcb_save_area *save = &to_svm(vcpu)->vmcb->save;\n\n\treturn save->cpl;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 1704
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "294-297",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\n\nstatic int svm_get_cpl(struct kvm_vcpu *vcpu)\n{\n\tstruct vmcb_save_area *save = &to_svm(vcpu)->vmcb->save;\n\n\treturn save->cpl;\n}"
  },
  {
    "function_name": "svm_get_segment",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "1634-1700",
    "snippet": "static void svm_get_segment(struct kvm_vcpu *vcpu,\n\t\t\t    struct kvm_segment *var, int seg)\n{\n\tstruct vmcb_seg *s = svm_seg(vcpu, seg);\n\n\tvar->base = s->base;\n\tvar->limit = s->limit;\n\tvar->selector = s->selector;\n\tvar->type = s->attrib & SVM_SELECTOR_TYPE_MASK;\n\tvar->s = (s->attrib >> SVM_SELECTOR_S_SHIFT) & 1;\n\tvar->dpl = (s->attrib >> SVM_SELECTOR_DPL_SHIFT) & 3;\n\tvar->present = (s->attrib >> SVM_SELECTOR_P_SHIFT) & 1;\n\tvar->avl = (s->attrib >> SVM_SELECTOR_AVL_SHIFT) & 1;\n\tvar->l = (s->attrib >> SVM_SELECTOR_L_SHIFT) & 1;\n\tvar->db = (s->attrib >> SVM_SELECTOR_DB_SHIFT) & 1;\n\n\t/*\n\t * AMD CPUs circa 2014 track the G bit for all segments except CS.\n\t * However, the SVM spec states that the G bit is not observed by the\n\t * CPU, and some VMware virtual CPUs drop the G bit for all segments.\n\t * So let's synthesize a legal G bit for all segments, this helps\n\t * running KVM nested. It also helps cross-vendor migration, because\n\t * Intel's vmentry has a check on the 'G' bit.\n\t */\n\tvar->g = s->limit > 0xfffff;\n\n\t/*\n\t * AMD's VMCB does not have an explicit unusable field, so emulate it\n\t * for cross vendor migration purposes by \"not present\"\n\t */\n\tvar->unusable = !var->present || (var->type == 0);\n\n\tswitch (seg) {\n\tcase VCPU_SREG_TR:\n\t\t/*\n\t\t * Work around a bug where the busy flag in the tr selector\n\t\t * isn't exposed\n\t\t */\n\t\tvar->type |= 0x2;\n\t\tbreak;\n\tcase VCPU_SREG_DS:\n\tcase VCPU_SREG_ES:\n\tcase VCPU_SREG_FS:\n\tcase VCPU_SREG_GS:\n\t\t/*\n\t\t * The accessed bit must always be set in the segment\n\t\t * descriptor cache, although it can be cleared in the\n\t\t * descriptor, the cached bit always remains at 1. Since\n\t\t * Intel has a check on this, set it here to support\n\t\t * cross-vendor migration.\n\t\t */\n\t\tif (!var->unusable)\n\t\t\tvar->type |= 0x1;\n\t\tbreak;\n\tcase VCPU_SREG_SS:\n\t\t/*\n\t\t * On AMD CPUs sometimes the DB bit in the segment\n\t\t * descriptor is left as 1, although the whole segment has\n\t\t * been made unusable. Clear it here to pass an Intel VMX\n\t\t * entry check when cross vendor migrating.\n\t\t */\n\t\tif (var->unusable)\n\t\t\tvar->db = 0;\n\t\tvar->dpl = to_svm(vcpu)->vmcb->save.cpl;\n\t\tbreak;\n\t}\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int nested = true;",
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 1697
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "294-297",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "svm_seg",
          "args": [
            "vcpu",
            "seg"
          ],
          "line": 1637
        },
        "resolved": true,
        "details": {
          "function_name": "svm_seg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "1609-1625",
          "snippet": "static struct vmcb_seg *svm_seg(struct kvm_vcpu *vcpu, int seg)\n{\n\tstruct vmcb_save_area *save = &to_svm(vcpu)->vmcb->save;\n\n\tswitch (seg) {\n\tcase VCPU_SREG_CS: return &save->cs;\n\tcase VCPU_SREG_DS: return &save->ds;\n\tcase VCPU_SREG_ES: return &save->es;\n\tcase VCPU_SREG_FS: return &save->fs;\n\tcase VCPU_SREG_GS: return &save->gs;\n\tcase VCPU_SREG_SS: return &save->ss;\n\tcase VCPU_SREG_TR: return &save->tr;\n\tcase VCPU_SREG_LDTR: return &save->ldtr;\n\t}\n\tBUG();\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\n\nstatic struct vmcb_seg *svm_seg(struct kvm_vcpu *vcpu, int seg)\n{\n\tstruct vmcb_save_area *save = &to_svm(vcpu)->vmcb->save;\n\n\tswitch (seg) {\n\tcase VCPU_SREG_CS: return &save->cs;\n\tcase VCPU_SREG_DS: return &save->ds;\n\tcase VCPU_SREG_ES: return &save->es;\n\tcase VCPU_SREG_FS: return &save->fs;\n\tcase VCPU_SREG_GS: return &save->gs;\n\tcase VCPU_SREG_SS: return &save->ss;\n\tcase VCPU_SREG_TR: return &save->tr;\n\tcase VCPU_SREG_LDTR: return &save->ldtr;\n\t}\n\tBUG();\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int nested = true;\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\n\nstatic void svm_get_segment(struct kvm_vcpu *vcpu,\n\t\t\t    struct kvm_segment *var, int seg)\n{\n\tstruct vmcb_seg *s = svm_seg(vcpu, seg);\n\n\tvar->base = s->base;\n\tvar->limit = s->limit;\n\tvar->selector = s->selector;\n\tvar->type = s->attrib & SVM_SELECTOR_TYPE_MASK;\n\tvar->s = (s->attrib >> SVM_SELECTOR_S_SHIFT) & 1;\n\tvar->dpl = (s->attrib >> SVM_SELECTOR_DPL_SHIFT) & 3;\n\tvar->present = (s->attrib >> SVM_SELECTOR_P_SHIFT) & 1;\n\tvar->avl = (s->attrib >> SVM_SELECTOR_AVL_SHIFT) & 1;\n\tvar->l = (s->attrib >> SVM_SELECTOR_L_SHIFT) & 1;\n\tvar->db = (s->attrib >> SVM_SELECTOR_DB_SHIFT) & 1;\n\n\t/*\n\t * AMD CPUs circa 2014 track the G bit for all segments except CS.\n\t * However, the SVM spec states that the G bit is not observed by the\n\t * CPU, and some VMware virtual CPUs drop the G bit for all segments.\n\t * So let's synthesize a legal G bit for all segments, this helps\n\t * running KVM nested. It also helps cross-vendor migration, because\n\t * Intel's vmentry has a check on the 'G' bit.\n\t */\n\tvar->g = s->limit > 0xfffff;\n\n\t/*\n\t * AMD's VMCB does not have an explicit unusable field, so emulate it\n\t * for cross vendor migration purposes by \"not present\"\n\t */\n\tvar->unusable = !var->present || (var->type == 0);\n\n\tswitch (seg) {\n\tcase VCPU_SREG_TR:\n\t\t/*\n\t\t * Work around a bug where the busy flag in the tr selector\n\t\t * isn't exposed\n\t\t */\n\t\tvar->type |= 0x2;\n\t\tbreak;\n\tcase VCPU_SREG_DS:\n\tcase VCPU_SREG_ES:\n\tcase VCPU_SREG_FS:\n\tcase VCPU_SREG_GS:\n\t\t/*\n\t\t * The accessed bit must always be set in the segment\n\t\t * descriptor cache, although it can be cleared in the\n\t\t * descriptor, the cached bit always remains at 1. Since\n\t\t * Intel has a check on this, set it here to support\n\t\t * cross-vendor migration.\n\t\t */\n\t\tif (!var->unusable)\n\t\t\tvar->type |= 0x1;\n\t\tbreak;\n\tcase VCPU_SREG_SS:\n\t\t/*\n\t\t * On AMD CPUs sometimes the DB bit in the segment\n\t\t * descriptor is left as 1, although the whole segment has\n\t\t * been made unusable. Clear it here to pass an Intel VMX\n\t\t * entry check when cross vendor migrating.\n\t\t */\n\t\tif (var->unusable)\n\t\t\tvar->db = 0;\n\t\tvar->dpl = to_svm(vcpu)->vmcb->save.cpl;\n\t\tbreak;\n\t}\n}"
  },
  {
    "function_name": "svm_get_segment_base",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "1627-1632",
    "snippet": "static u64 svm_get_segment_base(struct kvm_vcpu *vcpu, int seg)\n{\n\tstruct vmcb_seg *s = svm_seg(vcpu, seg);\n\n\treturn s->base;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "svm_seg",
          "args": [
            "vcpu",
            "seg"
          ],
          "line": 1629
        },
        "resolved": true,
        "details": {
          "function_name": "svm_seg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "1609-1625",
          "snippet": "static struct vmcb_seg *svm_seg(struct kvm_vcpu *vcpu, int seg)\n{\n\tstruct vmcb_save_area *save = &to_svm(vcpu)->vmcb->save;\n\n\tswitch (seg) {\n\tcase VCPU_SREG_CS: return &save->cs;\n\tcase VCPU_SREG_DS: return &save->ds;\n\tcase VCPU_SREG_ES: return &save->es;\n\tcase VCPU_SREG_FS: return &save->fs;\n\tcase VCPU_SREG_GS: return &save->gs;\n\tcase VCPU_SREG_SS: return &save->ss;\n\tcase VCPU_SREG_TR: return &save->tr;\n\tcase VCPU_SREG_LDTR: return &save->ldtr;\n\t}\n\tBUG();\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\n\nstatic struct vmcb_seg *svm_seg(struct kvm_vcpu *vcpu, int seg)\n{\n\tstruct vmcb_save_area *save = &to_svm(vcpu)->vmcb->save;\n\n\tswitch (seg) {\n\tcase VCPU_SREG_CS: return &save->cs;\n\tcase VCPU_SREG_DS: return &save->ds;\n\tcase VCPU_SREG_ES: return &save->es;\n\tcase VCPU_SREG_FS: return &save->fs;\n\tcase VCPU_SREG_GS: return &save->gs;\n\tcase VCPU_SREG_SS: return &save->ss;\n\tcase VCPU_SREG_TR: return &save->tr;\n\tcase VCPU_SREG_LDTR: return &save->ldtr;\n\t}\n\tBUG();\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\n\nstatic u64 svm_get_segment_base(struct kvm_vcpu *vcpu, int seg)\n{\n\tstruct vmcb_seg *s = svm_seg(vcpu, seg);\n\n\treturn s->base;\n}"
  },
  {
    "function_name": "svm_seg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "1609-1625",
    "snippet": "static struct vmcb_seg *svm_seg(struct kvm_vcpu *vcpu, int seg)\n{\n\tstruct vmcb_save_area *save = &to_svm(vcpu)->vmcb->save;\n\n\tswitch (seg) {\n\tcase VCPU_SREG_CS: return &save->cs;\n\tcase VCPU_SREG_DS: return &save->ds;\n\tcase VCPU_SREG_ES: return &save->es;\n\tcase VCPU_SREG_FS: return &save->fs;\n\tcase VCPU_SREG_GS: return &save->gs;\n\tcase VCPU_SREG_SS: return &save->ss;\n\tcase VCPU_SREG_TR: return &save->tr;\n\tcase VCPU_SREG_LDTR: return &save->ldtr;\n\t}\n\tBUG();\n\treturn NULL;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 1623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 1611
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "294-297",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\n\nstatic struct vmcb_seg *svm_seg(struct kvm_vcpu *vcpu, int seg)\n{\n\tstruct vmcb_save_area *save = &to_svm(vcpu)->vmcb->save;\n\n\tswitch (seg) {\n\tcase VCPU_SREG_CS: return &save->cs;\n\tcase VCPU_SREG_DS: return &save->ds;\n\tcase VCPU_SREG_ES: return &save->es;\n\tcase VCPU_SREG_FS: return &save->fs;\n\tcase VCPU_SREG_GS: return &save->gs;\n\tcase VCPU_SREG_SS: return &save->ss;\n\tcase VCPU_SREG_TR: return &save->tr;\n\tcase VCPU_SREG_LDTR: return &save->ldtr;\n\t}\n\tBUG();\n\treturn NULL;\n}"
  },
  {
    "function_name": "svm_clear_vintr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "1604-1607",
    "snippet": "static void svm_clear_vintr(struct vcpu_svm *svm)\n{\n\tclr_intercept(svm, INTERCEPT_VINTR);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "clr_intercept",
          "args": [
            "svm",
            "INTERCEPT_VINTR"
          ],
          "line": 1606
        },
        "resolved": true,
        "details": {
          "function_name": "clr_intercept",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "429-436",
          "snippet": "static inline void clr_intercept(struct vcpu_svm *svm, int bit)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept &= ~(1ULL << bit);\n\n\trecalc_intercepts(svm);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic inline void clr_intercept(struct vcpu_svm *svm, int bit)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept &= ~(1ULL << bit);\n\n\trecalc_intercepts(svm);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic void svm_clear_vintr(struct vcpu_svm *svm)\n{\n\tclr_intercept(svm, INTERCEPT_VINTR);\n}"
  },
  {
    "function_name": "svm_set_vintr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "1599-1602",
    "snippet": "static void svm_set_vintr(struct vcpu_svm *svm)\n{\n\tset_intercept(svm, INTERCEPT_VINTR);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_intercept",
          "args": [
            "svm",
            "INTERCEPT_VINTR"
          ],
          "line": 1601
        },
        "resolved": true,
        "details": {
          "function_name": "set_intercept",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "420-427",
          "snippet": "static inline void set_intercept(struct vcpu_svm *svm, int bit)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept |= (1ULL << bit);\n\n\trecalc_intercepts(svm);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic inline void set_intercept(struct vcpu_svm *svm, int bit)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept |= (1ULL << bit);\n\n\trecalc_intercepts(svm);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic void svm_set_vintr(struct vcpu_svm *svm)\n{\n\tset_intercept(svm, INTERCEPT_VINTR);\n}"
  },
  {
    "function_name": "svm_cache_reg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "1587-1597",
    "snippet": "static void svm_cache_reg(struct kvm_vcpu *vcpu, enum kvm_reg reg)\n{\n\tswitch (reg) {\n\tcase VCPU_EXREG_PDPTR:\n\t\tBUG_ON(!npt_enabled);\n\t\tload_pdptrs(vcpu, vcpu->arch.walk_mmu, kvm_read_cr3(vcpu));\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 1595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "load_pdptrs",
          "args": [
            "vcpu",
            "vcpu->arch.walk_mmu",
            "kvm_read_cr3(vcpu)"
          ],
          "line": 1592
        },
        "resolved": true,
        "details": {
          "function_name": "load_pdptrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "524-557",
          "snippet": "int load_pdptrs(struct kvm_vcpu *vcpu, struct kvm_mmu *mmu, unsigned long cr3)\n{\n\tgfn_t pdpt_gfn = cr3 >> PAGE_SHIFT;\n\tunsigned offset = ((cr3 & (PAGE_SIZE-1)) >> 5) << 2;\n\tint i;\n\tint ret;\n\tu64 pdpte[ARRAY_SIZE(mmu->pdptrs)];\n\n\tret = kvm_read_guest_page_mmu(vcpu, mmu, pdpt_gfn, pdpte,\n\t\t\t\t      offset * sizeof(u64), sizeof(pdpte),\n\t\t\t\t      PFERR_USER_MASK|PFERR_WRITE_MASK);\n\tif (ret < 0) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\tfor (i = 0; i < ARRAY_SIZE(pdpte); ++i) {\n\t\tif (is_present_gpte(pdpte[i]) &&\n\t\t    (pdpte[i] &\n\t\t     vcpu->arch.mmu.guest_rsvd_check.rsvd_bits_mask[0][2])) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tret = 1;\n\n\tmemcpy(mmu->pdptrs, pdpte, sizeof(mmu->pdptrs));\n\t__set_bit(VCPU_EXREG_PDPTR,\n\t\t  (unsigned long *)&vcpu->arch.regs_avail);\n\t__set_bit(VCPU_EXREG_PDPTR,\n\t\t  (unsigned long *)&vcpu->arch.regs_dirty);\nout:\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nint load_pdptrs(struct kvm_vcpu *vcpu, struct kvm_mmu *mmu, unsigned long cr3)\n{\n\tgfn_t pdpt_gfn = cr3 >> PAGE_SHIFT;\n\tunsigned offset = ((cr3 & (PAGE_SIZE-1)) >> 5) << 2;\n\tint i;\n\tint ret;\n\tu64 pdpte[ARRAY_SIZE(mmu->pdptrs)];\n\n\tret = kvm_read_guest_page_mmu(vcpu, mmu, pdpt_gfn, pdpte,\n\t\t\t\t      offset * sizeof(u64), sizeof(pdpte),\n\t\t\t\t      PFERR_USER_MASK|PFERR_WRITE_MASK);\n\tif (ret < 0) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\tfor (i = 0; i < ARRAY_SIZE(pdpte); ++i) {\n\t\tif (is_present_gpte(pdpte[i]) &&\n\t\t    (pdpte[i] &\n\t\t     vcpu->arch.mmu.guest_rsvd_check.rsvd_bits_mask[0][2])) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tret = 1;\n\n\tmemcpy(mmu->pdptrs, pdpte, sizeof(mmu->pdptrs));\n\t__set_bit(VCPU_EXREG_PDPTR,\n\t\t  (unsigned long *)&vcpu->arch.regs_avail);\n\t__set_bit(VCPU_EXREG_PDPTR,\n\t\t  (unsigned long *)&vcpu->arch.regs_dirty);\nout:\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_read_cr3",
          "args": [
            "vcpu"
          ],
          "line": 1592
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_read_cr3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "69-74",
          "snippet": "static inline ulong kvm_read_cr3(struct kvm_vcpu *vcpu)\n{\n\tif (!test_bit(VCPU_EXREG_CR3, (ulong *)&vcpu->arch.regs_avail))\n\t\tkvm_x86_ops->decache_cr3(vcpu);\n\treturn vcpu->arch.cr3;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline ulong kvm_read_cr3(struct kvm_vcpu *vcpu)\n{\n\tif (!test_bit(VCPU_EXREG_CR3, (ulong *)&vcpu->arch.regs_avail))\n\t\tkvm_x86_ops->decache_cr3(vcpu);\n\treturn vcpu->arch.cr3;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!npt_enabled"
          ],
          "line": 1591
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\n\nstatic void svm_cache_reg(struct kvm_vcpu *vcpu, enum kvm_reg reg)\n{\n\tswitch (reg) {\n\tcase VCPU_EXREG_PDPTR:\n\t\tBUG_ON(!npt_enabled);\n\t\tload_pdptrs(vcpu, vcpu->arch.walk_mmu, kvm_read_cr3(vcpu));\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}"
  },
  {
    "function_name": "svm_get_pkru",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "1582-1585",
    "snippet": "static u32 svm_get_pkru(struct kvm_vcpu *vcpu)\n{\n\treturn 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\n\nstatic u32 svm_get_pkru(struct kvm_vcpu *vcpu)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "svm_set_rflags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "1572-1580",
    "snippet": "static void svm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags)\n{\n       /*\n        * Any change of EFLAGS.VM is accompained by a reload of SS\n        * (caused by either a task switch or an inter-privilege IRET),\n        * so we do not need to update the CPL here.\n        */\n\tto_svm(vcpu)->vmcb->save.rflags = rflags;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 1579
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "294-297",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\n\nstatic void svm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags)\n{\n       /*\n        * Any change of EFLAGS.VM is accompained by a reload of SS\n        * (caused by either a task switch or an inter-privilege IRET),\n        * so we do not need to update the CPL here.\n        */\n\tto_svm(vcpu)->vmcb->save.rflags = rflags;\n}"
  },
  {
    "function_name": "svm_get_rflags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "1567-1570",
    "snippet": "static unsigned long svm_get_rflags(struct kvm_vcpu *vcpu)\n{\n\treturn to_svm(vcpu)->vmcb->save.rflags;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 1569
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "294-297",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\n\nstatic unsigned long svm_get_rflags(struct kvm_vcpu *vcpu)\n{\n\treturn to_svm(vcpu)->vmcb->save.rflags;\n}"
  },
  {
    "function_name": "svm_vcpu_unblocking",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "1562-1565",
    "snippet": "static void svm_vcpu_unblocking(struct kvm_vcpu *vcpu)\n{\n\tavic_set_running(vcpu, true);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "avic_set_running",
          "args": [
            "vcpu",
            "true"
          ],
          "line": 1564
        },
        "resolved": true,
        "details": {
          "function_name": "avic_set_running",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "1324-1346",
          "snippet": "static void avic_set_running(struct kvm_vcpu *vcpu, bool is_run)\n{\n\tu64 entry;\n\tint h_physical_id = __default_cpu_present_to_apicid(vcpu->cpu);\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (!kvm_vcpu_apicv_active(vcpu))\n\t\treturn;\n\n\tsvm->avic_is_running = is_run;\n\n\t/* ID = 0xff (broadcast), ID > 0xff (reserved) */\n\tif (WARN_ON(h_physical_id >= AVIC_MAX_PHYSICAL_ID_COUNT))\n\t\treturn;\n\n\tentry = READ_ONCE(*(svm->avic_physical_id_cache));\n\tWARN_ON(is_run == !!(entry & AVIC_PHYSICAL_ID_ENTRY_IS_RUNNING_MASK));\n\n\tentry &= ~AVIC_PHYSICAL_ID_ENTRY_IS_RUNNING_MASK;\n\tif (is_run)\n\t\tentry |= AVIC_PHYSICAL_ID_ENTRY_IS_RUNNING_MASK;\n\tWRITE_ONCE(*(svm->avic_physical_id_cache), entry);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define AVIC_PHYSICAL_ID_ENTRY_IS_RUNNING_MASK\t\t(1ULL << 62)",
            "#define AVIC_MAX_PHYSICAL_ID_COUNT\t255"
          ],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define AVIC_PHYSICAL_ID_ENTRY_IS_RUNNING_MASK\t\t(1ULL << 62)\n#define AVIC_MAX_PHYSICAL_ID_COUNT\t255\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic void avic_set_running(struct kvm_vcpu *vcpu, bool is_run)\n{\n\tu64 entry;\n\tint h_physical_id = __default_cpu_present_to_apicid(vcpu->cpu);\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (!kvm_vcpu_apicv_active(vcpu))\n\t\treturn;\n\n\tsvm->avic_is_running = is_run;\n\n\t/* ID = 0xff (broadcast), ID > 0xff (reserved) */\n\tif (WARN_ON(h_physical_id >= AVIC_MAX_PHYSICAL_ID_COUNT))\n\t\treturn;\n\n\tentry = READ_ONCE(*(svm->avic_physical_id_cache));\n\tWARN_ON(is_run == !!(entry & AVIC_PHYSICAL_ID_ENTRY_IS_RUNNING_MASK));\n\n\tentry &= ~AVIC_PHYSICAL_ID_ENTRY_IS_RUNNING_MASK;\n\tif (is_run)\n\t\tentry |= AVIC_PHYSICAL_ID_ENTRY_IS_RUNNING_MASK;\n\tWRITE_ONCE(*(svm->avic_physical_id_cache), entry);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\n\nstatic void svm_vcpu_unblocking(struct kvm_vcpu *vcpu)\n{\n\tavic_set_running(vcpu, true);\n}"
  },
  {
    "function_name": "svm_vcpu_blocking",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "1557-1560",
    "snippet": "static void svm_vcpu_blocking(struct kvm_vcpu *vcpu)\n{\n\tavic_set_running(vcpu, false);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "avic_set_running",
          "args": [
            "vcpu",
            "false"
          ],
          "line": 1559
        },
        "resolved": true,
        "details": {
          "function_name": "avic_set_running",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "1324-1346",
          "snippet": "static void avic_set_running(struct kvm_vcpu *vcpu, bool is_run)\n{\n\tu64 entry;\n\tint h_physical_id = __default_cpu_present_to_apicid(vcpu->cpu);\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (!kvm_vcpu_apicv_active(vcpu))\n\t\treturn;\n\n\tsvm->avic_is_running = is_run;\n\n\t/* ID = 0xff (broadcast), ID > 0xff (reserved) */\n\tif (WARN_ON(h_physical_id >= AVIC_MAX_PHYSICAL_ID_COUNT))\n\t\treturn;\n\n\tentry = READ_ONCE(*(svm->avic_physical_id_cache));\n\tWARN_ON(is_run == !!(entry & AVIC_PHYSICAL_ID_ENTRY_IS_RUNNING_MASK));\n\n\tentry &= ~AVIC_PHYSICAL_ID_ENTRY_IS_RUNNING_MASK;\n\tif (is_run)\n\t\tentry |= AVIC_PHYSICAL_ID_ENTRY_IS_RUNNING_MASK;\n\tWRITE_ONCE(*(svm->avic_physical_id_cache), entry);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define AVIC_PHYSICAL_ID_ENTRY_IS_RUNNING_MASK\t\t(1ULL << 62)",
            "#define AVIC_MAX_PHYSICAL_ID_COUNT\t255"
          ],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define AVIC_PHYSICAL_ID_ENTRY_IS_RUNNING_MASK\t\t(1ULL << 62)\n#define AVIC_MAX_PHYSICAL_ID_COUNT\t255\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic void avic_set_running(struct kvm_vcpu *vcpu, bool is_run)\n{\n\tu64 entry;\n\tint h_physical_id = __default_cpu_present_to_apicid(vcpu->cpu);\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (!kvm_vcpu_apicv_active(vcpu))\n\t\treturn;\n\n\tsvm->avic_is_running = is_run;\n\n\t/* ID = 0xff (broadcast), ID > 0xff (reserved) */\n\tif (WARN_ON(h_physical_id >= AVIC_MAX_PHYSICAL_ID_COUNT))\n\t\treturn;\n\n\tentry = READ_ONCE(*(svm->avic_physical_id_cache));\n\tWARN_ON(is_run == !!(entry & AVIC_PHYSICAL_ID_ENTRY_IS_RUNNING_MASK));\n\n\tentry &= ~AVIC_PHYSICAL_ID_ENTRY_IS_RUNNING_MASK;\n\tif (is_run)\n\t\tentry |= AVIC_PHYSICAL_ID_ENTRY_IS_RUNNING_MASK;\n\tWRITE_ONCE(*(svm->avic_physical_id_cache), entry);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\n\nstatic void svm_vcpu_blocking(struct kvm_vcpu *vcpu)\n{\n\tavic_set_running(vcpu, false);\n}"
  },
  {
    "function_name": "svm_vcpu_put",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "1535-1555",
    "snippet": "static void svm_vcpu_put(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tint i;\n\n\tavic_vcpu_put(vcpu);\n\n\t++vcpu->stat.host_state_reload;\n\tkvm_load_ldt(svm->host.ldt);\n#ifdef CONFIG_X86_64\n\tloadsegment(fs, svm->host.fs);\n\twrmsrl(MSR_KERNEL_GS_BASE, current->thread.gs);\n\tload_gs_index(svm->host.gs);\n#else\n#ifdef CONFIG_X86_32_LAZY_GS\n\tloadsegment(gs, svm->host.gs);\n#endif\n#endif\n\tfor (i = 0; i < NR_HOST_SAVE_USER_MSRS; i++)\n\t\twrmsrl(host_save_user_msrs[i], svm->host_user_msrs[i]);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define NR_HOST_SAVE_USER_MSRS ARRAY_SIZE(host_save_user_msrs)"
    ],
    "globals_used": [
      "static const u32 host_save_user_msrs[] = {\n#ifdef CONFIG_X86_64\n\tMSR_STAR, MSR_LSTAR, MSR_CSTAR, MSR_SYSCALL_MASK, MSR_KERNEL_GS_BASE,\n\tMSR_FS_BASE,\n#endif\n\tMSR_IA32_SYSENTER_CS, MSR_IA32_SYSENTER_ESP, MSR_IA32_SYSENTER_EIP,\n\tMSR_TSC_AUX,\n};",
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wrmsrl",
          "args": [
            "host_save_user_msrs[i]",
            "svm->host_user_msrs[i]"
          ],
          "line": 1554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "loadsegment",
          "args": [
            "gs",
            "svm->host.gs"
          ],
          "line": 1550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "load_gs_index",
          "args": [
            "svm->host.gs"
          ],
          "line": 1547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wrmsrl",
          "args": [
            "MSR_KERNEL_GS_BASE",
            "current->thread.gs"
          ],
          "line": 1546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "loadsegment",
          "args": [
            "fs",
            "svm->host.fs"
          ],
          "line": 1545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_load_ldt",
          "args": [
            "svm->host.ldt"
          ],
          "line": 1543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "avic_vcpu_put",
          "args": [
            "vcpu"
          ],
          "line": 1540
        },
        "resolved": true,
        "details": {
          "function_name": "avic_vcpu_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "1374-1385",
          "snippet": "static void avic_vcpu_put(struct kvm_vcpu *vcpu)\n{\n\tu64 entry;\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (!kvm_vcpu_apicv_active(vcpu))\n\t\treturn;\n\n\tentry = READ_ONCE(*(svm->avic_physical_id_cache));\n\tentry &= ~AVIC_PHYSICAL_ID_ENTRY_IS_RUNNING_MASK;\n\tWRITE_ONCE(*(svm->avic_physical_id_cache), entry);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define AVIC_PHYSICAL_ID_ENTRY_IS_RUNNING_MASK\t\t(1ULL << 62)"
          ],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define AVIC_PHYSICAL_ID_ENTRY_IS_RUNNING_MASK\t\t(1ULL << 62)\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic void avic_vcpu_put(struct kvm_vcpu *vcpu)\n{\n\tu64 entry;\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (!kvm_vcpu_apicv_active(vcpu))\n\t\treturn;\n\n\tentry = READ_ONCE(*(svm->avic_physical_id_cache));\n\tentry &= ~AVIC_PHYSICAL_ID_ENTRY_IS_RUNNING_MASK;\n\tWRITE_ONCE(*(svm->avic_physical_id_cache), entry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 1537
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "294-297",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define NR_HOST_SAVE_USER_MSRS ARRAY_SIZE(host_save_user_msrs)\n\nstatic const u32 host_save_user_msrs[] = {\n#ifdef CONFIG_X86_64\n\tMSR_STAR, MSR_LSTAR, MSR_CSTAR, MSR_SYSCALL_MASK, MSR_KERNEL_GS_BASE,\n\tMSR_FS_BASE,\n#endif\n\tMSR_IA32_SYSENTER_CS, MSR_IA32_SYSENTER_ESP, MSR_IA32_SYSENTER_EIP,\n\tMSR_TSC_AUX,\n};\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic void svm_vcpu_put(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tint i;\n\n\tavic_vcpu_put(vcpu);\n\n\t++vcpu->stat.host_state_reload;\n\tkvm_load_ldt(svm->host.ldt);\n#ifdef CONFIG_X86_64\n\tloadsegment(fs, svm->host.fs);\n\twrmsrl(MSR_KERNEL_GS_BASE, current->thread.gs);\n\tload_gs_index(svm->host.gs);\n#else\n#ifdef CONFIG_X86_32_LAZY_GS\n\tloadsegment(gs, svm->host.gs);\n#endif\n#endif\n\tfor (i = 0; i < NR_HOST_SAVE_USER_MSRS; i++)\n\t\twrmsrl(host_save_user_msrs[i], svm->host_user_msrs[i]);\n}"
  },
  {
    "function_name": "svm_vcpu_load",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "1501-1533",
    "snippet": "static void svm_vcpu_load(struct kvm_vcpu *vcpu, int cpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tint i;\n\n\tif (unlikely(cpu != vcpu->cpu)) {\n\t\tsvm->asid_generation = 0;\n\t\tmark_all_dirty(svm->vmcb);\n\t}\n\n#ifdef CONFIG_X86_64\n\trdmsrl(MSR_GS_BASE, to_svm(vcpu)->host.gs_base);\n#endif\n\tsavesegment(fs, svm->host.fs);\n\tsavesegment(gs, svm->host.gs);\n\tsvm->host.ldt = kvm_read_ldt();\n\n\tfor (i = 0; i < NR_HOST_SAVE_USER_MSRS; i++)\n\t\trdmsrl(host_save_user_msrs[i], svm->host_user_msrs[i]);\n\n\tif (static_cpu_has(X86_FEATURE_TSCRATEMSR)) {\n\t\tu64 tsc_ratio = vcpu->arch.tsc_scaling_ratio;\n\t\tif (tsc_ratio != __this_cpu_read(current_tsc_ratio)) {\n\t\t\t__this_cpu_write(current_tsc_ratio, tsc_ratio);\n\t\t\twrmsrl(MSR_AMD64_TSC_RATIO, tsc_ratio);\n\t\t}\n\t}\n\t/* This assumes that the kernel never uses MSR_TSC_AUX */\n\tif (static_cpu_has(X86_FEATURE_RDTSCP))\n\t\twrmsrl(MSR_TSC_AUX, svm->tsc_aux);\n\n\tavic_vcpu_load(vcpu, cpu);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define NR_HOST_SAVE_USER_MSRS ARRAY_SIZE(host_save_user_msrs)"
    ],
    "globals_used": [
      "static const u32 host_save_user_msrs[] = {\n#ifdef CONFIG_X86_64\n\tMSR_STAR, MSR_LSTAR, MSR_CSTAR, MSR_SYSCALL_MASK, MSR_KERNEL_GS_BASE,\n\tMSR_FS_BASE,\n#endif\n\tMSR_IA32_SYSENTER_CS, MSR_IA32_SYSENTER_ESP, MSR_IA32_SYSENTER_EIP,\n\tMSR_TSC_AUX,\n};",
      "static DEFINE_PER_CPU(u64, current_tsc_ratio);",
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "avic_vcpu_load",
          "args": [
            "vcpu",
            "cpu"
          ],
          "line": 1532
        },
        "resolved": true,
        "details": {
          "function_name": "avic_vcpu_load",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "1348-1372",
          "snippet": "static void avic_vcpu_load(struct kvm_vcpu *vcpu, int cpu)\n{\n\tu64 entry;\n\t/* ID = 0xff (broadcast), ID > 0xff (reserved) */\n\tint h_physical_id = __default_cpu_present_to_apicid(cpu);\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (!kvm_vcpu_apicv_active(vcpu))\n\t\treturn;\n\n\tif (WARN_ON(h_physical_id >= AVIC_MAX_PHYSICAL_ID_COUNT))\n\t\treturn;\n\n\tentry = READ_ONCE(*(svm->avic_physical_id_cache));\n\tWARN_ON(entry & AVIC_PHYSICAL_ID_ENTRY_IS_RUNNING_MASK);\n\n\tentry &= ~AVIC_PHYSICAL_ID_ENTRY_HOST_PHYSICAL_ID_MASK;\n\tentry |= (h_physical_id & AVIC_PHYSICAL_ID_ENTRY_HOST_PHYSICAL_ID_MASK);\n\n\tentry &= ~AVIC_PHYSICAL_ID_ENTRY_IS_RUNNING_MASK;\n\tif (svm->avic_is_running)\n\t\tentry |= AVIC_PHYSICAL_ID_ENTRY_IS_RUNNING_MASK;\n\n\tWRITE_ONCE(*(svm->avic_physical_id_cache), entry);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define AVIC_PHYSICAL_ID_ENTRY_IS_RUNNING_MASK\t\t(1ULL << 62)",
            "#define AVIC_PHYSICAL_ID_ENTRY_HOST_PHYSICAL_ID_MASK\t(0xFFULL)",
            "#define AVIC_MAX_PHYSICAL_ID_COUNT\t255"
          ],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define AVIC_PHYSICAL_ID_ENTRY_IS_RUNNING_MASK\t\t(1ULL << 62)\n#define AVIC_PHYSICAL_ID_ENTRY_HOST_PHYSICAL_ID_MASK\t(0xFFULL)\n#define AVIC_MAX_PHYSICAL_ID_COUNT\t255\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic void avic_vcpu_load(struct kvm_vcpu *vcpu, int cpu)\n{\n\tu64 entry;\n\t/* ID = 0xff (broadcast), ID > 0xff (reserved) */\n\tint h_physical_id = __default_cpu_present_to_apicid(cpu);\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (!kvm_vcpu_apicv_active(vcpu))\n\t\treturn;\n\n\tif (WARN_ON(h_physical_id >= AVIC_MAX_PHYSICAL_ID_COUNT))\n\t\treturn;\n\n\tentry = READ_ONCE(*(svm->avic_physical_id_cache));\n\tWARN_ON(entry & AVIC_PHYSICAL_ID_ENTRY_IS_RUNNING_MASK);\n\n\tentry &= ~AVIC_PHYSICAL_ID_ENTRY_HOST_PHYSICAL_ID_MASK;\n\tentry |= (h_physical_id & AVIC_PHYSICAL_ID_ENTRY_HOST_PHYSICAL_ID_MASK);\n\n\tentry &= ~AVIC_PHYSICAL_ID_ENTRY_IS_RUNNING_MASK;\n\tif (svm->avic_is_running)\n\t\tentry |= AVIC_PHYSICAL_ID_ENTRY_IS_RUNNING_MASK;\n\n\tWRITE_ONCE(*(svm->avic_physical_id_cache), entry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wrmsrl",
          "args": [
            "MSR_TSC_AUX",
            "svm->tsc_aux"
          ],
          "line": 1530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_cpu_has",
          "args": [
            "X86_FEATURE_RDTSCP"
          ],
          "line": 1529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wrmsrl",
          "args": [
            "MSR_AMD64_TSC_RATIO",
            "tsc_ratio"
          ],
          "line": 1525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_write",
          "args": [
            "current_tsc_ratio",
            "tsc_ratio"
          ],
          "line": 1524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_read",
          "args": [
            "current_tsc_ratio"
          ],
          "line": 1523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_cpu_has",
          "args": [
            "X86_FEATURE_TSCRATEMSR"
          ],
          "line": 1521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rdmsrl",
          "args": [
            "host_save_user_msrs[i]",
            "svm->host_user_msrs[i]"
          ],
          "line": 1519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_read_ldt",
          "args": [],
          "line": 1516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "savesegment",
          "args": [
            "gs",
            "svm->host.gs"
          ],
          "line": 1515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "savesegment",
          "args": [
            "fs",
            "svm->host.fs"
          ],
          "line": 1514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rdmsrl",
          "args": [
            "MSR_GS_BASE",
            "to_svm(vcpu)->host.gs_base"
          ],
          "line": 1512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 1512
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "294-297",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_all_dirty",
          "args": [
            "svm->vmcb"
          ],
          "line": 1508
        },
        "resolved": true,
        "details": {
          "function_name": "mark_all_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "278-281",
          "snippet": "static inline void mark_all_dirty(struct vmcb *vmcb)\n{\n\tvmcb->control.clean = 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic inline void mark_all_dirty(struct vmcb *vmcb)\n{\n\tvmcb->control.clean = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "cpu != vcpu->cpu"
          ],
          "line": 1506
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define NR_HOST_SAVE_USER_MSRS ARRAY_SIZE(host_save_user_msrs)\n\nstatic const u32 host_save_user_msrs[] = {\n#ifdef CONFIG_X86_64\n\tMSR_STAR, MSR_LSTAR, MSR_CSTAR, MSR_SYSCALL_MASK, MSR_KERNEL_GS_BASE,\n\tMSR_FS_BASE,\n#endif\n\tMSR_IA32_SYSENTER_CS, MSR_IA32_SYSENTER_ESP, MSR_IA32_SYSENTER_EIP,\n\tMSR_TSC_AUX,\n};\nstatic DEFINE_PER_CPU(u64, current_tsc_ratio);\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic void svm_vcpu_load(struct kvm_vcpu *vcpu, int cpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tint i;\n\n\tif (unlikely(cpu != vcpu->cpu)) {\n\t\tsvm->asid_generation = 0;\n\t\tmark_all_dirty(svm->vmcb);\n\t}\n\n#ifdef CONFIG_X86_64\n\trdmsrl(MSR_GS_BASE, to_svm(vcpu)->host.gs_base);\n#endif\n\tsavesegment(fs, svm->host.fs);\n\tsavesegment(gs, svm->host.gs);\n\tsvm->host.ldt = kvm_read_ldt();\n\n\tfor (i = 0; i < NR_HOST_SAVE_USER_MSRS; i++)\n\t\trdmsrl(host_save_user_msrs[i], svm->host_user_msrs[i]);\n\n\tif (static_cpu_has(X86_FEATURE_TSCRATEMSR)) {\n\t\tu64 tsc_ratio = vcpu->arch.tsc_scaling_ratio;\n\t\tif (tsc_ratio != __this_cpu_read(current_tsc_ratio)) {\n\t\t\t__this_cpu_write(current_tsc_ratio, tsc_ratio);\n\t\t\twrmsrl(MSR_AMD64_TSC_RATIO, tsc_ratio);\n\t\t}\n\t}\n\t/* This assumes that the kernel never uses MSR_TSC_AUX */\n\tif (static_cpu_has(X86_FEATURE_RDTSCP))\n\t\twrmsrl(MSR_TSC_AUX, svm->tsc_aux);\n\n\tavic_vcpu_load(vcpu, cpu);\n}"
  },
  {
    "function_name": "svm_free_vcpu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "1489-1499",
    "snippet": "static void svm_free_vcpu(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\t__free_page(pfn_to_page(svm->vmcb_pa >> PAGE_SHIFT));\n\t__free_pages(virt_to_page(svm->msrpm), MSRPM_ALLOC_ORDER);\n\t__free_page(virt_to_page(svm->nested.hsave));\n\t__free_pages(virt_to_page(svm->nested.msrpm), MSRPM_ALLOC_ORDER);\n\tkvm_vcpu_uninit(vcpu);\n\tkmem_cache_free(kvm_vcpu_cache, svm);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define MSRPM_ALLOC_ORDER 1"
    ],
    "globals_used": [
      "static int nested = true;",
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "kvm_vcpu_cache",
            "svm"
          ],
          "line": 1498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_uninit",
          "args": [
            "vcpu"
          ],
          "line": 1497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__free_pages",
          "args": [
            "virt_to_page(svm->nested.msrpm)",
            "MSRPM_ALLOC_ORDER"
          ],
          "line": 1496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virt_to_page",
          "args": [
            "svm->nested.msrpm"
          ],
          "line": 1496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__free_page",
          "args": [
            "virt_to_page(svm->nested.hsave)"
          ],
          "line": 1495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virt_to_page",
          "args": [
            "svm->nested.hsave"
          ],
          "line": 1495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__free_pages",
          "args": [
            "virt_to_page(svm->msrpm)",
            "MSRPM_ALLOC_ORDER"
          ],
          "line": 1494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virt_to_page",
          "args": [
            "svm->msrpm"
          ],
          "line": 1494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__free_page",
          "args": [
            "pfn_to_page(svm->vmcb_pa >> PAGE_SHIFT)"
          ],
          "line": 1493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_to_page",
          "args": [
            "svm->vmcb_pa >> PAGE_SHIFT"
          ],
          "line": 1493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 1491
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "294-297",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define MSRPM_ALLOC_ORDER 1\n\nstatic int nested = true;\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic void svm_free_vcpu(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\t__free_page(pfn_to_page(svm->vmcb_pa >> PAGE_SHIFT));\n\t__free_pages(virt_to_page(svm->msrpm), MSRPM_ALLOC_ORDER);\n\t__free_page(virt_to_page(svm->nested.hsave));\n\t__free_pages(virt_to_page(svm->nested.msrpm), MSRPM_ALLOC_ORDER);\n\tkvm_vcpu_uninit(vcpu);\n\tkmem_cache_free(kvm_vcpu_cache, svm);\n}"
  },
  {
    "function_name": "svm_create_vcpu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "1408-1487",
    "snippet": "static struct kvm_vcpu *svm_create_vcpu(struct kvm *kvm, unsigned int id)\n{\n\tstruct vcpu_svm *svm;\n\tstruct page *page;\n\tstruct page *msrpm_pages;\n\tstruct page *hsave_page;\n\tstruct page *nested_msrpm_pages;\n\tint err;\n\n\tsvm = kmem_cache_zalloc(kvm_vcpu_cache, GFP_KERNEL);\n\tif (!svm) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\terr = kvm_vcpu_init(&svm->vcpu, kvm, id);\n\tif (err)\n\t\tgoto free_svm;\n\n\terr = -ENOMEM;\n\tpage = alloc_page(GFP_KERNEL);\n\tif (!page)\n\t\tgoto uninit;\n\n\tmsrpm_pages = alloc_pages(GFP_KERNEL, MSRPM_ALLOC_ORDER);\n\tif (!msrpm_pages)\n\t\tgoto free_page1;\n\n\tnested_msrpm_pages = alloc_pages(GFP_KERNEL, MSRPM_ALLOC_ORDER);\n\tif (!nested_msrpm_pages)\n\t\tgoto free_page2;\n\n\thsave_page = alloc_page(GFP_KERNEL);\n\tif (!hsave_page)\n\t\tgoto free_page3;\n\n\tif (avic) {\n\t\terr = avic_init_backing_page(&svm->vcpu);\n\t\tif (err)\n\t\t\tgoto free_page4;\n\t}\n\n\t/* We initialize this flag to true to make sure that the is_running\n\t * bit would be set the first time the vcpu is loaded.\n\t */\n\tsvm->avic_is_running = true;\n\n\tsvm->nested.hsave = page_address(hsave_page);\n\n\tsvm->msrpm = page_address(msrpm_pages);\n\tsvm_vcpu_init_msrpm(svm->msrpm);\n\n\tsvm->nested.msrpm = page_address(nested_msrpm_pages);\n\tsvm_vcpu_init_msrpm(svm->nested.msrpm);\n\n\tsvm->vmcb = page_address(page);\n\tclear_page(svm->vmcb);\n\tsvm->vmcb_pa = page_to_pfn(page) << PAGE_SHIFT;\n\tsvm->asid_generation = 0;\n\tinit_vmcb(svm);\n\n\tsvm_init_osvw(&svm->vcpu);\n\n\treturn &svm->vcpu;\n\nfree_page4:\n\t__free_page(hsave_page);\nfree_page3:\n\t__free_pages(nested_msrpm_pages, MSRPM_ALLOC_ORDER);\nfree_page2:\n\t__free_pages(msrpm_pages, MSRPM_ALLOC_ORDER);\nfree_page1:\n\t__free_page(page);\nuninit:\n\tkvm_vcpu_uninit(&svm->vcpu);\nfree_svm:\n\tkmem_cache_free(kvm_vcpu_cache, svm);\nout:\n\treturn ERR_PTR(err);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define MSRPM_ALLOC_ORDER 1"
    ],
    "globals_used": [
      "static int nested = true;",
      "static int avic;",
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 1486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "kvm_vcpu_cache",
            "svm"
          ],
          "line": 1484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_uninit",
          "args": [
            "&svm->vcpu"
          ],
          "line": 1482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__free_page",
          "args": [
            "page"
          ],
          "line": 1480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__free_pages",
          "args": [
            "msrpm_pages",
            "MSRPM_ALLOC_ORDER"
          ],
          "line": 1478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__free_pages",
          "args": [
            "nested_msrpm_pages",
            "MSRPM_ALLOC_ORDER"
          ],
          "line": 1476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__free_page",
          "args": [
            "hsave_page"
          ],
          "line": 1474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svm_init_osvw",
          "args": [
            "&svm->vcpu"
          ],
          "line": 1469
        },
        "resolved": true,
        "details": {
          "function_name": "svm_init_osvw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "656-675",
          "snippet": "static void svm_init_osvw(struct kvm_vcpu *vcpu)\n{\n\t/*\n\t * Guests should see errata 400 and 415 as fixed (assuming that\n\t * HLT and IO instructions are intercepted).\n\t */\n\tvcpu->arch.osvw.length = (osvw_len >= 3) ? (osvw_len) : 3;\n\tvcpu->arch.osvw.status = osvw_status & ~(6ULL);\n\n\t/*\n\t * By increasing VCPU's osvw.length to 3 we are telling the guest that\n\t * all osvw.status bits inside that length, including bit 0 (which is\n\t * reserved for erratum 298), are valid. However, if host processor's\n\t * osvw_len is 0 then osvw_status[0] carries no information. We need to\n\t * be conservative here and therefore we tell the guest that erratum 298\n\t * is present (because we really don't know).\n\t */\n\tif (osvw_len == 0 && boot_cpu_data.x86 == 0x10)\n\t\tvcpu->arch.osvw.status |= 1;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static uint64_t osvw_len = 4, osvw_status;",
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic uint64_t osvw_len = 4, osvw_status;\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\n\nstatic void svm_init_osvw(struct kvm_vcpu *vcpu)\n{\n\t/*\n\t * Guests should see errata 400 and 415 as fixed (assuming that\n\t * HLT and IO instructions are intercepted).\n\t */\n\tvcpu->arch.osvw.length = (osvw_len >= 3) ? (osvw_len) : 3;\n\tvcpu->arch.osvw.status = osvw_status & ~(6ULL);\n\n\t/*\n\t * By increasing VCPU's osvw.length to 3 we are telling the guest that\n\t * all osvw.status bits inside that length, including bit 0 (which is\n\t * reserved for erratum 298), are valid. However, if host processor's\n\t * osvw_len is 0 then osvw_status[0] carries no information. We need to\n\t * be conservative here and therefore we tell the guest that erratum 298\n\t * is present (because we really don't know).\n\t */\n\tif (osvw_len == 0 && boot_cpu_data.x86 == 0x10)\n\t\tvcpu->arch.osvw.status |= 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_vmcb",
          "args": [
            "svm"
          ],
          "line": 1467
        },
        "resolved": true,
        "details": {
          "function_name": "init_vmcb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "1083-1201",
          "snippet": "static void init_vmcb(struct vcpu_svm *svm)\n{\n\tstruct vmcb_control_area *control = &svm->vmcb->control;\n\tstruct vmcb_save_area *save = &svm->vmcb->save;\n\n\tsvm->vcpu.fpu_active = 1;\n\tsvm->vcpu.arch.hflags = 0;\n\n\tset_cr_intercept(svm, INTERCEPT_CR0_READ);\n\tset_cr_intercept(svm, INTERCEPT_CR3_READ);\n\tset_cr_intercept(svm, INTERCEPT_CR4_READ);\n\tset_cr_intercept(svm, INTERCEPT_CR0_WRITE);\n\tset_cr_intercept(svm, INTERCEPT_CR3_WRITE);\n\tset_cr_intercept(svm, INTERCEPT_CR4_WRITE);\n\tif (!kvm_vcpu_apicv_active(&svm->vcpu))\n\t\tset_cr_intercept(svm, INTERCEPT_CR8_WRITE);\n\n\tset_dr_intercepts(svm);\n\n\tset_exception_intercept(svm, PF_VECTOR);\n\tset_exception_intercept(svm, UD_VECTOR);\n\tset_exception_intercept(svm, MC_VECTOR);\n\tset_exception_intercept(svm, AC_VECTOR);\n\tset_exception_intercept(svm, DB_VECTOR);\n\n\tset_intercept(svm, INTERCEPT_INTR);\n\tset_intercept(svm, INTERCEPT_NMI);\n\tset_intercept(svm, INTERCEPT_SMI);\n\tset_intercept(svm, INTERCEPT_SELECTIVE_CR0);\n\tset_intercept(svm, INTERCEPT_RDPMC);\n\tset_intercept(svm, INTERCEPT_CPUID);\n\tset_intercept(svm, INTERCEPT_INVD);\n\tset_intercept(svm, INTERCEPT_HLT);\n\tset_intercept(svm, INTERCEPT_INVLPG);\n\tset_intercept(svm, INTERCEPT_INVLPGA);\n\tset_intercept(svm, INTERCEPT_IOIO_PROT);\n\tset_intercept(svm, INTERCEPT_MSR_PROT);\n\tset_intercept(svm, INTERCEPT_TASK_SWITCH);\n\tset_intercept(svm, INTERCEPT_SHUTDOWN);\n\tset_intercept(svm, INTERCEPT_VMRUN);\n\tset_intercept(svm, INTERCEPT_VMMCALL);\n\tset_intercept(svm, INTERCEPT_VMLOAD);\n\tset_intercept(svm, INTERCEPT_VMSAVE);\n\tset_intercept(svm, INTERCEPT_STGI);\n\tset_intercept(svm, INTERCEPT_CLGI);\n\tset_intercept(svm, INTERCEPT_SKINIT);\n\tset_intercept(svm, INTERCEPT_WBINVD);\n\tset_intercept(svm, INTERCEPT_MONITOR);\n\tset_intercept(svm, INTERCEPT_MWAIT);\n\tset_intercept(svm, INTERCEPT_XSETBV);\n\n\tcontrol->iopm_base_pa = iopm_base;\n\tcontrol->msrpm_base_pa = __pa(svm->msrpm);\n\tcontrol->int_ctl = V_INTR_MASKING_MASK;\n\n\tinit_seg(&save->es);\n\tinit_seg(&save->ss);\n\tinit_seg(&save->ds);\n\tinit_seg(&save->fs);\n\tinit_seg(&save->gs);\n\n\tsave->cs.selector = 0xf000;\n\tsave->cs.base = 0xffff0000;\n\t/* Executable/Readable Code Segment */\n\tsave->cs.attrib = SVM_SELECTOR_READ_MASK | SVM_SELECTOR_P_MASK |\n\t\tSVM_SELECTOR_S_MASK | SVM_SELECTOR_CODE_MASK;\n\tsave->cs.limit = 0xffff;\n\n\tsave->gdtr.limit = 0xffff;\n\tsave->idtr.limit = 0xffff;\n\n\tinit_sys_seg(&save->ldtr, SEG_TYPE_LDT);\n\tinit_sys_seg(&save->tr, SEG_TYPE_BUSY_TSS16);\n\n\tsvm_set_efer(&svm->vcpu, 0);\n\tsave->dr6 = 0xffff0ff0;\n\tkvm_set_rflags(&svm->vcpu, 2);\n\tsave->rip = 0x0000fff0;\n\tsvm->vcpu.arch.regs[VCPU_REGS_RIP] = save->rip;\n\n\t/*\n\t * svm_set_cr0() sets PG and WP and clears NW and CD on save->cr0.\n\t * It also updates the guest-visible cr0 value.\n\t */\n\tsvm_set_cr0(&svm->vcpu, X86_CR0_NW | X86_CR0_CD | X86_CR0_ET);\n\tkvm_mmu_reset_context(&svm->vcpu);\n\n\tsave->cr4 = X86_CR4_PAE;\n\t/* rdx = ?? */\n\n\tif (npt_enabled) {\n\t\t/* Setup VMCB for Nested Paging */\n\t\tcontrol->nested_ctl = 1;\n\t\tclr_intercept(svm, INTERCEPT_INVLPG);\n\t\tclr_exception_intercept(svm, PF_VECTOR);\n\t\tclr_cr_intercept(svm, INTERCEPT_CR3_READ);\n\t\tclr_cr_intercept(svm, INTERCEPT_CR3_WRITE);\n\t\tsave->g_pat = svm->vcpu.arch.pat;\n\t\tsave->cr3 = 0;\n\t\tsave->cr4 = 0;\n\t}\n\tsvm->asid_generation = 0;\n\n\tsvm->nested.vmcb = 0;\n\tsvm->vcpu.arch.hflags = 0;\n\n\tif (boot_cpu_has(X86_FEATURE_PAUSEFILTER)) {\n\t\tcontrol->pause_filter_count = 3000;\n\t\tset_intercept(svm, INTERCEPT_PAUSE);\n\t}\n\n\tif (avic)\n\t\tavic_init_vmcb(svm);\n\n\tmark_all_dirty(svm->vmcb);\n\n\tenable_gif(svm);\n\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define SEG_TYPE_BUSY_TSS16 3",
            "#define SEG_TYPE_LDT 2"
          ],
          "globals_used": [
            "static int nested = true;",
            "static int avic;",
            "static void svm_set_cr0(struct kvm_vcpu *vcpu, unsigned long cr0);",
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);",
            "static unsigned long iopm_base;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define SEG_TYPE_BUSY_TSS16 3\n#define SEG_TYPE_LDT 2\n\nstatic int nested = true;\nstatic int avic;\nstatic void svm_set_cr0(struct kvm_vcpu *vcpu, unsigned long cr0);\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\nstatic unsigned long iopm_base;\n\nstatic void init_vmcb(struct vcpu_svm *svm)\n{\n\tstruct vmcb_control_area *control = &svm->vmcb->control;\n\tstruct vmcb_save_area *save = &svm->vmcb->save;\n\n\tsvm->vcpu.fpu_active = 1;\n\tsvm->vcpu.arch.hflags = 0;\n\n\tset_cr_intercept(svm, INTERCEPT_CR0_READ);\n\tset_cr_intercept(svm, INTERCEPT_CR3_READ);\n\tset_cr_intercept(svm, INTERCEPT_CR4_READ);\n\tset_cr_intercept(svm, INTERCEPT_CR0_WRITE);\n\tset_cr_intercept(svm, INTERCEPT_CR3_WRITE);\n\tset_cr_intercept(svm, INTERCEPT_CR4_WRITE);\n\tif (!kvm_vcpu_apicv_active(&svm->vcpu))\n\t\tset_cr_intercept(svm, INTERCEPT_CR8_WRITE);\n\n\tset_dr_intercepts(svm);\n\n\tset_exception_intercept(svm, PF_VECTOR);\n\tset_exception_intercept(svm, UD_VECTOR);\n\tset_exception_intercept(svm, MC_VECTOR);\n\tset_exception_intercept(svm, AC_VECTOR);\n\tset_exception_intercept(svm, DB_VECTOR);\n\n\tset_intercept(svm, INTERCEPT_INTR);\n\tset_intercept(svm, INTERCEPT_NMI);\n\tset_intercept(svm, INTERCEPT_SMI);\n\tset_intercept(svm, INTERCEPT_SELECTIVE_CR0);\n\tset_intercept(svm, INTERCEPT_RDPMC);\n\tset_intercept(svm, INTERCEPT_CPUID);\n\tset_intercept(svm, INTERCEPT_INVD);\n\tset_intercept(svm, INTERCEPT_HLT);\n\tset_intercept(svm, INTERCEPT_INVLPG);\n\tset_intercept(svm, INTERCEPT_INVLPGA);\n\tset_intercept(svm, INTERCEPT_IOIO_PROT);\n\tset_intercept(svm, INTERCEPT_MSR_PROT);\n\tset_intercept(svm, INTERCEPT_TASK_SWITCH);\n\tset_intercept(svm, INTERCEPT_SHUTDOWN);\n\tset_intercept(svm, INTERCEPT_VMRUN);\n\tset_intercept(svm, INTERCEPT_VMMCALL);\n\tset_intercept(svm, INTERCEPT_VMLOAD);\n\tset_intercept(svm, INTERCEPT_VMSAVE);\n\tset_intercept(svm, INTERCEPT_STGI);\n\tset_intercept(svm, INTERCEPT_CLGI);\n\tset_intercept(svm, INTERCEPT_SKINIT);\n\tset_intercept(svm, INTERCEPT_WBINVD);\n\tset_intercept(svm, INTERCEPT_MONITOR);\n\tset_intercept(svm, INTERCEPT_MWAIT);\n\tset_intercept(svm, INTERCEPT_XSETBV);\n\n\tcontrol->iopm_base_pa = iopm_base;\n\tcontrol->msrpm_base_pa = __pa(svm->msrpm);\n\tcontrol->int_ctl = V_INTR_MASKING_MASK;\n\n\tinit_seg(&save->es);\n\tinit_seg(&save->ss);\n\tinit_seg(&save->ds);\n\tinit_seg(&save->fs);\n\tinit_seg(&save->gs);\n\n\tsave->cs.selector = 0xf000;\n\tsave->cs.base = 0xffff0000;\n\t/* Executable/Readable Code Segment */\n\tsave->cs.attrib = SVM_SELECTOR_READ_MASK | SVM_SELECTOR_P_MASK |\n\t\tSVM_SELECTOR_S_MASK | SVM_SELECTOR_CODE_MASK;\n\tsave->cs.limit = 0xffff;\n\n\tsave->gdtr.limit = 0xffff;\n\tsave->idtr.limit = 0xffff;\n\n\tinit_sys_seg(&save->ldtr, SEG_TYPE_LDT);\n\tinit_sys_seg(&save->tr, SEG_TYPE_BUSY_TSS16);\n\n\tsvm_set_efer(&svm->vcpu, 0);\n\tsave->dr6 = 0xffff0ff0;\n\tkvm_set_rflags(&svm->vcpu, 2);\n\tsave->rip = 0x0000fff0;\n\tsvm->vcpu.arch.regs[VCPU_REGS_RIP] = save->rip;\n\n\t/*\n\t * svm_set_cr0() sets PG and WP and clears NW and CD on save->cr0.\n\t * It also updates the guest-visible cr0 value.\n\t */\n\tsvm_set_cr0(&svm->vcpu, X86_CR0_NW | X86_CR0_CD | X86_CR0_ET);\n\tkvm_mmu_reset_context(&svm->vcpu);\n\n\tsave->cr4 = X86_CR4_PAE;\n\t/* rdx = ?? */\n\n\tif (npt_enabled) {\n\t\t/* Setup VMCB for Nested Paging */\n\t\tcontrol->nested_ctl = 1;\n\t\tclr_intercept(svm, INTERCEPT_INVLPG);\n\t\tclr_exception_intercept(svm, PF_VECTOR);\n\t\tclr_cr_intercept(svm, INTERCEPT_CR3_READ);\n\t\tclr_cr_intercept(svm, INTERCEPT_CR3_WRITE);\n\t\tsave->g_pat = svm->vcpu.arch.pat;\n\t\tsave->cr3 = 0;\n\t\tsave->cr4 = 0;\n\t}\n\tsvm->asid_generation = 0;\n\n\tsvm->nested.vmcb = 0;\n\tsvm->vcpu.arch.hflags = 0;\n\n\tif (boot_cpu_has(X86_FEATURE_PAUSEFILTER)) {\n\t\tcontrol->pause_filter_count = 3000;\n\t\tset_intercept(svm, INTERCEPT_PAUSE);\n\t}\n\n\tif (avic)\n\t\tavic_init_vmcb(svm);\n\n\tmark_all_dirty(svm->vmcb);\n\n\tenable_gif(svm);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_to_pfn",
          "args": [
            "page"
          ],
          "line": 1465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_page",
          "args": [
            "svm->vmcb"
          ],
          "line": 1464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 1463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svm_vcpu_init_msrpm",
          "args": [
            "svm->nested.msrpm"
          ],
          "line": 1461
        },
        "resolved": true,
        "details": {
          "function_name": "svm_vcpu_init_msrpm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "850-862",
          "snippet": "static void svm_vcpu_init_msrpm(u32 *msrpm)\n{\n\tint i;\n\n\tmemset(msrpm, 0xff, PAGE_SIZE * (1 << MSRPM_ALLOC_ORDER));\n\n\tfor (i = 0; direct_access_msrs[i].index != MSR_INVALID; i++) {\n\t\tif (!direct_access_msrs[i].always)\n\t\t\tcontinue;\n\n\t\tset_msr_interception(msrpm, direct_access_msrs[i].index, 1, 1);\n\t}\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define MSR_INVALID\t\t\t0xffffffffU",
            "#define MSRPM_ALLOC_ORDER 1"
          ],
          "globals_used": [
            "static const struct svm_direct_access_msrs {\n\tu32 index;   /* Index of the MSR */\n\tbool always; /* True if intercept is always on */\n} direct_access_msrs[] = {\n\t{ .index = MSR_STAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_IA32_SYSENTER_CS,\t\t.always = true  },\n#ifdef CONFIG_X86_64\n\t{ .index = MSR_GS_BASE,\t\t\t\t.always = true  },\n\t{ .index = MSR_FS_BASE,\t\t\t\t.always = true  },\n\t{ .index = MSR_KERNEL_GS_BASE,\t\t\t.always = true  },\n\t{ .index = MSR_LSTAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_CSTAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_SYSCALL_MASK,\t\t\t.always = true  },\n#endif\n\t{ .index = MSR_IA32_LASTBRANCHFROMIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTBRANCHTOIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTINTFROMIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTINTTOIP,\t\t.always = false },\n\t{ .index = MSR_INVALID,\t\t\t\t.always = false },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define MSR_INVALID\t\t\t0xffffffffU\n#define MSRPM_ALLOC_ORDER 1\n\nstatic const struct svm_direct_access_msrs {\n\tu32 index;   /* Index of the MSR */\n\tbool always; /* True if intercept is always on */\n} direct_access_msrs[] = {\n\t{ .index = MSR_STAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_IA32_SYSENTER_CS,\t\t.always = true  },\n#ifdef CONFIG_X86_64\n\t{ .index = MSR_GS_BASE,\t\t\t\t.always = true  },\n\t{ .index = MSR_FS_BASE,\t\t\t\t.always = true  },\n\t{ .index = MSR_KERNEL_GS_BASE,\t\t\t.always = true  },\n\t{ .index = MSR_LSTAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_CSTAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_SYSCALL_MASK,\t\t\t.always = true  },\n#endif\n\t{ .index = MSR_IA32_LASTBRANCHFROMIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTBRANCHTOIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTINTFROMIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTINTTOIP,\t\t.always = false },\n\t{ .index = MSR_INVALID,\t\t\t\t.always = false },\n};\n\nstatic void svm_vcpu_init_msrpm(u32 *msrpm)\n{\n\tint i;\n\n\tmemset(msrpm, 0xff, PAGE_SIZE * (1 << MSRPM_ALLOC_ORDER));\n\n\tfor (i = 0; direct_access_msrs[i].index != MSR_INVALID; i++) {\n\t\tif (!direct_access_msrs[i].always)\n\t\t\tcontinue;\n\n\t\tset_msr_interception(msrpm, direct_access_msrs[i].index, 1, 1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "nested_msrpm_pages"
          ],
          "line": 1460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "msrpm_pages"
          ],
          "line": 1457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "hsave_page"
          ],
          "line": 1455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "avic_init_backing_page",
          "args": [
            "&svm->vcpu"
          ],
          "line": 1445
        },
        "resolved": true,
        "details": {
          "function_name": "avic_init_backing_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "1243-1276",
          "snippet": "static int avic_init_backing_page(struct kvm_vcpu *vcpu)\n{\n\tint ret;\n\tu64 *entry, new_entry;\n\tint id = vcpu->vcpu_id;\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tret = avic_init_access_page(vcpu);\n\tif (ret)\n\t\treturn ret;\n\n\tif (id >= AVIC_MAX_PHYSICAL_ID_COUNT)\n\t\treturn -EINVAL;\n\n\tif (!svm->vcpu.arch.apic->regs)\n\t\treturn -EINVAL;\n\n\tsvm->avic_backing_page = virt_to_page(svm->vcpu.arch.apic->regs);\n\n\t/* Setting AVIC backing page address in the phy APIC ID table */\n\tentry = avic_get_physical_id_entry(vcpu, id);\n\tif (!entry)\n\t\treturn -EINVAL;\n\n\tnew_entry = READ_ONCE(*entry);\n\tnew_entry = (page_to_phys(svm->avic_backing_page) &\n\t\t     AVIC_PHYSICAL_ID_ENTRY_BACKING_PAGE_MASK) |\n\t\t     AVIC_PHYSICAL_ID_ENTRY_VALID_MASK;\n\tWRITE_ONCE(*entry, new_entry);\n\n\tsvm->avic_physical_id_cache = entry;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define AVIC_PHYSICAL_ID_ENTRY_VALID_MASK\t\t(1ULL << 63)",
            "#define AVIC_PHYSICAL_ID_ENTRY_BACKING_PAGE_MASK\t(0xFFFFFFFFFFULL << 12)",
            "#define AVIC_MAX_PHYSICAL_ID_COUNT\t255"
          ],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define AVIC_PHYSICAL_ID_ENTRY_VALID_MASK\t\t(1ULL << 63)\n#define AVIC_PHYSICAL_ID_ENTRY_BACKING_PAGE_MASK\t(0xFFFFFFFFFFULL << 12)\n#define AVIC_MAX_PHYSICAL_ID_COUNT\t255\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic int avic_init_backing_page(struct kvm_vcpu *vcpu)\n{\n\tint ret;\n\tu64 *entry, new_entry;\n\tint id = vcpu->vcpu_id;\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tret = avic_init_access_page(vcpu);\n\tif (ret)\n\t\treturn ret;\n\n\tif (id >= AVIC_MAX_PHYSICAL_ID_COUNT)\n\t\treturn -EINVAL;\n\n\tif (!svm->vcpu.arch.apic->regs)\n\t\treturn -EINVAL;\n\n\tsvm->avic_backing_page = virt_to_page(svm->vcpu.arch.apic->regs);\n\n\t/* Setting AVIC backing page address in the phy APIC ID table */\n\tentry = avic_get_physical_id_entry(vcpu, id);\n\tif (!entry)\n\t\treturn -EINVAL;\n\n\tnew_entry = READ_ONCE(*entry);\n\tnew_entry = (page_to_phys(svm->avic_backing_page) &\n\t\t     AVIC_PHYSICAL_ID_ENTRY_BACKING_PAGE_MASK) |\n\t\t     AVIC_PHYSICAL_ID_ENTRY_VALID_MASK;\n\tWRITE_ONCE(*entry, new_entry);\n\n\tsvm->avic_physical_id_cache = entry;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_page",
          "args": [
            "GFP_KERNEL"
          ],
          "line": 1440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_pages",
          "args": [
            "GFP_KERNEL",
            "MSRPM_ALLOC_ORDER"
          ],
          "line": 1436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_pages",
          "args": [
            "GFP_KERNEL",
            "MSRPM_ALLOC_ORDER"
          ],
          "line": 1432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_page",
          "args": [
            "GFP_KERNEL"
          ],
          "line": 1428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_init",
          "args": [
            "&svm->vcpu",
            "kvm",
            "id"
          ],
          "line": 1423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_zalloc",
          "args": [
            "kvm_vcpu_cache",
            "GFP_KERNEL"
          ],
          "line": 1417
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define MSRPM_ALLOC_ORDER 1\n\nstatic int nested = true;\nstatic int avic;\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic struct kvm_vcpu *svm_create_vcpu(struct kvm *kvm, unsigned int id)\n{\n\tstruct vcpu_svm *svm;\n\tstruct page *page;\n\tstruct page *msrpm_pages;\n\tstruct page *hsave_page;\n\tstruct page *nested_msrpm_pages;\n\tint err;\n\n\tsvm = kmem_cache_zalloc(kvm_vcpu_cache, GFP_KERNEL);\n\tif (!svm) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\terr = kvm_vcpu_init(&svm->vcpu, kvm, id);\n\tif (err)\n\t\tgoto free_svm;\n\n\terr = -ENOMEM;\n\tpage = alloc_page(GFP_KERNEL);\n\tif (!page)\n\t\tgoto uninit;\n\n\tmsrpm_pages = alloc_pages(GFP_KERNEL, MSRPM_ALLOC_ORDER);\n\tif (!msrpm_pages)\n\t\tgoto free_page1;\n\n\tnested_msrpm_pages = alloc_pages(GFP_KERNEL, MSRPM_ALLOC_ORDER);\n\tif (!nested_msrpm_pages)\n\t\tgoto free_page2;\n\n\thsave_page = alloc_page(GFP_KERNEL);\n\tif (!hsave_page)\n\t\tgoto free_page3;\n\n\tif (avic) {\n\t\terr = avic_init_backing_page(&svm->vcpu);\n\t\tif (err)\n\t\t\tgoto free_page4;\n\t}\n\n\t/* We initialize this flag to true to make sure that the is_running\n\t * bit would be set the first time the vcpu is loaded.\n\t */\n\tsvm->avic_is_running = true;\n\n\tsvm->nested.hsave = page_address(hsave_page);\n\n\tsvm->msrpm = page_address(msrpm_pages);\n\tsvm_vcpu_init_msrpm(svm->msrpm);\n\n\tsvm->nested.msrpm = page_address(nested_msrpm_pages);\n\tsvm_vcpu_init_msrpm(svm->nested.msrpm);\n\n\tsvm->vmcb = page_address(page);\n\tclear_page(svm->vmcb);\n\tsvm->vmcb_pa = page_to_pfn(page) << PAGE_SHIFT;\n\tsvm->asid_generation = 0;\n\tinit_vmcb(svm);\n\n\tsvm_init_osvw(&svm->vcpu);\n\n\treturn &svm->vcpu;\n\nfree_page4:\n\t__free_page(hsave_page);\nfree_page3:\n\t__free_pages(nested_msrpm_pages, MSRPM_ALLOC_ORDER);\nfree_page2:\n\t__free_pages(msrpm_pages, MSRPM_ALLOC_ORDER);\nfree_page1:\n\t__free_page(page);\nuninit:\n\tkvm_vcpu_uninit(&svm->vcpu);\nfree_svm:\n\tkmem_cache_free(kvm_vcpu_cache, svm);\nout:\n\treturn ERR_PTR(err);\n}"
  },
  {
    "function_name": "svm_vcpu_reset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "1387-1406",
    "snippet": "static void svm_vcpu_reset(struct kvm_vcpu *vcpu, bool init_event)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tu32 dummy;\n\tu32 eax = 1;\n\n\tif (!init_event) {\n\t\tsvm->vcpu.arch.apic_base = APIC_DEFAULT_PHYS_BASE |\n\t\t\t\t\t   MSR_IA32_APICBASE_ENABLE;\n\t\tif (kvm_vcpu_is_reset_bsp(&svm->vcpu))\n\t\t\tsvm->vcpu.arch.apic_base |= MSR_IA32_APICBASE_BSP;\n\t}\n\tinit_vmcb(svm);\n\n\tkvm_cpuid(vcpu, &eax, &dummy, &dummy, &dummy);\n\tkvm_register_write(vcpu, VCPU_REGS_RDX, eax);\n\n\tif (kvm_vcpu_apicv_active(vcpu) && !init_event)\n\t\tavic_update_vapic_bar(svm, APIC_DEFAULT_PHYS_BASE);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "avic_update_vapic_bar",
          "args": [
            "svm",
            "APIC_DEFAULT_PHYS_BASE"
          ],
          "line": 1405
        },
        "resolved": true,
        "details": {
          "function_name": "avic_update_vapic_bar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "299-303",
          "snippet": "static inline void avic_update_vapic_bar(struct vcpu_svm *svm, u64 data)\n{\n\tsvm->vmcb->control.avic_vapic_bar = data & VMCB_AVIC_APIC_BAR_MASK;\n\tmark_dirty(svm->vmcb, VMCB_AVIC);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define VMCB_AVIC_APIC_BAR_MASK\t\t0xFFFFFFFFFF000ULL"
          ],
          "globals_used": [
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define VMCB_AVIC_APIC_BAR_MASK\t\t0xFFFFFFFFFF000ULL\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic inline void avic_update_vapic_bar(struct vcpu_svm *svm, u64 data)\n{\n\tsvm->vmcb->control.avic_vapic_bar = data & VMCB_AVIC_APIC_BAR_MASK;\n\tmark_dirty(svm->vmcb, VMCB_AVIC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_apicv_active",
          "args": [
            "vcpu"
          ],
          "line": 1404
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_vcpu_apicv_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.h",
          "lines": "181-184",
          "snippet": "static inline bool kvm_vcpu_apicv_active(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.apic && vcpu->arch.apicv_active;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline bool kvm_vcpu_apicv_active(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.apic && vcpu->arch.apicv_active;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_register_write",
          "args": [
            "vcpu",
            "VCPU_REGS_RDX",
            "eax"
          ],
          "line": 1402
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_register_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "18-25",
          "snippet": "static inline void kvm_register_write(struct kvm_vcpu *vcpu,\n\t\t\t\t      enum kvm_reg reg,\n\t\t\t\t      unsigned long val)\n{\n\tvcpu->arch.regs[reg] = val;\n\t__set_bit(reg, (unsigned long *)&vcpu->arch.regs_dirty);\n\t__set_bit(reg, (unsigned long *)&vcpu->arch.regs_avail);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void kvm_register_write(struct kvm_vcpu *vcpu,\n\t\t\t\t      enum kvm_reg reg,\n\t\t\t\t      unsigned long val)\n{\n\tvcpu->arch.regs[reg] = val;\n\t__set_bit(reg, (unsigned long *)&vcpu->arch.regs_dirty);\n\t__set_bit(reg, (unsigned long *)&vcpu->arch.regs_avail);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_cpuid",
          "args": [
            "vcpu",
            "&eax",
            "&dummy",
            "&dummy",
            "&dummy"
          ],
          "line": 1401
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_cpuid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/cpuid.c",
          "lines": "836-860",
          "snippet": "void kvm_cpuid(struct kvm_vcpu *vcpu, u32 *eax, u32 *ebx, u32 *ecx, u32 *edx)\n{\n\tu32 function = *eax, index = *ecx;\n\tstruct kvm_cpuid_entry2 *best;\n\n\tbest = kvm_find_cpuid_entry(vcpu, function, index);\n\n\tif (!best)\n\t\tbest = check_cpuid_limit(vcpu, function, index);\n\n\t/*\n\t * Perfmon not yet supported for L2 guest.\n\t */\n\tif (is_guest_mode(vcpu) && function == 0xa)\n\t\tbest = NULL;\n\n\tif (best) {\n\t\t*eax = best->eax;\n\t\t*ebx = best->ebx;\n\t\t*ecx = best->ecx;\n\t\t*edx = best->edx;\n\t} else\n\t\t*eax = *ebx = *ecx = *edx = 0;\n\ttrace_kvm_cpuid(function, *eax, *ebx, *ecx, *edx);\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"trace.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"cpuid.h\"",
            "#include <asm/fpu/xstate.h>",
            "#include <asm/user.h>",
            "#include <asm/fpu/internal.h> /* For use_eager_fpu.  Ugh! */",
            "#include <linux/uaccess.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"trace.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include <asm/fpu/xstate.h>\n#include <asm/user.h>\n#include <asm/fpu/internal.h> /* For use_eager_fpu.  Ugh! */\n#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n\nvoid kvm_cpuid(struct kvm_vcpu *vcpu, u32 *eax, u32 *ebx, u32 *ecx, u32 *edx)\n{\n\tu32 function = *eax, index = *ecx;\n\tstruct kvm_cpuid_entry2 *best;\n\n\tbest = kvm_find_cpuid_entry(vcpu, function, index);\n\n\tif (!best)\n\t\tbest = check_cpuid_limit(vcpu, function, index);\n\n\t/*\n\t * Perfmon not yet supported for L2 guest.\n\t */\n\tif (is_guest_mode(vcpu) && function == 0xa)\n\t\tbest = NULL;\n\n\tif (best) {\n\t\t*eax = best->eax;\n\t\t*ebx = best->ebx;\n\t\t*ecx = best->ecx;\n\t\t*edx = best->edx;\n\t} else\n\t\t*eax = *ebx = *ecx = *edx = 0;\n\ttrace_kvm_cpuid(function, *eax, *ebx, *ecx, *edx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_vmcb",
          "args": [
            "svm"
          ],
          "line": 1399
        },
        "resolved": true,
        "details": {
          "function_name": "init_vmcb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "1083-1201",
          "snippet": "static void init_vmcb(struct vcpu_svm *svm)\n{\n\tstruct vmcb_control_area *control = &svm->vmcb->control;\n\tstruct vmcb_save_area *save = &svm->vmcb->save;\n\n\tsvm->vcpu.fpu_active = 1;\n\tsvm->vcpu.arch.hflags = 0;\n\n\tset_cr_intercept(svm, INTERCEPT_CR0_READ);\n\tset_cr_intercept(svm, INTERCEPT_CR3_READ);\n\tset_cr_intercept(svm, INTERCEPT_CR4_READ);\n\tset_cr_intercept(svm, INTERCEPT_CR0_WRITE);\n\tset_cr_intercept(svm, INTERCEPT_CR3_WRITE);\n\tset_cr_intercept(svm, INTERCEPT_CR4_WRITE);\n\tif (!kvm_vcpu_apicv_active(&svm->vcpu))\n\t\tset_cr_intercept(svm, INTERCEPT_CR8_WRITE);\n\n\tset_dr_intercepts(svm);\n\n\tset_exception_intercept(svm, PF_VECTOR);\n\tset_exception_intercept(svm, UD_VECTOR);\n\tset_exception_intercept(svm, MC_VECTOR);\n\tset_exception_intercept(svm, AC_VECTOR);\n\tset_exception_intercept(svm, DB_VECTOR);\n\n\tset_intercept(svm, INTERCEPT_INTR);\n\tset_intercept(svm, INTERCEPT_NMI);\n\tset_intercept(svm, INTERCEPT_SMI);\n\tset_intercept(svm, INTERCEPT_SELECTIVE_CR0);\n\tset_intercept(svm, INTERCEPT_RDPMC);\n\tset_intercept(svm, INTERCEPT_CPUID);\n\tset_intercept(svm, INTERCEPT_INVD);\n\tset_intercept(svm, INTERCEPT_HLT);\n\tset_intercept(svm, INTERCEPT_INVLPG);\n\tset_intercept(svm, INTERCEPT_INVLPGA);\n\tset_intercept(svm, INTERCEPT_IOIO_PROT);\n\tset_intercept(svm, INTERCEPT_MSR_PROT);\n\tset_intercept(svm, INTERCEPT_TASK_SWITCH);\n\tset_intercept(svm, INTERCEPT_SHUTDOWN);\n\tset_intercept(svm, INTERCEPT_VMRUN);\n\tset_intercept(svm, INTERCEPT_VMMCALL);\n\tset_intercept(svm, INTERCEPT_VMLOAD);\n\tset_intercept(svm, INTERCEPT_VMSAVE);\n\tset_intercept(svm, INTERCEPT_STGI);\n\tset_intercept(svm, INTERCEPT_CLGI);\n\tset_intercept(svm, INTERCEPT_SKINIT);\n\tset_intercept(svm, INTERCEPT_WBINVD);\n\tset_intercept(svm, INTERCEPT_MONITOR);\n\tset_intercept(svm, INTERCEPT_MWAIT);\n\tset_intercept(svm, INTERCEPT_XSETBV);\n\n\tcontrol->iopm_base_pa = iopm_base;\n\tcontrol->msrpm_base_pa = __pa(svm->msrpm);\n\tcontrol->int_ctl = V_INTR_MASKING_MASK;\n\n\tinit_seg(&save->es);\n\tinit_seg(&save->ss);\n\tinit_seg(&save->ds);\n\tinit_seg(&save->fs);\n\tinit_seg(&save->gs);\n\n\tsave->cs.selector = 0xf000;\n\tsave->cs.base = 0xffff0000;\n\t/* Executable/Readable Code Segment */\n\tsave->cs.attrib = SVM_SELECTOR_READ_MASK | SVM_SELECTOR_P_MASK |\n\t\tSVM_SELECTOR_S_MASK | SVM_SELECTOR_CODE_MASK;\n\tsave->cs.limit = 0xffff;\n\n\tsave->gdtr.limit = 0xffff;\n\tsave->idtr.limit = 0xffff;\n\n\tinit_sys_seg(&save->ldtr, SEG_TYPE_LDT);\n\tinit_sys_seg(&save->tr, SEG_TYPE_BUSY_TSS16);\n\n\tsvm_set_efer(&svm->vcpu, 0);\n\tsave->dr6 = 0xffff0ff0;\n\tkvm_set_rflags(&svm->vcpu, 2);\n\tsave->rip = 0x0000fff0;\n\tsvm->vcpu.arch.regs[VCPU_REGS_RIP] = save->rip;\n\n\t/*\n\t * svm_set_cr0() sets PG and WP and clears NW and CD on save->cr0.\n\t * It also updates the guest-visible cr0 value.\n\t */\n\tsvm_set_cr0(&svm->vcpu, X86_CR0_NW | X86_CR0_CD | X86_CR0_ET);\n\tkvm_mmu_reset_context(&svm->vcpu);\n\n\tsave->cr4 = X86_CR4_PAE;\n\t/* rdx = ?? */\n\n\tif (npt_enabled) {\n\t\t/* Setup VMCB for Nested Paging */\n\t\tcontrol->nested_ctl = 1;\n\t\tclr_intercept(svm, INTERCEPT_INVLPG);\n\t\tclr_exception_intercept(svm, PF_VECTOR);\n\t\tclr_cr_intercept(svm, INTERCEPT_CR3_READ);\n\t\tclr_cr_intercept(svm, INTERCEPT_CR3_WRITE);\n\t\tsave->g_pat = svm->vcpu.arch.pat;\n\t\tsave->cr3 = 0;\n\t\tsave->cr4 = 0;\n\t}\n\tsvm->asid_generation = 0;\n\n\tsvm->nested.vmcb = 0;\n\tsvm->vcpu.arch.hflags = 0;\n\n\tif (boot_cpu_has(X86_FEATURE_PAUSEFILTER)) {\n\t\tcontrol->pause_filter_count = 3000;\n\t\tset_intercept(svm, INTERCEPT_PAUSE);\n\t}\n\n\tif (avic)\n\t\tavic_init_vmcb(svm);\n\n\tmark_all_dirty(svm->vmcb);\n\n\tenable_gif(svm);\n\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define SEG_TYPE_BUSY_TSS16 3",
            "#define SEG_TYPE_LDT 2"
          ],
          "globals_used": [
            "static int nested = true;",
            "static int avic;",
            "static void svm_set_cr0(struct kvm_vcpu *vcpu, unsigned long cr0);",
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);",
            "static unsigned long iopm_base;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define SEG_TYPE_BUSY_TSS16 3\n#define SEG_TYPE_LDT 2\n\nstatic int nested = true;\nstatic int avic;\nstatic void svm_set_cr0(struct kvm_vcpu *vcpu, unsigned long cr0);\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\nstatic unsigned long iopm_base;\n\nstatic void init_vmcb(struct vcpu_svm *svm)\n{\n\tstruct vmcb_control_area *control = &svm->vmcb->control;\n\tstruct vmcb_save_area *save = &svm->vmcb->save;\n\n\tsvm->vcpu.fpu_active = 1;\n\tsvm->vcpu.arch.hflags = 0;\n\n\tset_cr_intercept(svm, INTERCEPT_CR0_READ);\n\tset_cr_intercept(svm, INTERCEPT_CR3_READ);\n\tset_cr_intercept(svm, INTERCEPT_CR4_READ);\n\tset_cr_intercept(svm, INTERCEPT_CR0_WRITE);\n\tset_cr_intercept(svm, INTERCEPT_CR3_WRITE);\n\tset_cr_intercept(svm, INTERCEPT_CR4_WRITE);\n\tif (!kvm_vcpu_apicv_active(&svm->vcpu))\n\t\tset_cr_intercept(svm, INTERCEPT_CR8_WRITE);\n\n\tset_dr_intercepts(svm);\n\n\tset_exception_intercept(svm, PF_VECTOR);\n\tset_exception_intercept(svm, UD_VECTOR);\n\tset_exception_intercept(svm, MC_VECTOR);\n\tset_exception_intercept(svm, AC_VECTOR);\n\tset_exception_intercept(svm, DB_VECTOR);\n\n\tset_intercept(svm, INTERCEPT_INTR);\n\tset_intercept(svm, INTERCEPT_NMI);\n\tset_intercept(svm, INTERCEPT_SMI);\n\tset_intercept(svm, INTERCEPT_SELECTIVE_CR0);\n\tset_intercept(svm, INTERCEPT_RDPMC);\n\tset_intercept(svm, INTERCEPT_CPUID);\n\tset_intercept(svm, INTERCEPT_INVD);\n\tset_intercept(svm, INTERCEPT_HLT);\n\tset_intercept(svm, INTERCEPT_INVLPG);\n\tset_intercept(svm, INTERCEPT_INVLPGA);\n\tset_intercept(svm, INTERCEPT_IOIO_PROT);\n\tset_intercept(svm, INTERCEPT_MSR_PROT);\n\tset_intercept(svm, INTERCEPT_TASK_SWITCH);\n\tset_intercept(svm, INTERCEPT_SHUTDOWN);\n\tset_intercept(svm, INTERCEPT_VMRUN);\n\tset_intercept(svm, INTERCEPT_VMMCALL);\n\tset_intercept(svm, INTERCEPT_VMLOAD);\n\tset_intercept(svm, INTERCEPT_VMSAVE);\n\tset_intercept(svm, INTERCEPT_STGI);\n\tset_intercept(svm, INTERCEPT_CLGI);\n\tset_intercept(svm, INTERCEPT_SKINIT);\n\tset_intercept(svm, INTERCEPT_WBINVD);\n\tset_intercept(svm, INTERCEPT_MONITOR);\n\tset_intercept(svm, INTERCEPT_MWAIT);\n\tset_intercept(svm, INTERCEPT_XSETBV);\n\n\tcontrol->iopm_base_pa = iopm_base;\n\tcontrol->msrpm_base_pa = __pa(svm->msrpm);\n\tcontrol->int_ctl = V_INTR_MASKING_MASK;\n\n\tinit_seg(&save->es);\n\tinit_seg(&save->ss);\n\tinit_seg(&save->ds);\n\tinit_seg(&save->fs);\n\tinit_seg(&save->gs);\n\n\tsave->cs.selector = 0xf000;\n\tsave->cs.base = 0xffff0000;\n\t/* Executable/Readable Code Segment */\n\tsave->cs.attrib = SVM_SELECTOR_READ_MASK | SVM_SELECTOR_P_MASK |\n\t\tSVM_SELECTOR_S_MASK | SVM_SELECTOR_CODE_MASK;\n\tsave->cs.limit = 0xffff;\n\n\tsave->gdtr.limit = 0xffff;\n\tsave->idtr.limit = 0xffff;\n\n\tinit_sys_seg(&save->ldtr, SEG_TYPE_LDT);\n\tinit_sys_seg(&save->tr, SEG_TYPE_BUSY_TSS16);\n\n\tsvm_set_efer(&svm->vcpu, 0);\n\tsave->dr6 = 0xffff0ff0;\n\tkvm_set_rflags(&svm->vcpu, 2);\n\tsave->rip = 0x0000fff0;\n\tsvm->vcpu.arch.regs[VCPU_REGS_RIP] = save->rip;\n\n\t/*\n\t * svm_set_cr0() sets PG and WP and clears NW and CD on save->cr0.\n\t * It also updates the guest-visible cr0 value.\n\t */\n\tsvm_set_cr0(&svm->vcpu, X86_CR0_NW | X86_CR0_CD | X86_CR0_ET);\n\tkvm_mmu_reset_context(&svm->vcpu);\n\n\tsave->cr4 = X86_CR4_PAE;\n\t/* rdx = ?? */\n\n\tif (npt_enabled) {\n\t\t/* Setup VMCB for Nested Paging */\n\t\tcontrol->nested_ctl = 1;\n\t\tclr_intercept(svm, INTERCEPT_INVLPG);\n\t\tclr_exception_intercept(svm, PF_VECTOR);\n\t\tclr_cr_intercept(svm, INTERCEPT_CR3_READ);\n\t\tclr_cr_intercept(svm, INTERCEPT_CR3_WRITE);\n\t\tsave->g_pat = svm->vcpu.arch.pat;\n\t\tsave->cr3 = 0;\n\t\tsave->cr4 = 0;\n\t}\n\tsvm->asid_generation = 0;\n\n\tsvm->nested.vmcb = 0;\n\tsvm->vcpu.arch.hflags = 0;\n\n\tif (boot_cpu_has(X86_FEATURE_PAUSEFILTER)) {\n\t\tcontrol->pause_filter_count = 3000;\n\t\tset_intercept(svm, INTERCEPT_PAUSE);\n\t}\n\n\tif (avic)\n\t\tavic_init_vmcb(svm);\n\n\tmark_all_dirty(svm->vmcb);\n\n\tenable_gif(svm);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_is_reset_bsp",
          "args": [
            "&svm->vcpu"
          ],
          "line": 1396
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_vcpu_is_reset_bsp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "7607-7610",
          "snippet": "bool kvm_vcpu_is_reset_bsp(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->kvm->arch.bsp_vcpu_id == vcpu->vcpu_id;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nbool kvm_vcpu_is_reset_bsp(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->kvm->arch.bsp_vcpu_id == vcpu->vcpu_id;\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 1389
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "294-297",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic void svm_vcpu_reset(struct kvm_vcpu *vcpu, bool init_event)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tu32 dummy;\n\tu32 eax = 1;\n\n\tif (!init_event) {\n\t\tsvm->vcpu.arch.apic_base = APIC_DEFAULT_PHYS_BASE |\n\t\t\t\t\t   MSR_IA32_APICBASE_ENABLE;\n\t\tif (kvm_vcpu_is_reset_bsp(&svm->vcpu))\n\t\t\tsvm->vcpu.arch.apic_base |= MSR_IA32_APICBASE_BSP;\n\t}\n\tinit_vmcb(svm);\n\n\tkvm_cpuid(vcpu, &eax, &dummy, &dummy, &dummy);\n\tkvm_register_write(vcpu, VCPU_REGS_RDX, eax);\n\n\tif (kvm_vcpu_apicv_active(vcpu) && !init_event)\n\t\tavic_update_vapic_bar(svm, APIC_DEFAULT_PHYS_BASE);\n}"
  },
  {
    "function_name": "avic_vcpu_put",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "1374-1385",
    "snippet": "static void avic_vcpu_put(struct kvm_vcpu *vcpu)\n{\n\tu64 entry;\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (!kvm_vcpu_apicv_active(vcpu))\n\t\treturn;\n\n\tentry = READ_ONCE(*(svm->avic_physical_id_cache));\n\tentry &= ~AVIC_PHYSICAL_ID_ENTRY_IS_RUNNING_MASK;\n\tWRITE_ONCE(*(svm->avic_physical_id_cache), entry);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define AVIC_PHYSICAL_ID_ENTRY_IS_RUNNING_MASK\t\t(1ULL << 62)"
    ],
    "globals_used": [
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "*(svm->avic_physical_id_cache)",
            "entry"
          ],
          "line": 1384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "*(svm->avic_physical_id_cache)"
          ],
          "line": 1382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_apicv_active",
          "args": [
            "vcpu"
          ],
          "line": 1379
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_vcpu_apicv_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.h",
          "lines": "181-184",
          "snippet": "static inline bool kvm_vcpu_apicv_active(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.apic && vcpu->arch.apicv_active;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline bool kvm_vcpu_apicv_active(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.apic && vcpu->arch.apicv_active;\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 1377
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "294-297",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define AVIC_PHYSICAL_ID_ENTRY_IS_RUNNING_MASK\t\t(1ULL << 62)\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic void avic_vcpu_put(struct kvm_vcpu *vcpu)\n{\n\tu64 entry;\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (!kvm_vcpu_apicv_active(vcpu))\n\t\treturn;\n\n\tentry = READ_ONCE(*(svm->avic_physical_id_cache));\n\tentry &= ~AVIC_PHYSICAL_ID_ENTRY_IS_RUNNING_MASK;\n\tWRITE_ONCE(*(svm->avic_physical_id_cache), entry);\n}"
  },
  {
    "function_name": "avic_vcpu_load",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "1348-1372",
    "snippet": "static void avic_vcpu_load(struct kvm_vcpu *vcpu, int cpu)\n{\n\tu64 entry;\n\t/* ID = 0xff (broadcast), ID > 0xff (reserved) */\n\tint h_physical_id = __default_cpu_present_to_apicid(cpu);\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (!kvm_vcpu_apicv_active(vcpu))\n\t\treturn;\n\n\tif (WARN_ON(h_physical_id >= AVIC_MAX_PHYSICAL_ID_COUNT))\n\t\treturn;\n\n\tentry = READ_ONCE(*(svm->avic_physical_id_cache));\n\tWARN_ON(entry & AVIC_PHYSICAL_ID_ENTRY_IS_RUNNING_MASK);\n\n\tentry &= ~AVIC_PHYSICAL_ID_ENTRY_HOST_PHYSICAL_ID_MASK;\n\tentry |= (h_physical_id & AVIC_PHYSICAL_ID_ENTRY_HOST_PHYSICAL_ID_MASK);\n\n\tentry &= ~AVIC_PHYSICAL_ID_ENTRY_IS_RUNNING_MASK;\n\tif (svm->avic_is_running)\n\t\tentry |= AVIC_PHYSICAL_ID_ENTRY_IS_RUNNING_MASK;\n\n\tWRITE_ONCE(*(svm->avic_physical_id_cache), entry);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define AVIC_PHYSICAL_ID_ENTRY_IS_RUNNING_MASK\t\t(1ULL << 62)",
      "#define AVIC_PHYSICAL_ID_ENTRY_HOST_PHYSICAL_ID_MASK\t(0xFFULL)",
      "#define AVIC_MAX_PHYSICAL_ID_COUNT\t255"
    ],
    "globals_used": [
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "*(svm->avic_physical_id_cache)",
            "entry"
          ],
          "line": 1371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "entry & AVIC_PHYSICAL_ID_ENTRY_IS_RUNNING_MASK"
          ],
          "line": 1362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "*(svm->avic_physical_id_cache)"
          ],
          "line": 1361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "h_physical_id >= AVIC_MAX_PHYSICAL_ID_COUNT"
          ],
          "line": 1358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_apicv_active",
          "args": [
            "vcpu"
          ],
          "line": 1355
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_vcpu_apicv_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.h",
          "lines": "181-184",
          "snippet": "static inline bool kvm_vcpu_apicv_active(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.apic && vcpu->arch.apicv_active;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline bool kvm_vcpu_apicv_active(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.apic && vcpu->arch.apicv_active;\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 1353
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "294-297",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__default_cpu_present_to_apicid",
          "args": [
            "cpu"
          ],
          "line": 1352
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define AVIC_PHYSICAL_ID_ENTRY_IS_RUNNING_MASK\t\t(1ULL << 62)\n#define AVIC_PHYSICAL_ID_ENTRY_HOST_PHYSICAL_ID_MASK\t(0xFFULL)\n#define AVIC_MAX_PHYSICAL_ID_COUNT\t255\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic void avic_vcpu_load(struct kvm_vcpu *vcpu, int cpu)\n{\n\tu64 entry;\n\t/* ID = 0xff (broadcast), ID > 0xff (reserved) */\n\tint h_physical_id = __default_cpu_present_to_apicid(cpu);\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (!kvm_vcpu_apicv_active(vcpu))\n\t\treturn;\n\n\tif (WARN_ON(h_physical_id >= AVIC_MAX_PHYSICAL_ID_COUNT))\n\t\treturn;\n\n\tentry = READ_ONCE(*(svm->avic_physical_id_cache));\n\tWARN_ON(entry & AVIC_PHYSICAL_ID_ENTRY_IS_RUNNING_MASK);\n\n\tentry &= ~AVIC_PHYSICAL_ID_ENTRY_HOST_PHYSICAL_ID_MASK;\n\tentry |= (h_physical_id & AVIC_PHYSICAL_ID_ENTRY_HOST_PHYSICAL_ID_MASK);\n\n\tentry &= ~AVIC_PHYSICAL_ID_ENTRY_IS_RUNNING_MASK;\n\tif (svm->avic_is_running)\n\t\tentry |= AVIC_PHYSICAL_ID_ENTRY_IS_RUNNING_MASK;\n\n\tWRITE_ONCE(*(svm->avic_physical_id_cache), entry);\n}"
  },
  {
    "function_name": "avic_set_running",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "1324-1346",
    "snippet": "static void avic_set_running(struct kvm_vcpu *vcpu, bool is_run)\n{\n\tu64 entry;\n\tint h_physical_id = __default_cpu_present_to_apicid(vcpu->cpu);\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (!kvm_vcpu_apicv_active(vcpu))\n\t\treturn;\n\n\tsvm->avic_is_running = is_run;\n\n\t/* ID = 0xff (broadcast), ID > 0xff (reserved) */\n\tif (WARN_ON(h_physical_id >= AVIC_MAX_PHYSICAL_ID_COUNT))\n\t\treturn;\n\n\tentry = READ_ONCE(*(svm->avic_physical_id_cache));\n\tWARN_ON(is_run == !!(entry & AVIC_PHYSICAL_ID_ENTRY_IS_RUNNING_MASK));\n\n\tentry &= ~AVIC_PHYSICAL_ID_ENTRY_IS_RUNNING_MASK;\n\tif (is_run)\n\t\tentry |= AVIC_PHYSICAL_ID_ENTRY_IS_RUNNING_MASK;\n\tWRITE_ONCE(*(svm->avic_physical_id_cache), entry);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define AVIC_PHYSICAL_ID_ENTRY_IS_RUNNING_MASK\t\t(1ULL << 62)",
      "#define AVIC_MAX_PHYSICAL_ID_COUNT\t255"
    ],
    "globals_used": [
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "*(svm->avic_physical_id_cache)",
            "entry"
          ],
          "line": 1345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "is_run == !!(entry & AVIC_PHYSICAL_ID_ENTRY_IS_RUNNING_MASK)"
          ],
          "line": 1340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "*(svm->avic_physical_id_cache)"
          ],
          "line": 1339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "h_physical_id >= AVIC_MAX_PHYSICAL_ID_COUNT"
          ],
          "line": 1336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_apicv_active",
          "args": [
            "vcpu"
          ],
          "line": 1330
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_vcpu_apicv_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.h",
          "lines": "181-184",
          "snippet": "static inline bool kvm_vcpu_apicv_active(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.apic && vcpu->arch.apicv_active;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline bool kvm_vcpu_apicv_active(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.apic && vcpu->arch.apicv_active;\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 1328
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "294-297",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__default_cpu_present_to_apicid",
          "args": [
            "vcpu->cpu"
          ],
          "line": 1327
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define AVIC_PHYSICAL_ID_ENTRY_IS_RUNNING_MASK\t\t(1ULL << 62)\n#define AVIC_MAX_PHYSICAL_ID_COUNT\t255\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic void avic_set_running(struct kvm_vcpu *vcpu, bool is_run)\n{\n\tu64 entry;\n\tint h_physical_id = __default_cpu_present_to_apicid(vcpu->cpu);\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (!kvm_vcpu_apicv_active(vcpu))\n\t\treturn;\n\n\tsvm->avic_is_running = is_run;\n\n\t/* ID = 0xff (broadcast), ID > 0xff (reserved) */\n\tif (WARN_ON(h_physical_id >= AVIC_MAX_PHYSICAL_ID_COUNT))\n\t\treturn;\n\n\tentry = READ_ONCE(*(svm->avic_physical_id_cache));\n\tWARN_ON(is_run == !!(entry & AVIC_PHYSICAL_ID_ENTRY_IS_RUNNING_MASK));\n\n\tentry &= ~AVIC_PHYSICAL_ID_ENTRY_IS_RUNNING_MASK;\n\tif (is_run)\n\t\tentry |= AVIC_PHYSICAL_ID_ENTRY_IS_RUNNING_MASK;\n\tWRITE_ONCE(*(svm->avic_physical_id_cache), entry);\n}"
  },
  {
    "function_name": "avic_vm_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "1288-1319",
    "snippet": "static int avic_vm_init(struct kvm *kvm)\n{\n\tint err = -ENOMEM;\n\tstruct kvm_arch *vm_data = &kvm->arch;\n\tstruct page *p_page;\n\tstruct page *l_page;\n\n\tif (!avic)\n\t\treturn 0;\n\n\t/* Allocating physical APIC ID table (4KB) */\n\tp_page = alloc_page(GFP_KERNEL);\n\tif (!p_page)\n\t\tgoto free_avic;\n\n\tvm_data->avic_physical_id_table_page = p_page;\n\tclear_page(page_address(p_page));\n\n\t/* Allocating logical APIC ID table (4KB) */\n\tl_page = alloc_page(GFP_KERNEL);\n\tif (!l_page)\n\t\tgoto free_avic;\n\n\tvm_data->avic_logical_id_table_page = l_page;\n\tclear_page(page_address(l_page));\n\n\treturn 0;\n\nfree_avic:\n\tavic_vm_destroy(kvm);\n\treturn err;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int avic;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "avic_vm_destroy",
          "args": [
            "kvm"
          ],
          "line": 1317
        },
        "resolved": true,
        "details": {
          "function_name": "avic_vm_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "1278-1286",
          "snippet": "static void avic_vm_destroy(struct kvm *kvm)\n{\n\tstruct kvm_arch *vm_data = &kvm->arch;\n\n\tif (vm_data->avic_logical_id_table_page)\n\t\t__free_page(vm_data->avic_logical_id_table_page);\n\tif (vm_data->avic_physical_id_table_page)\n\t\t__free_page(vm_data->avic_physical_id_table_page);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void avic_vm_destroy(struct kvm *kvm)\n{\n\tstruct kvm_arch *vm_data = &kvm->arch;\n\n\tif (vm_data->avic_logical_id_table_page)\n\t\t__free_page(vm_data->avic_logical_id_table_page);\n\tif (vm_data->avic_physical_id_table_page)\n\t\t__free_page(vm_data->avic_physical_id_table_page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_page",
          "args": [
            "page_address(l_page)"
          ],
          "line": 1312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "l_page"
          ],
          "line": 1312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_page",
          "args": [
            "GFP_KERNEL"
          ],
          "line": 1307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_page",
          "args": [
            "page_address(p_page)"
          ],
          "line": 1304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "p_page"
          ],
          "line": 1304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_page",
          "args": [
            "GFP_KERNEL"
          ],
          "line": 1299
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int avic;\n\nstatic int avic_vm_init(struct kvm *kvm)\n{\n\tint err = -ENOMEM;\n\tstruct kvm_arch *vm_data = &kvm->arch;\n\tstruct page *p_page;\n\tstruct page *l_page;\n\n\tif (!avic)\n\t\treturn 0;\n\n\t/* Allocating physical APIC ID table (4KB) */\n\tp_page = alloc_page(GFP_KERNEL);\n\tif (!p_page)\n\t\tgoto free_avic;\n\n\tvm_data->avic_physical_id_table_page = p_page;\n\tclear_page(page_address(p_page));\n\n\t/* Allocating logical APIC ID table (4KB) */\n\tl_page = alloc_page(GFP_KERNEL);\n\tif (!l_page)\n\t\tgoto free_avic;\n\n\tvm_data->avic_logical_id_table_page = l_page;\n\tclear_page(page_address(l_page));\n\n\treturn 0;\n\nfree_avic:\n\tavic_vm_destroy(kvm);\n\treturn err;\n}"
  },
  {
    "function_name": "avic_vm_destroy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "1278-1286",
    "snippet": "static void avic_vm_destroy(struct kvm *kvm)\n{\n\tstruct kvm_arch *vm_data = &kvm->arch;\n\n\tif (vm_data->avic_logical_id_table_page)\n\t\t__free_page(vm_data->avic_logical_id_table_page);\n\tif (vm_data->avic_physical_id_table_page)\n\t\t__free_page(vm_data->avic_physical_id_table_page);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__free_page",
          "args": [
            "vm_data->avic_physical_id_table_page"
          ],
          "line": 1285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__free_page",
          "args": [
            "vm_data->avic_logical_id_table_page"
          ],
          "line": 1283
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void avic_vm_destroy(struct kvm *kvm)\n{\n\tstruct kvm_arch *vm_data = &kvm->arch;\n\n\tif (vm_data->avic_logical_id_table_page)\n\t\t__free_page(vm_data->avic_logical_id_table_page);\n\tif (vm_data->avic_physical_id_table_page)\n\t\t__free_page(vm_data->avic_physical_id_table_page);\n}"
  },
  {
    "function_name": "avic_init_backing_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "1243-1276",
    "snippet": "static int avic_init_backing_page(struct kvm_vcpu *vcpu)\n{\n\tint ret;\n\tu64 *entry, new_entry;\n\tint id = vcpu->vcpu_id;\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tret = avic_init_access_page(vcpu);\n\tif (ret)\n\t\treturn ret;\n\n\tif (id >= AVIC_MAX_PHYSICAL_ID_COUNT)\n\t\treturn -EINVAL;\n\n\tif (!svm->vcpu.arch.apic->regs)\n\t\treturn -EINVAL;\n\n\tsvm->avic_backing_page = virt_to_page(svm->vcpu.arch.apic->regs);\n\n\t/* Setting AVIC backing page address in the phy APIC ID table */\n\tentry = avic_get_physical_id_entry(vcpu, id);\n\tif (!entry)\n\t\treturn -EINVAL;\n\n\tnew_entry = READ_ONCE(*entry);\n\tnew_entry = (page_to_phys(svm->avic_backing_page) &\n\t\t     AVIC_PHYSICAL_ID_ENTRY_BACKING_PAGE_MASK) |\n\t\t     AVIC_PHYSICAL_ID_ENTRY_VALID_MASK;\n\tWRITE_ONCE(*entry, new_entry);\n\n\tsvm->avic_physical_id_cache = entry;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define AVIC_PHYSICAL_ID_ENTRY_VALID_MASK\t\t(1ULL << 63)",
      "#define AVIC_PHYSICAL_ID_ENTRY_BACKING_PAGE_MASK\t(0xFFFFFFFFFFULL << 12)",
      "#define AVIC_MAX_PHYSICAL_ID_COUNT\t255"
    ],
    "globals_used": [
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "*entry",
            "new_entry"
          ],
          "line": 1271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_to_phys",
          "args": [
            "svm->avic_backing_page"
          ],
          "line": 1268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "*entry"
          ],
          "line": 1267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "avic_get_physical_id_entry",
          "args": [
            "vcpu",
            "id"
          ],
          "line": 1263
        },
        "resolved": true,
        "details": {
          "function_name": "avic_get_physical_id_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "1203-1214",
          "snippet": "static u64 *avic_get_physical_id_entry(struct kvm_vcpu *vcpu, int index)\n{\n\tu64 *avic_physical_id_table;\n\tstruct kvm_arch *vm_data = &vcpu->kvm->arch;\n\n\tif (index >= AVIC_MAX_PHYSICAL_ID_COUNT)\n\t\treturn NULL;\n\n\tavic_physical_id_table = page_address(vm_data->avic_physical_id_table_page);\n\n\treturn &avic_physical_id_table[index];\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define AVIC_MAX_PHYSICAL_ID_COUNT\t255"
          ],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define AVIC_MAX_PHYSICAL_ID_COUNT\t255\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\n\nstatic u64 *avic_get_physical_id_entry(struct kvm_vcpu *vcpu, int index)\n{\n\tu64 *avic_physical_id_table;\n\tstruct kvm_arch *vm_data = &vcpu->kvm->arch;\n\n\tif (index >= AVIC_MAX_PHYSICAL_ID_COUNT)\n\t\treturn NULL;\n\n\tavic_physical_id_table = page_address(vm_data->avic_physical_id_table_page);\n\n\treturn &avic_physical_id_table[index];\n}"
        }
      },
      {
        "call_info": {
          "callee": "virt_to_page",
          "args": [
            "svm->vcpu.arch.apic->regs"
          ],
          "line": 1260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "avic_init_access_page",
          "args": [
            "vcpu"
          ],
          "line": 1250
        },
        "resolved": true,
        "details": {
          "function_name": "avic_init_access_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "1224-1241",
          "snippet": "static int avic_init_access_page(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm *kvm = vcpu->kvm;\n\tint ret;\n\n\tif (kvm->arch.apic_access_page_done)\n\t\treturn 0;\n\n\tret = x86_set_memory_region(kvm,\n\t\t\t\t    APIC_ACCESS_PAGE_PRIVATE_MEMSLOT,\n\t\t\t\t    APIC_DEFAULT_PHYS_BASE,\n\t\t\t\t    PAGE_SIZE);\n\tif (ret)\n\t\treturn ret;\n\n\tkvm->arch.apic_access_page_done = true;\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\n\nstatic int avic_init_access_page(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm *kvm = vcpu->kvm;\n\tint ret;\n\n\tif (kvm->arch.apic_access_page_done)\n\t\treturn 0;\n\n\tret = x86_set_memory_region(kvm,\n\t\t\t\t    APIC_ACCESS_PAGE_PRIVATE_MEMSLOT,\n\t\t\t\t    APIC_DEFAULT_PHYS_BASE,\n\t\t\t\t    PAGE_SIZE);\n\tif (ret)\n\t\treturn ret;\n\n\tkvm->arch.apic_access_page_done = true;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 1248
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "294-297",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define AVIC_PHYSICAL_ID_ENTRY_VALID_MASK\t\t(1ULL << 63)\n#define AVIC_PHYSICAL_ID_ENTRY_BACKING_PAGE_MASK\t(0xFFFFFFFFFFULL << 12)\n#define AVIC_MAX_PHYSICAL_ID_COUNT\t255\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic int avic_init_backing_page(struct kvm_vcpu *vcpu)\n{\n\tint ret;\n\tu64 *entry, new_entry;\n\tint id = vcpu->vcpu_id;\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tret = avic_init_access_page(vcpu);\n\tif (ret)\n\t\treturn ret;\n\n\tif (id >= AVIC_MAX_PHYSICAL_ID_COUNT)\n\t\treturn -EINVAL;\n\n\tif (!svm->vcpu.arch.apic->regs)\n\t\treturn -EINVAL;\n\n\tsvm->avic_backing_page = virt_to_page(svm->vcpu.arch.apic->regs);\n\n\t/* Setting AVIC backing page address in the phy APIC ID table */\n\tentry = avic_get_physical_id_entry(vcpu, id);\n\tif (!entry)\n\t\treturn -EINVAL;\n\n\tnew_entry = READ_ONCE(*entry);\n\tnew_entry = (page_to_phys(svm->avic_backing_page) &\n\t\t     AVIC_PHYSICAL_ID_ENTRY_BACKING_PAGE_MASK) |\n\t\t     AVIC_PHYSICAL_ID_ENTRY_VALID_MASK;\n\tWRITE_ONCE(*entry, new_entry);\n\n\tsvm->avic_physical_id_cache = entry;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "avic_init_access_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "1224-1241",
    "snippet": "static int avic_init_access_page(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm *kvm = vcpu->kvm;\n\tint ret;\n\n\tif (kvm->arch.apic_access_page_done)\n\t\treturn 0;\n\n\tret = x86_set_memory_region(kvm,\n\t\t\t\t    APIC_ACCESS_PAGE_PRIVATE_MEMSLOT,\n\t\t\t\t    APIC_DEFAULT_PHYS_BASE,\n\t\t\t\t    PAGE_SIZE);\n\tif (ret)\n\t\treturn ret;\n\n\tkvm->arch.apic_access_page_done = true;\n\treturn 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "x86_set_memory_region",
          "args": [
            "kvm",
            "APIC_ACCESS_PAGE_PRIVATE_MEMSLOT",
            "APIC_DEFAULT_PHYS_BASE",
            "PAGE_SIZE"
          ],
          "line": 1232
        },
        "resolved": true,
        "details": {
          "function_name": "x86_set_memory_region",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "7859-7868",
          "snippet": "int x86_set_memory_region(struct kvm *kvm, int id, gpa_t gpa, u32 size)\n{\n\tint r;\n\n\tmutex_lock(&kvm->slots_lock);\n\tr = __x86_set_memory_region(kvm, id, gpa, size);\n\tmutex_unlock(&kvm->slots_lock);\n\n\treturn r;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nint x86_set_memory_region(struct kvm *kvm, int id, gpa_t gpa, u32 size)\n{\n\tint r;\n\n\tmutex_lock(&kvm->slots_lock);\n\tr = __x86_set_memory_region(kvm, id, gpa, size);\n\tmutex_unlock(&kvm->slots_lock);\n\n\treturn r;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\n\nstatic int avic_init_access_page(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm *kvm = vcpu->kvm;\n\tint ret;\n\n\tif (kvm->arch.apic_access_page_done)\n\t\treturn 0;\n\n\tret = x86_set_memory_region(kvm,\n\t\t\t\t    APIC_ACCESS_PAGE_PRIVATE_MEMSLOT,\n\t\t\t\t    APIC_DEFAULT_PHYS_BASE,\n\t\t\t\t    PAGE_SIZE);\n\tif (ret)\n\t\treturn ret;\n\n\tkvm->arch.apic_access_page_done = true;\n\treturn 0;\n}"
  },
  {
    "function_name": "avic_get_physical_id_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "1203-1214",
    "snippet": "static u64 *avic_get_physical_id_entry(struct kvm_vcpu *vcpu, int index)\n{\n\tu64 *avic_physical_id_table;\n\tstruct kvm_arch *vm_data = &vcpu->kvm->arch;\n\n\tif (index >= AVIC_MAX_PHYSICAL_ID_COUNT)\n\t\treturn NULL;\n\n\tavic_physical_id_table = page_address(vm_data->avic_physical_id_table_page);\n\n\treturn &avic_physical_id_table[index];\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define AVIC_MAX_PHYSICAL_ID_COUNT\t255"
    ],
    "globals_used": [
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "vm_data->avic_physical_id_table_page"
          ],
          "line": 1211
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define AVIC_MAX_PHYSICAL_ID_COUNT\t255\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\n\nstatic u64 *avic_get_physical_id_entry(struct kvm_vcpu *vcpu, int index)\n{\n\tu64 *avic_physical_id_table;\n\tstruct kvm_arch *vm_data = &vcpu->kvm->arch;\n\n\tif (index >= AVIC_MAX_PHYSICAL_ID_COUNT)\n\t\treturn NULL;\n\n\tavic_physical_id_table = page_address(vm_data->avic_physical_id_table_page);\n\n\treturn &avic_physical_id_table[index];\n}"
  },
  {
    "function_name": "init_vmcb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "1083-1201",
    "snippet": "static void init_vmcb(struct vcpu_svm *svm)\n{\n\tstruct vmcb_control_area *control = &svm->vmcb->control;\n\tstruct vmcb_save_area *save = &svm->vmcb->save;\n\n\tsvm->vcpu.fpu_active = 1;\n\tsvm->vcpu.arch.hflags = 0;\n\n\tset_cr_intercept(svm, INTERCEPT_CR0_READ);\n\tset_cr_intercept(svm, INTERCEPT_CR3_READ);\n\tset_cr_intercept(svm, INTERCEPT_CR4_READ);\n\tset_cr_intercept(svm, INTERCEPT_CR0_WRITE);\n\tset_cr_intercept(svm, INTERCEPT_CR3_WRITE);\n\tset_cr_intercept(svm, INTERCEPT_CR4_WRITE);\n\tif (!kvm_vcpu_apicv_active(&svm->vcpu))\n\t\tset_cr_intercept(svm, INTERCEPT_CR8_WRITE);\n\n\tset_dr_intercepts(svm);\n\n\tset_exception_intercept(svm, PF_VECTOR);\n\tset_exception_intercept(svm, UD_VECTOR);\n\tset_exception_intercept(svm, MC_VECTOR);\n\tset_exception_intercept(svm, AC_VECTOR);\n\tset_exception_intercept(svm, DB_VECTOR);\n\n\tset_intercept(svm, INTERCEPT_INTR);\n\tset_intercept(svm, INTERCEPT_NMI);\n\tset_intercept(svm, INTERCEPT_SMI);\n\tset_intercept(svm, INTERCEPT_SELECTIVE_CR0);\n\tset_intercept(svm, INTERCEPT_RDPMC);\n\tset_intercept(svm, INTERCEPT_CPUID);\n\tset_intercept(svm, INTERCEPT_INVD);\n\tset_intercept(svm, INTERCEPT_HLT);\n\tset_intercept(svm, INTERCEPT_INVLPG);\n\tset_intercept(svm, INTERCEPT_INVLPGA);\n\tset_intercept(svm, INTERCEPT_IOIO_PROT);\n\tset_intercept(svm, INTERCEPT_MSR_PROT);\n\tset_intercept(svm, INTERCEPT_TASK_SWITCH);\n\tset_intercept(svm, INTERCEPT_SHUTDOWN);\n\tset_intercept(svm, INTERCEPT_VMRUN);\n\tset_intercept(svm, INTERCEPT_VMMCALL);\n\tset_intercept(svm, INTERCEPT_VMLOAD);\n\tset_intercept(svm, INTERCEPT_VMSAVE);\n\tset_intercept(svm, INTERCEPT_STGI);\n\tset_intercept(svm, INTERCEPT_CLGI);\n\tset_intercept(svm, INTERCEPT_SKINIT);\n\tset_intercept(svm, INTERCEPT_WBINVD);\n\tset_intercept(svm, INTERCEPT_MONITOR);\n\tset_intercept(svm, INTERCEPT_MWAIT);\n\tset_intercept(svm, INTERCEPT_XSETBV);\n\n\tcontrol->iopm_base_pa = iopm_base;\n\tcontrol->msrpm_base_pa = __pa(svm->msrpm);\n\tcontrol->int_ctl = V_INTR_MASKING_MASK;\n\n\tinit_seg(&save->es);\n\tinit_seg(&save->ss);\n\tinit_seg(&save->ds);\n\tinit_seg(&save->fs);\n\tinit_seg(&save->gs);\n\n\tsave->cs.selector = 0xf000;\n\tsave->cs.base = 0xffff0000;\n\t/* Executable/Readable Code Segment */\n\tsave->cs.attrib = SVM_SELECTOR_READ_MASK | SVM_SELECTOR_P_MASK |\n\t\tSVM_SELECTOR_S_MASK | SVM_SELECTOR_CODE_MASK;\n\tsave->cs.limit = 0xffff;\n\n\tsave->gdtr.limit = 0xffff;\n\tsave->idtr.limit = 0xffff;\n\n\tinit_sys_seg(&save->ldtr, SEG_TYPE_LDT);\n\tinit_sys_seg(&save->tr, SEG_TYPE_BUSY_TSS16);\n\n\tsvm_set_efer(&svm->vcpu, 0);\n\tsave->dr6 = 0xffff0ff0;\n\tkvm_set_rflags(&svm->vcpu, 2);\n\tsave->rip = 0x0000fff0;\n\tsvm->vcpu.arch.regs[VCPU_REGS_RIP] = save->rip;\n\n\t/*\n\t * svm_set_cr0() sets PG and WP and clears NW and CD on save->cr0.\n\t * It also updates the guest-visible cr0 value.\n\t */\n\tsvm_set_cr0(&svm->vcpu, X86_CR0_NW | X86_CR0_CD | X86_CR0_ET);\n\tkvm_mmu_reset_context(&svm->vcpu);\n\n\tsave->cr4 = X86_CR4_PAE;\n\t/* rdx = ?? */\n\n\tif (npt_enabled) {\n\t\t/* Setup VMCB for Nested Paging */\n\t\tcontrol->nested_ctl = 1;\n\t\tclr_intercept(svm, INTERCEPT_INVLPG);\n\t\tclr_exception_intercept(svm, PF_VECTOR);\n\t\tclr_cr_intercept(svm, INTERCEPT_CR3_READ);\n\t\tclr_cr_intercept(svm, INTERCEPT_CR3_WRITE);\n\t\tsave->g_pat = svm->vcpu.arch.pat;\n\t\tsave->cr3 = 0;\n\t\tsave->cr4 = 0;\n\t}\n\tsvm->asid_generation = 0;\n\n\tsvm->nested.vmcb = 0;\n\tsvm->vcpu.arch.hflags = 0;\n\n\tif (boot_cpu_has(X86_FEATURE_PAUSEFILTER)) {\n\t\tcontrol->pause_filter_count = 3000;\n\t\tset_intercept(svm, INTERCEPT_PAUSE);\n\t}\n\n\tif (avic)\n\t\tavic_init_vmcb(svm);\n\n\tmark_all_dirty(svm->vmcb);\n\n\tenable_gif(svm);\n\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define SEG_TYPE_BUSY_TSS16 3",
      "#define SEG_TYPE_LDT 2"
    ],
    "globals_used": [
      "static int nested = true;",
      "static int avic;",
      "static void svm_set_cr0(struct kvm_vcpu *vcpu, unsigned long cr0);",
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);",
      "static unsigned long iopm_base;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "enable_gif",
          "args": [
            "svm"
          ],
          "line": 1199
        },
        "resolved": true,
        "details": {
          "function_name": "enable_gif",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "438-441",
          "snippet": "static inline void enable_gif(struct vcpu_svm *svm)\n{\n\tsvm->vcpu.arch.hflags |= HF_GIF_MASK;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic inline void enable_gif(struct vcpu_svm *svm)\n{\n\tsvm->vcpu.arch.hflags |= HF_GIF_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_all_dirty",
          "args": [
            "svm->vmcb"
          ],
          "line": 1197
        },
        "resolved": true,
        "details": {
          "function_name": "mark_all_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "278-281",
          "snippet": "static inline void mark_all_dirty(struct vmcb *vmcb)\n{\n\tvmcb->control.clean = 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic inline void mark_all_dirty(struct vmcb *vmcb)\n{\n\tvmcb->control.clean = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "avic_init_vmcb",
          "args": [
            "svm"
          ],
          "line": 1195
        },
        "resolved": true,
        "details": {
          "function_name": "avic_init_vmcb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "1067-1081",
          "snippet": "static void avic_init_vmcb(struct vcpu_svm *svm)\n{\n\tstruct vmcb *vmcb = svm->vmcb;\n\tstruct kvm_arch *vm_data = &svm->vcpu.kvm->arch;\n\tphys_addr_t bpa = page_to_phys(svm->avic_backing_page);\n\tphys_addr_t lpa = page_to_phys(vm_data->avic_logical_id_table_page);\n\tphys_addr_t ppa = page_to_phys(vm_data->avic_physical_id_table_page);\n\n\tvmcb->control.avic_backing_page = bpa & AVIC_HPA_MASK;\n\tvmcb->control.avic_logical_id = lpa & AVIC_HPA_MASK;\n\tvmcb->control.avic_physical_id = ppa & AVIC_HPA_MASK;\n\tvmcb->control.avic_physical_id |= AVIC_MAX_PHYSICAL_ID_COUNT;\n\tvmcb->control.int_ctl |= AVIC_ENABLE_MASK;\n\tsvm->vcpu.arch.apicv_active = true;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define AVIC_MAX_PHYSICAL_ID_COUNT\t255",
            "#define AVIC_HPA_MASK\t~((0xFFFULL << 52) || 0xFFF)"
          ],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define AVIC_MAX_PHYSICAL_ID_COUNT\t255\n#define AVIC_HPA_MASK\t~((0xFFFULL << 52) || 0xFFF)\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic void avic_init_vmcb(struct vcpu_svm *svm)\n{\n\tstruct vmcb *vmcb = svm->vmcb;\n\tstruct kvm_arch *vm_data = &svm->vcpu.kvm->arch;\n\tphys_addr_t bpa = page_to_phys(svm->avic_backing_page);\n\tphys_addr_t lpa = page_to_phys(vm_data->avic_logical_id_table_page);\n\tphys_addr_t ppa = page_to_phys(vm_data->avic_physical_id_table_page);\n\n\tvmcb->control.avic_backing_page = bpa & AVIC_HPA_MASK;\n\tvmcb->control.avic_logical_id = lpa & AVIC_HPA_MASK;\n\tvmcb->control.avic_physical_id = ppa & AVIC_HPA_MASK;\n\tvmcb->control.avic_physical_id |= AVIC_MAX_PHYSICAL_ID_COUNT;\n\tvmcb->control.int_ctl |= AVIC_ENABLE_MASK;\n\tsvm->vcpu.arch.apicv_active = true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_intercept",
          "args": [
            "svm",
            "INTERCEPT_PAUSE"
          ],
          "line": 1191
        },
        "resolved": true,
        "details": {
          "function_name": "set_intercept",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "420-427",
          "snippet": "static inline void set_intercept(struct vcpu_svm *svm, int bit)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept |= (1ULL << bit);\n\n\trecalc_intercepts(svm);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic inline void set_intercept(struct vcpu_svm *svm, int bit)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept |= (1ULL << bit);\n\n\trecalc_intercepts(svm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "boot_cpu_has",
          "args": [
            "X86_FEATURE_PAUSEFILTER"
          ],
          "line": 1189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clr_cr_intercept",
          "args": [
            "svm",
            "INTERCEPT_CR3_WRITE"
          ],
          "line": 1179
        },
        "resolved": true,
        "details": {
          "function_name": "clr_cr_intercept",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "353-360",
          "snippet": "static inline void clr_cr_intercept(struct vcpu_svm *svm, int bit)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept_cr &= ~(1U << bit);\n\n\trecalc_intercepts(svm);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic inline void clr_cr_intercept(struct vcpu_svm *svm, int bit)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept_cr &= ~(1U << bit);\n\n\trecalc_intercepts(svm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clr_exception_intercept",
          "args": [
            "svm",
            "PF_VECTOR"
          ],
          "line": 1177
        },
        "resolved": true,
        "details": {
          "function_name": "clr_exception_intercept",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "411-418",
          "snippet": "static inline void clr_exception_intercept(struct vcpu_svm *svm, int bit)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept_exceptions &= ~(1U << bit);\n\n\trecalc_intercepts(svm);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic inline void clr_exception_intercept(struct vcpu_svm *svm, int bit)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept_exceptions &= ~(1U << bit);\n\n\trecalc_intercepts(svm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clr_intercept",
          "args": [
            "svm",
            "INTERCEPT_INVLPG"
          ],
          "line": 1176
        },
        "resolved": true,
        "details": {
          "function_name": "clr_intercept",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "429-436",
          "snippet": "static inline void clr_intercept(struct vcpu_svm *svm, int bit)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept &= ~(1ULL << bit);\n\n\trecalc_intercepts(svm);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic inline void clr_intercept(struct vcpu_svm *svm, int bit)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept &= ~(1ULL << bit);\n\n\trecalc_intercepts(svm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_mmu_reset_context",
          "args": [
            "&svm->vcpu"
          ],
          "line": 1168
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_reset_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "4230-4234",
          "snippet": "void kvm_mmu_reset_context(struct kvm_vcpu *vcpu)\n{\n\tkvm_mmu_unload(vcpu);\n\tinit_kvm_mmu(vcpu);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nvoid kvm_mmu_reset_context(struct kvm_vcpu *vcpu)\n{\n\tkvm_mmu_unload(vcpu);\n\tinit_kvm_mmu(vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "svm_set_cr0",
          "args": [
            "&svm->vcpu",
            "X86_CR0_NW | X86_CR0_CD | X86_CR0_ET"
          ],
          "line": 1167
        },
        "resolved": true,
        "details": {
          "function_name": "svm_set_cr0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "1777-1811",
          "snippet": "static void svm_set_cr0(struct kvm_vcpu *vcpu, unsigned long cr0)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n#ifdef CONFIG_X86_64\n\tif (vcpu->arch.efer & EFER_LME) {\n\t\tif (!is_paging(vcpu) && (cr0 & X86_CR0_PG)) {\n\t\t\tvcpu->arch.efer |= EFER_LMA;\n\t\t\tsvm->vmcb->save.efer |= EFER_LMA | EFER_LME;\n\t\t}\n\n\t\tif (is_paging(vcpu) && !(cr0 & X86_CR0_PG)) {\n\t\t\tvcpu->arch.efer &= ~EFER_LMA;\n\t\t\tsvm->vmcb->save.efer &= ~(EFER_LMA | EFER_LME);\n\t\t}\n\t}\n#endif\n\tvcpu->arch.cr0 = cr0;\n\n\tif (!npt_enabled)\n\t\tcr0 |= X86_CR0_PG | X86_CR0_WP;\n\n\tif (!vcpu->fpu_active)\n\t\tcr0 |= X86_CR0_TS;\n\t/*\n\t * re-enable caching here because the QEMU bios\n\t * does not do it - this results in some delay at\n\t * reboot\n\t */\n\tif (kvm_check_has_quirk(vcpu->kvm, KVM_X86_QUIRK_CD_NW_CLEARED))\n\t\tcr0 &= ~(X86_CR0_CD | X86_CR0_NW);\n\tsvm->vmcb->save.cr0 = cr0;\n\tmark_dirty(svm->vmcb, VMCB_CR);\n\tupdate_cr0_intercept(svm);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_set_cr0(struct kvm_vcpu *vcpu, unsigned long cr0);",
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_set_cr0(struct kvm_vcpu *vcpu, unsigned long cr0);\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic void svm_set_cr0(struct kvm_vcpu *vcpu, unsigned long cr0)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n#ifdef CONFIG_X86_64\n\tif (vcpu->arch.efer & EFER_LME) {\n\t\tif (!is_paging(vcpu) && (cr0 & X86_CR0_PG)) {\n\t\t\tvcpu->arch.efer |= EFER_LMA;\n\t\t\tsvm->vmcb->save.efer |= EFER_LMA | EFER_LME;\n\t\t}\n\n\t\tif (is_paging(vcpu) && !(cr0 & X86_CR0_PG)) {\n\t\t\tvcpu->arch.efer &= ~EFER_LMA;\n\t\t\tsvm->vmcb->save.efer &= ~(EFER_LMA | EFER_LME);\n\t\t}\n\t}\n#endif\n\tvcpu->arch.cr0 = cr0;\n\n\tif (!npt_enabled)\n\t\tcr0 |= X86_CR0_PG | X86_CR0_WP;\n\n\tif (!vcpu->fpu_active)\n\t\tcr0 |= X86_CR0_TS;\n\t/*\n\t * re-enable caching here because the QEMU bios\n\t * does not do it - this results in some delay at\n\t * reboot\n\t */\n\tif (kvm_check_has_quirk(vcpu->kvm, KVM_X86_QUIRK_CD_NW_CLEARED))\n\t\tcr0 &= ~(X86_CR0_CD | X86_CR0_NW);\n\tsvm->vmcb->save.cr0 = cr0;\n\tmark_dirty(svm->vmcb, VMCB_CR);\n\tupdate_cr0_intercept(svm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_set_rflags",
          "args": [
            "&svm->vcpu",
            "2"
          ],
          "line": 1159
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_set_rflags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "8182-8186",
          "snippet": "void kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags)\n{\n\t__kvm_set_rflags(vcpu, rflags);\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void __kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void __kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags);\n\nvoid kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags)\n{\n\t__kvm_set_rflags(vcpu, rflags);\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "svm_set_efer",
          "args": [
            "&svm->vcpu",
            "0"
          ],
          "line": 1157
        },
        "resolved": true,
        "details": {
          "function_name": "svm_set_efer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "535-543",
          "snippet": "static void svm_set_efer(struct kvm_vcpu *vcpu, u64 efer)\n{\n\tvcpu->arch.efer = efer;\n\tif (!npt_enabled && !(efer & EFER_LMA))\n\t\tefer &= ~EFER_LME;\n\n\tto_svm(vcpu)->vmcb->save.efer = efer | EFER_SVME;\n\tmark_dirty(to_svm(vcpu)->vmcb, VMCB_CR);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\n\nstatic void svm_set_efer(struct kvm_vcpu *vcpu, u64 efer)\n{\n\tvcpu->arch.efer = efer;\n\tif (!npt_enabled && !(efer & EFER_LMA))\n\t\tefer &= ~EFER_LME;\n\n\tto_svm(vcpu)->vmcb->save.efer = efer | EFER_SVME;\n\tmark_dirty(to_svm(vcpu)->vmcb, VMCB_CR);\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_sys_seg",
          "args": [
            "&save->tr",
            "SEG_TYPE_BUSY_TSS16"
          ],
          "line": 1155
        },
        "resolved": true,
        "details": {
          "function_name": "init_sys_seg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "1018-1024",
          "snippet": "static void init_sys_seg(struct vmcb_seg *seg, uint32_t type)\n{\n\tseg->selector = 0;\n\tseg->attrib = SVM_SELECTOR_P_MASK | type;\n\tseg->limit = 0xffff;\n\tseg->base = 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void init_sys_seg(struct vmcb_seg *seg, uint32_t type)\n{\n\tseg->selector = 0;\n\tseg->attrib = SVM_SELECTOR_P_MASK | type;\n\tseg->limit = 0xffff;\n\tseg->base = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_seg",
          "args": [
            "&save->gs"
          ],
          "line": 1142
        },
        "resolved": true,
        "details": {
          "function_name": "init_seg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "1009-1016",
          "snippet": "static void init_seg(struct vmcb_seg *seg)\n{\n\tseg->selector = 0;\n\tseg->attrib = SVM_SELECTOR_P_MASK | SVM_SELECTOR_S_MASK |\n\t\t      SVM_SELECTOR_WRITE_MASK; /* Read/Write Data Segment */\n\tseg->limit = 0xffff;\n\tseg->base = 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void init_seg(struct vmcb_seg *seg)\n{\n\tseg->selector = 0;\n\tseg->attrib = SVM_SELECTOR_P_MASK | SVM_SELECTOR_S_MASK |\n\t\t      SVM_SELECTOR_WRITE_MASK; /* Read/Write Data Segment */\n\tseg->limit = 0xffff;\n\tseg->base = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__pa",
          "args": [
            "svm->msrpm"
          ],
          "line": 1135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_exception_intercept",
          "args": [
            "svm",
            "DB_VECTOR"
          ],
          "line": 1106
        },
        "resolved": true,
        "details": {
          "function_name": "set_exception_intercept",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "402-409",
          "snippet": "static inline void set_exception_intercept(struct vcpu_svm *svm, int bit)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept_exceptions |= (1U << bit);\n\n\trecalc_intercepts(svm);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic inline void set_exception_intercept(struct vcpu_svm *svm, int bit)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept_exceptions |= (1U << bit);\n\n\trecalc_intercepts(svm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_dr_intercepts",
          "args": [
            "svm"
          ],
          "line": 1100
        },
        "resolved": true,
        "details": {
          "function_name": "set_dr_intercepts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "369-391",
          "snippet": "static inline void set_dr_intercepts(struct vcpu_svm *svm)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept_dr = (1 << INTERCEPT_DR0_READ)\n\t\t| (1 << INTERCEPT_DR1_READ)\n\t\t| (1 << INTERCEPT_DR2_READ)\n\t\t| (1 << INTERCEPT_DR3_READ)\n\t\t| (1 << INTERCEPT_DR4_READ)\n\t\t| (1 << INTERCEPT_DR5_READ)\n\t\t| (1 << INTERCEPT_DR6_READ)\n\t\t| (1 << INTERCEPT_DR7_READ)\n\t\t| (1 << INTERCEPT_DR0_WRITE)\n\t\t| (1 << INTERCEPT_DR1_WRITE)\n\t\t| (1 << INTERCEPT_DR2_WRITE)\n\t\t| (1 << INTERCEPT_DR3_WRITE)\n\t\t| (1 << INTERCEPT_DR4_WRITE)\n\t\t| (1 << INTERCEPT_DR5_WRITE)\n\t\t| (1 << INTERCEPT_DR6_WRITE)\n\t\t| (1 << INTERCEPT_DR7_WRITE);\n\n\trecalc_intercepts(svm);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic inline void set_dr_intercepts(struct vcpu_svm *svm)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept_dr = (1 << INTERCEPT_DR0_READ)\n\t\t| (1 << INTERCEPT_DR1_READ)\n\t\t| (1 << INTERCEPT_DR2_READ)\n\t\t| (1 << INTERCEPT_DR3_READ)\n\t\t| (1 << INTERCEPT_DR4_READ)\n\t\t| (1 << INTERCEPT_DR5_READ)\n\t\t| (1 << INTERCEPT_DR6_READ)\n\t\t| (1 << INTERCEPT_DR7_READ)\n\t\t| (1 << INTERCEPT_DR0_WRITE)\n\t\t| (1 << INTERCEPT_DR1_WRITE)\n\t\t| (1 << INTERCEPT_DR2_WRITE)\n\t\t| (1 << INTERCEPT_DR3_WRITE)\n\t\t| (1 << INTERCEPT_DR4_WRITE)\n\t\t| (1 << INTERCEPT_DR5_WRITE)\n\t\t| (1 << INTERCEPT_DR6_WRITE)\n\t\t| (1 << INTERCEPT_DR7_WRITE);\n\n\trecalc_intercepts(svm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_cr_intercept",
          "args": [
            "svm",
            "INTERCEPT_CR8_WRITE"
          ],
          "line": 1098
        },
        "resolved": true,
        "details": {
          "function_name": "set_cr_intercept",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "344-351",
          "snippet": "static inline void set_cr_intercept(struct vcpu_svm *svm, int bit)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept_cr |= (1U << bit);\n\n\trecalc_intercepts(svm);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic inline void set_cr_intercept(struct vcpu_svm *svm, int bit)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept_cr |= (1U << bit);\n\n\trecalc_intercepts(svm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_apicv_active",
          "args": [
            "&svm->vcpu"
          ],
          "line": 1097
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_vcpu_apicv_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.h",
          "lines": "181-184",
          "snippet": "static inline bool kvm_vcpu_apicv_active(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.apic && vcpu->arch.apicv_active;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline bool kvm_vcpu_apicv_active(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.apic && vcpu->arch.apicv_active;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define SEG_TYPE_BUSY_TSS16 3\n#define SEG_TYPE_LDT 2\n\nstatic int nested = true;\nstatic int avic;\nstatic void svm_set_cr0(struct kvm_vcpu *vcpu, unsigned long cr0);\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\nstatic unsigned long iopm_base;\n\nstatic void init_vmcb(struct vcpu_svm *svm)\n{\n\tstruct vmcb_control_area *control = &svm->vmcb->control;\n\tstruct vmcb_save_area *save = &svm->vmcb->save;\n\n\tsvm->vcpu.fpu_active = 1;\n\tsvm->vcpu.arch.hflags = 0;\n\n\tset_cr_intercept(svm, INTERCEPT_CR0_READ);\n\tset_cr_intercept(svm, INTERCEPT_CR3_READ);\n\tset_cr_intercept(svm, INTERCEPT_CR4_READ);\n\tset_cr_intercept(svm, INTERCEPT_CR0_WRITE);\n\tset_cr_intercept(svm, INTERCEPT_CR3_WRITE);\n\tset_cr_intercept(svm, INTERCEPT_CR4_WRITE);\n\tif (!kvm_vcpu_apicv_active(&svm->vcpu))\n\t\tset_cr_intercept(svm, INTERCEPT_CR8_WRITE);\n\n\tset_dr_intercepts(svm);\n\n\tset_exception_intercept(svm, PF_VECTOR);\n\tset_exception_intercept(svm, UD_VECTOR);\n\tset_exception_intercept(svm, MC_VECTOR);\n\tset_exception_intercept(svm, AC_VECTOR);\n\tset_exception_intercept(svm, DB_VECTOR);\n\n\tset_intercept(svm, INTERCEPT_INTR);\n\tset_intercept(svm, INTERCEPT_NMI);\n\tset_intercept(svm, INTERCEPT_SMI);\n\tset_intercept(svm, INTERCEPT_SELECTIVE_CR0);\n\tset_intercept(svm, INTERCEPT_RDPMC);\n\tset_intercept(svm, INTERCEPT_CPUID);\n\tset_intercept(svm, INTERCEPT_INVD);\n\tset_intercept(svm, INTERCEPT_HLT);\n\tset_intercept(svm, INTERCEPT_INVLPG);\n\tset_intercept(svm, INTERCEPT_INVLPGA);\n\tset_intercept(svm, INTERCEPT_IOIO_PROT);\n\tset_intercept(svm, INTERCEPT_MSR_PROT);\n\tset_intercept(svm, INTERCEPT_TASK_SWITCH);\n\tset_intercept(svm, INTERCEPT_SHUTDOWN);\n\tset_intercept(svm, INTERCEPT_VMRUN);\n\tset_intercept(svm, INTERCEPT_VMMCALL);\n\tset_intercept(svm, INTERCEPT_VMLOAD);\n\tset_intercept(svm, INTERCEPT_VMSAVE);\n\tset_intercept(svm, INTERCEPT_STGI);\n\tset_intercept(svm, INTERCEPT_CLGI);\n\tset_intercept(svm, INTERCEPT_SKINIT);\n\tset_intercept(svm, INTERCEPT_WBINVD);\n\tset_intercept(svm, INTERCEPT_MONITOR);\n\tset_intercept(svm, INTERCEPT_MWAIT);\n\tset_intercept(svm, INTERCEPT_XSETBV);\n\n\tcontrol->iopm_base_pa = iopm_base;\n\tcontrol->msrpm_base_pa = __pa(svm->msrpm);\n\tcontrol->int_ctl = V_INTR_MASKING_MASK;\n\n\tinit_seg(&save->es);\n\tinit_seg(&save->ss);\n\tinit_seg(&save->ds);\n\tinit_seg(&save->fs);\n\tinit_seg(&save->gs);\n\n\tsave->cs.selector = 0xf000;\n\tsave->cs.base = 0xffff0000;\n\t/* Executable/Readable Code Segment */\n\tsave->cs.attrib = SVM_SELECTOR_READ_MASK | SVM_SELECTOR_P_MASK |\n\t\tSVM_SELECTOR_S_MASK | SVM_SELECTOR_CODE_MASK;\n\tsave->cs.limit = 0xffff;\n\n\tsave->gdtr.limit = 0xffff;\n\tsave->idtr.limit = 0xffff;\n\n\tinit_sys_seg(&save->ldtr, SEG_TYPE_LDT);\n\tinit_sys_seg(&save->tr, SEG_TYPE_BUSY_TSS16);\n\n\tsvm_set_efer(&svm->vcpu, 0);\n\tsave->dr6 = 0xffff0ff0;\n\tkvm_set_rflags(&svm->vcpu, 2);\n\tsave->rip = 0x0000fff0;\n\tsvm->vcpu.arch.regs[VCPU_REGS_RIP] = save->rip;\n\n\t/*\n\t * svm_set_cr0() sets PG and WP and clears NW and CD on save->cr0.\n\t * It also updates the guest-visible cr0 value.\n\t */\n\tsvm_set_cr0(&svm->vcpu, X86_CR0_NW | X86_CR0_CD | X86_CR0_ET);\n\tkvm_mmu_reset_context(&svm->vcpu);\n\n\tsave->cr4 = X86_CR4_PAE;\n\t/* rdx = ?? */\n\n\tif (npt_enabled) {\n\t\t/* Setup VMCB for Nested Paging */\n\t\tcontrol->nested_ctl = 1;\n\t\tclr_intercept(svm, INTERCEPT_INVLPG);\n\t\tclr_exception_intercept(svm, PF_VECTOR);\n\t\tclr_cr_intercept(svm, INTERCEPT_CR3_READ);\n\t\tclr_cr_intercept(svm, INTERCEPT_CR3_WRITE);\n\t\tsave->g_pat = svm->vcpu.arch.pat;\n\t\tsave->cr3 = 0;\n\t\tsave->cr4 = 0;\n\t}\n\tsvm->asid_generation = 0;\n\n\tsvm->nested.vmcb = 0;\n\tsvm->vcpu.arch.hflags = 0;\n\n\tif (boot_cpu_has(X86_FEATURE_PAUSEFILTER)) {\n\t\tcontrol->pause_filter_count = 3000;\n\t\tset_intercept(svm, INTERCEPT_PAUSE);\n\t}\n\n\tif (avic)\n\t\tavic_init_vmcb(svm);\n\n\tmark_all_dirty(svm->vmcb);\n\n\tenable_gif(svm);\n\n}"
  },
  {
    "function_name": "avic_init_vmcb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "1067-1081",
    "snippet": "static void avic_init_vmcb(struct vcpu_svm *svm)\n{\n\tstruct vmcb *vmcb = svm->vmcb;\n\tstruct kvm_arch *vm_data = &svm->vcpu.kvm->arch;\n\tphys_addr_t bpa = page_to_phys(svm->avic_backing_page);\n\tphys_addr_t lpa = page_to_phys(vm_data->avic_logical_id_table_page);\n\tphys_addr_t ppa = page_to_phys(vm_data->avic_physical_id_table_page);\n\n\tvmcb->control.avic_backing_page = bpa & AVIC_HPA_MASK;\n\tvmcb->control.avic_logical_id = lpa & AVIC_HPA_MASK;\n\tvmcb->control.avic_physical_id = ppa & AVIC_HPA_MASK;\n\tvmcb->control.avic_physical_id |= AVIC_MAX_PHYSICAL_ID_COUNT;\n\tvmcb->control.int_ctl |= AVIC_ENABLE_MASK;\n\tsvm->vcpu.arch.apicv_active = true;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define AVIC_MAX_PHYSICAL_ID_COUNT\t255",
      "#define AVIC_HPA_MASK\t~((0xFFFULL << 52) || 0xFFF)"
    ],
    "globals_used": [
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_to_phys",
          "args": [
            "vm_data->avic_physical_id_table_page"
          ],
          "line": 1073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_to_phys",
          "args": [
            "vm_data->avic_logical_id_table_page"
          ],
          "line": 1072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_to_phys",
          "args": [
            "svm->avic_backing_page"
          ],
          "line": 1071
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define AVIC_MAX_PHYSICAL_ID_COUNT\t255\n#define AVIC_HPA_MASK\t~((0xFFFULL << 52) || 0xFFF)\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic void avic_init_vmcb(struct vcpu_svm *svm)\n{\n\tstruct vmcb *vmcb = svm->vmcb;\n\tstruct kvm_arch *vm_data = &svm->vcpu.kvm->arch;\n\tphys_addr_t bpa = page_to_phys(svm->avic_backing_page);\n\tphys_addr_t lpa = page_to_phys(vm_data->avic_logical_id_table_page);\n\tphys_addr_t ppa = page_to_phys(vm_data->avic_physical_id_table_page);\n\n\tvmcb->control.avic_backing_page = bpa & AVIC_HPA_MASK;\n\tvmcb->control.avic_logical_id = lpa & AVIC_HPA_MASK;\n\tvmcb->control.avic_physical_id = ppa & AVIC_HPA_MASK;\n\tvmcb->control.avic_physical_id |= AVIC_MAX_PHYSICAL_ID_COUNT;\n\tvmcb->control.int_ctl |= AVIC_ENABLE_MASK;\n\tsvm->vcpu.arch.apicv_active = true;\n}"
  },
  {
    "function_name": "svm_adjust_tsc_offset_guest",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "1052-1065",
    "snippet": "static void svm_adjust_tsc_offset_guest(struct kvm_vcpu *vcpu, s64 adjustment)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tsvm->vmcb->control.tsc_offset += adjustment;\n\tif (is_guest_mode(vcpu))\n\t\tsvm->nested.hsave->control.tsc_offset += adjustment;\n\telse\n\t\ttrace_kvm_write_tsc_offset(vcpu->vcpu_id,\n\t\t\t\t     svm->vmcb->control.tsc_offset - adjustment,\n\t\t\t\t     svm->vmcb->control.tsc_offset);\n\n\tmark_dirty(svm->vmcb, VMCB_INTERCEPTS);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int nested = true;",
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_dirty",
          "args": [
            "svm->vmcb",
            "VMCB_INTERCEPTS"
          ],
          "line": 1064
        },
        "resolved": true,
        "details": {
          "function_name": "mark_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "289-292",
          "snippet": "static inline void mark_dirty(struct vmcb *vmcb, int bit)\n{\n\tvmcb->control.clean &= ~(1 << bit);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic inline void mark_dirty(struct vmcb *vmcb, int bit)\n{\n\tvmcb->control.clean &= ~(1 << bit);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_kvm_write_tsc_offset",
          "args": [
            "vcpu->vcpu_id",
            "svm->vmcb->control.tsc_offset - adjustment",
            "svm->vmcb->control.tsc_offset"
          ],
          "line": 1060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_guest_mode",
          "args": [
            "vcpu"
          ],
          "line": 1057
        },
        "resolved": true,
        "details": {
          "function_name": "is_guest_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "102-105",
          "snippet": "static inline bool is_guest_mode(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.hflags & HF_GUEST_MASK;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline bool is_guest_mode(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.hflags & HF_GUEST_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 1054
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "294-297",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int nested = true;\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic void svm_adjust_tsc_offset_guest(struct kvm_vcpu *vcpu, s64 adjustment)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tsvm->vmcb->control.tsc_offset += adjustment;\n\tif (is_guest_mode(vcpu))\n\t\tsvm->nested.hsave->control.tsc_offset += adjustment;\n\telse\n\t\ttrace_kvm_write_tsc_offset(vcpu->vcpu_id,\n\t\t\t\t     svm->vmcb->control.tsc_offset - adjustment,\n\t\t\t\t     svm->vmcb->control.tsc_offset);\n\n\tmark_dirty(svm->vmcb, VMCB_INTERCEPTS);\n}"
  },
  {
    "function_name": "svm_write_tsc_offset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "1033-1050",
    "snippet": "static void svm_write_tsc_offset(struct kvm_vcpu *vcpu, u64 offset)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tu64 g_tsc_offset = 0;\n\n\tif (is_guest_mode(vcpu)) {\n\t\tg_tsc_offset = svm->vmcb->control.tsc_offset -\n\t\t\t       svm->nested.hsave->control.tsc_offset;\n\t\tsvm->nested.hsave->control.tsc_offset = offset;\n\t} else\n\t\ttrace_kvm_write_tsc_offset(vcpu->vcpu_id,\n\t\t\t\t\t   svm->vmcb->control.tsc_offset,\n\t\t\t\t\t   offset);\n\n\tsvm->vmcb->control.tsc_offset = offset + g_tsc_offset;\n\n\tmark_dirty(svm->vmcb, VMCB_INTERCEPTS);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int nested = true;",
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_dirty",
          "args": [
            "svm->vmcb",
            "VMCB_INTERCEPTS"
          ],
          "line": 1049
        },
        "resolved": true,
        "details": {
          "function_name": "mark_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "289-292",
          "snippet": "static inline void mark_dirty(struct vmcb *vmcb, int bit)\n{\n\tvmcb->control.clean &= ~(1 << bit);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic inline void mark_dirty(struct vmcb *vmcb, int bit)\n{\n\tvmcb->control.clean &= ~(1 << bit);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_kvm_write_tsc_offset",
          "args": [
            "vcpu->vcpu_id",
            "svm->vmcb->control.tsc_offset",
            "offset"
          ],
          "line": 1043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_guest_mode",
          "args": [
            "vcpu"
          ],
          "line": 1038
        },
        "resolved": true,
        "details": {
          "function_name": "is_guest_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "102-105",
          "snippet": "static inline bool is_guest_mode(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.hflags & HF_GUEST_MASK;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline bool is_guest_mode(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.hflags & HF_GUEST_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 1035
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "294-297",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int nested = true;\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic void svm_write_tsc_offset(struct kvm_vcpu *vcpu, u64 offset)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tu64 g_tsc_offset = 0;\n\n\tif (is_guest_mode(vcpu)) {\n\t\tg_tsc_offset = svm->vmcb->control.tsc_offset -\n\t\t\t       svm->nested.hsave->control.tsc_offset;\n\t\tsvm->nested.hsave->control.tsc_offset = offset;\n\t} else\n\t\ttrace_kvm_write_tsc_offset(vcpu->vcpu_id,\n\t\t\t\t\t   svm->vmcb->control.tsc_offset,\n\t\t\t\t\t   offset);\n\n\tsvm->vmcb->control.tsc_offset = offset + g_tsc_offset;\n\n\tmark_dirty(svm->vmcb, VMCB_INTERCEPTS);\n}"
  },
  {
    "function_name": "svm_read_tsc_offset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "1026-1031",
    "snippet": "static u64 svm_read_tsc_offset(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\treturn svm->vmcb->control.tsc_offset;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 1028
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "294-297",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic u64 svm_read_tsc_offset(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\treturn svm->vmcb->control.tsc_offset;\n}"
  },
  {
    "function_name": "init_sys_seg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "1018-1024",
    "snippet": "static void init_sys_seg(struct vmcb_seg *seg, uint32_t type)\n{\n\tseg->selector = 0;\n\tseg->attrib = SVM_SELECTOR_P_MASK | type;\n\tseg->limit = 0xffff;\n\tseg->base = 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void init_sys_seg(struct vmcb_seg *seg, uint32_t type)\n{\n\tseg->selector = 0;\n\tseg->attrib = SVM_SELECTOR_P_MASK | type;\n\tseg->limit = 0xffff;\n\tseg->base = 0;\n}"
  },
  {
    "function_name": "init_seg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "1009-1016",
    "snippet": "static void init_seg(struct vmcb_seg *seg)\n{\n\tseg->selector = 0;\n\tseg->attrib = SVM_SELECTOR_P_MASK | SVM_SELECTOR_S_MASK |\n\t\t      SVM_SELECTOR_WRITE_MASK; /* Read/Write Data Segment */\n\tseg->limit = 0xffff;\n\tseg->base = 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void init_seg(struct vmcb_seg *seg)\n{\n\tseg->selector = 0;\n\tseg->attrib = SVM_SELECTOR_P_MASK | SVM_SELECTOR_S_MASK |\n\t\t      SVM_SELECTOR_WRITE_MASK; /* Read/Write Data Segment */\n\tseg->limit = 0xffff;\n\tseg->base = 0;\n}"
  },
  {
    "function_name": "svm_hardware_unsetup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "998-1007",
    "snippet": "static __exit void svm_hardware_unsetup(void)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu)\n\t\tsvm_cpu_uninit(cpu);\n\n\t__free_pages(pfn_to_page(iopm_base >> PAGE_SHIFT), IOPM_ALLOC_ORDER);\n\tiopm_base = 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define IOPM_ALLOC_ORDER 2"
    ],
    "globals_used": [
      "static unsigned long iopm_base;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__free_pages",
          "args": [
            "pfn_to_page(iopm_base >> PAGE_SHIFT)",
            "IOPM_ALLOC_ORDER"
          ],
          "line": 1005
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_to_page",
          "args": [
            "iopm_base >> PAGE_SHIFT"
          ],
          "line": 1005
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define IOPM_ALLOC_ORDER 2\n\nstatic unsigned long iopm_base;\n\nstatic __exit void svm_hardware_unsetup(void)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu)\n\t\tsvm_cpu_uninit(cpu);\n\n\t__free_pages(pfn_to_page(iopm_base >> PAGE_SHIFT), IOPM_ALLOC_ORDER);\n\tiopm_base = 0;\n}"
  },
  {
    "function_name": "svm_hardware_setup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "929-996",
    "snippet": "static __init int svm_hardware_setup(void)\n{\n\tint cpu;\n\tstruct page *iopm_pages;\n\tvoid *iopm_va;\n\tint r;\n\n\tiopm_pages = alloc_pages(GFP_KERNEL, IOPM_ALLOC_ORDER);\n\n\tif (!iopm_pages)\n\t\treturn -ENOMEM;\n\n\tiopm_va = page_address(iopm_pages);\n\tmemset(iopm_va, 0xff, PAGE_SIZE * (1 << IOPM_ALLOC_ORDER));\n\tiopm_base = page_to_pfn(iopm_pages) << PAGE_SHIFT;\n\n\tinit_msrpm_offsets();\n\n\tif (boot_cpu_has(X86_FEATURE_NX))\n\t\tkvm_enable_efer_bits(EFER_NX);\n\n\tif (boot_cpu_has(X86_FEATURE_FXSR_OPT))\n\t\tkvm_enable_efer_bits(EFER_FFXSR);\n\n\tif (boot_cpu_has(X86_FEATURE_TSCRATEMSR)) {\n\t\tkvm_has_tsc_control = true;\n\t\tkvm_max_tsc_scaling_ratio = TSC_RATIO_MAX;\n\t\tkvm_tsc_scaling_ratio_frac_bits = 32;\n\t}\n\n\tif (nested) {\n\t\tprintk(KERN_INFO \"kvm: Nested Virtualization enabled\\n\");\n\t\tkvm_enable_efer_bits(EFER_SVME | EFER_LMSLE);\n\t}\n\n\tfor_each_possible_cpu(cpu) {\n\t\tr = svm_cpu_init(cpu);\n\t\tif (r)\n\t\t\tgoto err;\n\t}\n\n\tif (!boot_cpu_has(X86_FEATURE_NPT))\n\t\tnpt_enabled = false;\n\n\tif (npt_enabled && !npt) {\n\t\tprintk(KERN_INFO \"kvm: Nested Paging disabled\\n\");\n\t\tnpt_enabled = false;\n\t}\n\n\tif (npt_enabled) {\n\t\tprintk(KERN_INFO \"kvm: Nested Paging enabled\\n\");\n\t\tkvm_enable_tdp();\n\t} else\n\t\tkvm_disable_tdp();\n\n\tif (avic && (!npt_enabled || !boot_cpu_has(X86_FEATURE_AVIC)))\n\t\tavic = false;\n\n\tif (avic)\n\t\tpr_info(\"AVIC enabled\\n\");\n\n\treturn 0;\n\nerr:\n\t__free_pages(iopm_pages, IOPM_ALLOC_ORDER);\n\tiopm_base = 0;\n\treturn r;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define TSC_RATIO_MAX\t\t0x000000ffffffffffULL",
      "#define IOPM_ALLOC_ORDER 2"
    ],
    "globals_used": [
      "static int npt = true;",
      "static int nested = true;",
      "static int avic;",
      "static unsigned long iopm_base;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__free_pages",
          "args": [
            "iopm_pages",
            "IOPM_ALLOC_ORDER"
          ],
          "line": 993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"AVIC enabled\\n\""
          ],
          "line": 988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "boot_cpu_has",
          "args": [
            "X86_FEATURE_AVIC"
          ],
          "line": 984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_disable_tdp",
          "args": [],
          "line": 982
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_disable_tdp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "4562-4565",
          "snippet": "void kvm_disable_tdp(void)\n{\n\ttdp_enabled = false;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "bool tdp_enabled = false;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nbool tdp_enabled = false;\n\nvoid kvm_disable_tdp(void)\n{\n\ttdp_enabled = false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_enable_tdp",
          "args": [],
          "line": 980
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_enable_tdp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "4556-4559",
          "snippet": "void kvm_enable_tdp(void)\n{\n\ttdp_enabled = true;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "bool tdp_enabled = false;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nbool tdp_enabled = false;\n\nvoid kvm_enable_tdp(void)\n{\n\ttdp_enabled = true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO \"kvm: Nested Paging enabled\\n\""
          ],
          "line": 979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO \"kvm: Nested Paging disabled\\n\""
          ],
          "line": 974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "boot_cpu_has",
          "args": [
            "X86_FEATURE_NPT"
          ],
          "line": 970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svm_cpu_init",
          "args": [
            "cpu"
          ],
          "line": 965
        },
        "resolved": true,
        "details": {
          "function_name": "svm_cpu_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "789-811",
          "snippet": "static int svm_cpu_init(int cpu)\n{\n\tstruct svm_cpu_data *sd;\n\tint r;\n\n\tsd = kzalloc(sizeof(struct svm_cpu_data), GFP_KERNEL);\n\tif (!sd)\n\t\treturn -ENOMEM;\n\tsd->cpu = cpu;\n\tsd->save_area = alloc_page(GFP_KERNEL);\n\tr = -ENOMEM;\n\tif (!sd->save_area)\n\t\tgoto err_1;\n\n\tper_cpu(svm_data, cpu) = sd;\n\n\treturn 0;\n\nerr_1:\n\tkfree(sd);\n\treturn r;\n\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct svm_cpu_data *, svm_data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic DEFINE_PER_CPU(struct svm_cpu_data *, svm_data);\n\nstatic int svm_cpu_init(int cpu)\n{\n\tstruct svm_cpu_data *sd;\n\tint r;\n\n\tsd = kzalloc(sizeof(struct svm_cpu_data), GFP_KERNEL);\n\tif (!sd)\n\t\treturn -ENOMEM;\n\tsd->cpu = cpu;\n\tsd->save_area = alloc_page(GFP_KERNEL);\n\tr = -ENOMEM;\n\tif (!sd->save_area)\n\t\tgoto err_1;\n\n\tper_cpu(svm_data, cpu) = sd;\n\n\treturn 0;\n\nerr_1:\n\tkfree(sd);\n\treturn r;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_enable_efer_bits",
          "args": [
            "EFER_SVME | EFER_LMSLE"
          ],
          "line": 961
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_enable_efer_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "1038-1041",
          "snippet": "void kvm_enable_efer_bits(u64 mask)\n{\n       efer_reserved_bits &= ~mask;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nvoid kvm_enable_efer_bits(u64 mask)\n{\n       efer_reserved_bits &= ~mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO \"kvm: Nested Virtualization enabled\\n\""
          ],
          "line": 960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "boot_cpu_has",
          "args": [
            "X86_FEATURE_TSCRATEMSR"
          ],
          "line": 953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "boot_cpu_has",
          "args": [
            "X86_FEATURE_FXSR_OPT"
          ],
          "line": 950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "boot_cpu_has",
          "args": [
            "X86_FEATURE_NX"
          ],
          "line": 947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_msrpm_offsets",
          "args": [],
          "line": 945
        },
        "resolved": true,
        "details": {
          "function_name": "init_msrpm_offsets",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "891-905",
          "snippet": "static void init_msrpm_offsets(void)\n{\n\tint i;\n\n\tmemset(msrpm_offsets, 0xff, sizeof(msrpm_offsets));\n\n\tfor (i = 0; direct_access_msrs[i].index != MSR_INVALID; i++) {\n\t\tu32 offset;\n\n\t\toffset = svm_msrpm_offset(direct_access_msrs[i].index);\n\t\tBUG_ON(offset == MSR_INVALID);\n\n\t\tadd_msr_offset(offset);\n\t}\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define MSR_INVALID\t\t\t0xffffffffU"
          ],
          "globals_used": [
            "static u32 msrpm_offsets[MSRPM_OFFSETS]",
            "static const struct svm_direct_access_msrs {\n\tu32 index;   /* Index of the MSR */\n\tbool always; /* True if intercept is always on */\n} direct_access_msrs[] = {\n\t{ .index = MSR_STAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_IA32_SYSENTER_CS,\t\t.always = true  },\n#ifdef CONFIG_X86_64\n\t{ .index = MSR_GS_BASE,\t\t\t\t.always = true  },\n\t{ .index = MSR_FS_BASE,\t\t\t\t.always = true  },\n\t{ .index = MSR_KERNEL_GS_BASE,\t\t\t.always = true  },\n\t{ .index = MSR_LSTAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_CSTAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_SYSCALL_MASK,\t\t\t.always = true  },\n#endif\n\t{ .index = MSR_IA32_LASTBRANCHFROMIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTBRANCHTOIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTINTFROMIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTINTTOIP,\t\t.always = false },\n\t{ .index = MSR_INVALID,\t\t\t\t.always = false },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define MSR_INVALID\t\t\t0xffffffffU\n\nstatic u32 msrpm_offsets[MSRPM_OFFSETS];\nstatic const struct svm_direct_access_msrs {\n\tu32 index;   /* Index of the MSR */\n\tbool always; /* True if intercept is always on */\n} direct_access_msrs[] = {\n\t{ .index = MSR_STAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_IA32_SYSENTER_CS,\t\t.always = true  },\n#ifdef CONFIG_X86_64\n\t{ .index = MSR_GS_BASE,\t\t\t\t.always = true  },\n\t{ .index = MSR_FS_BASE,\t\t\t\t.always = true  },\n\t{ .index = MSR_KERNEL_GS_BASE,\t\t\t.always = true  },\n\t{ .index = MSR_LSTAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_CSTAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_SYSCALL_MASK,\t\t\t.always = true  },\n#endif\n\t{ .index = MSR_IA32_LASTBRANCHFROMIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTBRANCHTOIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTINTFROMIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTINTTOIP,\t\t.always = false },\n\t{ .index = MSR_INVALID,\t\t\t\t.always = false },\n};\n\nstatic void init_msrpm_offsets(void)\n{\n\tint i;\n\n\tmemset(msrpm_offsets, 0xff, sizeof(msrpm_offsets));\n\n\tfor (i = 0; direct_access_msrs[i].index != MSR_INVALID; i++) {\n\t\tu32 offset;\n\n\t\toffset = svm_msrpm_offset(direct_access_msrs[i].index);\n\t\tBUG_ON(offset == MSR_INVALID);\n\n\t\tadd_msr_offset(offset);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_to_pfn",
          "args": [
            "iopm_pages"
          ],
          "line": 943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "iopm_va",
            "0xff",
            "PAGE_SIZE * (1 << IOPM_ALLOC_ORDER)"
          ],
          "line": 942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "iopm_pages"
          ],
          "line": 941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_pages",
          "args": [
            "GFP_KERNEL",
            "IOPM_ALLOC_ORDER"
          ],
          "line": 936
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define TSC_RATIO_MAX\t\t0x000000ffffffffffULL\n#define IOPM_ALLOC_ORDER 2\n\nstatic int npt = true;\nstatic int nested = true;\nstatic int avic;\nstatic unsigned long iopm_base;\n\nstatic __init int svm_hardware_setup(void)\n{\n\tint cpu;\n\tstruct page *iopm_pages;\n\tvoid *iopm_va;\n\tint r;\n\n\tiopm_pages = alloc_pages(GFP_KERNEL, IOPM_ALLOC_ORDER);\n\n\tif (!iopm_pages)\n\t\treturn -ENOMEM;\n\n\tiopm_va = page_address(iopm_pages);\n\tmemset(iopm_va, 0xff, PAGE_SIZE * (1 << IOPM_ALLOC_ORDER));\n\tiopm_base = page_to_pfn(iopm_pages) << PAGE_SHIFT;\n\n\tinit_msrpm_offsets();\n\n\tif (boot_cpu_has(X86_FEATURE_NX))\n\t\tkvm_enable_efer_bits(EFER_NX);\n\n\tif (boot_cpu_has(X86_FEATURE_FXSR_OPT))\n\t\tkvm_enable_efer_bits(EFER_FFXSR);\n\n\tif (boot_cpu_has(X86_FEATURE_TSCRATEMSR)) {\n\t\tkvm_has_tsc_control = true;\n\t\tkvm_max_tsc_scaling_ratio = TSC_RATIO_MAX;\n\t\tkvm_tsc_scaling_ratio_frac_bits = 32;\n\t}\n\n\tif (nested) {\n\t\tprintk(KERN_INFO \"kvm: Nested Virtualization enabled\\n\");\n\t\tkvm_enable_efer_bits(EFER_SVME | EFER_LMSLE);\n\t}\n\n\tfor_each_possible_cpu(cpu) {\n\t\tr = svm_cpu_init(cpu);\n\t\tif (r)\n\t\t\tgoto err;\n\t}\n\n\tif (!boot_cpu_has(X86_FEATURE_NPT))\n\t\tnpt_enabled = false;\n\n\tif (npt_enabled && !npt) {\n\t\tprintk(KERN_INFO \"kvm: Nested Paging disabled\\n\");\n\t\tnpt_enabled = false;\n\t}\n\n\tif (npt_enabled) {\n\t\tprintk(KERN_INFO \"kvm: Nested Paging enabled\\n\");\n\t\tkvm_enable_tdp();\n\t} else\n\t\tkvm_disable_tdp();\n\n\tif (avic && (!npt_enabled || !boot_cpu_has(X86_FEATURE_AVIC)))\n\t\tavic = false;\n\n\tif (avic)\n\t\tpr_info(\"AVIC enabled\\n\");\n\n\treturn 0;\n\nerr:\n\t__free_pages(iopm_pages, IOPM_ALLOC_ORDER);\n\tiopm_base = 0;\n\treturn r;\n}"
  },
  {
    "function_name": "svm_disable_lbrv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "918-927",
    "snippet": "static void svm_disable_lbrv(struct vcpu_svm *svm)\n{\n\tu32 *msrpm = svm->msrpm;\n\n\tsvm->vmcb->control.lbr_ctl = 0;\n\tset_msr_interception(msrpm, MSR_IA32_LASTBRANCHFROMIP, 0, 0);\n\tset_msr_interception(msrpm, MSR_IA32_LASTBRANCHTOIP, 0, 0);\n\tset_msr_interception(msrpm, MSR_IA32_LASTINTFROMIP, 0, 0);\n\tset_msr_interception(msrpm, MSR_IA32_LASTINTTOIP, 0, 0);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_msr_interception",
          "args": [
            "msrpm",
            "MSR_IA32_LASTINTTOIP",
            "0",
            "0"
          ],
          "line": 926
        },
        "resolved": true,
        "details": {
          "function_name": "set_msr_interception",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "824-848",
          "snippet": "static void set_msr_interception(u32 *msrpm, unsigned msr,\n\t\t\t\t int read, int write)\n{\n\tu8 bit_read, bit_write;\n\tunsigned long tmp;\n\tu32 offset;\n\n\t/*\n\t * If this warning triggers extend the direct_access_msrs list at the\n\t * beginning of the file\n\t */\n\tWARN_ON(!valid_msr_intercept(msr));\n\n\toffset    = svm_msrpm_offset(msr);\n\tbit_read  = 2 * (msr & 0x0f);\n\tbit_write = 2 * (msr & 0x0f) + 1;\n\ttmp       = msrpm[offset];\n\n\tBUG_ON(offset == MSR_INVALID);\n\n\tread  ? clear_bit(bit_read,  &tmp) : set_bit(bit_read,  &tmp);\n\twrite ? clear_bit(bit_write, &tmp) : set_bit(bit_write, &tmp);\n\n\tmsrpm[offset] = tmp;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define MSR_INVALID\t\t\t0xffffffffU"
          ],
          "globals_used": [
            "static const struct svm_direct_access_msrs {\n\tu32 index;   /* Index of the MSR */\n\tbool always; /* True if intercept is always on */\n} direct_access_msrs[] = {\n\t{ .index = MSR_STAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_IA32_SYSENTER_CS,\t\t.always = true  },\n#ifdef CONFIG_X86_64\n\t{ .index = MSR_GS_BASE,\t\t\t\t.always = true  },\n\t{ .index = MSR_FS_BASE,\t\t\t\t.always = true  },\n\t{ .index = MSR_KERNEL_GS_BASE,\t\t\t.always = true  },\n\t{ .index = MSR_LSTAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_CSTAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_SYSCALL_MASK,\t\t\t.always = true  },\n#endif\n\t{ .index = MSR_IA32_LASTBRANCHFROMIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTBRANCHTOIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTINTFROMIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTINTTOIP,\t\t.always = false },\n\t{ .index = MSR_INVALID,\t\t\t\t.always = false },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define MSR_INVALID\t\t\t0xffffffffU\n\nstatic const struct svm_direct_access_msrs {\n\tu32 index;   /* Index of the MSR */\n\tbool always; /* True if intercept is always on */\n} direct_access_msrs[] = {\n\t{ .index = MSR_STAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_IA32_SYSENTER_CS,\t\t.always = true  },\n#ifdef CONFIG_X86_64\n\t{ .index = MSR_GS_BASE,\t\t\t\t.always = true  },\n\t{ .index = MSR_FS_BASE,\t\t\t\t.always = true  },\n\t{ .index = MSR_KERNEL_GS_BASE,\t\t\t.always = true  },\n\t{ .index = MSR_LSTAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_CSTAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_SYSCALL_MASK,\t\t\t.always = true  },\n#endif\n\t{ .index = MSR_IA32_LASTBRANCHFROMIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTBRANCHTOIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTINTFROMIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTINTTOIP,\t\t.always = false },\n\t{ .index = MSR_INVALID,\t\t\t\t.always = false },\n};\n\nstatic void set_msr_interception(u32 *msrpm, unsigned msr,\n\t\t\t\t int read, int write)\n{\n\tu8 bit_read, bit_write;\n\tunsigned long tmp;\n\tu32 offset;\n\n\t/*\n\t * If this warning triggers extend the direct_access_msrs list at the\n\t * beginning of the file\n\t */\n\tWARN_ON(!valid_msr_intercept(msr));\n\n\toffset    = svm_msrpm_offset(msr);\n\tbit_read  = 2 * (msr & 0x0f);\n\tbit_write = 2 * (msr & 0x0f) + 1;\n\ttmp       = msrpm[offset];\n\n\tBUG_ON(offset == MSR_INVALID);\n\n\tread  ? clear_bit(bit_read,  &tmp) : set_bit(bit_read,  &tmp);\n\twrite ? clear_bit(bit_write, &tmp) : set_bit(bit_write, &tmp);\n\n\tmsrpm[offset] = tmp;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic void svm_disable_lbrv(struct vcpu_svm *svm)\n{\n\tu32 *msrpm = svm->msrpm;\n\n\tsvm->vmcb->control.lbr_ctl = 0;\n\tset_msr_interception(msrpm, MSR_IA32_LASTBRANCHFROMIP, 0, 0);\n\tset_msr_interception(msrpm, MSR_IA32_LASTBRANCHTOIP, 0, 0);\n\tset_msr_interception(msrpm, MSR_IA32_LASTINTFROMIP, 0, 0);\n\tset_msr_interception(msrpm, MSR_IA32_LASTINTTOIP, 0, 0);\n}"
  },
  {
    "function_name": "svm_enable_lbrv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "907-916",
    "snippet": "static void svm_enable_lbrv(struct vcpu_svm *svm)\n{\n\tu32 *msrpm = svm->msrpm;\n\n\tsvm->vmcb->control.lbr_ctl = 1;\n\tset_msr_interception(msrpm, MSR_IA32_LASTBRANCHFROMIP, 1, 1);\n\tset_msr_interception(msrpm, MSR_IA32_LASTBRANCHTOIP, 1, 1);\n\tset_msr_interception(msrpm, MSR_IA32_LASTINTFROMIP, 1, 1);\n\tset_msr_interception(msrpm, MSR_IA32_LASTINTTOIP, 1, 1);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_msr_interception",
          "args": [
            "msrpm",
            "MSR_IA32_LASTINTTOIP",
            "1",
            "1"
          ],
          "line": 915
        },
        "resolved": true,
        "details": {
          "function_name": "set_msr_interception",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "824-848",
          "snippet": "static void set_msr_interception(u32 *msrpm, unsigned msr,\n\t\t\t\t int read, int write)\n{\n\tu8 bit_read, bit_write;\n\tunsigned long tmp;\n\tu32 offset;\n\n\t/*\n\t * If this warning triggers extend the direct_access_msrs list at the\n\t * beginning of the file\n\t */\n\tWARN_ON(!valid_msr_intercept(msr));\n\n\toffset    = svm_msrpm_offset(msr);\n\tbit_read  = 2 * (msr & 0x0f);\n\tbit_write = 2 * (msr & 0x0f) + 1;\n\ttmp       = msrpm[offset];\n\n\tBUG_ON(offset == MSR_INVALID);\n\n\tread  ? clear_bit(bit_read,  &tmp) : set_bit(bit_read,  &tmp);\n\twrite ? clear_bit(bit_write, &tmp) : set_bit(bit_write, &tmp);\n\n\tmsrpm[offset] = tmp;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define MSR_INVALID\t\t\t0xffffffffU"
          ],
          "globals_used": [
            "static const struct svm_direct_access_msrs {\n\tu32 index;   /* Index of the MSR */\n\tbool always; /* True if intercept is always on */\n} direct_access_msrs[] = {\n\t{ .index = MSR_STAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_IA32_SYSENTER_CS,\t\t.always = true  },\n#ifdef CONFIG_X86_64\n\t{ .index = MSR_GS_BASE,\t\t\t\t.always = true  },\n\t{ .index = MSR_FS_BASE,\t\t\t\t.always = true  },\n\t{ .index = MSR_KERNEL_GS_BASE,\t\t\t.always = true  },\n\t{ .index = MSR_LSTAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_CSTAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_SYSCALL_MASK,\t\t\t.always = true  },\n#endif\n\t{ .index = MSR_IA32_LASTBRANCHFROMIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTBRANCHTOIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTINTFROMIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTINTTOIP,\t\t.always = false },\n\t{ .index = MSR_INVALID,\t\t\t\t.always = false },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define MSR_INVALID\t\t\t0xffffffffU\n\nstatic const struct svm_direct_access_msrs {\n\tu32 index;   /* Index of the MSR */\n\tbool always; /* True if intercept is always on */\n} direct_access_msrs[] = {\n\t{ .index = MSR_STAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_IA32_SYSENTER_CS,\t\t.always = true  },\n#ifdef CONFIG_X86_64\n\t{ .index = MSR_GS_BASE,\t\t\t\t.always = true  },\n\t{ .index = MSR_FS_BASE,\t\t\t\t.always = true  },\n\t{ .index = MSR_KERNEL_GS_BASE,\t\t\t.always = true  },\n\t{ .index = MSR_LSTAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_CSTAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_SYSCALL_MASK,\t\t\t.always = true  },\n#endif\n\t{ .index = MSR_IA32_LASTBRANCHFROMIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTBRANCHTOIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTINTFROMIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTINTTOIP,\t\t.always = false },\n\t{ .index = MSR_INVALID,\t\t\t\t.always = false },\n};\n\nstatic void set_msr_interception(u32 *msrpm, unsigned msr,\n\t\t\t\t int read, int write)\n{\n\tu8 bit_read, bit_write;\n\tunsigned long tmp;\n\tu32 offset;\n\n\t/*\n\t * If this warning triggers extend the direct_access_msrs list at the\n\t * beginning of the file\n\t */\n\tWARN_ON(!valid_msr_intercept(msr));\n\n\toffset    = svm_msrpm_offset(msr);\n\tbit_read  = 2 * (msr & 0x0f);\n\tbit_write = 2 * (msr & 0x0f) + 1;\n\ttmp       = msrpm[offset];\n\n\tBUG_ON(offset == MSR_INVALID);\n\n\tread  ? clear_bit(bit_read,  &tmp) : set_bit(bit_read,  &tmp);\n\twrite ? clear_bit(bit_write, &tmp) : set_bit(bit_write, &tmp);\n\n\tmsrpm[offset] = tmp;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic void svm_enable_lbrv(struct vcpu_svm *svm)\n{\n\tu32 *msrpm = svm->msrpm;\n\n\tsvm->vmcb->control.lbr_ctl = 1;\n\tset_msr_interception(msrpm, MSR_IA32_LASTBRANCHFROMIP, 1, 1);\n\tset_msr_interception(msrpm, MSR_IA32_LASTBRANCHTOIP, 1, 1);\n\tset_msr_interception(msrpm, MSR_IA32_LASTINTFROMIP, 1, 1);\n\tset_msr_interception(msrpm, MSR_IA32_LASTINTTOIP, 1, 1);\n}"
  },
  {
    "function_name": "init_msrpm_offsets",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "891-905",
    "snippet": "static void init_msrpm_offsets(void)\n{\n\tint i;\n\n\tmemset(msrpm_offsets, 0xff, sizeof(msrpm_offsets));\n\n\tfor (i = 0; direct_access_msrs[i].index != MSR_INVALID; i++) {\n\t\tu32 offset;\n\n\t\toffset = svm_msrpm_offset(direct_access_msrs[i].index);\n\t\tBUG_ON(offset == MSR_INVALID);\n\n\t\tadd_msr_offset(offset);\n\t}\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define MSR_INVALID\t\t\t0xffffffffU"
    ],
    "globals_used": [
      "static u32 msrpm_offsets[MSRPM_OFFSETS]",
      "static const struct svm_direct_access_msrs {\n\tu32 index;   /* Index of the MSR */\n\tbool always; /* True if intercept is always on */\n} direct_access_msrs[] = {\n\t{ .index = MSR_STAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_IA32_SYSENTER_CS,\t\t.always = true  },\n#ifdef CONFIG_X86_64\n\t{ .index = MSR_GS_BASE,\t\t\t\t.always = true  },\n\t{ .index = MSR_FS_BASE,\t\t\t\t.always = true  },\n\t{ .index = MSR_KERNEL_GS_BASE,\t\t\t.always = true  },\n\t{ .index = MSR_LSTAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_CSTAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_SYSCALL_MASK,\t\t\t.always = true  },\n#endif\n\t{ .index = MSR_IA32_LASTBRANCHFROMIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTBRANCHTOIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTINTFROMIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTINTTOIP,\t\t.always = false },\n\t{ .index = MSR_INVALID,\t\t\t\t.always = false },\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "add_msr_offset",
          "args": [
            "offset"
          ],
          "line": 903
        },
        "resolved": true,
        "details": {
          "function_name": "add_msr_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "864-889",
          "snippet": "static void add_msr_offset(u32 offset)\n{\n\tint i;\n\n\tfor (i = 0; i < MSRPM_OFFSETS; ++i) {\n\n\t\t/* Offset already in list? */\n\t\tif (msrpm_offsets[i] == offset)\n\t\t\treturn;\n\n\t\t/* Slot used by another offset? */\n\t\tif (msrpm_offsets[i] != MSR_INVALID)\n\t\t\tcontinue;\n\n\t\t/* Add offset to list */\n\t\tmsrpm_offsets[i] = offset;\n\n\t\treturn;\n\t}\n\n\t/*\n\t * If this BUG triggers the msrpm_offsets table has an overflow. Just\n\t * increase MSRPM_OFFSETS in this case.\n\t */\n\tBUG();\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define MSR_INVALID\t\t\t0xffffffffU",
            "#define MSRPM_OFFSETS\t16"
          ],
          "globals_used": [
            "static u32 msrpm_offsets[MSRPM_OFFSETS]"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define MSR_INVALID\t\t\t0xffffffffU\n#define MSRPM_OFFSETS\t16\n\nstatic u32 msrpm_offsets[MSRPM_OFFSETS];\n\nstatic void add_msr_offset(u32 offset)\n{\n\tint i;\n\n\tfor (i = 0; i < MSRPM_OFFSETS; ++i) {\n\n\t\t/* Offset already in list? */\n\t\tif (msrpm_offsets[i] == offset)\n\t\t\treturn;\n\n\t\t/* Slot used by another offset? */\n\t\tif (msrpm_offsets[i] != MSR_INVALID)\n\t\t\tcontinue;\n\n\t\t/* Add offset to list */\n\t\tmsrpm_offsets[i] = offset;\n\n\t\treturn;\n\t}\n\n\t/*\n\t * If this BUG triggers the msrpm_offsets table has an overflow. Just\n\t * increase MSRPM_OFFSETS in this case.\n\t */\n\tBUG();\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "offset == MSR_INVALID"
          ],
          "line": 901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svm_msrpm_offset",
          "args": [
            "direct_access_msrs[i].index"
          ],
          "line": 900
        },
        "resolved": true,
        "details": {
          "function_name": "svm_msrpm_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "488-507",
          "snippet": "static u32 svm_msrpm_offset(u32 msr)\n{\n\tu32 offset;\n\tint i;\n\n\tfor (i = 0; i < NUM_MSR_MAPS; i++) {\n\t\tif (msr < msrpm_ranges[i] ||\n\t\t    msr >= msrpm_ranges[i] + MSRS_IN_RANGE)\n\t\t\tcontinue;\n\n\t\toffset  = (msr - msrpm_ranges[i]) / 4; /* 4 msrs per u8 */\n\t\toffset += (i * MSRS_RANGE_SIZE);       /* add range offset */\n\n\t\t/* Now we have the u8 offset - but need the u32 offset */\n\t\treturn offset / 4;\n\t}\n\n\t/* MSR not in any range */\n\treturn MSR_INVALID;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define MSRS_IN_RANGE (MSRS_RANGE_SIZE * 8 / 2)",
            "#define MSRS_RANGE_SIZE 2048",
            "#define NUM_MSR_MAPS ARRAY_SIZE(msrpm_ranges)",
            "#define MSR_INVALID\t\t\t0xffffffffU"
          ],
          "globals_used": [
            "static const u32 msrpm_ranges[] = {0, 0xc0000000, 0xc0010000};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define MSRS_IN_RANGE (MSRS_RANGE_SIZE * 8 / 2)\n#define MSRS_RANGE_SIZE 2048\n#define NUM_MSR_MAPS ARRAY_SIZE(msrpm_ranges)\n#define MSR_INVALID\t\t\t0xffffffffU\n\nstatic const u32 msrpm_ranges[] = {0, 0xc0000000, 0xc0010000};\n\nstatic u32 svm_msrpm_offset(u32 msr)\n{\n\tu32 offset;\n\tint i;\n\n\tfor (i = 0; i < NUM_MSR_MAPS; i++) {\n\t\tif (msr < msrpm_ranges[i] ||\n\t\t    msr >= msrpm_ranges[i] + MSRS_IN_RANGE)\n\t\t\tcontinue;\n\n\t\toffset  = (msr - msrpm_ranges[i]) / 4; /* 4 msrs per u8 */\n\t\toffset += (i * MSRS_RANGE_SIZE);       /* add range offset */\n\n\t\t/* Now we have the u8 offset - but need the u32 offset */\n\t\treturn offset / 4;\n\t}\n\n\t/* MSR not in any range */\n\treturn MSR_INVALID;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "msrpm_offsets",
            "0xff",
            "sizeof(msrpm_offsets)"
          ],
          "line": 895
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define MSR_INVALID\t\t\t0xffffffffU\n\nstatic u32 msrpm_offsets[MSRPM_OFFSETS];\nstatic const struct svm_direct_access_msrs {\n\tu32 index;   /* Index of the MSR */\n\tbool always; /* True if intercept is always on */\n} direct_access_msrs[] = {\n\t{ .index = MSR_STAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_IA32_SYSENTER_CS,\t\t.always = true  },\n#ifdef CONFIG_X86_64\n\t{ .index = MSR_GS_BASE,\t\t\t\t.always = true  },\n\t{ .index = MSR_FS_BASE,\t\t\t\t.always = true  },\n\t{ .index = MSR_KERNEL_GS_BASE,\t\t\t.always = true  },\n\t{ .index = MSR_LSTAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_CSTAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_SYSCALL_MASK,\t\t\t.always = true  },\n#endif\n\t{ .index = MSR_IA32_LASTBRANCHFROMIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTBRANCHTOIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTINTFROMIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTINTTOIP,\t\t.always = false },\n\t{ .index = MSR_INVALID,\t\t\t\t.always = false },\n};\n\nstatic void init_msrpm_offsets(void)\n{\n\tint i;\n\n\tmemset(msrpm_offsets, 0xff, sizeof(msrpm_offsets));\n\n\tfor (i = 0; direct_access_msrs[i].index != MSR_INVALID; i++) {\n\t\tu32 offset;\n\n\t\toffset = svm_msrpm_offset(direct_access_msrs[i].index);\n\t\tBUG_ON(offset == MSR_INVALID);\n\n\t\tadd_msr_offset(offset);\n\t}\n}"
  },
  {
    "function_name": "add_msr_offset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "864-889",
    "snippet": "static void add_msr_offset(u32 offset)\n{\n\tint i;\n\n\tfor (i = 0; i < MSRPM_OFFSETS; ++i) {\n\n\t\t/* Offset already in list? */\n\t\tif (msrpm_offsets[i] == offset)\n\t\t\treturn;\n\n\t\t/* Slot used by another offset? */\n\t\tif (msrpm_offsets[i] != MSR_INVALID)\n\t\t\tcontinue;\n\n\t\t/* Add offset to list */\n\t\tmsrpm_offsets[i] = offset;\n\n\t\treturn;\n\t}\n\n\t/*\n\t * If this BUG triggers the msrpm_offsets table has an overflow. Just\n\t * increase MSRPM_OFFSETS in this case.\n\t */\n\tBUG();\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define MSR_INVALID\t\t\t0xffffffffU",
      "#define MSRPM_OFFSETS\t16"
    ],
    "globals_used": [
      "static u32 msrpm_offsets[MSRPM_OFFSETS]"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 888
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define MSR_INVALID\t\t\t0xffffffffU\n#define MSRPM_OFFSETS\t16\n\nstatic u32 msrpm_offsets[MSRPM_OFFSETS];\n\nstatic void add_msr_offset(u32 offset)\n{\n\tint i;\n\n\tfor (i = 0; i < MSRPM_OFFSETS; ++i) {\n\n\t\t/* Offset already in list? */\n\t\tif (msrpm_offsets[i] == offset)\n\t\t\treturn;\n\n\t\t/* Slot used by another offset? */\n\t\tif (msrpm_offsets[i] != MSR_INVALID)\n\t\t\tcontinue;\n\n\t\t/* Add offset to list */\n\t\tmsrpm_offsets[i] = offset;\n\n\t\treturn;\n\t}\n\n\t/*\n\t * If this BUG triggers the msrpm_offsets table has an overflow. Just\n\t * increase MSRPM_OFFSETS in this case.\n\t */\n\tBUG();\n}"
  },
  {
    "function_name": "svm_vcpu_init_msrpm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "850-862",
    "snippet": "static void svm_vcpu_init_msrpm(u32 *msrpm)\n{\n\tint i;\n\n\tmemset(msrpm, 0xff, PAGE_SIZE * (1 << MSRPM_ALLOC_ORDER));\n\n\tfor (i = 0; direct_access_msrs[i].index != MSR_INVALID; i++) {\n\t\tif (!direct_access_msrs[i].always)\n\t\t\tcontinue;\n\n\t\tset_msr_interception(msrpm, direct_access_msrs[i].index, 1, 1);\n\t}\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define MSR_INVALID\t\t\t0xffffffffU",
      "#define MSRPM_ALLOC_ORDER 1"
    ],
    "globals_used": [
      "static const struct svm_direct_access_msrs {\n\tu32 index;   /* Index of the MSR */\n\tbool always; /* True if intercept is always on */\n} direct_access_msrs[] = {\n\t{ .index = MSR_STAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_IA32_SYSENTER_CS,\t\t.always = true  },\n#ifdef CONFIG_X86_64\n\t{ .index = MSR_GS_BASE,\t\t\t\t.always = true  },\n\t{ .index = MSR_FS_BASE,\t\t\t\t.always = true  },\n\t{ .index = MSR_KERNEL_GS_BASE,\t\t\t.always = true  },\n\t{ .index = MSR_LSTAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_CSTAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_SYSCALL_MASK,\t\t\t.always = true  },\n#endif\n\t{ .index = MSR_IA32_LASTBRANCHFROMIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTBRANCHTOIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTINTFROMIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTINTTOIP,\t\t.always = false },\n\t{ .index = MSR_INVALID,\t\t\t\t.always = false },\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_msr_interception",
          "args": [
            "msrpm",
            "direct_access_msrs[i].index",
            "1",
            "1"
          ],
          "line": 860
        },
        "resolved": true,
        "details": {
          "function_name": "set_msr_interception",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "824-848",
          "snippet": "static void set_msr_interception(u32 *msrpm, unsigned msr,\n\t\t\t\t int read, int write)\n{\n\tu8 bit_read, bit_write;\n\tunsigned long tmp;\n\tu32 offset;\n\n\t/*\n\t * If this warning triggers extend the direct_access_msrs list at the\n\t * beginning of the file\n\t */\n\tWARN_ON(!valid_msr_intercept(msr));\n\n\toffset    = svm_msrpm_offset(msr);\n\tbit_read  = 2 * (msr & 0x0f);\n\tbit_write = 2 * (msr & 0x0f) + 1;\n\ttmp       = msrpm[offset];\n\n\tBUG_ON(offset == MSR_INVALID);\n\n\tread  ? clear_bit(bit_read,  &tmp) : set_bit(bit_read,  &tmp);\n\twrite ? clear_bit(bit_write, &tmp) : set_bit(bit_write, &tmp);\n\n\tmsrpm[offset] = tmp;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define MSR_INVALID\t\t\t0xffffffffU"
          ],
          "globals_used": [
            "static const struct svm_direct_access_msrs {\n\tu32 index;   /* Index of the MSR */\n\tbool always; /* True if intercept is always on */\n} direct_access_msrs[] = {\n\t{ .index = MSR_STAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_IA32_SYSENTER_CS,\t\t.always = true  },\n#ifdef CONFIG_X86_64\n\t{ .index = MSR_GS_BASE,\t\t\t\t.always = true  },\n\t{ .index = MSR_FS_BASE,\t\t\t\t.always = true  },\n\t{ .index = MSR_KERNEL_GS_BASE,\t\t\t.always = true  },\n\t{ .index = MSR_LSTAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_CSTAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_SYSCALL_MASK,\t\t\t.always = true  },\n#endif\n\t{ .index = MSR_IA32_LASTBRANCHFROMIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTBRANCHTOIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTINTFROMIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTINTTOIP,\t\t.always = false },\n\t{ .index = MSR_INVALID,\t\t\t\t.always = false },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define MSR_INVALID\t\t\t0xffffffffU\n\nstatic const struct svm_direct_access_msrs {\n\tu32 index;   /* Index of the MSR */\n\tbool always; /* True if intercept is always on */\n} direct_access_msrs[] = {\n\t{ .index = MSR_STAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_IA32_SYSENTER_CS,\t\t.always = true  },\n#ifdef CONFIG_X86_64\n\t{ .index = MSR_GS_BASE,\t\t\t\t.always = true  },\n\t{ .index = MSR_FS_BASE,\t\t\t\t.always = true  },\n\t{ .index = MSR_KERNEL_GS_BASE,\t\t\t.always = true  },\n\t{ .index = MSR_LSTAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_CSTAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_SYSCALL_MASK,\t\t\t.always = true  },\n#endif\n\t{ .index = MSR_IA32_LASTBRANCHFROMIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTBRANCHTOIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTINTFROMIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTINTTOIP,\t\t.always = false },\n\t{ .index = MSR_INVALID,\t\t\t\t.always = false },\n};\n\nstatic void set_msr_interception(u32 *msrpm, unsigned msr,\n\t\t\t\t int read, int write)\n{\n\tu8 bit_read, bit_write;\n\tunsigned long tmp;\n\tu32 offset;\n\n\t/*\n\t * If this warning triggers extend the direct_access_msrs list at the\n\t * beginning of the file\n\t */\n\tWARN_ON(!valid_msr_intercept(msr));\n\n\toffset    = svm_msrpm_offset(msr);\n\tbit_read  = 2 * (msr & 0x0f);\n\tbit_write = 2 * (msr & 0x0f) + 1;\n\ttmp       = msrpm[offset];\n\n\tBUG_ON(offset == MSR_INVALID);\n\n\tread  ? clear_bit(bit_read,  &tmp) : set_bit(bit_read,  &tmp);\n\twrite ? clear_bit(bit_write, &tmp) : set_bit(bit_write, &tmp);\n\n\tmsrpm[offset] = tmp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "msrpm",
            "0xff",
            "PAGE_SIZE * (1 << MSRPM_ALLOC_ORDER)"
          ],
          "line": 854
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define MSR_INVALID\t\t\t0xffffffffU\n#define MSRPM_ALLOC_ORDER 1\n\nstatic const struct svm_direct_access_msrs {\n\tu32 index;   /* Index of the MSR */\n\tbool always; /* True if intercept is always on */\n} direct_access_msrs[] = {\n\t{ .index = MSR_STAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_IA32_SYSENTER_CS,\t\t.always = true  },\n#ifdef CONFIG_X86_64\n\t{ .index = MSR_GS_BASE,\t\t\t\t.always = true  },\n\t{ .index = MSR_FS_BASE,\t\t\t\t.always = true  },\n\t{ .index = MSR_KERNEL_GS_BASE,\t\t\t.always = true  },\n\t{ .index = MSR_LSTAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_CSTAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_SYSCALL_MASK,\t\t\t.always = true  },\n#endif\n\t{ .index = MSR_IA32_LASTBRANCHFROMIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTBRANCHTOIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTINTFROMIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTINTTOIP,\t\t.always = false },\n\t{ .index = MSR_INVALID,\t\t\t\t.always = false },\n};\n\nstatic void svm_vcpu_init_msrpm(u32 *msrpm)\n{\n\tint i;\n\n\tmemset(msrpm, 0xff, PAGE_SIZE * (1 << MSRPM_ALLOC_ORDER));\n\n\tfor (i = 0; direct_access_msrs[i].index != MSR_INVALID; i++) {\n\t\tif (!direct_access_msrs[i].always)\n\t\t\tcontinue;\n\n\t\tset_msr_interception(msrpm, direct_access_msrs[i].index, 1, 1);\n\t}\n}"
  },
  {
    "function_name": "set_msr_interception",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "824-848",
    "snippet": "static void set_msr_interception(u32 *msrpm, unsigned msr,\n\t\t\t\t int read, int write)\n{\n\tu8 bit_read, bit_write;\n\tunsigned long tmp;\n\tu32 offset;\n\n\t/*\n\t * If this warning triggers extend the direct_access_msrs list at the\n\t * beginning of the file\n\t */\n\tWARN_ON(!valid_msr_intercept(msr));\n\n\toffset    = svm_msrpm_offset(msr);\n\tbit_read  = 2 * (msr & 0x0f);\n\tbit_write = 2 * (msr & 0x0f) + 1;\n\ttmp       = msrpm[offset];\n\n\tBUG_ON(offset == MSR_INVALID);\n\n\tread  ? clear_bit(bit_read,  &tmp) : set_bit(bit_read,  &tmp);\n\twrite ? clear_bit(bit_write, &tmp) : set_bit(bit_write, &tmp);\n\n\tmsrpm[offset] = tmp;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define MSR_INVALID\t\t\t0xffffffffU"
    ],
    "globals_used": [
      "static const struct svm_direct_access_msrs {\n\tu32 index;   /* Index of the MSR */\n\tbool always; /* True if intercept is always on */\n} direct_access_msrs[] = {\n\t{ .index = MSR_STAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_IA32_SYSENTER_CS,\t\t.always = true  },\n#ifdef CONFIG_X86_64\n\t{ .index = MSR_GS_BASE,\t\t\t\t.always = true  },\n\t{ .index = MSR_FS_BASE,\t\t\t\t.always = true  },\n\t{ .index = MSR_KERNEL_GS_BASE,\t\t\t.always = true  },\n\t{ .index = MSR_LSTAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_CSTAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_SYSCALL_MASK,\t\t\t.always = true  },\n#endif\n\t{ .index = MSR_IA32_LASTBRANCHFROMIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTBRANCHTOIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTINTFROMIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTINTTOIP,\t\t.always = false },\n\t{ .index = MSR_INVALID,\t\t\t\t.always = false },\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "bit_write",
            "&tmp"
          ],
          "line": 845
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_set_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/vmx.c",
          "lines": "1599-1604",
          "snippet": "static __always_inline void vmcs_set_bits(unsigned long field, u32 mask)\n{\n        BUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x2000,\n\t\t\t \"vmcs_set_bits does not support 64-bit fields\");\n\t__vmcs_writel(field, __vmcs_readl(field) | mask);\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"trace.h\"",
            "#include <asm/irq_remapping.h>",
            "#include <asm/apic.h>",
            "#include <asm/kexec.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/mce.h>",
            "#include <asm/virtext.h>",
            "#include <asm/vmx.h>",
            "#include <asm/desc.h>",
            "#include <asm/io.h>",
            "#include <asm/cpu.h>",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/hrtimer.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include \"lapic.h\"",
            "#include \"cpuid.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"trace.h\"\n#include <asm/irq_remapping.h>\n#include <asm/apic.h>\n#include <asm/kexec.h>\n#include <asm/debugreg.h>\n#include <asm/perf_event.h>\n#include <asm/fpu/internal.h>\n#include <asm/mce.h>\n#include <asm/virtext.h>\n#include <asm/vmx.h>\n#include <asm/desc.h>\n#include <asm/io.h>\n#include <asm/cpu.h>\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/hrtimer.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic __always_inline void vmcs_set_bits(unsigned long field, u32 mask)\n{\n        BUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x2000,\n\t\t\t \"vmcs_set_bits does not support 64-bit fields\");\n\t__vmcs_writel(field, __vmcs_readl(field) | mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "bit_write",
            "&tmp"
          ],
          "line": 845
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_clear_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/vmx.c",
          "lines": "1592-1597",
          "snippet": "static __always_inline void vmcs_clear_bits(unsigned long field, u32 mask)\n{\n        BUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x2000,\n\t\t\t \"vmcs_clear_bits does not support 64-bit fields\");\n\t__vmcs_writel(field, __vmcs_readl(field) & ~mask);\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"trace.h\"",
            "#include <asm/irq_remapping.h>",
            "#include <asm/apic.h>",
            "#include <asm/kexec.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/mce.h>",
            "#include <asm/virtext.h>",
            "#include <asm/vmx.h>",
            "#include <asm/desc.h>",
            "#include <asm/io.h>",
            "#include <asm/cpu.h>",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/hrtimer.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include \"lapic.h\"",
            "#include \"cpuid.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"trace.h\"\n#include <asm/irq_remapping.h>\n#include <asm/apic.h>\n#include <asm/kexec.h>\n#include <asm/debugreg.h>\n#include <asm/perf_event.h>\n#include <asm/fpu/internal.h>\n#include <asm/mce.h>\n#include <asm/virtext.h>\n#include <asm/vmx.h>\n#include <asm/desc.h>\n#include <asm/io.h>\n#include <asm/cpu.h>\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/hrtimer.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic __always_inline void vmcs_clear_bits(unsigned long field, u32 mask)\n{\n        BUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x2000,\n\t\t\t \"vmcs_clear_bits does not support 64-bit fields\");\n\t__vmcs_writel(field, __vmcs_readl(field) & ~mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "offset == MSR_INVALID"
          ],
          "line": 842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svm_msrpm_offset",
          "args": [
            "msr"
          ],
          "line": 837
        },
        "resolved": true,
        "details": {
          "function_name": "svm_msrpm_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "488-507",
          "snippet": "static u32 svm_msrpm_offset(u32 msr)\n{\n\tu32 offset;\n\tint i;\n\n\tfor (i = 0; i < NUM_MSR_MAPS; i++) {\n\t\tif (msr < msrpm_ranges[i] ||\n\t\t    msr >= msrpm_ranges[i] + MSRS_IN_RANGE)\n\t\t\tcontinue;\n\n\t\toffset  = (msr - msrpm_ranges[i]) / 4; /* 4 msrs per u8 */\n\t\toffset += (i * MSRS_RANGE_SIZE);       /* add range offset */\n\n\t\t/* Now we have the u8 offset - but need the u32 offset */\n\t\treturn offset / 4;\n\t}\n\n\t/* MSR not in any range */\n\treturn MSR_INVALID;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define MSRS_IN_RANGE (MSRS_RANGE_SIZE * 8 / 2)",
            "#define MSRS_RANGE_SIZE 2048",
            "#define NUM_MSR_MAPS ARRAY_SIZE(msrpm_ranges)",
            "#define MSR_INVALID\t\t\t0xffffffffU"
          ],
          "globals_used": [
            "static const u32 msrpm_ranges[] = {0, 0xc0000000, 0xc0010000};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define MSRS_IN_RANGE (MSRS_RANGE_SIZE * 8 / 2)\n#define MSRS_RANGE_SIZE 2048\n#define NUM_MSR_MAPS ARRAY_SIZE(msrpm_ranges)\n#define MSR_INVALID\t\t\t0xffffffffU\n\nstatic const u32 msrpm_ranges[] = {0, 0xc0000000, 0xc0010000};\n\nstatic u32 svm_msrpm_offset(u32 msr)\n{\n\tu32 offset;\n\tint i;\n\n\tfor (i = 0; i < NUM_MSR_MAPS; i++) {\n\t\tif (msr < msrpm_ranges[i] ||\n\t\t    msr >= msrpm_ranges[i] + MSRS_IN_RANGE)\n\t\t\tcontinue;\n\n\t\toffset  = (msr - msrpm_ranges[i]) / 4; /* 4 msrs per u8 */\n\t\toffset += (i * MSRS_RANGE_SIZE);       /* add range offset */\n\n\t\t/* Now we have the u8 offset - but need the u32 offset */\n\t\treturn offset / 4;\n\t}\n\n\t/* MSR not in any range */\n\treturn MSR_INVALID;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!valid_msr_intercept(msr)"
          ],
          "line": 835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "valid_msr_intercept",
          "args": [
            "msr"
          ],
          "line": 835
        },
        "resolved": true,
        "details": {
          "function_name": "valid_msr_intercept",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "813-822",
          "snippet": "static bool valid_msr_intercept(u32 index)\n{\n\tint i;\n\n\tfor (i = 0; direct_access_msrs[i].index != MSR_INVALID; i++)\n\t\tif (direct_access_msrs[i].index == index)\n\t\t\treturn true;\n\n\treturn false;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define MSR_INVALID\t\t\t0xffffffffU"
          ],
          "globals_used": [
            "static const struct svm_direct_access_msrs {\n\tu32 index;   /* Index of the MSR */\n\tbool always; /* True if intercept is always on */\n} direct_access_msrs[] = {\n\t{ .index = MSR_STAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_IA32_SYSENTER_CS,\t\t.always = true  },\n#ifdef CONFIG_X86_64\n\t{ .index = MSR_GS_BASE,\t\t\t\t.always = true  },\n\t{ .index = MSR_FS_BASE,\t\t\t\t.always = true  },\n\t{ .index = MSR_KERNEL_GS_BASE,\t\t\t.always = true  },\n\t{ .index = MSR_LSTAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_CSTAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_SYSCALL_MASK,\t\t\t.always = true  },\n#endif\n\t{ .index = MSR_IA32_LASTBRANCHFROMIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTBRANCHTOIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTINTFROMIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTINTTOIP,\t\t.always = false },\n\t{ .index = MSR_INVALID,\t\t\t\t.always = false },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define MSR_INVALID\t\t\t0xffffffffU\n\nstatic const struct svm_direct_access_msrs {\n\tu32 index;   /* Index of the MSR */\n\tbool always; /* True if intercept is always on */\n} direct_access_msrs[] = {\n\t{ .index = MSR_STAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_IA32_SYSENTER_CS,\t\t.always = true  },\n#ifdef CONFIG_X86_64\n\t{ .index = MSR_GS_BASE,\t\t\t\t.always = true  },\n\t{ .index = MSR_FS_BASE,\t\t\t\t.always = true  },\n\t{ .index = MSR_KERNEL_GS_BASE,\t\t\t.always = true  },\n\t{ .index = MSR_LSTAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_CSTAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_SYSCALL_MASK,\t\t\t.always = true  },\n#endif\n\t{ .index = MSR_IA32_LASTBRANCHFROMIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTBRANCHTOIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTINTFROMIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTINTTOIP,\t\t.always = false },\n\t{ .index = MSR_INVALID,\t\t\t\t.always = false },\n};\n\nstatic bool valid_msr_intercept(u32 index)\n{\n\tint i;\n\n\tfor (i = 0; direct_access_msrs[i].index != MSR_INVALID; i++)\n\t\tif (direct_access_msrs[i].index == index)\n\t\t\treturn true;\n\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define MSR_INVALID\t\t\t0xffffffffU\n\nstatic const struct svm_direct_access_msrs {\n\tu32 index;   /* Index of the MSR */\n\tbool always; /* True if intercept is always on */\n} direct_access_msrs[] = {\n\t{ .index = MSR_STAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_IA32_SYSENTER_CS,\t\t.always = true  },\n#ifdef CONFIG_X86_64\n\t{ .index = MSR_GS_BASE,\t\t\t\t.always = true  },\n\t{ .index = MSR_FS_BASE,\t\t\t\t.always = true  },\n\t{ .index = MSR_KERNEL_GS_BASE,\t\t\t.always = true  },\n\t{ .index = MSR_LSTAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_CSTAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_SYSCALL_MASK,\t\t\t.always = true  },\n#endif\n\t{ .index = MSR_IA32_LASTBRANCHFROMIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTBRANCHTOIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTINTFROMIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTINTTOIP,\t\t.always = false },\n\t{ .index = MSR_INVALID,\t\t\t\t.always = false },\n};\n\nstatic void set_msr_interception(u32 *msrpm, unsigned msr,\n\t\t\t\t int read, int write)\n{\n\tu8 bit_read, bit_write;\n\tunsigned long tmp;\n\tu32 offset;\n\n\t/*\n\t * If this warning triggers extend the direct_access_msrs list at the\n\t * beginning of the file\n\t */\n\tWARN_ON(!valid_msr_intercept(msr));\n\n\toffset    = svm_msrpm_offset(msr);\n\tbit_read  = 2 * (msr & 0x0f);\n\tbit_write = 2 * (msr & 0x0f) + 1;\n\ttmp       = msrpm[offset];\n\n\tBUG_ON(offset == MSR_INVALID);\n\n\tread  ? clear_bit(bit_read,  &tmp) : set_bit(bit_read,  &tmp);\n\twrite ? clear_bit(bit_write, &tmp) : set_bit(bit_write, &tmp);\n\n\tmsrpm[offset] = tmp;\n}"
  },
  {
    "function_name": "valid_msr_intercept",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "813-822",
    "snippet": "static bool valid_msr_intercept(u32 index)\n{\n\tint i;\n\n\tfor (i = 0; direct_access_msrs[i].index != MSR_INVALID; i++)\n\t\tif (direct_access_msrs[i].index == index)\n\t\t\treturn true;\n\n\treturn false;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define MSR_INVALID\t\t\t0xffffffffU"
    ],
    "globals_used": [
      "static const struct svm_direct_access_msrs {\n\tu32 index;   /* Index of the MSR */\n\tbool always; /* True if intercept is always on */\n} direct_access_msrs[] = {\n\t{ .index = MSR_STAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_IA32_SYSENTER_CS,\t\t.always = true  },\n#ifdef CONFIG_X86_64\n\t{ .index = MSR_GS_BASE,\t\t\t\t.always = true  },\n\t{ .index = MSR_FS_BASE,\t\t\t\t.always = true  },\n\t{ .index = MSR_KERNEL_GS_BASE,\t\t\t.always = true  },\n\t{ .index = MSR_LSTAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_CSTAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_SYSCALL_MASK,\t\t\t.always = true  },\n#endif\n\t{ .index = MSR_IA32_LASTBRANCHFROMIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTBRANCHTOIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTINTFROMIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTINTTOIP,\t\t.always = false },\n\t{ .index = MSR_INVALID,\t\t\t\t.always = false },\n};"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define MSR_INVALID\t\t\t0xffffffffU\n\nstatic const struct svm_direct_access_msrs {\n\tu32 index;   /* Index of the MSR */\n\tbool always; /* True if intercept is always on */\n} direct_access_msrs[] = {\n\t{ .index = MSR_STAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_IA32_SYSENTER_CS,\t\t.always = true  },\n#ifdef CONFIG_X86_64\n\t{ .index = MSR_GS_BASE,\t\t\t\t.always = true  },\n\t{ .index = MSR_FS_BASE,\t\t\t\t.always = true  },\n\t{ .index = MSR_KERNEL_GS_BASE,\t\t\t.always = true  },\n\t{ .index = MSR_LSTAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_CSTAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_SYSCALL_MASK,\t\t\t.always = true  },\n#endif\n\t{ .index = MSR_IA32_LASTBRANCHFROMIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTBRANCHTOIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTINTFROMIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTINTTOIP,\t\t.always = false },\n\t{ .index = MSR_INVALID,\t\t\t\t.always = false },\n};\n\nstatic bool valid_msr_intercept(u32 index)\n{\n\tint i;\n\n\tfor (i = 0; direct_access_msrs[i].index != MSR_INVALID; i++)\n\t\tif (direct_access_msrs[i].index == index)\n\t\t\treturn true;\n\n\treturn false;\n}"
  },
  {
    "function_name": "svm_cpu_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "789-811",
    "snippet": "static int svm_cpu_init(int cpu)\n{\n\tstruct svm_cpu_data *sd;\n\tint r;\n\n\tsd = kzalloc(sizeof(struct svm_cpu_data), GFP_KERNEL);\n\tif (!sd)\n\t\treturn -ENOMEM;\n\tsd->cpu = cpu;\n\tsd->save_area = alloc_page(GFP_KERNEL);\n\tr = -ENOMEM;\n\tif (!sd->save_area)\n\t\tgoto err_1;\n\n\tper_cpu(svm_data, cpu) = sd;\n\n\treturn 0;\n\nerr_1:\n\tkfree(sd);\n\treturn r;\n\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct svm_cpu_data *, svm_data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sd"
          ],
          "line": 808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "svm_data",
            "cpu"
          ],
          "line": 803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_page",
          "args": [
            "GFP_KERNEL"
          ],
          "line": 798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct svm_cpu_data)",
            "GFP_KERNEL"
          ],
          "line": 794
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic DEFINE_PER_CPU(struct svm_cpu_data *, svm_data);\n\nstatic int svm_cpu_init(int cpu)\n{\n\tstruct svm_cpu_data *sd;\n\tint r;\n\n\tsd = kzalloc(sizeof(struct svm_cpu_data), GFP_KERNEL);\n\tif (!sd)\n\t\treturn -ENOMEM;\n\tsd->cpu = cpu;\n\tsd->save_area = alloc_page(GFP_KERNEL);\n\tr = -ENOMEM;\n\tif (!sd->save_area)\n\t\tgoto err_1;\n\n\tper_cpu(svm_data, cpu) = sd;\n\n\treturn 0;\n\nerr_1:\n\tkfree(sd);\n\treturn r;\n\n}"
  },
  {
    "function_name": "svm_cpu_uninit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "777-787",
    "snippet": "static void svm_cpu_uninit(int cpu)\n{\n\tstruct svm_cpu_data *sd = per_cpu(svm_data, raw_smp_processor_id());\n\n\tif (!sd)\n\t\treturn;\n\n\tper_cpu(svm_data, raw_smp_processor_id()) = NULL;\n\t__free_page(sd->save_area);\n\tkfree(sd);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct svm_cpu_data *, svm_data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sd"
          ],
          "line": 786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__free_page",
          "args": [
            "sd->save_area"
          ],
          "line": 785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "svm_data",
            "raw_smp_processor_id()"
          ],
          "line": 784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "svm_data",
            "raw_smp_processor_id()"
          ],
          "line": 779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 779
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic DEFINE_PER_CPU(struct svm_cpu_data *, svm_data);\n\nstatic void svm_cpu_uninit(int cpu)\n{\n\tstruct svm_cpu_data *sd = per_cpu(svm_data, raw_smp_processor_id());\n\n\tif (!sd)\n\t\treturn;\n\n\tper_cpu(svm_data, raw_smp_processor_id()) = NULL;\n\t__free_page(sd->save_area);\n\tkfree(sd);\n}"
  },
  {
    "function_name": "svm_hardware_enable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "700-775",
    "snippet": "static int svm_hardware_enable(void)\n{\n\n\tstruct svm_cpu_data *sd;\n\tuint64_t efer;\n\tstruct desc_ptr gdt_descr;\n\tstruct desc_struct *gdt;\n\tint me = raw_smp_processor_id();\n\n\trdmsrl(MSR_EFER, efer);\n\tif (efer & EFER_SVME)\n\t\treturn -EBUSY;\n\n\tif (!has_svm()) {\n\t\tpr_err(\"%s: err EOPNOTSUPP on %d\\n\", __func__, me);\n\t\treturn -EINVAL;\n\t}\n\tsd = per_cpu(svm_data, me);\n\tif (!sd) {\n\t\tpr_err(\"%s: svm_data is NULL on %d\\n\", __func__, me);\n\t\treturn -EINVAL;\n\t}\n\n\tsd->asid_generation = 1;\n\tsd->max_asid = cpuid_ebx(SVM_CPUID_FUNC) - 1;\n\tsd->next_asid = sd->max_asid + 1;\n\n\tnative_store_gdt(&gdt_descr);\n\tgdt = (struct desc_struct *)gdt_descr.address;\n\tsd->tss_desc = (struct kvm_ldttss_desc *)(gdt + GDT_ENTRY_TSS);\n\n\twrmsrl(MSR_EFER, efer | EFER_SVME);\n\n\twrmsrl(MSR_VM_HSAVE_PA, page_to_pfn(sd->save_area) << PAGE_SHIFT);\n\n\tif (static_cpu_has(X86_FEATURE_TSCRATEMSR)) {\n\t\twrmsrl(MSR_AMD64_TSC_RATIO, TSC_RATIO_DEFAULT);\n\t\t__this_cpu_write(current_tsc_ratio, TSC_RATIO_DEFAULT);\n\t}\n\n\n\t/*\n\t * Get OSVW bits.\n\t *\n\t * Note that it is possible to have a system with mixed processor\n\t * revisions and therefore different OSVW bits. If bits are not the same\n\t * on different processors then choose the worst case (i.e. if erratum\n\t * is present on one processor and not on another then assume that the\n\t * erratum is present everywhere).\n\t */\n\tif (cpu_has(&boot_cpu_data, X86_FEATURE_OSVW)) {\n\t\tuint64_t len, status = 0;\n\t\tint err;\n\n\t\tlen = native_read_msr_safe(MSR_AMD64_OSVW_ID_LENGTH, &err);\n\t\tif (!err)\n\t\t\tstatus = native_read_msr_safe(MSR_AMD64_OSVW_STATUS,\n\t\t\t\t\t\t      &err);\n\n\t\tif (err)\n\t\t\tosvw_status = osvw_len = 0;\n\t\telse {\n\t\t\tif (len < osvw_len)\n\t\t\t\tosvw_len = len;\n\t\t\tosvw_status |= status;\n\t\t\tosvw_status &= (1ULL << osvw_len) - 1;\n\t\t}\n\t} else\n\t\tosvw_status = osvw_len = 0;\n\n\tsvm_init_erratum_383();\n\n\tamd_pmu_enable_virt();\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define TSC_RATIO_DEFAULT\t0x0100000000ULL"
    ],
    "globals_used": [
      "static uint64_t osvw_len = 4, osvw_status;",
      "static DEFINE_PER_CPU(u64, current_tsc_ratio);",
      "static DEFINE_PER_CPU(struct svm_cpu_data *, svm_data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "amd_pmu_enable_virt",
          "args": [],
          "line": 772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svm_init_erratum_383",
          "args": [],
          "line": 770
        },
        "resolved": true,
        "details": {
          "function_name": "svm_init_erratum_383",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "632-654",
          "snippet": "static void svm_init_erratum_383(void)\n{\n\tu32 low, high;\n\tint err;\n\tu64 val;\n\n\tif (!static_cpu_has_bug(X86_BUG_AMD_TLB_MMATCH))\n\t\treturn;\n\n\t/* Use _safe variants to not break nested virtualization */\n\tval = native_read_msr_safe(MSR_AMD64_DC_CFG, &err);\n\tif (err)\n\t\treturn;\n\n\tval |= (1ULL << 47);\n\n\tlow  = lower_32_bits(val);\n\thigh = upper_32_bits(val);\n\n\tnative_write_msr_safe(MSR_AMD64_DC_CFG, low, high);\n\n\terratum_383_found = true;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool erratum_383_found",
            "static int nested = true;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic bool erratum_383_found;\nstatic int nested = true;\n\nstatic void svm_init_erratum_383(void)\n{\n\tu32 low, high;\n\tint err;\n\tu64 val;\n\n\tif (!static_cpu_has_bug(X86_BUG_AMD_TLB_MMATCH))\n\t\treturn;\n\n\t/* Use _safe variants to not break nested virtualization */\n\tval = native_read_msr_safe(MSR_AMD64_DC_CFG, &err);\n\tif (err)\n\t\treturn;\n\n\tval |= (1ULL << 47);\n\n\tlow  = lower_32_bits(val);\n\thigh = upper_32_bits(val);\n\n\tnative_write_msr_safe(MSR_AMD64_DC_CFG, low, high);\n\n\terratum_383_found = true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "native_read_msr_safe",
          "args": [
            "MSR_AMD64_OSVW_STATUS",
            "&err"
          ],
          "line": 756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "native_read_msr_safe",
          "args": [
            "MSR_AMD64_OSVW_ID_LENGTH",
            "&err"
          ],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_has",
          "args": [
            "&boot_cpu_data",
            "X86_FEATURE_OSVW"
          ],
          "line": 750
        },
        "resolved": true,
        "details": {
          "function_name": "nested_cpu_has2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/vmx.c",
          "lines": "1208-1213",
          "snippet": "static inline bool nested_cpu_has2(struct vmcs12 *vmcs12, u32 bit)\n{\n\treturn (vmcs12->cpu_based_vm_exec_control &\n\t\t\tCPU_BASED_ACTIVATE_SECONDARY_CONTROLS) &&\n\t\t(vmcs12->secondary_vm_exec_control & bit);\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"trace.h\"",
            "#include <asm/irq_remapping.h>",
            "#include <asm/apic.h>",
            "#include <asm/kexec.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/mce.h>",
            "#include <asm/virtext.h>",
            "#include <asm/vmx.h>",
            "#include <asm/desc.h>",
            "#include <asm/io.h>",
            "#include <asm/cpu.h>",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/hrtimer.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include \"lapic.h\"",
            "#include \"cpuid.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"trace.h\"\n#include <asm/irq_remapping.h>\n#include <asm/apic.h>\n#include <asm/kexec.h>\n#include <asm/debugreg.h>\n#include <asm/perf_event.h>\n#include <asm/fpu/internal.h>\n#include <asm/mce.h>\n#include <asm/virtext.h>\n#include <asm/vmx.h>\n#include <asm/desc.h>\n#include <asm/io.h>\n#include <asm/cpu.h>\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/hrtimer.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic inline bool nested_cpu_has2(struct vmcs12 *vmcs12, u32 bit)\n{\n\treturn (vmcs12->cpu_based_vm_exec_control &\n\t\t\tCPU_BASED_ACTIVATE_SECONDARY_CONTROLS) &&\n\t\t(vmcs12->secondary_vm_exec_control & bit);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__this_cpu_write",
          "args": [
            "current_tsc_ratio",
            "TSC_RATIO_DEFAULT"
          ],
          "line": 737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wrmsrl",
          "args": [
            "MSR_AMD64_TSC_RATIO",
            "TSC_RATIO_DEFAULT"
          ],
          "line": 736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_cpu_has",
          "args": [
            "X86_FEATURE_TSCRATEMSR"
          ],
          "line": 735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wrmsrl",
          "args": [
            "MSR_VM_HSAVE_PA",
            "page_to_pfn(sd->save_area) << PAGE_SHIFT"
          ],
          "line": 733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_to_pfn",
          "args": [
            "sd->save_area"
          ],
          "line": 733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wrmsrl",
          "args": [
            "MSR_EFER",
            "efer | EFER_SVME"
          ],
          "line": 731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "native_store_gdt",
          "args": [
            "&gdt_descr"
          ],
          "line": 727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpuid_ebx",
          "args": [
            "SVM_CPUID_FUNC"
          ],
          "line": 724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s: svm_data is NULL on %d\\n\"",
            "__func__",
            "me"
          ],
          "line": 719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "svm_data",
            "me"
          ],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s: err EOPNOTSUPP on %d\\n\"",
            "__func__",
            "me"
          ],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "has_svm",
          "args": [],
          "line": 713
        },
        "resolved": true,
        "details": {
          "function_name": "has_svm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "677-687",
          "snippet": "static int has_svm(void)\n{\n\tconst char *msg;\n\n\tif (!cpu_has_svm(&msg)) {\n\t\tprintk(KERN_INFO \"has_svm: %s\\n\", msg);\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int has_svm(void)\n{\n\tconst char *msg;\n\n\tif (!cpu_has_svm(&msg)) {\n\t\tprintk(KERN_INFO \"has_svm: %s\\n\", msg);\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rdmsrl",
          "args": [
            "MSR_EFER",
            "efer"
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 707
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define TSC_RATIO_DEFAULT\t0x0100000000ULL\n\nstatic uint64_t osvw_len = 4, osvw_status;\nstatic DEFINE_PER_CPU(u64, current_tsc_ratio);\nstatic DEFINE_PER_CPU(struct svm_cpu_data *, svm_data);\n\nstatic int svm_hardware_enable(void)\n{\n\n\tstruct svm_cpu_data *sd;\n\tuint64_t efer;\n\tstruct desc_ptr gdt_descr;\n\tstruct desc_struct *gdt;\n\tint me = raw_smp_processor_id();\n\n\trdmsrl(MSR_EFER, efer);\n\tif (efer & EFER_SVME)\n\t\treturn -EBUSY;\n\n\tif (!has_svm()) {\n\t\tpr_err(\"%s: err EOPNOTSUPP on %d\\n\", __func__, me);\n\t\treturn -EINVAL;\n\t}\n\tsd = per_cpu(svm_data, me);\n\tif (!sd) {\n\t\tpr_err(\"%s: svm_data is NULL on %d\\n\", __func__, me);\n\t\treturn -EINVAL;\n\t}\n\n\tsd->asid_generation = 1;\n\tsd->max_asid = cpuid_ebx(SVM_CPUID_FUNC) - 1;\n\tsd->next_asid = sd->max_asid + 1;\n\n\tnative_store_gdt(&gdt_descr);\n\tgdt = (struct desc_struct *)gdt_descr.address;\n\tsd->tss_desc = (struct kvm_ldttss_desc *)(gdt + GDT_ENTRY_TSS);\n\n\twrmsrl(MSR_EFER, efer | EFER_SVME);\n\n\twrmsrl(MSR_VM_HSAVE_PA, page_to_pfn(sd->save_area) << PAGE_SHIFT);\n\n\tif (static_cpu_has(X86_FEATURE_TSCRATEMSR)) {\n\t\twrmsrl(MSR_AMD64_TSC_RATIO, TSC_RATIO_DEFAULT);\n\t\t__this_cpu_write(current_tsc_ratio, TSC_RATIO_DEFAULT);\n\t}\n\n\n\t/*\n\t * Get OSVW bits.\n\t *\n\t * Note that it is possible to have a system with mixed processor\n\t * revisions and therefore different OSVW bits. If bits are not the same\n\t * on different processors then choose the worst case (i.e. if erratum\n\t * is present on one processor and not on another then assume that the\n\t * erratum is present everywhere).\n\t */\n\tif (cpu_has(&boot_cpu_data, X86_FEATURE_OSVW)) {\n\t\tuint64_t len, status = 0;\n\t\tint err;\n\n\t\tlen = native_read_msr_safe(MSR_AMD64_OSVW_ID_LENGTH, &err);\n\t\tif (!err)\n\t\t\tstatus = native_read_msr_safe(MSR_AMD64_OSVW_STATUS,\n\t\t\t\t\t\t      &err);\n\n\t\tif (err)\n\t\t\tosvw_status = osvw_len = 0;\n\t\telse {\n\t\t\tif (len < osvw_len)\n\t\t\t\tosvw_len = len;\n\t\t\tosvw_status |= status;\n\t\t\tosvw_status &= (1ULL << osvw_len) - 1;\n\t\t}\n\t} else\n\t\tosvw_status = osvw_len = 0;\n\n\tsvm_init_erratum_383();\n\n\tamd_pmu_enable_virt();\n\n\treturn 0;\n}"
  },
  {
    "function_name": "svm_hardware_disable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "689-698",
    "snippet": "static void svm_hardware_disable(void)\n{\n\t/* Make sure we clean up behind us */\n\tif (static_cpu_has(X86_FEATURE_TSCRATEMSR))\n\t\twrmsrl(MSR_AMD64_TSC_RATIO, TSC_RATIO_DEFAULT);\n\n\tcpu_svm_disable();\n\n\tamd_pmu_disable_virt();\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define TSC_RATIO_DEFAULT\t0x0100000000ULL"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "amd_pmu_disable_virt",
          "args": [],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_svm_disable",
          "args": [],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wrmsrl",
          "args": [
            "MSR_AMD64_TSC_RATIO",
            "TSC_RATIO_DEFAULT"
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_cpu_has",
          "args": [
            "X86_FEATURE_TSCRATEMSR"
          ],
          "line": 692
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define TSC_RATIO_DEFAULT\t0x0100000000ULL\n\nstatic void svm_hardware_disable(void)\n{\n\t/* Make sure we clean up behind us */\n\tif (static_cpu_has(X86_FEATURE_TSCRATEMSR))\n\t\twrmsrl(MSR_AMD64_TSC_RATIO, TSC_RATIO_DEFAULT);\n\n\tcpu_svm_disable();\n\n\tamd_pmu_disable_virt();\n}"
  },
  {
    "function_name": "has_svm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "677-687",
    "snippet": "static int has_svm(void)\n{\n\tconst char *msg;\n\n\tif (!cpu_has_svm(&msg)) {\n\t\tprintk(KERN_INFO \"has_svm: %s\\n\", msg);\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO \"has_svm: %s\\n\"",
            "msg"
          ],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_has_svm",
          "args": [
            "&msg"
          ],
          "line": 681
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int has_svm(void)\n{\n\tconst char *msg;\n\n\tif (!cpu_has_svm(&msg)) {\n\t\tprintk(KERN_INFO \"has_svm: %s\\n\", msg);\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}"
  },
  {
    "function_name": "svm_init_osvw",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "656-675",
    "snippet": "static void svm_init_osvw(struct kvm_vcpu *vcpu)\n{\n\t/*\n\t * Guests should see errata 400 and 415 as fixed (assuming that\n\t * HLT and IO instructions are intercepted).\n\t */\n\tvcpu->arch.osvw.length = (osvw_len >= 3) ? (osvw_len) : 3;\n\tvcpu->arch.osvw.status = osvw_status & ~(6ULL);\n\n\t/*\n\t * By increasing VCPU's osvw.length to 3 we are telling the guest that\n\t * all osvw.status bits inside that length, including bit 0 (which is\n\t * reserved for erratum 298), are valid. However, if host processor's\n\t * osvw_len is 0 then osvw_status[0] carries no information. We need to\n\t * be conservative here and therefore we tell the guest that erratum 298\n\t * is present (because we really don't know).\n\t */\n\tif (osvw_len == 0 && boot_cpu_data.x86 == 0x10)\n\t\tvcpu->arch.osvw.status |= 1;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static uint64_t osvw_len = 4, osvw_status;",
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic uint64_t osvw_len = 4, osvw_status;\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\n\nstatic void svm_init_osvw(struct kvm_vcpu *vcpu)\n{\n\t/*\n\t * Guests should see errata 400 and 415 as fixed (assuming that\n\t * HLT and IO instructions are intercepted).\n\t */\n\tvcpu->arch.osvw.length = (osvw_len >= 3) ? (osvw_len) : 3;\n\tvcpu->arch.osvw.status = osvw_status & ~(6ULL);\n\n\t/*\n\t * By increasing VCPU's osvw.length to 3 we are telling the guest that\n\t * all osvw.status bits inside that length, including bit 0 (which is\n\t * reserved for erratum 298), are valid. However, if host processor's\n\t * osvw_len is 0 then osvw_status[0] carries no information. We need to\n\t * be conservative here and therefore we tell the guest that erratum 298\n\t * is present (because we really don't know).\n\t */\n\tif (osvw_len == 0 && boot_cpu_data.x86 == 0x10)\n\t\tvcpu->arch.osvw.status |= 1;\n}"
  },
  {
    "function_name": "svm_init_erratum_383",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "632-654",
    "snippet": "static void svm_init_erratum_383(void)\n{\n\tu32 low, high;\n\tint err;\n\tu64 val;\n\n\tif (!static_cpu_has_bug(X86_BUG_AMD_TLB_MMATCH))\n\t\treturn;\n\n\t/* Use _safe variants to not break nested virtualization */\n\tval = native_read_msr_safe(MSR_AMD64_DC_CFG, &err);\n\tif (err)\n\t\treturn;\n\n\tval |= (1ULL << 47);\n\n\tlow  = lower_32_bits(val);\n\thigh = upper_32_bits(val);\n\n\tnative_write_msr_safe(MSR_AMD64_DC_CFG, low, high);\n\n\terratum_383_found = true;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool erratum_383_found",
      "static int nested = true;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "native_write_msr_safe",
          "args": [
            "MSR_AMD64_DC_CFG",
            "low",
            "high"
          ],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "upper_32_bits",
          "args": [
            "val"
          ],
          "line": 649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lower_32_bits",
          "args": [
            "val"
          ],
          "line": 648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "native_read_msr_safe",
          "args": [
            "MSR_AMD64_DC_CFG",
            "&err"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_cpu_has_bug",
          "args": [
            "X86_BUG_AMD_TLB_MMATCH"
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic bool erratum_383_found;\nstatic int nested = true;\n\nstatic void svm_init_erratum_383(void)\n{\n\tu32 low, high;\n\tint err;\n\tu64 val;\n\n\tif (!static_cpu_has_bug(X86_BUG_AMD_TLB_MMATCH))\n\t\treturn;\n\n\t/* Use _safe variants to not break nested virtualization */\n\tval = native_read_msr_safe(MSR_AMD64_DC_CFG, &err);\n\tif (err)\n\t\treturn;\n\n\tval |= (1ULL << 47);\n\n\tlow  = lower_32_bits(val);\n\thigh = upper_32_bits(val);\n\n\tnative_write_msr_safe(MSR_AMD64_DC_CFG, low, high);\n\n\terratum_383_found = true;\n}"
  },
  {
    "function_name": "svm_queue_exception",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "595-630",
    "snippet": "static void svm_queue_exception(struct kvm_vcpu *vcpu, unsigned nr,\n\t\t\t\tbool has_error_code, u32 error_code,\n\t\t\t\tbool reinject)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\t/*\n\t * If we are within a nested VM we'd better #VMEXIT and let the guest\n\t * handle the exception\n\t */\n\tif (!reinject &&\n\t    nested_svm_check_exception(svm, nr, has_error_code, error_code))\n\t\treturn;\n\n\tif (nr == BP_VECTOR && !static_cpu_has(X86_FEATURE_NRIPS)) {\n\t\tunsigned long rip, old_rip = kvm_rip_read(&svm->vcpu);\n\n\t\t/*\n\t\t * For guest debugging where we have to reinject #BP if some\n\t\t * INT3 is guest-owned:\n\t\t * Emulate nRIP by moving RIP forward. Will fail if injection\n\t\t * raises a fault that is not intercepted. Still better than\n\t\t * failing in all cases.\n\t\t */\n\t\tskip_emulated_instruction(&svm->vcpu);\n\t\trip = kvm_rip_read(&svm->vcpu);\n\t\tsvm->int3_rip = rip + svm->vmcb->save.cs.base;\n\t\tsvm->int3_injected = rip - old_rip;\n\t}\n\n\tsvm->vmcb->control.event_inj = nr\n\t\t| SVM_EVTINJ_VALID\n\t\t| (has_error_code ? SVM_EVTINJ_VALID_ERR : 0)\n\t\t| SVM_EVTINJ_TYPE_EXEPT;\n\tsvm->vmcb->control.event_inj_err = error_code;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int nested = true;",
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);",
      "static int nested_svm_check_exception(struct vcpu_svm *svm, unsigned nr,\n\t\t\t\t      bool has_error_code, u32 error_code);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_rip_read",
          "args": [
            "&svm->vcpu"
          ],
          "line": 620
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_rip_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "27-30",
          "snippet": "static inline unsigned long kvm_rip_read(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_register_read(vcpu, VCPU_REGS_RIP);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline unsigned long kvm_rip_read(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_register_read(vcpu, VCPU_REGS_RIP);\n}"
        }
      },
      {
        "call_info": {
          "callee": "skip_emulated_instruction",
          "args": [
            "&svm->vcpu"
          ],
          "line": 619
        },
        "resolved": true,
        "details": {
          "function_name": "skip_emulated_instruction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "572-593",
          "snippet": "static void skip_emulated_instruction(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (svm->vmcb->control.next_rip != 0) {\n\t\tWARN_ON_ONCE(!static_cpu_has(X86_FEATURE_NRIPS));\n\t\tsvm->next_rip = svm->vmcb->control.next_rip;\n\t}\n\n\tif (!svm->next_rip) {\n\t\tif (emulate_instruction(vcpu, EMULTYPE_SKIP) !=\n\t\t\t\tEMULATE_DONE)\n\t\t\tprintk(KERN_DEBUG \"%s: NOP\\n\", __func__);\n\t\treturn;\n\t}\n\tif (svm->next_rip - kvm_rip_read(vcpu) > MAX_INST_SIZE)\n\t\tprintk(KERN_ERR \"%s: ip 0x%lx next 0x%llx\\n\",\n\t\t       __func__, kvm_rip_read(vcpu), svm->next_rip);\n\n\tkvm_rip_write(vcpu, svm->next_rip);\n\tsvm_set_interrupt_shadow(vcpu, 0);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define MAX_INST_SIZE 15"
          ],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define MAX_INST_SIZE 15\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic void skip_emulated_instruction(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (svm->vmcb->control.next_rip != 0) {\n\t\tWARN_ON_ONCE(!static_cpu_has(X86_FEATURE_NRIPS));\n\t\tsvm->next_rip = svm->vmcb->control.next_rip;\n\t}\n\n\tif (!svm->next_rip) {\n\t\tif (emulate_instruction(vcpu, EMULTYPE_SKIP) !=\n\t\t\t\tEMULATE_DONE)\n\t\t\tprintk(KERN_DEBUG \"%s: NOP\\n\", __func__);\n\t\treturn;\n\t}\n\tif (svm->next_rip - kvm_rip_read(vcpu) > MAX_INST_SIZE)\n\t\tprintk(KERN_ERR \"%s: ip 0x%lx next 0x%llx\\n\",\n\t\t       __func__, kvm_rip_read(vcpu), svm->next_rip);\n\n\tkvm_rip_write(vcpu, svm->next_rip);\n\tsvm_set_interrupt_shadow(vcpu, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_cpu_has",
          "args": [
            "X86_FEATURE_NRIPS"
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nested_svm_check_exception",
          "args": [
            "svm",
            "nr",
            "has_error_code",
            "error_code"
          ],
          "line": 606
        },
        "resolved": true,
        "details": {
          "function_name": "nested_svm_check_exception",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "2262-2280",
          "snippet": "static int nested_svm_check_exception(struct vcpu_svm *svm, unsigned nr,\n\t\t\t\t      bool has_error_code, u32 error_code)\n{\n\tint vmexit;\n\n\tif (!is_guest_mode(&svm->vcpu))\n\t\treturn 0;\n\n\tsvm->vmcb->control.exit_code = SVM_EXIT_EXCP_BASE + nr;\n\tsvm->vmcb->control.exit_code_hi = 0;\n\tsvm->vmcb->control.exit_info_1 = error_code;\n\tsvm->vmcb->control.exit_info_2 = svm->vcpu.arch.cr2;\n\n\tvmexit = nested_svm_intercept(svm);\n\tif (vmexit == NESTED_EXIT_DONE)\n\t\tsvm->nested.exit_required = true;\n\n\treturn vmexit;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define NESTED_EXIT_DONE\t1\t/* Exit caused nested vmexit  */"
          ],
          "globals_used": [
            "static int nested = true;",
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);",
            "static int nested_svm_check_exception(struct vcpu_svm *svm, unsigned nr,\n\t\t\t\t      bool has_error_code, u32 error_code);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define NESTED_EXIT_DONE\t1\t/* Exit caused nested vmexit  */\n\nstatic int nested = true;\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\nstatic int nested_svm_check_exception(struct vcpu_svm *svm, unsigned nr,\n\t\t\t\t      bool has_error_code, u32 error_code);\n\nstatic int nested_svm_check_exception(struct vcpu_svm *svm, unsigned nr,\n\t\t\t\t      bool has_error_code, u32 error_code)\n{\n\tint vmexit;\n\n\tif (!is_guest_mode(&svm->vcpu))\n\t\treturn 0;\n\n\tsvm->vmcb->control.exit_code = SVM_EXIT_EXCP_BASE + nr;\n\tsvm->vmcb->control.exit_code_hi = 0;\n\tsvm->vmcb->control.exit_info_1 = error_code;\n\tsvm->vmcb->control.exit_info_2 = svm->vcpu.arch.cr2;\n\n\tvmexit = nested_svm_intercept(svm);\n\tif (vmexit == NESTED_EXIT_DONE)\n\t\tsvm->nested.exit_required = true;\n\n\treturn vmexit;\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 599
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "294-297",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int nested = true;\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\nstatic int nested_svm_check_exception(struct vcpu_svm *svm, unsigned nr,\n\t\t\t\t      bool has_error_code, u32 error_code);\n\nstatic void svm_queue_exception(struct kvm_vcpu *vcpu, unsigned nr,\n\t\t\t\tbool has_error_code, u32 error_code,\n\t\t\t\tbool reinject)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\t/*\n\t * If we are within a nested VM we'd better #VMEXIT and let the guest\n\t * handle the exception\n\t */\n\tif (!reinject &&\n\t    nested_svm_check_exception(svm, nr, has_error_code, error_code))\n\t\treturn;\n\n\tif (nr == BP_VECTOR && !static_cpu_has(X86_FEATURE_NRIPS)) {\n\t\tunsigned long rip, old_rip = kvm_rip_read(&svm->vcpu);\n\n\t\t/*\n\t\t * For guest debugging where we have to reinject #BP if some\n\t\t * INT3 is guest-owned:\n\t\t * Emulate nRIP by moving RIP forward. Will fail if injection\n\t\t * raises a fault that is not intercepted. Still better than\n\t\t * failing in all cases.\n\t\t */\n\t\tskip_emulated_instruction(&svm->vcpu);\n\t\trip = kvm_rip_read(&svm->vcpu);\n\t\tsvm->int3_rip = rip + svm->vmcb->save.cs.base;\n\t\tsvm->int3_injected = rip - old_rip;\n\t}\n\n\tsvm->vmcb->control.event_inj = nr\n\t\t| SVM_EVTINJ_VALID\n\t\t| (has_error_code ? SVM_EVTINJ_VALID_ERR : 0)\n\t\t| SVM_EVTINJ_TYPE_EXEPT;\n\tsvm->vmcb->control.event_inj_err = error_code;\n}"
  },
  {
    "function_name": "skip_emulated_instruction",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "572-593",
    "snippet": "static void skip_emulated_instruction(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (svm->vmcb->control.next_rip != 0) {\n\t\tWARN_ON_ONCE(!static_cpu_has(X86_FEATURE_NRIPS));\n\t\tsvm->next_rip = svm->vmcb->control.next_rip;\n\t}\n\n\tif (!svm->next_rip) {\n\t\tif (emulate_instruction(vcpu, EMULTYPE_SKIP) !=\n\t\t\t\tEMULATE_DONE)\n\t\t\tprintk(KERN_DEBUG \"%s: NOP\\n\", __func__);\n\t\treturn;\n\t}\n\tif (svm->next_rip - kvm_rip_read(vcpu) > MAX_INST_SIZE)\n\t\tprintk(KERN_ERR \"%s: ip 0x%lx next 0x%llx\\n\",\n\t\t       __func__, kvm_rip_read(vcpu), svm->next_rip);\n\n\tkvm_rip_write(vcpu, svm->next_rip);\n\tsvm_set_interrupt_shadow(vcpu, 0);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define MAX_INST_SIZE 15"
    ],
    "globals_used": [
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "svm_set_interrupt_shadow",
          "args": [
            "vcpu",
            "0"
          ],
          "line": 592
        },
        "resolved": true,
        "details": {
          "function_name": "svm_set_interrupt_shadow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "561-570",
          "snippet": "static void svm_set_interrupt_shadow(struct kvm_vcpu *vcpu, int mask)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (mask == 0)\n\t\tsvm->vmcb->control.int_state &= ~SVM_INTERRUPT_SHADOW_MASK;\n\telse\n\t\tsvm->vmcb->control.int_state |= SVM_INTERRUPT_SHADOW_MASK;\n\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic void svm_set_interrupt_shadow(struct kvm_vcpu *vcpu, int mask)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (mask == 0)\n\t\tsvm->vmcb->control.int_state &= ~SVM_INTERRUPT_SHADOW_MASK;\n\telse\n\t\tsvm->vmcb->control.int_state |= SVM_INTERRUPT_SHADOW_MASK;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_rip_write",
          "args": [
            "vcpu",
            "svm->next_rip"
          ],
          "line": 591
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_rip_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "32-35",
          "snippet": "static inline void kvm_rip_write(struct kvm_vcpu *vcpu, unsigned long val)\n{\n\tkvm_register_write(vcpu, VCPU_REGS_RIP, val);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void kvm_rip_write(struct kvm_vcpu *vcpu, unsigned long val)\n{\n\tkvm_register_write(vcpu, VCPU_REGS_RIP, val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"%s: ip 0x%lx next 0x%llx\\n\"",
            "__func__",
            "kvm_rip_read(vcpu)",
            "svm->next_rip"
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_rip_read",
          "args": [
            "vcpu"
          ],
          "line": 589
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_rip_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "27-30",
          "snippet": "static inline unsigned long kvm_rip_read(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_register_read(vcpu, VCPU_REGS_RIP);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline unsigned long kvm_rip_read(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_register_read(vcpu, VCPU_REGS_RIP);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_DEBUG \"%s: NOP\\n\"",
            "__func__"
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "emulate_instruction",
          "args": [
            "vcpu",
            "EMULTYPE_SKIP"
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!static_cpu_has(X86_FEATURE_NRIPS)"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_cpu_has",
          "args": [
            "X86_FEATURE_NRIPS"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 574
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "294-297",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define MAX_INST_SIZE 15\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic void skip_emulated_instruction(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (svm->vmcb->control.next_rip != 0) {\n\t\tWARN_ON_ONCE(!static_cpu_has(X86_FEATURE_NRIPS));\n\t\tsvm->next_rip = svm->vmcb->control.next_rip;\n\t}\n\n\tif (!svm->next_rip) {\n\t\tif (emulate_instruction(vcpu, EMULTYPE_SKIP) !=\n\t\t\t\tEMULATE_DONE)\n\t\t\tprintk(KERN_DEBUG \"%s: NOP\\n\", __func__);\n\t\treturn;\n\t}\n\tif (svm->next_rip - kvm_rip_read(vcpu) > MAX_INST_SIZE)\n\t\tprintk(KERN_ERR \"%s: ip 0x%lx next 0x%llx\\n\",\n\t\t       __func__, kvm_rip_read(vcpu), svm->next_rip);\n\n\tkvm_rip_write(vcpu, svm->next_rip);\n\tsvm_set_interrupt_shadow(vcpu, 0);\n}"
  },
  {
    "function_name": "svm_set_interrupt_shadow",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "561-570",
    "snippet": "static void svm_set_interrupt_shadow(struct kvm_vcpu *vcpu, int mask)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (mask == 0)\n\t\tsvm->vmcb->control.int_state &= ~SVM_INTERRUPT_SHADOW_MASK;\n\telse\n\t\tsvm->vmcb->control.int_state |= SVM_INTERRUPT_SHADOW_MASK;\n\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 563
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "294-297",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic void svm_set_interrupt_shadow(struct kvm_vcpu *vcpu, int mask)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (mask == 0)\n\t\tsvm->vmcb->control.int_state &= ~SVM_INTERRUPT_SHADOW_MASK;\n\telse\n\t\tsvm->vmcb->control.int_state |= SVM_INTERRUPT_SHADOW_MASK;\n\n}"
  },
  {
    "function_name": "svm_get_interrupt_shadow",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "551-559",
    "snippet": "static u32 svm_get_interrupt_shadow(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tu32 ret = 0;\n\n\tif (svm->vmcb->control.int_state & SVM_INTERRUPT_SHADOW_MASK)\n\t\tret = KVM_X86_SHADOW_INT_STI | KVM_X86_SHADOW_INT_MOV_SS;\n\treturn ret;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 553
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "294-297",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic u32 svm_get_interrupt_shadow(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tu32 ret = 0;\n\n\tif (svm->vmcb->control.int_state & SVM_INTERRUPT_SHADOW_MASK)\n\t\tret = KVM_X86_SHADOW_INT_STI | KVM_X86_SHADOW_INT_MOV_SS;\n\treturn ret;\n}"
  },
  {
    "function_name": "is_external_interrupt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "545-549",
    "snippet": "static int is_external_interrupt(u32 info)\n{\n\tinfo &= SVM_EVTINJ_TYPE_MASK | SVM_EVTINJ_VALID;\n\treturn info == (SVM_EVTINJ_VALID | SVM_EVTINJ_TYPE_INTR);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int is_external_interrupt(u32 info)\n{\n\tinfo &= SVM_EVTINJ_TYPE_MASK | SVM_EVTINJ_VALID;\n\treturn info == (SVM_EVTINJ_VALID | SVM_EVTINJ_TYPE_INTR);\n}"
  },
  {
    "function_name": "svm_set_efer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "535-543",
    "snippet": "static void svm_set_efer(struct kvm_vcpu *vcpu, u64 efer)\n{\n\tvcpu->arch.efer = efer;\n\tif (!npt_enabled && !(efer & EFER_LMA))\n\t\tefer &= ~EFER_LME;\n\n\tto_svm(vcpu)->vmcb->save.efer = efer | EFER_SVME;\n\tmark_dirty(to_svm(vcpu)->vmcb, VMCB_CR);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_dirty",
          "args": [
            "to_svm(vcpu)->vmcb",
            "VMCB_CR"
          ],
          "line": 542
        },
        "resolved": true,
        "details": {
          "function_name": "mark_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "289-292",
          "snippet": "static inline void mark_dirty(struct vmcb *vmcb, int bit)\n{\n\tvmcb->control.clean &= ~(1 << bit);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic inline void mark_dirty(struct vmcb *vmcb, int bit)\n{\n\tvmcb->control.clean &= ~(1 << bit);\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 542
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "294-297",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\n\nstatic void svm_set_efer(struct kvm_vcpu *vcpu, u64 efer)\n{\n\tvcpu->arch.efer = efer;\n\tif (!npt_enabled && !(efer & EFER_LMA))\n\t\tefer &= ~EFER_LME;\n\n\tto_svm(vcpu)->vmcb->save.efer = efer | EFER_SVME;\n\tmark_dirty(to_svm(vcpu)->vmcb, VMCB_CR);\n}"
  },
  {
    "function_name": "get_npt_level",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "526-533",
    "snippet": "static int get_npt_level(void)\n{\n#ifdef CONFIG_X86_64\n\treturn PT64_ROOT_LEVEL;\n#else\n\treturn PT32E_ROOT_LEVEL;\n#endif\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int get_npt_level(void)\n{\n#ifdef CONFIG_X86_64\n\treturn PT64_ROOT_LEVEL;\n#else\n\treturn PT32E_ROOT_LEVEL;\n#endif\n}"
  },
  {
    "function_name": "invlpga",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "521-524",
    "snippet": "static inline void invlpga(unsigned long addr, u32 asid)\n{\n\tasm volatile (__ex(SVM_INVLPGA) : : \"a\"(addr), \"c\"(asid));\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "\"c\"",
          "args": [
            "asid"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asm volatile",
          "args": [
            "addr"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic inline void invlpga(unsigned long addr, u32 asid)\n{\n\tasm volatile (__ex(SVM_INVLPGA) : : \"a\"(addr), \"c\"(asid));\n}"
  },
  {
    "function_name": "stgi",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "516-519",
    "snippet": "static inline void stgi(void)\n{\n\tasm volatile (__ex(SVM_STGI));\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic inline void stgi(void)\n{\n\tasm volatile (__ex(SVM_STGI));\n}"
  },
  {
    "function_name": "clgi",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "511-514",
    "snippet": "static inline void clgi(void)\n{\n\tasm volatile (__ex(SVM_CLGI));\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic inline void clgi(void)\n{\n\tasm volatile (__ex(SVM_CLGI));\n}"
  },
  {
    "function_name": "svm_msrpm_offset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "488-507",
    "snippet": "static u32 svm_msrpm_offset(u32 msr)\n{\n\tu32 offset;\n\tint i;\n\n\tfor (i = 0; i < NUM_MSR_MAPS; i++) {\n\t\tif (msr < msrpm_ranges[i] ||\n\t\t    msr >= msrpm_ranges[i] + MSRS_IN_RANGE)\n\t\t\tcontinue;\n\n\t\toffset  = (msr - msrpm_ranges[i]) / 4; /* 4 msrs per u8 */\n\t\toffset += (i * MSRS_RANGE_SIZE);       /* add range offset */\n\n\t\t/* Now we have the u8 offset - but need the u32 offset */\n\t\treturn offset / 4;\n\t}\n\n\t/* MSR not in any range */\n\treturn MSR_INVALID;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define MSRS_IN_RANGE (MSRS_RANGE_SIZE * 8 / 2)",
      "#define MSRS_RANGE_SIZE 2048",
      "#define NUM_MSR_MAPS ARRAY_SIZE(msrpm_ranges)",
      "#define MSR_INVALID\t\t\t0xffffffffU"
    ],
    "globals_used": [
      "static const u32 msrpm_ranges[] = {0, 0xc0000000, 0xc0010000};"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define MSRS_IN_RANGE (MSRS_RANGE_SIZE * 8 / 2)\n#define MSRS_RANGE_SIZE 2048\n#define NUM_MSR_MAPS ARRAY_SIZE(msrpm_ranges)\n#define MSR_INVALID\t\t\t0xffffffffU\n\nstatic const u32 msrpm_ranges[] = {0, 0xc0000000, 0xc0010000};\n\nstatic u32 svm_msrpm_offset(u32 msr)\n{\n\tu32 offset;\n\tint i;\n\n\tfor (i = 0; i < NUM_MSR_MAPS; i++) {\n\t\tif (msr < msrpm_ranges[i] ||\n\t\t    msr >= msrpm_ranges[i] + MSRS_IN_RANGE)\n\t\t\tcontinue;\n\n\t\toffset  = (msr - msrpm_ranges[i]) / 4; /* 4 msrs per u8 */\n\t\toffset += (i * MSRS_RANGE_SIZE);       /* add range offset */\n\n\t\t/* Now we have the u8 offset - but need the u32 offset */\n\t\treturn offset / 4;\n\t}\n\n\t/* MSR not in any range */\n\treturn MSR_INVALID;\n}"
  },
  {
    "function_name": "gif_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "448-451",
    "snippet": "static inline bool gif_set(struct vcpu_svm *svm)\n{\n\treturn !!(svm->vcpu.arch.hflags & HF_GIF_MASK);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic inline bool gif_set(struct vcpu_svm *svm)\n{\n\treturn !!(svm->vcpu.arch.hflags & HF_GIF_MASK);\n}"
  },
  {
    "function_name": "disable_gif",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "443-446",
    "snippet": "static inline void disable_gif(struct vcpu_svm *svm)\n{\n\tsvm->vcpu.arch.hflags &= ~HF_GIF_MASK;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic inline void disable_gif(struct vcpu_svm *svm)\n{\n\tsvm->vcpu.arch.hflags &= ~HF_GIF_MASK;\n}"
  },
  {
    "function_name": "enable_gif",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "438-441",
    "snippet": "static inline void enable_gif(struct vcpu_svm *svm)\n{\n\tsvm->vcpu.arch.hflags |= HF_GIF_MASK;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic inline void enable_gif(struct vcpu_svm *svm)\n{\n\tsvm->vcpu.arch.hflags |= HF_GIF_MASK;\n}"
  },
  {
    "function_name": "clr_intercept",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "429-436",
    "snippet": "static inline void clr_intercept(struct vcpu_svm *svm, int bit)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept &= ~(1ULL << bit);\n\n\trecalc_intercepts(svm);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "recalc_intercepts",
          "args": [
            "svm"
          ],
          "line": 435
        },
        "resolved": true,
        "details": {
          "function_name": "recalc_intercepts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "316-334",
          "snippet": "static void recalc_intercepts(struct vcpu_svm *svm)\n{\n\tstruct vmcb_control_area *c, *h;\n\tstruct nested_state *g;\n\n\tmark_dirty(svm->vmcb, VMCB_INTERCEPTS);\n\n\tif (!is_guest_mode(&svm->vcpu))\n\t\treturn;\n\n\tc = &svm->vmcb->control;\n\th = &svm->nested.hsave->control;\n\tg = &svm->nested;\n\n\tc->intercept_cr = h->intercept_cr | g->intercept_cr;\n\tc->intercept_dr = h->intercept_dr | g->intercept_dr;\n\tc->intercept_exceptions = h->intercept_exceptions | g->intercept_exceptions;\n\tc->intercept = h->intercept | g->intercept;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nested = true;",
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int nested = true;\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic void recalc_intercepts(struct vcpu_svm *svm)\n{\n\tstruct vmcb_control_area *c, *h;\n\tstruct nested_state *g;\n\n\tmark_dirty(svm->vmcb, VMCB_INTERCEPTS);\n\n\tif (!is_guest_mode(&svm->vcpu))\n\t\treturn;\n\n\tc = &svm->vmcb->control;\n\th = &svm->nested.hsave->control;\n\tg = &svm->nested;\n\n\tc->intercept_cr = h->intercept_cr | g->intercept_cr;\n\tc->intercept_dr = h->intercept_dr | g->intercept_dr;\n\tc->intercept_exceptions = h->intercept_exceptions | g->intercept_exceptions;\n\tc->intercept = h->intercept | g->intercept;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_host_vmcb",
          "args": [
            "svm"
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "get_host_vmcb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "336-342",
          "snippet": "static inline struct vmcb *get_host_vmcb(struct vcpu_svm *svm)\n{\n\tif (is_guest_mode(&svm->vcpu))\n\t\treturn svm->nested.hsave;\n\telse\n\t\treturn svm->vmcb;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nested = true;",
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int nested = true;\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic inline struct vmcb *get_host_vmcb(struct vcpu_svm *svm)\n{\n\tif (is_guest_mode(&svm->vcpu))\n\t\treturn svm->nested.hsave;\n\telse\n\t\treturn svm->vmcb;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic inline void clr_intercept(struct vcpu_svm *svm, int bit)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept &= ~(1ULL << bit);\n\n\trecalc_intercepts(svm);\n}"
  },
  {
    "function_name": "set_intercept",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "420-427",
    "snippet": "static inline void set_intercept(struct vcpu_svm *svm, int bit)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept |= (1ULL << bit);\n\n\trecalc_intercepts(svm);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "recalc_intercepts",
          "args": [
            "svm"
          ],
          "line": 426
        },
        "resolved": true,
        "details": {
          "function_name": "recalc_intercepts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "316-334",
          "snippet": "static void recalc_intercepts(struct vcpu_svm *svm)\n{\n\tstruct vmcb_control_area *c, *h;\n\tstruct nested_state *g;\n\n\tmark_dirty(svm->vmcb, VMCB_INTERCEPTS);\n\n\tif (!is_guest_mode(&svm->vcpu))\n\t\treturn;\n\n\tc = &svm->vmcb->control;\n\th = &svm->nested.hsave->control;\n\tg = &svm->nested;\n\n\tc->intercept_cr = h->intercept_cr | g->intercept_cr;\n\tc->intercept_dr = h->intercept_dr | g->intercept_dr;\n\tc->intercept_exceptions = h->intercept_exceptions | g->intercept_exceptions;\n\tc->intercept = h->intercept | g->intercept;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nested = true;",
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int nested = true;\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic void recalc_intercepts(struct vcpu_svm *svm)\n{\n\tstruct vmcb_control_area *c, *h;\n\tstruct nested_state *g;\n\n\tmark_dirty(svm->vmcb, VMCB_INTERCEPTS);\n\n\tif (!is_guest_mode(&svm->vcpu))\n\t\treturn;\n\n\tc = &svm->vmcb->control;\n\th = &svm->nested.hsave->control;\n\tg = &svm->nested;\n\n\tc->intercept_cr = h->intercept_cr | g->intercept_cr;\n\tc->intercept_dr = h->intercept_dr | g->intercept_dr;\n\tc->intercept_exceptions = h->intercept_exceptions | g->intercept_exceptions;\n\tc->intercept = h->intercept | g->intercept;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_host_vmcb",
          "args": [
            "svm"
          ],
          "line": 422
        },
        "resolved": true,
        "details": {
          "function_name": "get_host_vmcb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "336-342",
          "snippet": "static inline struct vmcb *get_host_vmcb(struct vcpu_svm *svm)\n{\n\tif (is_guest_mode(&svm->vcpu))\n\t\treturn svm->nested.hsave;\n\telse\n\t\treturn svm->vmcb;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nested = true;",
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int nested = true;\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic inline struct vmcb *get_host_vmcb(struct vcpu_svm *svm)\n{\n\tif (is_guest_mode(&svm->vcpu))\n\t\treturn svm->nested.hsave;\n\telse\n\t\treturn svm->vmcb;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic inline void set_intercept(struct vcpu_svm *svm, int bit)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept |= (1ULL << bit);\n\n\trecalc_intercepts(svm);\n}"
  },
  {
    "function_name": "clr_exception_intercept",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "411-418",
    "snippet": "static inline void clr_exception_intercept(struct vcpu_svm *svm, int bit)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept_exceptions &= ~(1U << bit);\n\n\trecalc_intercepts(svm);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "recalc_intercepts",
          "args": [
            "svm"
          ],
          "line": 417
        },
        "resolved": true,
        "details": {
          "function_name": "recalc_intercepts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "316-334",
          "snippet": "static void recalc_intercepts(struct vcpu_svm *svm)\n{\n\tstruct vmcb_control_area *c, *h;\n\tstruct nested_state *g;\n\n\tmark_dirty(svm->vmcb, VMCB_INTERCEPTS);\n\n\tif (!is_guest_mode(&svm->vcpu))\n\t\treturn;\n\n\tc = &svm->vmcb->control;\n\th = &svm->nested.hsave->control;\n\tg = &svm->nested;\n\n\tc->intercept_cr = h->intercept_cr | g->intercept_cr;\n\tc->intercept_dr = h->intercept_dr | g->intercept_dr;\n\tc->intercept_exceptions = h->intercept_exceptions | g->intercept_exceptions;\n\tc->intercept = h->intercept | g->intercept;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nested = true;",
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int nested = true;\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic void recalc_intercepts(struct vcpu_svm *svm)\n{\n\tstruct vmcb_control_area *c, *h;\n\tstruct nested_state *g;\n\n\tmark_dirty(svm->vmcb, VMCB_INTERCEPTS);\n\n\tif (!is_guest_mode(&svm->vcpu))\n\t\treturn;\n\n\tc = &svm->vmcb->control;\n\th = &svm->nested.hsave->control;\n\tg = &svm->nested;\n\n\tc->intercept_cr = h->intercept_cr | g->intercept_cr;\n\tc->intercept_dr = h->intercept_dr | g->intercept_dr;\n\tc->intercept_exceptions = h->intercept_exceptions | g->intercept_exceptions;\n\tc->intercept = h->intercept | g->intercept;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_host_vmcb",
          "args": [
            "svm"
          ],
          "line": 413
        },
        "resolved": true,
        "details": {
          "function_name": "get_host_vmcb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "336-342",
          "snippet": "static inline struct vmcb *get_host_vmcb(struct vcpu_svm *svm)\n{\n\tif (is_guest_mode(&svm->vcpu))\n\t\treturn svm->nested.hsave;\n\telse\n\t\treturn svm->vmcb;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nested = true;",
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int nested = true;\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic inline struct vmcb *get_host_vmcb(struct vcpu_svm *svm)\n{\n\tif (is_guest_mode(&svm->vcpu))\n\t\treturn svm->nested.hsave;\n\telse\n\t\treturn svm->vmcb;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic inline void clr_exception_intercept(struct vcpu_svm *svm, int bit)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept_exceptions &= ~(1U << bit);\n\n\trecalc_intercepts(svm);\n}"
  },
  {
    "function_name": "set_exception_intercept",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "402-409",
    "snippet": "static inline void set_exception_intercept(struct vcpu_svm *svm, int bit)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept_exceptions |= (1U << bit);\n\n\trecalc_intercepts(svm);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "recalc_intercepts",
          "args": [
            "svm"
          ],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "recalc_intercepts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "316-334",
          "snippet": "static void recalc_intercepts(struct vcpu_svm *svm)\n{\n\tstruct vmcb_control_area *c, *h;\n\tstruct nested_state *g;\n\n\tmark_dirty(svm->vmcb, VMCB_INTERCEPTS);\n\n\tif (!is_guest_mode(&svm->vcpu))\n\t\treturn;\n\n\tc = &svm->vmcb->control;\n\th = &svm->nested.hsave->control;\n\tg = &svm->nested;\n\n\tc->intercept_cr = h->intercept_cr | g->intercept_cr;\n\tc->intercept_dr = h->intercept_dr | g->intercept_dr;\n\tc->intercept_exceptions = h->intercept_exceptions | g->intercept_exceptions;\n\tc->intercept = h->intercept | g->intercept;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nested = true;",
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int nested = true;\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic void recalc_intercepts(struct vcpu_svm *svm)\n{\n\tstruct vmcb_control_area *c, *h;\n\tstruct nested_state *g;\n\n\tmark_dirty(svm->vmcb, VMCB_INTERCEPTS);\n\n\tif (!is_guest_mode(&svm->vcpu))\n\t\treturn;\n\n\tc = &svm->vmcb->control;\n\th = &svm->nested.hsave->control;\n\tg = &svm->nested;\n\n\tc->intercept_cr = h->intercept_cr | g->intercept_cr;\n\tc->intercept_dr = h->intercept_dr | g->intercept_dr;\n\tc->intercept_exceptions = h->intercept_exceptions | g->intercept_exceptions;\n\tc->intercept = h->intercept | g->intercept;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_host_vmcb",
          "args": [
            "svm"
          ],
          "line": 404
        },
        "resolved": true,
        "details": {
          "function_name": "get_host_vmcb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "336-342",
          "snippet": "static inline struct vmcb *get_host_vmcb(struct vcpu_svm *svm)\n{\n\tif (is_guest_mode(&svm->vcpu))\n\t\treturn svm->nested.hsave;\n\telse\n\t\treturn svm->vmcb;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nested = true;",
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int nested = true;\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic inline struct vmcb *get_host_vmcb(struct vcpu_svm *svm)\n{\n\tif (is_guest_mode(&svm->vcpu))\n\t\treturn svm->nested.hsave;\n\telse\n\t\treturn svm->vmcb;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic inline void set_exception_intercept(struct vcpu_svm *svm, int bit)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept_exceptions |= (1U << bit);\n\n\trecalc_intercepts(svm);\n}"
  },
  {
    "function_name": "clr_dr_intercepts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "393-400",
    "snippet": "static inline void clr_dr_intercepts(struct vcpu_svm *svm)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept_dr = 0;\n\n\trecalc_intercepts(svm);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "recalc_intercepts",
          "args": [
            "svm"
          ],
          "line": 399
        },
        "resolved": true,
        "details": {
          "function_name": "recalc_intercepts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "316-334",
          "snippet": "static void recalc_intercepts(struct vcpu_svm *svm)\n{\n\tstruct vmcb_control_area *c, *h;\n\tstruct nested_state *g;\n\n\tmark_dirty(svm->vmcb, VMCB_INTERCEPTS);\n\n\tif (!is_guest_mode(&svm->vcpu))\n\t\treturn;\n\n\tc = &svm->vmcb->control;\n\th = &svm->nested.hsave->control;\n\tg = &svm->nested;\n\n\tc->intercept_cr = h->intercept_cr | g->intercept_cr;\n\tc->intercept_dr = h->intercept_dr | g->intercept_dr;\n\tc->intercept_exceptions = h->intercept_exceptions | g->intercept_exceptions;\n\tc->intercept = h->intercept | g->intercept;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nested = true;",
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int nested = true;\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic void recalc_intercepts(struct vcpu_svm *svm)\n{\n\tstruct vmcb_control_area *c, *h;\n\tstruct nested_state *g;\n\n\tmark_dirty(svm->vmcb, VMCB_INTERCEPTS);\n\n\tif (!is_guest_mode(&svm->vcpu))\n\t\treturn;\n\n\tc = &svm->vmcb->control;\n\th = &svm->nested.hsave->control;\n\tg = &svm->nested;\n\n\tc->intercept_cr = h->intercept_cr | g->intercept_cr;\n\tc->intercept_dr = h->intercept_dr | g->intercept_dr;\n\tc->intercept_exceptions = h->intercept_exceptions | g->intercept_exceptions;\n\tc->intercept = h->intercept | g->intercept;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_host_vmcb",
          "args": [
            "svm"
          ],
          "line": 395
        },
        "resolved": true,
        "details": {
          "function_name": "get_host_vmcb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "336-342",
          "snippet": "static inline struct vmcb *get_host_vmcb(struct vcpu_svm *svm)\n{\n\tif (is_guest_mode(&svm->vcpu))\n\t\treturn svm->nested.hsave;\n\telse\n\t\treturn svm->vmcb;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nested = true;",
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int nested = true;\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic inline struct vmcb *get_host_vmcb(struct vcpu_svm *svm)\n{\n\tif (is_guest_mode(&svm->vcpu))\n\t\treturn svm->nested.hsave;\n\telse\n\t\treturn svm->vmcb;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic inline void clr_dr_intercepts(struct vcpu_svm *svm)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept_dr = 0;\n\n\trecalc_intercepts(svm);\n}"
  },
  {
    "function_name": "set_dr_intercepts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "369-391",
    "snippet": "static inline void set_dr_intercepts(struct vcpu_svm *svm)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept_dr = (1 << INTERCEPT_DR0_READ)\n\t\t| (1 << INTERCEPT_DR1_READ)\n\t\t| (1 << INTERCEPT_DR2_READ)\n\t\t| (1 << INTERCEPT_DR3_READ)\n\t\t| (1 << INTERCEPT_DR4_READ)\n\t\t| (1 << INTERCEPT_DR5_READ)\n\t\t| (1 << INTERCEPT_DR6_READ)\n\t\t| (1 << INTERCEPT_DR7_READ)\n\t\t| (1 << INTERCEPT_DR0_WRITE)\n\t\t| (1 << INTERCEPT_DR1_WRITE)\n\t\t| (1 << INTERCEPT_DR2_WRITE)\n\t\t| (1 << INTERCEPT_DR3_WRITE)\n\t\t| (1 << INTERCEPT_DR4_WRITE)\n\t\t| (1 << INTERCEPT_DR5_WRITE)\n\t\t| (1 << INTERCEPT_DR6_WRITE)\n\t\t| (1 << INTERCEPT_DR7_WRITE);\n\n\trecalc_intercepts(svm);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "recalc_intercepts",
          "args": [
            "svm"
          ],
          "line": 390
        },
        "resolved": true,
        "details": {
          "function_name": "recalc_intercepts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "316-334",
          "snippet": "static void recalc_intercepts(struct vcpu_svm *svm)\n{\n\tstruct vmcb_control_area *c, *h;\n\tstruct nested_state *g;\n\n\tmark_dirty(svm->vmcb, VMCB_INTERCEPTS);\n\n\tif (!is_guest_mode(&svm->vcpu))\n\t\treturn;\n\n\tc = &svm->vmcb->control;\n\th = &svm->nested.hsave->control;\n\tg = &svm->nested;\n\n\tc->intercept_cr = h->intercept_cr | g->intercept_cr;\n\tc->intercept_dr = h->intercept_dr | g->intercept_dr;\n\tc->intercept_exceptions = h->intercept_exceptions | g->intercept_exceptions;\n\tc->intercept = h->intercept | g->intercept;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nested = true;",
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int nested = true;\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic void recalc_intercepts(struct vcpu_svm *svm)\n{\n\tstruct vmcb_control_area *c, *h;\n\tstruct nested_state *g;\n\n\tmark_dirty(svm->vmcb, VMCB_INTERCEPTS);\n\n\tif (!is_guest_mode(&svm->vcpu))\n\t\treturn;\n\n\tc = &svm->vmcb->control;\n\th = &svm->nested.hsave->control;\n\tg = &svm->nested;\n\n\tc->intercept_cr = h->intercept_cr | g->intercept_cr;\n\tc->intercept_dr = h->intercept_dr | g->intercept_dr;\n\tc->intercept_exceptions = h->intercept_exceptions | g->intercept_exceptions;\n\tc->intercept = h->intercept | g->intercept;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_host_vmcb",
          "args": [
            "svm"
          ],
          "line": 371
        },
        "resolved": true,
        "details": {
          "function_name": "get_host_vmcb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "336-342",
          "snippet": "static inline struct vmcb *get_host_vmcb(struct vcpu_svm *svm)\n{\n\tif (is_guest_mode(&svm->vcpu))\n\t\treturn svm->nested.hsave;\n\telse\n\t\treturn svm->vmcb;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nested = true;",
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int nested = true;\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic inline struct vmcb *get_host_vmcb(struct vcpu_svm *svm)\n{\n\tif (is_guest_mode(&svm->vcpu))\n\t\treturn svm->nested.hsave;\n\telse\n\t\treturn svm->vmcb;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic inline void set_dr_intercepts(struct vcpu_svm *svm)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept_dr = (1 << INTERCEPT_DR0_READ)\n\t\t| (1 << INTERCEPT_DR1_READ)\n\t\t| (1 << INTERCEPT_DR2_READ)\n\t\t| (1 << INTERCEPT_DR3_READ)\n\t\t| (1 << INTERCEPT_DR4_READ)\n\t\t| (1 << INTERCEPT_DR5_READ)\n\t\t| (1 << INTERCEPT_DR6_READ)\n\t\t| (1 << INTERCEPT_DR7_READ)\n\t\t| (1 << INTERCEPT_DR0_WRITE)\n\t\t| (1 << INTERCEPT_DR1_WRITE)\n\t\t| (1 << INTERCEPT_DR2_WRITE)\n\t\t| (1 << INTERCEPT_DR3_WRITE)\n\t\t| (1 << INTERCEPT_DR4_WRITE)\n\t\t| (1 << INTERCEPT_DR5_WRITE)\n\t\t| (1 << INTERCEPT_DR6_WRITE)\n\t\t| (1 << INTERCEPT_DR7_WRITE);\n\n\trecalc_intercepts(svm);\n}"
  },
  {
    "function_name": "is_cr_intercept",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "362-367",
    "snippet": "static inline bool is_cr_intercept(struct vcpu_svm *svm, int bit)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\treturn vmcb->control.intercept_cr & (1U << bit);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_host_vmcb",
          "args": [
            "svm"
          ],
          "line": 364
        },
        "resolved": true,
        "details": {
          "function_name": "get_host_vmcb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "336-342",
          "snippet": "static inline struct vmcb *get_host_vmcb(struct vcpu_svm *svm)\n{\n\tif (is_guest_mode(&svm->vcpu))\n\t\treturn svm->nested.hsave;\n\telse\n\t\treturn svm->vmcb;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nested = true;",
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int nested = true;\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic inline struct vmcb *get_host_vmcb(struct vcpu_svm *svm)\n{\n\tif (is_guest_mode(&svm->vcpu))\n\t\treturn svm->nested.hsave;\n\telse\n\t\treturn svm->vmcb;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic inline bool is_cr_intercept(struct vcpu_svm *svm, int bit)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\treturn vmcb->control.intercept_cr & (1U << bit);\n}"
  },
  {
    "function_name": "clr_cr_intercept",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "353-360",
    "snippet": "static inline void clr_cr_intercept(struct vcpu_svm *svm, int bit)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept_cr &= ~(1U << bit);\n\n\trecalc_intercepts(svm);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "recalc_intercepts",
          "args": [
            "svm"
          ],
          "line": 359
        },
        "resolved": true,
        "details": {
          "function_name": "recalc_intercepts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "316-334",
          "snippet": "static void recalc_intercepts(struct vcpu_svm *svm)\n{\n\tstruct vmcb_control_area *c, *h;\n\tstruct nested_state *g;\n\n\tmark_dirty(svm->vmcb, VMCB_INTERCEPTS);\n\n\tif (!is_guest_mode(&svm->vcpu))\n\t\treturn;\n\n\tc = &svm->vmcb->control;\n\th = &svm->nested.hsave->control;\n\tg = &svm->nested;\n\n\tc->intercept_cr = h->intercept_cr | g->intercept_cr;\n\tc->intercept_dr = h->intercept_dr | g->intercept_dr;\n\tc->intercept_exceptions = h->intercept_exceptions | g->intercept_exceptions;\n\tc->intercept = h->intercept | g->intercept;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nested = true;",
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int nested = true;\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic void recalc_intercepts(struct vcpu_svm *svm)\n{\n\tstruct vmcb_control_area *c, *h;\n\tstruct nested_state *g;\n\n\tmark_dirty(svm->vmcb, VMCB_INTERCEPTS);\n\n\tif (!is_guest_mode(&svm->vcpu))\n\t\treturn;\n\n\tc = &svm->vmcb->control;\n\th = &svm->nested.hsave->control;\n\tg = &svm->nested;\n\n\tc->intercept_cr = h->intercept_cr | g->intercept_cr;\n\tc->intercept_dr = h->intercept_dr | g->intercept_dr;\n\tc->intercept_exceptions = h->intercept_exceptions | g->intercept_exceptions;\n\tc->intercept = h->intercept | g->intercept;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_host_vmcb",
          "args": [
            "svm"
          ],
          "line": 355
        },
        "resolved": true,
        "details": {
          "function_name": "get_host_vmcb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "336-342",
          "snippet": "static inline struct vmcb *get_host_vmcb(struct vcpu_svm *svm)\n{\n\tif (is_guest_mode(&svm->vcpu))\n\t\treturn svm->nested.hsave;\n\telse\n\t\treturn svm->vmcb;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nested = true;",
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int nested = true;\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic inline struct vmcb *get_host_vmcb(struct vcpu_svm *svm)\n{\n\tif (is_guest_mode(&svm->vcpu))\n\t\treturn svm->nested.hsave;\n\telse\n\t\treturn svm->vmcb;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic inline void clr_cr_intercept(struct vcpu_svm *svm, int bit)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept_cr &= ~(1U << bit);\n\n\trecalc_intercepts(svm);\n}"
  },
  {
    "function_name": "set_cr_intercept",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "344-351",
    "snippet": "static inline void set_cr_intercept(struct vcpu_svm *svm, int bit)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept_cr |= (1U << bit);\n\n\trecalc_intercepts(svm);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "recalc_intercepts",
          "args": [
            "svm"
          ],
          "line": 350
        },
        "resolved": true,
        "details": {
          "function_name": "recalc_intercepts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "316-334",
          "snippet": "static void recalc_intercepts(struct vcpu_svm *svm)\n{\n\tstruct vmcb_control_area *c, *h;\n\tstruct nested_state *g;\n\n\tmark_dirty(svm->vmcb, VMCB_INTERCEPTS);\n\n\tif (!is_guest_mode(&svm->vcpu))\n\t\treturn;\n\n\tc = &svm->vmcb->control;\n\th = &svm->nested.hsave->control;\n\tg = &svm->nested;\n\n\tc->intercept_cr = h->intercept_cr | g->intercept_cr;\n\tc->intercept_dr = h->intercept_dr | g->intercept_dr;\n\tc->intercept_exceptions = h->intercept_exceptions | g->intercept_exceptions;\n\tc->intercept = h->intercept | g->intercept;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nested = true;",
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int nested = true;\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic void recalc_intercepts(struct vcpu_svm *svm)\n{\n\tstruct vmcb_control_area *c, *h;\n\tstruct nested_state *g;\n\n\tmark_dirty(svm->vmcb, VMCB_INTERCEPTS);\n\n\tif (!is_guest_mode(&svm->vcpu))\n\t\treturn;\n\n\tc = &svm->vmcb->control;\n\th = &svm->nested.hsave->control;\n\tg = &svm->nested;\n\n\tc->intercept_cr = h->intercept_cr | g->intercept_cr;\n\tc->intercept_dr = h->intercept_dr | g->intercept_dr;\n\tc->intercept_exceptions = h->intercept_exceptions | g->intercept_exceptions;\n\tc->intercept = h->intercept | g->intercept;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_host_vmcb",
          "args": [
            "svm"
          ],
          "line": 346
        },
        "resolved": true,
        "details": {
          "function_name": "get_host_vmcb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "336-342",
          "snippet": "static inline struct vmcb *get_host_vmcb(struct vcpu_svm *svm)\n{\n\tif (is_guest_mode(&svm->vcpu))\n\t\treturn svm->nested.hsave;\n\telse\n\t\treturn svm->vmcb;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nested = true;",
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int nested = true;\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic inline struct vmcb *get_host_vmcb(struct vcpu_svm *svm)\n{\n\tif (is_guest_mode(&svm->vcpu))\n\t\treturn svm->nested.hsave;\n\telse\n\t\treturn svm->vmcb;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic inline void set_cr_intercept(struct vcpu_svm *svm, int bit)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept_cr |= (1U << bit);\n\n\trecalc_intercepts(svm);\n}"
  },
  {
    "function_name": "get_host_vmcb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "336-342",
    "snippet": "static inline struct vmcb *get_host_vmcb(struct vcpu_svm *svm)\n{\n\tif (is_guest_mode(&svm->vcpu))\n\t\treturn svm->nested.hsave;\n\telse\n\t\treturn svm->vmcb;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int nested = true;",
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "is_guest_mode",
          "args": [
            "&svm->vcpu"
          ],
          "line": 338
        },
        "resolved": true,
        "details": {
          "function_name": "is_guest_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "102-105",
          "snippet": "static inline bool is_guest_mode(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.hflags & HF_GUEST_MASK;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline bool is_guest_mode(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.hflags & HF_GUEST_MASK;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int nested = true;\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic inline struct vmcb *get_host_vmcb(struct vcpu_svm *svm)\n{\n\tif (is_guest_mode(&svm->vcpu))\n\t\treturn svm->nested.hsave;\n\telse\n\t\treturn svm->vmcb;\n}"
  },
  {
    "function_name": "recalc_intercepts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "316-334",
    "snippet": "static void recalc_intercepts(struct vcpu_svm *svm)\n{\n\tstruct vmcb_control_area *c, *h;\n\tstruct nested_state *g;\n\n\tmark_dirty(svm->vmcb, VMCB_INTERCEPTS);\n\n\tif (!is_guest_mode(&svm->vcpu))\n\t\treturn;\n\n\tc = &svm->vmcb->control;\n\th = &svm->nested.hsave->control;\n\tg = &svm->nested;\n\n\tc->intercept_cr = h->intercept_cr | g->intercept_cr;\n\tc->intercept_dr = h->intercept_dr | g->intercept_dr;\n\tc->intercept_exceptions = h->intercept_exceptions | g->intercept_exceptions;\n\tc->intercept = h->intercept | g->intercept;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int nested = true;",
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "is_guest_mode",
          "args": [
            "&svm->vcpu"
          ],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "is_guest_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "102-105",
          "snippet": "static inline bool is_guest_mode(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.hflags & HF_GUEST_MASK;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline bool is_guest_mode(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.hflags & HF_GUEST_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_dirty",
          "args": [
            "svm->vmcb",
            "VMCB_INTERCEPTS"
          ],
          "line": 321
        },
        "resolved": true,
        "details": {
          "function_name": "mark_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "289-292",
          "snippet": "static inline void mark_dirty(struct vmcb *vmcb, int bit)\n{\n\tvmcb->control.clean &= ~(1 << bit);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic inline void mark_dirty(struct vmcb *vmcb, int bit)\n{\n\tvmcb->control.clean &= ~(1 << bit);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int nested = true;\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic void recalc_intercepts(struct vcpu_svm *svm)\n{\n\tstruct vmcb_control_area *c, *h;\n\tstruct nested_state *g;\n\n\tmark_dirty(svm->vmcb, VMCB_INTERCEPTS);\n\n\tif (!is_guest_mode(&svm->vcpu))\n\t\treturn;\n\n\tc = &svm->vmcb->control;\n\th = &svm->nested.hsave->control;\n\tg = &svm->nested;\n\n\tc->intercept_cr = h->intercept_cr | g->intercept_cr;\n\tc->intercept_dr = h->intercept_dr | g->intercept_dr;\n\tc->intercept_exceptions = h->intercept_exceptions | g->intercept_exceptions;\n\tc->intercept = h->intercept | g->intercept;\n}"
  },
  {
    "function_name": "avic_vcpu_is_running",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "305-314",
    "snippet": "static inline bool avic_vcpu_is_running(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tu64 *entry = svm->avic_physical_id_cache;\n\n\tif (!entry)\n\t\treturn false;\n\n\treturn (READ_ONCE(*entry) & AVIC_PHYSICAL_ID_ENTRY_IS_RUNNING_MASK);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define AVIC_PHYSICAL_ID_ENTRY_IS_RUNNING_MASK\t\t(1ULL << 62)"
    ],
    "globals_used": [
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "*entry"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "294-297",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define AVIC_PHYSICAL_ID_ENTRY_IS_RUNNING_MASK\t\t(1ULL << 62)\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic inline bool avic_vcpu_is_running(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tu64 *entry = svm->avic_physical_id_cache;\n\n\tif (!entry)\n\t\treturn false;\n\n\treturn (READ_ONCE(*entry) & AVIC_PHYSICAL_ID_ENTRY_IS_RUNNING_MASK);\n}"
  },
  {
    "function_name": "avic_update_vapic_bar",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "299-303",
    "snippet": "static inline void avic_update_vapic_bar(struct vcpu_svm *svm, u64 data)\n{\n\tsvm->vmcb->control.avic_vapic_bar = data & VMCB_AVIC_APIC_BAR_MASK;\n\tmark_dirty(svm->vmcb, VMCB_AVIC);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define VMCB_AVIC_APIC_BAR_MASK\t\t0xFFFFFFFFFF000ULL"
    ],
    "globals_used": [
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
      "static int nested_svm_intercept(struct vcpu_svm *svm);",
      "static int nested_svm_vmexit(struct vcpu_svm *svm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_dirty",
          "args": [
            "svm->vmcb",
            "VMCB_AVIC"
          ],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "mark_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "289-292",
          "snippet": "static inline void mark_dirty(struct vmcb *vmcb, int bit)\n{\n\tvmcb->control.clean &= ~(1 << bit);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic inline void mark_dirty(struct vmcb *vmcb, int bit)\n{\n\tvmcb->control.clean &= ~(1 << bit);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define VMCB_AVIC_APIC_BAR_MASK\t\t0xFFFFFFFFFF000ULL\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic inline void avic_update_vapic_bar(struct vcpu_svm *svm, u64 data)\n{\n\tsvm->vmcb->control.avic_vapic_bar = data & VMCB_AVIC_APIC_BAR_MASK;\n\tmark_dirty(svm->vmcb, VMCB_AVIC);\n}"
  },
  {
    "function_name": "to_svm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "294-297",
    "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_flush_tlb(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "vcpu",
            "structvcpu_svm",
            "vcpu"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
  },
  {
    "function_name": "mark_dirty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "289-292",
    "snippet": "static inline void mark_dirty(struct vmcb *vmcb, int bit)\n{\n\tvmcb->control.clean &= ~(1 << bit);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic inline void mark_dirty(struct vmcb *vmcb, int bit)\n{\n\tvmcb->control.clean &= ~(1 << bit);\n}"
  },
  {
    "function_name": "mark_all_clean",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "283-287",
    "snippet": "static inline void mark_all_clean(struct vmcb *vmcb)\n{\n\tvmcb->control.clean = ((1 << VMCB_DIRTY_MAX) - 1)\n\t\t\t       & ~VMCB_ALWAYS_DIRTY_MASK;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define VMCB_ALWAYS_DIRTY_MASK\t((1U << VMCB_INTR) | (1U << VMCB_CR2))"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define VMCB_ALWAYS_DIRTY_MASK\t((1U << VMCB_INTR) | (1U << VMCB_CR2))\n\nstatic inline void mark_all_clean(struct vmcb *vmcb)\n{\n\tvmcb->control.clean = ((1 << VMCB_DIRTY_MAX) - 1)\n\t\t\t       & ~VMCB_ALWAYS_DIRTY_MASK;\n}"
  },
  {
    "function_name": "mark_all_dirty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
    "lines": "278-281",
    "snippet": "static inline void mark_all_dirty(struct vmcb *vmcb)\n{\n\tvmcb->control.clean = 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic inline void mark_all_dirty(struct vmcb *vmcb)\n{\n\tvmcb->control.clean = 0;\n}"
  }
]