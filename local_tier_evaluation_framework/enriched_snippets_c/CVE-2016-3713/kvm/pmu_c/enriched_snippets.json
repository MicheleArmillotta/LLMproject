[
  {
    "function_name": "kvm_pmu_destroy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/pmu.c",
    "lines": "306-309",
    "snippet": "void kvm_pmu_destroy(struct kvm_vcpu *vcpu)\n{\n\tkvm_pmu_reset(vcpu);\n}",
    "includes": [
      "#include \"pmu.h\"",
      "#include \"lapic.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include <asm/perf_event.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_pmu_reset",
          "args": [
            "vcpu"
          ],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_pmu_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/pmu.c",
          "lines": "288-294",
          "snippet": "void kvm_pmu_reset(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_pmu *pmu = vcpu_to_pmu(vcpu);\n\n\tirq_work_sync(&pmu->irq_work);\n\tkvm_x86_ops->pmu_ops->reset(vcpu);\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"lapic.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include <asm/perf_event.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include <asm/perf_event.h>\n#include <linux/perf_event.h>\n#include <linux/kvm_host.h>\n#include <linux/types.h>\n\nvoid kvm_pmu_reset(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_pmu *pmu = vcpu_to_pmu(vcpu);\n\n\tirq_work_sync(&pmu->irq_work);\n\tkvm_x86_ops->pmu_ops->reset(vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include <asm/perf_event.h>\n#include <linux/perf_event.h>\n#include <linux/kvm_host.h>\n#include <linux/types.h>\n\nvoid kvm_pmu_destroy(struct kvm_vcpu *vcpu)\n{\n\tkvm_pmu_reset(vcpu);\n}"
  },
  {
    "function_name": "kvm_pmu_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/pmu.c",
    "lines": "296-304",
    "snippet": "void kvm_pmu_init(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_pmu *pmu = vcpu_to_pmu(vcpu);\n\n\tmemset(pmu, 0, sizeof(*pmu));\n\tkvm_x86_ops->pmu_ops->init(vcpu);\n\tinit_irq_work(&pmu->irq_work, kvm_pmi_trigger_fn);\n\tkvm_pmu_refresh(vcpu);\n}",
    "includes": [
      "#include \"pmu.h\"",
      "#include \"lapic.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include <asm/perf_event.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_pmu_refresh",
          "args": [
            "vcpu"
          ],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_pmu_refresh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/pmu.c",
          "lines": "283-286",
          "snippet": "void kvm_pmu_refresh(struct kvm_vcpu *vcpu)\n{\n\tkvm_x86_ops->pmu_ops->refresh(vcpu);\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"lapic.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include <asm/perf_event.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include <asm/perf_event.h>\n#include <linux/perf_event.h>\n#include <linux/kvm_host.h>\n#include <linux/types.h>\n\nvoid kvm_pmu_refresh(struct kvm_vcpu *vcpu)\n{\n\tkvm_x86_ops->pmu_ops->refresh(vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_irq_work",
          "args": [
            "&pmu->irq_work",
            "kvm_pmi_trigger_fn"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_x86_ops->pmu_ops->init",
          "args": [
            "vcpu"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "pmu",
            "0",
            "sizeof(*pmu)"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vcpu_to_pmu",
          "args": [
            "vcpu"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include <asm/perf_event.h>\n#include <linux/perf_event.h>\n#include <linux/kvm_host.h>\n#include <linux/types.h>\n\nvoid kvm_pmu_init(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_pmu *pmu = vcpu_to_pmu(vcpu);\n\n\tmemset(pmu, 0, sizeof(*pmu));\n\tkvm_x86_ops->pmu_ops->init(vcpu);\n\tinit_irq_work(&pmu->irq_work, kvm_pmi_trigger_fn);\n\tkvm_pmu_refresh(vcpu);\n}"
  },
  {
    "function_name": "kvm_pmu_reset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/pmu.c",
    "lines": "288-294",
    "snippet": "void kvm_pmu_reset(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_pmu *pmu = vcpu_to_pmu(vcpu);\n\n\tirq_work_sync(&pmu->irq_work);\n\tkvm_x86_ops->pmu_ops->reset(vcpu);\n}",
    "includes": [
      "#include \"pmu.h\"",
      "#include \"lapic.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include <asm/perf_event.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_x86_ops->pmu_ops->reset",
          "args": [
            "vcpu"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_work_sync",
          "args": [
            "&pmu->irq_work"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vcpu_to_pmu",
          "args": [
            "vcpu"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include <asm/perf_event.h>\n#include <linux/perf_event.h>\n#include <linux/kvm_host.h>\n#include <linux/types.h>\n\nvoid kvm_pmu_reset(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_pmu *pmu = vcpu_to_pmu(vcpu);\n\n\tirq_work_sync(&pmu->irq_work);\n\tkvm_x86_ops->pmu_ops->reset(vcpu);\n}"
  },
  {
    "function_name": "kvm_pmu_refresh",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/pmu.c",
    "lines": "283-286",
    "snippet": "void kvm_pmu_refresh(struct kvm_vcpu *vcpu)\n{\n\tkvm_x86_ops->pmu_ops->refresh(vcpu);\n}",
    "includes": [
      "#include \"pmu.h\"",
      "#include \"lapic.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include <asm/perf_event.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_x86_ops->pmu_ops->refresh",
          "args": [
            "vcpu"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include <asm/perf_event.h>\n#include <linux/perf_event.h>\n#include <linux/kvm_host.h>\n#include <linux/types.h>\n\nvoid kvm_pmu_refresh(struct kvm_vcpu *vcpu)\n{\n\tkvm_x86_ops->pmu_ops->refresh(vcpu);\n}"
  },
  {
    "function_name": "kvm_pmu_set_msr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/pmu.c",
    "lines": "274-277",
    "snippet": "int kvm_pmu_set_msr(struct kvm_vcpu *vcpu, struct msr_data *msr_info)\n{\n\treturn kvm_x86_ops->pmu_ops->set_msr(vcpu, msr_info);\n}",
    "includes": [
      "#include \"pmu.h\"",
      "#include \"lapic.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include <asm/perf_event.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_x86_ops->pmu_ops->set_msr",
          "args": [
            "vcpu",
            "msr_info"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include <asm/perf_event.h>\n#include <linux/perf_event.h>\n#include <linux/kvm_host.h>\n#include <linux/types.h>\n\nint kvm_pmu_set_msr(struct kvm_vcpu *vcpu, struct msr_data *msr_info)\n{\n\treturn kvm_x86_ops->pmu_ops->set_msr(vcpu, msr_info);\n}"
  },
  {
    "function_name": "kvm_pmu_get_msr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/pmu.c",
    "lines": "269-272",
    "snippet": "int kvm_pmu_get_msr(struct kvm_vcpu *vcpu, u32 msr, u64 *data)\n{\n\treturn kvm_x86_ops->pmu_ops->get_msr(vcpu, msr, data);\n}",
    "includes": [
      "#include \"pmu.h\"",
      "#include \"lapic.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include <asm/perf_event.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_x86_ops->pmu_ops->get_msr",
          "args": [
            "vcpu",
            "msr",
            "data"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include <asm/perf_event.h>\n#include <linux/perf_event.h>\n#include <linux/kvm_host.h>\n#include <linux/types.h>\n\nint kvm_pmu_get_msr(struct kvm_vcpu *vcpu, u32 msr, u64 *data)\n{\n\treturn kvm_x86_ops->pmu_ops->get_msr(vcpu, msr, data);\n}"
  },
  {
    "function_name": "kvm_pmu_is_valid_msr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/pmu.c",
    "lines": "264-267",
    "snippet": "bool kvm_pmu_is_valid_msr(struct kvm_vcpu *vcpu, u32 msr)\n{\n\treturn kvm_x86_ops->pmu_ops->is_valid_msr(vcpu, msr);\n}",
    "includes": [
      "#include \"pmu.h\"",
      "#include \"lapic.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include <asm/perf_event.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_x86_ops->pmu_ops->is_valid_msr",
          "args": [
            "vcpu",
            "msr"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include <asm/perf_event.h>\n#include <linux/perf_event.h>\n#include <linux/kvm_host.h>\n#include <linux/types.h>\n\nbool kvm_pmu_is_valid_msr(struct kvm_vcpu *vcpu, u32 msr)\n{\n\treturn kvm_x86_ops->pmu_ops->is_valid_msr(vcpu, msr);\n}"
  },
  {
    "function_name": "kvm_pmu_deliver_pmi",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/pmu.c",
    "lines": "258-262",
    "snippet": "void kvm_pmu_deliver_pmi(struct kvm_vcpu *vcpu)\n{\n\tif (lapic_in_kernel(vcpu))\n\t\tkvm_apic_local_deliver(vcpu->arch.apic, APIC_LVTPC);\n}",
    "includes": [
      "#include \"pmu.h\"",
      "#include \"lapic.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include <asm/perf_event.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_apic_local_deliver",
          "args": [
            "vcpu->arch.apic",
            "APIC_LVTPC"
          ],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_local_deliver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "1786-1799",
          "snippet": "int kvm_apic_local_deliver(struct kvm_lapic *apic, int lvt_type)\n{\n\tu32 reg = kvm_lapic_get_reg(apic, lvt_type);\n\tint vector, mode, trig_mode;\n\n\tif (kvm_apic_hw_enabled(apic) && !(reg & APIC_LVT_MASKED)) {\n\t\tvector = reg & APIC_VECTOR_MASK;\n\t\tmode = reg & APIC_MODE_MASK;\n\t\ttrig_mode = reg & APIC_LVT_LEVEL_TRIGGER;\n\t\treturn __apic_accept_irq(apic, mode, vector, 1, trig_mode,\n\t\t\t\t\tNULL);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nint kvm_apic_local_deliver(struct kvm_lapic *apic, int lvt_type)\n{\n\tu32 reg = kvm_lapic_get_reg(apic, lvt_type);\n\tint vector, mode, trig_mode;\n\n\tif (kvm_apic_hw_enabled(apic) && !(reg & APIC_LVT_MASKED)) {\n\t\tvector = reg & APIC_VECTOR_MASK;\n\t\tmode = reg & APIC_MODE_MASK;\n\t\ttrig_mode = reg & APIC_LVT_LEVEL_TRIGGER;\n\t\treturn __apic_accept_irq(apic, mode, vector, 1, trig_mode,\n\t\t\t\t\tNULL);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lapic_in_kernel",
          "args": [
            "vcpu"
          ],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "lapic_in_kernel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.h",
          "lines": "141-146",
          "snippet": "static inline bool lapic_in_kernel(struct kvm_vcpu *vcpu)\n{\n\tif (static_key_false(&kvm_no_apic_vcpu))\n\t\treturn vcpu->arch.apic;\n\treturn true;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline bool lapic_in_kernel(struct kvm_vcpu *vcpu)\n{\n\tif (static_key_false(&kvm_no_apic_vcpu))\n\t\treturn vcpu->arch.apic;\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include <asm/perf_event.h>\n#include <linux/perf_event.h>\n#include <linux/kvm_host.h>\n#include <linux/types.h>\n\nvoid kvm_pmu_deliver_pmi(struct kvm_vcpu *vcpu)\n{\n\tif (lapic_in_kernel(vcpu))\n\t\tkvm_apic_local_deliver(vcpu->arch.apic, APIC_LVTPC);\n}"
  },
  {
    "function_name": "kvm_pmu_rdpmc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/pmu.c",
    "lines": "240-256",
    "snippet": "int kvm_pmu_rdpmc(struct kvm_vcpu *vcpu, unsigned idx, u64 *data)\n{\n\tbool fast_mode = idx & (1u << 31);\n\tstruct kvm_pmc *pmc;\n\tu64 ctr_val;\n\n\tpmc = kvm_x86_ops->pmu_ops->msr_idx_to_pmc(vcpu, idx);\n\tif (!pmc)\n\t\treturn 1;\n\n\tctr_val = pmc_read_counter(pmc);\n\tif (fast_mode)\n\t\tctr_val = (u32)ctr_val;\n\n\t*data = ctr_val;\n\treturn 0;\n}",
    "includes": [
      "#include \"pmu.h\"",
      "#include \"lapic.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include <asm/perf_event.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pmc_read_counter",
          "args": [
            "pmc"
          ],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "pmc_read_counter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/pmu.h",
          "lines": "40-50",
          "snippet": "static inline u64 pmc_read_counter(struct kvm_pmc *pmc)\n{\n\tu64 counter, enabled, running;\n\n\tcounter = pmc->counter;\n\tif (pmc->perf_event)\n\t\tcounter += perf_event_read_value(pmc->perf_event,\n\t\t\t\t\t\t &enabled, &running);\n\t/* FIXME: Scaling needed? */\n\treturn counter & pmc_bitmask(pmc);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline u64 pmc_read_counter(struct kvm_pmc *pmc)\n{\n\tu64 counter, enabled, running;\n\n\tcounter = pmc->counter;\n\tif (pmc->perf_event)\n\t\tcounter += perf_event_read_value(pmc->perf_event,\n\t\t\t\t\t\t &enabled, &running);\n\t/* FIXME: Scaling needed? */\n\treturn counter & pmc_bitmask(pmc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_x86_ops->pmu_ops->msr_idx_to_pmc",
          "args": [
            "vcpu",
            "idx"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include <asm/perf_event.h>\n#include <linux/perf_event.h>\n#include <linux/kvm_host.h>\n#include <linux/types.h>\n\nint kvm_pmu_rdpmc(struct kvm_vcpu *vcpu, unsigned idx, u64 *data)\n{\n\tbool fast_mode = idx & (1u << 31);\n\tstruct kvm_pmc *pmc;\n\tu64 ctr_val;\n\n\tpmc = kvm_x86_ops->pmu_ops->msr_idx_to_pmc(vcpu, idx);\n\tif (!pmc)\n\t\treturn 1;\n\n\tctr_val = pmc_read_counter(pmc);\n\tif (fast_mode)\n\t\tctr_val = (u32)ctr_val;\n\n\t*data = ctr_val;\n\treturn 0;\n}"
  },
  {
    "function_name": "kvm_pmu_is_valid_msr_idx",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/pmu.c",
    "lines": "235-238",
    "snippet": "int kvm_pmu_is_valid_msr_idx(struct kvm_vcpu *vcpu, unsigned idx)\n{\n\treturn kvm_x86_ops->pmu_ops->is_valid_msr_idx(vcpu, idx);\n}",
    "includes": [
      "#include \"pmu.h\"",
      "#include \"lapic.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include <asm/perf_event.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_x86_ops->pmu_ops->is_valid_msr_idx",
          "args": [
            "vcpu",
            "idx"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include <asm/perf_event.h>\n#include <linux/perf_event.h>\n#include <linux/kvm_host.h>\n#include <linux/types.h>\n\nint kvm_pmu_is_valid_msr_idx(struct kvm_vcpu *vcpu, unsigned idx)\n{\n\treturn kvm_x86_ops->pmu_ops->is_valid_msr_idx(vcpu, idx);\n}"
  },
  {
    "function_name": "kvm_pmu_handle_event",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/pmu.c",
    "lines": "214-232",
    "snippet": "void kvm_pmu_handle_event(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_pmu *pmu = vcpu_to_pmu(vcpu);\n\tu64 bitmask;\n\tint bit;\n\n\tbitmask = pmu->reprogram_pmi;\n\n\tfor_each_set_bit(bit, (unsigned long *)&bitmask, X86_PMC_IDX_MAX) {\n\t\tstruct kvm_pmc *pmc = kvm_x86_ops->pmu_ops->pmc_idx_to_pmc(pmu, bit);\n\n\t\tif (unlikely(!pmc || !pmc->perf_event)) {\n\t\t\tclear_bit(bit, (unsigned long *)&pmu->reprogram_pmi);\n\t\t\tcontinue;\n\t\t}\n\n\t\treprogram_counter(pmu, bit);\n\t}\n}",
    "includes": [
      "#include \"pmu.h\"",
      "#include \"lapic.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include <asm/perf_event.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reprogram_counter",
          "args": [
            "pmu",
            "bit"
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "reprogram_counter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/pmu.c",
          "lines": "196-211",
          "snippet": "void reprogram_counter(struct kvm_pmu *pmu, int pmc_idx)\n{\n\tstruct kvm_pmc *pmc = kvm_x86_ops->pmu_ops->pmc_idx_to_pmc(pmu, pmc_idx);\n\n\tif (!pmc)\n\t\treturn;\n\n\tif (pmc_is_gp(pmc))\n\t\treprogram_gp_counter(pmc, pmc->eventsel);\n\telse {\n\t\tint idx = pmc_idx - INTEL_PMC_IDX_FIXED;\n\t\tu8 ctrl = fixed_ctrl_field(pmu->fixed_ctr_ctrl, idx);\n\n\t\treprogram_fixed_counter(pmc, ctrl, idx);\n\t}\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"lapic.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include <asm/perf_event.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include <asm/perf_event.h>\n#include <linux/perf_event.h>\n#include <linux/kvm_host.h>\n#include <linux/types.h>\n\nvoid reprogram_counter(struct kvm_pmu *pmu, int pmc_idx)\n{\n\tstruct kvm_pmc *pmc = kvm_x86_ops->pmu_ops->pmc_idx_to_pmc(pmu, pmc_idx);\n\n\tif (!pmc)\n\t\treturn;\n\n\tif (pmc_is_gp(pmc))\n\t\treprogram_gp_counter(pmc, pmc->eventsel);\n\telse {\n\t\tint idx = pmc_idx - INTEL_PMC_IDX_FIXED;\n\t\tu8 ctrl = fixed_ctrl_field(pmu->fixed_ctr_ctrl, idx);\n\n\t\treprogram_fixed_counter(pmc, ctrl, idx);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "bit",
            "(unsigned long *)&pmu->reprogram_pmi"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_clear_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/vmx.c",
          "lines": "1592-1597",
          "snippet": "static __always_inline void vmcs_clear_bits(unsigned long field, u32 mask)\n{\n        BUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x2000,\n\t\t\t \"vmcs_clear_bits does not support 64-bit fields\");\n\t__vmcs_writel(field, __vmcs_readl(field) & ~mask);\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"trace.h\"",
            "#include <asm/irq_remapping.h>",
            "#include <asm/apic.h>",
            "#include <asm/kexec.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/mce.h>",
            "#include <asm/virtext.h>",
            "#include <asm/vmx.h>",
            "#include <asm/desc.h>",
            "#include <asm/io.h>",
            "#include <asm/cpu.h>",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/hrtimer.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include \"lapic.h\"",
            "#include \"cpuid.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"trace.h\"\n#include <asm/irq_remapping.h>\n#include <asm/apic.h>\n#include <asm/kexec.h>\n#include <asm/debugreg.h>\n#include <asm/perf_event.h>\n#include <asm/fpu/internal.h>\n#include <asm/mce.h>\n#include <asm/virtext.h>\n#include <asm/vmx.h>\n#include <asm/desc.h>\n#include <asm/io.h>\n#include <asm/cpu.h>\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/hrtimer.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic __always_inline void vmcs_clear_bits(unsigned long field, u32 mask)\n{\n        BUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x2000,\n\t\t\t \"vmcs_clear_bits does not support 64-bit fields\");\n\t__vmcs_writel(field, __vmcs_readl(field) & ~mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!pmc || !pmc->perf_event"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_x86_ops->pmu_ops->pmc_idx_to_pmc",
          "args": [
            "pmu",
            "bit"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_set_bit",
          "args": [
            "bit",
            "(unsigned long *)&bitmask",
            "X86_PMC_IDX_MAX"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vcpu_to_pmu",
          "args": [
            "vcpu"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include <asm/perf_event.h>\n#include <linux/perf_event.h>\n#include <linux/kvm_host.h>\n#include <linux/types.h>\n\nvoid kvm_pmu_handle_event(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_pmu *pmu = vcpu_to_pmu(vcpu);\n\tu64 bitmask;\n\tint bit;\n\n\tbitmask = pmu->reprogram_pmi;\n\n\tfor_each_set_bit(bit, (unsigned long *)&bitmask, X86_PMC_IDX_MAX) {\n\t\tstruct kvm_pmc *pmc = kvm_x86_ops->pmu_ops->pmc_idx_to_pmc(pmu, bit);\n\n\t\tif (unlikely(!pmc || !pmc->perf_event)) {\n\t\t\tclear_bit(bit, (unsigned long *)&pmu->reprogram_pmi);\n\t\t\tcontinue;\n\t\t}\n\n\t\treprogram_counter(pmu, bit);\n\t}\n}"
  },
  {
    "function_name": "reprogram_counter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/pmu.c",
    "lines": "196-211",
    "snippet": "void reprogram_counter(struct kvm_pmu *pmu, int pmc_idx)\n{\n\tstruct kvm_pmc *pmc = kvm_x86_ops->pmu_ops->pmc_idx_to_pmc(pmu, pmc_idx);\n\n\tif (!pmc)\n\t\treturn;\n\n\tif (pmc_is_gp(pmc))\n\t\treprogram_gp_counter(pmc, pmc->eventsel);\n\telse {\n\t\tint idx = pmc_idx - INTEL_PMC_IDX_FIXED;\n\t\tu8 ctrl = fixed_ctrl_field(pmu->fixed_ctr_ctrl, idx);\n\n\t\treprogram_fixed_counter(pmc, ctrl, idx);\n\t}\n}",
    "includes": [
      "#include \"pmu.h\"",
      "#include \"lapic.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include <asm/perf_event.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reprogram_fixed_counter",
          "args": [
            "pmc",
            "ctrl",
            "idx"
          ],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "reprogram_fixed_counter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/pmu.c",
          "lines": "178-193",
          "snippet": "void reprogram_fixed_counter(struct kvm_pmc *pmc, u8 ctrl, int idx)\n{\n\tunsigned en_field = ctrl & 0x3;\n\tbool pmi = ctrl & 0x8;\n\n\tpmc_stop_counter(pmc);\n\n\tif (!en_field || !pmc_is_enabled(pmc))\n\t\treturn;\n\n\tpmc_reprogram_counter(pmc, PERF_TYPE_HARDWARE,\n\t\t\t      kvm_x86_ops->pmu_ops->find_fixed_event(idx),\n\t\t\t      !(en_field & 0x2), /* exclude user */\n\t\t\t      !(en_field & 0x1), /* exclude kernel */\n\t\t\t      pmi, false, false);\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"lapic.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include <asm/perf_event.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include <asm/perf_event.h>\n#include <linux/perf_event.h>\n#include <linux/kvm_host.h>\n#include <linux/types.h>\n\nvoid reprogram_fixed_counter(struct kvm_pmc *pmc, u8 ctrl, int idx)\n{\n\tunsigned en_field = ctrl & 0x3;\n\tbool pmi = ctrl & 0x8;\n\n\tpmc_stop_counter(pmc);\n\n\tif (!en_field || !pmc_is_enabled(pmc))\n\t\treturn;\n\n\tpmc_reprogram_counter(pmc, PERF_TYPE_HARDWARE,\n\t\t\t      kvm_x86_ops->pmu_ops->find_fixed_event(idx),\n\t\t\t      !(en_field & 0x2), /* exclude user */\n\t\t\t      !(en_field & 0x1), /* exclude kernel */\n\t\t\t      pmi, false, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fixed_ctrl_field",
          "args": [
            "pmu->fixed_ctr_ctrl",
            "idx"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reprogram_gp_counter",
          "args": [
            "pmc",
            "pmc->eventsel"
          ],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "reprogram_gp_counter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/pmu.c",
          "lines": "136-175",
          "snippet": "void reprogram_gp_counter(struct kvm_pmc *pmc, u64 eventsel)\n{\n\tunsigned config, type = PERF_TYPE_RAW;\n\tu8 event_select, unit_mask;\n\n\tif (eventsel & ARCH_PERFMON_EVENTSEL_PIN_CONTROL)\n\t\tprintk_once(\"kvm pmu: pin control bit is ignored\\n\");\n\n\tpmc->eventsel = eventsel;\n\n\tpmc_stop_counter(pmc);\n\n\tif (!(eventsel & ARCH_PERFMON_EVENTSEL_ENABLE) || !pmc_is_enabled(pmc))\n\t\treturn;\n\n\tevent_select = eventsel & ARCH_PERFMON_EVENTSEL_EVENT;\n\tunit_mask = (eventsel & ARCH_PERFMON_EVENTSEL_UMASK) >> 8;\n\n\tif (!(eventsel & (ARCH_PERFMON_EVENTSEL_EDGE |\n\t\t\t  ARCH_PERFMON_EVENTSEL_INV |\n\t\t\t  ARCH_PERFMON_EVENTSEL_CMASK |\n\t\t\t  HSW_IN_TX |\n\t\t\t  HSW_IN_TX_CHECKPOINTED))) {\n\t\tconfig = kvm_x86_ops->pmu_ops->find_arch_event(pmc_to_pmu(pmc),\n\t\t\t\t\t\t      event_select,\n\t\t\t\t\t\t      unit_mask);\n\t\tif (config != PERF_COUNT_HW_MAX)\n\t\t\ttype = PERF_TYPE_HARDWARE;\n\t}\n\n\tif (type == PERF_TYPE_RAW)\n\t\tconfig = eventsel & X86_RAW_EVENT_MASK;\n\n\tpmc_reprogram_counter(pmc, type, config,\n\t\t\t      !(eventsel & ARCH_PERFMON_EVENTSEL_USR),\n\t\t\t      !(eventsel & ARCH_PERFMON_EVENTSEL_OS),\n\t\t\t      eventsel & ARCH_PERFMON_EVENTSEL_INT,\n\t\t\t      (eventsel & HSW_IN_TX),\n\t\t\t      (eventsel & HSW_IN_TX_CHECKPOINTED));\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"lapic.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include <asm/perf_event.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include <asm/perf_event.h>\n#include <linux/perf_event.h>\n#include <linux/kvm_host.h>\n#include <linux/types.h>\n\nvoid reprogram_gp_counter(struct kvm_pmc *pmc, u64 eventsel)\n{\n\tunsigned config, type = PERF_TYPE_RAW;\n\tu8 event_select, unit_mask;\n\n\tif (eventsel & ARCH_PERFMON_EVENTSEL_PIN_CONTROL)\n\t\tprintk_once(\"kvm pmu: pin control bit is ignored\\n\");\n\n\tpmc->eventsel = eventsel;\n\n\tpmc_stop_counter(pmc);\n\n\tif (!(eventsel & ARCH_PERFMON_EVENTSEL_ENABLE) || !pmc_is_enabled(pmc))\n\t\treturn;\n\n\tevent_select = eventsel & ARCH_PERFMON_EVENTSEL_EVENT;\n\tunit_mask = (eventsel & ARCH_PERFMON_EVENTSEL_UMASK) >> 8;\n\n\tif (!(eventsel & (ARCH_PERFMON_EVENTSEL_EDGE |\n\t\t\t  ARCH_PERFMON_EVENTSEL_INV |\n\t\t\t  ARCH_PERFMON_EVENTSEL_CMASK |\n\t\t\t  HSW_IN_TX |\n\t\t\t  HSW_IN_TX_CHECKPOINTED))) {\n\t\tconfig = kvm_x86_ops->pmu_ops->find_arch_event(pmc_to_pmu(pmc),\n\t\t\t\t\t\t      event_select,\n\t\t\t\t\t\t      unit_mask);\n\t\tif (config != PERF_COUNT_HW_MAX)\n\t\t\ttype = PERF_TYPE_HARDWARE;\n\t}\n\n\tif (type == PERF_TYPE_RAW)\n\t\tconfig = eventsel & X86_RAW_EVENT_MASK;\n\n\tpmc_reprogram_counter(pmc, type, config,\n\t\t\t      !(eventsel & ARCH_PERFMON_EVENTSEL_USR),\n\t\t\t      !(eventsel & ARCH_PERFMON_EVENTSEL_OS),\n\t\t\t      eventsel & ARCH_PERFMON_EVENTSEL_INT,\n\t\t\t      (eventsel & HSW_IN_TX),\n\t\t\t      (eventsel & HSW_IN_TX_CHECKPOINTED));\n}"
        }
      },
      {
        "call_info": {
          "callee": "pmc_is_gp",
          "args": [
            "pmc"
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "pmc_is_gp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/pmu.h",
          "lines": "61-64",
          "snippet": "static inline bool pmc_is_gp(struct kvm_pmc *pmc)\n{\n\treturn pmc->type == KVM_PMC_GP;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline bool pmc_is_gp(struct kvm_pmc *pmc)\n{\n\treturn pmc->type == KVM_PMC_GP;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_x86_ops->pmu_ops->pmc_idx_to_pmc",
          "args": [
            "pmu",
            "pmc_idx"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include <asm/perf_event.h>\n#include <linux/perf_event.h>\n#include <linux/kvm_host.h>\n#include <linux/types.h>\n\nvoid reprogram_counter(struct kvm_pmu *pmu, int pmc_idx)\n{\n\tstruct kvm_pmc *pmc = kvm_x86_ops->pmu_ops->pmc_idx_to_pmc(pmu, pmc_idx);\n\n\tif (!pmc)\n\t\treturn;\n\n\tif (pmc_is_gp(pmc))\n\t\treprogram_gp_counter(pmc, pmc->eventsel);\n\telse {\n\t\tint idx = pmc_idx - INTEL_PMC_IDX_FIXED;\n\t\tu8 ctrl = fixed_ctrl_field(pmu->fixed_ctr_ctrl, idx);\n\n\t\treprogram_fixed_counter(pmc, ctrl, idx);\n\t}\n}"
  },
  {
    "function_name": "reprogram_fixed_counter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/pmu.c",
    "lines": "178-193",
    "snippet": "void reprogram_fixed_counter(struct kvm_pmc *pmc, u8 ctrl, int idx)\n{\n\tunsigned en_field = ctrl & 0x3;\n\tbool pmi = ctrl & 0x8;\n\n\tpmc_stop_counter(pmc);\n\n\tif (!en_field || !pmc_is_enabled(pmc))\n\t\treturn;\n\n\tpmc_reprogram_counter(pmc, PERF_TYPE_HARDWARE,\n\t\t\t      kvm_x86_ops->pmu_ops->find_fixed_event(idx),\n\t\t\t      !(en_field & 0x2), /* exclude user */\n\t\t\t      !(en_field & 0x1), /* exclude kernel */\n\t\t\t      pmi, false, false);\n}",
    "includes": [
      "#include \"pmu.h\"",
      "#include \"lapic.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include <asm/perf_event.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pmc_reprogram_counter",
          "args": [
            "pmc",
            "PERF_TYPE_HARDWARE",
            "kvm_x86_ops->pmu_ops->find_fixed_event(idx)",
            "!(en_field & 0x2)",
            "/* exclude user */!(en_field & 0x1)",
            "/* exclude kernel */pmi",
            "false",
            "false"
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "pmc_reprogram_counter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/pmu.c",
          "lines": "99-134",
          "snippet": "static void pmc_reprogram_counter(struct kvm_pmc *pmc, u32 type,\n\t\t\t\t  unsigned config, bool exclude_user,\n\t\t\t\t  bool exclude_kernel, bool intr,\n\t\t\t\t  bool in_tx, bool in_tx_cp)\n{\n\tstruct perf_event *event;\n\tstruct perf_event_attr attr = {\n\t\t.type = type,\n\t\t.size = sizeof(attr),\n\t\t.pinned = true,\n\t\t.exclude_idle = true,\n\t\t.exclude_host = 1,\n\t\t.exclude_user = exclude_user,\n\t\t.exclude_kernel = exclude_kernel,\n\t\t.config = config,\n\t};\n\n\tif (in_tx)\n\t\tattr.config |= HSW_IN_TX;\n\tif (in_tx_cp)\n\t\tattr.config |= HSW_IN_TX_CHECKPOINTED;\n\n\tattr.sample_period = (-pmc->counter) & pmc_bitmask(pmc);\n\n\tevent = perf_event_create_kernel_counter(&attr, -1, current,\n\t\t\t\t\t\t intr ? kvm_perf_overflow_intr :\n\t\t\t\t\t\t kvm_perf_overflow, pmc);\n\tif (IS_ERR(event)) {\n\t\tprintk_once(\"kvm_pmu: event creation failed %ld\\n\",\n\t\t\t    PTR_ERR(event));\n\t\treturn;\n\t}\n\n\tpmc->perf_event = event;\n\tclear_bit(pmc->idx, (unsigned long*)&pmc_to_pmu(pmc)->reprogram_pmi);\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"lapic.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include <asm/perf_event.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include <asm/perf_event.h>\n#include <linux/perf_event.h>\n#include <linux/kvm_host.h>\n#include <linux/types.h>\n\nstatic void pmc_reprogram_counter(struct kvm_pmc *pmc, u32 type,\n\t\t\t\t  unsigned config, bool exclude_user,\n\t\t\t\t  bool exclude_kernel, bool intr,\n\t\t\t\t  bool in_tx, bool in_tx_cp)\n{\n\tstruct perf_event *event;\n\tstruct perf_event_attr attr = {\n\t\t.type = type,\n\t\t.size = sizeof(attr),\n\t\t.pinned = true,\n\t\t.exclude_idle = true,\n\t\t.exclude_host = 1,\n\t\t.exclude_user = exclude_user,\n\t\t.exclude_kernel = exclude_kernel,\n\t\t.config = config,\n\t};\n\n\tif (in_tx)\n\t\tattr.config |= HSW_IN_TX;\n\tif (in_tx_cp)\n\t\tattr.config |= HSW_IN_TX_CHECKPOINTED;\n\n\tattr.sample_period = (-pmc->counter) & pmc_bitmask(pmc);\n\n\tevent = perf_event_create_kernel_counter(&attr, -1, current,\n\t\t\t\t\t\t intr ? kvm_perf_overflow_intr :\n\t\t\t\t\t\t kvm_perf_overflow, pmc);\n\tif (IS_ERR(event)) {\n\t\tprintk_once(\"kvm_pmu: event creation failed %ld\\n\",\n\t\t\t    PTR_ERR(event));\n\t\treturn;\n\t}\n\n\tpmc->perf_event = event;\n\tclear_bit(pmc->idx, (unsigned long*)&pmc_to_pmu(pmc)->reprogram_pmi);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_x86_ops->pmu_ops->find_fixed_event",
          "args": [
            "idx"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmc_is_enabled",
          "args": [
            "pmc"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "pmc_is_enabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/pmu.h",
          "lines": "71-74",
          "snippet": "static inline bool pmc_is_enabled(struct kvm_pmc *pmc)\n{\n\treturn kvm_x86_ops->pmu_ops->pmc_is_enabled(pmc);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline bool pmc_is_enabled(struct kvm_pmc *pmc)\n{\n\treturn kvm_x86_ops->pmu_ops->pmc_is_enabled(pmc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pmc_stop_counter",
          "args": [
            "pmc"
          ],
          "line": 183
        },
        "resolved": true,
        "details": {
          "function_name": "pmc_stop_counter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/pmu.h",
          "lines": "52-59",
          "snippet": "static inline void pmc_stop_counter(struct kvm_pmc *pmc)\n{\n\tif (pmc->perf_event) {\n\t\tpmc->counter = pmc_read_counter(pmc);\n\t\tperf_event_release_kernel(pmc->perf_event);\n\t\tpmc->perf_event = NULL;\n\t}\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void pmc_stop_counter(struct kvm_pmc *pmc)\n{\n\tif (pmc->perf_event) {\n\t\tpmc->counter = pmc_read_counter(pmc);\n\t\tperf_event_release_kernel(pmc->perf_event);\n\t\tpmc->perf_event = NULL;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include <asm/perf_event.h>\n#include <linux/perf_event.h>\n#include <linux/kvm_host.h>\n#include <linux/types.h>\n\nvoid reprogram_fixed_counter(struct kvm_pmc *pmc, u8 ctrl, int idx)\n{\n\tunsigned en_field = ctrl & 0x3;\n\tbool pmi = ctrl & 0x8;\n\n\tpmc_stop_counter(pmc);\n\n\tif (!en_field || !pmc_is_enabled(pmc))\n\t\treturn;\n\n\tpmc_reprogram_counter(pmc, PERF_TYPE_HARDWARE,\n\t\t\t      kvm_x86_ops->pmu_ops->find_fixed_event(idx),\n\t\t\t      !(en_field & 0x2), /* exclude user */\n\t\t\t      !(en_field & 0x1), /* exclude kernel */\n\t\t\t      pmi, false, false);\n}"
  },
  {
    "function_name": "reprogram_gp_counter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/pmu.c",
    "lines": "136-175",
    "snippet": "void reprogram_gp_counter(struct kvm_pmc *pmc, u64 eventsel)\n{\n\tunsigned config, type = PERF_TYPE_RAW;\n\tu8 event_select, unit_mask;\n\n\tif (eventsel & ARCH_PERFMON_EVENTSEL_PIN_CONTROL)\n\t\tprintk_once(\"kvm pmu: pin control bit is ignored\\n\");\n\n\tpmc->eventsel = eventsel;\n\n\tpmc_stop_counter(pmc);\n\n\tif (!(eventsel & ARCH_PERFMON_EVENTSEL_ENABLE) || !pmc_is_enabled(pmc))\n\t\treturn;\n\n\tevent_select = eventsel & ARCH_PERFMON_EVENTSEL_EVENT;\n\tunit_mask = (eventsel & ARCH_PERFMON_EVENTSEL_UMASK) >> 8;\n\n\tif (!(eventsel & (ARCH_PERFMON_EVENTSEL_EDGE |\n\t\t\t  ARCH_PERFMON_EVENTSEL_INV |\n\t\t\t  ARCH_PERFMON_EVENTSEL_CMASK |\n\t\t\t  HSW_IN_TX |\n\t\t\t  HSW_IN_TX_CHECKPOINTED))) {\n\t\tconfig = kvm_x86_ops->pmu_ops->find_arch_event(pmc_to_pmu(pmc),\n\t\t\t\t\t\t      event_select,\n\t\t\t\t\t\t      unit_mask);\n\t\tif (config != PERF_COUNT_HW_MAX)\n\t\t\ttype = PERF_TYPE_HARDWARE;\n\t}\n\n\tif (type == PERF_TYPE_RAW)\n\t\tconfig = eventsel & X86_RAW_EVENT_MASK;\n\n\tpmc_reprogram_counter(pmc, type, config,\n\t\t\t      !(eventsel & ARCH_PERFMON_EVENTSEL_USR),\n\t\t\t      !(eventsel & ARCH_PERFMON_EVENTSEL_OS),\n\t\t\t      eventsel & ARCH_PERFMON_EVENTSEL_INT,\n\t\t\t      (eventsel & HSW_IN_TX),\n\t\t\t      (eventsel & HSW_IN_TX_CHECKPOINTED));\n}",
    "includes": [
      "#include \"pmu.h\"",
      "#include \"lapic.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include <asm/perf_event.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pmc_reprogram_counter",
          "args": [
            "pmc",
            "type",
            "config",
            "!(eventsel & ARCH_PERFMON_EVENTSEL_USR)",
            "!(eventsel & ARCH_PERFMON_EVENTSEL_OS)",
            "eventsel & ARCH_PERFMON_EVENTSEL_INT",
            "(eventsel & HSW_IN_TX)",
            "(eventsel & HSW_IN_TX_CHECKPOINTED)"
          ],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "pmc_reprogram_counter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/pmu.c",
          "lines": "99-134",
          "snippet": "static void pmc_reprogram_counter(struct kvm_pmc *pmc, u32 type,\n\t\t\t\t  unsigned config, bool exclude_user,\n\t\t\t\t  bool exclude_kernel, bool intr,\n\t\t\t\t  bool in_tx, bool in_tx_cp)\n{\n\tstruct perf_event *event;\n\tstruct perf_event_attr attr = {\n\t\t.type = type,\n\t\t.size = sizeof(attr),\n\t\t.pinned = true,\n\t\t.exclude_idle = true,\n\t\t.exclude_host = 1,\n\t\t.exclude_user = exclude_user,\n\t\t.exclude_kernel = exclude_kernel,\n\t\t.config = config,\n\t};\n\n\tif (in_tx)\n\t\tattr.config |= HSW_IN_TX;\n\tif (in_tx_cp)\n\t\tattr.config |= HSW_IN_TX_CHECKPOINTED;\n\n\tattr.sample_period = (-pmc->counter) & pmc_bitmask(pmc);\n\n\tevent = perf_event_create_kernel_counter(&attr, -1, current,\n\t\t\t\t\t\t intr ? kvm_perf_overflow_intr :\n\t\t\t\t\t\t kvm_perf_overflow, pmc);\n\tif (IS_ERR(event)) {\n\t\tprintk_once(\"kvm_pmu: event creation failed %ld\\n\",\n\t\t\t    PTR_ERR(event));\n\t\treturn;\n\t}\n\n\tpmc->perf_event = event;\n\tclear_bit(pmc->idx, (unsigned long*)&pmc_to_pmu(pmc)->reprogram_pmi);\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"lapic.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include <asm/perf_event.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include <asm/perf_event.h>\n#include <linux/perf_event.h>\n#include <linux/kvm_host.h>\n#include <linux/types.h>\n\nstatic void pmc_reprogram_counter(struct kvm_pmc *pmc, u32 type,\n\t\t\t\t  unsigned config, bool exclude_user,\n\t\t\t\t  bool exclude_kernel, bool intr,\n\t\t\t\t  bool in_tx, bool in_tx_cp)\n{\n\tstruct perf_event *event;\n\tstruct perf_event_attr attr = {\n\t\t.type = type,\n\t\t.size = sizeof(attr),\n\t\t.pinned = true,\n\t\t.exclude_idle = true,\n\t\t.exclude_host = 1,\n\t\t.exclude_user = exclude_user,\n\t\t.exclude_kernel = exclude_kernel,\n\t\t.config = config,\n\t};\n\n\tif (in_tx)\n\t\tattr.config |= HSW_IN_TX;\n\tif (in_tx_cp)\n\t\tattr.config |= HSW_IN_TX_CHECKPOINTED;\n\n\tattr.sample_period = (-pmc->counter) & pmc_bitmask(pmc);\n\n\tevent = perf_event_create_kernel_counter(&attr, -1, current,\n\t\t\t\t\t\t intr ? kvm_perf_overflow_intr :\n\t\t\t\t\t\t kvm_perf_overflow, pmc);\n\tif (IS_ERR(event)) {\n\t\tprintk_once(\"kvm_pmu: event creation failed %ld\\n\",\n\t\t\t    PTR_ERR(event));\n\t\treturn;\n\t}\n\n\tpmc->perf_event = event;\n\tclear_bit(pmc->idx, (unsigned long*)&pmc_to_pmu(pmc)->reprogram_pmi);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_x86_ops->pmu_ops->find_arch_event",
          "args": [
            "pmc_to_pmu(pmc)",
            "event_select",
            "unit_mask"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmc_to_pmu",
          "args": [
            "pmc"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmc_is_enabled",
          "args": [
            "pmc"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "pmc_is_enabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/pmu.h",
          "lines": "71-74",
          "snippet": "static inline bool pmc_is_enabled(struct kvm_pmc *pmc)\n{\n\treturn kvm_x86_ops->pmu_ops->pmc_is_enabled(pmc);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline bool pmc_is_enabled(struct kvm_pmc *pmc)\n{\n\treturn kvm_x86_ops->pmu_ops->pmc_is_enabled(pmc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pmc_stop_counter",
          "args": [
            "pmc"
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "pmc_stop_counter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/pmu.h",
          "lines": "52-59",
          "snippet": "static inline void pmc_stop_counter(struct kvm_pmc *pmc)\n{\n\tif (pmc->perf_event) {\n\t\tpmc->counter = pmc_read_counter(pmc);\n\t\tperf_event_release_kernel(pmc->perf_event);\n\t\tpmc->perf_event = NULL;\n\t}\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void pmc_stop_counter(struct kvm_pmc *pmc)\n{\n\tif (pmc->perf_event) {\n\t\tpmc->counter = pmc_read_counter(pmc);\n\t\tperf_event_release_kernel(pmc->perf_event);\n\t\tpmc->perf_event = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk_once",
          "args": [
            "\"kvm pmu: pin control bit is ignored\\n\""
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include <asm/perf_event.h>\n#include <linux/perf_event.h>\n#include <linux/kvm_host.h>\n#include <linux/types.h>\n\nvoid reprogram_gp_counter(struct kvm_pmc *pmc, u64 eventsel)\n{\n\tunsigned config, type = PERF_TYPE_RAW;\n\tu8 event_select, unit_mask;\n\n\tif (eventsel & ARCH_PERFMON_EVENTSEL_PIN_CONTROL)\n\t\tprintk_once(\"kvm pmu: pin control bit is ignored\\n\");\n\n\tpmc->eventsel = eventsel;\n\n\tpmc_stop_counter(pmc);\n\n\tif (!(eventsel & ARCH_PERFMON_EVENTSEL_ENABLE) || !pmc_is_enabled(pmc))\n\t\treturn;\n\n\tevent_select = eventsel & ARCH_PERFMON_EVENTSEL_EVENT;\n\tunit_mask = (eventsel & ARCH_PERFMON_EVENTSEL_UMASK) >> 8;\n\n\tif (!(eventsel & (ARCH_PERFMON_EVENTSEL_EDGE |\n\t\t\t  ARCH_PERFMON_EVENTSEL_INV |\n\t\t\t  ARCH_PERFMON_EVENTSEL_CMASK |\n\t\t\t  HSW_IN_TX |\n\t\t\t  HSW_IN_TX_CHECKPOINTED))) {\n\t\tconfig = kvm_x86_ops->pmu_ops->find_arch_event(pmc_to_pmu(pmc),\n\t\t\t\t\t\t      event_select,\n\t\t\t\t\t\t      unit_mask);\n\t\tif (config != PERF_COUNT_HW_MAX)\n\t\t\ttype = PERF_TYPE_HARDWARE;\n\t}\n\n\tif (type == PERF_TYPE_RAW)\n\t\tconfig = eventsel & X86_RAW_EVENT_MASK;\n\n\tpmc_reprogram_counter(pmc, type, config,\n\t\t\t      !(eventsel & ARCH_PERFMON_EVENTSEL_USR),\n\t\t\t      !(eventsel & ARCH_PERFMON_EVENTSEL_OS),\n\t\t\t      eventsel & ARCH_PERFMON_EVENTSEL_INT,\n\t\t\t      (eventsel & HSW_IN_TX),\n\t\t\t      (eventsel & HSW_IN_TX_CHECKPOINTED));\n}"
  },
  {
    "function_name": "pmc_reprogram_counter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/pmu.c",
    "lines": "99-134",
    "snippet": "static void pmc_reprogram_counter(struct kvm_pmc *pmc, u32 type,\n\t\t\t\t  unsigned config, bool exclude_user,\n\t\t\t\t  bool exclude_kernel, bool intr,\n\t\t\t\t  bool in_tx, bool in_tx_cp)\n{\n\tstruct perf_event *event;\n\tstruct perf_event_attr attr = {\n\t\t.type = type,\n\t\t.size = sizeof(attr),\n\t\t.pinned = true,\n\t\t.exclude_idle = true,\n\t\t.exclude_host = 1,\n\t\t.exclude_user = exclude_user,\n\t\t.exclude_kernel = exclude_kernel,\n\t\t.config = config,\n\t};\n\n\tif (in_tx)\n\t\tattr.config |= HSW_IN_TX;\n\tif (in_tx_cp)\n\t\tattr.config |= HSW_IN_TX_CHECKPOINTED;\n\n\tattr.sample_period = (-pmc->counter) & pmc_bitmask(pmc);\n\n\tevent = perf_event_create_kernel_counter(&attr, -1, current,\n\t\t\t\t\t\t intr ? kvm_perf_overflow_intr :\n\t\t\t\t\t\t kvm_perf_overflow, pmc);\n\tif (IS_ERR(event)) {\n\t\tprintk_once(\"kvm_pmu: event creation failed %ld\\n\",\n\t\t\t    PTR_ERR(event));\n\t\treturn;\n\t}\n\n\tpmc->perf_event = event;\n\tclear_bit(pmc->idx, (unsigned long*)&pmc_to_pmu(pmc)->reprogram_pmi);\n}",
    "includes": [
      "#include \"pmu.h\"",
      "#include \"lapic.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include <asm/perf_event.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "pmc->idx",
            "(unsigned long*)&pmc_to_pmu(pmc)->reprogram_pmi"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_clear_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/vmx.c",
          "lines": "1592-1597",
          "snippet": "static __always_inline void vmcs_clear_bits(unsigned long field, u32 mask)\n{\n        BUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x2000,\n\t\t\t \"vmcs_clear_bits does not support 64-bit fields\");\n\t__vmcs_writel(field, __vmcs_readl(field) & ~mask);\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"trace.h\"",
            "#include <asm/irq_remapping.h>",
            "#include <asm/apic.h>",
            "#include <asm/kexec.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/mce.h>",
            "#include <asm/virtext.h>",
            "#include <asm/vmx.h>",
            "#include <asm/desc.h>",
            "#include <asm/io.h>",
            "#include <asm/cpu.h>",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/hrtimer.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include \"lapic.h\"",
            "#include \"cpuid.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"trace.h\"\n#include <asm/irq_remapping.h>\n#include <asm/apic.h>\n#include <asm/kexec.h>\n#include <asm/debugreg.h>\n#include <asm/perf_event.h>\n#include <asm/fpu/internal.h>\n#include <asm/mce.h>\n#include <asm/virtext.h>\n#include <asm/vmx.h>\n#include <asm/desc.h>\n#include <asm/io.h>\n#include <asm/cpu.h>\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/hrtimer.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic __always_inline void vmcs_clear_bits(unsigned long field, u32 mask)\n{\n        BUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x2000,\n\t\t\t \"vmcs_clear_bits does not support 64-bit fields\");\n\t__vmcs_writel(field, __vmcs_readl(field) & ~mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pmc_to_pmu",
          "args": [
            "pmc"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk_once",
          "args": [
            "\"kvm_pmu: event creation failed %ld\\n\"",
            "PTR_ERR(event)"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "event"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "event"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perf_event_create_kernel_counter",
          "args": [
            "&attr",
            "-1",
            "current",
            "intr ? kvm_perf_overflow_intr :\n\t\t\t\t\t\t kvm_perf_overflow",
            "pmc"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmc_bitmask",
          "args": [
            "pmc"
          ],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "pmc_bitmask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/pmu.h",
          "lines": "33-38",
          "snippet": "static inline u64 pmc_bitmask(struct kvm_pmc *pmc)\n{\n\tstruct kvm_pmu *pmu = pmc_to_pmu(pmc);\n\n\treturn pmu->counter_bitmask[pmc->type];\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline u64 pmc_bitmask(struct kvm_pmc *pmc)\n{\n\tstruct kvm_pmu *pmu = pmc_to_pmu(pmc);\n\n\treturn pmu->counter_bitmask[pmc->type];\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include <asm/perf_event.h>\n#include <linux/perf_event.h>\n#include <linux/kvm_host.h>\n#include <linux/types.h>\n\nstatic void pmc_reprogram_counter(struct kvm_pmc *pmc, u32 type,\n\t\t\t\t  unsigned config, bool exclude_user,\n\t\t\t\t  bool exclude_kernel, bool intr,\n\t\t\t\t  bool in_tx, bool in_tx_cp)\n{\n\tstruct perf_event *event;\n\tstruct perf_event_attr attr = {\n\t\t.type = type,\n\t\t.size = sizeof(attr),\n\t\t.pinned = true,\n\t\t.exclude_idle = true,\n\t\t.exclude_host = 1,\n\t\t.exclude_user = exclude_user,\n\t\t.exclude_kernel = exclude_kernel,\n\t\t.config = config,\n\t};\n\n\tif (in_tx)\n\t\tattr.config |= HSW_IN_TX;\n\tif (in_tx_cp)\n\t\tattr.config |= HSW_IN_TX_CHECKPOINTED;\n\n\tattr.sample_period = (-pmc->counter) & pmc_bitmask(pmc);\n\n\tevent = perf_event_create_kernel_counter(&attr, -1, current,\n\t\t\t\t\t\t intr ? kvm_perf_overflow_intr :\n\t\t\t\t\t\t kvm_perf_overflow, pmc);\n\tif (IS_ERR(event)) {\n\t\tprintk_once(\"kvm_pmu: event creation failed %ld\\n\",\n\t\t\t    PTR_ERR(event));\n\t\treturn;\n\t}\n\n\tpmc->perf_event = event;\n\tclear_bit(pmc->idx, (unsigned long*)&pmc_to_pmu(pmc)->reprogram_pmi);\n}"
  },
  {
    "function_name": "kvm_perf_overflow_intr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/pmu.c",
    "lines": "72-97",
    "snippet": "static void kvm_perf_overflow_intr(struct perf_event *perf_event,\n\t\t\t\t   struct perf_sample_data *data,\n\t\t\t\t   struct pt_regs *regs)\n{\n\tstruct kvm_pmc *pmc = perf_event->overflow_handler_context;\n\tstruct kvm_pmu *pmu = pmc_to_pmu(pmc);\n\n\tif (!test_and_set_bit(pmc->idx,\n\t\t\t      (unsigned long *)&pmu->reprogram_pmi)) {\n\t\t__set_bit(pmc->idx, (unsigned long *)&pmu->global_status);\n\t\tkvm_make_request(KVM_REQ_PMU, pmc->vcpu);\n\n\t\t/*\n\t\t * Inject PMI. If vcpu was in a guest mode during NMI PMI\n\t\t * can be ejected on a guest mode re-entry. Otherwise we can't\n\t\t * be sure that vcpu wasn't executing hlt instruction at the\n\t\t * time of vmexit and is not going to re-enter guest mode until\n\t\t * woken up. So we should wake it, but this is impossible from\n\t\t * NMI context. Do it from irq work instead.\n\t\t */\n\t\tif (!kvm_is_in_guest())\n\t\t\tirq_work_queue(&pmc_to_pmu(pmc)->irq_work);\n\t\telse\n\t\t\tkvm_make_request(KVM_REQ_PMI, pmc->vcpu);\n\t}\n}",
    "includes": [
      "#include \"pmu.h\"",
      "#include \"lapic.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include <asm/perf_event.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_make_request",
          "args": [
            "KVM_REQ_PMI",
            "pmc->vcpu"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_work_queue",
          "args": [
            "&pmc_to_pmu(pmc)->irq_work"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmc_to_pmu",
          "args": [
            "pmc"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_is_in_guest",
          "args": [],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_is_in_guest",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "5711-5714",
          "snippet": "int kvm_is_in_guest(void)\n{\n\treturn __this_cpu_read(current_vcpu) != NULL;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nint kvm_is_in_guest(void)\n{\n\treturn __this_cpu_read(current_vcpu) != NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_make_request",
          "args": [
            "KVM_REQ_PMU",
            "pmc->vcpu"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__set_bit",
          "args": [
            "pmc->idx",
            "(unsigned long *)&pmu->global_status"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_and_set_bit",
          "args": [
            "pmc->idx",
            "(unsigned long *)&pmu->reprogram_pmi"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmc_to_pmu",
          "args": [
            "pmc"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include <asm/perf_event.h>\n#include <linux/perf_event.h>\n#include <linux/kvm_host.h>\n#include <linux/types.h>\n\nstatic void kvm_perf_overflow_intr(struct perf_event *perf_event,\n\t\t\t\t   struct perf_sample_data *data,\n\t\t\t\t   struct pt_regs *regs)\n{\n\tstruct kvm_pmc *pmc = perf_event->overflow_handler_context;\n\tstruct kvm_pmu *pmu = pmc_to_pmu(pmc);\n\n\tif (!test_and_set_bit(pmc->idx,\n\t\t\t      (unsigned long *)&pmu->reprogram_pmi)) {\n\t\t__set_bit(pmc->idx, (unsigned long *)&pmu->global_status);\n\t\tkvm_make_request(KVM_REQ_PMU, pmc->vcpu);\n\n\t\t/*\n\t\t * Inject PMI. If vcpu was in a guest mode during NMI PMI\n\t\t * can be ejected on a guest mode re-entry. Otherwise we can't\n\t\t * be sure that vcpu wasn't executing hlt instruction at the\n\t\t * time of vmexit and is not going to re-enter guest mode until\n\t\t * woken up. So we should wake it, but this is impossible from\n\t\t * NMI context. Do it from irq work instead.\n\t\t */\n\t\tif (!kvm_is_in_guest())\n\t\t\tirq_work_queue(&pmc_to_pmu(pmc)->irq_work);\n\t\telse\n\t\t\tkvm_make_request(KVM_REQ_PMI, pmc->vcpu);\n\t}\n}"
  },
  {
    "function_name": "kvm_perf_overflow",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/pmu.c",
    "lines": "58-70",
    "snippet": "static void kvm_perf_overflow(struct perf_event *perf_event,\n\t\t\t      struct perf_sample_data *data,\n\t\t\t      struct pt_regs *regs)\n{\n\tstruct kvm_pmc *pmc = perf_event->overflow_handler_context;\n\tstruct kvm_pmu *pmu = pmc_to_pmu(pmc);\n\n\tif (!test_and_set_bit(pmc->idx,\n\t\t\t      (unsigned long *)&pmu->reprogram_pmi)) {\n\t\t__set_bit(pmc->idx, (unsigned long *)&pmu->global_status);\n\t\tkvm_make_request(KVM_REQ_PMU, pmc->vcpu);\n\t}\n}",
    "includes": [
      "#include \"pmu.h\"",
      "#include \"lapic.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include <asm/perf_event.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_make_request",
          "args": [
            "KVM_REQ_PMU",
            "pmc->vcpu"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__set_bit",
          "args": [
            "pmc->idx",
            "(unsigned long *)&pmu->global_status"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_and_set_bit",
          "args": [
            "pmc->idx",
            "(unsigned long *)&pmu->reprogram_pmi"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmc_to_pmu",
          "args": [
            "pmc"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include <asm/perf_event.h>\n#include <linux/perf_event.h>\n#include <linux/kvm_host.h>\n#include <linux/types.h>\n\nstatic void kvm_perf_overflow(struct perf_event *perf_event,\n\t\t\t      struct perf_sample_data *data,\n\t\t\t      struct pt_regs *regs)\n{\n\tstruct kvm_pmc *pmc = perf_event->overflow_handler_context;\n\tstruct kvm_pmu *pmu = pmc_to_pmu(pmc);\n\n\tif (!test_and_set_bit(pmc->idx,\n\t\t\t      (unsigned long *)&pmu->reprogram_pmi)) {\n\t\t__set_bit(pmc->idx, (unsigned long *)&pmu->global_status);\n\t\tkvm_make_request(KVM_REQ_PMU, pmc->vcpu);\n\t}\n}"
  },
  {
    "function_name": "kvm_pmi_trigger_fn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/pmu.c",
    "lines": "50-56",
    "snippet": "static void kvm_pmi_trigger_fn(struct irq_work *irq_work)\n{\n\tstruct kvm_pmu *pmu = container_of(irq_work, struct kvm_pmu, irq_work);\n\tstruct kvm_vcpu *vcpu = pmu_to_vcpu(pmu);\n\n\tkvm_pmu_deliver_pmi(vcpu);\n}",
    "includes": [
      "#include \"pmu.h\"",
      "#include \"lapic.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include <asm/perf_event.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_pmu_deliver_pmi",
          "args": [
            "vcpu"
          ],
          "line": 55
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_pmu_deliver_pmi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/pmu.c",
          "lines": "258-262",
          "snippet": "void kvm_pmu_deliver_pmi(struct kvm_vcpu *vcpu)\n{\n\tif (lapic_in_kernel(vcpu))\n\t\tkvm_apic_local_deliver(vcpu->arch.apic, APIC_LVTPC);\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"lapic.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include <asm/perf_event.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include <asm/perf_event.h>\n#include <linux/perf_event.h>\n#include <linux/kvm_host.h>\n#include <linux/types.h>\n\nvoid kvm_pmu_deliver_pmi(struct kvm_vcpu *vcpu)\n{\n\tif (lapic_in_kernel(vcpu))\n\t\tkvm_apic_local_deliver(vcpu->arch.apic, APIC_LVTPC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pmu_to_vcpu",
          "args": [
            "pmu"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "irq_work",
            "structkvm_pmu",
            "irq_work"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include <asm/perf_event.h>\n#include <linux/perf_event.h>\n#include <linux/kvm_host.h>\n#include <linux/types.h>\n\nstatic void kvm_pmi_trigger_fn(struct irq_work *irq_work)\n{\n\tstruct kvm_pmu *pmu = container_of(irq_work, struct kvm_pmu, irq_work);\n\tstruct kvm_vcpu *vcpu = pmu_to_vcpu(pmu);\n\n\tkvm_pmu_deliver_pmi(vcpu);\n}"
  }
]