[
  {
    "function_name": "kvm_destroy_pic",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/i8259.c",
    "lines": "654-660",
    "snippet": "void kvm_destroy_pic(struct kvm_pic *vpic)\n{\n\tkvm_io_bus_unregister_dev(vpic->kvm, KVM_PIO_BUS, &vpic->dev_master);\n\tkvm_io_bus_unregister_dev(vpic->kvm, KVM_PIO_BUS, &vpic->dev_slave);\n\tkvm_io_bus_unregister_dev(vpic->kvm, KVM_PIO_BUS, &vpic->dev_eclr);\n\tkfree(vpic);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/kvm_host.h>",
      "#include \"irq.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "vpic"
          ],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_io_bus_unregister_dev",
          "args": [
            "vpic->kvm",
            "KVM_PIO_BUS",
            "&vpic->dev_eclr"
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_io_bus_unregister_dev",
          "args": [
            "vpic->kvm",
            "KVM_PIO_BUS",
            "&vpic->dev_slave"
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_io_bus_unregister_dev",
          "args": [
            "vpic->kvm",
            "KVM_PIO_BUS",
            "&vpic->dev_master"
          ],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nvoid kvm_destroy_pic(struct kvm_pic *vpic)\n{\n\tkvm_io_bus_unregister_dev(vpic->kvm, KVM_PIO_BUS, &vpic->dev_master);\n\tkvm_io_bus_unregister_dev(vpic->kvm, KVM_PIO_BUS, &vpic->dev_slave);\n\tkvm_io_bus_unregister_dev(vpic->kvm, KVM_PIO_BUS, &vpic->dev_eclr);\n\tkfree(vpic);\n}"
  },
  {
    "function_name": "kvm_create_pic",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/i8259.c",
    "lines": "601-652",
    "snippet": "struct kvm_pic *kvm_create_pic(struct kvm *kvm)\n{\n\tstruct kvm_pic *s;\n\tint ret;\n\n\ts = kzalloc(sizeof(struct kvm_pic), GFP_KERNEL);\n\tif (!s)\n\t\treturn NULL;\n\tspin_lock_init(&s->lock);\n\ts->kvm = kvm;\n\ts->pics[0].elcr_mask = 0xf8;\n\ts->pics[1].elcr_mask = 0xde;\n\ts->pics[0].pics_state = s;\n\ts->pics[1].pics_state = s;\n\n\t/*\n\t * Initialize PIO device\n\t */\n\tkvm_iodevice_init(&s->dev_master, &picdev_master_ops);\n\tkvm_iodevice_init(&s->dev_slave, &picdev_slave_ops);\n\tkvm_iodevice_init(&s->dev_eclr, &picdev_eclr_ops);\n\tmutex_lock(&kvm->slots_lock);\n\tret = kvm_io_bus_register_dev(kvm, KVM_PIO_BUS, 0x20, 2,\n\t\t\t\t      &s->dev_master);\n\tif (ret < 0)\n\t\tgoto fail_unlock;\n\n\tret = kvm_io_bus_register_dev(kvm, KVM_PIO_BUS, 0xa0, 2, &s->dev_slave);\n\tif (ret < 0)\n\t\tgoto fail_unreg_2;\n\n\tret = kvm_io_bus_register_dev(kvm, KVM_PIO_BUS, 0x4d0, 2, &s->dev_eclr);\n\tif (ret < 0)\n\t\tgoto fail_unreg_1;\n\n\tmutex_unlock(&kvm->slots_lock);\n\n\treturn s;\n\nfail_unreg_1:\n\tkvm_io_bus_unregister_dev(kvm, KVM_PIO_BUS, &s->dev_slave);\n\nfail_unreg_2:\n\tkvm_io_bus_unregister_dev(kvm, KVM_PIO_BUS, &s->dev_master);\n\nfail_unlock:\n\tmutex_unlock(&kvm->slots_lock);\n\n\tkfree(s);\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/kvm_host.h>",
      "#include \"irq.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct kvm_io_device_ops picdev_master_ops = {\n\t.read     = picdev_master_read,\n\t.write    = picdev_master_write,\n};",
      "static const struct kvm_io_device_ops picdev_slave_ops = {\n\t.read     = picdev_slave_read,\n\t.write    = picdev_slave_write,\n};",
      "static const struct kvm_io_device_ops picdev_eclr_ops = {\n\t.read     = picdev_eclr_read,\n\t.write    = picdev_eclr_write,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "s"
          ],
          "line": 649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&kvm->slots_lock"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_io_bus_unregister_dev",
          "args": [
            "kvm",
            "KVM_PIO_BUS",
            "&s->dev_master"
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_io_bus_unregister_dev",
          "args": [
            "kvm",
            "KVM_PIO_BUS",
            "&s->dev_slave"
          ],
          "line": 641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&kvm->slots_lock"
          ],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_io_bus_register_dev",
          "args": [
            "kvm",
            "KVM_PIO_BUS",
            "0x4d0",
            "2",
            "&s->dev_eclr"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_io_bus_register_dev",
          "args": [
            "kvm",
            "KVM_PIO_BUS",
            "0xa0",
            "2",
            "&s->dev_slave"
          ],
          "line": 628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_io_bus_register_dev",
          "args": [
            "kvm",
            "KVM_PIO_BUS",
            "0x20",
            "2",
            "&s->dev_master"
          ],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&kvm->slots_lock"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_iodevice_init",
          "args": [
            "&s->dev_eclr",
            "&picdev_eclr_ops"
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_iodevice_init",
          "args": [
            "&s->dev_slave",
            "&picdev_slave_ops"
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_iodevice_init",
          "args": [
            "&s->dev_master",
            "&picdev_master_ops"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&s->lock"
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct kvm_pic)",
            "GFP_KERNEL"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic const struct kvm_io_device_ops picdev_master_ops = {\n\t.read     = picdev_master_read,\n\t.write    = picdev_master_write,\n};\nstatic const struct kvm_io_device_ops picdev_slave_ops = {\n\t.read     = picdev_slave_read,\n\t.write    = picdev_slave_write,\n};\nstatic const struct kvm_io_device_ops picdev_eclr_ops = {\n\t.read     = picdev_eclr_read,\n\t.write    = picdev_eclr_write,\n};\n\nstruct kvm_pic *kvm_create_pic(struct kvm *kvm)\n{\n\tstruct kvm_pic *s;\n\tint ret;\n\n\ts = kzalloc(sizeof(struct kvm_pic), GFP_KERNEL);\n\tif (!s)\n\t\treturn NULL;\n\tspin_lock_init(&s->lock);\n\ts->kvm = kvm;\n\ts->pics[0].elcr_mask = 0xf8;\n\ts->pics[1].elcr_mask = 0xde;\n\ts->pics[0].pics_state = s;\n\ts->pics[1].pics_state = s;\n\n\t/*\n\t * Initialize PIO device\n\t */\n\tkvm_iodevice_init(&s->dev_master, &picdev_master_ops);\n\tkvm_iodevice_init(&s->dev_slave, &picdev_slave_ops);\n\tkvm_iodevice_init(&s->dev_eclr, &picdev_eclr_ops);\n\tmutex_lock(&kvm->slots_lock);\n\tret = kvm_io_bus_register_dev(kvm, KVM_PIO_BUS, 0x20, 2,\n\t\t\t\t      &s->dev_master);\n\tif (ret < 0)\n\t\tgoto fail_unlock;\n\n\tret = kvm_io_bus_register_dev(kvm, KVM_PIO_BUS, 0xa0, 2, &s->dev_slave);\n\tif (ret < 0)\n\t\tgoto fail_unreg_2;\n\n\tret = kvm_io_bus_register_dev(kvm, KVM_PIO_BUS, 0x4d0, 2, &s->dev_eclr);\n\tif (ret < 0)\n\t\tgoto fail_unreg_1;\n\n\tmutex_unlock(&kvm->slots_lock);\n\n\treturn s;\n\nfail_unreg_1:\n\tkvm_io_bus_unregister_dev(kvm, KVM_PIO_BUS, &s->dev_slave);\n\nfail_unreg_2:\n\tkvm_io_bus_unregister_dev(kvm, KVM_PIO_BUS, &s->dev_master);\n\nfail_unlock:\n\tmutex_unlock(&kvm->slots_lock);\n\n\tkfree(s);\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "pic_irq_request",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/i8259.c",
    "lines": "577-584",
    "snippet": "static void pic_irq_request(struct kvm *kvm, int level)\n{\n\tstruct kvm_pic *s = pic_irqchip(kvm);\n\n\tif (!s->output)\n\t\ts->wakeup_needed = true;\n\ts->output = level;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/kvm_host.h>",
      "#include \"irq.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void pic_irq_request(struct kvm *kvm, int level);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pic_irqchip",
          "args": [
            "kvm"
          ],
          "line": 579
        },
        "resolved": true,
        "details": {
          "function_name": "ioapic_irqchip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/ioapic.h",
          "lines": "108-111",
          "snippet": "static inline struct kvm_ioapic *ioapic_irqchip(struct kvm *kvm)\n{\n\treturn kvm->arch.vioapic;\n}",
          "includes": [
            "#include <kvm/iodev.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kvm/iodev.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct kvm_ioapic *ioapic_irqchip(struct kvm *kvm)\n{\n\treturn kvm->arch.vioapic;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void pic_irq_request(struct kvm *kvm, int level);\n\nstatic void pic_irq_request(struct kvm *kvm, int level)\n{\n\tstruct kvm_pic *s = pic_irqchip(kvm);\n\n\tif (!s->output)\n\t\ts->wakeup_needed = true;\n\ts->output = level;\n}"
  },
  {
    "function_name": "picdev_eclr_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/i8259.c",
    "lines": "567-572",
    "snippet": "static int picdev_eclr_read(struct kvm_vcpu *vcpu, struct kvm_io_device *dev,\n\t\t\t    gpa_t addr, int len, void *val)\n{\n\treturn picdev_read(container_of(dev, struct kvm_pic, dev_eclr),\n\t\t\t    addr, len, val);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/kvm_host.h>",
      "#include \"irq.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "picdev_read",
          "args": [
            "container_of(dev, struct kvm_pic, dev_eclr)",
            "addr",
            "len",
            "val"
          ],
          "line": 570
        },
        "resolved": true,
        "details": {
          "function_name": "picdev_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/i8259.c",
          "lines": "502-530",
          "snippet": "static int picdev_read(struct kvm_pic *s,\n\t\t       gpa_t addr, int len, void *val)\n{\n\tunsigned char data = 0;\n\tif (!picdev_in_range(addr))\n\t\treturn -EOPNOTSUPP;\n\n\tif (len != 1) {\n\t\tmemset(val, 0, len);\n\t\tpr_pic_unimpl(\"non byte read\\n\");\n\t\treturn 0;\n\t}\n\tpic_lock(s);\n\tswitch (addr) {\n\tcase 0x20:\n\tcase 0x21:\n\tcase 0xa0:\n\tcase 0xa1:\n\t\tdata = pic_ioport_read(&s->pics[addr >> 7], addr);\n\t\tbreak;\n\tcase 0x4d0:\n\tcase 0x4d1:\n\t\tdata = elcr_ioport_read(&s->pics[addr & 1], addr);\n\t\tbreak;\n\t}\n\t*(unsigned char *)val = data;\n\tpic_unlock(s);\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/kvm_host.h>",
            "#include \"irq.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic int picdev_read(struct kvm_pic *s,\n\t\t       gpa_t addr, int len, void *val)\n{\n\tunsigned char data = 0;\n\tif (!picdev_in_range(addr))\n\t\treturn -EOPNOTSUPP;\n\n\tif (len != 1) {\n\t\tmemset(val, 0, len);\n\t\tpr_pic_unimpl(\"non byte read\\n\");\n\t\treturn 0;\n\t}\n\tpic_lock(s);\n\tswitch (addr) {\n\tcase 0x20:\n\tcase 0x21:\n\tcase 0xa0:\n\tcase 0xa1:\n\t\tdata = pic_ioport_read(&s->pics[addr >> 7], addr);\n\t\tbreak;\n\tcase 0x4d0:\n\tcase 0x4d1:\n\t\tdata = elcr_ioport_read(&s->pics[addr & 1], addr);\n\t\tbreak;\n\t}\n\t*(unsigned char *)val = data;\n\tpic_unlock(s);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "dev",
            "structkvm_pic",
            "dev_eclr"
          ],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic int picdev_eclr_read(struct kvm_vcpu *vcpu, struct kvm_io_device *dev,\n\t\t\t    gpa_t addr, int len, void *val)\n{\n\treturn picdev_read(container_of(dev, struct kvm_pic, dev_eclr),\n\t\t\t    addr, len, val);\n}"
  },
  {
    "function_name": "picdev_eclr_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/i8259.c",
    "lines": "560-565",
    "snippet": "static int picdev_eclr_write(struct kvm_vcpu *vcpu, struct kvm_io_device *dev,\n\t\t\t     gpa_t addr, int len, const void *val)\n{\n\treturn picdev_write(container_of(dev, struct kvm_pic, dev_eclr),\n\t\t\t    addr, len, val);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/kvm_host.h>",
      "#include \"irq.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "picdev_write",
          "args": [
            "container_of(dev, struct kvm_pic, dev_eclr)",
            "addr",
            "len",
            "val"
          ],
          "line": 563
        },
        "resolved": true,
        "details": {
          "function_name": "picdev_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/i8259.c",
          "lines": "474-500",
          "snippet": "static int picdev_write(struct kvm_pic *s,\n\t\t\t gpa_t addr, int len, const void *val)\n{\n\tunsigned char data = *(unsigned char *)val;\n\tif (!picdev_in_range(addr))\n\t\treturn -EOPNOTSUPP;\n\n\tif (len != 1) {\n\t\tpr_pic_unimpl(\"non byte write\\n\");\n\t\treturn 0;\n\t}\n\tpic_lock(s);\n\tswitch (addr) {\n\tcase 0x20:\n\tcase 0x21:\n\tcase 0xa0:\n\tcase 0xa1:\n\t\tpic_ioport_write(&s->pics[addr >> 7], addr, data);\n\t\tbreak;\n\tcase 0x4d0:\n\tcase 0x4d1:\n\t\telcr_ioport_write(&s->pics[addr & 1], addr, data);\n\t\tbreak;\n\t}\n\tpic_unlock(s);\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/kvm_host.h>",
            "#include \"irq.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic int picdev_write(struct kvm_pic *s,\n\t\t\t gpa_t addr, int len, const void *val)\n{\n\tunsigned char data = *(unsigned char *)val;\n\tif (!picdev_in_range(addr))\n\t\treturn -EOPNOTSUPP;\n\n\tif (len != 1) {\n\t\tpr_pic_unimpl(\"non byte write\\n\");\n\t\treturn 0;\n\t}\n\tpic_lock(s);\n\tswitch (addr) {\n\tcase 0x20:\n\tcase 0x21:\n\tcase 0xa0:\n\tcase 0xa1:\n\t\tpic_ioport_write(&s->pics[addr >> 7], addr, data);\n\t\tbreak;\n\tcase 0x4d0:\n\tcase 0x4d1:\n\t\telcr_ioport_write(&s->pics[addr & 1], addr, data);\n\t\tbreak;\n\t}\n\tpic_unlock(s);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "dev",
            "structkvm_pic",
            "dev_eclr"
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic int picdev_eclr_write(struct kvm_vcpu *vcpu, struct kvm_io_device *dev,\n\t\t\t     gpa_t addr, int len, const void *val)\n{\n\treturn picdev_write(container_of(dev, struct kvm_pic, dev_eclr),\n\t\t\t    addr, len, val);\n}"
  },
  {
    "function_name": "picdev_slave_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/i8259.c",
    "lines": "553-558",
    "snippet": "static int picdev_slave_read(struct kvm_vcpu *vcpu, struct kvm_io_device *dev,\n\t\t\t     gpa_t addr, int len, void *val)\n{\n\treturn picdev_read(container_of(dev, struct kvm_pic, dev_slave),\n\t\t\t    addr, len, val);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/kvm_host.h>",
      "#include \"irq.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "picdev_read",
          "args": [
            "container_of(dev, struct kvm_pic, dev_slave)",
            "addr",
            "len",
            "val"
          ],
          "line": 556
        },
        "resolved": true,
        "details": {
          "function_name": "picdev_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/i8259.c",
          "lines": "502-530",
          "snippet": "static int picdev_read(struct kvm_pic *s,\n\t\t       gpa_t addr, int len, void *val)\n{\n\tunsigned char data = 0;\n\tif (!picdev_in_range(addr))\n\t\treturn -EOPNOTSUPP;\n\n\tif (len != 1) {\n\t\tmemset(val, 0, len);\n\t\tpr_pic_unimpl(\"non byte read\\n\");\n\t\treturn 0;\n\t}\n\tpic_lock(s);\n\tswitch (addr) {\n\tcase 0x20:\n\tcase 0x21:\n\tcase 0xa0:\n\tcase 0xa1:\n\t\tdata = pic_ioport_read(&s->pics[addr >> 7], addr);\n\t\tbreak;\n\tcase 0x4d0:\n\tcase 0x4d1:\n\t\tdata = elcr_ioport_read(&s->pics[addr & 1], addr);\n\t\tbreak;\n\t}\n\t*(unsigned char *)val = data;\n\tpic_unlock(s);\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/kvm_host.h>",
            "#include \"irq.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic int picdev_read(struct kvm_pic *s,\n\t\t       gpa_t addr, int len, void *val)\n{\n\tunsigned char data = 0;\n\tif (!picdev_in_range(addr))\n\t\treturn -EOPNOTSUPP;\n\n\tif (len != 1) {\n\t\tmemset(val, 0, len);\n\t\tpr_pic_unimpl(\"non byte read\\n\");\n\t\treturn 0;\n\t}\n\tpic_lock(s);\n\tswitch (addr) {\n\tcase 0x20:\n\tcase 0x21:\n\tcase 0xa0:\n\tcase 0xa1:\n\t\tdata = pic_ioport_read(&s->pics[addr >> 7], addr);\n\t\tbreak;\n\tcase 0x4d0:\n\tcase 0x4d1:\n\t\tdata = elcr_ioport_read(&s->pics[addr & 1], addr);\n\t\tbreak;\n\t}\n\t*(unsigned char *)val = data;\n\tpic_unlock(s);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "dev",
            "structkvm_pic",
            "dev_slave"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic int picdev_slave_read(struct kvm_vcpu *vcpu, struct kvm_io_device *dev,\n\t\t\t     gpa_t addr, int len, void *val)\n{\n\treturn picdev_read(container_of(dev, struct kvm_pic, dev_slave),\n\t\t\t    addr, len, val);\n}"
  },
  {
    "function_name": "picdev_slave_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/i8259.c",
    "lines": "546-551",
    "snippet": "static int picdev_slave_write(struct kvm_vcpu *vcpu, struct kvm_io_device *dev,\n\t\t\t      gpa_t addr, int len, const void *val)\n{\n\treturn picdev_write(container_of(dev, struct kvm_pic, dev_slave),\n\t\t\t    addr, len, val);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/kvm_host.h>",
      "#include \"irq.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "picdev_write",
          "args": [
            "container_of(dev, struct kvm_pic, dev_slave)",
            "addr",
            "len",
            "val"
          ],
          "line": 549
        },
        "resolved": true,
        "details": {
          "function_name": "picdev_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/i8259.c",
          "lines": "474-500",
          "snippet": "static int picdev_write(struct kvm_pic *s,\n\t\t\t gpa_t addr, int len, const void *val)\n{\n\tunsigned char data = *(unsigned char *)val;\n\tif (!picdev_in_range(addr))\n\t\treturn -EOPNOTSUPP;\n\n\tif (len != 1) {\n\t\tpr_pic_unimpl(\"non byte write\\n\");\n\t\treturn 0;\n\t}\n\tpic_lock(s);\n\tswitch (addr) {\n\tcase 0x20:\n\tcase 0x21:\n\tcase 0xa0:\n\tcase 0xa1:\n\t\tpic_ioport_write(&s->pics[addr >> 7], addr, data);\n\t\tbreak;\n\tcase 0x4d0:\n\tcase 0x4d1:\n\t\telcr_ioport_write(&s->pics[addr & 1], addr, data);\n\t\tbreak;\n\t}\n\tpic_unlock(s);\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/kvm_host.h>",
            "#include \"irq.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic int picdev_write(struct kvm_pic *s,\n\t\t\t gpa_t addr, int len, const void *val)\n{\n\tunsigned char data = *(unsigned char *)val;\n\tif (!picdev_in_range(addr))\n\t\treturn -EOPNOTSUPP;\n\n\tif (len != 1) {\n\t\tpr_pic_unimpl(\"non byte write\\n\");\n\t\treturn 0;\n\t}\n\tpic_lock(s);\n\tswitch (addr) {\n\tcase 0x20:\n\tcase 0x21:\n\tcase 0xa0:\n\tcase 0xa1:\n\t\tpic_ioport_write(&s->pics[addr >> 7], addr, data);\n\t\tbreak;\n\tcase 0x4d0:\n\tcase 0x4d1:\n\t\telcr_ioport_write(&s->pics[addr & 1], addr, data);\n\t\tbreak;\n\t}\n\tpic_unlock(s);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "dev",
            "structkvm_pic",
            "dev_slave"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic int picdev_slave_write(struct kvm_vcpu *vcpu, struct kvm_io_device *dev,\n\t\t\t      gpa_t addr, int len, const void *val)\n{\n\treturn picdev_write(container_of(dev, struct kvm_pic, dev_slave),\n\t\t\t    addr, len, val);\n}"
  },
  {
    "function_name": "picdev_master_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/i8259.c",
    "lines": "539-544",
    "snippet": "static int picdev_master_read(struct kvm_vcpu *vcpu, struct kvm_io_device *dev,\n\t\t\t      gpa_t addr, int len, void *val)\n{\n\treturn picdev_read(container_of(dev, struct kvm_pic, dev_master),\n\t\t\t    addr, len, val);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/kvm_host.h>",
      "#include \"irq.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "picdev_read",
          "args": [
            "container_of(dev, struct kvm_pic, dev_master)",
            "addr",
            "len",
            "val"
          ],
          "line": 542
        },
        "resolved": true,
        "details": {
          "function_name": "picdev_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/i8259.c",
          "lines": "502-530",
          "snippet": "static int picdev_read(struct kvm_pic *s,\n\t\t       gpa_t addr, int len, void *val)\n{\n\tunsigned char data = 0;\n\tif (!picdev_in_range(addr))\n\t\treturn -EOPNOTSUPP;\n\n\tif (len != 1) {\n\t\tmemset(val, 0, len);\n\t\tpr_pic_unimpl(\"non byte read\\n\");\n\t\treturn 0;\n\t}\n\tpic_lock(s);\n\tswitch (addr) {\n\tcase 0x20:\n\tcase 0x21:\n\tcase 0xa0:\n\tcase 0xa1:\n\t\tdata = pic_ioport_read(&s->pics[addr >> 7], addr);\n\t\tbreak;\n\tcase 0x4d0:\n\tcase 0x4d1:\n\t\tdata = elcr_ioport_read(&s->pics[addr & 1], addr);\n\t\tbreak;\n\t}\n\t*(unsigned char *)val = data;\n\tpic_unlock(s);\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/kvm_host.h>",
            "#include \"irq.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic int picdev_read(struct kvm_pic *s,\n\t\t       gpa_t addr, int len, void *val)\n{\n\tunsigned char data = 0;\n\tif (!picdev_in_range(addr))\n\t\treturn -EOPNOTSUPP;\n\n\tif (len != 1) {\n\t\tmemset(val, 0, len);\n\t\tpr_pic_unimpl(\"non byte read\\n\");\n\t\treturn 0;\n\t}\n\tpic_lock(s);\n\tswitch (addr) {\n\tcase 0x20:\n\tcase 0x21:\n\tcase 0xa0:\n\tcase 0xa1:\n\t\tdata = pic_ioport_read(&s->pics[addr >> 7], addr);\n\t\tbreak;\n\tcase 0x4d0:\n\tcase 0x4d1:\n\t\tdata = elcr_ioport_read(&s->pics[addr & 1], addr);\n\t\tbreak;\n\t}\n\t*(unsigned char *)val = data;\n\tpic_unlock(s);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "dev",
            "structkvm_pic",
            "dev_master"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic int picdev_master_read(struct kvm_vcpu *vcpu, struct kvm_io_device *dev,\n\t\t\t      gpa_t addr, int len, void *val)\n{\n\treturn picdev_read(container_of(dev, struct kvm_pic, dev_master),\n\t\t\t    addr, len, val);\n}"
  },
  {
    "function_name": "picdev_master_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/i8259.c",
    "lines": "532-537",
    "snippet": "static int picdev_master_write(struct kvm_vcpu *vcpu, struct kvm_io_device *dev,\n\t\t\t       gpa_t addr, int len, const void *val)\n{\n\treturn picdev_write(container_of(dev, struct kvm_pic, dev_master),\n\t\t\t    addr, len, val);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/kvm_host.h>",
      "#include \"irq.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "picdev_write",
          "args": [
            "container_of(dev, struct kvm_pic, dev_master)",
            "addr",
            "len",
            "val"
          ],
          "line": 535
        },
        "resolved": true,
        "details": {
          "function_name": "picdev_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/i8259.c",
          "lines": "474-500",
          "snippet": "static int picdev_write(struct kvm_pic *s,\n\t\t\t gpa_t addr, int len, const void *val)\n{\n\tunsigned char data = *(unsigned char *)val;\n\tif (!picdev_in_range(addr))\n\t\treturn -EOPNOTSUPP;\n\n\tif (len != 1) {\n\t\tpr_pic_unimpl(\"non byte write\\n\");\n\t\treturn 0;\n\t}\n\tpic_lock(s);\n\tswitch (addr) {\n\tcase 0x20:\n\tcase 0x21:\n\tcase 0xa0:\n\tcase 0xa1:\n\t\tpic_ioport_write(&s->pics[addr >> 7], addr, data);\n\t\tbreak;\n\tcase 0x4d0:\n\tcase 0x4d1:\n\t\telcr_ioport_write(&s->pics[addr & 1], addr, data);\n\t\tbreak;\n\t}\n\tpic_unlock(s);\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/kvm_host.h>",
            "#include \"irq.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic int picdev_write(struct kvm_pic *s,\n\t\t\t gpa_t addr, int len, const void *val)\n{\n\tunsigned char data = *(unsigned char *)val;\n\tif (!picdev_in_range(addr))\n\t\treturn -EOPNOTSUPP;\n\n\tif (len != 1) {\n\t\tpr_pic_unimpl(\"non byte write\\n\");\n\t\treturn 0;\n\t}\n\tpic_lock(s);\n\tswitch (addr) {\n\tcase 0x20:\n\tcase 0x21:\n\tcase 0xa0:\n\tcase 0xa1:\n\t\tpic_ioport_write(&s->pics[addr >> 7], addr, data);\n\t\tbreak;\n\tcase 0x4d0:\n\tcase 0x4d1:\n\t\telcr_ioport_write(&s->pics[addr & 1], addr, data);\n\t\tbreak;\n\t}\n\tpic_unlock(s);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "dev",
            "structkvm_pic",
            "dev_master"
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic int picdev_master_write(struct kvm_vcpu *vcpu, struct kvm_io_device *dev,\n\t\t\t       gpa_t addr, int len, const void *val)\n{\n\treturn picdev_write(container_of(dev, struct kvm_pic, dev_master),\n\t\t\t    addr, len, val);\n}"
  },
  {
    "function_name": "picdev_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/i8259.c",
    "lines": "502-530",
    "snippet": "static int picdev_read(struct kvm_pic *s,\n\t\t       gpa_t addr, int len, void *val)\n{\n\tunsigned char data = 0;\n\tif (!picdev_in_range(addr))\n\t\treturn -EOPNOTSUPP;\n\n\tif (len != 1) {\n\t\tmemset(val, 0, len);\n\t\tpr_pic_unimpl(\"non byte read\\n\");\n\t\treturn 0;\n\t}\n\tpic_lock(s);\n\tswitch (addr) {\n\tcase 0x20:\n\tcase 0x21:\n\tcase 0xa0:\n\tcase 0xa1:\n\t\tdata = pic_ioport_read(&s->pics[addr >> 7], addr);\n\t\tbreak;\n\tcase 0x4d0:\n\tcase 0x4d1:\n\t\tdata = elcr_ioport_read(&s->pics[addr & 1], addr);\n\t\tbreak;\n\t}\n\t*(unsigned char *)val = data;\n\tpic_unlock(s);\n\treturn 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/kvm_host.h>",
      "#include \"irq.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pic_unlock",
          "args": [
            "s"
          ],
          "line": 528
        },
        "resolved": true,
        "details": {
          "function_name": "pic_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/i8259.c",
          "lines": "48-73",
          "snippet": "static void pic_unlock(struct kvm_pic *s)\n\t__releases(&s->lock)\n{\n\tbool wakeup = s->wakeup_needed;\n\tstruct kvm_vcpu *vcpu, *found = NULL;\n\tint i;\n\n\ts->wakeup_needed = false;\n\n\tspin_unlock(&s->lock);\n\n\tif (wakeup) {\n\t\tkvm_for_each_vcpu(i, vcpu, s->kvm) {\n\t\t\tif (kvm_apic_accept_pic_intr(vcpu)) {\n\t\t\t\tfound = vcpu;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!found)\n\t\t\treturn;\n\n\t\tkvm_make_request(KVM_REQ_EVENT, found);\n\t\tkvm_vcpu_kick(found);\n\t}\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/kvm_host.h>",
            "#include \"irq.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void pic_unlock(struct kvm_pic *s)\n\t__releases(&s->lock)\n{\n\tbool wakeup = s->wakeup_needed;\n\tstruct kvm_vcpu *vcpu, *found = NULL;\n\tint i;\n\n\ts->wakeup_needed = false;\n\n\tspin_unlock(&s->lock);\n\n\tif (wakeup) {\n\t\tkvm_for_each_vcpu(i, vcpu, s->kvm) {\n\t\t\tif (kvm_apic_accept_pic_intr(vcpu)) {\n\t\t\t\tfound = vcpu;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!found)\n\t\t\treturn;\n\n\t\tkvm_make_request(KVM_REQ_EVENT, found);\n\t\tkvm_vcpu_kick(found);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "elcr_ioport_read",
          "args": [
            "&s->pics[addr & 1]",
            "addr"
          ],
          "line": 524
        },
        "resolved": true,
        "details": {
          "function_name": "elcr_ioport_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/i8259.c",
          "lines": "453-457",
          "snippet": "static u32 elcr_ioport_read(void *opaque, u32 addr1)\n{\n\tstruct kvm_kpic_state *s = opaque;\n\treturn s->elcr;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/kvm_host.h>",
            "#include \"irq.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic u32 elcr_ioport_read(void *opaque, u32 addr1)\n{\n\tstruct kvm_kpic_state *s = opaque;\n\treturn s->elcr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pic_ioport_read",
          "args": [
            "&s->pics[addr >> 7]",
            "addr"
          ],
          "line": 520
        },
        "resolved": true,
        "details": {
          "function_name": "pic_ioport_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/i8259.c",
          "lines": "425-445",
          "snippet": "static u32 pic_ioport_read(void *opaque, u32 addr1)\n{\n\tstruct kvm_kpic_state *s = opaque;\n\tunsigned int addr;\n\tint ret;\n\n\taddr = addr1;\n\taddr &= 1;\n\tif (s->poll) {\n\t\tret = pic_poll_read(s, addr1);\n\t\ts->poll = 0;\n\t} else\n\t\tif (addr == 0)\n\t\t\tif (s->read_reg_select)\n\t\t\t\tret = s->isr;\n\t\t\telse\n\t\t\t\tret = s->irr;\n\t\telse\n\t\t\tret = s->imr;\n\treturn ret;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/kvm_host.h>",
            "#include \"irq.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic u32 pic_ioport_read(void *opaque, u32 addr1)\n{\n\tstruct kvm_kpic_state *s = opaque;\n\tunsigned int addr;\n\tint ret;\n\n\taddr = addr1;\n\taddr &= 1;\n\tif (s->poll) {\n\t\tret = pic_poll_read(s, addr1);\n\t\ts->poll = 0;\n\t} else\n\t\tif (addr == 0)\n\t\t\tif (s->read_reg_select)\n\t\t\t\tret = s->isr;\n\t\t\telse\n\t\t\t\tret = s->irr;\n\t\telse\n\t\t\tret = s->imr;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pic_lock",
          "args": [
            "s"
          ],
          "line": 514
        },
        "resolved": true,
        "details": {
          "function_name": "pic_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/i8259.c",
          "lines": "42-46",
          "snippet": "static void pic_lock(struct kvm_pic *s)\n\t__acquires(&s->lock)\n{\n\tspin_lock(&s->lock);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/kvm_host.h>",
            "#include \"irq.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void pic_lock(struct kvm_pic *s)\n\t__acquires(&s->lock)\n{\n\tspin_lock(&s->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_pic_unimpl",
          "args": [
            "\"non byte read\\n\""
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "val",
            "0",
            "len"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "picdev_in_range",
          "args": [
            "addr"
          ],
          "line": 506
        },
        "resolved": true,
        "details": {
          "function_name": "picdev_in_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/i8259.c",
          "lines": "459-472",
          "snippet": "static int picdev_in_range(gpa_t addr)\n{\n\tswitch (addr) {\n\tcase 0x20:\n\tcase 0x21:\n\tcase 0xa0:\n\tcase 0xa1:\n\tcase 0x4d0:\n\tcase 0x4d1:\n\t\treturn 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/kvm_host.h>",
            "#include \"irq.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic int picdev_in_range(gpa_t addr)\n{\n\tswitch (addr) {\n\tcase 0x20:\n\tcase 0x21:\n\tcase 0xa0:\n\tcase 0xa1:\n\tcase 0x4d0:\n\tcase 0x4d1:\n\t\treturn 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic int picdev_read(struct kvm_pic *s,\n\t\t       gpa_t addr, int len, void *val)\n{\n\tunsigned char data = 0;\n\tif (!picdev_in_range(addr))\n\t\treturn -EOPNOTSUPP;\n\n\tif (len != 1) {\n\t\tmemset(val, 0, len);\n\t\tpr_pic_unimpl(\"non byte read\\n\");\n\t\treturn 0;\n\t}\n\tpic_lock(s);\n\tswitch (addr) {\n\tcase 0x20:\n\tcase 0x21:\n\tcase 0xa0:\n\tcase 0xa1:\n\t\tdata = pic_ioport_read(&s->pics[addr >> 7], addr);\n\t\tbreak;\n\tcase 0x4d0:\n\tcase 0x4d1:\n\t\tdata = elcr_ioport_read(&s->pics[addr & 1], addr);\n\t\tbreak;\n\t}\n\t*(unsigned char *)val = data;\n\tpic_unlock(s);\n\treturn 0;\n}"
  },
  {
    "function_name": "picdev_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/i8259.c",
    "lines": "474-500",
    "snippet": "static int picdev_write(struct kvm_pic *s,\n\t\t\t gpa_t addr, int len, const void *val)\n{\n\tunsigned char data = *(unsigned char *)val;\n\tif (!picdev_in_range(addr))\n\t\treturn -EOPNOTSUPP;\n\n\tif (len != 1) {\n\t\tpr_pic_unimpl(\"non byte write\\n\");\n\t\treturn 0;\n\t}\n\tpic_lock(s);\n\tswitch (addr) {\n\tcase 0x20:\n\tcase 0x21:\n\tcase 0xa0:\n\tcase 0xa1:\n\t\tpic_ioport_write(&s->pics[addr >> 7], addr, data);\n\t\tbreak;\n\tcase 0x4d0:\n\tcase 0x4d1:\n\t\telcr_ioport_write(&s->pics[addr & 1], addr, data);\n\t\tbreak;\n\t}\n\tpic_unlock(s);\n\treturn 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/kvm_host.h>",
      "#include \"irq.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pic_unlock",
          "args": [
            "s"
          ],
          "line": 498
        },
        "resolved": true,
        "details": {
          "function_name": "pic_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/i8259.c",
          "lines": "48-73",
          "snippet": "static void pic_unlock(struct kvm_pic *s)\n\t__releases(&s->lock)\n{\n\tbool wakeup = s->wakeup_needed;\n\tstruct kvm_vcpu *vcpu, *found = NULL;\n\tint i;\n\n\ts->wakeup_needed = false;\n\n\tspin_unlock(&s->lock);\n\n\tif (wakeup) {\n\t\tkvm_for_each_vcpu(i, vcpu, s->kvm) {\n\t\t\tif (kvm_apic_accept_pic_intr(vcpu)) {\n\t\t\t\tfound = vcpu;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!found)\n\t\t\treturn;\n\n\t\tkvm_make_request(KVM_REQ_EVENT, found);\n\t\tkvm_vcpu_kick(found);\n\t}\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/kvm_host.h>",
            "#include \"irq.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void pic_unlock(struct kvm_pic *s)\n\t__releases(&s->lock)\n{\n\tbool wakeup = s->wakeup_needed;\n\tstruct kvm_vcpu *vcpu, *found = NULL;\n\tint i;\n\n\ts->wakeup_needed = false;\n\n\tspin_unlock(&s->lock);\n\n\tif (wakeup) {\n\t\tkvm_for_each_vcpu(i, vcpu, s->kvm) {\n\t\t\tif (kvm_apic_accept_pic_intr(vcpu)) {\n\t\t\t\tfound = vcpu;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!found)\n\t\t\treturn;\n\n\t\tkvm_make_request(KVM_REQ_EVENT, found);\n\t\tkvm_vcpu_kick(found);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "elcr_ioport_write",
          "args": [
            "&s->pics[addr & 1]",
            "addr",
            "data"
          ],
          "line": 495
        },
        "resolved": true,
        "details": {
          "function_name": "elcr_ioport_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/i8259.c",
          "lines": "447-451",
          "snippet": "static void elcr_ioport_write(void *opaque, u32 addr, u32 val)\n{\n\tstruct kvm_kpic_state *s = opaque;\n\ts->elcr = val & s->elcr_mask;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/kvm_host.h>",
            "#include \"irq.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void elcr_ioport_write(void *opaque, u32 addr, u32 val)\n{\n\tstruct kvm_kpic_state *s = opaque;\n\ts->elcr = val & s->elcr_mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pic_ioport_write",
          "args": [
            "&s->pics[addr >> 7]",
            "addr",
            "data"
          ],
          "line": 491
        },
        "resolved": true,
        "details": {
          "function_name": "pic_ioport_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/i8259.c",
          "lines": "310-401",
          "snippet": "static void pic_ioport_write(void *opaque, u32 addr, u32 val)\n{\n\tstruct kvm_kpic_state *s = opaque;\n\tint priority, cmd, irq;\n\n\taddr &= 1;\n\tif (addr == 0) {\n\t\tif (val & 0x10) {\n\t\t\ts->init4 = val & 1;\n\t\t\tif (val & 0x02)\n\t\t\t\tpr_pic_unimpl(\"single mode not supported\");\n\t\t\tif (val & 0x08)\n\t\t\t\tpr_pic_unimpl(\n\t\t\t\t\t\t\"level sensitive irq not supported\");\n\t\t\tkvm_pic_reset(s);\n\t\t} else if (val & 0x08) {\n\t\t\tif (val & 0x04)\n\t\t\t\ts->poll = 1;\n\t\t\tif (val & 0x02)\n\t\t\t\ts->read_reg_select = val & 1;\n\t\t\tif (val & 0x40)\n\t\t\t\ts->special_mask = (val >> 5) & 1;\n\t\t} else {\n\t\t\tcmd = val >> 5;\n\t\t\tswitch (cmd) {\n\t\t\tcase 0:\n\t\t\tcase 4:\n\t\t\t\ts->rotate_on_auto_eoi = cmd >> 2;\n\t\t\t\tbreak;\n\t\t\tcase 1:\t/* end of interrupt */\n\t\t\tcase 5:\n\t\t\t\tpriority = get_priority(s, s->isr);\n\t\t\t\tif (priority != 8) {\n\t\t\t\t\tirq = (priority + s->priority_add) & 7;\n\t\t\t\t\tif (cmd == 5)\n\t\t\t\t\t\ts->priority_add = (irq + 1) & 7;\n\t\t\t\t\tpic_clear_isr(s, irq);\n\t\t\t\t\tpic_update_irq(s->pics_state);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tirq = val & 7;\n\t\t\t\tpic_clear_isr(s, irq);\n\t\t\t\tpic_update_irq(s->pics_state);\n\t\t\t\tbreak;\n\t\t\tcase 6:\n\t\t\t\ts->priority_add = (val + 1) & 7;\n\t\t\t\tpic_update_irq(s->pics_state);\n\t\t\t\tbreak;\n\t\t\tcase 7:\n\t\t\t\tirq = val & 7;\n\t\t\t\ts->priority_add = (irq + 1) & 7;\n\t\t\t\tpic_clear_isr(s, irq);\n\t\t\t\tpic_update_irq(s->pics_state);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\t/* no operation */\n\t\t\t}\n\t\t}\n\t} else\n\t\tswitch (s->init_state) {\n\t\tcase 0: { /* normal mode */\n\t\t\tu8 imr_diff = s->imr ^ val,\n\t\t\t\toff = (s == &s->pics_state->pics[0]) ? 0 : 8;\n\t\t\ts->imr = val;\n\t\t\tfor (irq = 0; irq < PIC_NUM_PINS/2; irq++)\n\t\t\t\tif (imr_diff & (1 << irq))\n\t\t\t\t\tkvm_fire_mask_notifiers(\n\t\t\t\t\t\ts->pics_state->kvm,\n\t\t\t\t\t\tSELECT_PIC(irq + off),\n\t\t\t\t\t\tirq + off,\n\t\t\t\t\t\t!!(s->imr & (1 << irq)));\n\t\t\tpic_update_irq(s->pics_state);\n\t\t\tbreak;\n\t\t}\n\t\tcase 1:\n\t\t\ts->irq_base = val & 0xf8;\n\t\t\ts->init_state = 2;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tif (s->init4)\n\t\t\t\ts->init_state = 3;\n\t\t\telse\n\t\t\t\ts->init_state = 0;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\ts->special_fully_nested_mode = (val >> 4) & 1;\n\t\t\ts->auto_eoi = (val >> 1) & 1;\n\t\t\ts->init_state = 0;\n\t\t\tbreak;\n\t\t}\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/kvm_host.h>",
            "#include \"irq.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void pic_irq_request(struct kvm *kvm, int level);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void pic_irq_request(struct kvm *kvm, int level);\n\nstatic void pic_ioport_write(void *opaque, u32 addr, u32 val)\n{\n\tstruct kvm_kpic_state *s = opaque;\n\tint priority, cmd, irq;\n\n\taddr &= 1;\n\tif (addr == 0) {\n\t\tif (val & 0x10) {\n\t\t\ts->init4 = val & 1;\n\t\t\tif (val & 0x02)\n\t\t\t\tpr_pic_unimpl(\"single mode not supported\");\n\t\t\tif (val & 0x08)\n\t\t\t\tpr_pic_unimpl(\n\t\t\t\t\t\t\"level sensitive irq not supported\");\n\t\t\tkvm_pic_reset(s);\n\t\t} else if (val & 0x08) {\n\t\t\tif (val & 0x04)\n\t\t\t\ts->poll = 1;\n\t\t\tif (val & 0x02)\n\t\t\t\ts->read_reg_select = val & 1;\n\t\t\tif (val & 0x40)\n\t\t\t\ts->special_mask = (val >> 5) & 1;\n\t\t} else {\n\t\t\tcmd = val >> 5;\n\t\t\tswitch (cmd) {\n\t\t\tcase 0:\n\t\t\tcase 4:\n\t\t\t\ts->rotate_on_auto_eoi = cmd >> 2;\n\t\t\t\tbreak;\n\t\t\tcase 1:\t/* end of interrupt */\n\t\t\tcase 5:\n\t\t\t\tpriority = get_priority(s, s->isr);\n\t\t\t\tif (priority != 8) {\n\t\t\t\t\tirq = (priority + s->priority_add) & 7;\n\t\t\t\t\tif (cmd == 5)\n\t\t\t\t\t\ts->priority_add = (irq + 1) & 7;\n\t\t\t\t\tpic_clear_isr(s, irq);\n\t\t\t\t\tpic_update_irq(s->pics_state);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tirq = val & 7;\n\t\t\t\tpic_clear_isr(s, irq);\n\t\t\t\tpic_update_irq(s->pics_state);\n\t\t\t\tbreak;\n\t\t\tcase 6:\n\t\t\t\ts->priority_add = (val + 1) & 7;\n\t\t\t\tpic_update_irq(s->pics_state);\n\t\t\t\tbreak;\n\t\t\tcase 7:\n\t\t\t\tirq = val & 7;\n\t\t\t\ts->priority_add = (irq + 1) & 7;\n\t\t\t\tpic_clear_isr(s, irq);\n\t\t\t\tpic_update_irq(s->pics_state);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\t/* no operation */\n\t\t\t}\n\t\t}\n\t} else\n\t\tswitch (s->init_state) {\n\t\tcase 0: { /* normal mode */\n\t\t\tu8 imr_diff = s->imr ^ val,\n\t\t\t\toff = (s == &s->pics_state->pics[0]) ? 0 : 8;\n\t\t\ts->imr = val;\n\t\t\tfor (irq = 0; irq < PIC_NUM_PINS/2; irq++)\n\t\t\t\tif (imr_diff & (1 << irq))\n\t\t\t\t\tkvm_fire_mask_notifiers(\n\t\t\t\t\t\ts->pics_state->kvm,\n\t\t\t\t\t\tSELECT_PIC(irq + off),\n\t\t\t\t\t\tirq + off,\n\t\t\t\t\t\t!!(s->imr & (1 << irq)));\n\t\t\tpic_update_irq(s->pics_state);\n\t\t\tbreak;\n\t\t}\n\t\tcase 1:\n\t\t\ts->irq_base = val & 0xf8;\n\t\t\ts->init_state = 2;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tif (s->init4)\n\t\t\t\ts->init_state = 3;\n\t\t\telse\n\t\t\t\ts->init_state = 0;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\ts->special_fully_nested_mode = (val >> 4) & 1;\n\t\t\ts->auto_eoi = (val >> 1) & 1;\n\t\t\ts->init_state = 0;\n\t\t\tbreak;\n\t\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pic_lock",
          "args": [
            "s"
          ],
          "line": 485
        },
        "resolved": true,
        "details": {
          "function_name": "pic_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/i8259.c",
          "lines": "42-46",
          "snippet": "static void pic_lock(struct kvm_pic *s)\n\t__acquires(&s->lock)\n{\n\tspin_lock(&s->lock);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/kvm_host.h>",
            "#include \"irq.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void pic_lock(struct kvm_pic *s)\n\t__acquires(&s->lock)\n{\n\tspin_lock(&s->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_pic_unimpl",
          "args": [
            "\"non byte write\\n\""
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "picdev_in_range",
          "args": [
            "addr"
          ],
          "line": 478
        },
        "resolved": true,
        "details": {
          "function_name": "picdev_in_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/i8259.c",
          "lines": "459-472",
          "snippet": "static int picdev_in_range(gpa_t addr)\n{\n\tswitch (addr) {\n\tcase 0x20:\n\tcase 0x21:\n\tcase 0xa0:\n\tcase 0xa1:\n\tcase 0x4d0:\n\tcase 0x4d1:\n\t\treturn 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/kvm_host.h>",
            "#include \"irq.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic int picdev_in_range(gpa_t addr)\n{\n\tswitch (addr) {\n\tcase 0x20:\n\tcase 0x21:\n\tcase 0xa0:\n\tcase 0xa1:\n\tcase 0x4d0:\n\tcase 0x4d1:\n\t\treturn 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic int picdev_write(struct kvm_pic *s,\n\t\t\t gpa_t addr, int len, const void *val)\n{\n\tunsigned char data = *(unsigned char *)val;\n\tif (!picdev_in_range(addr))\n\t\treturn -EOPNOTSUPP;\n\n\tif (len != 1) {\n\t\tpr_pic_unimpl(\"non byte write\\n\");\n\t\treturn 0;\n\t}\n\tpic_lock(s);\n\tswitch (addr) {\n\tcase 0x20:\n\tcase 0x21:\n\tcase 0xa0:\n\tcase 0xa1:\n\t\tpic_ioport_write(&s->pics[addr >> 7], addr, data);\n\t\tbreak;\n\tcase 0x4d0:\n\tcase 0x4d1:\n\t\telcr_ioport_write(&s->pics[addr & 1], addr, data);\n\t\tbreak;\n\t}\n\tpic_unlock(s);\n\treturn 0;\n}"
  },
  {
    "function_name": "picdev_in_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/i8259.c",
    "lines": "459-472",
    "snippet": "static int picdev_in_range(gpa_t addr)\n{\n\tswitch (addr) {\n\tcase 0x20:\n\tcase 0x21:\n\tcase 0xa0:\n\tcase 0xa1:\n\tcase 0x4d0:\n\tcase 0x4d1:\n\t\treturn 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/kvm_host.h>",
      "#include \"irq.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic int picdev_in_range(gpa_t addr)\n{\n\tswitch (addr) {\n\tcase 0x20:\n\tcase 0x21:\n\tcase 0xa0:\n\tcase 0xa1:\n\tcase 0x4d0:\n\tcase 0x4d1:\n\t\treturn 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
  },
  {
    "function_name": "elcr_ioport_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/i8259.c",
    "lines": "453-457",
    "snippet": "static u32 elcr_ioport_read(void *opaque, u32 addr1)\n{\n\tstruct kvm_kpic_state *s = opaque;\n\treturn s->elcr;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/kvm_host.h>",
      "#include \"irq.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic u32 elcr_ioport_read(void *opaque, u32 addr1)\n{\n\tstruct kvm_kpic_state *s = opaque;\n\treturn s->elcr;\n}"
  },
  {
    "function_name": "elcr_ioport_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/i8259.c",
    "lines": "447-451",
    "snippet": "static void elcr_ioport_write(void *opaque, u32 addr, u32 val)\n{\n\tstruct kvm_kpic_state *s = opaque;\n\ts->elcr = val & s->elcr_mask;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/kvm_host.h>",
      "#include \"irq.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void elcr_ioport_write(void *opaque, u32 addr, u32 val)\n{\n\tstruct kvm_kpic_state *s = opaque;\n\ts->elcr = val & s->elcr_mask;\n}"
  },
  {
    "function_name": "pic_ioport_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/i8259.c",
    "lines": "425-445",
    "snippet": "static u32 pic_ioport_read(void *opaque, u32 addr1)\n{\n\tstruct kvm_kpic_state *s = opaque;\n\tunsigned int addr;\n\tint ret;\n\n\taddr = addr1;\n\taddr &= 1;\n\tif (s->poll) {\n\t\tret = pic_poll_read(s, addr1);\n\t\ts->poll = 0;\n\t} else\n\t\tif (addr == 0)\n\t\t\tif (s->read_reg_select)\n\t\t\t\tret = s->isr;\n\t\t\telse\n\t\t\t\tret = s->irr;\n\t\telse\n\t\t\tret = s->imr;\n\treturn ret;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/kvm_host.h>",
      "#include \"irq.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pic_poll_read",
          "args": [
            "s",
            "addr1"
          ],
          "line": 434
        },
        "resolved": true,
        "details": {
          "function_name": "pic_poll_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/i8259.c",
          "lines": "403-423",
          "snippet": "static u32 pic_poll_read(struct kvm_kpic_state *s, u32 addr1)\n{\n\tint ret;\n\n\tret = pic_get_irq(s);\n\tif (ret >= 0) {\n\t\tif (addr1 >> 7) {\n\t\t\ts->pics_state->pics[0].isr &= ~(1 << 2);\n\t\t\ts->pics_state->pics[0].irr &= ~(1 << 2);\n\t\t}\n\t\ts->irr &= ~(1 << ret);\n\t\tpic_clear_isr(s, ret);\n\t\tif (addr1 >> 7 || ret != 2)\n\t\t\tpic_update_irq(s->pics_state);\n\t} else {\n\t\tret = 0x07;\n\t\tpic_update_irq(s->pics_state);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/kvm_host.h>",
            "#include \"irq.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic u32 pic_poll_read(struct kvm_kpic_state *s, u32 addr1)\n{\n\tint ret;\n\n\tret = pic_get_irq(s);\n\tif (ret >= 0) {\n\t\tif (addr1 >> 7) {\n\t\t\ts->pics_state->pics[0].isr &= ~(1 << 2);\n\t\t\ts->pics_state->pics[0].irr &= ~(1 << 2);\n\t\t}\n\t\ts->irr &= ~(1 << ret);\n\t\tpic_clear_isr(s, ret);\n\t\tif (addr1 >> 7 || ret != 2)\n\t\t\tpic_update_irq(s->pics_state);\n\t} else {\n\t\tret = 0x07;\n\t\tpic_update_irq(s->pics_state);\n\t}\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic u32 pic_ioport_read(void *opaque, u32 addr1)\n{\n\tstruct kvm_kpic_state *s = opaque;\n\tunsigned int addr;\n\tint ret;\n\n\taddr = addr1;\n\taddr &= 1;\n\tif (s->poll) {\n\t\tret = pic_poll_read(s, addr1);\n\t\ts->poll = 0;\n\t} else\n\t\tif (addr == 0)\n\t\t\tif (s->read_reg_select)\n\t\t\t\tret = s->isr;\n\t\t\telse\n\t\t\t\tret = s->irr;\n\t\telse\n\t\t\tret = s->imr;\n\treturn ret;\n}"
  },
  {
    "function_name": "pic_poll_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/i8259.c",
    "lines": "403-423",
    "snippet": "static u32 pic_poll_read(struct kvm_kpic_state *s, u32 addr1)\n{\n\tint ret;\n\n\tret = pic_get_irq(s);\n\tif (ret >= 0) {\n\t\tif (addr1 >> 7) {\n\t\t\ts->pics_state->pics[0].isr &= ~(1 << 2);\n\t\t\ts->pics_state->pics[0].irr &= ~(1 << 2);\n\t\t}\n\t\ts->irr &= ~(1 << ret);\n\t\tpic_clear_isr(s, ret);\n\t\tif (addr1 >> 7 || ret != 2)\n\t\t\tpic_update_irq(s->pics_state);\n\t} else {\n\t\tret = 0x07;\n\t\tpic_update_irq(s->pics_state);\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/kvm_host.h>",
      "#include \"irq.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pic_update_irq",
          "args": [
            "s->pics_state"
          ],
          "line": 419
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_pic_update_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/i8259.c",
          "lines": "184-189",
          "snippet": "void kvm_pic_update_irq(struct kvm_pic *s)\n{\n\tpic_lock(s);\n\tpic_update_irq(s);\n\tpic_unlock(s);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/kvm_host.h>",
            "#include \"irq.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nvoid kvm_pic_update_irq(struct kvm_pic *s)\n{\n\tpic_lock(s);\n\tpic_update_irq(s);\n\tpic_unlock(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pic_clear_isr",
          "args": [
            "s",
            "ret"
          ],
          "line": 414
        },
        "resolved": true,
        "details": {
          "function_name": "pic_clear_isr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/i8259.c",
          "lines": "75-89",
          "snippet": "static void pic_clear_isr(struct kvm_kpic_state *s, int irq)\n{\n\ts->isr &= ~(1 << irq);\n\tif (s != &s->pics_state->pics[0])\n\t\tirq += 8;\n\t/*\n\t * We are dropping lock while calling ack notifiers since ack\n\t * notifier callbacks for assigned devices call into PIC recursively.\n\t * Other interrupt may be delivered to PIC while lock is dropped but\n\t * it should be safe since PIC state is already updated at this stage.\n\t */\n\tpic_unlock(s->pics_state);\n\tkvm_notify_acked_irq(s->pics_state->kvm, SELECT_PIC(irq), irq);\n\tpic_lock(s->pics_state);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/kvm_host.h>",
            "#include \"irq.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void pic_clear_isr(struct kvm_kpic_state *s, int irq)\n{\n\ts->isr &= ~(1 << irq);\n\tif (s != &s->pics_state->pics[0])\n\t\tirq += 8;\n\t/*\n\t * We are dropping lock while calling ack notifiers since ack\n\t * notifier callbacks for assigned devices call into PIC recursively.\n\t * Other interrupt may be delivered to PIC while lock is dropped but\n\t * it should be safe since PIC state is already updated at this stage.\n\t */\n\tpic_unlock(s->pics_state);\n\tkvm_notify_acked_irq(s->pics_state->kvm, SELECT_PIC(irq), irq);\n\tpic_lock(s->pics_state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pic_get_irq",
          "args": [
            "s"
          ],
          "line": 407
        },
        "resolved": true,
        "details": {
          "function_name": "pic_get_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/i8259.c",
          "lines": "138-162",
          "snippet": "static int pic_get_irq(struct kvm_kpic_state *s)\n{\n\tint mask, cur_priority, priority;\n\n\tmask = s->irr & ~s->imr;\n\tpriority = get_priority(s, mask);\n\tif (priority == 8)\n\t\treturn -1;\n\t/*\n\t * compute current priority. If special fully nested mode on the\n\t * master, the IRQ coming from the slave is not taken into account\n\t * for the priority computation.\n\t */\n\tmask = s->isr;\n\tif (s->special_fully_nested_mode && s == &s->pics_state->pics[0])\n\t\tmask &= ~(1 << 2);\n\tcur_priority = get_priority(s, mask);\n\tif (priority < cur_priority)\n\t\t/*\n\t\t * higher priority found: an irq should be generated\n\t\t */\n\t\treturn (priority + s->priority_add) & 7;\n\telse\n\t\treturn -1;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/kvm_host.h>",
            "#include \"irq.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic int pic_get_irq(struct kvm_kpic_state *s)\n{\n\tint mask, cur_priority, priority;\n\n\tmask = s->irr & ~s->imr;\n\tpriority = get_priority(s, mask);\n\tif (priority == 8)\n\t\treturn -1;\n\t/*\n\t * compute current priority. If special fully nested mode on the\n\t * master, the IRQ coming from the slave is not taken into account\n\t * for the priority computation.\n\t */\n\tmask = s->isr;\n\tif (s->special_fully_nested_mode && s == &s->pics_state->pics[0])\n\t\tmask &= ~(1 << 2);\n\tcur_priority = get_priority(s, mask);\n\tif (priority < cur_priority)\n\t\t/*\n\t\t * higher priority found: an irq should be generated\n\t\t */\n\t\treturn (priority + s->priority_add) & 7;\n\telse\n\t\treturn -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic u32 pic_poll_read(struct kvm_kpic_state *s, u32 addr1)\n{\n\tint ret;\n\n\tret = pic_get_irq(s);\n\tif (ret >= 0) {\n\t\tif (addr1 >> 7) {\n\t\t\ts->pics_state->pics[0].isr &= ~(1 << 2);\n\t\t\ts->pics_state->pics[0].irr &= ~(1 << 2);\n\t\t}\n\t\ts->irr &= ~(1 << ret);\n\t\tpic_clear_isr(s, ret);\n\t\tif (addr1 >> 7 || ret != 2)\n\t\t\tpic_update_irq(s->pics_state);\n\t} else {\n\t\tret = 0x07;\n\t\tpic_update_irq(s->pics_state);\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "pic_ioport_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/i8259.c",
    "lines": "310-401",
    "snippet": "static void pic_ioport_write(void *opaque, u32 addr, u32 val)\n{\n\tstruct kvm_kpic_state *s = opaque;\n\tint priority, cmd, irq;\n\n\taddr &= 1;\n\tif (addr == 0) {\n\t\tif (val & 0x10) {\n\t\t\ts->init4 = val & 1;\n\t\t\tif (val & 0x02)\n\t\t\t\tpr_pic_unimpl(\"single mode not supported\");\n\t\t\tif (val & 0x08)\n\t\t\t\tpr_pic_unimpl(\n\t\t\t\t\t\t\"level sensitive irq not supported\");\n\t\t\tkvm_pic_reset(s);\n\t\t} else if (val & 0x08) {\n\t\t\tif (val & 0x04)\n\t\t\t\ts->poll = 1;\n\t\t\tif (val & 0x02)\n\t\t\t\ts->read_reg_select = val & 1;\n\t\t\tif (val & 0x40)\n\t\t\t\ts->special_mask = (val >> 5) & 1;\n\t\t} else {\n\t\t\tcmd = val >> 5;\n\t\t\tswitch (cmd) {\n\t\t\tcase 0:\n\t\t\tcase 4:\n\t\t\t\ts->rotate_on_auto_eoi = cmd >> 2;\n\t\t\t\tbreak;\n\t\t\tcase 1:\t/* end of interrupt */\n\t\t\tcase 5:\n\t\t\t\tpriority = get_priority(s, s->isr);\n\t\t\t\tif (priority != 8) {\n\t\t\t\t\tirq = (priority + s->priority_add) & 7;\n\t\t\t\t\tif (cmd == 5)\n\t\t\t\t\t\ts->priority_add = (irq + 1) & 7;\n\t\t\t\t\tpic_clear_isr(s, irq);\n\t\t\t\t\tpic_update_irq(s->pics_state);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tirq = val & 7;\n\t\t\t\tpic_clear_isr(s, irq);\n\t\t\t\tpic_update_irq(s->pics_state);\n\t\t\t\tbreak;\n\t\t\tcase 6:\n\t\t\t\ts->priority_add = (val + 1) & 7;\n\t\t\t\tpic_update_irq(s->pics_state);\n\t\t\t\tbreak;\n\t\t\tcase 7:\n\t\t\t\tirq = val & 7;\n\t\t\t\ts->priority_add = (irq + 1) & 7;\n\t\t\t\tpic_clear_isr(s, irq);\n\t\t\t\tpic_update_irq(s->pics_state);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\t/* no operation */\n\t\t\t}\n\t\t}\n\t} else\n\t\tswitch (s->init_state) {\n\t\tcase 0: { /* normal mode */\n\t\t\tu8 imr_diff = s->imr ^ val,\n\t\t\t\toff = (s == &s->pics_state->pics[0]) ? 0 : 8;\n\t\t\ts->imr = val;\n\t\t\tfor (irq = 0; irq < PIC_NUM_PINS/2; irq++)\n\t\t\t\tif (imr_diff & (1 << irq))\n\t\t\t\t\tkvm_fire_mask_notifiers(\n\t\t\t\t\t\ts->pics_state->kvm,\n\t\t\t\t\t\tSELECT_PIC(irq + off),\n\t\t\t\t\t\tirq + off,\n\t\t\t\t\t\t!!(s->imr & (1 << irq)));\n\t\t\tpic_update_irq(s->pics_state);\n\t\t\tbreak;\n\t\t}\n\t\tcase 1:\n\t\t\ts->irq_base = val & 0xf8;\n\t\t\ts->init_state = 2;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tif (s->init4)\n\t\t\t\ts->init_state = 3;\n\t\t\telse\n\t\t\t\ts->init_state = 0;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\ts->special_fully_nested_mode = (val >> 4) & 1;\n\t\t\ts->auto_eoi = (val >> 1) & 1;\n\t\t\ts->init_state = 0;\n\t\t\tbreak;\n\t\t}\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/kvm_host.h>",
      "#include \"irq.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void pic_irq_request(struct kvm *kvm, int level);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pic_update_irq",
          "args": [
            "s->pics_state"
          ],
          "line": 382
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_pic_update_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/i8259.c",
          "lines": "184-189",
          "snippet": "void kvm_pic_update_irq(struct kvm_pic *s)\n{\n\tpic_lock(s);\n\tpic_update_irq(s);\n\tpic_unlock(s);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/kvm_host.h>",
            "#include \"irq.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nvoid kvm_pic_update_irq(struct kvm_pic *s)\n{\n\tpic_lock(s);\n\tpic_update_irq(s);\n\tpic_unlock(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_fire_mask_notifiers",
          "args": [
            "s->pics_state->kvm",
            "SELECT_PIC(irq + off)",
            "irq + off",
            "!!(s->imr & (1 << irq))"
          ],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_fire_mask_notifiers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/irq_comm.c",
          "lines": "226-239",
          "snippet": "void kvm_fire_mask_notifiers(struct kvm *kvm, unsigned irqchip, unsigned pin,\n\t\t\t     bool mask)\n{\n\tstruct kvm_irq_mask_notifier *kimn;\n\tint idx, gsi;\n\n\tidx = srcu_read_lock(&kvm->irq_srcu);\n\tgsi = kvm_irq_map_chip_pin(kvm, irqchip, pin);\n\tif (gsi != -1)\n\t\thlist_for_each_entry_rcu(kimn, &kvm->arch.mask_notifier_list, link)\n\t\t\tif (kimn->irq == gsi)\n\t\t\t\tkimn->func(kimn, mask);\n\tsrcu_read_unlock(&kvm->irq_srcu, idx);\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"hyperv.h\"",
            "#include \"lapic.h\"",
            "#include \"ioapic.h\"",
            "#include \"irq.h\"",
            "#include <asm/msidef.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"hyperv.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include \"irq.h\"\n#include <asm/msidef.h>\n#include <trace/events/kvm.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nvoid kvm_fire_mask_notifiers(struct kvm *kvm, unsigned irqchip, unsigned pin,\n\t\t\t     bool mask)\n{\n\tstruct kvm_irq_mask_notifier *kimn;\n\tint idx, gsi;\n\n\tidx = srcu_read_lock(&kvm->irq_srcu);\n\tgsi = kvm_irq_map_chip_pin(kvm, irqchip, pin);\n\tif (gsi != -1)\n\t\thlist_for_each_entry_rcu(kimn, &kvm->arch.mask_notifier_list, link)\n\t\t\tif (kimn->irq == gsi)\n\t\t\t\tkimn->func(kimn, mask);\n\tsrcu_read_unlock(&kvm->irq_srcu, idx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SELECT_PIC",
          "args": [
            "irq + off"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pic_clear_isr",
          "args": [
            "s",
            "irq"
          ],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "pic_clear_isr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/i8259.c",
          "lines": "75-89",
          "snippet": "static void pic_clear_isr(struct kvm_kpic_state *s, int irq)\n{\n\ts->isr &= ~(1 << irq);\n\tif (s != &s->pics_state->pics[0])\n\t\tirq += 8;\n\t/*\n\t * We are dropping lock while calling ack notifiers since ack\n\t * notifier callbacks for assigned devices call into PIC recursively.\n\t * Other interrupt may be delivered to PIC while lock is dropped but\n\t * it should be safe since PIC state is already updated at this stage.\n\t */\n\tpic_unlock(s->pics_state);\n\tkvm_notify_acked_irq(s->pics_state->kvm, SELECT_PIC(irq), irq);\n\tpic_lock(s->pics_state);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/kvm_host.h>",
            "#include \"irq.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void pic_clear_isr(struct kvm_kpic_state *s, int irq)\n{\n\ts->isr &= ~(1 << irq);\n\tif (s != &s->pics_state->pics[0])\n\t\tirq += 8;\n\t/*\n\t * We are dropping lock while calling ack notifiers since ack\n\t * notifier callbacks for assigned devices call into PIC recursively.\n\t * Other interrupt may be delivered to PIC while lock is dropped but\n\t * it should be safe since PIC state is already updated at this stage.\n\t */\n\tpic_unlock(s->pics_state);\n\tkvm_notify_acked_irq(s->pics_state->kvm, SELECT_PIC(irq), irq);\n\tpic_lock(s->pics_state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_priority",
          "args": [
            "s",
            "s->isr"
          ],
          "line": 341
        },
        "resolved": true,
        "details": {
          "function_name": "get_priority",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/i8259.c",
          "lines": "124-133",
          "snippet": "static inline int get_priority(struct kvm_kpic_state *s, int mask)\n{\n\tint priority;\n\tif (mask == 0)\n\t\treturn 8;\n\tpriority = 0;\n\twhile ((mask & (1 << ((priority + s->priority_add) & 7))) == 0)\n\t\tpriority++;\n\treturn priority;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/kvm_host.h>",
            "#include \"irq.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic inline int get_priority(struct kvm_kpic_state *s, int mask)\n{\n\tint priority;\n\tif (mask == 0)\n\t\treturn 8;\n\tpriority = 0;\n\twhile ((mask & (1 << ((priority + s->priority_add) & 7))) == 0)\n\t\tpriority++;\n\treturn priority;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_pic_reset",
          "args": [
            "s"
          ],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_pic_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/i8259.c",
          "lines": "276-308",
          "snippet": "void kvm_pic_reset(struct kvm_kpic_state *s)\n{\n\tint irq, i;\n\tstruct kvm_vcpu *vcpu;\n\tu8 edge_irr = s->irr & ~s->elcr;\n\tbool found = false;\n\n\ts->last_irr = 0;\n\ts->irr &= s->elcr;\n\ts->imr = 0;\n\ts->priority_add = 0;\n\ts->special_mask = 0;\n\ts->read_reg_select = 0;\n\tif (!s->init4) {\n\t\ts->special_fully_nested_mode = 0;\n\t\ts->auto_eoi = 0;\n\t}\n\ts->init_state = 1;\n\n\tkvm_for_each_vcpu(i, vcpu, s->pics_state->kvm)\n\t\tif (kvm_apic_accept_pic_intr(vcpu)) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\n\n\tif (!found)\n\t\treturn;\n\n\tfor (irq = 0; irq < PIC_NUM_PINS/2; irq++)\n\t\tif (edge_irr & (1 << irq))\n\t\t\tpic_clear_isr(s, irq);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/kvm_host.h>",
            "#include \"irq.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nvoid kvm_pic_reset(struct kvm_kpic_state *s)\n{\n\tint irq, i;\n\tstruct kvm_vcpu *vcpu;\n\tu8 edge_irr = s->irr & ~s->elcr;\n\tbool found = false;\n\n\ts->last_irr = 0;\n\ts->irr &= s->elcr;\n\ts->imr = 0;\n\ts->priority_add = 0;\n\ts->special_mask = 0;\n\ts->read_reg_select = 0;\n\tif (!s->init4) {\n\t\ts->special_fully_nested_mode = 0;\n\t\ts->auto_eoi = 0;\n\t}\n\ts->init_state = 1;\n\n\tkvm_for_each_vcpu(i, vcpu, s->pics_state->kvm)\n\t\tif (kvm_apic_accept_pic_intr(vcpu)) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\n\n\tif (!found)\n\t\treturn;\n\n\tfor (irq = 0; irq < PIC_NUM_PINS/2; irq++)\n\t\tif (edge_irr & (1 << irq))\n\t\t\tpic_clear_isr(s, irq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_pic_unimpl",
          "args": [
            "\"level sensitive irq not supported\""
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_pic_unimpl",
          "args": [
            "\"single mode not supported\""
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void pic_irq_request(struct kvm *kvm, int level);\n\nstatic void pic_ioport_write(void *opaque, u32 addr, u32 val)\n{\n\tstruct kvm_kpic_state *s = opaque;\n\tint priority, cmd, irq;\n\n\taddr &= 1;\n\tif (addr == 0) {\n\t\tif (val & 0x10) {\n\t\t\ts->init4 = val & 1;\n\t\t\tif (val & 0x02)\n\t\t\t\tpr_pic_unimpl(\"single mode not supported\");\n\t\t\tif (val & 0x08)\n\t\t\t\tpr_pic_unimpl(\n\t\t\t\t\t\t\"level sensitive irq not supported\");\n\t\t\tkvm_pic_reset(s);\n\t\t} else if (val & 0x08) {\n\t\t\tif (val & 0x04)\n\t\t\t\ts->poll = 1;\n\t\t\tif (val & 0x02)\n\t\t\t\ts->read_reg_select = val & 1;\n\t\t\tif (val & 0x40)\n\t\t\t\ts->special_mask = (val >> 5) & 1;\n\t\t} else {\n\t\t\tcmd = val >> 5;\n\t\t\tswitch (cmd) {\n\t\t\tcase 0:\n\t\t\tcase 4:\n\t\t\t\ts->rotate_on_auto_eoi = cmd >> 2;\n\t\t\t\tbreak;\n\t\t\tcase 1:\t/* end of interrupt */\n\t\t\tcase 5:\n\t\t\t\tpriority = get_priority(s, s->isr);\n\t\t\t\tif (priority != 8) {\n\t\t\t\t\tirq = (priority + s->priority_add) & 7;\n\t\t\t\t\tif (cmd == 5)\n\t\t\t\t\t\ts->priority_add = (irq + 1) & 7;\n\t\t\t\t\tpic_clear_isr(s, irq);\n\t\t\t\t\tpic_update_irq(s->pics_state);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tirq = val & 7;\n\t\t\t\tpic_clear_isr(s, irq);\n\t\t\t\tpic_update_irq(s->pics_state);\n\t\t\t\tbreak;\n\t\t\tcase 6:\n\t\t\t\ts->priority_add = (val + 1) & 7;\n\t\t\t\tpic_update_irq(s->pics_state);\n\t\t\t\tbreak;\n\t\t\tcase 7:\n\t\t\t\tirq = val & 7;\n\t\t\t\ts->priority_add = (irq + 1) & 7;\n\t\t\t\tpic_clear_isr(s, irq);\n\t\t\t\tpic_update_irq(s->pics_state);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\t/* no operation */\n\t\t\t}\n\t\t}\n\t} else\n\t\tswitch (s->init_state) {\n\t\tcase 0: { /* normal mode */\n\t\t\tu8 imr_diff = s->imr ^ val,\n\t\t\t\toff = (s == &s->pics_state->pics[0]) ? 0 : 8;\n\t\t\ts->imr = val;\n\t\t\tfor (irq = 0; irq < PIC_NUM_PINS/2; irq++)\n\t\t\t\tif (imr_diff & (1 << irq))\n\t\t\t\t\tkvm_fire_mask_notifiers(\n\t\t\t\t\t\ts->pics_state->kvm,\n\t\t\t\t\t\tSELECT_PIC(irq + off),\n\t\t\t\t\t\tirq + off,\n\t\t\t\t\t\t!!(s->imr & (1 << irq)));\n\t\t\tpic_update_irq(s->pics_state);\n\t\t\tbreak;\n\t\t}\n\t\tcase 1:\n\t\t\ts->irq_base = val & 0xf8;\n\t\t\ts->init_state = 2;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tif (s->init4)\n\t\t\t\ts->init_state = 3;\n\t\t\telse\n\t\t\t\ts->init_state = 0;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\ts->special_fully_nested_mode = (val >> 4) & 1;\n\t\t\ts->auto_eoi = (val >> 1) & 1;\n\t\t\ts->init_state = 0;\n\t\t\tbreak;\n\t\t}\n}"
  },
  {
    "function_name": "kvm_pic_reset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/i8259.c",
    "lines": "276-308",
    "snippet": "void kvm_pic_reset(struct kvm_kpic_state *s)\n{\n\tint irq, i;\n\tstruct kvm_vcpu *vcpu;\n\tu8 edge_irr = s->irr & ~s->elcr;\n\tbool found = false;\n\n\ts->last_irr = 0;\n\ts->irr &= s->elcr;\n\ts->imr = 0;\n\ts->priority_add = 0;\n\ts->special_mask = 0;\n\ts->read_reg_select = 0;\n\tif (!s->init4) {\n\t\ts->special_fully_nested_mode = 0;\n\t\ts->auto_eoi = 0;\n\t}\n\ts->init_state = 1;\n\n\tkvm_for_each_vcpu(i, vcpu, s->pics_state->kvm)\n\t\tif (kvm_apic_accept_pic_intr(vcpu)) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\n\n\tif (!found)\n\t\treturn;\n\n\tfor (irq = 0; irq < PIC_NUM_PINS/2; irq++)\n\t\tif (edge_irr & (1 << irq))\n\t\t\tpic_clear_isr(s, irq);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/kvm_host.h>",
      "#include \"irq.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pic_clear_isr",
          "args": [
            "s",
            "irq"
          ],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "pic_clear_isr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/i8259.c",
          "lines": "75-89",
          "snippet": "static void pic_clear_isr(struct kvm_kpic_state *s, int irq)\n{\n\ts->isr &= ~(1 << irq);\n\tif (s != &s->pics_state->pics[0])\n\t\tirq += 8;\n\t/*\n\t * We are dropping lock while calling ack notifiers since ack\n\t * notifier callbacks for assigned devices call into PIC recursively.\n\t * Other interrupt may be delivered to PIC while lock is dropped but\n\t * it should be safe since PIC state is already updated at this stage.\n\t */\n\tpic_unlock(s->pics_state);\n\tkvm_notify_acked_irq(s->pics_state->kvm, SELECT_PIC(irq), irq);\n\tpic_lock(s->pics_state);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/kvm_host.h>",
            "#include \"irq.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void pic_clear_isr(struct kvm_kpic_state *s, int irq)\n{\n\ts->isr &= ~(1 << irq);\n\tif (s != &s->pics_state->pics[0])\n\t\tirq += 8;\n\t/*\n\t * We are dropping lock while calling ack notifiers since ack\n\t * notifier callbacks for assigned devices call into PIC recursively.\n\t * Other interrupt may be delivered to PIC while lock is dropped but\n\t * it should be safe since PIC state is already updated at this stage.\n\t */\n\tpic_unlock(s->pics_state);\n\tkvm_notify_acked_irq(s->pics_state->kvm, SELECT_PIC(irq), irq);\n\tpic_lock(s->pics_state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_apic_accept_pic_intr",
          "args": [
            "vcpu"
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_accept_pic_intr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "1888-1899",
          "snippet": "int kvm_apic_accept_pic_intr(struct kvm_vcpu *vcpu)\n{\n\tu32 lvt0 = kvm_lapic_get_reg(vcpu->arch.apic, APIC_LVT0);\n\tint r = 0;\n\n\tif (!kvm_apic_hw_enabled(vcpu->arch.apic))\n\t\tr = 1;\n\tif ((lvt0 & APIC_LVT_MASKED) == 0 &&\n\t    GET_APIC_DELIVERY_MODE(lvt0) == APIC_MODE_EXTINT)\n\t\tr = 1;\n\treturn r;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nint kvm_apic_accept_pic_intr(struct kvm_vcpu *vcpu)\n{\n\tu32 lvt0 = kvm_lapic_get_reg(vcpu->arch.apic, APIC_LVT0);\n\tint r = 0;\n\n\tif (!kvm_apic_hw_enabled(vcpu->arch.apic))\n\t\tr = 1;\n\tif ((lvt0 & APIC_LVT_MASKED) == 0 &&\n\t    GET_APIC_DELIVERY_MODE(lvt0) == APIC_MODE_EXTINT)\n\t\tr = 1;\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_for_each_vcpu",
          "args": [
            "i",
            "vcpu",
            "s->pics_state->kvm"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nvoid kvm_pic_reset(struct kvm_kpic_state *s)\n{\n\tint irq, i;\n\tstruct kvm_vcpu *vcpu;\n\tu8 edge_irr = s->irr & ~s->elcr;\n\tbool found = false;\n\n\ts->last_irr = 0;\n\ts->irr &= s->elcr;\n\ts->imr = 0;\n\ts->priority_add = 0;\n\ts->special_mask = 0;\n\ts->read_reg_select = 0;\n\tif (!s->init4) {\n\t\ts->special_fully_nested_mode = 0;\n\t\ts->auto_eoi = 0;\n\t}\n\ts->init_state = 1;\n\n\tkvm_for_each_vcpu(i, vcpu, s->pics_state->kvm)\n\t\tif (kvm_apic_accept_pic_intr(vcpu)) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\n\n\tif (!found)\n\t\treturn;\n\n\tfor (irq = 0; irq < PIC_NUM_PINS/2; irq++)\n\t\tif (edge_irr & (1 << irq))\n\t\t\tpic_clear_isr(s, irq);\n}"
  },
  {
    "function_name": "kvm_pic_read_irq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/i8259.c",
    "lines": "239-274",
    "snippet": "int kvm_pic_read_irq(struct kvm *kvm)\n{\n\tint irq, irq2, intno;\n\tstruct kvm_pic *s = pic_irqchip(kvm);\n\n\ts->output = 0;\n\n\tpic_lock(s);\n\tirq = pic_get_irq(&s->pics[0]);\n\tif (irq >= 0) {\n\t\tpic_intack(&s->pics[0], irq);\n\t\tif (irq == 2) {\n\t\t\tirq2 = pic_get_irq(&s->pics[1]);\n\t\t\tif (irq2 >= 0)\n\t\t\t\tpic_intack(&s->pics[1], irq2);\n\t\t\telse\n\t\t\t\t/*\n\t\t\t\t * spurious IRQ on slave controller\n\t\t\t\t */\n\t\t\t\tirq2 = 7;\n\t\t\tintno = s->pics[1].irq_base + irq2;\n\t\t\tirq = irq2 + 8;\n\t\t} else\n\t\t\tintno = s->pics[0].irq_base + irq;\n\t} else {\n\t\t/*\n\t\t * spurious IRQ on host controller\n\t\t */\n\t\tirq = 7;\n\t\tintno = s->pics[0].irq_base + irq;\n\t}\n\tpic_update_irq(s);\n\tpic_unlock(s);\n\n\treturn intno;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/kvm_host.h>",
      "#include \"irq.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pic_unlock",
          "args": [
            "s"
          ],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "pic_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/i8259.c",
          "lines": "48-73",
          "snippet": "static void pic_unlock(struct kvm_pic *s)\n\t__releases(&s->lock)\n{\n\tbool wakeup = s->wakeup_needed;\n\tstruct kvm_vcpu *vcpu, *found = NULL;\n\tint i;\n\n\ts->wakeup_needed = false;\n\n\tspin_unlock(&s->lock);\n\n\tif (wakeup) {\n\t\tkvm_for_each_vcpu(i, vcpu, s->kvm) {\n\t\t\tif (kvm_apic_accept_pic_intr(vcpu)) {\n\t\t\t\tfound = vcpu;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!found)\n\t\t\treturn;\n\n\t\tkvm_make_request(KVM_REQ_EVENT, found);\n\t\tkvm_vcpu_kick(found);\n\t}\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/kvm_host.h>",
            "#include \"irq.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void pic_unlock(struct kvm_pic *s)\n\t__releases(&s->lock)\n{\n\tbool wakeup = s->wakeup_needed;\n\tstruct kvm_vcpu *vcpu, *found = NULL;\n\tint i;\n\n\ts->wakeup_needed = false;\n\n\tspin_unlock(&s->lock);\n\n\tif (wakeup) {\n\t\tkvm_for_each_vcpu(i, vcpu, s->kvm) {\n\t\t\tif (kvm_apic_accept_pic_intr(vcpu)) {\n\t\t\t\tfound = vcpu;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!found)\n\t\t\treturn;\n\n\t\tkvm_make_request(KVM_REQ_EVENT, found);\n\t\tkvm_vcpu_kick(found);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pic_update_irq",
          "args": [
            "s"
          ],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_pic_update_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/i8259.c",
          "lines": "184-189",
          "snippet": "void kvm_pic_update_irq(struct kvm_pic *s)\n{\n\tpic_lock(s);\n\tpic_update_irq(s);\n\tpic_unlock(s);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/kvm_host.h>",
            "#include \"irq.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nvoid kvm_pic_update_irq(struct kvm_pic *s)\n{\n\tpic_lock(s);\n\tpic_update_irq(s);\n\tpic_unlock(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pic_intack",
          "args": [
            "&s->pics[1]",
            "irq2"
          ],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "pic_intack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/i8259.c",
          "lines": "222-237",
          "snippet": "static inline void pic_intack(struct kvm_kpic_state *s, int irq)\n{\n\ts->isr |= 1 << irq;\n\t/*\n\t * We don't clear a level sensitive interrupt here\n\t */\n\tif (!(s->elcr & (1 << irq)))\n\t\ts->irr &= ~(1 << irq);\n\n\tif (s->auto_eoi) {\n\t\tif (s->rotate_on_auto_eoi)\n\t\t\ts->priority_add = (irq + 1) & 7;\n\t\tpic_clear_isr(s, irq);\n\t}\n\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/kvm_host.h>",
            "#include \"irq.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void pic_irq_request(struct kvm *kvm, int level);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void pic_irq_request(struct kvm *kvm, int level);\n\nstatic inline void pic_intack(struct kvm_kpic_state *s, int irq)\n{\n\ts->isr |= 1 << irq;\n\t/*\n\t * We don't clear a level sensitive interrupt here\n\t */\n\tif (!(s->elcr & (1 << irq)))\n\t\ts->irr &= ~(1 << irq);\n\n\tif (s->auto_eoi) {\n\t\tif (s->rotate_on_auto_eoi)\n\t\t\ts->priority_add = (irq + 1) & 7;\n\t\tpic_clear_isr(s, irq);\n\t}\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "pic_get_irq",
          "args": [
            "&s->pics[1]"
          ],
          "line": 251
        },
        "resolved": true,
        "details": {
          "function_name": "pic_get_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/i8259.c",
          "lines": "138-162",
          "snippet": "static int pic_get_irq(struct kvm_kpic_state *s)\n{\n\tint mask, cur_priority, priority;\n\n\tmask = s->irr & ~s->imr;\n\tpriority = get_priority(s, mask);\n\tif (priority == 8)\n\t\treturn -1;\n\t/*\n\t * compute current priority. If special fully nested mode on the\n\t * master, the IRQ coming from the slave is not taken into account\n\t * for the priority computation.\n\t */\n\tmask = s->isr;\n\tif (s->special_fully_nested_mode && s == &s->pics_state->pics[0])\n\t\tmask &= ~(1 << 2);\n\tcur_priority = get_priority(s, mask);\n\tif (priority < cur_priority)\n\t\t/*\n\t\t * higher priority found: an irq should be generated\n\t\t */\n\t\treturn (priority + s->priority_add) & 7;\n\telse\n\t\treturn -1;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/kvm_host.h>",
            "#include \"irq.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic int pic_get_irq(struct kvm_kpic_state *s)\n{\n\tint mask, cur_priority, priority;\n\n\tmask = s->irr & ~s->imr;\n\tpriority = get_priority(s, mask);\n\tif (priority == 8)\n\t\treturn -1;\n\t/*\n\t * compute current priority. If special fully nested mode on the\n\t * master, the IRQ coming from the slave is not taken into account\n\t * for the priority computation.\n\t */\n\tmask = s->isr;\n\tif (s->special_fully_nested_mode && s == &s->pics_state->pics[0])\n\t\tmask &= ~(1 << 2);\n\tcur_priority = get_priority(s, mask);\n\tif (priority < cur_priority)\n\t\t/*\n\t\t * higher priority found: an irq should be generated\n\t\t */\n\t\treturn (priority + s->priority_add) & 7;\n\telse\n\t\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pic_lock",
          "args": [
            "s"
          ],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "pic_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/i8259.c",
          "lines": "42-46",
          "snippet": "static void pic_lock(struct kvm_pic *s)\n\t__acquires(&s->lock)\n{\n\tspin_lock(&s->lock);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/kvm_host.h>",
            "#include \"irq.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void pic_lock(struct kvm_pic *s)\n\t__acquires(&s->lock)\n{\n\tspin_lock(&s->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pic_irqchip",
          "args": [
            "kvm"
          ],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "ioapic_irqchip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/ioapic.h",
          "lines": "108-111",
          "snippet": "static inline struct kvm_ioapic *ioapic_irqchip(struct kvm *kvm)\n{\n\treturn kvm->arch.vioapic;\n}",
          "includes": [
            "#include <kvm/iodev.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kvm/iodev.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct kvm_ioapic *ioapic_irqchip(struct kvm *kvm)\n{\n\treturn kvm->arch.vioapic;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nint kvm_pic_read_irq(struct kvm *kvm)\n{\n\tint irq, irq2, intno;\n\tstruct kvm_pic *s = pic_irqchip(kvm);\n\n\ts->output = 0;\n\n\tpic_lock(s);\n\tirq = pic_get_irq(&s->pics[0]);\n\tif (irq >= 0) {\n\t\tpic_intack(&s->pics[0], irq);\n\t\tif (irq == 2) {\n\t\t\tirq2 = pic_get_irq(&s->pics[1]);\n\t\t\tif (irq2 >= 0)\n\t\t\t\tpic_intack(&s->pics[1], irq2);\n\t\t\telse\n\t\t\t\t/*\n\t\t\t\t * spurious IRQ on slave controller\n\t\t\t\t */\n\t\t\t\tirq2 = 7;\n\t\t\tintno = s->pics[1].irq_base + irq2;\n\t\t\tirq = irq2 + 8;\n\t\t} else\n\t\t\tintno = s->pics[0].irq_base + irq;\n\t} else {\n\t\t/*\n\t\t * spurious IRQ on host controller\n\t\t */\n\t\tirq = 7;\n\t\tintno = s->pics[0].irq_base + irq;\n\t}\n\tpic_update_irq(s);\n\tpic_unlock(s);\n\n\treturn intno;\n}"
  },
  {
    "function_name": "pic_intack",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/i8259.c",
    "lines": "222-237",
    "snippet": "static inline void pic_intack(struct kvm_kpic_state *s, int irq)\n{\n\ts->isr |= 1 << irq;\n\t/*\n\t * We don't clear a level sensitive interrupt here\n\t */\n\tif (!(s->elcr & (1 << irq)))\n\t\ts->irr &= ~(1 << irq);\n\n\tif (s->auto_eoi) {\n\t\tif (s->rotate_on_auto_eoi)\n\t\t\ts->priority_add = (irq + 1) & 7;\n\t\tpic_clear_isr(s, irq);\n\t}\n\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/kvm_host.h>",
      "#include \"irq.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void pic_irq_request(struct kvm *kvm, int level);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pic_clear_isr",
          "args": [
            "s",
            "irq"
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "pic_clear_isr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/i8259.c",
          "lines": "75-89",
          "snippet": "static void pic_clear_isr(struct kvm_kpic_state *s, int irq)\n{\n\ts->isr &= ~(1 << irq);\n\tif (s != &s->pics_state->pics[0])\n\t\tirq += 8;\n\t/*\n\t * We are dropping lock while calling ack notifiers since ack\n\t * notifier callbacks for assigned devices call into PIC recursively.\n\t * Other interrupt may be delivered to PIC while lock is dropped but\n\t * it should be safe since PIC state is already updated at this stage.\n\t */\n\tpic_unlock(s->pics_state);\n\tkvm_notify_acked_irq(s->pics_state->kvm, SELECT_PIC(irq), irq);\n\tpic_lock(s->pics_state);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/kvm_host.h>",
            "#include \"irq.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void pic_clear_isr(struct kvm_kpic_state *s, int irq)\n{\n\ts->isr &= ~(1 << irq);\n\tif (s != &s->pics_state->pics[0])\n\t\tirq += 8;\n\t/*\n\t * We are dropping lock while calling ack notifiers since ack\n\t * notifier callbacks for assigned devices call into PIC recursively.\n\t * Other interrupt may be delivered to PIC while lock is dropped but\n\t * it should be safe since PIC state is already updated at this stage.\n\t */\n\tpic_unlock(s->pics_state);\n\tkvm_notify_acked_irq(s->pics_state->kvm, SELECT_PIC(irq), irq);\n\tpic_lock(s->pics_state);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void pic_irq_request(struct kvm *kvm, int level);\n\nstatic inline void pic_intack(struct kvm_kpic_state *s, int irq)\n{\n\ts->isr |= 1 << irq;\n\t/*\n\t * We don't clear a level sensitive interrupt here\n\t */\n\tif (!(s->elcr & (1 << irq)))\n\t\ts->irr &= ~(1 << irq);\n\n\tif (s->auto_eoi) {\n\t\tif (s->rotate_on_auto_eoi)\n\t\t\ts->priority_add = (irq + 1) & 7;\n\t\tpic_clear_isr(s, irq);\n\t}\n\n}"
  },
  {
    "function_name": "kvm_pic_clear_all",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/i8259.c",
    "lines": "209-217",
    "snippet": "void kvm_pic_clear_all(struct kvm_pic *s, int irq_source_id)\n{\n\tint i;\n\n\tpic_lock(s);\n\tfor (i = 0; i < PIC_NUM_PINS; i++)\n\t\t__clear_bit(irq_source_id, &s->irq_states[i]);\n\tpic_unlock(s);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/kvm_host.h>",
      "#include \"irq.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pic_unlock",
          "args": [
            "s"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "pic_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/i8259.c",
          "lines": "48-73",
          "snippet": "static void pic_unlock(struct kvm_pic *s)\n\t__releases(&s->lock)\n{\n\tbool wakeup = s->wakeup_needed;\n\tstruct kvm_vcpu *vcpu, *found = NULL;\n\tint i;\n\n\ts->wakeup_needed = false;\n\n\tspin_unlock(&s->lock);\n\n\tif (wakeup) {\n\t\tkvm_for_each_vcpu(i, vcpu, s->kvm) {\n\t\t\tif (kvm_apic_accept_pic_intr(vcpu)) {\n\t\t\t\tfound = vcpu;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!found)\n\t\t\treturn;\n\n\t\tkvm_make_request(KVM_REQ_EVENT, found);\n\t\tkvm_vcpu_kick(found);\n\t}\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/kvm_host.h>",
            "#include \"irq.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void pic_unlock(struct kvm_pic *s)\n\t__releases(&s->lock)\n{\n\tbool wakeup = s->wakeup_needed;\n\tstruct kvm_vcpu *vcpu, *found = NULL;\n\tint i;\n\n\ts->wakeup_needed = false;\n\n\tspin_unlock(&s->lock);\n\n\tif (wakeup) {\n\t\tkvm_for_each_vcpu(i, vcpu, s->kvm) {\n\t\t\tif (kvm_apic_accept_pic_intr(vcpu)) {\n\t\t\t\tfound = vcpu;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!found)\n\t\t\treturn;\n\n\t\tkvm_make_request(KVM_REQ_EVENT, found);\n\t\tkvm_vcpu_kick(found);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "__clear_bit",
          "args": [
            "irq_source_id",
            "&s->irq_states[i]"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pic_lock",
          "args": [
            "s"
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "pic_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/i8259.c",
          "lines": "42-46",
          "snippet": "static void pic_lock(struct kvm_pic *s)\n\t__acquires(&s->lock)\n{\n\tspin_lock(&s->lock);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/kvm_host.h>",
            "#include \"irq.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void pic_lock(struct kvm_pic *s)\n\t__acquires(&s->lock)\n{\n\tspin_lock(&s->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nvoid kvm_pic_clear_all(struct kvm_pic *s, int irq_source_id)\n{\n\tint i;\n\n\tpic_lock(s);\n\tfor (i = 0; i < PIC_NUM_PINS; i++)\n\t\t__clear_bit(irq_source_id, &s->irq_states[i]);\n\tpic_unlock(s);\n}"
  },
  {
    "function_name": "kvm_pic_set_irq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/i8259.c",
    "lines": "191-207",
    "snippet": "int kvm_pic_set_irq(struct kvm_pic *s, int irq, int irq_source_id, int level)\n{\n\tint ret, irq_level;\n\n\tBUG_ON(irq < 0 || irq >= PIC_NUM_PINS);\n\n\tpic_lock(s);\n\tirq_level = __kvm_irq_line_state(&s->irq_states[irq],\n\t\t\t\t\t irq_source_id, level);\n\tret = pic_set_irq1(&s->pics[irq >> 3], irq & 7, irq_level);\n\tpic_update_irq(s);\n\ttrace_kvm_pic_set_irq(irq >> 3, irq & 7, s->pics[irq >> 3].elcr,\n\t\t\t      s->pics[irq >> 3].imr, ret == 0);\n\tpic_unlock(s);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/kvm_host.h>",
      "#include \"irq.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void pic_irq_request(struct kvm *kvm, int level);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pic_unlock",
          "args": [
            "s"
          ],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "pic_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/i8259.c",
          "lines": "48-73",
          "snippet": "static void pic_unlock(struct kvm_pic *s)\n\t__releases(&s->lock)\n{\n\tbool wakeup = s->wakeup_needed;\n\tstruct kvm_vcpu *vcpu, *found = NULL;\n\tint i;\n\n\ts->wakeup_needed = false;\n\n\tspin_unlock(&s->lock);\n\n\tif (wakeup) {\n\t\tkvm_for_each_vcpu(i, vcpu, s->kvm) {\n\t\t\tif (kvm_apic_accept_pic_intr(vcpu)) {\n\t\t\t\tfound = vcpu;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!found)\n\t\t\treturn;\n\n\t\tkvm_make_request(KVM_REQ_EVENT, found);\n\t\tkvm_vcpu_kick(found);\n\t}\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/kvm_host.h>",
            "#include \"irq.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void pic_unlock(struct kvm_pic *s)\n\t__releases(&s->lock)\n{\n\tbool wakeup = s->wakeup_needed;\n\tstruct kvm_vcpu *vcpu, *found = NULL;\n\tint i;\n\n\ts->wakeup_needed = false;\n\n\tspin_unlock(&s->lock);\n\n\tif (wakeup) {\n\t\tkvm_for_each_vcpu(i, vcpu, s->kvm) {\n\t\t\tif (kvm_apic_accept_pic_intr(vcpu)) {\n\t\t\t\tfound = vcpu;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!found)\n\t\t\treturn;\n\n\t\tkvm_make_request(KVM_REQ_EVENT, found);\n\t\tkvm_vcpu_kick(found);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_kvm_pic_set_irq",
          "args": [
            "irq >> 3",
            "irq & 7",
            "s->pics[irq >> 3].elcr",
            "s->pics[irq >> 3].imr",
            "ret == 0"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pic_update_irq",
          "args": [
            "s"
          ],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_pic_update_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/i8259.c",
          "lines": "184-189",
          "snippet": "void kvm_pic_update_irq(struct kvm_pic *s)\n{\n\tpic_lock(s);\n\tpic_update_irq(s);\n\tpic_unlock(s);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/kvm_host.h>",
            "#include \"irq.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nvoid kvm_pic_update_irq(struct kvm_pic *s)\n{\n\tpic_lock(s);\n\tpic_update_irq(s);\n\tpic_unlock(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pic_set_irq1",
          "args": [
            "&s->pics[irq >> 3]",
            "irq & 7",
            "irq_level"
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "pic_set_irq1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/i8259.c",
          "lines": "94-118",
          "snippet": "static inline int pic_set_irq1(struct kvm_kpic_state *s, int irq, int level)\n{\n\tint mask, ret = 1;\n\tmask = 1 << irq;\n\tif (s->elcr & mask)\t/* level triggered */\n\t\tif (level) {\n\t\t\tret = !(s->irr & mask);\n\t\t\ts->irr |= mask;\n\t\t\ts->last_irr |= mask;\n\t\t} else {\n\t\t\ts->irr &= ~mask;\n\t\t\ts->last_irr &= ~mask;\n\t\t}\n\telse\t/* edge triggered */\n\t\tif (level) {\n\t\t\tif ((s->last_irr & mask) == 0) {\n\t\t\t\tret = !(s->irr & mask);\n\t\t\t\ts->irr |= mask;\n\t\t\t}\n\t\t\ts->last_irr |= mask;\n\t\t} else\n\t\t\ts->last_irr &= ~mask;\n\n\treturn (s->imr & mask) ? -1 : ret;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/kvm_host.h>",
            "#include \"irq.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void pic_irq_request(struct kvm *kvm, int level);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void pic_irq_request(struct kvm *kvm, int level);\n\nstatic inline int pic_set_irq1(struct kvm_kpic_state *s, int irq, int level)\n{\n\tint mask, ret = 1;\n\tmask = 1 << irq;\n\tif (s->elcr & mask)\t/* level triggered */\n\t\tif (level) {\n\t\t\tret = !(s->irr & mask);\n\t\t\ts->irr |= mask;\n\t\t\ts->last_irr |= mask;\n\t\t} else {\n\t\t\ts->irr &= ~mask;\n\t\t\ts->last_irr &= ~mask;\n\t\t}\n\telse\t/* edge triggered */\n\t\tif (level) {\n\t\t\tif ((s->last_irr & mask) == 0) {\n\t\t\t\tret = !(s->irr & mask);\n\t\t\t\ts->irr |= mask;\n\t\t\t}\n\t\t\ts->last_irr |= mask;\n\t\t} else\n\t\t\ts->last_irr &= ~mask;\n\n\treturn (s->imr & mask) ? -1 : ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__kvm_irq_line_state",
          "args": [
            "&s->irq_states[irq]",
            "irq_source_id",
            "level"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pic_lock",
          "args": [
            "s"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "pic_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/i8259.c",
          "lines": "42-46",
          "snippet": "static void pic_lock(struct kvm_pic *s)\n\t__acquires(&s->lock)\n{\n\tspin_lock(&s->lock);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/kvm_host.h>",
            "#include \"irq.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void pic_lock(struct kvm_pic *s)\n\t__acquires(&s->lock)\n{\n\tspin_lock(&s->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "irq < 0 || irq >= PIC_NUM_PINS"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void pic_irq_request(struct kvm *kvm, int level);\n\nint kvm_pic_set_irq(struct kvm_pic *s, int irq, int irq_source_id, int level)\n{\n\tint ret, irq_level;\n\n\tBUG_ON(irq < 0 || irq >= PIC_NUM_PINS);\n\n\tpic_lock(s);\n\tirq_level = __kvm_irq_line_state(&s->irq_states[irq],\n\t\t\t\t\t irq_source_id, level);\n\tret = pic_set_irq1(&s->pics[irq >> 3], irq & 7, irq_level);\n\tpic_update_irq(s);\n\ttrace_kvm_pic_set_irq(irq >> 3, irq & 7, s->pics[irq >> 3].elcr,\n\t\t\t      s->pics[irq >> 3].imr, ret == 0);\n\tpic_unlock(s);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "kvm_pic_update_irq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/i8259.c",
    "lines": "184-189",
    "snippet": "void kvm_pic_update_irq(struct kvm_pic *s)\n{\n\tpic_lock(s);\n\tpic_update_irq(s);\n\tpic_unlock(s);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/kvm_host.h>",
      "#include \"irq.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pic_unlock",
          "args": [
            "s"
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "pic_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/i8259.c",
          "lines": "48-73",
          "snippet": "static void pic_unlock(struct kvm_pic *s)\n\t__releases(&s->lock)\n{\n\tbool wakeup = s->wakeup_needed;\n\tstruct kvm_vcpu *vcpu, *found = NULL;\n\tint i;\n\n\ts->wakeup_needed = false;\n\n\tspin_unlock(&s->lock);\n\n\tif (wakeup) {\n\t\tkvm_for_each_vcpu(i, vcpu, s->kvm) {\n\t\t\tif (kvm_apic_accept_pic_intr(vcpu)) {\n\t\t\t\tfound = vcpu;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!found)\n\t\t\treturn;\n\n\t\tkvm_make_request(KVM_REQ_EVENT, found);\n\t\tkvm_vcpu_kick(found);\n\t}\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/kvm_host.h>",
            "#include \"irq.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void pic_unlock(struct kvm_pic *s)\n\t__releases(&s->lock)\n{\n\tbool wakeup = s->wakeup_needed;\n\tstruct kvm_vcpu *vcpu, *found = NULL;\n\tint i;\n\n\ts->wakeup_needed = false;\n\n\tspin_unlock(&s->lock);\n\n\tif (wakeup) {\n\t\tkvm_for_each_vcpu(i, vcpu, s->kvm) {\n\t\t\tif (kvm_apic_accept_pic_intr(vcpu)) {\n\t\t\t\tfound = vcpu;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!found)\n\t\t\treturn;\n\n\t\tkvm_make_request(KVM_REQ_EVENT, found);\n\t\tkvm_vcpu_kick(found);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pic_update_irq",
          "args": [
            "s"
          ],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_pic_update_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/i8259.c",
          "lines": "184-189",
          "snippet": "void kvm_pic_update_irq(struct kvm_pic *s)\n{\n\tpic_lock(s);\n\tpic_update_irq(s);\n\tpic_unlock(s);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "pic_lock",
          "args": [
            "s"
          ],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "pic_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/i8259.c",
          "lines": "42-46",
          "snippet": "static void pic_lock(struct kvm_pic *s)\n\t__acquires(&s->lock)\n{\n\tspin_lock(&s->lock);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/kvm_host.h>",
            "#include \"irq.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void pic_lock(struct kvm_pic *s)\n\t__acquires(&s->lock)\n{\n\tspin_lock(&s->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nvoid kvm_pic_update_irq(struct kvm_pic *s)\n{\n\tpic_lock(s);\n\tpic_update_irq(s);\n\tpic_unlock(s);\n}"
  },
  {
    "function_name": "pic_update_irq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/i8259.c",
    "lines": "168-182",
    "snippet": "static void pic_update_irq(struct kvm_pic *s)\n{\n\tint irq2, irq;\n\n\tirq2 = pic_get_irq(&s->pics[1]);\n\tif (irq2 >= 0) {\n\t\t/*\n\t\t * if irq request by slave pic, signal master PIC\n\t\t */\n\t\tpic_set_irq1(&s->pics[0], 2, 1);\n\t\tpic_set_irq1(&s->pics[0], 2, 0);\n\t}\n\tirq = pic_get_irq(&s->pics[0]);\n\tpic_irq_request(s->kvm, irq >= 0);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/kvm_host.h>",
      "#include \"irq.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pic_irq_request",
          "args": [
            "s->kvm",
            "irq >= 0"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "pic_irq_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/i8259.c",
          "lines": "577-584",
          "snippet": "static void pic_irq_request(struct kvm *kvm, int level)\n{\n\tstruct kvm_pic *s = pic_irqchip(kvm);\n\n\tif (!s->output)\n\t\ts->wakeup_needed = true;\n\ts->output = level;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/kvm_host.h>",
            "#include \"irq.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void pic_irq_request(struct kvm *kvm, int level);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void pic_irq_request(struct kvm *kvm, int level);\n\nstatic void pic_irq_request(struct kvm *kvm, int level)\n{\n\tstruct kvm_pic *s = pic_irqchip(kvm);\n\n\tif (!s->output)\n\t\ts->wakeup_needed = true;\n\ts->output = level;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pic_get_irq",
          "args": [
            "&s->pics[0]"
          ],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "pic_get_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/i8259.c",
          "lines": "138-162",
          "snippet": "static int pic_get_irq(struct kvm_kpic_state *s)\n{\n\tint mask, cur_priority, priority;\n\n\tmask = s->irr & ~s->imr;\n\tpriority = get_priority(s, mask);\n\tif (priority == 8)\n\t\treturn -1;\n\t/*\n\t * compute current priority. If special fully nested mode on the\n\t * master, the IRQ coming from the slave is not taken into account\n\t * for the priority computation.\n\t */\n\tmask = s->isr;\n\tif (s->special_fully_nested_mode && s == &s->pics_state->pics[0])\n\t\tmask &= ~(1 << 2);\n\tcur_priority = get_priority(s, mask);\n\tif (priority < cur_priority)\n\t\t/*\n\t\t * higher priority found: an irq should be generated\n\t\t */\n\t\treturn (priority + s->priority_add) & 7;\n\telse\n\t\treturn -1;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/kvm_host.h>",
            "#include \"irq.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic int pic_get_irq(struct kvm_kpic_state *s)\n{\n\tint mask, cur_priority, priority;\n\n\tmask = s->irr & ~s->imr;\n\tpriority = get_priority(s, mask);\n\tif (priority == 8)\n\t\treturn -1;\n\t/*\n\t * compute current priority. If special fully nested mode on the\n\t * master, the IRQ coming from the slave is not taken into account\n\t * for the priority computation.\n\t */\n\tmask = s->isr;\n\tif (s->special_fully_nested_mode && s == &s->pics_state->pics[0])\n\t\tmask &= ~(1 << 2);\n\tcur_priority = get_priority(s, mask);\n\tif (priority < cur_priority)\n\t\t/*\n\t\t * higher priority found: an irq should be generated\n\t\t */\n\t\treturn (priority + s->priority_add) & 7;\n\telse\n\t\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pic_set_irq1",
          "args": [
            "&s->pics[0]",
            "2",
            "0"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "pic_set_irq1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/i8259.c",
          "lines": "94-118",
          "snippet": "static inline int pic_set_irq1(struct kvm_kpic_state *s, int irq, int level)\n{\n\tint mask, ret = 1;\n\tmask = 1 << irq;\n\tif (s->elcr & mask)\t/* level triggered */\n\t\tif (level) {\n\t\t\tret = !(s->irr & mask);\n\t\t\ts->irr |= mask;\n\t\t\ts->last_irr |= mask;\n\t\t} else {\n\t\t\ts->irr &= ~mask;\n\t\t\ts->last_irr &= ~mask;\n\t\t}\n\telse\t/* edge triggered */\n\t\tif (level) {\n\t\t\tif ((s->last_irr & mask) == 0) {\n\t\t\t\tret = !(s->irr & mask);\n\t\t\t\ts->irr |= mask;\n\t\t\t}\n\t\t\ts->last_irr |= mask;\n\t\t} else\n\t\t\ts->last_irr &= ~mask;\n\n\treturn (s->imr & mask) ? -1 : ret;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/kvm_host.h>",
            "#include \"irq.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void pic_irq_request(struct kvm *kvm, int level);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void pic_irq_request(struct kvm *kvm, int level);\n\nstatic inline int pic_set_irq1(struct kvm_kpic_state *s, int irq, int level)\n{\n\tint mask, ret = 1;\n\tmask = 1 << irq;\n\tif (s->elcr & mask)\t/* level triggered */\n\t\tif (level) {\n\t\t\tret = !(s->irr & mask);\n\t\t\ts->irr |= mask;\n\t\t\ts->last_irr |= mask;\n\t\t} else {\n\t\t\ts->irr &= ~mask;\n\t\t\ts->last_irr &= ~mask;\n\t\t}\n\telse\t/* edge triggered */\n\t\tif (level) {\n\t\t\tif ((s->last_irr & mask) == 0) {\n\t\t\t\tret = !(s->irr & mask);\n\t\t\t\ts->irr |= mask;\n\t\t\t}\n\t\t\ts->last_irr |= mask;\n\t\t} else\n\t\t\ts->last_irr &= ~mask;\n\n\treturn (s->imr & mask) ? -1 : ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void pic_update_irq(struct kvm_pic *s)\n{\n\tint irq2, irq;\n\n\tirq2 = pic_get_irq(&s->pics[1]);\n\tif (irq2 >= 0) {\n\t\t/*\n\t\t * if irq request by slave pic, signal master PIC\n\t\t */\n\t\tpic_set_irq1(&s->pics[0], 2, 1);\n\t\tpic_set_irq1(&s->pics[0], 2, 0);\n\t}\n\tirq = pic_get_irq(&s->pics[0]);\n\tpic_irq_request(s->kvm, irq >= 0);\n}"
  },
  {
    "function_name": "pic_get_irq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/i8259.c",
    "lines": "138-162",
    "snippet": "static int pic_get_irq(struct kvm_kpic_state *s)\n{\n\tint mask, cur_priority, priority;\n\n\tmask = s->irr & ~s->imr;\n\tpriority = get_priority(s, mask);\n\tif (priority == 8)\n\t\treturn -1;\n\t/*\n\t * compute current priority. If special fully nested mode on the\n\t * master, the IRQ coming from the slave is not taken into account\n\t * for the priority computation.\n\t */\n\tmask = s->isr;\n\tif (s->special_fully_nested_mode && s == &s->pics_state->pics[0])\n\t\tmask &= ~(1 << 2);\n\tcur_priority = get_priority(s, mask);\n\tif (priority < cur_priority)\n\t\t/*\n\t\t * higher priority found: an irq should be generated\n\t\t */\n\t\treturn (priority + s->priority_add) & 7;\n\telse\n\t\treturn -1;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/kvm_host.h>",
      "#include \"irq.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_priority",
          "args": [
            "s",
            "mask"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "get_priority",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/i8259.c",
          "lines": "124-133",
          "snippet": "static inline int get_priority(struct kvm_kpic_state *s, int mask)\n{\n\tint priority;\n\tif (mask == 0)\n\t\treturn 8;\n\tpriority = 0;\n\twhile ((mask & (1 << ((priority + s->priority_add) & 7))) == 0)\n\t\tpriority++;\n\treturn priority;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/kvm_host.h>",
            "#include \"irq.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic inline int get_priority(struct kvm_kpic_state *s, int mask)\n{\n\tint priority;\n\tif (mask == 0)\n\t\treturn 8;\n\tpriority = 0;\n\twhile ((mask & (1 << ((priority + s->priority_add) & 7))) == 0)\n\t\tpriority++;\n\treturn priority;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic int pic_get_irq(struct kvm_kpic_state *s)\n{\n\tint mask, cur_priority, priority;\n\n\tmask = s->irr & ~s->imr;\n\tpriority = get_priority(s, mask);\n\tif (priority == 8)\n\t\treturn -1;\n\t/*\n\t * compute current priority. If special fully nested mode on the\n\t * master, the IRQ coming from the slave is not taken into account\n\t * for the priority computation.\n\t */\n\tmask = s->isr;\n\tif (s->special_fully_nested_mode && s == &s->pics_state->pics[0])\n\t\tmask &= ~(1 << 2);\n\tcur_priority = get_priority(s, mask);\n\tif (priority < cur_priority)\n\t\t/*\n\t\t * higher priority found: an irq should be generated\n\t\t */\n\t\treturn (priority + s->priority_add) & 7;\n\telse\n\t\treturn -1;\n}"
  },
  {
    "function_name": "get_priority",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/i8259.c",
    "lines": "124-133",
    "snippet": "static inline int get_priority(struct kvm_kpic_state *s, int mask)\n{\n\tint priority;\n\tif (mask == 0)\n\t\treturn 8;\n\tpriority = 0;\n\twhile ((mask & (1 << ((priority + s->priority_add) & 7))) == 0)\n\t\tpriority++;\n\treturn priority;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/kvm_host.h>",
      "#include \"irq.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic inline int get_priority(struct kvm_kpic_state *s, int mask)\n{\n\tint priority;\n\tif (mask == 0)\n\t\treturn 8;\n\tpriority = 0;\n\twhile ((mask & (1 << ((priority + s->priority_add) & 7))) == 0)\n\t\tpriority++;\n\treturn priority;\n}"
  },
  {
    "function_name": "pic_set_irq1",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/i8259.c",
    "lines": "94-118",
    "snippet": "static inline int pic_set_irq1(struct kvm_kpic_state *s, int irq, int level)\n{\n\tint mask, ret = 1;\n\tmask = 1 << irq;\n\tif (s->elcr & mask)\t/* level triggered */\n\t\tif (level) {\n\t\t\tret = !(s->irr & mask);\n\t\t\ts->irr |= mask;\n\t\t\ts->last_irr |= mask;\n\t\t} else {\n\t\t\ts->irr &= ~mask;\n\t\t\ts->last_irr &= ~mask;\n\t\t}\n\telse\t/* edge triggered */\n\t\tif (level) {\n\t\t\tif ((s->last_irr & mask) == 0) {\n\t\t\t\tret = !(s->irr & mask);\n\t\t\t\ts->irr |= mask;\n\t\t\t}\n\t\t\ts->last_irr |= mask;\n\t\t} else\n\t\t\ts->last_irr &= ~mask;\n\n\treturn (s->imr & mask) ? -1 : ret;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/kvm_host.h>",
      "#include \"irq.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void pic_irq_request(struct kvm *kvm, int level);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void pic_irq_request(struct kvm *kvm, int level);\n\nstatic inline int pic_set_irq1(struct kvm_kpic_state *s, int irq, int level)\n{\n\tint mask, ret = 1;\n\tmask = 1 << irq;\n\tif (s->elcr & mask)\t/* level triggered */\n\t\tif (level) {\n\t\t\tret = !(s->irr & mask);\n\t\t\ts->irr |= mask;\n\t\t\ts->last_irr |= mask;\n\t\t} else {\n\t\t\ts->irr &= ~mask;\n\t\t\ts->last_irr &= ~mask;\n\t\t}\n\telse\t/* edge triggered */\n\t\tif (level) {\n\t\t\tif ((s->last_irr & mask) == 0) {\n\t\t\t\tret = !(s->irr & mask);\n\t\t\t\ts->irr |= mask;\n\t\t\t}\n\t\t\ts->last_irr |= mask;\n\t\t} else\n\t\t\ts->last_irr &= ~mask;\n\n\treturn (s->imr & mask) ? -1 : ret;\n}"
  },
  {
    "function_name": "pic_clear_isr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/i8259.c",
    "lines": "75-89",
    "snippet": "static void pic_clear_isr(struct kvm_kpic_state *s, int irq)\n{\n\ts->isr &= ~(1 << irq);\n\tif (s != &s->pics_state->pics[0])\n\t\tirq += 8;\n\t/*\n\t * We are dropping lock while calling ack notifiers since ack\n\t * notifier callbacks for assigned devices call into PIC recursively.\n\t * Other interrupt may be delivered to PIC while lock is dropped but\n\t * it should be safe since PIC state is already updated at this stage.\n\t */\n\tpic_unlock(s->pics_state);\n\tkvm_notify_acked_irq(s->pics_state->kvm, SELECT_PIC(irq), irq);\n\tpic_lock(s->pics_state);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/kvm_host.h>",
      "#include \"irq.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pic_lock",
          "args": [
            "s->pics_state"
          ],
          "line": 88
        },
        "resolved": true,
        "details": {
          "function_name": "pic_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/i8259.c",
          "lines": "42-46",
          "snippet": "static void pic_lock(struct kvm_pic *s)\n\t__acquires(&s->lock)\n{\n\tspin_lock(&s->lock);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/kvm_host.h>",
            "#include \"irq.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void pic_lock(struct kvm_pic *s)\n\t__acquires(&s->lock)\n{\n\tspin_lock(&s->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_notify_acked_irq",
          "args": [
            "s->pics_state->kvm",
            "SELECT_PIC(irq)",
            "irq"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SELECT_PIC",
          "args": [
            "irq"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pic_unlock",
          "args": [
            "s->pics_state"
          ],
          "line": 86
        },
        "resolved": true,
        "details": {
          "function_name": "pic_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/i8259.c",
          "lines": "48-73",
          "snippet": "static void pic_unlock(struct kvm_pic *s)\n\t__releases(&s->lock)\n{\n\tbool wakeup = s->wakeup_needed;\n\tstruct kvm_vcpu *vcpu, *found = NULL;\n\tint i;\n\n\ts->wakeup_needed = false;\n\n\tspin_unlock(&s->lock);\n\n\tif (wakeup) {\n\t\tkvm_for_each_vcpu(i, vcpu, s->kvm) {\n\t\t\tif (kvm_apic_accept_pic_intr(vcpu)) {\n\t\t\t\tfound = vcpu;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!found)\n\t\t\treturn;\n\n\t\tkvm_make_request(KVM_REQ_EVENT, found);\n\t\tkvm_vcpu_kick(found);\n\t}\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/kvm_host.h>",
            "#include \"irq.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void pic_unlock(struct kvm_pic *s)\n\t__releases(&s->lock)\n{\n\tbool wakeup = s->wakeup_needed;\n\tstruct kvm_vcpu *vcpu, *found = NULL;\n\tint i;\n\n\ts->wakeup_needed = false;\n\n\tspin_unlock(&s->lock);\n\n\tif (wakeup) {\n\t\tkvm_for_each_vcpu(i, vcpu, s->kvm) {\n\t\t\tif (kvm_apic_accept_pic_intr(vcpu)) {\n\t\t\t\tfound = vcpu;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!found)\n\t\t\treturn;\n\n\t\tkvm_make_request(KVM_REQ_EVENT, found);\n\t\tkvm_vcpu_kick(found);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void pic_clear_isr(struct kvm_kpic_state *s, int irq)\n{\n\ts->isr &= ~(1 << irq);\n\tif (s != &s->pics_state->pics[0])\n\t\tirq += 8;\n\t/*\n\t * We are dropping lock while calling ack notifiers since ack\n\t * notifier callbacks for assigned devices call into PIC recursively.\n\t * Other interrupt may be delivered to PIC while lock is dropped but\n\t * it should be safe since PIC state is already updated at this stage.\n\t */\n\tpic_unlock(s->pics_state);\n\tkvm_notify_acked_irq(s->pics_state->kvm, SELECT_PIC(irq), irq);\n\tpic_lock(s->pics_state);\n}"
  },
  {
    "function_name": "pic_unlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/i8259.c",
    "lines": "48-73",
    "snippet": "static void pic_unlock(struct kvm_pic *s)\n\t__releases(&s->lock)\n{\n\tbool wakeup = s->wakeup_needed;\n\tstruct kvm_vcpu *vcpu, *found = NULL;\n\tint i;\n\n\ts->wakeup_needed = false;\n\n\tspin_unlock(&s->lock);\n\n\tif (wakeup) {\n\t\tkvm_for_each_vcpu(i, vcpu, s->kvm) {\n\t\t\tif (kvm_apic_accept_pic_intr(vcpu)) {\n\t\t\t\tfound = vcpu;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!found)\n\t\t\treturn;\n\n\t\tkvm_make_request(KVM_REQ_EVENT, found);\n\t\tkvm_vcpu_kick(found);\n\t}\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/kvm_host.h>",
      "#include \"irq.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_vcpu_kick",
          "args": [
            "found"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_make_request",
          "args": [
            "KVM_REQ_EVENT",
            "found"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_apic_accept_pic_intr",
          "args": [
            "vcpu"
          ],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_accept_pic_intr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "1888-1899",
          "snippet": "int kvm_apic_accept_pic_intr(struct kvm_vcpu *vcpu)\n{\n\tu32 lvt0 = kvm_lapic_get_reg(vcpu->arch.apic, APIC_LVT0);\n\tint r = 0;\n\n\tif (!kvm_apic_hw_enabled(vcpu->arch.apic))\n\t\tr = 1;\n\tif ((lvt0 & APIC_LVT_MASKED) == 0 &&\n\t    GET_APIC_DELIVERY_MODE(lvt0) == APIC_MODE_EXTINT)\n\t\tr = 1;\n\treturn r;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nint kvm_apic_accept_pic_intr(struct kvm_vcpu *vcpu)\n{\n\tu32 lvt0 = kvm_lapic_get_reg(vcpu->arch.apic, APIC_LVT0);\n\tint r = 0;\n\n\tif (!kvm_apic_hw_enabled(vcpu->arch.apic))\n\t\tr = 1;\n\tif ((lvt0 & APIC_LVT_MASKED) == 0 &&\n\t    GET_APIC_DELIVERY_MODE(lvt0) == APIC_MODE_EXTINT)\n\t\tr = 1;\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_for_each_vcpu",
          "args": [
            "i",
            "vcpu",
            "s->kvm"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&s->lock"
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "&s->lock"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void pic_unlock(struct kvm_pic *s)\n\t__releases(&s->lock)\n{\n\tbool wakeup = s->wakeup_needed;\n\tstruct kvm_vcpu *vcpu, *found = NULL;\n\tint i;\n\n\ts->wakeup_needed = false;\n\n\tspin_unlock(&s->lock);\n\n\tif (wakeup) {\n\t\tkvm_for_each_vcpu(i, vcpu, s->kvm) {\n\t\t\tif (kvm_apic_accept_pic_intr(vcpu)) {\n\t\t\t\tfound = vcpu;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!found)\n\t\t\treturn;\n\n\t\tkvm_make_request(KVM_REQ_EVENT, found);\n\t\tkvm_vcpu_kick(found);\n\t}\n}"
  },
  {
    "function_name": "pic_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/i8259.c",
    "lines": "42-46",
    "snippet": "static void pic_lock(struct kvm_pic *s)\n\t__acquires(&s->lock)\n{\n\tspin_lock(&s->lock);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/kvm_host.h>",
      "#include \"irq.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&s->lock"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__acquires",
          "args": [
            "&s->lock"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void pic_lock(struct kvm_pic *s)\n\t__acquires(&s->lock)\n{\n\tspin_lock(&s->lock);\n}"
  }
]