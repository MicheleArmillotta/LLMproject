[
  {
    "function_name": "emulator_writeback_register_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "5493-5496",
    "snippet": "void emulator_writeback_register_cache(struct x86_emulate_ctxt *ctxt)\n{\n\twriteback_registers(ctxt);\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "writeback_registers",
          "args": [
            "ctxt"
          ],
          "line": 5495
        },
        "resolved": true,
        "details": {
          "function_name": "writeback_registers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "283-289",
          "snippet": "static void writeback_registers(struct x86_emulate_ctxt *ctxt)\n{\n\tunsigned reg;\n\n\tfor_each_set_bit(reg, (ulong *)&ctxt->regs_dirty, 16)\n\t\tctxt->ops->write_gpr(ctxt, reg, ctxt->_regs[reg]);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic void writeback_registers(struct x86_emulate_ctxt *ctxt)\n{\n\tunsigned reg;\n\n\tfor_each_set_bit(reg, (ulong *)&ctxt->regs_dirty, 16)\n\t\tctxt->ops->write_gpr(ctxt, reg, ctxt->_regs[reg]);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nvoid emulator_writeback_register_cache(struct x86_emulate_ctxt *ctxt)\n{\n\twriteback_registers(ctxt);\n}"
  },
  {
    "function_name": "emulator_invalidate_register_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "5488-5491",
    "snippet": "void emulator_invalidate_register_cache(struct x86_emulate_ctxt *ctxt)\n{\n\tinvalidate_registers(ctxt);\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "invalidate_registers",
          "args": [
            "ctxt"
          ],
          "line": 5490
        },
        "resolved": true,
        "details": {
          "function_name": "invalidate_registers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "291-295",
          "snippet": "static void invalidate_registers(struct x86_emulate_ctxt *ctxt)\n{\n\tctxt->regs_dirty = 0;\n\tctxt->regs_valid = 0;\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic void invalidate_registers(struct x86_emulate_ctxt *ctxt)\n{\n\tctxt->regs_dirty = 0;\n\tctxt->regs_valid = 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nvoid emulator_invalidate_register_cache(struct x86_emulate_ctxt *ctxt)\n{\n\tinvalidate_registers(ctxt);\n}"
  },
  {
    "function_name": "x86_emulate_insn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "5136-5486",
    "snippet": "int x86_emulate_insn(struct x86_emulate_ctxt *ctxt)\n{\n\tconst struct x86_emulate_ops *ops = ctxt->ops;\n\tint rc = X86EMUL_CONTINUE;\n\tint saved_dst_type = ctxt->dst.type;\n\n\tctxt->mem_read.pos = 0;\n\n\t/* LOCK prefix is allowed only with some instructions */\n\tif (ctxt->lock_prefix && (!(ctxt->d & Lock) || ctxt->dst.type != OP_MEM)) {\n\t\trc = emulate_ud(ctxt);\n\t\tgoto done;\n\t}\n\n\tif ((ctxt->d & SrcMask) == SrcMemFAddr && ctxt->src.type != OP_MEM) {\n\t\trc = emulate_ud(ctxt);\n\t\tgoto done;\n\t}\n\n\tif (unlikely(ctxt->d &\n\t\t     (No64|Undefined|Sse|Mmx|Intercept|CheckPerm|Priv|Prot|String))) {\n\t\tif ((ctxt->mode == X86EMUL_MODE_PROT64 && (ctxt->d & No64)) ||\n\t\t\t\t(ctxt->d & Undefined)) {\n\t\t\trc = emulate_ud(ctxt);\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (((ctxt->d & (Sse|Mmx)) && ((ops->get_cr(ctxt, 0) & X86_CR0_EM)))\n\t\t    || ((ctxt->d & Sse) && !(ops->get_cr(ctxt, 4) & X86_CR4_OSFXSR))) {\n\t\t\trc = emulate_ud(ctxt);\n\t\t\tgoto done;\n\t\t}\n\n\t\tif ((ctxt->d & (Sse|Mmx)) && (ops->get_cr(ctxt, 0) & X86_CR0_TS)) {\n\t\t\trc = emulate_nm(ctxt);\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (ctxt->d & Mmx) {\n\t\t\trc = flush_pending_x87_faults(ctxt);\n\t\t\tif (rc != X86EMUL_CONTINUE)\n\t\t\t\tgoto done;\n\t\t\t/*\n\t\t\t * Now that we know the fpu is exception safe, we can fetch\n\t\t\t * operands from it.\n\t\t\t */\n\t\t\tfetch_possible_mmx_operand(ctxt, &ctxt->src);\n\t\t\tfetch_possible_mmx_operand(ctxt, &ctxt->src2);\n\t\t\tif (!(ctxt->d & Mov))\n\t\t\t\tfetch_possible_mmx_operand(ctxt, &ctxt->dst);\n\t\t}\n\n\t\tif (unlikely(ctxt->emul_flags & X86EMUL_GUEST_MASK) && ctxt->intercept) {\n\t\t\trc = emulator_check_intercept(ctxt, ctxt->intercept,\n\t\t\t\t\t\t      X86_ICPT_PRE_EXCEPT);\n\t\t\tif (rc != X86EMUL_CONTINUE)\n\t\t\t\tgoto done;\n\t\t}\n\n\t\t/* Instruction can only be executed in protected mode */\n\t\tif ((ctxt->d & Prot) && ctxt->mode < X86EMUL_MODE_PROT16) {\n\t\t\trc = emulate_ud(ctxt);\n\t\t\tgoto done;\n\t\t}\n\n\t\t/* Privileged instruction can be executed only in CPL=0 */\n\t\tif ((ctxt->d & Priv) && ops->cpl(ctxt)) {\n\t\t\tif (ctxt->d & PrivUD)\n\t\t\t\trc = emulate_ud(ctxt);\n\t\t\telse\n\t\t\t\trc = emulate_gp(ctxt, 0);\n\t\t\tgoto done;\n\t\t}\n\n\t\t/* Do instruction specific permission checks */\n\t\tif (ctxt->d & CheckPerm) {\n\t\t\trc = ctxt->check_perm(ctxt);\n\t\t\tif (rc != X86EMUL_CONTINUE)\n\t\t\t\tgoto done;\n\t\t}\n\n\t\tif (unlikely(ctxt->emul_flags & X86EMUL_GUEST_MASK) && (ctxt->d & Intercept)) {\n\t\t\trc = emulator_check_intercept(ctxt, ctxt->intercept,\n\t\t\t\t\t\t      X86_ICPT_POST_EXCEPT);\n\t\t\tif (rc != X86EMUL_CONTINUE)\n\t\t\t\tgoto done;\n\t\t}\n\n\t\tif (ctxt->rep_prefix && (ctxt->d & String)) {\n\t\t\t/* All REP prefixes have the same first termination condition */\n\t\t\tif (address_mask(ctxt, reg_read(ctxt, VCPU_REGS_RCX)) == 0) {\n\t\t\t\tstring_registers_quirk(ctxt);\n\t\t\t\tctxt->eip = ctxt->_eip;\n\t\t\t\tctxt->eflags &= ~X86_EFLAGS_RF;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t}\n\n\tif ((ctxt->src.type == OP_MEM) && !(ctxt->d & NoAccess)) {\n\t\trc = segmented_read(ctxt, ctxt->src.addr.mem,\n\t\t\t\t    ctxt->src.valptr, ctxt->src.bytes);\n\t\tif (rc != X86EMUL_CONTINUE)\n\t\t\tgoto done;\n\t\tctxt->src.orig_val64 = ctxt->src.val64;\n\t}\n\n\tif (ctxt->src2.type == OP_MEM) {\n\t\trc = segmented_read(ctxt, ctxt->src2.addr.mem,\n\t\t\t\t    &ctxt->src2.val, ctxt->src2.bytes);\n\t\tif (rc != X86EMUL_CONTINUE)\n\t\t\tgoto done;\n\t}\n\n\tif ((ctxt->d & DstMask) == ImplicitOps)\n\t\tgoto special_insn;\n\n\n\tif ((ctxt->dst.type == OP_MEM) && !(ctxt->d & Mov)) {\n\t\t/* optimisation - avoid slow emulated read if Mov */\n\t\trc = segmented_read(ctxt, ctxt->dst.addr.mem,\n\t\t\t\t   &ctxt->dst.val, ctxt->dst.bytes);\n\t\tif (rc != X86EMUL_CONTINUE) {\n\t\t\tif (!(ctxt->d & NoWrite) &&\n\t\t\t    rc == X86EMUL_PROPAGATE_FAULT &&\n\t\t\t    ctxt->exception.vector == PF_VECTOR)\n\t\t\t\tctxt->exception.error_code |= PFERR_WRITE_MASK;\n\t\t\tgoto done;\n\t\t}\n\t}\n\t/* Copy full 64-bit value for CMPXCHG8B.  */\n\tctxt->dst.orig_val64 = ctxt->dst.val64;\n\nspecial_insn:\n\n\tif (unlikely(ctxt->emul_flags & X86EMUL_GUEST_MASK) && (ctxt->d & Intercept)) {\n\t\trc = emulator_check_intercept(ctxt, ctxt->intercept,\n\t\t\t\t\t      X86_ICPT_POST_MEMACCESS);\n\t\tif (rc != X86EMUL_CONTINUE)\n\t\t\tgoto done;\n\t}\n\n\tif (ctxt->rep_prefix && (ctxt->d & String))\n\t\tctxt->eflags |= X86_EFLAGS_RF;\n\telse\n\t\tctxt->eflags &= ~X86_EFLAGS_RF;\n\n\tif (ctxt->execute) {\n\t\tif (ctxt->d & Fastop) {\n\t\t\tvoid (*fop)(struct fastop *) = (void *)ctxt->execute;\n\t\t\trc = fastop(ctxt, fop);\n\t\t\tif (rc != X86EMUL_CONTINUE)\n\t\t\t\tgoto done;\n\t\t\tgoto writeback;\n\t\t}\n\t\trc = ctxt->execute(ctxt);\n\t\tif (rc != X86EMUL_CONTINUE)\n\t\t\tgoto done;\n\t\tgoto writeback;\n\t}\n\n\tif (ctxt->opcode_len == 2)\n\t\tgoto twobyte_insn;\n\telse if (ctxt->opcode_len == 3)\n\t\tgoto threebyte_insn;\n\n\tswitch (ctxt->b) {\n\tcase 0x70 ... 0x7f: /* jcc (short) */\n\t\tif (test_cc(ctxt->b, ctxt->eflags))\n\t\t\trc = jmp_rel(ctxt, ctxt->src.val);\n\t\tbreak;\n\tcase 0x8d: /* lea r16/r32, m */\n\t\tctxt->dst.val = ctxt->src.addr.mem.ea;\n\t\tbreak;\n\tcase 0x90 ... 0x97: /* nop / xchg reg, rax */\n\t\tif (ctxt->dst.addr.reg == reg_rmw(ctxt, VCPU_REGS_RAX))\n\t\t\tctxt->dst.type = OP_NONE;\n\t\telse\n\t\t\trc = em_xchg(ctxt);\n\t\tbreak;\n\tcase 0x98: /* cbw/cwde/cdqe */\n\t\tswitch (ctxt->op_bytes) {\n\t\tcase 2: ctxt->dst.val = (s8)ctxt->dst.val; break;\n\t\tcase 4: ctxt->dst.val = (s16)ctxt->dst.val; break;\n\t\tcase 8: ctxt->dst.val = (s32)ctxt->dst.val; break;\n\t\t}\n\t\tbreak;\n\tcase 0xcc:\t\t/* int3 */\n\t\trc = emulate_int(ctxt, 3);\n\t\tbreak;\n\tcase 0xcd:\t\t/* int n */\n\t\trc = emulate_int(ctxt, ctxt->src.val);\n\t\tbreak;\n\tcase 0xce:\t\t/* into */\n\t\tif (ctxt->eflags & X86_EFLAGS_OF)\n\t\t\trc = emulate_int(ctxt, 4);\n\t\tbreak;\n\tcase 0xe9: /* jmp rel */\n\tcase 0xeb: /* jmp rel short */\n\t\trc = jmp_rel(ctxt, ctxt->src.val);\n\t\tctxt->dst.type = OP_NONE; /* Disable writeback. */\n\t\tbreak;\n\tcase 0xf4:              /* hlt */\n\t\tctxt->ops->halt(ctxt);\n\t\tbreak;\n\tcase 0xf5:\t/* cmc */\n\t\t/* complement carry flag from eflags reg */\n\t\tctxt->eflags ^= X86_EFLAGS_CF;\n\t\tbreak;\n\tcase 0xf8: /* clc */\n\t\tctxt->eflags &= ~X86_EFLAGS_CF;\n\t\tbreak;\n\tcase 0xf9: /* stc */\n\t\tctxt->eflags |= X86_EFLAGS_CF;\n\t\tbreak;\n\tcase 0xfc: /* cld */\n\t\tctxt->eflags &= ~X86_EFLAGS_DF;\n\t\tbreak;\n\tcase 0xfd: /* std */\n\t\tctxt->eflags |= X86_EFLAGS_DF;\n\t\tbreak;\n\tdefault:\n\t\tgoto cannot_emulate;\n\t}\n\n\tif (rc != X86EMUL_CONTINUE)\n\t\tgoto done;\n\nwriteback:\n\tif (ctxt->d & SrcWrite) {\n\t\tBUG_ON(ctxt->src.type == OP_MEM || ctxt->src.type == OP_MEM_STR);\n\t\trc = writeback(ctxt, &ctxt->src);\n\t\tif (rc != X86EMUL_CONTINUE)\n\t\t\tgoto done;\n\t}\n\tif (!(ctxt->d & NoWrite)) {\n\t\trc = writeback(ctxt, &ctxt->dst);\n\t\tif (rc != X86EMUL_CONTINUE)\n\t\t\tgoto done;\n\t}\n\n\t/*\n\t * restore dst type in case the decoding will be reused\n\t * (happens for string instruction )\n\t */\n\tctxt->dst.type = saved_dst_type;\n\n\tif ((ctxt->d & SrcMask) == SrcSI)\n\t\tstring_addr_inc(ctxt, VCPU_REGS_RSI, &ctxt->src);\n\n\tif ((ctxt->d & DstMask) == DstDI)\n\t\tstring_addr_inc(ctxt, VCPU_REGS_RDI, &ctxt->dst);\n\n\tif (ctxt->rep_prefix && (ctxt->d & String)) {\n\t\tunsigned int count;\n\t\tstruct read_cache *r = &ctxt->io_read;\n\t\tif ((ctxt->d & SrcMask) == SrcSI)\n\t\t\tcount = ctxt->src.count;\n\t\telse\n\t\t\tcount = ctxt->dst.count;\n\t\tregister_address_increment(ctxt, VCPU_REGS_RCX, -count);\n\n\t\tif (!string_insn_completed(ctxt)) {\n\t\t\t/*\n\t\t\t * Re-enter guest when pio read ahead buffer is empty\n\t\t\t * or, if it is not used, after each 1024 iteration.\n\t\t\t */\n\t\t\tif ((r->end != 0 || reg_read(ctxt, VCPU_REGS_RCX) & 0x3ff) &&\n\t\t\t    (r->end == 0 || r->end != r->pos)) {\n\t\t\t\t/*\n\t\t\t\t * Reset read cache. Usually happens before\n\t\t\t\t * decode, but since instruction is restarted\n\t\t\t\t * we have to do it here.\n\t\t\t\t */\n\t\t\t\tctxt->mem_read.end = 0;\n\t\t\t\twriteback_registers(ctxt);\n\t\t\t\treturn EMULATION_RESTART;\n\t\t\t}\n\t\t\tgoto done; /* skip rip writeback */\n\t\t}\n\t\tctxt->eflags &= ~X86_EFLAGS_RF;\n\t}\n\n\tctxt->eip = ctxt->_eip;\n\ndone:\n\tif (rc == X86EMUL_PROPAGATE_FAULT) {\n\t\tWARN_ON(ctxt->exception.vector > 0x1f);\n\t\tctxt->have_exception = true;\n\t}\n\tif (rc == X86EMUL_INTERCEPTED)\n\t\treturn EMULATION_INTERCEPTED;\n\n\tif (rc == X86EMUL_CONTINUE)\n\t\twriteback_registers(ctxt);\n\n\treturn (rc == X86EMUL_UNHANDLEABLE) ? EMULATION_FAILED : EMULATION_OK;\n\ntwobyte_insn:\n\tswitch (ctxt->b) {\n\tcase 0x09:\t\t/* wbinvd */\n\t\t(ctxt->ops->wbinvd)(ctxt);\n\t\tbreak;\n\tcase 0x08:\t\t/* invd */\n\tcase 0x0d:\t\t/* GrpP (prefetch) */\n\tcase 0x18:\t\t/* Grp16 (prefetch/nop) */\n\tcase 0x1f:\t\t/* nop */\n\t\tbreak;\n\tcase 0x20: /* mov cr, reg */\n\t\tctxt->dst.val = ops->get_cr(ctxt, ctxt->modrm_reg);\n\t\tbreak;\n\tcase 0x21: /* mov from dr to reg */\n\t\tops->get_dr(ctxt, ctxt->modrm_reg, &ctxt->dst.val);\n\t\tbreak;\n\tcase 0x40 ... 0x4f:\t/* cmov */\n\t\tif (test_cc(ctxt->b, ctxt->eflags))\n\t\t\tctxt->dst.val = ctxt->src.val;\n\t\telse if (ctxt->op_bytes != 4)\n\t\t\tctxt->dst.type = OP_NONE; /* no writeback */\n\t\tbreak;\n\tcase 0x80 ... 0x8f: /* jnz rel, etc*/\n\t\tif (test_cc(ctxt->b, ctxt->eflags))\n\t\t\trc = jmp_rel(ctxt, ctxt->src.val);\n\t\tbreak;\n\tcase 0x90 ... 0x9f:     /* setcc r/m8 */\n\t\tctxt->dst.val = test_cc(ctxt->b, ctxt->eflags);\n\t\tbreak;\n\tcase 0xb6 ... 0xb7:\t/* movzx */\n\t\tctxt->dst.bytes = ctxt->op_bytes;\n\t\tctxt->dst.val = (ctxt->src.bytes == 1) ? (u8) ctxt->src.val\n\t\t\t\t\t\t       : (u16) ctxt->src.val;\n\t\tbreak;\n\tcase 0xbe ... 0xbf:\t/* movsx */\n\t\tctxt->dst.bytes = ctxt->op_bytes;\n\t\tctxt->dst.val = (ctxt->src.bytes == 1) ? (s8) ctxt->src.val :\n\t\t\t\t\t\t\t(s16) ctxt->src.val;\n\t\tbreak;\n\tdefault:\n\t\tgoto cannot_emulate;\n\t}\n\nthreebyte_insn:\n\n\tif (rc != X86EMUL_CONTINUE)\n\t\tgoto done;\n\n\tgoto writeback;\n\ncannot_emulate:\n\treturn EMULATION_FAILED;\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define PrivUD      ((u64)1 << 51)  /* #UD instead of #GP on CPL > 0 */",
      "#define CheckPerm   ((u64)1 << 49)  /* Has valid check_perm field */",
      "#define Intercept   ((u64)1 << 48)  /* Has valid intercept field */",
      "#define SrcWrite    ((u64)1 << 46)  /* Write back src operand */",
      "#define NoWrite     ((u64)1 << 45)  /* No writeback */",
      "#define Fastop      ((u64)1 << 44)  /* Use opcode::u.fastop */",
      "#define Mmx         ((u64)1 << 40)  /* MMX Vector instruction */",
      "#define No64\t    (1<<28)",
      "#define Priv        (1<<27) /* instruction generates #GP if current CPL != 0 */",
      "#define Lock        (1<<26) /* lock prefix is allowed for the instruction */",
      "#define Undefined   (1<<25) /* No Such Instruction */",
      "#define NoAccess    (1<<23) /* Don't access memory (lea/invlpg/verr etc) */",
      "#define Prot        (1<<21) /* instruction generates #UD if not in prot-mode */",
      "#define Mov         (1<<20)",
      "#define Sse         (1<<18)     /* SSE Vector instruction */",
      "#define String      (1<<13)     /* String instruction (rep capable) */",
      "#define SrcMask     (OpMask << SrcShift)",
      "#define SrcMemFAddr (OpMemFAddr << SrcShift)",
      "#define SrcSI       (OpSI << SrcShift)",
      "#define DstMask     (OpMask << DstShift)",
      "#define DstDI       (OpDI << DstShift)",
      "#define ImplicitOps (OpImplicit << DstShift)"
    ],
    "globals_used": [
      "static int fastop(struct x86_emulate_ctxt *ctxt, void (*fop)(struct fastop *));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_cc",
          "args": [
            "ctxt->b",
            "ctxt->eflags"
          ],
          "line": 5461
        },
        "resolved": true,
        "details": {
          "function_name": "test_cc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "972-981",
          "snippet": "static __always_inline u8 test_cc(unsigned int condition, unsigned long flags)\n{\n\tu8 rc;\n\tvoid (*fop)(void) = (void *)em_setcc + 4 * (condition & 0xf);\n\n\tflags = (flags & EFLAGS_MASK) | X86_EFLAGS_IF;\n\tasm(\"push %[flags]; popf; call *%[fastop]\"\n\t    : \"=a\"(rc) : [fastop]\"r\"(fop), [flags]\"r\"(flags));\n\treturn rc;\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define EFLAGS_MASK (X86_EFLAGS_OF|X86_EFLAGS_SF|X86_EFLAGS_ZF|X86_EFLAGS_AF|\\\n\t\t     X86_EFLAGS_PF|X86_EFLAGS_CF)"
          ],
          "globals_used": [
            "static int fastop(struct x86_emulate_ctxt *ctxt, void (*fop)(struct fastop *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\n#define EFLAGS_MASK (X86_EFLAGS_OF|X86_EFLAGS_SF|X86_EFLAGS_ZF|X86_EFLAGS_AF|\\\n\t\t     X86_EFLAGS_PF|X86_EFLAGS_CF)\n\nstatic int fastop(struct x86_emulate_ctxt *ctxt, void (*fop)(struct fastop *));\n\nstatic __always_inline u8 test_cc(unsigned int condition, unsigned long flags)\n{\n\tu8 rc;\n\tvoid (*fop)(void) = (void *)em_setcc + 4 * (condition & 0xf);\n\n\tflags = (flags & EFLAGS_MASK) | X86_EFLAGS_IF;\n\tasm(\"push %[flags]; popf; call *%[fastop]\"\n\t    : \"=a\"(rc) : [fastop]\"r\"(fop), [flags]\"r\"(flags));\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jmp_rel",
          "args": [
            "ctxt",
            "ctxt->src.val"
          ],
          "line": 5458
        },
        "resolved": true,
        "details": {
          "function_name": "jmp_rel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "776-779",
          "snippet": "static inline int jmp_rel(struct x86_emulate_ctxt *ctxt, int rel)\n{\n\treturn assign_eip_near(ctxt, ctxt->_eip + rel);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline int jmp_rel(struct x86_emulate_ctxt *ctxt, int rel)\n{\n\treturn assign_eip_near(ctxt, ctxt->_eip + rel);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ops->get_dr",
          "args": [
            "ctxt",
            "ctxt->modrm_reg",
            "&ctxt->dst.val"
          ],
          "line": 5448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ops->get_cr",
          "args": [
            "ctxt",
            "ctxt->modrm_reg"
          ],
          "line": 5445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "ctxt"
          ],
          "line": 5437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "writeback_registers",
          "args": [
            "ctxt"
          ],
          "line": 5430
        },
        "resolved": true,
        "details": {
          "function_name": "writeback_registers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "283-289",
          "snippet": "static void writeback_registers(struct x86_emulate_ctxt *ctxt)\n{\n\tunsigned reg;\n\n\tfor_each_set_bit(reg, (ulong *)&ctxt->regs_dirty, 16)\n\t\tctxt->ops->write_gpr(ctxt, reg, ctxt->_regs[reg]);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic void writeback_registers(struct x86_emulate_ctxt *ctxt)\n{\n\tunsigned reg;\n\n\tfor_each_set_bit(reg, (ulong *)&ctxt->regs_dirty, 16)\n\t\tctxt->ops->write_gpr(ctxt, reg, ctxt->_regs[reg]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "ctxt->exception.vector > 0x1f"
          ],
          "line": 5423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reg_read",
          "args": [
            "ctxt",
            "VCPU_REGS_RCX"
          ],
          "line": 5403
        },
        "resolved": true,
        "details": {
          "function_name": "reg_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "261-268",
          "snippet": "static ulong reg_read(struct x86_emulate_ctxt *ctxt, unsigned nr)\n{\n\tif (!(ctxt->regs_valid & (1 << nr))) {\n\t\tctxt->regs_valid |= 1 << nr;\n\t\tctxt->_regs[nr] = ctxt->ops->read_gpr(ctxt, nr);\n\t}\n\treturn ctxt->_regs[nr];\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic ulong reg_read(struct x86_emulate_ctxt *ctxt, unsigned nr)\n{\n\tif (!(ctxt->regs_valid & (1 << nr))) {\n\t\tctxt->regs_valid |= 1 << nr;\n\t\tctxt->_regs[nr] = ctxt->ops->read_gpr(ctxt, nr);\n\t}\n\treturn ctxt->_regs[nr];\n}"
        }
      },
      {
        "call_info": {
          "callee": "string_insn_completed",
          "args": [
            "ctxt"
          ],
          "line": 5398
        },
        "resolved": true,
        "details": {
          "function_name": "string_insn_completed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "5062-5080",
          "snippet": "static bool string_insn_completed(struct x86_emulate_ctxt *ctxt)\n{\n\t/* The second termination condition only applies for REPE\n\t * and REPNE. Test if the repeat string operation prefix is\n\t * REPE/REPZ or REPNE/REPNZ and if it's the case it tests the\n\t * corresponding termination condition according to:\n\t * \t- if REPE/REPZ and ZF = 0 then done\n\t * \t- if REPNE/REPNZ and ZF = 1 then done\n\t */\n\tif (((ctxt->b == 0xa6) || (ctxt->b == 0xa7) ||\n\t     (ctxt->b == 0xae) || (ctxt->b == 0xaf))\n\t    && (((ctxt->rep_prefix == REPE_PREFIX) &&\n\t\t ((ctxt->eflags & X86_EFLAGS_ZF) == 0))\n\t\t|| ((ctxt->rep_prefix == REPNE_PREFIX) &&\n\t\t    ((ctxt->eflags & X86_EFLAGS_ZF) == X86_EFLAGS_ZF))))\n\t\treturn true;\n\n\treturn false;\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic bool string_insn_completed(struct x86_emulate_ctxt *ctxt)\n{\n\t/* The second termination condition only applies for REPE\n\t * and REPNE. Test if the repeat string operation prefix is\n\t * REPE/REPZ or REPNE/REPNZ and if it's the case it tests the\n\t * corresponding termination condition according to:\n\t * \t- if REPE/REPZ and ZF = 0 then done\n\t * \t- if REPNE/REPNZ and ZF = 1 then done\n\t */\n\tif (((ctxt->b == 0xa6) || (ctxt->b == 0xa7) ||\n\t     (ctxt->b == 0xae) || (ctxt->b == 0xaf))\n\t    && (((ctxt->rep_prefix == REPE_PREFIX) &&\n\t\t ((ctxt->eflags & X86_EFLAGS_ZF) == 0))\n\t\t|| ((ctxt->rep_prefix == REPNE_PREFIX) &&\n\t\t    ((ctxt->eflags & X86_EFLAGS_ZF) == X86_EFLAGS_ZF))))\n\t\treturn true;\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "register_address_increment",
          "args": [
            "ctxt",
            "VCPU_REGS_RCX",
            "-count"
          ],
          "line": 5396
        },
        "resolved": true,
        "details": {
          "function_name": "register_address_increment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "537-543",
          "snippet": "static inline void\nregister_address_increment(struct x86_emulate_ctxt *ctxt, int reg, int inc)\n{\n\tulong *preg = reg_rmw(ctxt, reg);\n\n\tassign_register(preg, *preg + inc, ctxt->ad_bytes);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline void\nregister_address_increment(struct x86_emulate_ctxt *ctxt, int reg, int inc)\n{\n\tulong *preg = reg_rmw(ctxt, reg);\n\n\tassign_register(preg, *preg + inc, ctxt->ad_bytes);\n}"
        }
      },
      {
        "call_info": {
          "callee": "string_addr_inc",
          "args": [
            "ctxt",
            "VCPU_REGS_RDI",
            "&ctxt->dst"
          ],
          "line": 5387
        },
        "resolved": true,
        "details": {
          "function_name": "string_addr_inc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "3275-3282",
          "snippet": "static void string_addr_inc(struct x86_emulate_ctxt *ctxt, int reg,\n\t\tstruct operand *op)\n{\n\tint df = (ctxt->eflags & X86_EFLAGS_DF) ? -op->count : op->count;\n\n\tregister_address_increment(ctxt, reg, df * op->bytes);\n\top->addr.mem.ea = register_address(ctxt, reg);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic void string_addr_inc(struct x86_emulate_ctxt *ctxt, int reg,\n\t\tstruct operand *op)\n{\n\tint df = (ctxt->eflags & X86_EFLAGS_DF) ? -op->count : op->count;\n\n\tregister_address_increment(ctxt, reg, df * op->bytes);\n\top->addr.mem.ea = register_address(ctxt, reg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "writeback",
          "args": [
            "ctxt",
            "&ctxt->dst"
          ],
          "line": 5372
        },
        "resolved": true,
        "details": {
          "function_name": "writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "1723-1761",
          "snippet": "static int writeback(struct x86_emulate_ctxt *ctxt, struct operand *op)\n{\n\tswitch (op->type) {\n\tcase OP_REG:\n\t\twrite_register_operand(op);\n\t\tbreak;\n\tcase OP_MEM:\n\t\tif (ctxt->lock_prefix)\n\t\t\treturn segmented_cmpxchg(ctxt,\n\t\t\t\t\t\t op->addr.mem,\n\t\t\t\t\t\t &op->orig_val,\n\t\t\t\t\t\t &op->val,\n\t\t\t\t\t\t op->bytes);\n\t\telse\n\t\t\treturn segmented_write(ctxt,\n\t\t\t\t\t       op->addr.mem,\n\t\t\t\t\t       &op->val,\n\t\t\t\t\t       op->bytes);\n\t\tbreak;\n\tcase OP_MEM_STR:\n\t\treturn segmented_write(ctxt,\n\t\t\t\t       op->addr.mem,\n\t\t\t\t       op->data,\n\t\t\t\t       op->bytes * op->count);\n\t\tbreak;\n\tcase OP_XMM:\n\t\twrite_sse_reg(ctxt, &op->vec_val, op->addr.xmm);\n\t\tbreak;\n\tcase OP_MM:\n\t\twrite_mmx_reg(ctxt, &op->mm_val, op->addr.mm);\n\t\tbreak;\n\tcase OP_NONE:\n\t\t/* no writeback */\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn X86EMUL_CONTINUE;\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int writeback(struct x86_emulate_ctxt *ctxt, struct operand *op)\n{\n\tswitch (op->type) {\n\tcase OP_REG:\n\t\twrite_register_operand(op);\n\t\tbreak;\n\tcase OP_MEM:\n\t\tif (ctxt->lock_prefix)\n\t\t\treturn segmented_cmpxchg(ctxt,\n\t\t\t\t\t\t op->addr.mem,\n\t\t\t\t\t\t &op->orig_val,\n\t\t\t\t\t\t &op->val,\n\t\t\t\t\t\t op->bytes);\n\t\telse\n\t\t\treturn segmented_write(ctxt,\n\t\t\t\t\t       op->addr.mem,\n\t\t\t\t\t       &op->val,\n\t\t\t\t\t       op->bytes);\n\t\tbreak;\n\tcase OP_MEM_STR:\n\t\treturn segmented_write(ctxt,\n\t\t\t\t       op->addr.mem,\n\t\t\t\t       op->data,\n\t\t\t\t       op->bytes * op->count);\n\t\tbreak;\n\tcase OP_XMM:\n\t\twrite_sse_reg(ctxt, &op->vec_val, op->addr.xmm);\n\t\tbreak;\n\tcase OP_MM:\n\t\twrite_mmx_reg(ctxt, &op->mm_val, op->addr.mm);\n\t\tbreak;\n\tcase OP_NONE:\n\t\t/* no writeback */\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn X86EMUL_CONTINUE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ctxt->src.type == OP_MEM || ctxt->src.type == OP_MEM_STR"
          ],
          "line": 5366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ctxt->ops->halt",
          "args": [
            "ctxt"
          ],
          "line": 5339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "emulate_int",
          "args": [
            "ctxt",
            "4"
          ],
          "line": 5331
        },
        "resolved": true,
        "details": {
          "function_name": "emulate_int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "2020-2033",
          "snippet": "static int emulate_int(struct x86_emulate_ctxt *ctxt, int irq)\n{\n\tswitch(ctxt->mode) {\n\tcase X86EMUL_MODE_REAL:\n\t\treturn __emulate_int_real(ctxt, irq);\n\tcase X86EMUL_MODE_VM86:\n\tcase X86EMUL_MODE_PROT16:\n\tcase X86EMUL_MODE_PROT32:\n\tcase X86EMUL_MODE_PROT64:\n\tdefault:\n\t\t/* Protected mode interrupts unimplemented yet */\n\t\treturn X86EMUL_UNHANDLEABLE;\n\t}\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int emulate_int(struct x86_emulate_ctxt *ctxt, int irq)\n{\n\tswitch(ctxt->mode) {\n\tcase X86EMUL_MODE_REAL:\n\t\treturn __emulate_int_real(ctxt, irq);\n\tcase X86EMUL_MODE_VM86:\n\tcase X86EMUL_MODE_PROT16:\n\tcase X86EMUL_MODE_PROT32:\n\tcase X86EMUL_MODE_PROT64:\n\tdefault:\n\t\t/* Protected mode interrupts unimplemented yet */\n\t\treturn X86EMUL_UNHANDLEABLE;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "em_xchg",
          "args": [
            "ctxt"
          ],
          "line": 5314
        },
        "resolved": true,
        "details": {
          "function_name": "em_xchg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "3433-3443",
          "snippet": "static int em_xchg(struct x86_emulate_ctxt *ctxt)\n{\n\t/* Write back the register source. */\n\tctxt->src.val = ctxt->dst.val;\n\twrite_register_operand(&ctxt->src);\n\n\t/* Write back the memory destination with implicit LOCK prefix. */\n\tctxt->dst.val = ctxt->src.orig_val;\n\tctxt->lock_prefix = 1;\n\treturn X86EMUL_CONTINUE;\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int em_xchg(struct x86_emulate_ctxt *ctxt)\n{\n\t/* Write back the register source. */\n\tctxt->src.val = ctxt->dst.val;\n\twrite_register_operand(&ctxt->src);\n\n\t/* Write back the memory destination with implicit LOCK prefix. */\n\tctxt->dst.val = ctxt->src.orig_val;\n\tctxt->lock_prefix = 1;\n\treturn X86EMUL_CONTINUE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reg_rmw",
          "args": [
            "ctxt",
            "VCPU_REGS_RAX"
          ],
          "line": 5311
        },
        "resolved": true,
        "details": {
          "function_name": "reg_rmw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "277-281",
          "snippet": "static ulong *reg_rmw(struct x86_emulate_ctxt *ctxt, unsigned nr)\n{\n\treg_read(ctxt, nr);\n\treturn reg_write(ctxt, nr);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic ulong *reg_rmw(struct x86_emulate_ctxt *ctxt, unsigned nr)\n{\n\treg_read(ctxt, nr);\n\treturn reg_write(ctxt, nr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ctxt->execute",
          "args": [
            "ctxt"
          ],
          "line": 5291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fastop",
          "args": [
            "ctxt",
            "fop"
          ],
          "line": 5286
        },
        "resolved": true,
        "details": {
          "function_name": "fastop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "5111-5124",
          "snippet": "static int fastop(struct x86_emulate_ctxt *ctxt, void (*fop)(struct fastop *))\n{\n\tulong flags = (ctxt->eflags & EFLAGS_MASK) | X86_EFLAGS_IF;\n\tif (!(ctxt->d & ByteOp))\n\t\tfop += __ffs(ctxt->dst.bytes) * FASTOP_SIZE;\n\tasm(\"push %[flags]; popf; call *%[fastop]; pushf; pop %[flags]\\n\"\n\t    : \"+a\"(ctxt->dst.val), \"+d\"(ctxt->src.val), [flags]\"+D\"(flags),\n\t      [fastop]\"+S\"(fop)\n\t    : \"c\"(ctxt->src2.val));\n\tctxt->eflags = (ctxt->eflags & ~EFLAGS_MASK) | (flags & EFLAGS_MASK);\n\tif (!fop) /* exception is returned in fop variable */\n\t\treturn emulate_de(ctxt);\n\treturn X86EMUL_CONTINUE;\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define EFLAGS_MASK (X86_EFLAGS_OF|X86_EFLAGS_SF|X86_EFLAGS_ZF|X86_EFLAGS_AF|\\\n\t\t     X86_EFLAGS_PF|X86_EFLAGS_CF)",
            "#define FASTOP_SIZE 8",
            "#define ByteOp      (1<<0)\t/* 8-bit operands. */"
          ],
          "globals_used": [
            "static int fastop(struct x86_emulate_ctxt *ctxt, void (*fop)(struct fastop *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\n#define EFLAGS_MASK (X86_EFLAGS_OF|X86_EFLAGS_SF|X86_EFLAGS_ZF|X86_EFLAGS_AF|\\\n\t\t     X86_EFLAGS_PF|X86_EFLAGS_CF)\n#define FASTOP_SIZE 8\n#define ByteOp      (1<<0)\t/* 8-bit operands. */\n\nstatic int fastop(struct x86_emulate_ctxt *ctxt, void (*fop)(struct fastop *));\n\nstatic int fastop(struct x86_emulate_ctxt *ctxt, void (*fop)(struct fastop *))\n{\n\tulong flags = (ctxt->eflags & EFLAGS_MASK) | X86_EFLAGS_IF;\n\tif (!(ctxt->d & ByteOp))\n\t\tfop += __ffs(ctxt->dst.bytes) * FASTOP_SIZE;\n\tasm(\"push %[flags]; popf; call *%[fastop]; pushf; pop %[flags]\\n\"\n\t    : \"+a\"(ctxt->dst.val), \"+d\"(ctxt->src.val), [flags]\"+D\"(flags),\n\t      [fastop]\"+S\"(fop)\n\t    : \"c\"(ctxt->src2.val));\n\tctxt->eflags = (ctxt->eflags & ~EFLAGS_MASK) | (flags & EFLAGS_MASK);\n\tif (!fop) /* exception is returned in fop variable */\n\t\treturn emulate_de(ctxt);\n\treturn X86EMUL_CONTINUE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "emulator_check_intercept",
          "args": [
            "ctxt",
            "ctxt->intercept",
            "X86_ICPT_POST_MEMACCESS"
          ],
          "line": 5272
        },
        "resolved": true,
        "details": {
          "function_name": "emulator_check_intercept",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "450-469",
          "snippet": "static int emulator_check_intercept(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t    enum x86_intercept intercept,\n\t\t\t\t    enum x86_intercept_stage stage)\n{\n\tstruct x86_instruction_info info = {\n\t\t.intercept  = intercept,\n\t\t.rep_prefix = ctxt->rep_prefix,\n\t\t.modrm_mod  = ctxt->modrm_mod,\n\t\t.modrm_reg  = ctxt->modrm_reg,\n\t\t.modrm_rm   = ctxt->modrm_rm,\n\t\t.src_val    = ctxt->src.val64,\n\t\t.dst_val    = ctxt->dst.val64,\n\t\t.src_bytes  = ctxt->src.bytes,\n\t\t.dst_bytes  = ctxt->dst.bytes,\n\t\t.ad_bytes   = ctxt->ad_bytes,\n\t\t.next_rip   = ctxt->eip,\n\t};\n\n\treturn ctxt->ops->intercept(ctxt, &info, stage);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int emulator_check_intercept(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t    enum x86_intercept intercept,\n\t\t\t\t    enum x86_intercept_stage stage)\n{\n\tstruct x86_instruction_info info = {\n\t\t.intercept  = intercept,\n\t\t.rep_prefix = ctxt->rep_prefix,\n\t\t.modrm_mod  = ctxt->modrm_mod,\n\t\t.modrm_reg  = ctxt->modrm_reg,\n\t\t.modrm_rm   = ctxt->modrm_rm,\n\t\t.src_val    = ctxt->src.val64,\n\t\t.dst_val    = ctxt->dst.val64,\n\t\t.src_bytes  = ctxt->src.bytes,\n\t\t.dst_bytes  = ctxt->dst.bytes,\n\t\t.ad_bytes   = ctxt->ad_bytes,\n\t\t.next_rip   = ctxt->eip,\n\t};\n\n\treturn ctxt->ops->intercept(ctxt, &info, stage);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ctxt->emul_flags & X86EMUL_GUEST_MASK"
          ],
          "line": 5271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "segmented_read",
          "args": [
            "ctxt",
            "ctxt->dst.addr.mem",
            "&ctxt->dst.val",
            "ctxt->dst.bytes"
          ],
          "line": 5256
        },
        "resolved": true,
        "details": {
          "function_name": "segmented_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "1374-1386",
          "snippet": "static int segmented_read(struct x86_emulate_ctxt *ctxt,\n\t\t\t  struct segmented_address addr,\n\t\t\t  void *data,\n\t\t\t  unsigned size)\n{\n\tint rc;\n\tulong linear;\n\n\trc = linearize(ctxt, addr, size, false, &linear);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\treturn read_emulated(ctxt, linear, data, size);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int segmented_read(struct x86_emulate_ctxt *ctxt,\n\t\t\t  struct segmented_address addr,\n\t\t\t  void *data,\n\t\t\t  unsigned size)\n{\n\tint rc;\n\tulong linear;\n\n\trc = linearize(ctxt, addr, size, false, &linear);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\treturn read_emulated(ctxt, linear, data, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "string_registers_quirk",
          "args": [
            "ctxt"
          ],
          "line": 5227
        },
        "resolved": true,
        "details": {
          "function_name": "string_registers_quirk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "2863-2885",
          "snippet": "static void string_registers_quirk(struct x86_emulate_ctxt *ctxt)\n{\n\t/*\n\t * Intel CPUs mask the counter and pointers in quite strange\n\t * manner when ECX is zero due to REP-string optimizations.\n\t */\n#ifdef CONFIG_X86_64\n\tif (ctxt->ad_bytes != 4 || !vendor_intel(ctxt))\n\t\treturn;\n\n\t*reg_write(ctxt, VCPU_REGS_RCX) = 0;\n\n\tswitch (ctxt->b) {\n\tcase 0xa4:\t/* movsb */\n\tcase 0xa5:\t/* movsd/w */\n\t\t*reg_rmw(ctxt, VCPU_REGS_RSI) &= (u32)-1;\n\t\t/* fall through */\n\tcase 0xaa:\t/* stosb */\n\tcase 0xab:\t/* stosd/w */\n\t\t*reg_rmw(ctxt, VCPU_REGS_RDI) &= (u32)-1;\n\t}\n#endif\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic void string_registers_quirk(struct x86_emulate_ctxt *ctxt)\n{\n\t/*\n\t * Intel CPUs mask the counter and pointers in quite strange\n\t * manner when ECX is zero due to REP-string optimizations.\n\t */\n#ifdef CONFIG_X86_64\n\tif (ctxt->ad_bytes != 4 || !vendor_intel(ctxt))\n\t\treturn;\n\n\t*reg_write(ctxt, VCPU_REGS_RCX) = 0;\n\n\tswitch (ctxt->b) {\n\tcase 0xa4:\t/* movsb */\n\tcase 0xa5:\t/* movsd/w */\n\t\t*reg_rmw(ctxt, VCPU_REGS_RSI) &= (u32)-1;\n\t\t/* fall through */\n\tcase 0xaa:\t/* stosb */\n\tcase 0xab:\t/* stosd/w */\n\t\t*reg_rmw(ctxt, VCPU_REGS_RDI) &= (u32)-1;\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "address_mask",
          "args": [
            "ctxt",
            "reg_read(ctxt, VCPU_REGS_RCX)"
          ],
          "line": 5226
        },
        "resolved": true,
        "details": {
          "function_name": "address_mask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "517-524",
          "snippet": "static inline unsigned long\naddress_mask(struct x86_emulate_ctxt *ctxt, unsigned long reg)\n{\n\tif (ctxt->ad_bytes == sizeof(unsigned long))\n\t\treturn reg;\n\telse\n\t\treturn reg & ad_mask(ctxt);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline unsigned long\naddress_mask(struct x86_emulate_ctxt *ctxt, unsigned long reg)\n{\n\tif (ctxt->ad_bytes == sizeof(unsigned long))\n\t\treturn reg;\n\telse\n\t\treturn reg & ad_mask(ctxt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ctxt->emul_flags & X86EMUL_GUEST_MASK"
          ],
          "line": 5217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ctxt->check_perm",
          "args": [
            "ctxt"
          ],
          "line": 5212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "emulate_gp",
          "args": [
            "ctxt",
            "0"
          ],
          "line": 5206
        },
        "resolved": true,
        "details": {
          "function_name": "emulate_gp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "580-583",
          "snippet": "static int emulate_gp(struct x86_emulate_ctxt *ctxt, int err)\n{\n\treturn emulate_exception(ctxt, GP_VECTOR, err, true);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int emulate_gp(struct x86_emulate_ctxt *ctxt, int err)\n{\n\treturn emulate_exception(ctxt, GP_VECTOR, err, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "emulate_ud",
          "args": [
            "ctxt"
          ],
          "line": 5204
        },
        "resolved": true,
        "details": {
          "function_name": "emulate_ud",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "590-593",
          "snippet": "static int emulate_ud(struct x86_emulate_ctxt *ctxt)\n{\n\treturn emulate_exception(ctxt, UD_VECTOR, 0, false);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int emulate_ud(struct x86_emulate_ctxt *ctxt)\n{\n\treturn emulate_exception(ctxt, UD_VECTOR, 0, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ops->cpl",
          "args": [
            "ctxt"
          ],
          "line": 5202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ctxt->emul_flags & X86EMUL_GUEST_MASK"
          ],
          "line": 5188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fetch_possible_mmx_operand",
          "args": [
            "ctxt",
            "&ctxt->dst"
          ],
          "line": 5185
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_possible_mmx_operand",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "5104-5109",
          "snippet": "static void fetch_possible_mmx_operand(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t       struct operand *op)\n{\n\tif (op->type == OP_MM)\n\t\tread_mmx_reg(ctxt, &op->mm_val, op->addr.mm);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic void fetch_possible_mmx_operand(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t       struct operand *op)\n{\n\tif (op->type == OP_MM)\n\t\tread_mmx_reg(ctxt, &op->mm_val, op->addr.mm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_pending_x87_faults",
          "args": [
            "ctxt"
          ],
          "line": 5175
        },
        "resolved": true,
        "details": {
          "function_name": "flush_pending_x87_faults",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "5082-5102",
          "snippet": "static int flush_pending_x87_faults(struct x86_emulate_ctxt *ctxt)\n{\n\tbool fault = false;\n\n\tctxt->ops->get_fpu(ctxt);\n\tasm volatile(\"1: fwait \\n\\t\"\n\t\t     \"2: \\n\\t\"\n\t\t     \".pushsection .fixup,\\\"ax\\\" \\n\\t\"\n\t\t     \"3: \\n\\t\"\n\t\t     \"movb $1, %[fault] \\n\\t\"\n\t\t     \"jmp 2b \\n\\t\"\n\t\t     \".popsection \\n\\t\"\n\t\t     _ASM_EXTABLE(1b, 3b)\n\t\t     : [fault]\"+qm\"(fault));\n\tctxt->ops->put_fpu(ctxt);\n\n\tif (unlikely(fault))\n\t\treturn emulate_exception(ctxt, MF_VECTOR, 0, false);\n\n\treturn X86EMUL_CONTINUE;\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int flush_pending_x87_faults(struct x86_emulate_ctxt *ctxt)\n{\n\tbool fault = false;\n\n\tctxt->ops->get_fpu(ctxt);\n\tasm volatile(\"1: fwait \\n\\t\"\n\t\t     \"2: \\n\\t\"\n\t\t     \".pushsection .fixup,\\\"ax\\\" \\n\\t\"\n\t\t     \"3: \\n\\t\"\n\t\t     \"movb $1, %[fault] \\n\\t\"\n\t\t     \"jmp 2b \\n\\t\"\n\t\t     \".popsection \\n\\t\"\n\t\t     _ASM_EXTABLE(1b, 3b)\n\t\t     : [fault]\"+qm\"(fault));\n\tctxt->ops->put_fpu(ctxt);\n\n\tif (unlikely(fault))\n\t\treturn emulate_exception(ctxt, MF_VECTOR, 0, false);\n\n\treturn X86EMUL_CONTINUE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "emulate_nm",
          "args": [
            "ctxt"
          ],
          "line": 5170
        },
        "resolved": true,
        "details": {
          "function_name": "emulate_nm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "605-608",
          "snippet": "static int emulate_nm(struct x86_emulate_ctxt *ctxt)\n{\n\treturn emulate_exception(ctxt, NM_VECTOR, 0, false);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int emulate_nm(struct x86_emulate_ctxt *ctxt)\n{\n\treturn emulate_exception(ctxt, NM_VECTOR, 0, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ops->get_cr",
          "args": [
            "ctxt",
            "0"
          ],
          "line": 5169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ops->get_cr",
          "args": [
            "ctxt",
            "4"
          ],
          "line": 5164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ops->get_cr",
          "args": [
            "ctxt",
            "0"
          ],
          "line": 5163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ctxt->d &\n\t\t     (No64|Undefined|Sse|Mmx|Intercept|CheckPerm|Priv|Prot|String)"
          ],
          "line": 5155
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\n#define PrivUD      ((u64)1 << 51)  /* #UD instead of #GP on CPL > 0 */\n#define CheckPerm   ((u64)1 << 49)  /* Has valid check_perm field */\n#define Intercept   ((u64)1 << 48)  /* Has valid intercept field */\n#define SrcWrite    ((u64)1 << 46)  /* Write back src operand */\n#define NoWrite     ((u64)1 << 45)  /* No writeback */\n#define Fastop      ((u64)1 << 44)  /* Use opcode::u.fastop */\n#define Mmx         ((u64)1 << 40)  /* MMX Vector instruction */\n#define No64\t    (1<<28)\n#define Priv        (1<<27) /* instruction generates #GP if current CPL != 0 */\n#define Lock        (1<<26) /* lock prefix is allowed for the instruction */\n#define Undefined   (1<<25) /* No Such Instruction */\n#define NoAccess    (1<<23) /* Don't access memory (lea/invlpg/verr etc) */\n#define Prot        (1<<21) /* instruction generates #UD if not in prot-mode */\n#define Mov         (1<<20)\n#define Sse         (1<<18)     /* SSE Vector instruction */\n#define String      (1<<13)     /* String instruction (rep capable) */\n#define SrcMask     (OpMask << SrcShift)\n#define SrcMemFAddr (OpMemFAddr << SrcShift)\n#define SrcSI       (OpSI << SrcShift)\n#define DstMask     (OpMask << DstShift)\n#define DstDI       (OpDI << DstShift)\n#define ImplicitOps (OpImplicit << DstShift)\n\nstatic int fastop(struct x86_emulate_ctxt *ctxt, void (*fop)(struct fastop *));\n\nint x86_emulate_insn(struct x86_emulate_ctxt *ctxt)\n{\n\tconst struct x86_emulate_ops *ops = ctxt->ops;\n\tint rc = X86EMUL_CONTINUE;\n\tint saved_dst_type = ctxt->dst.type;\n\n\tctxt->mem_read.pos = 0;\n\n\t/* LOCK prefix is allowed only with some instructions */\n\tif (ctxt->lock_prefix && (!(ctxt->d & Lock) || ctxt->dst.type != OP_MEM)) {\n\t\trc = emulate_ud(ctxt);\n\t\tgoto done;\n\t}\n\n\tif ((ctxt->d & SrcMask) == SrcMemFAddr && ctxt->src.type != OP_MEM) {\n\t\trc = emulate_ud(ctxt);\n\t\tgoto done;\n\t}\n\n\tif (unlikely(ctxt->d &\n\t\t     (No64|Undefined|Sse|Mmx|Intercept|CheckPerm|Priv|Prot|String))) {\n\t\tif ((ctxt->mode == X86EMUL_MODE_PROT64 && (ctxt->d & No64)) ||\n\t\t\t\t(ctxt->d & Undefined)) {\n\t\t\trc = emulate_ud(ctxt);\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (((ctxt->d & (Sse|Mmx)) && ((ops->get_cr(ctxt, 0) & X86_CR0_EM)))\n\t\t    || ((ctxt->d & Sse) && !(ops->get_cr(ctxt, 4) & X86_CR4_OSFXSR))) {\n\t\t\trc = emulate_ud(ctxt);\n\t\t\tgoto done;\n\t\t}\n\n\t\tif ((ctxt->d & (Sse|Mmx)) && (ops->get_cr(ctxt, 0) & X86_CR0_TS)) {\n\t\t\trc = emulate_nm(ctxt);\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (ctxt->d & Mmx) {\n\t\t\trc = flush_pending_x87_faults(ctxt);\n\t\t\tif (rc != X86EMUL_CONTINUE)\n\t\t\t\tgoto done;\n\t\t\t/*\n\t\t\t * Now that we know the fpu is exception safe, we can fetch\n\t\t\t * operands from it.\n\t\t\t */\n\t\t\tfetch_possible_mmx_operand(ctxt, &ctxt->src);\n\t\t\tfetch_possible_mmx_operand(ctxt, &ctxt->src2);\n\t\t\tif (!(ctxt->d & Mov))\n\t\t\t\tfetch_possible_mmx_operand(ctxt, &ctxt->dst);\n\t\t}\n\n\t\tif (unlikely(ctxt->emul_flags & X86EMUL_GUEST_MASK) && ctxt->intercept) {\n\t\t\trc = emulator_check_intercept(ctxt, ctxt->intercept,\n\t\t\t\t\t\t      X86_ICPT_PRE_EXCEPT);\n\t\t\tif (rc != X86EMUL_CONTINUE)\n\t\t\t\tgoto done;\n\t\t}\n\n\t\t/* Instruction can only be executed in protected mode */\n\t\tif ((ctxt->d & Prot) && ctxt->mode < X86EMUL_MODE_PROT16) {\n\t\t\trc = emulate_ud(ctxt);\n\t\t\tgoto done;\n\t\t}\n\n\t\t/* Privileged instruction can be executed only in CPL=0 */\n\t\tif ((ctxt->d & Priv) && ops->cpl(ctxt)) {\n\t\t\tif (ctxt->d & PrivUD)\n\t\t\t\trc = emulate_ud(ctxt);\n\t\t\telse\n\t\t\t\trc = emulate_gp(ctxt, 0);\n\t\t\tgoto done;\n\t\t}\n\n\t\t/* Do instruction specific permission checks */\n\t\tif (ctxt->d & CheckPerm) {\n\t\t\trc = ctxt->check_perm(ctxt);\n\t\t\tif (rc != X86EMUL_CONTINUE)\n\t\t\t\tgoto done;\n\t\t}\n\n\t\tif (unlikely(ctxt->emul_flags & X86EMUL_GUEST_MASK) && (ctxt->d & Intercept)) {\n\t\t\trc = emulator_check_intercept(ctxt, ctxt->intercept,\n\t\t\t\t\t\t      X86_ICPT_POST_EXCEPT);\n\t\t\tif (rc != X86EMUL_CONTINUE)\n\t\t\t\tgoto done;\n\t\t}\n\n\t\tif (ctxt->rep_prefix && (ctxt->d & String)) {\n\t\t\t/* All REP prefixes have the same first termination condition */\n\t\t\tif (address_mask(ctxt, reg_read(ctxt, VCPU_REGS_RCX)) == 0) {\n\t\t\t\tstring_registers_quirk(ctxt);\n\t\t\t\tctxt->eip = ctxt->_eip;\n\t\t\t\tctxt->eflags &= ~X86_EFLAGS_RF;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t}\n\n\tif ((ctxt->src.type == OP_MEM) && !(ctxt->d & NoAccess)) {\n\t\trc = segmented_read(ctxt, ctxt->src.addr.mem,\n\t\t\t\t    ctxt->src.valptr, ctxt->src.bytes);\n\t\tif (rc != X86EMUL_CONTINUE)\n\t\t\tgoto done;\n\t\tctxt->src.orig_val64 = ctxt->src.val64;\n\t}\n\n\tif (ctxt->src2.type == OP_MEM) {\n\t\trc = segmented_read(ctxt, ctxt->src2.addr.mem,\n\t\t\t\t    &ctxt->src2.val, ctxt->src2.bytes);\n\t\tif (rc != X86EMUL_CONTINUE)\n\t\t\tgoto done;\n\t}\n\n\tif ((ctxt->d & DstMask) == ImplicitOps)\n\t\tgoto special_insn;\n\n\n\tif ((ctxt->dst.type == OP_MEM) && !(ctxt->d & Mov)) {\n\t\t/* optimisation - avoid slow emulated read if Mov */\n\t\trc = segmented_read(ctxt, ctxt->dst.addr.mem,\n\t\t\t\t   &ctxt->dst.val, ctxt->dst.bytes);\n\t\tif (rc != X86EMUL_CONTINUE) {\n\t\t\tif (!(ctxt->d & NoWrite) &&\n\t\t\t    rc == X86EMUL_PROPAGATE_FAULT &&\n\t\t\t    ctxt->exception.vector == PF_VECTOR)\n\t\t\t\tctxt->exception.error_code |= PFERR_WRITE_MASK;\n\t\t\tgoto done;\n\t\t}\n\t}\n\t/* Copy full 64-bit value for CMPXCHG8B.  */\n\tctxt->dst.orig_val64 = ctxt->dst.val64;\n\nspecial_insn:\n\n\tif (unlikely(ctxt->emul_flags & X86EMUL_GUEST_MASK) && (ctxt->d & Intercept)) {\n\t\trc = emulator_check_intercept(ctxt, ctxt->intercept,\n\t\t\t\t\t      X86_ICPT_POST_MEMACCESS);\n\t\tif (rc != X86EMUL_CONTINUE)\n\t\t\tgoto done;\n\t}\n\n\tif (ctxt->rep_prefix && (ctxt->d & String))\n\t\tctxt->eflags |= X86_EFLAGS_RF;\n\telse\n\t\tctxt->eflags &= ~X86_EFLAGS_RF;\n\n\tif (ctxt->execute) {\n\t\tif (ctxt->d & Fastop) {\n\t\t\tvoid (*fop)(struct fastop *) = (void *)ctxt->execute;\n\t\t\trc = fastop(ctxt, fop);\n\t\t\tif (rc != X86EMUL_CONTINUE)\n\t\t\t\tgoto done;\n\t\t\tgoto writeback;\n\t\t}\n\t\trc = ctxt->execute(ctxt);\n\t\tif (rc != X86EMUL_CONTINUE)\n\t\t\tgoto done;\n\t\tgoto writeback;\n\t}\n\n\tif (ctxt->opcode_len == 2)\n\t\tgoto twobyte_insn;\n\telse if (ctxt->opcode_len == 3)\n\t\tgoto threebyte_insn;\n\n\tswitch (ctxt->b) {\n\tcase 0x70 ... 0x7f: /* jcc (short) */\n\t\tif (test_cc(ctxt->b, ctxt->eflags))\n\t\t\trc = jmp_rel(ctxt, ctxt->src.val);\n\t\tbreak;\n\tcase 0x8d: /* lea r16/r32, m */\n\t\tctxt->dst.val = ctxt->src.addr.mem.ea;\n\t\tbreak;\n\tcase 0x90 ... 0x97: /* nop / xchg reg, rax */\n\t\tif (ctxt->dst.addr.reg == reg_rmw(ctxt, VCPU_REGS_RAX))\n\t\t\tctxt->dst.type = OP_NONE;\n\t\telse\n\t\t\trc = em_xchg(ctxt);\n\t\tbreak;\n\tcase 0x98: /* cbw/cwde/cdqe */\n\t\tswitch (ctxt->op_bytes) {\n\t\tcase 2: ctxt->dst.val = (s8)ctxt->dst.val; break;\n\t\tcase 4: ctxt->dst.val = (s16)ctxt->dst.val; break;\n\t\tcase 8: ctxt->dst.val = (s32)ctxt->dst.val; break;\n\t\t}\n\t\tbreak;\n\tcase 0xcc:\t\t/* int3 */\n\t\trc = emulate_int(ctxt, 3);\n\t\tbreak;\n\tcase 0xcd:\t\t/* int n */\n\t\trc = emulate_int(ctxt, ctxt->src.val);\n\t\tbreak;\n\tcase 0xce:\t\t/* into */\n\t\tif (ctxt->eflags & X86_EFLAGS_OF)\n\t\t\trc = emulate_int(ctxt, 4);\n\t\tbreak;\n\tcase 0xe9: /* jmp rel */\n\tcase 0xeb: /* jmp rel short */\n\t\trc = jmp_rel(ctxt, ctxt->src.val);\n\t\tctxt->dst.type = OP_NONE; /* Disable writeback. */\n\t\tbreak;\n\tcase 0xf4:              /* hlt */\n\t\tctxt->ops->halt(ctxt);\n\t\tbreak;\n\tcase 0xf5:\t/* cmc */\n\t\t/* complement carry flag from eflags reg */\n\t\tctxt->eflags ^= X86_EFLAGS_CF;\n\t\tbreak;\n\tcase 0xf8: /* clc */\n\t\tctxt->eflags &= ~X86_EFLAGS_CF;\n\t\tbreak;\n\tcase 0xf9: /* stc */\n\t\tctxt->eflags |= X86_EFLAGS_CF;\n\t\tbreak;\n\tcase 0xfc: /* cld */\n\t\tctxt->eflags &= ~X86_EFLAGS_DF;\n\t\tbreak;\n\tcase 0xfd: /* std */\n\t\tctxt->eflags |= X86_EFLAGS_DF;\n\t\tbreak;\n\tdefault:\n\t\tgoto cannot_emulate;\n\t}\n\n\tif (rc != X86EMUL_CONTINUE)\n\t\tgoto done;\n\nwriteback:\n\tif (ctxt->d & SrcWrite) {\n\t\tBUG_ON(ctxt->src.type == OP_MEM || ctxt->src.type == OP_MEM_STR);\n\t\trc = writeback(ctxt, &ctxt->src);\n\t\tif (rc != X86EMUL_CONTINUE)\n\t\t\tgoto done;\n\t}\n\tif (!(ctxt->d & NoWrite)) {\n\t\trc = writeback(ctxt, &ctxt->dst);\n\t\tif (rc != X86EMUL_CONTINUE)\n\t\t\tgoto done;\n\t}\n\n\t/*\n\t * restore dst type in case the decoding will be reused\n\t * (happens for string instruction )\n\t */\n\tctxt->dst.type = saved_dst_type;\n\n\tif ((ctxt->d & SrcMask) == SrcSI)\n\t\tstring_addr_inc(ctxt, VCPU_REGS_RSI, &ctxt->src);\n\n\tif ((ctxt->d & DstMask) == DstDI)\n\t\tstring_addr_inc(ctxt, VCPU_REGS_RDI, &ctxt->dst);\n\n\tif (ctxt->rep_prefix && (ctxt->d & String)) {\n\t\tunsigned int count;\n\t\tstruct read_cache *r = &ctxt->io_read;\n\t\tif ((ctxt->d & SrcMask) == SrcSI)\n\t\t\tcount = ctxt->src.count;\n\t\telse\n\t\t\tcount = ctxt->dst.count;\n\t\tregister_address_increment(ctxt, VCPU_REGS_RCX, -count);\n\n\t\tif (!string_insn_completed(ctxt)) {\n\t\t\t/*\n\t\t\t * Re-enter guest when pio read ahead buffer is empty\n\t\t\t * or, if it is not used, after each 1024 iteration.\n\t\t\t */\n\t\t\tif ((r->end != 0 || reg_read(ctxt, VCPU_REGS_RCX) & 0x3ff) &&\n\t\t\t    (r->end == 0 || r->end != r->pos)) {\n\t\t\t\t/*\n\t\t\t\t * Reset read cache. Usually happens before\n\t\t\t\t * decode, but since instruction is restarted\n\t\t\t\t * we have to do it here.\n\t\t\t\t */\n\t\t\t\tctxt->mem_read.end = 0;\n\t\t\t\twriteback_registers(ctxt);\n\t\t\t\treturn EMULATION_RESTART;\n\t\t\t}\n\t\t\tgoto done; /* skip rip writeback */\n\t\t}\n\t\tctxt->eflags &= ~X86_EFLAGS_RF;\n\t}\n\n\tctxt->eip = ctxt->_eip;\n\ndone:\n\tif (rc == X86EMUL_PROPAGATE_FAULT) {\n\t\tWARN_ON(ctxt->exception.vector > 0x1f);\n\t\tctxt->have_exception = true;\n\t}\n\tif (rc == X86EMUL_INTERCEPTED)\n\t\treturn EMULATION_INTERCEPTED;\n\n\tif (rc == X86EMUL_CONTINUE)\n\t\twriteback_registers(ctxt);\n\n\treturn (rc == X86EMUL_UNHANDLEABLE) ? EMULATION_FAILED : EMULATION_OK;\n\ntwobyte_insn:\n\tswitch (ctxt->b) {\n\tcase 0x09:\t\t/* wbinvd */\n\t\t(ctxt->ops->wbinvd)(ctxt);\n\t\tbreak;\n\tcase 0x08:\t\t/* invd */\n\tcase 0x0d:\t\t/* GrpP (prefetch) */\n\tcase 0x18:\t\t/* Grp16 (prefetch/nop) */\n\tcase 0x1f:\t\t/* nop */\n\t\tbreak;\n\tcase 0x20: /* mov cr, reg */\n\t\tctxt->dst.val = ops->get_cr(ctxt, ctxt->modrm_reg);\n\t\tbreak;\n\tcase 0x21: /* mov from dr to reg */\n\t\tops->get_dr(ctxt, ctxt->modrm_reg, &ctxt->dst.val);\n\t\tbreak;\n\tcase 0x40 ... 0x4f:\t/* cmov */\n\t\tif (test_cc(ctxt->b, ctxt->eflags))\n\t\t\tctxt->dst.val = ctxt->src.val;\n\t\telse if (ctxt->op_bytes != 4)\n\t\t\tctxt->dst.type = OP_NONE; /* no writeback */\n\t\tbreak;\n\tcase 0x80 ... 0x8f: /* jnz rel, etc*/\n\t\tif (test_cc(ctxt->b, ctxt->eflags))\n\t\t\trc = jmp_rel(ctxt, ctxt->src.val);\n\t\tbreak;\n\tcase 0x90 ... 0x9f:     /* setcc r/m8 */\n\t\tctxt->dst.val = test_cc(ctxt->b, ctxt->eflags);\n\t\tbreak;\n\tcase 0xb6 ... 0xb7:\t/* movzx */\n\t\tctxt->dst.bytes = ctxt->op_bytes;\n\t\tctxt->dst.val = (ctxt->src.bytes == 1) ? (u8) ctxt->src.val\n\t\t\t\t\t\t       : (u16) ctxt->src.val;\n\t\tbreak;\n\tcase 0xbe ... 0xbf:\t/* movsx */\n\t\tctxt->dst.bytes = ctxt->op_bytes;\n\t\tctxt->dst.val = (ctxt->src.bytes == 1) ? (s8) ctxt->src.val :\n\t\t\t\t\t\t\t(s16) ctxt->src.val;\n\t\tbreak;\n\tdefault:\n\t\tgoto cannot_emulate;\n\t}\n\nthreebyte_insn:\n\n\tif (rc != X86EMUL_CONTINUE)\n\t\tgoto done;\n\n\tgoto writeback;\n\ncannot_emulate:\n\treturn EMULATION_FAILED;\n}"
  },
  {
    "function_name": "init_decode_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "5126-5134",
    "snippet": "void init_decode_cache(struct x86_emulate_ctxt *ctxt)\n{\n\tmemset(&ctxt->rip_relative, 0,\n\t       (void *)&ctxt->modrm - (void *)&ctxt->rip_relative);\n\n\tctxt->io_read.pos = 0;\n\tctxt->io_read.end = 0;\n\tctxt->mem_read.end = 0;\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&ctxt->rip_relative",
            "0",
            "(void *)&ctxt->modrm - (void *)&ctxt->rip_relative"
          ],
          "line": 5128
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nvoid init_decode_cache(struct x86_emulate_ctxt *ctxt)\n{\n\tmemset(&ctxt->rip_relative, 0,\n\t       (void *)&ctxt->modrm - (void *)&ctxt->rip_relative);\n\n\tctxt->io_read.pos = 0;\n\tctxt->io_read.end = 0;\n\tctxt->mem_read.end = 0;\n}"
  },
  {
    "function_name": "fastop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "5111-5124",
    "snippet": "static int fastop(struct x86_emulate_ctxt *ctxt, void (*fop)(struct fastop *))\n{\n\tulong flags = (ctxt->eflags & EFLAGS_MASK) | X86_EFLAGS_IF;\n\tif (!(ctxt->d & ByteOp))\n\t\tfop += __ffs(ctxt->dst.bytes) * FASTOP_SIZE;\n\tasm(\"push %[flags]; popf; call *%[fastop]; pushf; pop %[flags]\\n\"\n\t    : \"+a\"(ctxt->dst.val), \"+d\"(ctxt->src.val), [flags]\"+D\"(flags),\n\t      [fastop]\"+S\"(fop)\n\t    : \"c\"(ctxt->src2.val));\n\tctxt->eflags = (ctxt->eflags & ~EFLAGS_MASK) | (flags & EFLAGS_MASK);\n\tif (!fop) /* exception is returned in fop variable */\n\t\treturn emulate_de(ctxt);\n\treturn X86EMUL_CONTINUE;\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define EFLAGS_MASK (X86_EFLAGS_OF|X86_EFLAGS_SF|X86_EFLAGS_ZF|X86_EFLAGS_AF|\\\n\t\t     X86_EFLAGS_PF|X86_EFLAGS_CF)",
      "#define FASTOP_SIZE 8",
      "#define ByteOp      (1<<0)\t/* 8-bit operands. */"
    ],
    "globals_used": [
      "static int fastop(struct x86_emulate_ctxt *ctxt, void (*fop)(struct fastop *));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "emulate_de",
          "args": [
            "ctxt"
          ],
          "line": 5122
        },
        "resolved": true,
        "details": {
          "function_name": "emulate_de",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "600-603",
          "snippet": "static int emulate_de(struct x86_emulate_ctxt *ctxt)\n{\n\treturn emulate_exception(ctxt, DE_VECTOR, 0, false);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int emulate_de(struct x86_emulate_ctxt *ctxt)\n{\n\treturn emulate_exception(ctxt, DE_VECTOR, 0, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ffs",
          "args": [
            "ctxt->dst.bytes"
          ],
          "line": 5115
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\n#define EFLAGS_MASK (X86_EFLAGS_OF|X86_EFLAGS_SF|X86_EFLAGS_ZF|X86_EFLAGS_AF|\\\n\t\t     X86_EFLAGS_PF|X86_EFLAGS_CF)\n#define FASTOP_SIZE 8\n#define ByteOp      (1<<0)\t/* 8-bit operands. */\n\nstatic int fastop(struct x86_emulate_ctxt *ctxt, void (*fop)(struct fastop *));\n\nstatic int fastop(struct x86_emulate_ctxt *ctxt, void (*fop)(struct fastop *))\n{\n\tulong flags = (ctxt->eflags & EFLAGS_MASK) | X86_EFLAGS_IF;\n\tif (!(ctxt->d & ByteOp))\n\t\tfop += __ffs(ctxt->dst.bytes) * FASTOP_SIZE;\n\tasm(\"push %[flags]; popf; call *%[fastop]; pushf; pop %[flags]\\n\"\n\t    : \"+a\"(ctxt->dst.val), \"+d\"(ctxt->src.val), [flags]\"+D\"(flags),\n\t      [fastop]\"+S\"(fop)\n\t    : \"c\"(ctxt->src2.val));\n\tctxt->eflags = (ctxt->eflags & ~EFLAGS_MASK) | (flags & EFLAGS_MASK);\n\tif (!fop) /* exception is returned in fop variable */\n\t\treturn emulate_de(ctxt);\n\treturn X86EMUL_CONTINUE;\n}"
  },
  {
    "function_name": "fetch_possible_mmx_operand",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "5104-5109",
    "snippet": "static void fetch_possible_mmx_operand(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t       struct operand *op)\n{\n\tif (op->type == OP_MM)\n\t\tread_mmx_reg(ctxt, &op->mm_val, op->addr.mm);\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_mmx_reg",
          "args": [
            "ctxt",
            "&op->mm_val",
            "op->addr.mm"
          ],
          "line": 5108
        },
        "resolved": true,
        "details": {
          "function_name": "read_mmx_reg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "1056-1071",
          "snippet": "static void read_mmx_reg(struct x86_emulate_ctxt *ctxt, u64 *data, int reg)\n{\n\tctxt->ops->get_fpu(ctxt);\n\tswitch (reg) {\n\tcase 0: asm(\"movq %%mm0, %0\" : \"=m\"(*data)); break;\n\tcase 1: asm(\"movq %%mm1, %0\" : \"=m\"(*data)); break;\n\tcase 2: asm(\"movq %%mm2, %0\" : \"=m\"(*data)); break;\n\tcase 3: asm(\"movq %%mm3, %0\" : \"=m\"(*data)); break;\n\tcase 4: asm(\"movq %%mm4, %0\" : \"=m\"(*data)); break;\n\tcase 5: asm(\"movq %%mm5, %0\" : \"=m\"(*data)); break;\n\tcase 6: asm(\"movq %%mm6, %0\" : \"=m\"(*data)); break;\n\tcase 7: asm(\"movq %%mm7, %0\" : \"=m\"(*data)); break;\n\tdefault: BUG();\n\t}\n\tctxt->ops->put_fpu(ctxt);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic void read_mmx_reg(struct x86_emulate_ctxt *ctxt, u64 *data, int reg)\n{\n\tctxt->ops->get_fpu(ctxt);\n\tswitch (reg) {\n\tcase 0: asm(\"movq %%mm0, %0\" : \"=m\"(*data)); break;\n\tcase 1: asm(\"movq %%mm1, %0\" : \"=m\"(*data)); break;\n\tcase 2: asm(\"movq %%mm2, %0\" : \"=m\"(*data)); break;\n\tcase 3: asm(\"movq %%mm3, %0\" : \"=m\"(*data)); break;\n\tcase 4: asm(\"movq %%mm4, %0\" : \"=m\"(*data)); break;\n\tcase 5: asm(\"movq %%mm5, %0\" : \"=m\"(*data)); break;\n\tcase 6: asm(\"movq %%mm6, %0\" : \"=m\"(*data)); break;\n\tcase 7: asm(\"movq %%mm7, %0\" : \"=m\"(*data)); break;\n\tdefault: BUG();\n\t}\n\tctxt->ops->put_fpu(ctxt);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic void fetch_possible_mmx_operand(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t       struct operand *op)\n{\n\tif (op->type == OP_MM)\n\t\tread_mmx_reg(ctxt, &op->mm_val, op->addr.mm);\n}"
  },
  {
    "function_name": "flush_pending_x87_faults",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "5082-5102",
    "snippet": "static int flush_pending_x87_faults(struct x86_emulate_ctxt *ctxt)\n{\n\tbool fault = false;\n\n\tctxt->ops->get_fpu(ctxt);\n\tasm volatile(\"1: fwait \\n\\t\"\n\t\t     \"2: \\n\\t\"\n\t\t     \".pushsection .fixup,\\\"ax\\\" \\n\\t\"\n\t\t     \"3: \\n\\t\"\n\t\t     \"movb $1, %[fault] \\n\\t\"\n\t\t     \"jmp 2b \\n\\t\"\n\t\t     \".popsection \\n\\t\"\n\t\t     _ASM_EXTABLE(1b, 3b)\n\t\t     : [fault]\"+qm\"(fault));\n\tctxt->ops->put_fpu(ctxt);\n\n\tif (unlikely(fault))\n\t\treturn emulate_exception(ctxt, MF_VECTOR, 0, false);\n\n\treturn X86EMUL_CONTINUE;\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "emulate_exception",
          "args": [
            "ctxt",
            "MF_VECTOR",
            "0",
            "false"
          ],
          "line": 5099
        },
        "resolved": true,
        "details": {
          "function_name": "emulate_exception",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "565-573",
          "snippet": "static int emulate_exception(struct x86_emulate_ctxt *ctxt, int vec,\n\t\t\t     u32 error, bool valid)\n{\n\tWARN_ON(vec > 0x1f);\n\tctxt->exception.vector = vec;\n\tctxt->exception.error_code = error;\n\tctxt->exception.error_code_valid = valid;\n\treturn X86EMUL_PROPAGATE_FAULT;\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int emulate_exception(struct x86_emulate_ctxt *ctxt, int vec,\n\t\t\t     u32 error, bool valid)\n{\n\tWARN_ON(vec > 0x1f);\n\tctxt->exception.vector = vec;\n\tctxt->exception.error_code = error;\n\tctxt->exception.error_code_valid = valid;\n\treturn X86EMUL_PROPAGATE_FAULT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "fault"
          ],
          "line": 5098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qm\"",
          "args": [
            "ctxt"
          ],
          "line": 5095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asm volatile",
          "args": [
            "1b",
            "3b"
          ],
          "line": 5087
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ctxt->ops->get_fpu",
          "args": [
            "ctxt"
          ],
          "line": 5086
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int flush_pending_x87_faults(struct x86_emulate_ctxt *ctxt)\n{\n\tbool fault = false;\n\n\tctxt->ops->get_fpu(ctxt);\n\tasm volatile(\"1: fwait \\n\\t\"\n\t\t     \"2: \\n\\t\"\n\t\t     \".pushsection .fixup,\\\"ax\\\" \\n\\t\"\n\t\t     \"3: \\n\\t\"\n\t\t     \"movb $1, %[fault] \\n\\t\"\n\t\t     \"jmp 2b \\n\\t\"\n\t\t     \".popsection \\n\\t\"\n\t\t     _ASM_EXTABLE(1b, 3b)\n\t\t     : [fault]\"+qm\"(fault));\n\tctxt->ops->put_fpu(ctxt);\n\n\tif (unlikely(fault))\n\t\treturn emulate_exception(ctxt, MF_VECTOR, 0, false);\n\n\treturn X86EMUL_CONTINUE;\n}"
  },
  {
    "function_name": "string_insn_completed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "5062-5080",
    "snippet": "static bool string_insn_completed(struct x86_emulate_ctxt *ctxt)\n{\n\t/* The second termination condition only applies for REPE\n\t * and REPNE. Test if the repeat string operation prefix is\n\t * REPE/REPZ or REPNE/REPNZ and if it's the case it tests the\n\t * corresponding termination condition according to:\n\t * \t- if REPE/REPZ and ZF = 0 then done\n\t * \t- if REPNE/REPNZ and ZF = 1 then done\n\t */\n\tif (((ctxt->b == 0xa6) || (ctxt->b == 0xa7) ||\n\t     (ctxt->b == 0xae) || (ctxt->b == 0xaf))\n\t    && (((ctxt->rep_prefix == REPE_PREFIX) &&\n\t\t ((ctxt->eflags & X86_EFLAGS_ZF) == 0))\n\t\t|| ((ctxt->rep_prefix == REPNE_PREFIX) &&\n\t\t    ((ctxt->eflags & X86_EFLAGS_ZF) == X86_EFLAGS_ZF))))\n\t\treturn true;\n\n\treturn false;\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic bool string_insn_completed(struct x86_emulate_ctxt *ctxt)\n{\n\t/* The second termination condition only applies for REPE\n\t * and REPNE. Test if the repeat string operation prefix is\n\t * REPE/REPZ or REPNE/REPNZ and if it's the case it tests the\n\t * corresponding termination condition according to:\n\t * \t- if REPE/REPZ and ZF = 0 then done\n\t * \t- if REPNE/REPNZ and ZF = 1 then done\n\t */\n\tif (((ctxt->b == 0xa6) || (ctxt->b == 0xa7) ||\n\t     (ctxt->b == 0xae) || (ctxt->b == 0xaf))\n\t    && (((ctxt->rep_prefix == REPE_PREFIX) &&\n\t\t ((ctxt->eflags & X86_EFLAGS_ZF) == 0))\n\t\t|| ((ctxt->rep_prefix == REPNE_PREFIX) &&\n\t\t    ((ctxt->eflags & X86_EFLAGS_ZF) == X86_EFLAGS_ZF))))\n\t\treturn true;\n\n\treturn false;\n}"
  },
  {
    "function_name": "x86_page_table_writing_insn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "5057-5060",
    "snippet": "bool x86_page_table_writing_insn(struct x86_emulate_ctxt *ctxt)\n{\n\treturn ctxt->d & PageTable;\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define PageTable   (1 << 29)   /* instruction used to write page table */"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\n#define PageTable   (1 << 29)   /* instruction used to write page table */\n\nbool x86_page_table_writing_insn(struct x86_emulate_ctxt *ctxt)\n{\n\treturn ctxt->d & PageTable;\n}"
  },
  {
    "function_name": "x86_decode_insn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "4788-5055",
    "snippet": "int x86_decode_insn(struct x86_emulate_ctxt *ctxt, void *insn, int insn_len)\n{\n\tint rc = X86EMUL_CONTINUE;\n\tint mode = ctxt->mode;\n\tint def_op_bytes, def_ad_bytes, goffset, simd_prefix;\n\tbool op_prefix = false;\n\tbool has_seg_override = false;\n\tstruct opcode opcode;\n\n\tctxt->memop.type = OP_NONE;\n\tctxt->memopp = NULL;\n\tctxt->_eip = ctxt->eip;\n\tctxt->fetch.ptr = ctxt->fetch.data;\n\tctxt->fetch.end = ctxt->fetch.data + insn_len;\n\tctxt->opcode_len = 1;\n\tif (insn_len > 0)\n\t\tmemcpy(ctxt->fetch.data, insn, insn_len);\n\telse {\n\t\trc = __do_insn_fetch_bytes(ctxt, 1);\n\t\tif (rc != X86EMUL_CONTINUE)\n\t\t\treturn rc;\n\t}\n\n\tswitch (mode) {\n\tcase X86EMUL_MODE_REAL:\n\tcase X86EMUL_MODE_VM86:\n\tcase X86EMUL_MODE_PROT16:\n\t\tdef_op_bytes = def_ad_bytes = 2;\n\t\tbreak;\n\tcase X86EMUL_MODE_PROT32:\n\t\tdef_op_bytes = def_ad_bytes = 4;\n\t\tbreak;\n#ifdef CONFIG_X86_64\n\tcase X86EMUL_MODE_PROT64:\n\t\tdef_op_bytes = 4;\n\t\tdef_ad_bytes = 8;\n\t\tbreak;\n#endif\n\tdefault:\n\t\treturn EMULATION_FAILED;\n\t}\n\n\tctxt->op_bytes = def_op_bytes;\n\tctxt->ad_bytes = def_ad_bytes;\n\n\t/* Legacy prefixes. */\n\tfor (;;) {\n\t\tswitch (ctxt->b = insn_fetch(u8, ctxt)) {\n\t\tcase 0x66:\t/* operand-size override */\n\t\t\top_prefix = true;\n\t\t\t/* switch between 2/4 bytes */\n\t\t\tctxt->op_bytes = def_op_bytes ^ 6;\n\t\t\tbreak;\n\t\tcase 0x67:\t/* address-size override */\n\t\t\tif (mode == X86EMUL_MODE_PROT64)\n\t\t\t\t/* switch between 4/8 bytes */\n\t\t\t\tctxt->ad_bytes = def_ad_bytes ^ 12;\n\t\t\telse\n\t\t\t\t/* switch between 2/4 bytes */\n\t\t\t\tctxt->ad_bytes = def_ad_bytes ^ 6;\n\t\t\tbreak;\n\t\tcase 0x26:\t/* ES override */\n\t\tcase 0x2e:\t/* CS override */\n\t\tcase 0x36:\t/* SS override */\n\t\tcase 0x3e:\t/* DS override */\n\t\t\thas_seg_override = true;\n\t\t\tctxt->seg_override = (ctxt->b >> 3) & 3;\n\t\t\tbreak;\n\t\tcase 0x64:\t/* FS override */\n\t\tcase 0x65:\t/* GS override */\n\t\t\thas_seg_override = true;\n\t\t\tctxt->seg_override = ctxt->b & 7;\n\t\t\tbreak;\n\t\tcase 0x40 ... 0x4f: /* REX */\n\t\t\tif (mode != X86EMUL_MODE_PROT64)\n\t\t\t\tgoto done_prefixes;\n\t\t\tctxt->rex_prefix = ctxt->b;\n\t\t\tcontinue;\n\t\tcase 0xf0:\t/* LOCK */\n\t\t\tctxt->lock_prefix = 1;\n\t\t\tbreak;\n\t\tcase 0xf2:\t/* REPNE/REPNZ */\n\t\tcase 0xf3:\t/* REP/REPE/REPZ */\n\t\t\tctxt->rep_prefix = ctxt->b;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto done_prefixes;\n\t\t}\n\n\t\t/* Any legacy prefix after a REX prefix nullifies its effect. */\n\n\t\tctxt->rex_prefix = 0;\n\t}\n\ndone_prefixes:\n\n\t/* REX prefix. */\n\tif (ctxt->rex_prefix & 8)\n\t\tctxt->op_bytes = 8;\t/* REX.W */\n\n\t/* Opcode byte(s). */\n\topcode = opcode_table[ctxt->b];\n\t/* Two-byte opcode? */\n\tif (ctxt->b == 0x0f) {\n\t\tctxt->opcode_len = 2;\n\t\tctxt->b = insn_fetch(u8, ctxt);\n\t\topcode = twobyte_table[ctxt->b];\n\n\t\t/* 0F_38 opcode map */\n\t\tif (ctxt->b == 0x38) {\n\t\t\tctxt->opcode_len = 3;\n\t\t\tctxt->b = insn_fetch(u8, ctxt);\n\t\t\topcode = opcode_map_0f_38[ctxt->b];\n\t\t}\n\t}\n\tctxt->d = opcode.flags;\n\n\tif (ctxt->d & ModRM)\n\t\tctxt->modrm = insn_fetch(u8, ctxt);\n\n\t/* vex-prefix instructions are not implemented */\n\tif (ctxt->opcode_len == 1 && (ctxt->b == 0xc5 || ctxt->b == 0xc4) &&\n\t    (mode == X86EMUL_MODE_PROT64 || (ctxt->modrm & 0xc0) == 0xc0)) {\n\t\tctxt->d = NotImpl;\n\t}\n\n\twhile (ctxt->d & GroupMask) {\n\t\tswitch (ctxt->d & GroupMask) {\n\t\tcase Group:\n\t\t\tgoffset = (ctxt->modrm >> 3) & 7;\n\t\t\topcode = opcode.u.group[goffset];\n\t\t\tbreak;\n\t\tcase GroupDual:\n\t\t\tgoffset = (ctxt->modrm >> 3) & 7;\n\t\t\tif ((ctxt->modrm >> 6) == 3)\n\t\t\t\topcode = opcode.u.gdual->mod3[goffset];\n\t\t\telse\n\t\t\t\topcode = opcode.u.gdual->mod012[goffset];\n\t\t\tbreak;\n\t\tcase RMExt:\n\t\t\tgoffset = ctxt->modrm & 7;\n\t\t\topcode = opcode.u.group[goffset];\n\t\t\tbreak;\n\t\tcase Prefix:\n\t\t\tif (ctxt->rep_prefix && op_prefix)\n\t\t\t\treturn EMULATION_FAILED;\n\t\t\tsimd_prefix = op_prefix ? 0x66 : ctxt->rep_prefix;\n\t\t\tswitch (simd_prefix) {\n\t\t\tcase 0x00: opcode = opcode.u.gprefix->pfx_no; break;\n\t\t\tcase 0x66: opcode = opcode.u.gprefix->pfx_66; break;\n\t\t\tcase 0xf2: opcode = opcode.u.gprefix->pfx_f2; break;\n\t\t\tcase 0xf3: opcode = opcode.u.gprefix->pfx_f3; break;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Escape:\n\t\t\tif (ctxt->modrm > 0xbf)\n\t\t\t\topcode = opcode.u.esc->high[ctxt->modrm - 0xc0];\n\t\t\telse\n\t\t\t\topcode = opcode.u.esc->op[(ctxt->modrm >> 3) & 7];\n\t\t\tbreak;\n\t\tcase InstrDual:\n\t\t\tif ((ctxt->modrm >> 6) == 3)\n\t\t\t\topcode = opcode.u.idual->mod3;\n\t\t\telse\n\t\t\t\topcode = opcode.u.idual->mod012;\n\t\t\tbreak;\n\t\tcase ModeDual:\n\t\t\tif (ctxt->mode == X86EMUL_MODE_PROT64)\n\t\t\t\topcode = opcode.u.mdual->mode64;\n\t\t\telse\n\t\t\t\topcode = opcode.u.mdual->mode32;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn EMULATION_FAILED;\n\t\t}\n\n\t\tctxt->d &= ~(u64)GroupMask;\n\t\tctxt->d |= opcode.flags;\n\t}\n\n\t/* Unrecognised? */\n\tif (ctxt->d == 0)\n\t\treturn EMULATION_FAILED;\n\n\tctxt->execute = opcode.u.execute;\n\n\tif (unlikely(ctxt->ud) && likely(!(ctxt->d & EmulateOnUD)))\n\t\treturn EMULATION_FAILED;\n\n\tif (unlikely(ctxt->d &\n\t    (NotImpl|Stack|Op3264|Sse|Mmx|Intercept|CheckPerm|NearBranch|\n\t     No16))) {\n\t\t/*\n\t\t * These are copied unconditionally here, and checked unconditionally\n\t\t * in x86_emulate_insn.\n\t\t */\n\t\tctxt->check_perm = opcode.check_perm;\n\t\tctxt->intercept = opcode.intercept;\n\n\t\tif (ctxt->d & NotImpl)\n\t\t\treturn EMULATION_FAILED;\n\n\t\tif (mode == X86EMUL_MODE_PROT64) {\n\t\t\tif (ctxt->op_bytes == 4 && (ctxt->d & Stack))\n\t\t\t\tctxt->op_bytes = 8;\n\t\t\telse if (ctxt->d & NearBranch)\n\t\t\t\tctxt->op_bytes = 8;\n\t\t}\n\n\t\tif (ctxt->d & Op3264) {\n\t\t\tif (mode == X86EMUL_MODE_PROT64)\n\t\t\t\tctxt->op_bytes = 8;\n\t\t\telse\n\t\t\t\tctxt->op_bytes = 4;\n\t\t}\n\n\t\tif ((ctxt->d & No16) && ctxt->op_bytes == 2)\n\t\t\tctxt->op_bytes = 4;\n\n\t\tif (ctxt->d & Sse)\n\t\t\tctxt->op_bytes = 16;\n\t\telse if (ctxt->d & Mmx)\n\t\t\tctxt->op_bytes = 8;\n\t}\n\n\t/* ModRM and SIB bytes. */\n\tif (ctxt->d & ModRM) {\n\t\trc = decode_modrm(ctxt, &ctxt->memop);\n\t\tif (!has_seg_override) {\n\t\t\thas_seg_override = true;\n\t\t\tctxt->seg_override = ctxt->modrm_seg;\n\t\t}\n\t} else if (ctxt->d & MemAbs)\n\t\trc = decode_abs(ctxt, &ctxt->memop);\n\tif (rc != X86EMUL_CONTINUE)\n\t\tgoto done;\n\n\tif (!has_seg_override)\n\t\tctxt->seg_override = VCPU_SREG_DS;\n\n\tctxt->memop.addr.mem.seg = ctxt->seg_override;\n\n\t/*\n\t * Decode and fetch the source operand: register, memory\n\t * or immediate.\n\t */\n\trc = decode_operand(ctxt, &ctxt->src, (ctxt->d >> SrcShift) & OpMask);\n\tif (rc != X86EMUL_CONTINUE)\n\t\tgoto done;\n\n\t/*\n\t * Decode and fetch the second source operand: register, memory\n\t * or immediate.\n\t */\n\trc = decode_operand(ctxt, &ctxt->src2, (ctxt->d >> Src2Shift) & OpMask);\n\tif (rc != X86EMUL_CONTINUE)\n\t\tgoto done;\n\n\t/* Decode and fetch the destination operand: register or memory. */\n\trc = decode_operand(ctxt, &ctxt->dst, (ctxt->d >> DstShift) & OpMask);\n\n\tif (ctxt->rip_relative)\n\t\tctxt->memopp->addr.mem.ea = address_mask(ctxt,\n\t\t\t\t\tctxt->memopp->addr.mem.ea + ctxt->_eip);\n\ndone:\n\treturn (rc != X86EMUL_CONTINUE) ? EMULATION_FAILED : EMULATION_OK;\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define No16\t    ((u64)1 << 53)  /* No 16 bit operand */",
      "#define NearBranch  ((u64)1 << 52)  /* Near branches */",
      "#define CheckPerm   ((u64)1 << 49)  /* Has valid check_perm field */",
      "#define Intercept   ((u64)1 << 48)  /* Has valid intercept field */",
      "#define Mmx         ((u64)1 << 40)  /* MMX Vector instruction */",
      "#define Src2Shift   (31)",
      "#define NotImpl     (1 << 30)   /* instruction is not implemented */",
      "#define Op3264      (1<<24) /* Operand is 64b in long mode, 32b otherwise */",
      "#define EmulateOnUD (1<<22) /* Emulate if unsupported by the host */",
      "#define ModRM       (1<<19)",
      "#define Sse         (1<<18)     /* SSE Vector instruction */",
      "#define ModeDual    (7<<15)     /* Different instruction for 32/64 bit */",
      "#define InstrDual   (6<<15)     /* Alternate instruction decoding of mod == 3 */",
      "#define Escape      (5<<15)     /* Escape to coprocessor instruction */",
      "#define RMExt       (4<<15)     /* Opcode extension in ModRM r/m if mod == 3 */",
      "#define Prefix      (3<<15)     /* Instruction varies with 66/f2/f3 prefix */",
      "#define GroupDual   (2<<15)     /* Alternate decoding of mod == 3 */",
      "#define Group       (1<<15)     /* Bits 3:5 of modrm byte extend opcode */",
      "#define GroupMask   (7<<15)     /* Opcode uses one of the group mechanisms */",
      "#define Stack       (1<<14)     /* Stack instruction (push/pop) */",
      "#define MemAbs      (1<<12)      /* Memory operand is absolute displacement */",
      "#define SrcShift    6",
      "#define DstShift    1",
      "#define OpMask             ((1ull << OpBits) - 1)"
    ],
    "globals_used": [
      "static const struct opcode opcode_table[256] = {\n\t/* 0x00 - 0x07 */\n\tF6ALU(Lock, em_add),\n\tI(ImplicitOps | Stack | No64 | Src2ES, em_push_sreg),\n\tI(ImplicitOps | Stack | No64 | Src2ES, em_pop_sreg),\n\t/* 0x08 - 0x0F */\n\tF6ALU(Lock | PageTable, em_or),\n\tI(ImplicitOps | Stack | No64 | Src2CS, em_push_sreg),\n\tN,\n\t/* 0x10 - 0x17 */\n\tF6ALU(Lock, em_adc),\n\tI(ImplicitOps | Stack | No64 | Src2SS, em_push_sreg),\n\tI(ImplicitOps | Stack | No64 | Src2SS, em_pop_sreg),\n\t/* 0x18 - 0x1F */\n\tF6ALU(Lock, em_sbb),\n\tI(ImplicitOps | Stack | No64 | Src2DS, em_push_sreg),\n\tI(ImplicitOps | Stack | No64 | Src2DS, em_pop_sreg),\n\t/* 0x20 - 0x27 */\n\tF6ALU(Lock | PageTable, em_and), N, N,\n\t/* 0x28 - 0x2F */\n\tF6ALU(Lock, em_sub), N, I(ByteOp | DstAcc | No64, em_das),\n\t/* 0x30 - 0x37 */\n\tF6ALU(Lock, em_xor), N, N,\n\t/* 0x38 - 0x3F */\n\tF6ALU(NoWrite, em_cmp), N, N,\n\t/* 0x40 - 0x4F */\n\tX8(F(DstReg, em_inc)), X8(F(DstReg, em_dec)),\n\t/* 0x50 - 0x57 */\n\tX8(I(SrcReg | Stack, em_push)),\n\t/* 0x58 - 0x5F */\n\tX8(I(DstReg | Stack, em_pop)),\n\t/* 0x60 - 0x67 */\n\tI(ImplicitOps | Stack | No64, em_pusha),\n\tI(ImplicitOps | Stack | No64, em_popa),\n\tN, MD(ModRM, &mode_dual_63),\n\tN, N, N, N,\n\t/* 0x68 - 0x6F */\n\tI(SrcImm | Mov | Stack, em_push),\n\tI(DstReg | SrcMem | ModRM | Src2Imm, em_imul_3op),\n\tI(SrcImmByte | Mov | Stack, em_push),\n\tI(DstReg | SrcMem | ModRM | Src2ImmByte, em_imul_3op),\n\tI2bvIP(DstDI | SrcDX | Mov | String | Unaligned, em_in, ins, check_perm_in), /* insb, insw/insd */\n\tI2bvIP(SrcSI | DstDX | String, em_out, outs, check_perm_out), /* outsb, outsw/outsd */\n\t/* 0x70 - 0x7F */\n\tX16(D(SrcImmByte | NearBranch)),\n\t/* 0x80 - 0x87 */\n\tG(ByteOp | DstMem | SrcImm, group1),\n\tG(DstMem | SrcImm, group1),\n\tG(ByteOp | DstMem | SrcImm | No64, group1),\n\tG(DstMem | SrcImmByte, group1),\n\tF2bv(DstMem | SrcReg | ModRM | NoWrite, em_test),\n\tI2bv(DstMem | SrcReg | ModRM | Lock | PageTable, em_xchg),\n\t/* 0x88 - 0x8F */\n\tI2bv(DstMem | SrcReg | ModRM | Mov | PageTable, em_mov),\n\tI2bv(DstReg | SrcMem | ModRM | Mov, em_mov),\n\tI(DstMem | SrcNone | ModRM | Mov | PageTable, em_mov_rm_sreg),\n\tD(ModRM | SrcMem | NoAccess | DstReg),\n\tI(ImplicitOps | SrcMem16 | ModRM, em_mov_sreg_rm),\n\tG(0, group1A),\n\t/* 0x90 - 0x97 */\n\tDI(SrcAcc | DstReg, pause), X7(D(SrcAcc | DstReg)),\n\t/* 0x98 - 0x9F */\n\tD(DstAcc | SrcNone), I(ImplicitOps | SrcAcc, em_cwd),\n\tI(SrcImmFAddr | No64, em_call_far), N,\n\tII(ImplicitOps | Stack, em_pushf, pushf),\n\tII(ImplicitOps | Stack, em_popf, popf),\n\tI(ImplicitOps, em_sahf), I(ImplicitOps, em_lahf),\n\t/* 0xA0 - 0xA7 */\n\tI2bv(DstAcc | SrcMem | Mov | MemAbs, em_mov),\n\tI2bv(DstMem | SrcAcc | Mov | MemAbs | PageTable, em_mov),\n\tI2bv(SrcSI | DstDI | Mov | String, em_mov),\n\tF2bv(SrcSI | DstDI | String | NoWrite, em_cmp_r),\n\t/* 0xA8 - 0xAF */\n\tF2bv(DstAcc | SrcImm | NoWrite, em_test),\n\tI2bv(SrcAcc | DstDI | Mov | String, em_mov),\n\tI2bv(SrcSI | DstAcc | Mov | String, em_mov),\n\tF2bv(SrcAcc | DstDI | String | NoWrite, em_cmp_r),\n\t/* 0xB0 - 0xB7 */\n\tX8(I(ByteOp | DstReg | SrcImm | Mov, em_mov)),\n\t/* 0xB8 - 0xBF */\n\tX8(I(DstReg | SrcImm64 | Mov, em_mov)),\n\t/* 0xC0 - 0xC7 */\n\tG(ByteOp | Src2ImmByte, group2), G(Src2ImmByte, group2),\n\tI(ImplicitOps | NearBranch | SrcImmU16, em_ret_near_imm),\n\tI(ImplicitOps | NearBranch, em_ret),\n\tI(DstReg | SrcMemFAddr | ModRM | No64 | Src2ES, em_lseg),\n\tI(DstReg | SrcMemFAddr | ModRM | No64 | Src2DS, em_lseg),\n\tG(ByteOp, group11), G(0, group11),\n\t/* 0xC8 - 0xCF */\n\tI(Stack | SrcImmU16 | Src2ImmByte, em_enter), I(Stack, em_leave),\n\tI(ImplicitOps | SrcImmU16, em_ret_far_imm),\n\tI(ImplicitOps, em_ret_far),\n\tD(ImplicitOps), DI(SrcImmByte, intn),\n\tD(ImplicitOps | No64), II(ImplicitOps, em_iret, iret),\n\t/* 0xD0 - 0xD7 */\n\tG(Src2One | ByteOp, group2), G(Src2One, group2),\n\tG(Src2CL | ByteOp, group2), G(Src2CL, group2),\n\tI(DstAcc | SrcImmUByte | No64, em_aam),\n\tI(DstAcc | SrcImmUByte | No64, em_aad),\n\tF(DstAcc | ByteOp | No64, em_salc),\n\tI(DstAcc | SrcXLat | ByteOp, em_mov),\n\t/* 0xD8 - 0xDF */\n\tN, E(0, &escape_d9), N, E(0, &escape_db), N, E(0, &escape_dd), N, N,\n\t/* 0xE0 - 0xE7 */\n\tX3(I(SrcImmByte | NearBranch, em_loop)),\n\tI(SrcImmByte | NearBranch, em_jcxz),\n\tI2bvIP(SrcImmUByte | DstAcc, em_in,  in,  check_perm_in),\n\tI2bvIP(SrcAcc | DstImmUByte, em_out, out, check_perm_out),\n\t/* 0xE8 - 0xEF */\n\tI(SrcImm | NearBranch, em_call), D(SrcImm | ImplicitOps | NearBranch),\n\tI(SrcImmFAddr | No64, em_jmp_far),\n\tD(SrcImmByte | ImplicitOps | NearBranch),\n\tI2bvIP(SrcDX | DstAcc, em_in,  in,  check_perm_in),\n\tI2bvIP(SrcAcc | DstDX, em_out, out, check_perm_out),\n\t/* 0xF0 - 0xF7 */\n\tN, DI(ImplicitOps, icebp), N, N,\n\tDI(ImplicitOps | Priv, hlt), D(ImplicitOps),\n\tG(ByteOp, group3), G(0, group3),\n\t/* 0xF8 - 0xFF */\n\tD(ImplicitOps), D(ImplicitOps),\n\tI(ImplicitOps, em_cli), I(ImplicitOps, em_sti),\n\tD(ImplicitOps), D(ImplicitOps), G(0, group4), G(0, group5),\n};",
      "static const struct opcode twobyte_table[256] = {\n\t/* 0x00 - 0x0F */\n\tG(0, group6), GD(0, &group7), N, N,\n\tN, I(ImplicitOps | EmulateOnUD, em_syscall),\n\tII(ImplicitOps | Priv, em_clts, clts), N,\n\tDI(ImplicitOps | Priv, invd), DI(ImplicitOps | Priv, wbinvd), N, N,\n\tN, D(ImplicitOps | ModRM | SrcMem | NoAccess), N, N,\n\t/* 0x10 - 0x1F */\n\tN, N, N, N, N, N, N, N,\n\tD(ImplicitOps | ModRM | SrcMem | NoAccess),\n\tN, N, N, N, N, N, D(ImplicitOps | ModRM | SrcMem | NoAccess),\n\t/* 0x20 - 0x2F */\n\tDIP(ModRM | DstMem | Priv | Op3264 | NoMod, cr_read, check_cr_read),\n\tDIP(ModRM | DstMem | Priv | Op3264 | NoMod, dr_read, check_dr_read),\n\tIIP(ModRM | SrcMem | Priv | Op3264 | NoMod, em_cr_write, cr_write,\n\t\t\t\t\t\tcheck_cr_write),\n\tIIP(ModRM | SrcMem | Priv | Op3264 | NoMod, em_dr_write, dr_write,\n\t\t\t\t\t\tcheck_dr_write),\n\tN, N, N, N,\n\tGP(ModRM | DstReg | SrcMem | Mov | Sse, &pfx_0f_28_0f_29),\n\tGP(ModRM | DstMem | SrcReg | Mov | Sse, &pfx_0f_28_0f_29),\n\tN, GP(ModRM | DstMem | SrcReg | Mov | Sse, &pfx_0f_2b),\n\tN, N, N, N,\n\t/* 0x30 - 0x3F */\n\tII(ImplicitOps | Priv, em_wrmsr, wrmsr),\n\tIIP(ImplicitOps, em_rdtsc, rdtsc, check_rdtsc),\n\tII(ImplicitOps | Priv, em_rdmsr, rdmsr),\n\tIIP(ImplicitOps, em_rdpmc, rdpmc, check_rdpmc),\n\tI(ImplicitOps | EmulateOnUD, em_sysenter),\n\tI(ImplicitOps | Priv | EmulateOnUD, em_sysexit),\n\tN, N,\n\tN, N, N, N, N, N, N, N,\n\t/* 0x40 - 0x4F */\n\tX16(D(DstReg | SrcMem | ModRM)),\n\t/* 0x50 - 0x5F */\n\tN, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N,\n\t/* 0x60 - 0x6F */\n\tN, N, N, N,\n\tN, N, N, N,\n\tN, N, N, N,\n\tN, N, N, GP(SrcMem | DstReg | ModRM | Mov, &pfx_0f_6f_0f_7f),\n\t/* 0x70 - 0x7F */\n\tN, N, N, N,\n\tN, N, N, N,\n\tN, N, N, N,\n\tN, N, N, GP(SrcReg | DstMem | ModRM | Mov, &pfx_0f_6f_0f_7f),\n\t/* 0x80 - 0x8F */\n\tX16(D(SrcImm | NearBranch)),\n\t/* 0x90 - 0x9F */\n\tX16(D(ByteOp | DstMem | SrcNone | ModRM| Mov)),\n\t/* 0xA0 - 0xA7 */\n\tI(Stack | Src2FS, em_push_sreg), I(Stack | Src2FS, em_pop_sreg),\n\tII(ImplicitOps, em_cpuid, cpuid),\n\tF(DstMem | SrcReg | ModRM | BitOp | NoWrite, em_bt),\n\tF(DstMem | SrcReg | Src2ImmByte | ModRM, em_shld),\n\tF(DstMem | SrcReg | Src2CL | ModRM, em_shld), N, N,\n\t/* 0xA8 - 0xAF */\n\tI(Stack | Src2GS, em_push_sreg), I(Stack | Src2GS, em_pop_sreg),\n\tII(EmulateOnUD | ImplicitOps, em_rsm, rsm),\n\tF(DstMem | SrcReg | ModRM | BitOp | Lock | PageTable, em_bts),\n\tF(DstMem | SrcReg | Src2ImmByte | ModRM, em_shrd),\n\tF(DstMem | SrcReg | Src2CL | ModRM, em_shrd),\n\tGD(0, &group15), F(DstReg | SrcMem | ModRM, em_imul),\n\t/* 0xB0 - 0xB7 */\n\tI2bv(DstMem | SrcReg | ModRM | Lock | PageTable | SrcWrite, em_cmpxchg),\n\tI(DstReg | SrcMemFAddr | ModRM | Src2SS, em_lseg),\n\tF(DstMem | SrcReg | ModRM | BitOp | Lock, em_btr),\n\tI(DstReg | SrcMemFAddr | ModRM | Src2FS, em_lseg),\n\tI(DstReg | SrcMemFAddr | ModRM | Src2GS, em_lseg),\n\tD(DstReg | SrcMem8 | ModRM | Mov), D(DstReg | SrcMem16 | ModRM | Mov),\n\t/* 0xB8 - 0xBF */\n\tN, N,\n\tG(BitOp, group8),\n\tF(DstMem | SrcReg | ModRM | BitOp | Lock | PageTable, em_btc),\n\tI(DstReg | SrcMem | ModRM, em_bsf_c),\n\tI(DstReg | SrcMem | ModRM, em_bsr_c),\n\tD(DstReg | SrcMem8 | ModRM | Mov), D(DstReg | SrcMem16 | ModRM | Mov),\n\t/* 0xC0 - 0xC7 */\n\tF2bv(DstMem | SrcReg | ModRM | SrcWrite | Lock, em_xadd),\n\tN, ID(0, &instr_dual_0f_c3),\n\tN, N, N, GD(0, &group9),\n\t/* 0xC8 - 0xCF */\n\tX8(I(DstReg, em_bswap)),\n\t/* 0xD0 - 0xDF */\n\tN, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N,\n\t/* 0xE0 - 0xEF */\n\tN, N, N, N, N, N, N, GP(SrcReg | DstMem | ModRM | Mov, &pfx_0f_e7),\n\tN, N, N, N, N, N, N, N,\n\t/* 0xF0 - 0xFF */\n\tN, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N\n};",
      "static const struct opcode opcode_map_0f_38[256] = {\n\t/* 0x00 - 0x7f */\n\tX16(N), X16(N), X16(N), X16(N), X16(N), X16(N), X16(N), X16(N),\n\t/* 0x80 - 0xef */\n\tX16(N), X16(N), X16(N), X16(N), X16(N), X16(N), X16(N),\n\t/* 0xf0 - 0xf1 */\n\tGP(EmulateOnUD | ModRM, &three_byte_0f_38_f0),\n\tGP(EmulateOnUD | ModRM, &three_byte_0f_38_f1),\n\t/* 0xf2 - 0xff */\n\tN, N, X4(N), X8(N)\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "address_mask",
          "args": [
            "ctxt",
            "ctxt->memopp->addr.mem.ea + ctxt->_eip"
          ],
          "line": 5050
        },
        "resolved": true,
        "details": {
          "function_name": "address_mask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "517-524",
          "snippet": "static inline unsigned long\naddress_mask(struct x86_emulate_ctxt *ctxt, unsigned long reg)\n{\n\tif (ctxt->ad_bytes == sizeof(unsigned long))\n\t\treturn reg;\n\telse\n\t\treturn reg & ad_mask(ctxt);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline unsigned long\naddress_mask(struct x86_emulate_ctxt *ctxt, unsigned long reg)\n{\n\tif (ctxt->ad_bytes == sizeof(unsigned long))\n\t\treturn reg;\n\telse\n\t\treturn reg & ad_mask(ctxt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "decode_operand",
          "args": [
            "ctxt",
            "&ctxt->dst",
            "(ctxt->d >> DstShift) & OpMask"
          ],
          "line": 5047
        },
        "resolved": true,
        "details": {
          "function_name": "decode_operand",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "4622-4786",
          "snippet": "static int decode_operand(struct x86_emulate_ctxt *ctxt, struct operand *op,\n\t\t\t  unsigned d)\n{\n\tint rc = X86EMUL_CONTINUE;\n\n\tswitch (d) {\n\tcase OpReg:\n\t\tdecode_register_operand(ctxt, op);\n\t\tbreak;\n\tcase OpImmUByte:\n\t\trc = decode_imm(ctxt, op, 1, false);\n\t\tbreak;\n\tcase OpMem:\n\t\tctxt->memop.bytes = (ctxt->d & ByteOp) ? 1 : ctxt->op_bytes;\n\tmem_common:\n\t\t*op = ctxt->memop;\n\t\tctxt->memopp = op;\n\t\tif (ctxt->d & BitOp)\n\t\t\tfetch_bit_operand(ctxt);\n\t\top->orig_val = op->val;\n\t\tbreak;\n\tcase OpMem64:\n\t\tctxt->memop.bytes = (ctxt->op_bytes == 8) ? 16 : 8;\n\t\tgoto mem_common;\n\tcase OpAcc:\n\t\top->type = OP_REG;\n\t\top->bytes = (ctxt->d & ByteOp) ? 1 : ctxt->op_bytes;\n\t\top->addr.reg = reg_rmw(ctxt, VCPU_REGS_RAX);\n\t\tfetch_register_operand(op);\n\t\top->orig_val = op->val;\n\t\tbreak;\n\tcase OpAccLo:\n\t\top->type = OP_REG;\n\t\top->bytes = (ctxt->d & ByteOp) ? 2 : ctxt->op_bytes;\n\t\top->addr.reg = reg_rmw(ctxt, VCPU_REGS_RAX);\n\t\tfetch_register_operand(op);\n\t\top->orig_val = op->val;\n\t\tbreak;\n\tcase OpAccHi:\n\t\tif (ctxt->d & ByteOp) {\n\t\t\top->type = OP_NONE;\n\t\t\tbreak;\n\t\t}\n\t\top->type = OP_REG;\n\t\top->bytes = ctxt->op_bytes;\n\t\top->addr.reg = reg_rmw(ctxt, VCPU_REGS_RDX);\n\t\tfetch_register_operand(op);\n\t\top->orig_val = op->val;\n\t\tbreak;\n\tcase OpDI:\n\t\top->type = OP_MEM;\n\t\top->bytes = (ctxt->d & ByteOp) ? 1 : ctxt->op_bytes;\n\t\top->addr.mem.ea =\n\t\t\tregister_address(ctxt, VCPU_REGS_RDI);\n\t\top->addr.mem.seg = VCPU_SREG_ES;\n\t\top->val = 0;\n\t\top->count = 1;\n\t\tbreak;\n\tcase OpDX:\n\t\top->type = OP_REG;\n\t\top->bytes = 2;\n\t\top->addr.reg = reg_rmw(ctxt, VCPU_REGS_RDX);\n\t\tfetch_register_operand(op);\n\t\tbreak;\n\tcase OpCL:\n\t\top->type = OP_IMM;\n\t\top->bytes = 1;\n\t\top->val = reg_read(ctxt, VCPU_REGS_RCX) & 0xff;\n\t\tbreak;\n\tcase OpImmByte:\n\t\trc = decode_imm(ctxt, op, 1, true);\n\t\tbreak;\n\tcase OpOne:\n\t\top->type = OP_IMM;\n\t\top->bytes = 1;\n\t\top->val = 1;\n\t\tbreak;\n\tcase OpImm:\n\t\trc = decode_imm(ctxt, op, imm_size(ctxt), true);\n\t\tbreak;\n\tcase OpImm64:\n\t\trc = decode_imm(ctxt, op, ctxt->op_bytes, true);\n\t\tbreak;\n\tcase OpMem8:\n\t\tctxt->memop.bytes = 1;\n\t\tif (ctxt->memop.type == OP_REG) {\n\t\t\tctxt->memop.addr.reg = decode_register(ctxt,\n\t\t\t\t\tctxt->modrm_rm, true);\n\t\t\tfetch_register_operand(&ctxt->memop);\n\t\t}\n\t\tgoto mem_common;\n\tcase OpMem16:\n\t\tctxt->memop.bytes = 2;\n\t\tgoto mem_common;\n\tcase OpMem32:\n\t\tctxt->memop.bytes = 4;\n\t\tgoto mem_common;\n\tcase OpImmU16:\n\t\trc = decode_imm(ctxt, op, 2, false);\n\t\tbreak;\n\tcase OpImmU:\n\t\trc = decode_imm(ctxt, op, imm_size(ctxt), false);\n\t\tbreak;\n\tcase OpSI:\n\t\top->type = OP_MEM;\n\t\top->bytes = (ctxt->d & ByteOp) ? 1 : ctxt->op_bytes;\n\t\top->addr.mem.ea =\n\t\t\tregister_address(ctxt, VCPU_REGS_RSI);\n\t\top->addr.mem.seg = ctxt->seg_override;\n\t\top->val = 0;\n\t\top->count = 1;\n\t\tbreak;\n\tcase OpXLat:\n\t\top->type = OP_MEM;\n\t\top->bytes = (ctxt->d & ByteOp) ? 1 : ctxt->op_bytes;\n\t\top->addr.mem.ea =\n\t\t\taddress_mask(ctxt,\n\t\t\t\treg_read(ctxt, VCPU_REGS_RBX) +\n\t\t\t\t(reg_read(ctxt, VCPU_REGS_RAX) & 0xff));\n\t\top->addr.mem.seg = ctxt->seg_override;\n\t\top->val = 0;\n\t\tbreak;\n\tcase OpImmFAddr:\n\t\top->type = OP_IMM;\n\t\top->addr.mem.ea = ctxt->_eip;\n\t\top->bytes = ctxt->op_bytes + 2;\n\t\tinsn_fetch_arr(op->valptr, op->bytes, ctxt);\n\t\tbreak;\n\tcase OpMemFAddr:\n\t\tctxt->memop.bytes = ctxt->op_bytes + 2;\n\t\tgoto mem_common;\n\tcase OpES:\n\t\top->type = OP_IMM;\n\t\top->val = VCPU_SREG_ES;\n\t\tbreak;\n\tcase OpCS:\n\t\top->type = OP_IMM;\n\t\top->val = VCPU_SREG_CS;\n\t\tbreak;\n\tcase OpSS:\n\t\top->type = OP_IMM;\n\t\top->val = VCPU_SREG_SS;\n\t\tbreak;\n\tcase OpDS:\n\t\top->type = OP_IMM;\n\t\top->val = VCPU_SREG_DS;\n\t\tbreak;\n\tcase OpFS:\n\t\top->type = OP_IMM;\n\t\top->val = VCPU_SREG_FS;\n\t\tbreak;\n\tcase OpGS:\n\t\top->type = OP_IMM;\n\t\top->val = VCPU_SREG_GS;\n\t\tbreak;\n\tcase OpImplicit:\n\t\t/* Special instructions do their own operand decoding. */\n\tdefault:\n\t\top->type = OP_NONE; /* Disable writeback. */\n\t\tbreak;\n\t}\n\ndone:\n\treturn rc;\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define BitOp       (1<<11)",
            "#define ByteOp      (1<<0)\t/* 8-bit operands. */",
            "#define OpAccHi           30ull  /* High part of extended acc (-/DX/EDX/RDX) */",
            "#define OpAccLo           29ull  /* Low part of extended acc (AX/AX/EAX/RAX) */",
            "#define OpXLat            28ull  /* memory at BX/EBX/RBX + zero-extended AL */",
            "#define OpImm64           27ull  /* Sign extended 16/32/64-bit immediate */",
            "#define OpMem8            26ull  /* 8-bit zero extended memory operand */",
            "#define OpGS              25ull  /* GS */",
            "#define OpFS              24ull  /* FS */",
            "#define OpDS              23ull  /* DS */",
            "#define OpSS              22ull  /* SS */",
            "#define OpCS              21ull  /* CS */",
            "#define OpES              20ull  /* ES */",
            "#define OpImmU16          19ull  /* Immediate operand, 16 bits, zero extended */",
            "#define OpMemFAddr        18ull  /* Far address in memory */",
            "#define OpImmFAddr        17ull  /* Immediate far address */",
            "#define OpSI              16ull  /* SI/ESI/RSI */",
            "#define OpImmU            15ull  /* Immediate operand, zero extended */",
            "#define OpMem32           14ull  /* Memory operand (32-bit). */",
            "#define OpMem16           13ull  /* Memory operand (16-bit). */",
            "#define OpImm             12ull  /* Sign extended up to 32-bit immediate */",
            "#define OpOne             11ull  /* Implied 1 */",
            "#define OpImmByte         10ull  /* 8-bit sign extended immediate */",
            "#define OpCL               9ull  /* CL register (for shifts) */",
            "#define OpDX               8ull  /* DX register */",
            "#define OpImmUByte         7ull  /* Zero-extended 8-bit immediate */",
            "#define OpMem64            6ull  /* Memory, 64-bit */",
            "#define OpDI               5ull  /* ES:DI/EDI/RDI */",
            "#define OpAcc              4ull  /* Accumulator: AL/AX/EAX/RAX */",
            "#define OpMem              3ull  /* Memory */",
            "#define OpReg              2ull  /* Register */",
            "#define OpImplicit         1ull  /* No generic decode */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\n#define BitOp       (1<<11)\n#define ByteOp      (1<<0)\t/* 8-bit operands. */\n#define OpAccHi           30ull  /* High part of extended acc (-/DX/EDX/RDX) */\n#define OpAccLo           29ull  /* Low part of extended acc (AX/AX/EAX/RAX) */\n#define OpXLat            28ull  /* memory at BX/EBX/RBX + zero-extended AL */\n#define OpImm64           27ull  /* Sign extended 16/32/64-bit immediate */\n#define OpMem8            26ull  /* 8-bit zero extended memory operand */\n#define OpGS              25ull  /* GS */\n#define OpFS              24ull  /* FS */\n#define OpDS              23ull  /* DS */\n#define OpSS              22ull  /* SS */\n#define OpCS              21ull  /* CS */\n#define OpES              20ull  /* ES */\n#define OpImmU16          19ull  /* Immediate operand, 16 bits, zero extended */\n#define OpMemFAddr        18ull  /* Far address in memory */\n#define OpImmFAddr        17ull  /* Immediate far address */\n#define OpSI              16ull  /* SI/ESI/RSI */\n#define OpImmU            15ull  /* Immediate operand, zero extended */\n#define OpMem32           14ull  /* Memory operand (32-bit). */\n#define OpMem16           13ull  /* Memory operand (16-bit). */\n#define OpImm             12ull  /* Sign extended up to 32-bit immediate */\n#define OpOne             11ull  /* Implied 1 */\n#define OpImmByte         10ull  /* 8-bit sign extended immediate */\n#define OpCL               9ull  /* CL register (for shifts) */\n#define OpDX               8ull  /* DX register */\n#define OpImmUByte         7ull  /* Zero-extended 8-bit immediate */\n#define OpMem64            6ull  /* Memory, 64-bit */\n#define OpDI               5ull  /* ES:DI/EDI/RDI */\n#define OpAcc              4ull  /* Accumulator: AL/AX/EAX/RAX */\n#define OpMem              3ull  /* Memory */\n#define OpReg              2ull  /* Register */\n#define OpImplicit         1ull  /* No generic decode */\n\nstatic int decode_operand(struct x86_emulate_ctxt *ctxt, struct operand *op,\n\t\t\t  unsigned d)\n{\n\tint rc = X86EMUL_CONTINUE;\n\n\tswitch (d) {\n\tcase OpReg:\n\t\tdecode_register_operand(ctxt, op);\n\t\tbreak;\n\tcase OpImmUByte:\n\t\trc = decode_imm(ctxt, op, 1, false);\n\t\tbreak;\n\tcase OpMem:\n\t\tctxt->memop.bytes = (ctxt->d & ByteOp) ? 1 : ctxt->op_bytes;\n\tmem_common:\n\t\t*op = ctxt->memop;\n\t\tctxt->memopp = op;\n\t\tif (ctxt->d & BitOp)\n\t\t\tfetch_bit_operand(ctxt);\n\t\top->orig_val = op->val;\n\t\tbreak;\n\tcase OpMem64:\n\t\tctxt->memop.bytes = (ctxt->op_bytes == 8) ? 16 : 8;\n\t\tgoto mem_common;\n\tcase OpAcc:\n\t\top->type = OP_REG;\n\t\top->bytes = (ctxt->d & ByteOp) ? 1 : ctxt->op_bytes;\n\t\top->addr.reg = reg_rmw(ctxt, VCPU_REGS_RAX);\n\t\tfetch_register_operand(op);\n\t\top->orig_val = op->val;\n\t\tbreak;\n\tcase OpAccLo:\n\t\top->type = OP_REG;\n\t\top->bytes = (ctxt->d & ByteOp) ? 2 : ctxt->op_bytes;\n\t\top->addr.reg = reg_rmw(ctxt, VCPU_REGS_RAX);\n\t\tfetch_register_operand(op);\n\t\top->orig_val = op->val;\n\t\tbreak;\n\tcase OpAccHi:\n\t\tif (ctxt->d & ByteOp) {\n\t\t\top->type = OP_NONE;\n\t\t\tbreak;\n\t\t}\n\t\top->type = OP_REG;\n\t\top->bytes = ctxt->op_bytes;\n\t\top->addr.reg = reg_rmw(ctxt, VCPU_REGS_RDX);\n\t\tfetch_register_operand(op);\n\t\top->orig_val = op->val;\n\t\tbreak;\n\tcase OpDI:\n\t\top->type = OP_MEM;\n\t\top->bytes = (ctxt->d & ByteOp) ? 1 : ctxt->op_bytes;\n\t\top->addr.mem.ea =\n\t\t\tregister_address(ctxt, VCPU_REGS_RDI);\n\t\top->addr.mem.seg = VCPU_SREG_ES;\n\t\top->val = 0;\n\t\top->count = 1;\n\t\tbreak;\n\tcase OpDX:\n\t\top->type = OP_REG;\n\t\top->bytes = 2;\n\t\top->addr.reg = reg_rmw(ctxt, VCPU_REGS_RDX);\n\t\tfetch_register_operand(op);\n\t\tbreak;\n\tcase OpCL:\n\t\top->type = OP_IMM;\n\t\top->bytes = 1;\n\t\top->val = reg_read(ctxt, VCPU_REGS_RCX) & 0xff;\n\t\tbreak;\n\tcase OpImmByte:\n\t\trc = decode_imm(ctxt, op, 1, true);\n\t\tbreak;\n\tcase OpOne:\n\t\top->type = OP_IMM;\n\t\top->bytes = 1;\n\t\top->val = 1;\n\t\tbreak;\n\tcase OpImm:\n\t\trc = decode_imm(ctxt, op, imm_size(ctxt), true);\n\t\tbreak;\n\tcase OpImm64:\n\t\trc = decode_imm(ctxt, op, ctxt->op_bytes, true);\n\t\tbreak;\n\tcase OpMem8:\n\t\tctxt->memop.bytes = 1;\n\t\tif (ctxt->memop.type == OP_REG) {\n\t\t\tctxt->memop.addr.reg = decode_register(ctxt,\n\t\t\t\t\tctxt->modrm_rm, true);\n\t\t\tfetch_register_operand(&ctxt->memop);\n\t\t}\n\t\tgoto mem_common;\n\tcase OpMem16:\n\t\tctxt->memop.bytes = 2;\n\t\tgoto mem_common;\n\tcase OpMem32:\n\t\tctxt->memop.bytes = 4;\n\t\tgoto mem_common;\n\tcase OpImmU16:\n\t\trc = decode_imm(ctxt, op, 2, false);\n\t\tbreak;\n\tcase OpImmU:\n\t\trc = decode_imm(ctxt, op, imm_size(ctxt), false);\n\t\tbreak;\n\tcase OpSI:\n\t\top->type = OP_MEM;\n\t\top->bytes = (ctxt->d & ByteOp) ? 1 : ctxt->op_bytes;\n\t\top->addr.mem.ea =\n\t\t\tregister_address(ctxt, VCPU_REGS_RSI);\n\t\top->addr.mem.seg = ctxt->seg_override;\n\t\top->val = 0;\n\t\top->count = 1;\n\t\tbreak;\n\tcase OpXLat:\n\t\top->type = OP_MEM;\n\t\top->bytes = (ctxt->d & ByteOp) ? 1 : ctxt->op_bytes;\n\t\top->addr.mem.ea =\n\t\t\taddress_mask(ctxt,\n\t\t\t\treg_read(ctxt, VCPU_REGS_RBX) +\n\t\t\t\t(reg_read(ctxt, VCPU_REGS_RAX) & 0xff));\n\t\top->addr.mem.seg = ctxt->seg_override;\n\t\top->val = 0;\n\t\tbreak;\n\tcase OpImmFAddr:\n\t\top->type = OP_IMM;\n\t\top->addr.mem.ea = ctxt->_eip;\n\t\top->bytes = ctxt->op_bytes + 2;\n\t\tinsn_fetch_arr(op->valptr, op->bytes, ctxt);\n\t\tbreak;\n\tcase OpMemFAddr:\n\t\tctxt->memop.bytes = ctxt->op_bytes + 2;\n\t\tgoto mem_common;\n\tcase OpES:\n\t\top->type = OP_IMM;\n\t\top->val = VCPU_SREG_ES;\n\t\tbreak;\n\tcase OpCS:\n\t\top->type = OP_IMM;\n\t\top->val = VCPU_SREG_CS;\n\t\tbreak;\n\tcase OpSS:\n\t\top->type = OP_IMM;\n\t\top->val = VCPU_SREG_SS;\n\t\tbreak;\n\tcase OpDS:\n\t\top->type = OP_IMM;\n\t\top->val = VCPU_SREG_DS;\n\t\tbreak;\n\tcase OpFS:\n\t\top->type = OP_IMM;\n\t\top->val = VCPU_SREG_FS;\n\t\tbreak;\n\tcase OpGS:\n\t\top->type = OP_IMM;\n\t\top->val = VCPU_SREG_GS;\n\t\tbreak;\n\tcase OpImplicit:\n\t\t/* Special instructions do their own operand decoding. */\n\tdefault:\n\t\top->type = OP_NONE; /* Disable writeback. */\n\t\tbreak;\n\t}\n\ndone:\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "decode_abs",
          "args": [
            "ctxt",
            "&ctxt->memop"
          ],
          "line": 5021
        },
        "resolved": true,
        "details": {
          "function_name": "decode_abs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "1307-1326",
          "snippet": "static int decode_abs(struct x86_emulate_ctxt *ctxt,\n\t\t      struct operand *op)\n{\n\tint rc = X86EMUL_CONTINUE;\n\n\top->type = OP_MEM;\n\tswitch (ctxt->ad_bytes) {\n\tcase 2:\n\t\top->addr.mem.ea = insn_fetch(u16, ctxt);\n\t\tbreak;\n\tcase 4:\n\t\top->addr.mem.ea = insn_fetch(u32, ctxt);\n\t\tbreak;\n\tcase 8:\n\t\top->addr.mem.ea = insn_fetch(u64, ctxt);\n\t\tbreak;\n\t}\ndone:\n\treturn rc;\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int decode_abs(struct x86_emulate_ctxt *ctxt,\n\t\t      struct operand *op)\n{\n\tint rc = X86EMUL_CONTINUE;\n\n\top->type = OP_MEM;\n\tswitch (ctxt->ad_bytes) {\n\tcase 2:\n\t\top->addr.mem.ea = insn_fetch(u16, ctxt);\n\t\tbreak;\n\tcase 4:\n\t\top->addr.mem.ea = insn_fetch(u32, ctxt);\n\t\tbreak;\n\tcase 8:\n\t\top->addr.mem.ea = insn_fetch(u64, ctxt);\n\t\tbreak;\n\t}\ndone:\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "decode_modrm",
          "args": [
            "ctxt",
            "&ctxt->memop"
          ],
          "line": 5015
        },
        "resolved": true,
        "details": {
          "function_name": "decode_modrm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "1170-1305",
          "snippet": "static int decode_modrm(struct x86_emulate_ctxt *ctxt,\n\t\t\tstruct operand *op)\n{\n\tu8 sib;\n\tint index_reg, base_reg, scale;\n\tint rc = X86EMUL_CONTINUE;\n\tulong modrm_ea = 0;\n\n\tctxt->modrm_reg = ((ctxt->rex_prefix << 1) & 8); /* REX.R */\n\tindex_reg = (ctxt->rex_prefix << 2) & 8; /* REX.X */\n\tbase_reg = (ctxt->rex_prefix << 3) & 8; /* REX.B */\n\n\tctxt->modrm_mod = (ctxt->modrm & 0xc0) >> 6;\n\tctxt->modrm_reg |= (ctxt->modrm & 0x38) >> 3;\n\tctxt->modrm_rm = base_reg | (ctxt->modrm & 0x07);\n\tctxt->modrm_seg = VCPU_SREG_DS;\n\n\tif (ctxt->modrm_mod == 3 || (ctxt->d & NoMod)) {\n\t\top->type = OP_REG;\n\t\top->bytes = (ctxt->d & ByteOp) ? 1 : ctxt->op_bytes;\n\t\top->addr.reg = decode_register(ctxt, ctxt->modrm_rm,\n\t\t\t\tctxt->d & ByteOp);\n\t\tif (ctxt->d & Sse) {\n\t\t\top->type = OP_XMM;\n\t\t\top->bytes = 16;\n\t\t\top->addr.xmm = ctxt->modrm_rm;\n\t\t\tread_sse_reg(ctxt, &op->vec_val, ctxt->modrm_rm);\n\t\t\treturn rc;\n\t\t}\n\t\tif (ctxt->d & Mmx) {\n\t\t\top->type = OP_MM;\n\t\t\top->bytes = 8;\n\t\t\top->addr.mm = ctxt->modrm_rm & 7;\n\t\t\treturn rc;\n\t\t}\n\t\tfetch_register_operand(op);\n\t\treturn rc;\n\t}\n\n\top->type = OP_MEM;\n\n\tif (ctxt->ad_bytes == 2) {\n\t\tunsigned bx = reg_read(ctxt, VCPU_REGS_RBX);\n\t\tunsigned bp = reg_read(ctxt, VCPU_REGS_RBP);\n\t\tunsigned si = reg_read(ctxt, VCPU_REGS_RSI);\n\t\tunsigned di = reg_read(ctxt, VCPU_REGS_RDI);\n\n\t\t/* 16-bit ModR/M decode. */\n\t\tswitch (ctxt->modrm_mod) {\n\t\tcase 0:\n\t\t\tif (ctxt->modrm_rm == 6)\n\t\t\t\tmodrm_ea += insn_fetch(u16, ctxt);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tmodrm_ea += insn_fetch(s8, ctxt);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tmodrm_ea += insn_fetch(u16, ctxt);\n\t\t\tbreak;\n\t\t}\n\t\tswitch (ctxt->modrm_rm) {\n\t\tcase 0:\n\t\t\tmodrm_ea += bx + si;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tmodrm_ea += bx + di;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tmodrm_ea += bp + si;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tmodrm_ea += bp + di;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tmodrm_ea += si;\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tmodrm_ea += di;\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\tif (ctxt->modrm_mod != 0)\n\t\t\t\tmodrm_ea += bp;\n\t\t\tbreak;\n\t\tcase 7:\n\t\t\tmodrm_ea += bx;\n\t\t\tbreak;\n\t\t}\n\t\tif (ctxt->modrm_rm == 2 || ctxt->modrm_rm == 3 ||\n\t\t    (ctxt->modrm_rm == 6 && ctxt->modrm_mod != 0))\n\t\t\tctxt->modrm_seg = VCPU_SREG_SS;\n\t\tmodrm_ea = (u16)modrm_ea;\n\t} else {\n\t\t/* 32/64-bit ModR/M decode. */\n\t\tif ((ctxt->modrm_rm & 7) == 4) {\n\t\t\tsib = insn_fetch(u8, ctxt);\n\t\t\tindex_reg |= (sib >> 3) & 7;\n\t\t\tbase_reg |= sib & 7;\n\t\t\tscale = sib >> 6;\n\n\t\t\tif ((base_reg & 7) == 5 && ctxt->modrm_mod == 0)\n\t\t\t\tmodrm_ea += insn_fetch(s32, ctxt);\n\t\t\telse {\n\t\t\t\tmodrm_ea += reg_read(ctxt, base_reg);\n\t\t\t\tadjust_modrm_seg(ctxt, base_reg);\n\t\t\t\t/* Increment ESP on POP [ESP] */\n\t\t\t\tif ((ctxt->d & IncSP) &&\n\t\t\t\t    base_reg == VCPU_REGS_RSP)\n\t\t\t\t\tmodrm_ea += ctxt->op_bytes;\n\t\t\t}\n\t\t\tif (index_reg != 4)\n\t\t\t\tmodrm_ea += reg_read(ctxt, index_reg) << scale;\n\t\t} else if ((ctxt->modrm_rm & 7) == 5 && ctxt->modrm_mod == 0) {\n\t\t\tmodrm_ea += insn_fetch(s32, ctxt);\n\t\t\tif (ctxt->mode == X86EMUL_MODE_PROT64)\n\t\t\t\tctxt->rip_relative = 1;\n\t\t} else {\n\t\t\tbase_reg = ctxt->modrm_rm;\n\t\t\tmodrm_ea += reg_read(ctxt, base_reg);\n\t\t\tadjust_modrm_seg(ctxt, base_reg);\n\t\t}\n\t\tswitch (ctxt->modrm_mod) {\n\t\tcase 1:\n\t\t\tmodrm_ea += insn_fetch(s8, ctxt);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tmodrm_ea += insn_fetch(s32, ctxt);\n\t\t\tbreak;\n\t\t}\n\t}\n\top->addr.mem.ea = modrm_ea;\n\tif (ctxt->ad_bytes != 8)\n\t\tctxt->memop.addr.mem.ea = (u32)ctxt->memop.addr.mem.ea;\n\ndone:\n\treturn rc;\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define IncSP       ((u64)1 << 54)  /* SP is incremented before ModRM calc */",
            "#define NoMod\t    ((u64)1 << 47)  /* Mod field is ignored */",
            "#define Mmx         ((u64)1 << 40)  /* MMX Vector instruction */",
            "#define Sse         (1<<18)     /* SSE Vector instruction */",
            "#define ByteOp      (1<<0)\t/* 8-bit operands. */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\n#define IncSP       ((u64)1 << 54)  /* SP is incremented before ModRM calc */\n#define NoMod\t    ((u64)1 << 47)  /* Mod field is ignored */\n#define Mmx         ((u64)1 << 40)  /* MMX Vector instruction */\n#define Sse         (1<<18)     /* SSE Vector instruction */\n#define ByteOp      (1<<0)\t/* 8-bit operands. */\n\nstatic int decode_modrm(struct x86_emulate_ctxt *ctxt,\n\t\t\tstruct operand *op)\n{\n\tu8 sib;\n\tint index_reg, base_reg, scale;\n\tint rc = X86EMUL_CONTINUE;\n\tulong modrm_ea = 0;\n\n\tctxt->modrm_reg = ((ctxt->rex_prefix << 1) & 8); /* REX.R */\n\tindex_reg = (ctxt->rex_prefix << 2) & 8; /* REX.X */\n\tbase_reg = (ctxt->rex_prefix << 3) & 8; /* REX.B */\n\n\tctxt->modrm_mod = (ctxt->modrm & 0xc0) >> 6;\n\tctxt->modrm_reg |= (ctxt->modrm & 0x38) >> 3;\n\tctxt->modrm_rm = base_reg | (ctxt->modrm & 0x07);\n\tctxt->modrm_seg = VCPU_SREG_DS;\n\n\tif (ctxt->modrm_mod == 3 || (ctxt->d & NoMod)) {\n\t\top->type = OP_REG;\n\t\top->bytes = (ctxt->d & ByteOp) ? 1 : ctxt->op_bytes;\n\t\top->addr.reg = decode_register(ctxt, ctxt->modrm_rm,\n\t\t\t\tctxt->d & ByteOp);\n\t\tif (ctxt->d & Sse) {\n\t\t\top->type = OP_XMM;\n\t\t\top->bytes = 16;\n\t\t\top->addr.xmm = ctxt->modrm_rm;\n\t\t\tread_sse_reg(ctxt, &op->vec_val, ctxt->modrm_rm);\n\t\t\treturn rc;\n\t\t}\n\t\tif (ctxt->d & Mmx) {\n\t\t\top->type = OP_MM;\n\t\t\top->bytes = 8;\n\t\t\top->addr.mm = ctxt->modrm_rm & 7;\n\t\t\treturn rc;\n\t\t}\n\t\tfetch_register_operand(op);\n\t\treturn rc;\n\t}\n\n\top->type = OP_MEM;\n\n\tif (ctxt->ad_bytes == 2) {\n\t\tunsigned bx = reg_read(ctxt, VCPU_REGS_RBX);\n\t\tunsigned bp = reg_read(ctxt, VCPU_REGS_RBP);\n\t\tunsigned si = reg_read(ctxt, VCPU_REGS_RSI);\n\t\tunsigned di = reg_read(ctxt, VCPU_REGS_RDI);\n\n\t\t/* 16-bit ModR/M decode. */\n\t\tswitch (ctxt->modrm_mod) {\n\t\tcase 0:\n\t\t\tif (ctxt->modrm_rm == 6)\n\t\t\t\tmodrm_ea += insn_fetch(u16, ctxt);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tmodrm_ea += insn_fetch(s8, ctxt);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tmodrm_ea += insn_fetch(u16, ctxt);\n\t\t\tbreak;\n\t\t}\n\t\tswitch (ctxt->modrm_rm) {\n\t\tcase 0:\n\t\t\tmodrm_ea += bx + si;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tmodrm_ea += bx + di;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tmodrm_ea += bp + si;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tmodrm_ea += bp + di;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tmodrm_ea += si;\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tmodrm_ea += di;\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\tif (ctxt->modrm_mod != 0)\n\t\t\t\tmodrm_ea += bp;\n\t\t\tbreak;\n\t\tcase 7:\n\t\t\tmodrm_ea += bx;\n\t\t\tbreak;\n\t\t}\n\t\tif (ctxt->modrm_rm == 2 || ctxt->modrm_rm == 3 ||\n\t\t    (ctxt->modrm_rm == 6 && ctxt->modrm_mod != 0))\n\t\t\tctxt->modrm_seg = VCPU_SREG_SS;\n\t\tmodrm_ea = (u16)modrm_ea;\n\t} else {\n\t\t/* 32/64-bit ModR/M decode. */\n\t\tif ((ctxt->modrm_rm & 7) == 4) {\n\t\t\tsib = insn_fetch(u8, ctxt);\n\t\t\tindex_reg |= (sib >> 3) & 7;\n\t\t\tbase_reg |= sib & 7;\n\t\t\tscale = sib >> 6;\n\n\t\t\tif ((base_reg & 7) == 5 && ctxt->modrm_mod == 0)\n\t\t\t\tmodrm_ea += insn_fetch(s32, ctxt);\n\t\t\telse {\n\t\t\t\tmodrm_ea += reg_read(ctxt, base_reg);\n\t\t\t\tadjust_modrm_seg(ctxt, base_reg);\n\t\t\t\t/* Increment ESP on POP [ESP] */\n\t\t\t\tif ((ctxt->d & IncSP) &&\n\t\t\t\t    base_reg == VCPU_REGS_RSP)\n\t\t\t\t\tmodrm_ea += ctxt->op_bytes;\n\t\t\t}\n\t\t\tif (index_reg != 4)\n\t\t\t\tmodrm_ea += reg_read(ctxt, index_reg) << scale;\n\t\t} else if ((ctxt->modrm_rm & 7) == 5 && ctxt->modrm_mod == 0) {\n\t\t\tmodrm_ea += insn_fetch(s32, ctxt);\n\t\t\tif (ctxt->mode == X86EMUL_MODE_PROT64)\n\t\t\t\tctxt->rip_relative = 1;\n\t\t} else {\n\t\t\tbase_reg = ctxt->modrm_rm;\n\t\t\tmodrm_ea += reg_read(ctxt, base_reg);\n\t\t\tadjust_modrm_seg(ctxt, base_reg);\n\t\t}\n\t\tswitch (ctxt->modrm_mod) {\n\t\tcase 1:\n\t\t\tmodrm_ea += insn_fetch(s8, ctxt);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tmodrm_ea += insn_fetch(s32, ctxt);\n\t\t\tbreak;\n\t\t}\n\t}\n\top->addr.mem.ea = modrm_ea;\n\tif (ctxt->ad_bytes != 8)\n\t\tctxt->memop.addr.mem.ea = (u32)ctxt->memop.addr.mem.ea;\n\ndone:\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ctxt->d &\n\t    (NotImpl|Stack|Op3264|Sse|Mmx|Intercept|CheckPerm|NearBranch|\n\t     No16)"
          ],
          "line": 4977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!(ctxt->d & EmulateOnUD)"
          ],
          "line": 4974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ctxt->ud"
          ],
          "line": 4974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "insn_fetch",
          "args": [
            "u8",
            "ctxt"
          ],
          "line": 4906
        },
        "resolved": true,
        "details": {
          "function_name": "do_insn_fetch_bytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "843-852",
          "snippet": "static __always_inline int do_insn_fetch_bytes(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t\t       unsigned size)\n{\n\tunsigned done_size = ctxt->fetch.end - ctxt->fetch.ptr;\n\n\tif (unlikely(done_size < size))\n\t\treturn __do_insn_fetch_bytes(ctxt, size - done_size);\n\telse\n\t\treturn X86EMUL_CONTINUE;\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic __always_inline int do_insn_fetch_bytes(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t\t       unsigned size)\n{\n\tunsigned done_size = ctxt->fetch.end - ctxt->fetch.ptr;\n\n\tif (unlikely(done_size < size))\n\t\treturn __do_insn_fetch_bytes(ctxt, size - done_size);\n\telse\n\t\treturn X86EMUL_CONTINUE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__do_insn_fetch_bytes",
          "args": [
            "ctxt",
            "1"
          ],
          "line": 4806
        },
        "resolved": true,
        "details": {
          "function_name": "__do_insn_fetch_bytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "799-841",
          "snippet": "static int __do_insn_fetch_bytes(struct x86_emulate_ctxt *ctxt, int op_size)\n{\n\tint rc;\n\tunsigned size, max_size;\n\tunsigned long linear;\n\tint cur_size = ctxt->fetch.end - ctxt->fetch.data;\n\tstruct segmented_address addr = { .seg = VCPU_SREG_CS,\n\t\t\t\t\t   .ea = ctxt->eip + cur_size };\n\n\t/*\n\t * We do not know exactly how many bytes will be needed, and\n\t * __linearize is expensive, so fetch as much as possible.  We\n\t * just have to avoid going beyond the 15 byte limit, the end\n\t * of the segment, or the end of the page.\n\t *\n\t * __linearize is called with size 0 so that it does not do any\n\t * boundary check itself.  Instead, we use max_size to check\n\t * against op_size.\n\t */\n\trc = __linearize(ctxt, addr, &max_size, 0, false, true, ctxt->mode,\n\t\t\t &linear);\n\tif (unlikely(rc != X86EMUL_CONTINUE))\n\t\treturn rc;\n\n\tsize = min_t(unsigned, 15UL ^ cur_size, max_size);\n\tsize = min_t(unsigned, size, PAGE_SIZE - offset_in_page(linear));\n\n\t/*\n\t * One instruction can only straddle two pages,\n\t * and one has been loaded at the beginning of\n\t * x86_decode_insn.  So, if not enough bytes\n\t * still, we must have hit the 15-byte boundary.\n\t */\n\tif (unlikely(size < op_size))\n\t\treturn emulate_gp(ctxt, 0);\n\n\trc = ctxt->ops->fetch(ctxt, linear, ctxt->fetch.end,\n\t\t\t      size, &ctxt->exception);\n\tif (unlikely(rc != X86EMUL_CONTINUE))\n\t\treturn rc;\n\tctxt->fetch.end += size;\n\treturn X86EMUL_CONTINUE;\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int __do_insn_fetch_bytes(struct x86_emulate_ctxt *ctxt, int op_size)\n{\n\tint rc;\n\tunsigned size, max_size;\n\tunsigned long linear;\n\tint cur_size = ctxt->fetch.end - ctxt->fetch.data;\n\tstruct segmented_address addr = { .seg = VCPU_SREG_CS,\n\t\t\t\t\t   .ea = ctxt->eip + cur_size };\n\n\t/*\n\t * We do not know exactly how many bytes will be needed, and\n\t * __linearize is expensive, so fetch as much as possible.  We\n\t * just have to avoid going beyond the 15 byte limit, the end\n\t * of the segment, or the end of the page.\n\t *\n\t * __linearize is called with size 0 so that it does not do any\n\t * boundary check itself.  Instead, we use max_size to check\n\t * against op_size.\n\t */\n\trc = __linearize(ctxt, addr, &max_size, 0, false, true, ctxt->mode,\n\t\t\t &linear);\n\tif (unlikely(rc != X86EMUL_CONTINUE))\n\t\treturn rc;\n\n\tsize = min_t(unsigned, 15UL ^ cur_size, max_size);\n\tsize = min_t(unsigned, size, PAGE_SIZE - offset_in_page(linear));\n\n\t/*\n\t * One instruction can only straddle two pages,\n\t * and one has been loaded at the beginning of\n\t * x86_decode_insn.  So, if not enough bytes\n\t * still, we must have hit the 15-byte boundary.\n\t */\n\tif (unlikely(size < op_size))\n\t\treturn emulate_gp(ctxt, 0);\n\n\trc = ctxt->ops->fetch(ctxt, linear, ctxt->fetch.end,\n\t\t\t      size, &ctxt->exception);\n\tif (unlikely(rc != X86EMUL_CONTINUE))\n\t\treturn rc;\n\tctxt->fetch.end += size;\n\treturn X86EMUL_CONTINUE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ctxt->fetch.data",
            "insn",
            "insn_len"
          ],
          "line": 4804
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\n#define No16\t    ((u64)1 << 53)  /* No 16 bit operand */\n#define NearBranch  ((u64)1 << 52)  /* Near branches */\n#define CheckPerm   ((u64)1 << 49)  /* Has valid check_perm field */\n#define Intercept   ((u64)1 << 48)  /* Has valid intercept field */\n#define Mmx         ((u64)1 << 40)  /* MMX Vector instruction */\n#define Src2Shift   (31)\n#define NotImpl     (1 << 30)   /* instruction is not implemented */\n#define Op3264      (1<<24) /* Operand is 64b in long mode, 32b otherwise */\n#define EmulateOnUD (1<<22) /* Emulate if unsupported by the host */\n#define ModRM       (1<<19)\n#define Sse         (1<<18)     /* SSE Vector instruction */\n#define ModeDual    (7<<15)     /* Different instruction for 32/64 bit */\n#define InstrDual   (6<<15)     /* Alternate instruction decoding of mod == 3 */\n#define Escape      (5<<15)     /* Escape to coprocessor instruction */\n#define RMExt       (4<<15)     /* Opcode extension in ModRM r/m if mod == 3 */\n#define Prefix      (3<<15)     /* Instruction varies with 66/f2/f3 prefix */\n#define GroupDual   (2<<15)     /* Alternate decoding of mod == 3 */\n#define Group       (1<<15)     /* Bits 3:5 of modrm byte extend opcode */\n#define GroupMask   (7<<15)     /* Opcode uses one of the group mechanisms */\n#define Stack       (1<<14)     /* Stack instruction (push/pop) */\n#define MemAbs      (1<<12)      /* Memory operand is absolute displacement */\n#define SrcShift    6\n#define DstShift    1\n#define OpMask             ((1ull << OpBits) - 1)\n\nstatic const struct opcode opcode_table[256] = {\n\t/* 0x00 - 0x07 */\n\tF6ALU(Lock, em_add),\n\tI(ImplicitOps | Stack | No64 | Src2ES, em_push_sreg),\n\tI(ImplicitOps | Stack | No64 | Src2ES, em_pop_sreg),\n\t/* 0x08 - 0x0F */\n\tF6ALU(Lock | PageTable, em_or),\n\tI(ImplicitOps | Stack | No64 | Src2CS, em_push_sreg),\n\tN,\n\t/* 0x10 - 0x17 */\n\tF6ALU(Lock, em_adc),\n\tI(ImplicitOps | Stack | No64 | Src2SS, em_push_sreg),\n\tI(ImplicitOps | Stack | No64 | Src2SS, em_pop_sreg),\n\t/* 0x18 - 0x1F */\n\tF6ALU(Lock, em_sbb),\n\tI(ImplicitOps | Stack | No64 | Src2DS, em_push_sreg),\n\tI(ImplicitOps | Stack | No64 | Src2DS, em_pop_sreg),\n\t/* 0x20 - 0x27 */\n\tF6ALU(Lock | PageTable, em_and), N, N,\n\t/* 0x28 - 0x2F */\n\tF6ALU(Lock, em_sub), N, I(ByteOp | DstAcc | No64, em_das),\n\t/* 0x30 - 0x37 */\n\tF6ALU(Lock, em_xor), N, N,\n\t/* 0x38 - 0x3F */\n\tF6ALU(NoWrite, em_cmp), N, N,\n\t/* 0x40 - 0x4F */\n\tX8(F(DstReg, em_inc)), X8(F(DstReg, em_dec)),\n\t/* 0x50 - 0x57 */\n\tX8(I(SrcReg | Stack, em_push)),\n\t/* 0x58 - 0x5F */\n\tX8(I(DstReg | Stack, em_pop)),\n\t/* 0x60 - 0x67 */\n\tI(ImplicitOps | Stack | No64, em_pusha),\n\tI(ImplicitOps | Stack | No64, em_popa),\n\tN, MD(ModRM, &mode_dual_63),\n\tN, N, N, N,\n\t/* 0x68 - 0x6F */\n\tI(SrcImm | Mov | Stack, em_push),\n\tI(DstReg | SrcMem | ModRM | Src2Imm, em_imul_3op),\n\tI(SrcImmByte | Mov | Stack, em_push),\n\tI(DstReg | SrcMem | ModRM | Src2ImmByte, em_imul_3op),\n\tI2bvIP(DstDI | SrcDX | Mov | String | Unaligned, em_in, ins, check_perm_in), /* insb, insw/insd */\n\tI2bvIP(SrcSI | DstDX | String, em_out, outs, check_perm_out), /* outsb, outsw/outsd */\n\t/* 0x70 - 0x7F */\n\tX16(D(SrcImmByte | NearBranch)),\n\t/* 0x80 - 0x87 */\n\tG(ByteOp | DstMem | SrcImm, group1),\n\tG(DstMem | SrcImm, group1),\n\tG(ByteOp | DstMem | SrcImm | No64, group1),\n\tG(DstMem | SrcImmByte, group1),\n\tF2bv(DstMem | SrcReg | ModRM | NoWrite, em_test),\n\tI2bv(DstMem | SrcReg | ModRM | Lock | PageTable, em_xchg),\n\t/* 0x88 - 0x8F */\n\tI2bv(DstMem | SrcReg | ModRM | Mov | PageTable, em_mov),\n\tI2bv(DstReg | SrcMem | ModRM | Mov, em_mov),\n\tI(DstMem | SrcNone | ModRM | Mov | PageTable, em_mov_rm_sreg),\n\tD(ModRM | SrcMem | NoAccess | DstReg),\n\tI(ImplicitOps | SrcMem16 | ModRM, em_mov_sreg_rm),\n\tG(0, group1A),\n\t/* 0x90 - 0x97 */\n\tDI(SrcAcc | DstReg, pause), X7(D(SrcAcc | DstReg)),\n\t/* 0x98 - 0x9F */\n\tD(DstAcc | SrcNone), I(ImplicitOps | SrcAcc, em_cwd),\n\tI(SrcImmFAddr | No64, em_call_far), N,\n\tII(ImplicitOps | Stack, em_pushf, pushf),\n\tII(ImplicitOps | Stack, em_popf, popf),\n\tI(ImplicitOps, em_sahf), I(ImplicitOps, em_lahf),\n\t/* 0xA0 - 0xA7 */\n\tI2bv(DstAcc | SrcMem | Mov | MemAbs, em_mov),\n\tI2bv(DstMem | SrcAcc | Mov | MemAbs | PageTable, em_mov),\n\tI2bv(SrcSI | DstDI | Mov | String, em_mov),\n\tF2bv(SrcSI | DstDI | String | NoWrite, em_cmp_r),\n\t/* 0xA8 - 0xAF */\n\tF2bv(DstAcc | SrcImm | NoWrite, em_test),\n\tI2bv(SrcAcc | DstDI | Mov | String, em_mov),\n\tI2bv(SrcSI | DstAcc | Mov | String, em_mov),\n\tF2bv(SrcAcc | DstDI | String | NoWrite, em_cmp_r),\n\t/* 0xB0 - 0xB7 */\n\tX8(I(ByteOp | DstReg | SrcImm | Mov, em_mov)),\n\t/* 0xB8 - 0xBF */\n\tX8(I(DstReg | SrcImm64 | Mov, em_mov)),\n\t/* 0xC0 - 0xC7 */\n\tG(ByteOp | Src2ImmByte, group2), G(Src2ImmByte, group2),\n\tI(ImplicitOps | NearBranch | SrcImmU16, em_ret_near_imm),\n\tI(ImplicitOps | NearBranch, em_ret),\n\tI(DstReg | SrcMemFAddr | ModRM | No64 | Src2ES, em_lseg),\n\tI(DstReg | SrcMemFAddr | ModRM | No64 | Src2DS, em_lseg),\n\tG(ByteOp, group11), G(0, group11),\n\t/* 0xC8 - 0xCF */\n\tI(Stack | SrcImmU16 | Src2ImmByte, em_enter), I(Stack, em_leave),\n\tI(ImplicitOps | SrcImmU16, em_ret_far_imm),\n\tI(ImplicitOps, em_ret_far),\n\tD(ImplicitOps), DI(SrcImmByte, intn),\n\tD(ImplicitOps | No64), II(ImplicitOps, em_iret, iret),\n\t/* 0xD0 - 0xD7 */\n\tG(Src2One | ByteOp, group2), G(Src2One, group2),\n\tG(Src2CL | ByteOp, group2), G(Src2CL, group2),\n\tI(DstAcc | SrcImmUByte | No64, em_aam),\n\tI(DstAcc | SrcImmUByte | No64, em_aad),\n\tF(DstAcc | ByteOp | No64, em_salc),\n\tI(DstAcc | SrcXLat | ByteOp, em_mov),\n\t/* 0xD8 - 0xDF */\n\tN, E(0, &escape_d9), N, E(0, &escape_db), N, E(0, &escape_dd), N, N,\n\t/* 0xE0 - 0xE7 */\n\tX3(I(SrcImmByte | NearBranch, em_loop)),\n\tI(SrcImmByte | NearBranch, em_jcxz),\n\tI2bvIP(SrcImmUByte | DstAcc, em_in,  in,  check_perm_in),\n\tI2bvIP(SrcAcc | DstImmUByte, em_out, out, check_perm_out),\n\t/* 0xE8 - 0xEF */\n\tI(SrcImm | NearBranch, em_call), D(SrcImm | ImplicitOps | NearBranch),\n\tI(SrcImmFAddr | No64, em_jmp_far),\n\tD(SrcImmByte | ImplicitOps | NearBranch),\n\tI2bvIP(SrcDX | DstAcc, em_in,  in,  check_perm_in),\n\tI2bvIP(SrcAcc | DstDX, em_out, out, check_perm_out),\n\t/* 0xF0 - 0xF7 */\n\tN, DI(ImplicitOps, icebp), N, N,\n\tDI(ImplicitOps | Priv, hlt), D(ImplicitOps),\n\tG(ByteOp, group3), G(0, group3),\n\t/* 0xF8 - 0xFF */\n\tD(ImplicitOps), D(ImplicitOps),\n\tI(ImplicitOps, em_cli), I(ImplicitOps, em_sti),\n\tD(ImplicitOps), D(ImplicitOps), G(0, group4), G(0, group5),\n};\nstatic const struct opcode twobyte_table[256] = {\n\t/* 0x00 - 0x0F */\n\tG(0, group6), GD(0, &group7), N, N,\n\tN, I(ImplicitOps | EmulateOnUD, em_syscall),\n\tII(ImplicitOps | Priv, em_clts, clts), N,\n\tDI(ImplicitOps | Priv, invd), DI(ImplicitOps | Priv, wbinvd), N, N,\n\tN, D(ImplicitOps | ModRM | SrcMem | NoAccess), N, N,\n\t/* 0x10 - 0x1F */\n\tN, N, N, N, N, N, N, N,\n\tD(ImplicitOps | ModRM | SrcMem | NoAccess),\n\tN, N, N, N, N, N, D(ImplicitOps | ModRM | SrcMem | NoAccess),\n\t/* 0x20 - 0x2F */\n\tDIP(ModRM | DstMem | Priv | Op3264 | NoMod, cr_read, check_cr_read),\n\tDIP(ModRM | DstMem | Priv | Op3264 | NoMod, dr_read, check_dr_read),\n\tIIP(ModRM | SrcMem | Priv | Op3264 | NoMod, em_cr_write, cr_write,\n\t\t\t\t\t\tcheck_cr_write),\n\tIIP(ModRM | SrcMem | Priv | Op3264 | NoMod, em_dr_write, dr_write,\n\t\t\t\t\t\tcheck_dr_write),\n\tN, N, N, N,\n\tGP(ModRM | DstReg | SrcMem | Mov | Sse, &pfx_0f_28_0f_29),\n\tGP(ModRM | DstMem | SrcReg | Mov | Sse, &pfx_0f_28_0f_29),\n\tN, GP(ModRM | DstMem | SrcReg | Mov | Sse, &pfx_0f_2b),\n\tN, N, N, N,\n\t/* 0x30 - 0x3F */\n\tII(ImplicitOps | Priv, em_wrmsr, wrmsr),\n\tIIP(ImplicitOps, em_rdtsc, rdtsc, check_rdtsc),\n\tII(ImplicitOps | Priv, em_rdmsr, rdmsr),\n\tIIP(ImplicitOps, em_rdpmc, rdpmc, check_rdpmc),\n\tI(ImplicitOps | EmulateOnUD, em_sysenter),\n\tI(ImplicitOps | Priv | EmulateOnUD, em_sysexit),\n\tN, N,\n\tN, N, N, N, N, N, N, N,\n\t/* 0x40 - 0x4F */\n\tX16(D(DstReg | SrcMem | ModRM)),\n\t/* 0x50 - 0x5F */\n\tN, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N,\n\t/* 0x60 - 0x6F */\n\tN, N, N, N,\n\tN, N, N, N,\n\tN, N, N, N,\n\tN, N, N, GP(SrcMem | DstReg | ModRM | Mov, &pfx_0f_6f_0f_7f),\n\t/* 0x70 - 0x7F */\n\tN, N, N, N,\n\tN, N, N, N,\n\tN, N, N, N,\n\tN, N, N, GP(SrcReg | DstMem | ModRM | Mov, &pfx_0f_6f_0f_7f),\n\t/* 0x80 - 0x8F */\n\tX16(D(SrcImm | NearBranch)),\n\t/* 0x90 - 0x9F */\n\tX16(D(ByteOp | DstMem | SrcNone | ModRM| Mov)),\n\t/* 0xA0 - 0xA7 */\n\tI(Stack | Src2FS, em_push_sreg), I(Stack | Src2FS, em_pop_sreg),\n\tII(ImplicitOps, em_cpuid, cpuid),\n\tF(DstMem | SrcReg | ModRM | BitOp | NoWrite, em_bt),\n\tF(DstMem | SrcReg | Src2ImmByte | ModRM, em_shld),\n\tF(DstMem | SrcReg | Src2CL | ModRM, em_shld), N, N,\n\t/* 0xA8 - 0xAF */\n\tI(Stack | Src2GS, em_push_sreg), I(Stack | Src2GS, em_pop_sreg),\n\tII(EmulateOnUD | ImplicitOps, em_rsm, rsm),\n\tF(DstMem | SrcReg | ModRM | BitOp | Lock | PageTable, em_bts),\n\tF(DstMem | SrcReg | Src2ImmByte | ModRM, em_shrd),\n\tF(DstMem | SrcReg | Src2CL | ModRM, em_shrd),\n\tGD(0, &group15), F(DstReg | SrcMem | ModRM, em_imul),\n\t/* 0xB0 - 0xB7 */\n\tI2bv(DstMem | SrcReg | ModRM | Lock | PageTable | SrcWrite, em_cmpxchg),\n\tI(DstReg | SrcMemFAddr | ModRM | Src2SS, em_lseg),\n\tF(DstMem | SrcReg | ModRM | BitOp | Lock, em_btr),\n\tI(DstReg | SrcMemFAddr | ModRM | Src2FS, em_lseg),\n\tI(DstReg | SrcMemFAddr | ModRM | Src2GS, em_lseg),\n\tD(DstReg | SrcMem8 | ModRM | Mov), D(DstReg | SrcMem16 | ModRM | Mov),\n\t/* 0xB8 - 0xBF */\n\tN, N,\n\tG(BitOp, group8),\n\tF(DstMem | SrcReg | ModRM | BitOp | Lock | PageTable, em_btc),\n\tI(DstReg | SrcMem | ModRM, em_bsf_c),\n\tI(DstReg | SrcMem | ModRM, em_bsr_c),\n\tD(DstReg | SrcMem8 | ModRM | Mov), D(DstReg | SrcMem16 | ModRM | Mov),\n\t/* 0xC0 - 0xC7 */\n\tF2bv(DstMem | SrcReg | ModRM | SrcWrite | Lock, em_xadd),\n\tN, ID(0, &instr_dual_0f_c3),\n\tN, N, N, GD(0, &group9),\n\t/* 0xC8 - 0xCF */\n\tX8(I(DstReg, em_bswap)),\n\t/* 0xD0 - 0xDF */\n\tN, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N,\n\t/* 0xE0 - 0xEF */\n\tN, N, N, N, N, N, N, GP(SrcReg | DstMem | ModRM | Mov, &pfx_0f_e7),\n\tN, N, N, N, N, N, N, N,\n\t/* 0xF0 - 0xFF */\n\tN, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N\n};\nstatic const struct opcode opcode_map_0f_38[256] = {\n\t/* 0x00 - 0x7f */\n\tX16(N), X16(N), X16(N), X16(N), X16(N), X16(N), X16(N), X16(N),\n\t/* 0x80 - 0xef */\n\tX16(N), X16(N), X16(N), X16(N), X16(N), X16(N), X16(N),\n\t/* 0xf0 - 0xf1 */\n\tGP(EmulateOnUD | ModRM, &three_byte_0f_38_f0),\n\tGP(EmulateOnUD | ModRM, &three_byte_0f_38_f1),\n\t/* 0xf2 - 0xff */\n\tN, N, X4(N), X8(N)\n};\n\nint x86_decode_insn(struct x86_emulate_ctxt *ctxt, void *insn, int insn_len)\n{\n\tint rc = X86EMUL_CONTINUE;\n\tint mode = ctxt->mode;\n\tint def_op_bytes, def_ad_bytes, goffset, simd_prefix;\n\tbool op_prefix = false;\n\tbool has_seg_override = false;\n\tstruct opcode opcode;\n\n\tctxt->memop.type = OP_NONE;\n\tctxt->memopp = NULL;\n\tctxt->_eip = ctxt->eip;\n\tctxt->fetch.ptr = ctxt->fetch.data;\n\tctxt->fetch.end = ctxt->fetch.data + insn_len;\n\tctxt->opcode_len = 1;\n\tif (insn_len > 0)\n\t\tmemcpy(ctxt->fetch.data, insn, insn_len);\n\telse {\n\t\trc = __do_insn_fetch_bytes(ctxt, 1);\n\t\tif (rc != X86EMUL_CONTINUE)\n\t\t\treturn rc;\n\t}\n\n\tswitch (mode) {\n\tcase X86EMUL_MODE_REAL:\n\tcase X86EMUL_MODE_VM86:\n\tcase X86EMUL_MODE_PROT16:\n\t\tdef_op_bytes = def_ad_bytes = 2;\n\t\tbreak;\n\tcase X86EMUL_MODE_PROT32:\n\t\tdef_op_bytes = def_ad_bytes = 4;\n\t\tbreak;\n#ifdef CONFIG_X86_64\n\tcase X86EMUL_MODE_PROT64:\n\t\tdef_op_bytes = 4;\n\t\tdef_ad_bytes = 8;\n\t\tbreak;\n#endif\n\tdefault:\n\t\treturn EMULATION_FAILED;\n\t}\n\n\tctxt->op_bytes = def_op_bytes;\n\tctxt->ad_bytes = def_ad_bytes;\n\n\t/* Legacy prefixes. */\n\tfor (;;) {\n\t\tswitch (ctxt->b = insn_fetch(u8, ctxt)) {\n\t\tcase 0x66:\t/* operand-size override */\n\t\t\top_prefix = true;\n\t\t\t/* switch between 2/4 bytes */\n\t\t\tctxt->op_bytes = def_op_bytes ^ 6;\n\t\t\tbreak;\n\t\tcase 0x67:\t/* address-size override */\n\t\t\tif (mode == X86EMUL_MODE_PROT64)\n\t\t\t\t/* switch between 4/8 bytes */\n\t\t\t\tctxt->ad_bytes = def_ad_bytes ^ 12;\n\t\t\telse\n\t\t\t\t/* switch between 2/4 bytes */\n\t\t\t\tctxt->ad_bytes = def_ad_bytes ^ 6;\n\t\t\tbreak;\n\t\tcase 0x26:\t/* ES override */\n\t\tcase 0x2e:\t/* CS override */\n\t\tcase 0x36:\t/* SS override */\n\t\tcase 0x3e:\t/* DS override */\n\t\t\thas_seg_override = true;\n\t\t\tctxt->seg_override = (ctxt->b >> 3) & 3;\n\t\t\tbreak;\n\t\tcase 0x64:\t/* FS override */\n\t\tcase 0x65:\t/* GS override */\n\t\t\thas_seg_override = true;\n\t\t\tctxt->seg_override = ctxt->b & 7;\n\t\t\tbreak;\n\t\tcase 0x40 ... 0x4f: /* REX */\n\t\t\tif (mode != X86EMUL_MODE_PROT64)\n\t\t\t\tgoto done_prefixes;\n\t\t\tctxt->rex_prefix = ctxt->b;\n\t\t\tcontinue;\n\t\tcase 0xf0:\t/* LOCK */\n\t\t\tctxt->lock_prefix = 1;\n\t\t\tbreak;\n\t\tcase 0xf2:\t/* REPNE/REPNZ */\n\t\tcase 0xf3:\t/* REP/REPE/REPZ */\n\t\t\tctxt->rep_prefix = ctxt->b;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto done_prefixes;\n\t\t}\n\n\t\t/* Any legacy prefix after a REX prefix nullifies its effect. */\n\n\t\tctxt->rex_prefix = 0;\n\t}\n\ndone_prefixes:\n\n\t/* REX prefix. */\n\tif (ctxt->rex_prefix & 8)\n\t\tctxt->op_bytes = 8;\t/* REX.W */\n\n\t/* Opcode byte(s). */\n\topcode = opcode_table[ctxt->b];\n\t/* Two-byte opcode? */\n\tif (ctxt->b == 0x0f) {\n\t\tctxt->opcode_len = 2;\n\t\tctxt->b = insn_fetch(u8, ctxt);\n\t\topcode = twobyte_table[ctxt->b];\n\n\t\t/* 0F_38 opcode map */\n\t\tif (ctxt->b == 0x38) {\n\t\t\tctxt->opcode_len = 3;\n\t\t\tctxt->b = insn_fetch(u8, ctxt);\n\t\t\topcode = opcode_map_0f_38[ctxt->b];\n\t\t}\n\t}\n\tctxt->d = opcode.flags;\n\n\tif (ctxt->d & ModRM)\n\t\tctxt->modrm = insn_fetch(u8, ctxt);\n\n\t/* vex-prefix instructions are not implemented */\n\tif (ctxt->opcode_len == 1 && (ctxt->b == 0xc5 || ctxt->b == 0xc4) &&\n\t    (mode == X86EMUL_MODE_PROT64 || (ctxt->modrm & 0xc0) == 0xc0)) {\n\t\tctxt->d = NotImpl;\n\t}\n\n\twhile (ctxt->d & GroupMask) {\n\t\tswitch (ctxt->d & GroupMask) {\n\t\tcase Group:\n\t\t\tgoffset = (ctxt->modrm >> 3) & 7;\n\t\t\topcode = opcode.u.group[goffset];\n\t\t\tbreak;\n\t\tcase GroupDual:\n\t\t\tgoffset = (ctxt->modrm >> 3) & 7;\n\t\t\tif ((ctxt->modrm >> 6) == 3)\n\t\t\t\topcode = opcode.u.gdual->mod3[goffset];\n\t\t\telse\n\t\t\t\topcode = opcode.u.gdual->mod012[goffset];\n\t\t\tbreak;\n\t\tcase RMExt:\n\t\t\tgoffset = ctxt->modrm & 7;\n\t\t\topcode = opcode.u.group[goffset];\n\t\t\tbreak;\n\t\tcase Prefix:\n\t\t\tif (ctxt->rep_prefix && op_prefix)\n\t\t\t\treturn EMULATION_FAILED;\n\t\t\tsimd_prefix = op_prefix ? 0x66 : ctxt->rep_prefix;\n\t\t\tswitch (simd_prefix) {\n\t\t\tcase 0x00: opcode = opcode.u.gprefix->pfx_no; break;\n\t\t\tcase 0x66: opcode = opcode.u.gprefix->pfx_66; break;\n\t\t\tcase 0xf2: opcode = opcode.u.gprefix->pfx_f2; break;\n\t\t\tcase 0xf3: opcode = opcode.u.gprefix->pfx_f3; break;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Escape:\n\t\t\tif (ctxt->modrm > 0xbf)\n\t\t\t\topcode = opcode.u.esc->high[ctxt->modrm - 0xc0];\n\t\t\telse\n\t\t\t\topcode = opcode.u.esc->op[(ctxt->modrm >> 3) & 7];\n\t\t\tbreak;\n\t\tcase InstrDual:\n\t\t\tif ((ctxt->modrm >> 6) == 3)\n\t\t\t\topcode = opcode.u.idual->mod3;\n\t\t\telse\n\t\t\t\topcode = opcode.u.idual->mod012;\n\t\t\tbreak;\n\t\tcase ModeDual:\n\t\t\tif (ctxt->mode == X86EMUL_MODE_PROT64)\n\t\t\t\topcode = opcode.u.mdual->mode64;\n\t\t\telse\n\t\t\t\topcode = opcode.u.mdual->mode32;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn EMULATION_FAILED;\n\t\t}\n\n\t\tctxt->d &= ~(u64)GroupMask;\n\t\tctxt->d |= opcode.flags;\n\t}\n\n\t/* Unrecognised? */\n\tif (ctxt->d == 0)\n\t\treturn EMULATION_FAILED;\n\n\tctxt->execute = opcode.u.execute;\n\n\tif (unlikely(ctxt->ud) && likely(!(ctxt->d & EmulateOnUD)))\n\t\treturn EMULATION_FAILED;\n\n\tif (unlikely(ctxt->d &\n\t    (NotImpl|Stack|Op3264|Sse|Mmx|Intercept|CheckPerm|NearBranch|\n\t     No16))) {\n\t\t/*\n\t\t * These are copied unconditionally here, and checked unconditionally\n\t\t * in x86_emulate_insn.\n\t\t */\n\t\tctxt->check_perm = opcode.check_perm;\n\t\tctxt->intercept = opcode.intercept;\n\n\t\tif (ctxt->d & NotImpl)\n\t\t\treturn EMULATION_FAILED;\n\n\t\tif (mode == X86EMUL_MODE_PROT64) {\n\t\t\tif (ctxt->op_bytes == 4 && (ctxt->d & Stack))\n\t\t\t\tctxt->op_bytes = 8;\n\t\t\telse if (ctxt->d & NearBranch)\n\t\t\t\tctxt->op_bytes = 8;\n\t\t}\n\n\t\tif (ctxt->d & Op3264) {\n\t\t\tif (mode == X86EMUL_MODE_PROT64)\n\t\t\t\tctxt->op_bytes = 8;\n\t\t\telse\n\t\t\t\tctxt->op_bytes = 4;\n\t\t}\n\n\t\tif ((ctxt->d & No16) && ctxt->op_bytes == 2)\n\t\t\tctxt->op_bytes = 4;\n\n\t\tif (ctxt->d & Sse)\n\t\t\tctxt->op_bytes = 16;\n\t\telse if (ctxt->d & Mmx)\n\t\t\tctxt->op_bytes = 8;\n\t}\n\n\t/* ModRM and SIB bytes. */\n\tif (ctxt->d & ModRM) {\n\t\trc = decode_modrm(ctxt, &ctxt->memop);\n\t\tif (!has_seg_override) {\n\t\t\thas_seg_override = true;\n\t\t\tctxt->seg_override = ctxt->modrm_seg;\n\t\t}\n\t} else if (ctxt->d & MemAbs)\n\t\trc = decode_abs(ctxt, &ctxt->memop);\n\tif (rc != X86EMUL_CONTINUE)\n\t\tgoto done;\n\n\tif (!has_seg_override)\n\t\tctxt->seg_override = VCPU_SREG_DS;\n\n\tctxt->memop.addr.mem.seg = ctxt->seg_override;\n\n\t/*\n\t * Decode and fetch the source operand: register, memory\n\t * or immediate.\n\t */\n\trc = decode_operand(ctxt, &ctxt->src, (ctxt->d >> SrcShift) & OpMask);\n\tif (rc != X86EMUL_CONTINUE)\n\t\tgoto done;\n\n\t/*\n\t * Decode and fetch the second source operand: register, memory\n\t * or immediate.\n\t */\n\trc = decode_operand(ctxt, &ctxt->src2, (ctxt->d >> Src2Shift) & OpMask);\n\tif (rc != X86EMUL_CONTINUE)\n\t\tgoto done;\n\n\t/* Decode and fetch the destination operand: register or memory. */\n\trc = decode_operand(ctxt, &ctxt->dst, (ctxt->d >> DstShift) & OpMask);\n\n\tif (ctxt->rip_relative)\n\t\tctxt->memopp->addr.mem.ea = address_mask(ctxt,\n\t\t\t\t\tctxt->memopp->addr.mem.ea + ctxt->_eip);\n\ndone:\n\treturn (rc != X86EMUL_CONTINUE) ? EMULATION_FAILED : EMULATION_OK;\n}"
  },
  {
    "function_name": "decode_operand",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "4622-4786",
    "snippet": "static int decode_operand(struct x86_emulate_ctxt *ctxt, struct operand *op,\n\t\t\t  unsigned d)\n{\n\tint rc = X86EMUL_CONTINUE;\n\n\tswitch (d) {\n\tcase OpReg:\n\t\tdecode_register_operand(ctxt, op);\n\t\tbreak;\n\tcase OpImmUByte:\n\t\trc = decode_imm(ctxt, op, 1, false);\n\t\tbreak;\n\tcase OpMem:\n\t\tctxt->memop.bytes = (ctxt->d & ByteOp) ? 1 : ctxt->op_bytes;\n\tmem_common:\n\t\t*op = ctxt->memop;\n\t\tctxt->memopp = op;\n\t\tif (ctxt->d & BitOp)\n\t\t\tfetch_bit_operand(ctxt);\n\t\top->orig_val = op->val;\n\t\tbreak;\n\tcase OpMem64:\n\t\tctxt->memop.bytes = (ctxt->op_bytes == 8) ? 16 : 8;\n\t\tgoto mem_common;\n\tcase OpAcc:\n\t\top->type = OP_REG;\n\t\top->bytes = (ctxt->d & ByteOp) ? 1 : ctxt->op_bytes;\n\t\top->addr.reg = reg_rmw(ctxt, VCPU_REGS_RAX);\n\t\tfetch_register_operand(op);\n\t\top->orig_val = op->val;\n\t\tbreak;\n\tcase OpAccLo:\n\t\top->type = OP_REG;\n\t\top->bytes = (ctxt->d & ByteOp) ? 2 : ctxt->op_bytes;\n\t\top->addr.reg = reg_rmw(ctxt, VCPU_REGS_RAX);\n\t\tfetch_register_operand(op);\n\t\top->orig_val = op->val;\n\t\tbreak;\n\tcase OpAccHi:\n\t\tif (ctxt->d & ByteOp) {\n\t\t\top->type = OP_NONE;\n\t\t\tbreak;\n\t\t}\n\t\top->type = OP_REG;\n\t\top->bytes = ctxt->op_bytes;\n\t\top->addr.reg = reg_rmw(ctxt, VCPU_REGS_RDX);\n\t\tfetch_register_operand(op);\n\t\top->orig_val = op->val;\n\t\tbreak;\n\tcase OpDI:\n\t\top->type = OP_MEM;\n\t\top->bytes = (ctxt->d & ByteOp) ? 1 : ctxt->op_bytes;\n\t\top->addr.mem.ea =\n\t\t\tregister_address(ctxt, VCPU_REGS_RDI);\n\t\top->addr.mem.seg = VCPU_SREG_ES;\n\t\top->val = 0;\n\t\top->count = 1;\n\t\tbreak;\n\tcase OpDX:\n\t\top->type = OP_REG;\n\t\top->bytes = 2;\n\t\top->addr.reg = reg_rmw(ctxt, VCPU_REGS_RDX);\n\t\tfetch_register_operand(op);\n\t\tbreak;\n\tcase OpCL:\n\t\top->type = OP_IMM;\n\t\top->bytes = 1;\n\t\top->val = reg_read(ctxt, VCPU_REGS_RCX) & 0xff;\n\t\tbreak;\n\tcase OpImmByte:\n\t\trc = decode_imm(ctxt, op, 1, true);\n\t\tbreak;\n\tcase OpOne:\n\t\top->type = OP_IMM;\n\t\top->bytes = 1;\n\t\top->val = 1;\n\t\tbreak;\n\tcase OpImm:\n\t\trc = decode_imm(ctxt, op, imm_size(ctxt), true);\n\t\tbreak;\n\tcase OpImm64:\n\t\trc = decode_imm(ctxt, op, ctxt->op_bytes, true);\n\t\tbreak;\n\tcase OpMem8:\n\t\tctxt->memop.bytes = 1;\n\t\tif (ctxt->memop.type == OP_REG) {\n\t\t\tctxt->memop.addr.reg = decode_register(ctxt,\n\t\t\t\t\tctxt->modrm_rm, true);\n\t\t\tfetch_register_operand(&ctxt->memop);\n\t\t}\n\t\tgoto mem_common;\n\tcase OpMem16:\n\t\tctxt->memop.bytes = 2;\n\t\tgoto mem_common;\n\tcase OpMem32:\n\t\tctxt->memop.bytes = 4;\n\t\tgoto mem_common;\n\tcase OpImmU16:\n\t\trc = decode_imm(ctxt, op, 2, false);\n\t\tbreak;\n\tcase OpImmU:\n\t\trc = decode_imm(ctxt, op, imm_size(ctxt), false);\n\t\tbreak;\n\tcase OpSI:\n\t\top->type = OP_MEM;\n\t\top->bytes = (ctxt->d & ByteOp) ? 1 : ctxt->op_bytes;\n\t\top->addr.mem.ea =\n\t\t\tregister_address(ctxt, VCPU_REGS_RSI);\n\t\top->addr.mem.seg = ctxt->seg_override;\n\t\top->val = 0;\n\t\top->count = 1;\n\t\tbreak;\n\tcase OpXLat:\n\t\top->type = OP_MEM;\n\t\top->bytes = (ctxt->d & ByteOp) ? 1 : ctxt->op_bytes;\n\t\top->addr.mem.ea =\n\t\t\taddress_mask(ctxt,\n\t\t\t\treg_read(ctxt, VCPU_REGS_RBX) +\n\t\t\t\t(reg_read(ctxt, VCPU_REGS_RAX) & 0xff));\n\t\top->addr.mem.seg = ctxt->seg_override;\n\t\top->val = 0;\n\t\tbreak;\n\tcase OpImmFAddr:\n\t\top->type = OP_IMM;\n\t\top->addr.mem.ea = ctxt->_eip;\n\t\top->bytes = ctxt->op_bytes + 2;\n\t\tinsn_fetch_arr(op->valptr, op->bytes, ctxt);\n\t\tbreak;\n\tcase OpMemFAddr:\n\t\tctxt->memop.bytes = ctxt->op_bytes + 2;\n\t\tgoto mem_common;\n\tcase OpES:\n\t\top->type = OP_IMM;\n\t\top->val = VCPU_SREG_ES;\n\t\tbreak;\n\tcase OpCS:\n\t\top->type = OP_IMM;\n\t\top->val = VCPU_SREG_CS;\n\t\tbreak;\n\tcase OpSS:\n\t\top->type = OP_IMM;\n\t\top->val = VCPU_SREG_SS;\n\t\tbreak;\n\tcase OpDS:\n\t\top->type = OP_IMM;\n\t\top->val = VCPU_SREG_DS;\n\t\tbreak;\n\tcase OpFS:\n\t\top->type = OP_IMM;\n\t\top->val = VCPU_SREG_FS;\n\t\tbreak;\n\tcase OpGS:\n\t\top->type = OP_IMM;\n\t\top->val = VCPU_SREG_GS;\n\t\tbreak;\n\tcase OpImplicit:\n\t\t/* Special instructions do their own operand decoding. */\n\tdefault:\n\t\top->type = OP_NONE; /* Disable writeback. */\n\t\tbreak;\n\t}\n\ndone:\n\treturn rc;\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define BitOp       (1<<11)",
      "#define ByteOp      (1<<0)\t/* 8-bit operands. */",
      "#define OpAccHi           30ull  /* High part of extended acc (-/DX/EDX/RDX) */",
      "#define OpAccLo           29ull  /* Low part of extended acc (AX/AX/EAX/RAX) */",
      "#define OpXLat            28ull  /* memory at BX/EBX/RBX + zero-extended AL */",
      "#define OpImm64           27ull  /* Sign extended 16/32/64-bit immediate */",
      "#define OpMem8            26ull  /* 8-bit zero extended memory operand */",
      "#define OpGS              25ull  /* GS */",
      "#define OpFS              24ull  /* FS */",
      "#define OpDS              23ull  /* DS */",
      "#define OpSS              22ull  /* SS */",
      "#define OpCS              21ull  /* CS */",
      "#define OpES              20ull  /* ES */",
      "#define OpImmU16          19ull  /* Immediate operand, 16 bits, zero extended */",
      "#define OpMemFAddr        18ull  /* Far address in memory */",
      "#define OpImmFAddr        17ull  /* Immediate far address */",
      "#define OpSI              16ull  /* SI/ESI/RSI */",
      "#define OpImmU            15ull  /* Immediate operand, zero extended */",
      "#define OpMem32           14ull  /* Memory operand (32-bit). */",
      "#define OpMem16           13ull  /* Memory operand (16-bit). */",
      "#define OpImm             12ull  /* Sign extended up to 32-bit immediate */",
      "#define OpOne             11ull  /* Implied 1 */",
      "#define OpImmByte         10ull  /* 8-bit sign extended immediate */",
      "#define OpCL               9ull  /* CL register (for shifts) */",
      "#define OpDX               8ull  /* DX register */",
      "#define OpImmUByte         7ull  /* Zero-extended 8-bit immediate */",
      "#define OpMem64            6ull  /* Memory, 64-bit */",
      "#define OpDI               5ull  /* ES:DI/EDI/RDI */",
      "#define OpAcc              4ull  /* Accumulator: AL/AX/EAX/RAX */",
      "#define OpMem              3ull  /* Memory */",
      "#define OpReg              2ull  /* Register */",
      "#define OpImplicit         1ull  /* No generic decode */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "insn_fetch_arr",
          "args": [
            "op->valptr",
            "op->bytes",
            "ctxt"
          ],
          "line": 4748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "address_mask",
          "args": [
            "ctxt",
            "reg_read(ctxt, VCPU_REGS_RBX) +\n\t\t\t\t(reg_read(ctxt, VCPU_REGS_RAX) & 0xff)"
          ],
          "line": 4738
        },
        "resolved": true,
        "details": {
          "function_name": "address_mask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "517-524",
          "snippet": "static inline unsigned long\naddress_mask(struct x86_emulate_ctxt *ctxt, unsigned long reg)\n{\n\tif (ctxt->ad_bytes == sizeof(unsigned long))\n\t\treturn reg;\n\telse\n\t\treturn reg & ad_mask(ctxt);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline unsigned long\naddress_mask(struct x86_emulate_ctxt *ctxt, unsigned long reg)\n{\n\tif (ctxt->ad_bytes == sizeof(unsigned long))\n\t\treturn reg;\n\telse\n\t\treturn reg & ad_mask(ctxt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reg_read",
          "args": [
            "ctxt",
            "VCPU_REGS_RAX"
          ],
          "line": 4740
        },
        "resolved": true,
        "details": {
          "function_name": "reg_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "261-268",
          "snippet": "static ulong reg_read(struct x86_emulate_ctxt *ctxt, unsigned nr)\n{\n\tif (!(ctxt->regs_valid & (1 << nr))) {\n\t\tctxt->regs_valid |= 1 << nr;\n\t\tctxt->_regs[nr] = ctxt->ops->read_gpr(ctxt, nr);\n\t}\n\treturn ctxt->_regs[nr];\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic ulong reg_read(struct x86_emulate_ctxt *ctxt, unsigned nr)\n{\n\tif (!(ctxt->regs_valid & (1 << nr))) {\n\t\tctxt->regs_valid |= 1 << nr;\n\t\tctxt->_regs[nr] = ctxt->ops->read_gpr(ctxt, nr);\n\t}\n\treturn ctxt->_regs[nr];\n}"
        }
      },
      {
        "call_info": {
          "callee": "register_address",
          "args": [
            "ctxt",
            "VCPU_REGS_RSI"
          ],
          "line": 4729
        },
        "resolved": true,
        "details": {
          "function_name": "register_address",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "526-530",
          "snippet": "static inline unsigned long\nregister_address(struct x86_emulate_ctxt *ctxt, int reg)\n{\n\treturn address_mask(ctxt, reg_read(ctxt, reg));\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline unsigned long\nregister_address(struct x86_emulate_ctxt *ctxt, int reg)\n{\n\treturn address_mask(ctxt, reg_read(ctxt, reg));\n}"
        }
      },
      {
        "call_info": {
          "callee": "decode_imm",
          "args": [
            "ctxt",
            "op",
            "imm_size(ctxt)",
            "false"
          ],
          "line": 4723
        },
        "resolved": true,
        "details": {
          "function_name": "decode_imm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "4582-4620",
          "snippet": "static int decode_imm(struct x86_emulate_ctxt *ctxt, struct operand *op,\n\t\t      unsigned size, bool sign_extension)\n{\n\tint rc = X86EMUL_CONTINUE;\n\n\top->type = OP_IMM;\n\top->bytes = size;\n\top->addr.mem.ea = ctxt->_eip;\n\t/* NB. Immediates are sign-extended as necessary. */\n\tswitch (op->bytes) {\n\tcase 1:\n\t\top->val = insn_fetch(s8, ctxt);\n\t\tbreak;\n\tcase 2:\n\t\top->val = insn_fetch(s16, ctxt);\n\t\tbreak;\n\tcase 4:\n\t\top->val = insn_fetch(s32, ctxt);\n\t\tbreak;\n\tcase 8:\n\t\top->val = insn_fetch(s64, ctxt);\n\t\tbreak;\n\t}\n\tif (!sign_extension) {\n\t\tswitch (op->bytes) {\n\t\tcase 1:\n\t\t\top->val &= 0xff;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\top->val &= 0xffff;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\top->val &= 0xffffffff;\n\t\t\tbreak;\n\t\t}\n\t}\ndone:\n\treturn rc;\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int decode_imm(struct x86_emulate_ctxt *ctxt, struct operand *op,\n\t\t      unsigned size, bool sign_extension)\n{\n\tint rc = X86EMUL_CONTINUE;\n\n\top->type = OP_IMM;\n\top->bytes = size;\n\top->addr.mem.ea = ctxt->_eip;\n\t/* NB. Immediates are sign-extended as necessary. */\n\tswitch (op->bytes) {\n\tcase 1:\n\t\top->val = insn_fetch(s8, ctxt);\n\t\tbreak;\n\tcase 2:\n\t\top->val = insn_fetch(s16, ctxt);\n\t\tbreak;\n\tcase 4:\n\t\top->val = insn_fetch(s32, ctxt);\n\t\tbreak;\n\tcase 8:\n\t\top->val = insn_fetch(s64, ctxt);\n\t\tbreak;\n\t}\n\tif (!sign_extension) {\n\t\tswitch (op->bytes) {\n\t\tcase 1:\n\t\t\top->val &= 0xff;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\top->val &= 0xffff;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\top->val &= 0xffffffff;\n\t\t\tbreak;\n\t\t}\n\t}\ndone:\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "imm_size",
          "args": [
            "ctxt"
          ],
          "line": 4723
        },
        "resolved": true,
        "details": {
          "function_name": "imm_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "4572-4580",
          "snippet": "static unsigned imm_size(struct x86_emulate_ctxt *ctxt)\n{\n\tunsigned size;\n\n\tsize = (ctxt->d & ByteOp) ? 1 : ctxt->op_bytes;\n\tif (size == 8)\n\t\tsize = 4;\n\treturn size;\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define ByteOp      (1<<0)\t/* 8-bit operands. */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\n#define ByteOp      (1<<0)\t/* 8-bit operands. */\n\nstatic unsigned imm_size(struct x86_emulate_ctxt *ctxt)\n{\n\tunsigned size;\n\n\tsize = (ctxt->d & ByteOp) ? 1 : ctxt->op_bytes;\n\tif (size == 8)\n\t\tsize = 4;\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fetch_register_operand",
          "args": [
            "&ctxt->memop"
          ],
          "line": 4710
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_register_operand",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "983-999",
          "snippet": "static void fetch_register_operand(struct operand *op)\n{\n\tswitch (op->bytes) {\n\tcase 1:\n\t\top->val = *(u8 *)op->addr.reg;\n\t\tbreak;\n\tcase 2:\n\t\top->val = *(u16 *)op->addr.reg;\n\t\tbreak;\n\tcase 4:\n\t\top->val = *(u32 *)op->addr.reg;\n\t\tbreak;\n\tcase 8:\n\t\top->val = *(u64 *)op->addr.reg;\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic void fetch_register_operand(struct operand *op)\n{\n\tswitch (op->bytes) {\n\tcase 1:\n\t\top->val = *(u8 *)op->addr.reg;\n\t\tbreak;\n\tcase 2:\n\t\top->val = *(u16 *)op->addr.reg;\n\t\tbreak;\n\tcase 4:\n\t\top->val = *(u32 *)op->addr.reg;\n\t\tbreak;\n\tcase 8:\n\t\top->val = *(u64 *)op->addr.reg;\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "decode_register",
          "args": [
            "ctxt",
            "ctxt->modrm_rm",
            "true"
          ],
          "line": 4708
        },
        "resolved": true,
        "details": {
          "function_name": "decode_register",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "882-893",
          "snippet": "static void *decode_register(struct x86_emulate_ctxt *ctxt, u8 modrm_reg,\n\t\t\t     int byteop)\n{\n\tvoid *p;\n\tint highbyte_regs = (ctxt->rex_prefix == 0) && byteop;\n\n\tif (highbyte_regs && modrm_reg >= 4 && modrm_reg < 8)\n\t\tp = (unsigned char *)reg_rmw(ctxt, modrm_reg & 3) + 1;\n\telse\n\t\tp = reg_rmw(ctxt, modrm_reg);\n\treturn p;\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic void *decode_register(struct x86_emulate_ctxt *ctxt, u8 modrm_reg,\n\t\t\t     int byteop)\n{\n\tvoid *p;\n\tint highbyte_regs = (ctxt->rex_prefix == 0) && byteop;\n\n\tif (highbyte_regs && modrm_reg >= 4 && modrm_reg < 8)\n\t\tp = (unsigned char *)reg_rmw(ctxt, modrm_reg & 3) + 1;\n\telse\n\t\tp = reg_rmw(ctxt, modrm_reg);\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reg_rmw",
          "args": [
            "ctxt",
            "VCPU_REGS_RDX"
          ],
          "line": 4683
        },
        "resolved": true,
        "details": {
          "function_name": "reg_rmw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "277-281",
          "snippet": "static ulong *reg_rmw(struct x86_emulate_ctxt *ctxt, unsigned nr)\n{\n\treg_read(ctxt, nr);\n\treturn reg_write(ctxt, nr);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic ulong *reg_rmw(struct x86_emulate_ctxt *ctxt, unsigned nr)\n{\n\treg_read(ctxt, nr);\n\treturn reg_write(ctxt, nr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fetch_bit_operand",
          "args": [
            "ctxt"
          ],
          "line": 4640
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_bit_operand",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "1328-1348",
          "snippet": "static void fetch_bit_operand(struct x86_emulate_ctxt *ctxt)\n{\n\tlong sv = 0, mask;\n\n\tif (ctxt->dst.type == OP_MEM && ctxt->src.type == OP_REG) {\n\t\tmask = ~((long)ctxt->dst.bytes * 8 - 1);\n\n\t\tif (ctxt->src.bytes == 2)\n\t\t\tsv = (s16)ctxt->src.val & (s16)mask;\n\t\telse if (ctxt->src.bytes == 4)\n\t\t\tsv = (s32)ctxt->src.val & (s32)mask;\n\t\telse\n\t\t\tsv = (s64)ctxt->src.val & (s64)mask;\n\n\t\tctxt->dst.addr.mem.ea = address_mask(ctxt,\n\t\t\t\t\t   ctxt->dst.addr.mem.ea + (sv >> 3));\n\t}\n\n\t/* only subword offset */\n\tctxt->src.val &= (ctxt->dst.bytes << 3) - 1;\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic void fetch_bit_operand(struct x86_emulate_ctxt *ctxt)\n{\n\tlong sv = 0, mask;\n\n\tif (ctxt->dst.type == OP_MEM && ctxt->src.type == OP_REG) {\n\t\tmask = ~((long)ctxt->dst.bytes * 8 - 1);\n\n\t\tif (ctxt->src.bytes == 2)\n\t\t\tsv = (s16)ctxt->src.val & (s16)mask;\n\t\telse if (ctxt->src.bytes == 4)\n\t\t\tsv = (s32)ctxt->src.val & (s32)mask;\n\t\telse\n\t\t\tsv = (s64)ctxt->src.val & (s64)mask;\n\n\t\tctxt->dst.addr.mem.ea = address_mask(ctxt,\n\t\t\t\t\t   ctxt->dst.addr.mem.ea + (sv >> 3));\n\t}\n\n\t/* only subword offset */\n\tctxt->src.val &= (ctxt->dst.bytes << 3) - 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "decode_register_operand",
          "args": [
            "ctxt",
            "op"
          ],
          "line": 4629
        },
        "resolved": true,
        "details": {
          "function_name": "decode_register_operand",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "1133-1162",
          "snippet": "static void decode_register_operand(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t    struct operand *op)\n{\n\tunsigned reg = ctxt->modrm_reg;\n\n\tif (!(ctxt->d & ModRM))\n\t\treg = (ctxt->b & 7) | ((ctxt->rex_prefix & 1) << 3);\n\n\tif (ctxt->d & Sse) {\n\t\top->type = OP_XMM;\n\t\top->bytes = 16;\n\t\top->addr.xmm = reg;\n\t\tread_sse_reg(ctxt, &op->vec_val, reg);\n\t\treturn;\n\t}\n\tif (ctxt->d & Mmx) {\n\t\treg &= 7;\n\t\top->type = OP_MM;\n\t\top->bytes = 8;\n\t\top->addr.mm = reg;\n\t\treturn;\n\t}\n\n\top->type = OP_REG;\n\top->bytes = (ctxt->d & ByteOp) ? 1 : ctxt->op_bytes;\n\top->addr.reg = decode_register(ctxt, reg, ctxt->d & ByteOp);\n\n\tfetch_register_operand(op);\n\top->orig_val = op->val;\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define Mmx         ((u64)1 << 40)  /* MMX Vector instruction */",
            "#define ModRM       (1<<19)",
            "#define Sse         (1<<18)     /* SSE Vector instruction */",
            "#define ByteOp      (1<<0)\t/* 8-bit operands. */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\n#define Mmx         ((u64)1 << 40)  /* MMX Vector instruction */\n#define ModRM       (1<<19)\n#define Sse         (1<<18)     /* SSE Vector instruction */\n#define ByteOp      (1<<0)\t/* 8-bit operands. */\n\nstatic void decode_register_operand(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t    struct operand *op)\n{\n\tunsigned reg = ctxt->modrm_reg;\n\n\tif (!(ctxt->d & ModRM))\n\t\treg = (ctxt->b & 7) | ((ctxt->rex_prefix & 1) << 3);\n\n\tif (ctxt->d & Sse) {\n\t\top->type = OP_XMM;\n\t\top->bytes = 16;\n\t\top->addr.xmm = reg;\n\t\tread_sse_reg(ctxt, &op->vec_val, reg);\n\t\treturn;\n\t}\n\tif (ctxt->d & Mmx) {\n\t\treg &= 7;\n\t\top->type = OP_MM;\n\t\top->bytes = 8;\n\t\top->addr.mm = reg;\n\t\treturn;\n\t}\n\n\top->type = OP_REG;\n\top->bytes = (ctxt->d & ByteOp) ? 1 : ctxt->op_bytes;\n\top->addr.reg = decode_register(ctxt, reg, ctxt->d & ByteOp);\n\n\tfetch_register_operand(op);\n\top->orig_val = op->val;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\n#define BitOp       (1<<11)\n#define ByteOp      (1<<0)\t/* 8-bit operands. */\n#define OpAccHi           30ull  /* High part of extended acc (-/DX/EDX/RDX) */\n#define OpAccLo           29ull  /* Low part of extended acc (AX/AX/EAX/RAX) */\n#define OpXLat            28ull  /* memory at BX/EBX/RBX + zero-extended AL */\n#define OpImm64           27ull  /* Sign extended 16/32/64-bit immediate */\n#define OpMem8            26ull  /* 8-bit zero extended memory operand */\n#define OpGS              25ull  /* GS */\n#define OpFS              24ull  /* FS */\n#define OpDS              23ull  /* DS */\n#define OpSS              22ull  /* SS */\n#define OpCS              21ull  /* CS */\n#define OpES              20ull  /* ES */\n#define OpImmU16          19ull  /* Immediate operand, 16 bits, zero extended */\n#define OpMemFAddr        18ull  /* Far address in memory */\n#define OpImmFAddr        17ull  /* Immediate far address */\n#define OpSI              16ull  /* SI/ESI/RSI */\n#define OpImmU            15ull  /* Immediate operand, zero extended */\n#define OpMem32           14ull  /* Memory operand (32-bit). */\n#define OpMem16           13ull  /* Memory operand (16-bit). */\n#define OpImm             12ull  /* Sign extended up to 32-bit immediate */\n#define OpOne             11ull  /* Implied 1 */\n#define OpImmByte         10ull  /* 8-bit sign extended immediate */\n#define OpCL               9ull  /* CL register (for shifts) */\n#define OpDX               8ull  /* DX register */\n#define OpImmUByte         7ull  /* Zero-extended 8-bit immediate */\n#define OpMem64            6ull  /* Memory, 64-bit */\n#define OpDI               5ull  /* ES:DI/EDI/RDI */\n#define OpAcc              4ull  /* Accumulator: AL/AX/EAX/RAX */\n#define OpMem              3ull  /* Memory */\n#define OpReg              2ull  /* Register */\n#define OpImplicit         1ull  /* No generic decode */\n\nstatic int decode_operand(struct x86_emulate_ctxt *ctxt, struct operand *op,\n\t\t\t  unsigned d)\n{\n\tint rc = X86EMUL_CONTINUE;\n\n\tswitch (d) {\n\tcase OpReg:\n\t\tdecode_register_operand(ctxt, op);\n\t\tbreak;\n\tcase OpImmUByte:\n\t\trc = decode_imm(ctxt, op, 1, false);\n\t\tbreak;\n\tcase OpMem:\n\t\tctxt->memop.bytes = (ctxt->d & ByteOp) ? 1 : ctxt->op_bytes;\n\tmem_common:\n\t\t*op = ctxt->memop;\n\t\tctxt->memopp = op;\n\t\tif (ctxt->d & BitOp)\n\t\t\tfetch_bit_operand(ctxt);\n\t\top->orig_val = op->val;\n\t\tbreak;\n\tcase OpMem64:\n\t\tctxt->memop.bytes = (ctxt->op_bytes == 8) ? 16 : 8;\n\t\tgoto mem_common;\n\tcase OpAcc:\n\t\top->type = OP_REG;\n\t\top->bytes = (ctxt->d & ByteOp) ? 1 : ctxt->op_bytes;\n\t\top->addr.reg = reg_rmw(ctxt, VCPU_REGS_RAX);\n\t\tfetch_register_operand(op);\n\t\top->orig_val = op->val;\n\t\tbreak;\n\tcase OpAccLo:\n\t\top->type = OP_REG;\n\t\top->bytes = (ctxt->d & ByteOp) ? 2 : ctxt->op_bytes;\n\t\top->addr.reg = reg_rmw(ctxt, VCPU_REGS_RAX);\n\t\tfetch_register_operand(op);\n\t\top->orig_val = op->val;\n\t\tbreak;\n\tcase OpAccHi:\n\t\tif (ctxt->d & ByteOp) {\n\t\t\top->type = OP_NONE;\n\t\t\tbreak;\n\t\t}\n\t\top->type = OP_REG;\n\t\top->bytes = ctxt->op_bytes;\n\t\top->addr.reg = reg_rmw(ctxt, VCPU_REGS_RDX);\n\t\tfetch_register_operand(op);\n\t\top->orig_val = op->val;\n\t\tbreak;\n\tcase OpDI:\n\t\top->type = OP_MEM;\n\t\top->bytes = (ctxt->d & ByteOp) ? 1 : ctxt->op_bytes;\n\t\top->addr.mem.ea =\n\t\t\tregister_address(ctxt, VCPU_REGS_RDI);\n\t\top->addr.mem.seg = VCPU_SREG_ES;\n\t\top->val = 0;\n\t\top->count = 1;\n\t\tbreak;\n\tcase OpDX:\n\t\top->type = OP_REG;\n\t\top->bytes = 2;\n\t\top->addr.reg = reg_rmw(ctxt, VCPU_REGS_RDX);\n\t\tfetch_register_operand(op);\n\t\tbreak;\n\tcase OpCL:\n\t\top->type = OP_IMM;\n\t\top->bytes = 1;\n\t\top->val = reg_read(ctxt, VCPU_REGS_RCX) & 0xff;\n\t\tbreak;\n\tcase OpImmByte:\n\t\trc = decode_imm(ctxt, op, 1, true);\n\t\tbreak;\n\tcase OpOne:\n\t\top->type = OP_IMM;\n\t\top->bytes = 1;\n\t\top->val = 1;\n\t\tbreak;\n\tcase OpImm:\n\t\trc = decode_imm(ctxt, op, imm_size(ctxt), true);\n\t\tbreak;\n\tcase OpImm64:\n\t\trc = decode_imm(ctxt, op, ctxt->op_bytes, true);\n\t\tbreak;\n\tcase OpMem8:\n\t\tctxt->memop.bytes = 1;\n\t\tif (ctxt->memop.type == OP_REG) {\n\t\t\tctxt->memop.addr.reg = decode_register(ctxt,\n\t\t\t\t\tctxt->modrm_rm, true);\n\t\t\tfetch_register_operand(&ctxt->memop);\n\t\t}\n\t\tgoto mem_common;\n\tcase OpMem16:\n\t\tctxt->memop.bytes = 2;\n\t\tgoto mem_common;\n\tcase OpMem32:\n\t\tctxt->memop.bytes = 4;\n\t\tgoto mem_common;\n\tcase OpImmU16:\n\t\trc = decode_imm(ctxt, op, 2, false);\n\t\tbreak;\n\tcase OpImmU:\n\t\trc = decode_imm(ctxt, op, imm_size(ctxt), false);\n\t\tbreak;\n\tcase OpSI:\n\t\top->type = OP_MEM;\n\t\top->bytes = (ctxt->d & ByteOp) ? 1 : ctxt->op_bytes;\n\t\top->addr.mem.ea =\n\t\t\tregister_address(ctxt, VCPU_REGS_RSI);\n\t\top->addr.mem.seg = ctxt->seg_override;\n\t\top->val = 0;\n\t\top->count = 1;\n\t\tbreak;\n\tcase OpXLat:\n\t\top->type = OP_MEM;\n\t\top->bytes = (ctxt->d & ByteOp) ? 1 : ctxt->op_bytes;\n\t\top->addr.mem.ea =\n\t\t\taddress_mask(ctxt,\n\t\t\t\treg_read(ctxt, VCPU_REGS_RBX) +\n\t\t\t\t(reg_read(ctxt, VCPU_REGS_RAX) & 0xff));\n\t\top->addr.mem.seg = ctxt->seg_override;\n\t\top->val = 0;\n\t\tbreak;\n\tcase OpImmFAddr:\n\t\top->type = OP_IMM;\n\t\top->addr.mem.ea = ctxt->_eip;\n\t\top->bytes = ctxt->op_bytes + 2;\n\t\tinsn_fetch_arr(op->valptr, op->bytes, ctxt);\n\t\tbreak;\n\tcase OpMemFAddr:\n\t\tctxt->memop.bytes = ctxt->op_bytes + 2;\n\t\tgoto mem_common;\n\tcase OpES:\n\t\top->type = OP_IMM;\n\t\top->val = VCPU_SREG_ES;\n\t\tbreak;\n\tcase OpCS:\n\t\top->type = OP_IMM;\n\t\top->val = VCPU_SREG_CS;\n\t\tbreak;\n\tcase OpSS:\n\t\top->type = OP_IMM;\n\t\top->val = VCPU_SREG_SS;\n\t\tbreak;\n\tcase OpDS:\n\t\top->type = OP_IMM;\n\t\top->val = VCPU_SREG_DS;\n\t\tbreak;\n\tcase OpFS:\n\t\top->type = OP_IMM;\n\t\top->val = VCPU_SREG_FS;\n\t\tbreak;\n\tcase OpGS:\n\t\top->type = OP_IMM;\n\t\top->val = VCPU_SREG_GS;\n\t\tbreak;\n\tcase OpImplicit:\n\t\t/* Special instructions do their own operand decoding. */\n\tdefault:\n\t\top->type = OP_NONE; /* Disable writeback. */\n\t\tbreak;\n\t}\n\ndone:\n\treturn rc;\n}"
  },
  {
    "function_name": "decode_imm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "4582-4620",
    "snippet": "static int decode_imm(struct x86_emulate_ctxt *ctxt, struct operand *op,\n\t\t      unsigned size, bool sign_extension)\n{\n\tint rc = X86EMUL_CONTINUE;\n\n\top->type = OP_IMM;\n\top->bytes = size;\n\top->addr.mem.ea = ctxt->_eip;\n\t/* NB. Immediates are sign-extended as necessary. */\n\tswitch (op->bytes) {\n\tcase 1:\n\t\top->val = insn_fetch(s8, ctxt);\n\t\tbreak;\n\tcase 2:\n\t\top->val = insn_fetch(s16, ctxt);\n\t\tbreak;\n\tcase 4:\n\t\top->val = insn_fetch(s32, ctxt);\n\t\tbreak;\n\tcase 8:\n\t\top->val = insn_fetch(s64, ctxt);\n\t\tbreak;\n\t}\n\tif (!sign_extension) {\n\t\tswitch (op->bytes) {\n\t\tcase 1:\n\t\t\top->val &= 0xff;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\top->val &= 0xffff;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\top->val &= 0xffffffff;\n\t\t\tbreak;\n\t\t}\n\t}\ndone:\n\treturn rc;\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "insn_fetch",
          "args": [
            "s64",
            "ctxt"
          ],
          "line": 4602
        },
        "resolved": true,
        "details": {
          "function_name": "do_insn_fetch_bytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "843-852",
          "snippet": "static __always_inline int do_insn_fetch_bytes(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t\t       unsigned size)\n{\n\tunsigned done_size = ctxt->fetch.end - ctxt->fetch.ptr;\n\n\tif (unlikely(done_size < size))\n\t\treturn __do_insn_fetch_bytes(ctxt, size - done_size);\n\telse\n\t\treturn X86EMUL_CONTINUE;\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic __always_inline int do_insn_fetch_bytes(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t\t       unsigned size)\n{\n\tunsigned done_size = ctxt->fetch.end - ctxt->fetch.ptr;\n\n\tif (unlikely(done_size < size))\n\t\treturn __do_insn_fetch_bytes(ctxt, size - done_size);\n\telse\n\t\treturn X86EMUL_CONTINUE;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int decode_imm(struct x86_emulate_ctxt *ctxt, struct operand *op,\n\t\t      unsigned size, bool sign_extension)\n{\n\tint rc = X86EMUL_CONTINUE;\n\n\top->type = OP_IMM;\n\top->bytes = size;\n\top->addr.mem.ea = ctxt->_eip;\n\t/* NB. Immediates are sign-extended as necessary. */\n\tswitch (op->bytes) {\n\tcase 1:\n\t\top->val = insn_fetch(s8, ctxt);\n\t\tbreak;\n\tcase 2:\n\t\top->val = insn_fetch(s16, ctxt);\n\t\tbreak;\n\tcase 4:\n\t\top->val = insn_fetch(s32, ctxt);\n\t\tbreak;\n\tcase 8:\n\t\top->val = insn_fetch(s64, ctxt);\n\t\tbreak;\n\t}\n\tif (!sign_extension) {\n\t\tswitch (op->bytes) {\n\t\tcase 1:\n\t\t\top->val &= 0xff;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\top->val &= 0xffff;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\top->val &= 0xffffffff;\n\t\t\tbreak;\n\t\t}\n\t}\ndone:\n\treturn rc;\n}"
  },
  {
    "function_name": "imm_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "4572-4580",
    "snippet": "static unsigned imm_size(struct x86_emulate_ctxt *ctxt)\n{\n\tunsigned size;\n\n\tsize = (ctxt->d & ByteOp) ? 1 : ctxt->op_bytes;\n\tif (size == 8)\n\t\tsize = 4;\n\treturn size;\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define ByteOp      (1<<0)\t/* 8-bit operands. */"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\n#define ByteOp      (1<<0)\t/* 8-bit operands. */\n\nstatic unsigned imm_size(struct x86_emulate_ctxt *ctxt)\n{\n\tunsigned size;\n\n\tsize = (ctxt->d & ByteOp) ? 1 : ctxt->op_bytes;\n\tif (size == 8)\n\t\tsize = 4;\n\treturn size;\n}"
  },
  {
    "function_name": "check_perm_out",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "4041-4048",
    "snippet": "static int check_perm_out(struct x86_emulate_ctxt *ctxt)\n{\n\tctxt->src.bytes = min(ctxt->src.bytes, 4u);\n\tif (!emulator_io_permited(ctxt, ctxt->dst.val, ctxt->src.bytes))\n\t\treturn emulate_gp(ctxt, 0);\n\n\treturn X86EMUL_CONTINUE;\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "emulate_gp",
          "args": [
            "ctxt",
            "0"
          ],
          "line": 4045
        },
        "resolved": true,
        "details": {
          "function_name": "emulate_gp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "580-583",
          "snippet": "static int emulate_gp(struct x86_emulate_ctxt *ctxt, int err)\n{\n\treturn emulate_exception(ctxt, GP_VECTOR, err, true);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int emulate_gp(struct x86_emulate_ctxt *ctxt, int err)\n{\n\treturn emulate_exception(ctxt, GP_VECTOR, err, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "emulator_io_permited",
          "args": [
            "ctxt",
            "ctxt->dst.val",
            "ctxt->src.bytes"
          ],
          "line": 4044
        },
        "resolved": true,
        "details": {
          "function_name": "emulator_io_permited",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "2848-2861",
          "snippet": "static bool emulator_io_permited(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t u16 port, u16 len)\n{\n\tif (ctxt->perm_ok)\n\t\treturn true;\n\n\tif (emulator_bad_iopl(ctxt))\n\t\tif (!emulator_io_port_access_allowed(ctxt, port, len))\n\t\t\treturn false;\n\n\tctxt->perm_ok = true;\n\n\treturn true;\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic bool emulator_io_permited(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t u16 port, u16 len)\n{\n\tif (ctxt->perm_ok)\n\t\treturn true;\n\n\tif (emulator_bad_iopl(ctxt))\n\t\tif (!emulator_io_port_access_allowed(ctxt, port, len))\n\t\t\treturn false;\n\n\tctxt->perm_ok = true;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "ctxt->src.bytes",
            "4u"
          ],
          "line": 4043
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int check_perm_out(struct x86_emulate_ctxt *ctxt)\n{\n\tctxt->src.bytes = min(ctxt->src.bytes, 4u);\n\tif (!emulator_io_permited(ctxt, ctxt->dst.val, ctxt->src.bytes))\n\t\treturn emulate_gp(ctxt, 0);\n\n\treturn X86EMUL_CONTINUE;\n}"
  },
  {
    "function_name": "check_perm_in",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "4032-4039",
    "snippet": "static int check_perm_in(struct x86_emulate_ctxt *ctxt)\n{\n\tctxt->dst.bytes = min(ctxt->dst.bytes, 4u);\n\tif (!emulator_io_permited(ctxt, ctxt->src.val, ctxt->dst.bytes))\n\t\treturn emulate_gp(ctxt, 0);\n\n\treturn X86EMUL_CONTINUE;\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "emulate_gp",
          "args": [
            "ctxt",
            "0"
          ],
          "line": 4036
        },
        "resolved": true,
        "details": {
          "function_name": "emulate_gp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "580-583",
          "snippet": "static int emulate_gp(struct x86_emulate_ctxt *ctxt, int err)\n{\n\treturn emulate_exception(ctxt, GP_VECTOR, err, true);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int emulate_gp(struct x86_emulate_ctxt *ctxt, int err)\n{\n\treturn emulate_exception(ctxt, GP_VECTOR, err, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "emulator_io_permited",
          "args": [
            "ctxt",
            "ctxt->src.val",
            "ctxt->dst.bytes"
          ],
          "line": 4035
        },
        "resolved": true,
        "details": {
          "function_name": "emulator_io_permited",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "2848-2861",
          "snippet": "static bool emulator_io_permited(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t u16 port, u16 len)\n{\n\tif (ctxt->perm_ok)\n\t\treturn true;\n\n\tif (emulator_bad_iopl(ctxt))\n\t\tif (!emulator_io_port_access_allowed(ctxt, port, len))\n\t\t\treturn false;\n\n\tctxt->perm_ok = true;\n\n\treturn true;\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic bool emulator_io_permited(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t u16 port, u16 len)\n{\n\tif (ctxt->perm_ok)\n\t\treturn true;\n\n\tif (emulator_bad_iopl(ctxt))\n\t\tif (!emulator_io_port_access_allowed(ctxt, port, len))\n\t\t\treturn false;\n\n\tctxt->perm_ok = true;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "ctxt->dst.bytes",
            "4u"
          ],
          "line": 4034
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int check_perm_in(struct x86_emulate_ctxt *ctxt)\n{\n\tctxt->dst.bytes = min(ctxt->dst.bytes, 4u);\n\tif (!emulator_io_permited(ctxt, ctxt->src.val, ctxt->dst.bytes))\n\t\treturn emulate_gp(ctxt, 0);\n\n\treturn X86EMUL_CONTINUE;\n}"
  },
  {
    "function_name": "check_rdpmc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "4020-4030",
    "snippet": "static int check_rdpmc(struct x86_emulate_ctxt *ctxt)\n{\n\tu64 cr4 = ctxt->ops->get_cr(ctxt, 4);\n\tu64 rcx = reg_read(ctxt, VCPU_REGS_RCX);\n\n\tif ((!(cr4 & X86_CR4_PCE) && ctxt->ops->cpl(ctxt)) ||\n\t    ctxt->ops->check_pmc(ctxt, rcx))\n\t\treturn emulate_gp(ctxt, 0);\n\n\treturn X86EMUL_CONTINUE;\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "emulate_gp",
          "args": [
            "ctxt",
            "0"
          ],
          "line": 4027
        },
        "resolved": true,
        "details": {
          "function_name": "emulate_gp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "580-583",
          "snippet": "static int emulate_gp(struct x86_emulate_ctxt *ctxt, int err)\n{\n\treturn emulate_exception(ctxt, GP_VECTOR, err, true);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int emulate_gp(struct x86_emulate_ctxt *ctxt, int err)\n{\n\treturn emulate_exception(ctxt, GP_VECTOR, err, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ctxt->ops->check_pmc",
          "args": [
            "ctxt",
            "rcx"
          ],
          "line": 4026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ctxt->ops->cpl",
          "args": [
            "ctxt"
          ],
          "line": 4025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reg_read",
          "args": [
            "ctxt",
            "VCPU_REGS_RCX"
          ],
          "line": 4023
        },
        "resolved": true,
        "details": {
          "function_name": "reg_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "261-268",
          "snippet": "static ulong reg_read(struct x86_emulate_ctxt *ctxt, unsigned nr)\n{\n\tif (!(ctxt->regs_valid & (1 << nr))) {\n\t\tctxt->regs_valid |= 1 << nr;\n\t\tctxt->_regs[nr] = ctxt->ops->read_gpr(ctxt, nr);\n\t}\n\treturn ctxt->_regs[nr];\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic ulong reg_read(struct x86_emulate_ctxt *ctxt, unsigned nr)\n{\n\tif (!(ctxt->regs_valid & (1 << nr))) {\n\t\tctxt->regs_valid |= 1 << nr;\n\t\tctxt->_regs[nr] = ctxt->ops->read_gpr(ctxt, nr);\n\t}\n\treturn ctxt->_regs[nr];\n}"
        }
      },
      {
        "call_info": {
          "callee": "ctxt->ops->get_cr",
          "args": [
            "ctxt",
            "4"
          ],
          "line": 4022
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int check_rdpmc(struct x86_emulate_ctxt *ctxt)\n{\n\tu64 cr4 = ctxt->ops->get_cr(ctxt, 4);\n\tu64 rcx = reg_read(ctxt, VCPU_REGS_RCX);\n\n\tif ((!(cr4 & X86_CR4_PCE) && ctxt->ops->cpl(ctxt)) ||\n\t    ctxt->ops->check_pmc(ctxt, rcx))\n\t\treturn emulate_gp(ctxt, 0);\n\n\treturn X86EMUL_CONTINUE;\n}"
  },
  {
    "function_name": "check_rdtsc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "4010-4018",
    "snippet": "static int check_rdtsc(struct x86_emulate_ctxt *ctxt)\n{\n\tu64 cr4 = ctxt->ops->get_cr(ctxt, 4);\n\n\tif (cr4 & X86_CR4_TSD && ctxt->ops->cpl(ctxt))\n\t\treturn emulate_ud(ctxt);\n\n\treturn X86EMUL_CONTINUE;\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "emulate_ud",
          "args": [
            "ctxt"
          ],
          "line": 4015
        },
        "resolved": true,
        "details": {
          "function_name": "emulate_ud",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "590-593",
          "snippet": "static int emulate_ud(struct x86_emulate_ctxt *ctxt)\n{\n\treturn emulate_exception(ctxt, UD_VECTOR, 0, false);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int emulate_ud(struct x86_emulate_ctxt *ctxt)\n{\n\treturn emulate_exception(ctxt, UD_VECTOR, 0, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ctxt->ops->cpl",
          "args": [
            "ctxt"
          ],
          "line": 4014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ctxt->ops->get_cr",
          "args": [
            "ctxt",
            "4"
          ],
          "line": 4012
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int check_rdtsc(struct x86_emulate_ctxt *ctxt)\n{\n\tu64 cr4 = ctxt->ops->get_cr(ctxt, 4);\n\n\tif (cr4 & X86_CR4_TSD && ctxt->ops->cpl(ctxt))\n\t\treturn emulate_ud(ctxt);\n\n\treturn X86EMUL_CONTINUE;\n}"
  },
  {
    "function_name": "check_svme_pa",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "3999-4008",
    "snippet": "static int check_svme_pa(struct x86_emulate_ctxt *ctxt)\n{\n\tu64 rax = reg_read(ctxt, VCPU_REGS_RAX);\n\n\t/* Valid physical address? */\n\tif (rax & 0xffff000000000000ULL)\n\t\treturn emulate_gp(ctxt, 0);\n\n\treturn check_svme(ctxt);\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "check_svme",
          "args": [
            "ctxt"
          ],
          "line": 4007
        },
        "resolved": true,
        "details": {
          "function_name": "check_svme_pa",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "3999-4008",
          "snippet": "static int check_svme_pa(struct x86_emulate_ctxt *ctxt)\n{\n\tu64 rax = reg_read(ctxt, VCPU_REGS_RAX);\n\n\t/* Valid physical address? */\n\tif (rax & 0xffff000000000000ULL)\n\t\treturn emulate_gp(ctxt, 0);\n\n\treturn check_svme(ctxt);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "emulate_gp",
          "args": [
            "ctxt",
            "0"
          ],
          "line": 4005
        },
        "resolved": true,
        "details": {
          "function_name": "emulate_gp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "580-583",
          "snippet": "static int emulate_gp(struct x86_emulate_ctxt *ctxt, int err)\n{\n\treturn emulate_exception(ctxt, GP_VECTOR, err, true);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int emulate_gp(struct x86_emulate_ctxt *ctxt, int err)\n{\n\treturn emulate_exception(ctxt, GP_VECTOR, err, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reg_read",
          "args": [
            "ctxt",
            "VCPU_REGS_RAX"
          ],
          "line": 4001
        },
        "resolved": true,
        "details": {
          "function_name": "reg_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "261-268",
          "snippet": "static ulong reg_read(struct x86_emulate_ctxt *ctxt, unsigned nr)\n{\n\tif (!(ctxt->regs_valid & (1 << nr))) {\n\t\tctxt->regs_valid |= 1 << nr;\n\t\tctxt->_regs[nr] = ctxt->ops->read_gpr(ctxt, nr);\n\t}\n\treturn ctxt->_regs[nr];\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic ulong reg_read(struct x86_emulate_ctxt *ctxt, unsigned nr)\n{\n\tif (!(ctxt->regs_valid & (1 << nr))) {\n\t\tctxt->regs_valid |= 1 << nr;\n\t\tctxt->_regs[nr] = ctxt->ops->read_gpr(ctxt, nr);\n\t}\n\treturn ctxt->_regs[nr];\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int check_svme_pa(struct x86_emulate_ctxt *ctxt)\n{\n\tu64 rax = reg_read(ctxt, VCPU_REGS_RAX);\n\n\t/* Valid physical address? */\n\tif (rax & 0xffff000000000000ULL)\n\t\treturn emulate_gp(ctxt, 0);\n\n\treturn check_svme(ctxt);\n}"
  },
  {
    "function_name": "check_svme",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "3987-3997",
    "snippet": "static int check_svme(struct x86_emulate_ctxt *ctxt)\n{\n\tu64 efer;\n\n\tctxt->ops->get_msr(ctxt, MSR_EFER, &efer);\n\n\tif (!(efer & EFER_SVME))\n\t\treturn emulate_ud(ctxt);\n\n\treturn X86EMUL_CONTINUE;\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "emulate_ud",
          "args": [
            "ctxt"
          ],
          "line": 3994
        },
        "resolved": true,
        "details": {
          "function_name": "emulate_ud",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "590-593",
          "snippet": "static int emulate_ud(struct x86_emulate_ctxt *ctxt)\n{\n\treturn emulate_exception(ctxt, UD_VECTOR, 0, false);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int emulate_ud(struct x86_emulate_ctxt *ctxt)\n{\n\treturn emulate_exception(ctxt, UD_VECTOR, 0, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ctxt->ops->get_msr",
          "args": [
            "ctxt",
            "MSR_EFER",
            "&efer"
          ],
          "line": 3991
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int check_svme(struct x86_emulate_ctxt *ctxt)\n{\n\tu64 efer;\n\n\tctxt->ops->get_msr(ctxt, MSR_EFER, &efer);\n\n\tif (!(efer & EFER_SVME))\n\t\treturn emulate_ud(ctxt);\n\n\treturn X86EMUL_CONTINUE;\n}"
  },
  {
    "function_name": "check_dr_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "3976-3985",
    "snippet": "static int check_dr_write(struct x86_emulate_ctxt *ctxt)\n{\n\tu64 new_val = ctxt->src.val64;\n\tint dr = ctxt->modrm_reg;\n\n\tif ((dr == 6 || dr == 7) && (new_val & 0xffffffff00000000ULL))\n\t\treturn emulate_gp(ctxt, 0);\n\n\treturn check_dr_read(ctxt);\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "check_dr_read",
          "args": [
            "ctxt"
          ],
          "line": 3984
        },
        "resolved": true,
        "details": {
          "function_name": "check_dr_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "3951-3974",
          "snippet": "static int check_dr_read(struct x86_emulate_ctxt *ctxt)\n{\n\tint dr = ctxt->modrm_reg;\n\tu64 cr4;\n\n\tif (dr > 7)\n\t\treturn emulate_ud(ctxt);\n\n\tcr4 = ctxt->ops->get_cr(ctxt, 4);\n\tif ((cr4 & X86_CR4_DE) && (dr == 4 || dr == 5))\n\t\treturn emulate_ud(ctxt);\n\n\tif (check_dr7_gd(ctxt)) {\n\t\tulong dr6;\n\n\t\tctxt->ops->get_dr(ctxt, 6, &dr6);\n\t\tdr6 &= ~15;\n\t\tdr6 |= DR6_BD | DR6_RTM;\n\t\tctxt->ops->set_dr(ctxt, 6, dr6);\n\t\treturn emulate_db(ctxt);\n\t}\n\n\treturn X86EMUL_CONTINUE;\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int check_dr_read(struct x86_emulate_ctxt *ctxt)\n{\n\tint dr = ctxt->modrm_reg;\n\tu64 cr4;\n\n\tif (dr > 7)\n\t\treturn emulate_ud(ctxt);\n\n\tcr4 = ctxt->ops->get_cr(ctxt, 4);\n\tif ((cr4 & X86_CR4_DE) && (dr == 4 || dr == 5))\n\t\treturn emulate_ud(ctxt);\n\n\tif (check_dr7_gd(ctxt)) {\n\t\tulong dr6;\n\n\t\tctxt->ops->get_dr(ctxt, 6, &dr6);\n\t\tdr6 &= ~15;\n\t\tdr6 |= DR6_BD | DR6_RTM;\n\t\tctxt->ops->set_dr(ctxt, 6, dr6);\n\t\treturn emulate_db(ctxt);\n\t}\n\n\treturn X86EMUL_CONTINUE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "emulate_gp",
          "args": [
            "ctxt",
            "0"
          ],
          "line": 3982
        },
        "resolved": true,
        "details": {
          "function_name": "emulate_gp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "580-583",
          "snippet": "static int emulate_gp(struct x86_emulate_ctxt *ctxt, int err)\n{\n\treturn emulate_exception(ctxt, GP_VECTOR, err, true);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int emulate_gp(struct x86_emulate_ctxt *ctxt, int err)\n{\n\treturn emulate_exception(ctxt, GP_VECTOR, err, true);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int check_dr_write(struct x86_emulate_ctxt *ctxt)\n{\n\tu64 new_val = ctxt->src.val64;\n\tint dr = ctxt->modrm_reg;\n\n\tif ((dr == 6 || dr == 7) && (new_val & 0xffffffff00000000ULL))\n\t\treturn emulate_gp(ctxt, 0);\n\n\treturn check_dr_read(ctxt);\n}"
  },
  {
    "function_name": "check_dr_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "3951-3974",
    "snippet": "static int check_dr_read(struct x86_emulate_ctxt *ctxt)\n{\n\tint dr = ctxt->modrm_reg;\n\tu64 cr4;\n\n\tif (dr > 7)\n\t\treturn emulate_ud(ctxt);\n\n\tcr4 = ctxt->ops->get_cr(ctxt, 4);\n\tif ((cr4 & X86_CR4_DE) && (dr == 4 || dr == 5))\n\t\treturn emulate_ud(ctxt);\n\n\tif (check_dr7_gd(ctxt)) {\n\t\tulong dr6;\n\n\t\tctxt->ops->get_dr(ctxt, 6, &dr6);\n\t\tdr6 &= ~15;\n\t\tdr6 |= DR6_BD | DR6_RTM;\n\t\tctxt->ops->set_dr(ctxt, 6, dr6);\n\t\treturn emulate_db(ctxt);\n\t}\n\n\treturn X86EMUL_CONTINUE;\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "emulate_db",
          "args": [
            "ctxt"
          ],
          "line": 3970
        },
        "resolved": true,
        "details": {
          "function_name": "emulate_db",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "575-578",
          "snippet": "static int emulate_db(struct x86_emulate_ctxt *ctxt)\n{\n\treturn emulate_exception(ctxt, DB_VECTOR, 0, false);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int emulate_db(struct x86_emulate_ctxt *ctxt)\n{\n\treturn emulate_exception(ctxt, DB_VECTOR, 0, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ctxt->ops->set_dr",
          "args": [
            "ctxt",
            "6",
            "dr6"
          ],
          "line": 3969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ctxt->ops->get_dr",
          "args": [
            "ctxt",
            "6",
            "&dr6"
          ],
          "line": 3966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_dr7_gd",
          "args": [
            "ctxt"
          ],
          "line": 3963
        },
        "resolved": true,
        "details": {
          "function_name": "check_dr7_gd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "3941-3949",
          "snippet": "static int check_dr7_gd(struct x86_emulate_ctxt *ctxt)\n{\n\tunsigned long dr7;\n\n\tctxt->ops->get_dr(ctxt, 7, &dr7);\n\n\t/* Check if DR7.Global_Enable is set */\n\treturn dr7 & (1 << 13);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int check_dr7_gd(struct x86_emulate_ctxt *ctxt)\n{\n\tunsigned long dr7;\n\n\tctxt->ops->get_dr(ctxt, 7, &dr7);\n\n\t/* Check if DR7.Global_Enable is set */\n\treturn dr7 & (1 << 13);\n}"
        }
      },
      {
        "call_info": {
          "callee": "emulate_ud",
          "args": [
            "ctxt"
          ],
          "line": 3961
        },
        "resolved": true,
        "details": {
          "function_name": "emulate_ud",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "590-593",
          "snippet": "static int emulate_ud(struct x86_emulate_ctxt *ctxt)\n{\n\treturn emulate_exception(ctxt, UD_VECTOR, 0, false);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int emulate_ud(struct x86_emulate_ctxt *ctxt)\n{\n\treturn emulate_exception(ctxt, UD_VECTOR, 0, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ctxt->ops->get_cr",
          "args": [
            "ctxt",
            "4"
          ],
          "line": 3959
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int check_dr_read(struct x86_emulate_ctxt *ctxt)\n{\n\tint dr = ctxt->modrm_reg;\n\tu64 cr4;\n\n\tif (dr > 7)\n\t\treturn emulate_ud(ctxt);\n\n\tcr4 = ctxt->ops->get_cr(ctxt, 4);\n\tif ((cr4 & X86_CR4_DE) && (dr == 4 || dr == 5))\n\t\treturn emulate_ud(ctxt);\n\n\tif (check_dr7_gd(ctxt)) {\n\t\tulong dr6;\n\n\t\tctxt->ops->get_dr(ctxt, 6, &dr6);\n\t\tdr6 &= ~15;\n\t\tdr6 |= DR6_BD | DR6_RTM;\n\t\tctxt->ops->set_dr(ctxt, 6, dr6);\n\t\treturn emulate_db(ctxt);\n\t}\n\n\treturn X86EMUL_CONTINUE;\n}"
  },
  {
    "function_name": "check_dr7_gd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "3941-3949",
    "snippet": "static int check_dr7_gd(struct x86_emulate_ctxt *ctxt)\n{\n\tunsigned long dr7;\n\n\tctxt->ops->get_dr(ctxt, 7, &dr7);\n\n\t/* Check if DR7.Global_Enable is set */\n\treturn dr7 & (1 << 13);\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ctxt->ops->get_dr",
          "args": [
            "ctxt",
            "7",
            "&dr7"
          ],
          "line": 3945
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int check_dr7_gd(struct x86_emulate_ctxt *ctxt)\n{\n\tunsigned long dr7;\n\n\tctxt->ops->get_dr(ctxt, 7, &dr7);\n\n\t/* Check if DR7.Global_Enable is set */\n\treturn dr7 & (1 << 13);\n}"
  },
  {
    "function_name": "check_cr_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "3880-3939",
    "snippet": "static int check_cr_write(struct x86_emulate_ctxt *ctxt)\n{\n\tu64 new_val = ctxt->src.val64;\n\tint cr = ctxt->modrm_reg;\n\tu64 efer = 0;\n\n\tstatic u64 cr_reserved_bits[] = {\n\t\t0xffffffff00000000ULL,\n\t\t0, 0, 0, /* CR3 checked later */\n\t\tCR4_RESERVED_BITS,\n\t\t0, 0, 0,\n\t\tCR8_RESERVED_BITS,\n\t};\n\n\tif (!valid_cr(cr))\n\t\treturn emulate_ud(ctxt);\n\n\tif (new_val & cr_reserved_bits[cr])\n\t\treturn emulate_gp(ctxt, 0);\n\n\tswitch (cr) {\n\tcase 0: {\n\t\tu64 cr4;\n\t\tif (((new_val & X86_CR0_PG) && !(new_val & X86_CR0_PE)) ||\n\t\t    ((new_val & X86_CR0_NW) && !(new_val & X86_CR0_CD)))\n\t\t\treturn emulate_gp(ctxt, 0);\n\n\t\tcr4 = ctxt->ops->get_cr(ctxt, 4);\n\t\tctxt->ops->get_msr(ctxt, MSR_EFER, &efer);\n\n\t\tif ((new_val & X86_CR0_PG) && (efer & EFER_LME) &&\n\t\t    !(cr4 & X86_CR4_PAE))\n\t\t\treturn emulate_gp(ctxt, 0);\n\n\t\tbreak;\n\t\t}\n\tcase 3: {\n\t\tu64 rsvd = 0;\n\n\t\tctxt->ops->get_msr(ctxt, MSR_EFER, &efer);\n\t\tif (efer & EFER_LMA)\n\t\t\trsvd = CR3_L_MODE_RESERVED_BITS & ~CR3_PCID_INVD;\n\n\t\tif (new_val & rsvd)\n\t\t\treturn emulate_gp(ctxt, 0);\n\n\t\tbreak;\n\t\t}\n\tcase 4: {\n\t\tctxt->ops->get_msr(ctxt, MSR_EFER, &efer);\n\n\t\tif ((efer & EFER_LMA) && !(new_val & X86_CR4_PAE))\n\t\t\treturn emulate_gp(ctxt, 0);\n\n\t\tbreak;\n\t\t}\n\t}\n\n\treturn X86EMUL_CONTINUE;\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "emulate_gp",
          "args": [
            "ctxt",
            "0"
          ],
          "line": 3932
        },
        "resolved": true,
        "details": {
          "function_name": "emulate_gp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "580-583",
          "snippet": "static int emulate_gp(struct x86_emulate_ctxt *ctxt, int err)\n{\n\treturn emulate_exception(ctxt, GP_VECTOR, err, true);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int emulate_gp(struct x86_emulate_ctxt *ctxt, int err)\n{\n\treturn emulate_exception(ctxt, GP_VECTOR, err, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ctxt->ops->get_msr",
          "args": [
            "ctxt",
            "MSR_EFER",
            "&efer"
          ],
          "line": 3929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ctxt->ops->get_msr",
          "args": [
            "ctxt",
            "MSR_EFER",
            "&efer"
          ],
          "line": 3919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ctxt->ops->get_msr",
          "args": [
            "ctxt",
            "MSR_EFER",
            "&efer"
          ],
          "line": 3908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ctxt->ops->get_cr",
          "args": [
            "ctxt",
            "4"
          ],
          "line": 3907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "emulate_ud",
          "args": [
            "ctxt"
          ],
          "line": 3895
        },
        "resolved": true,
        "details": {
          "function_name": "emulate_ud",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "590-593",
          "snippet": "static int emulate_ud(struct x86_emulate_ctxt *ctxt)\n{\n\treturn emulate_exception(ctxt, UD_VECTOR, 0, false);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int emulate_ud(struct x86_emulate_ctxt *ctxt)\n{\n\treturn emulate_exception(ctxt, UD_VECTOR, 0, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "valid_cr",
          "args": [
            "cr"
          ],
          "line": 3894
        },
        "resolved": true,
        "details": {
          "function_name": "valid_cr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "3860-3870",
          "snippet": "static bool valid_cr(int nr)\n{\n\tswitch (nr) {\n\tcase 0:\n\tcase 2 ... 4:\n\tcase 8:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic bool valid_cr(int nr)\n{\n\tswitch (nr) {\n\tcase 0:\n\tcase 2 ... 4:\n\tcase 8:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int check_cr_write(struct x86_emulate_ctxt *ctxt)\n{\n\tu64 new_val = ctxt->src.val64;\n\tint cr = ctxt->modrm_reg;\n\tu64 efer = 0;\n\n\tstatic u64 cr_reserved_bits[] = {\n\t\t0xffffffff00000000ULL,\n\t\t0, 0, 0, /* CR3 checked later */\n\t\tCR4_RESERVED_BITS,\n\t\t0, 0, 0,\n\t\tCR8_RESERVED_BITS,\n\t};\n\n\tif (!valid_cr(cr))\n\t\treturn emulate_ud(ctxt);\n\n\tif (new_val & cr_reserved_bits[cr])\n\t\treturn emulate_gp(ctxt, 0);\n\n\tswitch (cr) {\n\tcase 0: {\n\t\tu64 cr4;\n\t\tif (((new_val & X86_CR0_PG) && !(new_val & X86_CR0_PE)) ||\n\t\t    ((new_val & X86_CR0_NW) && !(new_val & X86_CR0_CD)))\n\t\t\treturn emulate_gp(ctxt, 0);\n\n\t\tcr4 = ctxt->ops->get_cr(ctxt, 4);\n\t\tctxt->ops->get_msr(ctxt, MSR_EFER, &efer);\n\n\t\tif ((new_val & X86_CR0_PG) && (efer & EFER_LME) &&\n\t\t    !(cr4 & X86_CR4_PAE))\n\t\t\treturn emulate_gp(ctxt, 0);\n\n\t\tbreak;\n\t\t}\n\tcase 3: {\n\t\tu64 rsvd = 0;\n\n\t\tctxt->ops->get_msr(ctxt, MSR_EFER, &efer);\n\t\tif (efer & EFER_LMA)\n\t\t\trsvd = CR3_L_MODE_RESERVED_BITS & ~CR3_PCID_INVD;\n\n\t\tif (new_val & rsvd)\n\t\t\treturn emulate_gp(ctxt, 0);\n\n\t\tbreak;\n\t\t}\n\tcase 4: {\n\t\tctxt->ops->get_msr(ctxt, MSR_EFER, &efer);\n\n\t\tif ((efer & EFER_LMA) && !(new_val & X86_CR4_PAE))\n\t\t\treturn emulate_gp(ctxt, 0);\n\n\t\tbreak;\n\t\t}\n\t}\n\n\treturn X86EMUL_CONTINUE;\n}"
  },
  {
    "function_name": "check_cr_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "3872-3878",
    "snippet": "static int check_cr_read(struct x86_emulate_ctxt *ctxt)\n{\n\tif (!valid_cr(ctxt->modrm_reg))\n\t\treturn emulate_ud(ctxt);\n\n\treturn X86EMUL_CONTINUE;\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "emulate_ud",
          "args": [
            "ctxt"
          ],
          "line": 3875
        },
        "resolved": true,
        "details": {
          "function_name": "emulate_ud",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "590-593",
          "snippet": "static int emulate_ud(struct x86_emulate_ctxt *ctxt)\n{\n\treturn emulate_exception(ctxt, UD_VECTOR, 0, false);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int emulate_ud(struct x86_emulate_ctxt *ctxt)\n{\n\treturn emulate_exception(ctxt, UD_VECTOR, 0, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "valid_cr",
          "args": [
            "ctxt->modrm_reg"
          ],
          "line": 3874
        },
        "resolved": true,
        "details": {
          "function_name": "valid_cr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "3860-3870",
          "snippet": "static bool valid_cr(int nr)\n{\n\tswitch (nr) {\n\tcase 0:\n\tcase 2 ... 4:\n\tcase 8:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic bool valid_cr(int nr)\n{\n\tswitch (nr) {\n\tcase 0:\n\tcase 2 ... 4:\n\tcase 8:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int check_cr_read(struct x86_emulate_ctxt *ctxt)\n{\n\tif (!valid_cr(ctxt->modrm_reg))\n\t\treturn emulate_ud(ctxt);\n\n\treturn X86EMUL_CONTINUE;\n}"
  },
  {
    "function_name": "valid_cr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "3860-3870",
    "snippet": "static bool valid_cr(int nr)\n{\n\tswitch (nr) {\n\tcase 0:\n\tcase 2 ... 4:\n\tcase 8:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic bool valid_cr(int nr)\n{\n\tswitch (nr) {\n\tcase 0:\n\tcase 2 ... 4:\n\tcase 8:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}"
  },
  {
    "function_name": "em_movsxd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "3854-3858",
    "snippet": "static int em_movsxd(struct x86_emulate_ctxt *ctxt)\n{\n\tctxt->dst.val = (s32) ctxt->src.val;\n\treturn X86EMUL_CONTINUE;\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int em_movsxd(struct x86_emulate_ctxt *ctxt)\n{\n\tctxt->dst.val = (s32) ctxt->src.val;\n\treturn X86EMUL_CONTINUE;\n}"
  },
  {
    "function_name": "em_clflush",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "3848-3852",
    "snippet": "static int em_clflush(struct x86_emulate_ctxt *ctxt)\n{\n\t/* emulating clflush regardless of cpuid */\n\treturn X86EMUL_CONTINUE;\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int em_clflush(struct x86_emulate_ctxt *ctxt)\n{\n\t/* emulating clflush regardless of cpuid */\n\treturn X86EMUL_CONTINUE;\n}"
  },
  {
    "function_name": "em_bswap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "3833-3846",
    "snippet": "static int em_bswap(struct x86_emulate_ctxt *ctxt)\n{\n\tswitch (ctxt->op_bytes) {\n#ifdef CONFIG_X86_64\n\tcase 8:\n\t\tasm(\"bswap %0\" : \"+r\"(ctxt->dst.val));\n\t\tbreak;\n#endif\n\tdefault:\n\t\tasm(\"bswap %0\" : \"+r\"(*(u32 *)&ctxt->dst.val));\n\t\tbreak;\n\t}\n\treturn X86EMUL_CONTINUE;\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int em_bswap(struct x86_emulate_ctxt *ctxt)\n{\n\tswitch (ctxt->op_bytes) {\n#ifdef CONFIG_X86_64\n\tcase 8:\n\t\tasm(\"bswap %0\" : \"+r\"(ctxt->dst.val));\n\t\tbreak;\n#endif\n\tdefault:\n\t\tasm(\"bswap %0\" : \"+r\"(*(u32 *)&ctxt->dst.val));\n\t\tbreak;\n\t}\n\treturn X86EMUL_CONTINUE;\n}"
  },
  {
    "function_name": "em_lahf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "3826-3831",
    "snippet": "static int em_lahf(struct x86_emulate_ctxt *ctxt)\n{\n\t*reg_rmw(ctxt, VCPU_REGS_RAX) &= ~0xff00UL;\n\t*reg_rmw(ctxt, VCPU_REGS_RAX) |= (ctxt->eflags & 0xff) << 8;\n\treturn X86EMUL_CONTINUE;\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reg_rmw",
          "args": [
            "ctxt",
            "VCPU_REGS_RAX"
          ],
          "line": 3829
        },
        "resolved": true,
        "details": {
          "function_name": "reg_rmw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "277-281",
          "snippet": "static ulong *reg_rmw(struct x86_emulate_ctxt *ctxt, unsigned nr)\n{\n\treg_read(ctxt, nr);\n\treturn reg_write(ctxt, nr);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic ulong *reg_rmw(struct x86_emulate_ctxt *ctxt, unsigned nr)\n{\n\treg_read(ctxt, nr);\n\treturn reg_write(ctxt, nr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int em_lahf(struct x86_emulate_ctxt *ctxt)\n{\n\t*reg_rmw(ctxt, VCPU_REGS_RAX) &= ~0xff00UL;\n\t*reg_rmw(ctxt, VCPU_REGS_RAX) |= (ctxt->eflags & 0xff) << 8;\n\treturn X86EMUL_CONTINUE;\n}"
  },
  {
    "function_name": "em_sahf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "3813-3824",
    "snippet": "static int em_sahf(struct x86_emulate_ctxt *ctxt)\n{\n\tu32 flags;\n\n\tflags = X86_EFLAGS_CF | X86_EFLAGS_PF | X86_EFLAGS_AF | X86_EFLAGS_ZF |\n\t\tX86_EFLAGS_SF;\n\tflags &= *reg_rmw(ctxt, VCPU_REGS_RAX) >> 8;\n\n\tctxt->eflags &= ~0xffUL;\n\tctxt->eflags |= flags | X86_EFLAGS_FIXED;\n\treturn X86EMUL_CONTINUE;\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reg_rmw",
          "args": [
            "ctxt",
            "VCPU_REGS_RAX"
          ],
          "line": 3819
        },
        "resolved": true,
        "details": {
          "function_name": "reg_rmw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "277-281",
          "snippet": "static ulong *reg_rmw(struct x86_emulate_ctxt *ctxt, unsigned nr)\n{\n\treg_read(ctxt, nr);\n\treturn reg_write(ctxt, nr);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic ulong *reg_rmw(struct x86_emulate_ctxt *ctxt, unsigned nr)\n{\n\treg_read(ctxt, nr);\n\treturn reg_write(ctxt, nr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int em_sahf(struct x86_emulate_ctxt *ctxt)\n{\n\tu32 flags;\n\n\tflags = X86_EFLAGS_CF | X86_EFLAGS_PF | X86_EFLAGS_AF | X86_EFLAGS_ZF |\n\t\tX86_EFLAGS_SF;\n\tflags &= *reg_rmw(ctxt, VCPU_REGS_RAX) >> 8;\n\n\tctxt->eflags &= ~0xffUL;\n\tctxt->eflags |= flags | X86_EFLAGS_FIXED;\n\treturn X86EMUL_CONTINUE;\n}"
  },
  {
    "function_name": "em_cpuid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "3799-3811",
    "snippet": "static int em_cpuid(struct x86_emulate_ctxt *ctxt)\n{\n\tu32 eax, ebx, ecx, edx;\n\n\teax = reg_read(ctxt, VCPU_REGS_RAX);\n\tecx = reg_read(ctxt, VCPU_REGS_RCX);\n\tctxt->ops->get_cpuid(ctxt, &eax, &ebx, &ecx, &edx);\n\t*reg_write(ctxt, VCPU_REGS_RAX) = eax;\n\t*reg_write(ctxt, VCPU_REGS_RBX) = ebx;\n\t*reg_write(ctxt, VCPU_REGS_RCX) = ecx;\n\t*reg_write(ctxt, VCPU_REGS_RDX) = edx;\n\treturn X86EMUL_CONTINUE;\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reg_write",
          "args": [
            "ctxt",
            "VCPU_REGS_RDX"
          ],
          "line": 3809
        },
        "resolved": true,
        "details": {
          "function_name": "reg_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "270-275",
          "snippet": "static ulong *reg_write(struct x86_emulate_ctxt *ctxt, unsigned nr)\n{\n\tctxt->regs_valid |= 1 << nr;\n\tctxt->regs_dirty |= 1 << nr;\n\treturn &ctxt->_regs[nr];\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic ulong *reg_write(struct x86_emulate_ctxt *ctxt, unsigned nr)\n{\n\tctxt->regs_valid |= 1 << nr;\n\tctxt->regs_dirty |= 1 << nr;\n\treturn &ctxt->_regs[nr];\n}"
        }
      },
      {
        "call_info": {
          "callee": "ctxt->ops->get_cpuid",
          "args": [
            "ctxt",
            "&eax",
            "&ebx",
            "&ecx",
            "&edx"
          ],
          "line": 3805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reg_read",
          "args": [
            "ctxt",
            "VCPU_REGS_RCX"
          ],
          "line": 3804
        },
        "resolved": true,
        "details": {
          "function_name": "reg_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "261-268",
          "snippet": "static ulong reg_read(struct x86_emulate_ctxt *ctxt, unsigned nr)\n{\n\tif (!(ctxt->regs_valid & (1 << nr))) {\n\t\tctxt->regs_valid |= 1 << nr;\n\t\tctxt->_regs[nr] = ctxt->ops->read_gpr(ctxt, nr);\n\t}\n\treturn ctxt->_regs[nr];\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic ulong reg_read(struct x86_emulate_ctxt *ctxt, unsigned nr)\n{\n\tif (!(ctxt->regs_valid & (1 << nr))) {\n\t\tctxt->regs_valid |= 1 << nr;\n\t\tctxt->_regs[nr] = ctxt->ops->read_gpr(ctxt, nr);\n\t}\n\treturn ctxt->_regs[nr];\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int em_cpuid(struct x86_emulate_ctxt *ctxt)\n{\n\tu32 eax, ebx, ecx, edx;\n\n\teax = reg_read(ctxt, VCPU_REGS_RAX);\n\tecx = reg_read(ctxt, VCPU_REGS_RCX);\n\tctxt->ops->get_cpuid(ctxt, &eax, &ebx, &ecx, &edx);\n\t*reg_write(ctxt, VCPU_REGS_RAX) = eax;\n\t*reg_write(ctxt, VCPU_REGS_RBX) = ebx;\n\t*reg_write(ctxt, VCPU_REGS_RCX) = ecx;\n\t*reg_write(ctxt, VCPU_REGS_RDX) = edx;\n\treturn X86EMUL_CONTINUE;\n}"
  },
  {
    "function_name": "em_sti",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "3789-3797",
    "snippet": "static int em_sti(struct x86_emulate_ctxt *ctxt)\n{\n\tif (emulator_bad_iopl(ctxt))\n\t\treturn emulate_gp(ctxt, 0);\n\n\tctxt->interruptibility = KVM_X86_SHADOW_INT_STI;\n\tctxt->eflags |= X86_EFLAGS_IF;\n\treturn X86EMUL_CONTINUE;\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "emulate_gp",
          "args": [
            "ctxt",
            "0"
          ],
          "line": 3792
        },
        "resolved": true,
        "details": {
          "function_name": "emulate_gp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "580-583",
          "snippet": "static int emulate_gp(struct x86_emulate_ctxt *ctxt, int err)\n{\n\treturn emulate_exception(ctxt, GP_VECTOR, err, true);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int emulate_gp(struct x86_emulate_ctxt *ctxt, int err)\n{\n\treturn emulate_exception(ctxt, GP_VECTOR, err, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "emulator_bad_iopl",
          "args": [
            "ctxt"
          ],
          "line": 3791
        },
        "resolved": true,
        "details": {
          "function_name": "emulator_bad_iopl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "2804-2813",
          "snippet": "static bool emulator_bad_iopl(struct x86_emulate_ctxt *ctxt)\n{\n\tint iopl;\n\tif (ctxt->mode == X86EMUL_MODE_REAL)\n\t\treturn false;\n\tif (ctxt->mode == X86EMUL_MODE_VM86)\n\t\treturn true;\n\tiopl = (ctxt->eflags & X86_EFLAGS_IOPL) >> X86_EFLAGS_IOPL_BIT;\n\treturn ctxt->ops->cpl(ctxt) > iopl;\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic bool emulator_bad_iopl(struct x86_emulate_ctxt *ctxt)\n{\n\tint iopl;\n\tif (ctxt->mode == X86EMUL_MODE_REAL)\n\t\treturn false;\n\tif (ctxt->mode == X86EMUL_MODE_VM86)\n\t\treturn true;\n\tiopl = (ctxt->eflags & X86_EFLAGS_IOPL) >> X86_EFLAGS_IOPL_BIT;\n\treturn ctxt->ops->cpl(ctxt) > iopl;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int em_sti(struct x86_emulate_ctxt *ctxt)\n{\n\tif (emulator_bad_iopl(ctxt))\n\t\treturn emulate_gp(ctxt, 0);\n\n\tctxt->interruptibility = KVM_X86_SHADOW_INT_STI;\n\tctxt->eflags |= X86_EFLAGS_IF;\n\treturn X86EMUL_CONTINUE;\n}"
  },
  {
    "function_name": "em_cli",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "3780-3787",
    "snippet": "static int em_cli(struct x86_emulate_ctxt *ctxt)\n{\n\tif (emulator_bad_iopl(ctxt))\n\t\treturn emulate_gp(ctxt, 0);\n\n\tctxt->eflags &= ~X86_EFLAGS_IF;\n\treturn X86EMUL_CONTINUE;\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "emulate_gp",
          "args": [
            "ctxt",
            "0"
          ],
          "line": 3783
        },
        "resolved": true,
        "details": {
          "function_name": "emulate_gp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "580-583",
          "snippet": "static int emulate_gp(struct x86_emulate_ctxt *ctxt, int err)\n{\n\treturn emulate_exception(ctxt, GP_VECTOR, err, true);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int emulate_gp(struct x86_emulate_ctxt *ctxt, int err)\n{\n\treturn emulate_exception(ctxt, GP_VECTOR, err, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "emulator_bad_iopl",
          "args": [
            "ctxt"
          ],
          "line": 3782
        },
        "resolved": true,
        "details": {
          "function_name": "emulator_bad_iopl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "2804-2813",
          "snippet": "static bool emulator_bad_iopl(struct x86_emulate_ctxt *ctxt)\n{\n\tint iopl;\n\tif (ctxt->mode == X86EMUL_MODE_REAL)\n\t\treturn false;\n\tif (ctxt->mode == X86EMUL_MODE_VM86)\n\t\treturn true;\n\tiopl = (ctxt->eflags & X86_EFLAGS_IOPL) >> X86_EFLAGS_IOPL_BIT;\n\treturn ctxt->ops->cpl(ctxt) > iopl;\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic bool emulator_bad_iopl(struct x86_emulate_ctxt *ctxt)\n{\n\tint iopl;\n\tif (ctxt->mode == X86EMUL_MODE_REAL)\n\t\treturn false;\n\tif (ctxt->mode == X86EMUL_MODE_VM86)\n\t\treturn true;\n\tiopl = (ctxt->eflags & X86_EFLAGS_IOPL) >> X86_EFLAGS_IOPL_BIT;\n\treturn ctxt->ops->cpl(ctxt) > iopl;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int em_cli(struct x86_emulate_ctxt *ctxt)\n{\n\tif (emulator_bad_iopl(ctxt))\n\t\treturn emulate_gp(ctxt, 0);\n\n\tctxt->eflags &= ~X86_EFLAGS_IF;\n\treturn X86EMUL_CONTINUE;\n}"
  },
  {
    "function_name": "em_out",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "3771-3778",
    "snippet": "static int em_out(struct x86_emulate_ctxt *ctxt)\n{\n\tctxt->ops->pio_out_emulated(ctxt, ctxt->src.bytes, ctxt->dst.val,\n\t\t\t\t    &ctxt->src.val, 1);\n\t/* Disable writeback. */\n\tctxt->dst.type = OP_NONE;\n\treturn X86EMUL_CONTINUE;\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ctxt->ops->pio_out_emulated",
          "args": [
            "ctxt",
            "ctxt->src.bytes",
            "ctxt->dst.val",
            "&ctxt->src.val",
            "1"
          ],
          "line": 3773
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int em_out(struct x86_emulate_ctxt *ctxt)\n{\n\tctxt->ops->pio_out_emulated(ctxt, ctxt->src.bytes, ctxt->dst.val,\n\t\t\t\t    &ctxt->src.val, 1);\n\t/* Disable writeback. */\n\tctxt->dst.type = OP_NONE;\n\treturn X86EMUL_CONTINUE;\n}"
  },
  {
    "function_name": "em_in",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "3762-3769",
    "snippet": "static int em_in(struct x86_emulate_ctxt *ctxt)\n{\n\tif (!pio_in_emulated(ctxt, ctxt->dst.bytes, ctxt->src.val,\n\t\t\t     &ctxt->dst.val))\n\t\treturn X86EMUL_IO_NEEDED;\n\n\treturn X86EMUL_CONTINUE;\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pio_in_emulated",
          "args": [
            "ctxt",
            "ctxt->dst.bytes",
            "ctxt->src.val",
            "&ctxt->dst.val"
          ],
          "line": 3764
        },
        "resolved": true,
        "details": {
          "function_name": "pio_in_emulated",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "1418-1451",
          "snippet": "static int pio_in_emulated(struct x86_emulate_ctxt *ctxt,\n\t\t\t   unsigned int size, unsigned short port,\n\t\t\t   void *dest)\n{\n\tstruct read_cache *rc = &ctxt->io_read;\n\n\tif (rc->pos == rc->end) { /* refill pio read ahead */\n\t\tunsigned int in_page, n;\n\t\tunsigned int count = ctxt->rep_prefix ?\n\t\t\taddress_mask(ctxt, reg_read(ctxt, VCPU_REGS_RCX)) : 1;\n\t\tin_page = (ctxt->eflags & X86_EFLAGS_DF) ?\n\t\t\toffset_in_page(reg_read(ctxt, VCPU_REGS_RDI)) :\n\t\t\tPAGE_SIZE - offset_in_page(reg_read(ctxt, VCPU_REGS_RDI));\n\t\tn = min3(in_page, (unsigned int)sizeof(rc->data) / size, count);\n\t\tif (n == 0)\n\t\t\tn = 1;\n\t\trc->pos = rc->end = 0;\n\t\tif (!ctxt->ops->pio_in_emulated(ctxt, size, port, rc->data, n))\n\t\t\treturn 0;\n\t\trc->end = n * size;\n\t}\n\n\tif (ctxt->rep_prefix && (ctxt->d & String) &&\n\t    !(ctxt->eflags & X86_EFLAGS_DF)) {\n\t\tctxt->dst.data = rc->data + rc->pos;\n\t\tctxt->dst.type = OP_MEM_STR;\n\t\tctxt->dst.count = (rc->end - rc->pos) / size;\n\t\trc->pos = rc->end;\n\t} else {\n\t\tmemcpy(dest, rc->data + rc->pos, size);\n\t\trc->pos += size;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define String      (1<<13)     /* String instruction (rep capable) */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\n#define String      (1<<13)     /* String instruction (rep capable) */\n\nstatic int pio_in_emulated(struct x86_emulate_ctxt *ctxt,\n\t\t\t   unsigned int size, unsigned short port,\n\t\t\t   void *dest)\n{\n\tstruct read_cache *rc = &ctxt->io_read;\n\n\tif (rc->pos == rc->end) { /* refill pio read ahead */\n\t\tunsigned int in_page, n;\n\t\tunsigned int count = ctxt->rep_prefix ?\n\t\t\taddress_mask(ctxt, reg_read(ctxt, VCPU_REGS_RCX)) : 1;\n\t\tin_page = (ctxt->eflags & X86_EFLAGS_DF) ?\n\t\t\toffset_in_page(reg_read(ctxt, VCPU_REGS_RDI)) :\n\t\t\tPAGE_SIZE - offset_in_page(reg_read(ctxt, VCPU_REGS_RDI));\n\t\tn = min3(in_page, (unsigned int)sizeof(rc->data) / size, count);\n\t\tif (n == 0)\n\t\t\tn = 1;\n\t\trc->pos = rc->end = 0;\n\t\tif (!ctxt->ops->pio_in_emulated(ctxt, size, port, rc->data, n))\n\t\t\treturn 0;\n\t\trc->end = n * size;\n\t}\n\n\tif (ctxt->rep_prefix && (ctxt->d & String) &&\n\t    !(ctxt->eflags & X86_EFLAGS_DF)) {\n\t\tctxt->dst.data = rc->data + rc->pos;\n\t\tctxt->dst.type = OP_MEM_STR;\n\t\tctxt->dst.count = (rc->end - rc->pos) / size;\n\t\trc->pos = rc->end;\n\t} else {\n\t\tmemcpy(dest, rc->data + rc->pos, size);\n\t\trc->pos += size;\n\t}\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int em_in(struct x86_emulate_ctxt *ctxt)\n{\n\tif (!pio_in_emulated(ctxt, ctxt->dst.bytes, ctxt->src.val,\n\t\t\t     &ctxt->dst.val))\n\t\treturn X86EMUL_IO_NEEDED;\n\n\treturn X86EMUL_CONTINUE;\n}"
  },
  {
    "function_name": "em_jcxz",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "3752-3760",
    "snippet": "static int em_jcxz(struct x86_emulate_ctxt *ctxt)\n{\n\tint rc = X86EMUL_CONTINUE;\n\n\tif (address_mask(ctxt, reg_read(ctxt, VCPU_REGS_RCX)) == 0)\n\t\trc = jmp_rel(ctxt, ctxt->src.val);\n\n\treturn rc;\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "jmp_rel",
          "args": [
            "ctxt",
            "ctxt->src.val"
          ],
          "line": 3757
        },
        "resolved": true,
        "details": {
          "function_name": "jmp_rel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "776-779",
          "snippet": "static inline int jmp_rel(struct x86_emulate_ctxt *ctxt, int rel)\n{\n\treturn assign_eip_near(ctxt, ctxt->_eip + rel);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline int jmp_rel(struct x86_emulate_ctxt *ctxt, int rel)\n{\n\treturn assign_eip_near(ctxt, ctxt->_eip + rel);\n}"
        }
      },
      {
        "call_info": {
          "callee": "address_mask",
          "args": [
            "ctxt",
            "reg_read(ctxt, VCPU_REGS_RCX)"
          ],
          "line": 3756
        },
        "resolved": true,
        "details": {
          "function_name": "address_mask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "517-524",
          "snippet": "static inline unsigned long\naddress_mask(struct x86_emulate_ctxt *ctxt, unsigned long reg)\n{\n\tif (ctxt->ad_bytes == sizeof(unsigned long))\n\t\treturn reg;\n\telse\n\t\treturn reg & ad_mask(ctxt);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline unsigned long\naddress_mask(struct x86_emulate_ctxt *ctxt, unsigned long reg)\n{\n\tif (ctxt->ad_bytes == sizeof(unsigned long))\n\t\treturn reg;\n\telse\n\t\treturn reg & ad_mask(ctxt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reg_read",
          "args": [
            "ctxt",
            "VCPU_REGS_RCX"
          ],
          "line": 3756
        },
        "resolved": true,
        "details": {
          "function_name": "reg_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "261-268",
          "snippet": "static ulong reg_read(struct x86_emulate_ctxt *ctxt, unsigned nr)\n{\n\tif (!(ctxt->regs_valid & (1 << nr))) {\n\t\tctxt->regs_valid |= 1 << nr;\n\t\tctxt->_regs[nr] = ctxt->ops->read_gpr(ctxt, nr);\n\t}\n\treturn ctxt->_regs[nr];\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic ulong reg_read(struct x86_emulate_ctxt *ctxt, unsigned nr)\n{\n\tif (!(ctxt->regs_valid & (1 << nr))) {\n\t\tctxt->regs_valid |= 1 << nr;\n\t\tctxt->_regs[nr] = ctxt->ops->read_gpr(ctxt, nr);\n\t}\n\treturn ctxt->_regs[nr];\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int em_jcxz(struct x86_emulate_ctxt *ctxt)\n{\n\tint rc = X86EMUL_CONTINUE;\n\n\tif (address_mask(ctxt, reg_read(ctxt, VCPU_REGS_RCX)) == 0)\n\t\trc = jmp_rel(ctxt, ctxt->src.val);\n\n\treturn rc;\n}"
  },
  {
    "function_name": "em_loop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "3740-3750",
    "snippet": "static int em_loop(struct x86_emulate_ctxt *ctxt)\n{\n\tint rc = X86EMUL_CONTINUE;\n\n\tregister_address_increment(ctxt, VCPU_REGS_RCX, -1);\n\tif ((address_mask(ctxt, reg_read(ctxt, VCPU_REGS_RCX)) != 0) &&\n\t    (ctxt->b == 0xe2 || test_cc(ctxt->b ^ 0x5, ctxt->eflags)))\n\t\trc = jmp_rel(ctxt, ctxt->src.val);\n\n\treturn rc;\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "jmp_rel",
          "args": [
            "ctxt",
            "ctxt->src.val"
          ],
          "line": 3747
        },
        "resolved": true,
        "details": {
          "function_name": "jmp_rel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "776-779",
          "snippet": "static inline int jmp_rel(struct x86_emulate_ctxt *ctxt, int rel)\n{\n\treturn assign_eip_near(ctxt, ctxt->_eip + rel);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline int jmp_rel(struct x86_emulate_ctxt *ctxt, int rel)\n{\n\treturn assign_eip_near(ctxt, ctxt->_eip + rel);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_cc",
          "args": [
            "ctxt->b ^ 0x5",
            "ctxt->eflags"
          ],
          "line": 3746
        },
        "resolved": true,
        "details": {
          "function_name": "test_cc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "972-981",
          "snippet": "static __always_inline u8 test_cc(unsigned int condition, unsigned long flags)\n{\n\tu8 rc;\n\tvoid (*fop)(void) = (void *)em_setcc + 4 * (condition & 0xf);\n\n\tflags = (flags & EFLAGS_MASK) | X86_EFLAGS_IF;\n\tasm(\"push %[flags]; popf; call *%[fastop]\"\n\t    : \"=a\"(rc) : [fastop]\"r\"(fop), [flags]\"r\"(flags));\n\treturn rc;\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define EFLAGS_MASK (X86_EFLAGS_OF|X86_EFLAGS_SF|X86_EFLAGS_ZF|X86_EFLAGS_AF|\\\n\t\t     X86_EFLAGS_PF|X86_EFLAGS_CF)"
          ],
          "globals_used": [
            "static int fastop(struct x86_emulate_ctxt *ctxt, void (*fop)(struct fastop *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\n#define EFLAGS_MASK (X86_EFLAGS_OF|X86_EFLAGS_SF|X86_EFLAGS_ZF|X86_EFLAGS_AF|\\\n\t\t     X86_EFLAGS_PF|X86_EFLAGS_CF)\n\nstatic int fastop(struct x86_emulate_ctxt *ctxt, void (*fop)(struct fastop *));\n\nstatic __always_inline u8 test_cc(unsigned int condition, unsigned long flags)\n{\n\tu8 rc;\n\tvoid (*fop)(void) = (void *)em_setcc + 4 * (condition & 0xf);\n\n\tflags = (flags & EFLAGS_MASK) | X86_EFLAGS_IF;\n\tasm(\"push %[flags]; popf; call *%[fastop]\"\n\t    : \"=a\"(rc) : [fastop]\"r\"(fop), [flags]\"r\"(flags));\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "address_mask",
          "args": [
            "ctxt",
            "reg_read(ctxt, VCPU_REGS_RCX)"
          ],
          "line": 3745
        },
        "resolved": true,
        "details": {
          "function_name": "address_mask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "517-524",
          "snippet": "static inline unsigned long\naddress_mask(struct x86_emulate_ctxt *ctxt, unsigned long reg)\n{\n\tif (ctxt->ad_bytes == sizeof(unsigned long))\n\t\treturn reg;\n\telse\n\t\treturn reg & ad_mask(ctxt);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline unsigned long\naddress_mask(struct x86_emulate_ctxt *ctxt, unsigned long reg)\n{\n\tif (ctxt->ad_bytes == sizeof(unsigned long))\n\t\treturn reg;\n\telse\n\t\treturn reg & ad_mask(ctxt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reg_read",
          "args": [
            "ctxt",
            "VCPU_REGS_RCX"
          ],
          "line": 3745
        },
        "resolved": true,
        "details": {
          "function_name": "reg_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "261-268",
          "snippet": "static ulong reg_read(struct x86_emulate_ctxt *ctxt, unsigned nr)\n{\n\tif (!(ctxt->regs_valid & (1 << nr))) {\n\t\tctxt->regs_valid |= 1 << nr;\n\t\tctxt->_regs[nr] = ctxt->ops->read_gpr(ctxt, nr);\n\t}\n\treturn ctxt->_regs[nr];\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic ulong reg_read(struct x86_emulate_ctxt *ctxt, unsigned nr)\n{\n\tif (!(ctxt->regs_valid & (1 << nr))) {\n\t\tctxt->regs_valid |= 1 << nr;\n\t\tctxt->_regs[nr] = ctxt->ops->read_gpr(ctxt, nr);\n\t}\n\treturn ctxt->_regs[nr];\n}"
        }
      },
      {
        "call_info": {
          "callee": "register_address_increment",
          "args": [
            "ctxt",
            "VCPU_REGS_RCX",
            "-1"
          ],
          "line": 3744
        },
        "resolved": true,
        "details": {
          "function_name": "register_address_increment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "537-543",
          "snippet": "static inline void\nregister_address_increment(struct x86_emulate_ctxt *ctxt, int reg, int inc)\n{\n\tulong *preg = reg_rmw(ctxt, reg);\n\n\tassign_register(preg, *preg + inc, ctxt->ad_bytes);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline void\nregister_address_increment(struct x86_emulate_ctxt *ctxt, int reg, int inc)\n{\n\tulong *preg = reg_rmw(ctxt, reg);\n\n\tassign_register(preg, *preg + inc, ctxt->ad_bytes);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int em_loop(struct x86_emulate_ctxt *ctxt)\n{\n\tint rc = X86EMUL_CONTINUE;\n\n\tregister_address_increment(ctxt, VCPU_REGS_RCX, -1);\n\tif ((address_mask(ctxt, reg_read(ctxt, VCPU_REGS_RCX)) != 0) &&\n\t    (ctxt->b == 0xe2 || test_cc(ctxt->b ^ 0x5, ctxt->eflags)))\n\t\trc = jmp_rel(ctxt, ctxt->src.val);\n\n\treturn rc;\n}"
  },
  {
    "function_name": "em_lmsw",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "3732-3738",
    "snippet": "static int em_lmsw(struct x86_emulate_ctxt *ctxt)\n{\n\tctxt->ops->set_cr(ctxt, 0, (ctxt->ops->get_cr(ctxt, 0) & ~0x0eul)\n\t\t\t  | (ctxt->src.val & 0x0f));\n\tctxt->dst.type = OP_NONE;\n\treturn X86EMUL_CONTINUE;\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ctxt->ops->set_cr",
          "args": [
            "ctxt",
            "0",
            "(ctxt->ops->get_cr(ctxt, 0) & ~0x0eul)\n\t\t\t  | (ctxt->src.val & 0x0f)"
          ],
          "line": 3734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ctxt->ops->get_cr",
          "args": [
            "ctxt",
            "0"
          ],
          "line": 3734
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int em_lmsw(struct x86_emulate_ctxt *ctxt)\n{\n\tctxt->ops->set_cr(ctxt, 0, (ctxt->ops->get_cr(ctxt, 0) & ~0x0eul)\n\t\t\t  | (ctxt->src.val & 0x0f));\n\tctxt->dst.type = OP_NONE;\n\treturn X86EMUL_CONTINUE;\n}"
  },
  {
    "function_name": "em_smsw",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "3724-3730",
    "snippet": "static int em_smsw(struct x86_emulate_ctxt *ctxt)\n{\n\tif (ctxt->dst.type == OP_MEM)\n\t\tctxt->dst.bytes = 2;\n\tctxt->dst.val = ctxt->ops->get_cr(ctxt, 0);\n\treturn X86EMUL_CONTINUE;\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ctxt->ops->get_cr",
          "args": [
            "ctxt",
            "0"
          ],
          "line": 3728
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int em_smsw(struct x86_emulate_ctxt *ctxt)\n{\n\tif (ctxt->dst.type == OP_MEM)\n\t\tctxt->dst.bytes = 2;\n\tctxt->dst.val = ctxt->ops->get_cr(ctxt, 0);\n\treturn X86EMUL_CONTINUE;\n}"
  },
  {
    "function_name": "em_lidt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "3719-3722",
    "snippet": "static int em_lidt(struct x86_emulate_ctxt *ctxt)\n{\n\treturn em_lgdt_lidt(ctxt, false);\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "em_lgdt_lidt",
          "args": [
            "ctxt",
            "false"
          ],
          "line": 3721
        },
        "resolved": true,
        "details": {
          "function_name": "em_lgdt_lidt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "3690-3712",
          "snippet": "static int em_lgdt_lidt(struct x86_emulate_ctxt *ctxt, bool lgdt)\n{\n\tstruct desc_ptr desc_ptr;\n\tint rc;\n\n\tif (ctxt->mode == X86EMUL_MODE_PROT64)\n\t\tctxt->op_bytes = 8;\n\trc = read_descriptor(ctxt, ctxt->src.addr.mem,\n\t\t\t     &desc_ptr.size, &desc_ptr.address,\n\t\t\t     ctxt->op_bytes);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\tif (ctxt->mode == X86EMUL_MODE_PROT64 &&\n\t    is_noncanonical_address(desc_ptr.address))\n\t\treturn emulate_gp(ctxt, 0);\n\tif (lgdt)\n\t\tctxt->ops->set_gdt(ctxt, &desc_ptr);\n\telse\n\t\tctxt->ops->set_idt(ctxt, &desc_ptr);\n\t/* Disable writeback. */\n\tctxt->dst.type = OP_NONE;\n\treturn X86EMUL_CONTINUE;\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int em_lgdt_lidt(struct x86_emulate_ctxt *ctxt, bool lgdt)\n{\n\tstruct desc_ptr desc_ptr;\n\tint rc;\n\n\tif (ctxt->mode == X86EMUL_MODE_PROT64)\n\t\tctxt->op_bytes = 8;\n\trc = read_descriptor(ctxt, ctxt->src.addr.mem,\n\t\t\t     &desc_ptr.size, &desc_ptr.address,\n\t\t\t     ctxt->op_bytes);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\tif (ctxt->mode == X86EMUL_MODE_PROT64 &&\n\t    is_noncanonical_address(desc_ptr.address))\n\t\treturn emulate_gp(ctxt, 0);\n\tif (lgdt)\n\t\tctxt->ops->set_gdt(ctxt, &desc_ptr);\n\telse\n\t\tctxt->ops->set_idt(ctxt, &desc_ptr);\n\t/* Disable writeback. */\n\tctxt->dst.type = OP_NONE;\n\treturn X86EMUL_CONTINUE;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int em_lidt(struct x86_emulate_ctxt *ctxt)\n{\n\treturn em_lgdt_lidt(ctxt, false);\n}"
  },
  {
    "function_name": "em_lgdt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "3714-3717",
    "snippet": "static int em_lgdt(struct x86_emulate_ctxt *ctxt)\n{\n\treturn em_lgdt_lidt(ctxt, true);\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "em_lgdt_lidt",
          "args": [
            "ctxt",
            "true"
          ],
          "line": 3716
        },
        "resolved": true,
        "details": {
          "function_name": "em_lgdt_lidt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "3690-3712",
          "snippet": "static int em_lgdt_lidt(struct x86_emulate_ctxt *ctxt, bool lgdt)\n{\n\tstruct desc_ptr desc_ptr;\n\tint rc;\n\n\tif (ctxt->mode == X86EMUL_MODE_PROT64)\n\t\tctxt->op_bytes = 8;\n\trc = read_descriptor(ctxt, ctxt->src.addr.mem,\n\t\t\t     &desc_ptr.size, &desc_ptr.address,\n\t\t\t     ctxt->op_bytes);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\tif (ctxt->mode == X86EMUL_MODE_PROT64 &&\n\t    is_noncanonical_address(desc_ptr.address))\n\t\treturn emulate_gp(ctxt, 0);\n\tif (lgdt)\n\t\tctxt->ops->set_gdt(ctxt, &desc_ptr);\n\telse\n\t\tctxt->ops->set_idt(ctxt, &desc_ptr);\n\t/* Disable writeback. */\n\tctxt->dst.type = OP_NONE;\n\treturn X86EMUL_CONTINUE;\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int em_lgdt_lidt(struct x86_emulate_ctxt *ctxt, bool lgdt)\n{\n\tstruct desc_ptr desc_ptr;\n\tint rc;\n\n\tif (ctxt->mode == X86EMUL_MODE_PROT64)\n\t\tctxt->op_bytes = 8;\n\trc = read_descriptor(ctxt, ctxt->src.addr.mem,\n\t\t\t     &desc_ptr.size, &desc_ptr.address,\n\t\t\t     ctxt->op_bytes);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\tif (ctxt->mode == X86EMUL_MODE_PROT64 &&\n\t    is_noncanonical_address(desc_ptr.address))\n\t\treturn emulate_gp(ctxt, 0);\n\tif (lgdt)\n\t\tctxt->ops->set_gdt(ctxt, &desc_ptr);\n\telse\n\t\tctxt->ops->set_idt(ctxt, &desc_ptr);\n\t/* Disable writeback. */\n\tctxt->dst.type = OP_NONE;\n\treturn X86EMUL_CONTINUE;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int em_lgdt(struct x86_emulate_ctxt *ctxt)\n{\n\treturn em_lgdt_lidt(ctxt, true);\n}"
  },
  {
    "function_name": "em_lgdt_lidt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "3690-3712",
    "snippet": "static int em_lgdt_lidt(struct x86_emulate_ctxt *ctxt, bool lgdt)\n{\n\tstruct desc_ptr desc_ptr;\n\tint rc;\n\n\tif (ctxt->mode == X86EMUL_MODE_PROT64)\n\t\tctxt->op_bytes = 8;\n\trc = read_descriptor(ctxt, ctxt->src.addr.mem,\n\t\t\t     &desc_ptr.size, &desc_ptr.address,\n\t\t\t     ctxt->op_bytes);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\tif (ctxt->mode == X86EMUL_MODE_PROT64 &&\n\t    is_noncanonical_address(desc_ptr.address))\n\t\treturn emulate_gp(ctxt, 0);\n\tif (lgdt)\n\t\tctxt->ops->set_gdt(ctxt, &desc_ptr);\n\telse\n\t\tctxt->ops->set_idt(ctxt, &desc_ptr);\n\t/* Disable writeback. */\n\tctxt->dst.type = OP_NONE;\n\treturn X86EMUL_CONTINUE;\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ctxt->ops->set_idt",
          "args": [
            "ctxt",
            "&desc_ptr"
          ],
          "line": 3708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ctxt->ops->set_gdt",
          "args": [
            "ctxt",
            "&desc_ptr"
          ],
          "line": 3706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "emulate_gp",
          "args": [
            "ctxt",
            "0"
          ],
          "line": 3704
        },
        "resolved": true,
        "details": {
          "function_name": "emulate_gp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "580-583",
          "snippet": "static int emulate_gp(struct x86_emulate_ctxt *ctxt, int err)\n{\n\treturn emulate_exception(ctxt, GP_VECTOR, err, true);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int emulate_gp(struct x86_emulate_ctxt *ctxt, int err)\n{\n\treturn emulate_exception(ctxt, GP_VECTOR, err, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_noncanonical_address",
          "args": [
            "desc_ptr.address"
          ],
          "line": 3703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_descriptor",
          "args": [
            "ctxt",
            "ctxt->src.addr.mem",
            "&desc_ptr.size",
            "&desc_ptr.address",
            "ctxt->op_bytes"
          ],
          "line": 3697
        },
        "resolved": true,
        "details": {
          "function_name": "read_descriptor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "895-910",
          "snippet": "static int read_descriptor(struct x86_emulate_ctxt *ctxt,\n\t\t\t   struct segmented_address addr,\n\t\t\t   u16 *size, unsigned long *address, int op_bytes)\n{\n\tint rc;\n\n\tif (op_bytes == 2)\n\t\top_bytes = 3;\n\t*address = 0;\n\trc = segmented_read_std(ctxt, addr, size, 2);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\taddr.ea += 2;\n\trc = segmented_read_std(ctxt, addr, address, op_bytes);\n\treturn rc;\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int read_descriptor(struct x86_emulate_ctxt *ctxt,\n\t\t\t   struct segmented_address addr,\n\t\t\t   u16 *size, unsigned long *address, int op_bytes)\n{\n\tint rc;\n\n\tif (op_bytes == 2)\n\t\top_bytes = 3;\n\t*address = 0;\n\trc = segmented_read_std(ctxt, addr, size, 2);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\taddr.ea += 2;\n\trc = segmented_read_std(ctxt, addr, address, op_bytes);\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int em_lgdt_lidt(struct x86_emulate_ctxt *ctxt, bool lgdt)\n{\n\tstruct desc_ptr desc_ptr;\n\tint rc;\n\n\tif (ctxt->mode == X86EMUL_MODE_PROT64)\n\t\tctxt->op_bytes = 8;\n\trc = read_descriptor(ctxt, ctxt->src.addr.mem,\n\t\t\t     &desc_ptr.size, &desc_ptr.address,\n\t\t\t     ctxt->op_bytes);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\tif (ctxt->mode == X86EMUL_MODE_PROT64 &&\n\t    is_noncanonical_address(desc_ptr.address))\n\t\treturn emulate_gp(ctxt, 0);\n\tif (lgdt)\n\t\tctxt->ops->set_gdt(ctxt, &desc_ptr);\n\telse\n\t\tctxt->ops->set_idt(ctxt, &desc_ptr);\n\t/* Disable writeback. */\n\tctxt->dst.type = OP_NONE;\n\treturn X86EMUL_CONTINUE;\n}"
  },
  {
    "function_name": "em_sidt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "3685-3688",
    "snippet": "static int em_sidt(struct x86_emulate_ctxt *ctxt)\n{\n\treturn emulate_store_desc_ptr(ctxt, ctxt->ops->get_idt);\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "emulate_store_desc_ptr",
          "args": [
            "ctxt",
            "ctxt->ops->get_idt"
          ],
          "line": 3687
        },
        "resolved": true,
        "details": {
          "function_name": "emulate_store_desc_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "3661-3678",
          "snippet": "static int emulate_store_desc_ptr(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t  void (*get)(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t\t      struct desc_ptr *ptr))\n{\n\tstruct desc_ptr desc_ptr;\n\n\tif (ctxt->mode == X86EMUL_MODE_PROT64)\n\t\tctxt->op_bytes = 8;\n\tget(ctxt, &desc_ptr);\n\tif (ctxt->op_bytes == 2) {\n\t\tctxt->op_bytes = 4;\n\t\tdesc_ptr.address &= 0x00ffffff;\n\t}\n\t/* Disable writeback. */\n\tctxt->dst.type = OP_NONE;\n\treturn segmented_write(ctxt, ctxt->dst.addr.mem,\n\t\t\t       &desc_ptr, 2 + ctxt->op_bytes);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int emulate_store_desc_ptr(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t  void (*get)(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t\t      struct desc_ptr *ptr))\n{\n\tstruct desc_ptr desc_ptr;\n\n\tif (ctxt->mode == X86EMUL_MODE_PROT64)\n\t\tctxt->op_bytes = 8;\n\tget(ctxt, &desc_ptr);\n\tif (ctxt->op_bytes == 2) {\n\t\tctxt->op_bytes = 4;\n\t\tdesc_ptr.address &= 0x00ffffff;\n\t}\n\t/* Disable writeback. */\n\tctxt->dst.type = OP_NONE;\n\treturn segmented_write(ctxt, ctxt->dst.addr.mem,\n\t\t\t       &desc_ptr, 2 + ctxt->op_bytes);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int em_sidt(struct x86_emulate_ctxt *ctxt)\n{\n\treturn emulate_store_desc_ptr(ctxt, ctxt->ops->get_idt);\n}"
  },
  {
    "function_name": "em_sgdt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "3680-3683",
    "snippet": "static int em_sgdt(struct x86_emulate_ctxt *ctxt)\n{\n\treturn emulate_store_desc_ptr(ctxt, ctxt->ops->get_gdt);\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "emulate_store_desc_ptr",
          "args": [
            "ctxt",
            "ctxt->ops->get_gdt"
          ],
          "line": 3682
        },
        "resolved": true,
        "details": {
          "function_name": "emulate_store_desc_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "3661-3678",
          "snippet": "static int emulate_store_desc_ptr(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t  void (*get)(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t\t      struct desc_ptr *ptr))\n{\n\tstruct desc_ptr desc_ptr;\n\n\tif (ctxt->mode == X86EMUL_MODE_PROT64)\n\t\tctxt->op_bytes = 8;\n\tget(ctxt, &desc_ptr);\n\tif (ctxt->op_bytes == 2) {\n\t\tctxt->op_bytes = 4;\n\t\tdesc_ptr.address &= 0x00ffffff;\n\t}\n\t/* Disable writeback. */\n\tctxt->dst.type = OP_NONE;\n\treturn segmented_write(ctxt, ctxt->dst.addr.mem,\n\t\t\t       &desc_ptr, 2 + ctxt->op_bytes);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int emulate_store_desc_ptr(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t  void (*get)(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t\t      struct desc_ptr *ptr))\n{\n\tstruct desc_ptr desc_ptr;\n\n\tif (ctxt->mode == X86EMUL_MODE_PROT64)\n\t\tctxt->op_bytes = 8;\n\tget(ctxt, &desc_ptr);\n\tif (ctxt->op_bytes == 2) {\n\t\tctxt->op_bytes = 4;\n\t\tdesc_ptr.address &= 0x00ffffff;\n\t}\n\t/* Disable writeback. */\n\tctxt->dst.type = OP_NONE;\n\treturn segmented_write(ctxt, ctxt->dst.addr.mem,\n\t\t\t       &desc_ptr, 2 + ctxt->op_bytes);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int em_sgdt(struct x86_emulate_ctxt *ctxt)\n{\n\treturn emulate_store_desc_ptr(ctxt, ctxt->ops->get_gdt);\n}"
  },
  {
    "function_name": "emulate_store_desc_ptr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "3661-3678",
    "snippet": "static int emulate_store_desc_ptr(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t  void (*get)(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t\t      struct desc_ptr *ptr))\n{\n\tstruct desc_ptr desc_ptr;\n\n\tif (ctxt->mode == X86EMUL_MODE_PROT64)\n\t\tctxt->op_bytes = 8;\n\tget(ctxt, &desc_ptr);\n\tif (ctxt->op_bytes == 2) {\n\t\tctxt->op_bytes = 4;\n\t\tdesc_ptr.address &= 0x00ffffff;\n\t}\n\t/* Disable writeback. */\n\tctxt->dst.type = OP_NONE;\n\treturn segmented_write(ctxt, ctxt->dst.addr.mem,\n\t\t\t       &desc_ptr, 2 + ctxt->op_bytes);\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "segmented_write",
          "args": [
            "ctxt",
            "ctxt->dst.addr.mem",
            "&desc_ptr",
            "2 + ctxt->op_bytes"
          ],
          "line": 3676
        },
        "resolved": true,
        "details": {
          "function_name": "segmented_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "1388-1401",
          "snippet": "static int segmented_write(struct x86_emulate_ctxt *ctxt,\n\t\t\t   struct segmented_address addr,\n\t\t\t   const void *data,\n\t\t\t   unsigned size)\n{\n\tint rc;\n\tulong linear;\n\n\trc = linearize(ctxt, addr, size, true, &linear);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\treturn ctxt->ops->write_emulated(ctxt, linear, data, size,\n\t\t\t\t\t &ctxt->exception);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int segmented_write(struct x86_emulate_ctxt *ctxt,\n\t\t\t   struct segmented_address addr,\n\t\t\t   const void *data,\n\t\t\t   unsigned size)\n{\n\tint rc;\n\tulong linear;\n\n\trc = linearize(ctxt, addr, size, true, &linear);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\treturn ctxt->ops->write_emulated(ctxt, linear, data, size,\n\t\t\t\t\t &ctxt->exception);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get",
          "args": [
            "ctxt",
            "&desc_ptr"
          ],
          "line": 3669
        },
        "resolved": true,
        "details": {
          "function_name": "get_segment_selector",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "610-617",
          "snippet": "static u16 get_segment_selector(struct x86_emulate_ctxt *ctxt, unsigned seg)\n{\n\tu16 selector;\n\tstruct desc_struct desc;\n\n\tctxt->ops->get_segment(ctxt, &selector, &desc, NULL, seg);\n\treturn selector;\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic u16 get_segment_selector(struct x86_emulate_ctxt *ctxt, unsigned seg)\n{\n\tu16 selector;\n\tstruct desc_struct desc;\n\n\tctxt->ops->get_segment(ctxt, &selector, &desc, NULL, seg);\n\treturn selector;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int emulate_store_desc_ptr(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t  void (*get)(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t\t      struct desc_ptr *ptr))\n{\n\tstruct desc_ptr desc_ptr;\n\n\tif (ctxt->mode == X86EMUL_MODE_PROT64)\n\t\tctxt->op_bytes = 8;\n\tget(ctxt, &desc_ptr);\n\tif (ctxt->op_bytes == 2) {\n\t\tctxt->op_bytes = 4;\n\t\tdesc_ptr.address &= 0x00ffffff;\n\t}\n\t/* Disable writeback. */\n\tctxt->dst.type = OP_NONE;\n\treturn segmented_write(ctxt, ctxt->dst.addr.mem,\n\t\t\t       &desc_ptr, 2 + ctxt->op_bytes);\n}"
  },
  {
    "function_name": "em_hypercall",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "3647-3659",
    "snippet": "static int em_hypercall(struct x86_emulate_ctxt *ctxt)\n{\n\tint rc = ctxt->ops->fix_hypercall(ctxt);\n\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\t/* Let the processor re-execute the fixed hypercall */\n\tctxt->_eip = ctxt->eip;\n\t/* Disable writeback. */\n\tctxt->dst.type = OP_NONE;\n\treturn X86EMUL_CONTINUE;\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ctxt->ops->fix_hypercall",
          "args": [
            "ctxt"
          ],
          "line": 3649
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int em_hypercall(struct x86_emulate_ctxt *ctxt)\n{\n\tint rc = ctxt->ops->fix_hypercall(ctxt);\n\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\t/* Let the processor re-execute the fixed hypercall */\n\tctxt->_eip = ctxt->eip;\n\t/* Disable writeback. */\n\tctxt->dst.type = OP_NONE;\n\treturn X86EMUL_CONTINUE;\n}"
  },
  {
    "function_name": "em_clts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "3637-3645",
    "snippet": "static int em_clts(struct x86_emulate_ctxt *ctxt)\n{\n\tulong cr0;\n\n\tcr0 = ctxt->ops->get_cr(ctxt, 0);\n\tcr0 &= ~X86_CR0_TS;\n\tctxt->ops->set_cr(ctxt, 0, cr0);\n\treturn X86EMUL_CONTINUE;\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ctxt->ops->set_cr",
          "args": [
            "ctxt",
            "0",
            "cr0"
          ],
          "line": 3643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ctxt->ops->get_cr",
          "args": [
            "ctxt",
            "0"
          ],
          "line": 3641
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int em_clts(struct x86_emulate_ctxt *ctxt)\n{\n\tulong cr0;\n\n\tcr0 = ctxt->ops->get_cr(ctxt, 0);\n\tcr0 &= ~X86_CR0_TS;\n\tctxt->ops->set_cr(ctxt, 0, cr0);\n\treturn X86EMUL_CONTINUE;\n}"
  },
  {
    "function_name": "em_invlpg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "3624-3635",
    "snippet": "static int em_invlpg(struct x86_emulate_ctxt *ctxt)\n{\n\tint rc;\n\tulong linear;\n\n\trc = linearize(ctxt, ctxt->src.addr.mem, 1, false, &linear);\n\tif (rc == X86EMUL_CONTINUE)\n\t\tctxt->ops->invlpg(ctxt, linear);\n\t/* Disable writeback. */\n\tctxt->dst.type = OP_NONE;\n\treturn X86EMUL_CONTINUE;\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ctxt->ops->invlpg",
          "args": [
            "ctxt",
            "linear"
          ],
          "line": 3631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "linearize",
          "args": [
            "ctxt",
            "ctxt->src.addr.mem",
            "1",
            "false",
            "&linear"
          ],
          "line": 3629
        },
        "resolved": true,
        "details": {
          "function_name": "linearize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "718-726",
          "snippet": "static int linearize(struct x86_emulate_ctxt *ctxt,\n\t\t     struct segmented_address addr,\n\t\t     unsigned size, bool write,\n\t\t     ulong *linear)\n{\n\tunsigned max_size;\n\treturn __linearize(ctxt, addr, &max_size, size, write, false,\n\t\t\t   ctxt->mode, linear);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int linearize(struct x86_emulate_ctxt *ctxt,\n\t\t     struct segmented_address addr,\n\t\t     unsigned size, bool write,\n\t\t     ulong *linear)\n{\n\tunsigned max_size;\n\treturn __linearize(ctxt, addr, &max_size, size, write, false,\n\t\t\t   ctxt->mode, linear);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int em_invlpg(struct x86_emulate_ctxt *ctxt)\n{\n\tint rc;\n\tulong linear;\n\n\trc = linearize(ctxt, ctxt->src.addr.mem, 1, false, &linear);\n\tif (rc == X86EMUL_CONTINUE)\n\t\tctxt->ops->invlpg(ctxt, linear);\n\t/* Disable writeback. */\n\tctxt->dst.type = OP_NONE;\n\treturn X86EMUL_CONTINUE;\n}"
  },
  {
    "function_name": "em_ltr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "3615-3622",
    "snippet": "static int em_ltr(struct x86_emulate_ctxt *ctxt)\n{\n\tu16 sel = ctxt->src.val;\n\n\t/* Disable writeback. */\n\tctxt->dst.type = OP_NONE;\n\treturn load_segment_descriptor(ctxt, sel, VCPU_SREG_TR);\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "load_segment_descriptor",
          "args": [
            "ctxt",
            "sel",
            "VCPU_SREG_TR"
          ],
          "line": 3621
        },
        "resolved": true,
        "details": {
          "function_name": "load_segment_descriptor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "1710-1716",
          "snippet": "static int load_segment_descriptor(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t   u16 selector, int seg)\n{\n\tu8 cpl = ctxt->ops->cpl(ctxt);\n\treturn __load_segment_descriptor(ctxt, selector, seg, cpl,\n\t\t\t\t\t X86_TRANSFER_NONE, NULL);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int load_segment_descriptor(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t   u16 selector, int seg)\n{\n\tu8 cpl = ctxt->ops->cpl(ctxt);\n\treturn __load_segment_descriptor(ctxt, selector, seg, cpl,\n\t\t\t\t\t X86_TRANSFER_NONE, NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int em_ltr(struct x86_emulate_ctxt *ctxt)\n{\n\tu16 sel = ctxt->src.val;\n\n\t/* Disable writeback. */\n\tctxt->dst.type = OP_NONE;\n\treturn load_segment_descriptor(ctxt, sel, VCPU_SREG_TR);\n}"
  },
  {
    "function_name": "em_lldt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "3606-3613",
    "snippet": "static int em_lldt(struct x86_emulate_ctxt *ctxt)\n{\n\tu16 sel = ctxt->src.val;\n\n\t/* Disable writeback. */\n\tctxt->dst.type = OP_NONE;\n\treturn load_segment_descriptor(ctxt, sel, VCPU_SREG_LDTR);\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "load_segment_descriptor",
          "args": [
            "ctxt",
            "sel",
            "VCPU_SREG_LDTR"
          ],
          "line": 3612
        },
        "resolved": true,
        "details": {
          "function_name": "load_segment_descriptor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "1710-1716",
          "snippet": "static int load_segment_descriptor(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t   u16 selector, int seg)\n{\n\tu8 cpl = ctxt->ops->cpl(ctxt);\n\treturn __load_segment_descriptor(ctxt, selector, seg, cpl,\n\t\t\t\t\t X86_TRANSFER_NONE, NULL);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int load_segment_descriptor(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t   u16 selector, int seg)\n{\n\tu8 cpl = ctxt->ops->cpl(ctxt);\n\treturn __load_segment_descriptor(ctxt, selector, seg, cpl,\n\t\t\t\t\t X86_TRANSFER_NONE, NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int em_lldt(struct x86_emulate_ctxt *ctxt)\n{\n\tu16 sel = ctxt->src.val;\n\n\t/* Disable writeback. */\n\tctxt->dst.type = OP_NONE;\n\treturn load_segment_descriptor(ctxt, sel, VCPU_SREG_LDTR);\n}"
  },
  {
    "function_name": "em_mov_sreg_rm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "3591-3604",
    "snippet": "static int em_mov_sreg_rm(struct x86_emulate_ctxt *ctxt)\n{\n\tu16 sel = ctxt->src.val;\n\n\tif (ctxt->modrm_reg == VCPU_SREG_CS || ctxt->modrm_reg > VCPU_SREG_GS)\n\t\treturn emulate_ud(ctxt);\n\n\tif (ctxt->modrm_reg == VCPU_SREG_SS)\n\t\tctxt->interruptibility = KVM_X86_SHADOW_INT_MOV_SS;\n\n\t/* Disable writeback. */\n\tctxt->dst.type = OP_NONE;\n\treturn load_segment_descriptor(ctxt, sel, ctxt->modrm_reg);\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "load_segment_descriptor",
          "args": [
            "ctxt",
            "sel",
            "ctxt->modrm_reg"
          ],
          "line": 3603
        },
        "resolved": true,
        "details": {
          "function_name": "load_segment_descriptor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "1710-1716",
          "snippet": "static int load_segment_descriptor(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t   u16 selector, int seg)\n{\n\tu8 cpl = ctxt->ops->cpl(ctxt);\n\treturn __load_segment_descriptor(ctxt, selector, seg, cpl,\n\t\t\t\t\t X86_TRANSFER_NONE, NULL);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int load_segment_descriptor(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t   u16 selector, int seg)\n{\n\tu8 cpl = ctxt->ops->cpl(ctxt);\n\treturn __load_segment_descriptor(ctxt, selector, seg, cpl,\n\t\t\t\t\t X86_TRANSFER_NONE, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "emulate_ud",
          "args": [
            "ctxt"
          ],
          "line": 3596
        },
        "resolved": true,
        "details": {
          "function_name": "emulate_ud",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "590-593",
          "snippet": "static int emulate_ud(struct x86_emulate_ctxt *ctxt)\n{\n\treturn emulate_exception(ctxt, UD_VECTOR, 0, false);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int emulate_ud(struct x86_emulate_ctxt *ctxt)\n{\n\treturn emulate_exception(ctxt, UD_VECTOR, 0, false);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int em_mov_sreg_rm(struct x86_emulate_ctxt *ctxt)\n{\n\tu16 sel = ctxt->src.val;\n\n\tif (ctxt->modrm_reg == VCPU_SREG_CS || ctxt->modrm_reg > VCPU_SREG_GS)\n\t\treturn emulate_ud(ctxt);\n\n\tif (ctxt->modrm_reg == VCPU_SREG_SS)\n\t\tctxt->interruptibility = KVM_X86_SHADOW_INT_MOV_SS;\n\n\t/* Disable writeback. */\n\tctxt->dst.type = OP_NONE;\n\treturn load_segment_descriptor(ctxt, sel, ctxt->modrm_reg);\n}"
  },
  {
    "function_name": "em_mov_rm_sreg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "3580-3589",
    "snippet": "static int em_mov_rm_sreg(struct x86_emulate_ctxt *ctxt)\n{\n\tif (ctxt->modrm_reg > VCPU_SREG_GS)\n\t\treturn emulate_ud(ctxt);\n\n\tctxt->dst.val = get_segment_selector(ctxt, ctxt->modrm_reg);\n\tif (ctxt->dst.bytes == 4 && ctxt->dst.type == OP_MEM)\n\t\tctxt->dst.bytes = 2;\n\treturn X86EMUL_CONTINUE;\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_segment_selector",
          "args": [
            "ctxt",
            "ctxt->modrm_reg"
          ],
          "line": 3585
        },
        "resolved": true,
        "details": {
          "function_name": "get_segment_selector",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "610-617",
          "snippet": "static u16 get_segment_selector(struct x86_emulate_ctxt *ctxt, unsigned seg)\n{\n\tu16 selector;\n\tstruct desc_struct desc;\n\n\tctxt->ops->get_segment(ctxt, &selector, &desc, NULL, seg);\n\treturn selector;\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic u16 get_segment_selector(struct x86_emulate_ctxt *ctxt, unsigned seg)\n{\n\tu16 selector;\n\tstruct desc_struct desc;\n\n\tctxt->ops->get_segment(ctxt, &selector, &desc, NULL, seg);\n\treturn selector;\n}"
        }
      },
      {
        "call_info": {
          "callee": "emulate_ud",
          "args": [
            "ctxt"
          ],
          "line": 3583
        },
        "resolved": true,
        "details": {
          "function_name": "emulate_ud",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "590-593",
          "snippet": "static int emulate_ud(struct x86_emulate_ctxt *ctxt)\n{\n\treturn emulate_exception(ctxt, UD_VECTOR, 0, false);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int emulate_ud(struct x86_emulate_ctxt *ctxt)\n{\n\treturn emulate_exception(ctxt, UD_VECTOR, 0, false);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int em_mov_rm_sreg(struct x86_emulate_ctxt *ctxt)\n{\n\tif (ctxt->modrm_reg > VCPU_SREG_GS)\n\t\treturn emulate_ud(ctxt);\n\n\tctxt->dst.val = get_segment_selector(ctxt, ctxt->modrm_reg);\n\tif (ctxt->dst.bytes == 4 && ctxt->dst.type == OP_MEM)\n\t\tctxt->dst.bytes = 2;\n\treturn X86EMUL_CONTINUE;\n}"
  },
  {
    "function_name": "em_rdmsr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "3568-3578",
    "snippet": "static int em_rdmsr(struct x86_emulate_ctxt *ctxt)\n{\n\tu64 msr_data;\n\n\tif (ctxt->ops->get_msr(ctxt, reg_read(ctxt, VCPU_REGS_RCX), &msr_data))\n\t\treturn emulate_gp(ctxt, 0);\n\n\t*reg_write(ctxt, VCPU_REGS_RAX) = (u32)msr_data;\n\t*reg_write(ctxt, VCPU_REGS_RDX) = msr_data >> 32;\n\treturn X86EMUL_CONTINUE;\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reg_write",
          "args": [
            "ctxt",
            "VCPU_REGS_RDX"
          ],
          "line": 3576
        },
        "resolved": true,
        "details": {
          "function_name": "reg_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "270-275",
          "snippet": "static ulong *reg_write(struct x86_emulate_ctxt *ctxt, unsigned nr)\n{\n\tctxt->regs_valid |= 1 << nr;\n\tctxt->regs_dirty |= 1 << nr;\n\treturn &ctxt->_regs[nr];\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic ulong *reg_write(struct x86_emulate_ctxt *ctxt, unsigned nr)\n{\n\tctxt->regs_valid |= 1 << nr;\n\tctxt->regs_dirty |= 1 << nr;\n\treturn &ctxt->_regs[nr];\n}"
        }
      },
      {
        "call_info": {
          "callee": "emulate_gp",
          "args": [
            "ctxt",
            "0"
          ],
          "line": 3573
        },
        "resolved": true,
        "details": {
          "function_name": "emulate_gp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "580-583",
          "snippet": "static int emulate_gp(struct x86_emulate_ctxt *ctxt, int err)\n{\n\treturn emulate_exception(ctxt, GP_VECTOR, err, true);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int emulate_gp(struct x86_emulate_ctxt *ctxt, int err)\n{\n\treturn emulate_exception(ctxt, GP_VECTOR, err, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ctxt->ops->get_msr",
          "args": [
            "ctxt",
            "reg_read(ctxt, VCPU_REGS_RCX)",
            "&msr_data"
          ],
          "line": 3572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reg_read",
          "args": [
            "ctxt",
            "VCPU_REGS_RCX"
          ],
          "line": 3572
        },
        "resolved": true,
        "details": {
          "function_name": "reg_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "261-268",
          "snippet": "static ulong reg_read(struct x86_emulate_ctxt *ctxt, unsigned nr)\n{\n\tif (!(ctxt->regs_valid & (1 << nr))) {\n\t\tctxt->regs_valid |= 1 << nr;\n\t\tctxt->_regs[nr] = ctxt->ops->read_gpr(ctxt, nr);\n\t}\n\treturn ctxt->_regs[nr];\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic ulong reg_read(struct x86_emulate_ctxt *ctxt, unsigned nr)\n{\n\tif (!(ctxt->regs_valid & (1 << nr))) {\n\t\tctxt->regs_valid |= 1 << nr;\n\t\tctxt->_regs[nr] = ctxt->ops->read_gpr(ctxt, nr);\n\t}\n\treturn ctxt->_regs[nr];\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int em_rdmsr(struct x86_emulate_ctxt *ctxt)\n{\n\tu64 msr_data;\n\n\tif (ctxt->ops->get_msr(ctxt, reg_read(ctxt, VCPU_REGS_RCX), &msr_data))\n\t\treturn emulate_gp(ctxt, 0);\n\n\t*reg_write(ctxt, VCPU_REGS_RAX) = (u32)msr_data;\n\t*reg_write(ctxt, VCPU_REGS_RDX) = msr_data >> 32;\n\treturn X86EMUL_CONTINUE;\n}"
  },
  {
    "function_name": "em_wrmsr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "3556-3566",
    "snippet": "static int em_wrmsr(struct x86_emulate_ctxt *ctxt)\n{\n\tu64 msr_data;\n\n\tmsr_data = (u32)reg_read(ctxt, VCPU_REGS_RAX)\n\t\t| ((u64)reg_read(ctxt, VCPU_REGS_RDX) << 32);\n\tif (ctxt->ops->set_msr(ctxt, reg_read(ctxt, VCPU_REGS_RCX), msr_data))\n\t\treturn emulate_gp(ctxt, 0);\n\n\treturn X86EMUL_CONTINUE;\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "emulate_gp",
          "args": [
            "ctxt",
            "0"
          ],
          "line": 3563
        },
        "resolved": true,
        "details": {
          "function_name": "emulate_gp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "580-583",
          "snippet": "static int emulate_gp(struct x86_emulate_ctxt *ctxt, int err)\n{\n\treturn emulate_exception(ctxt, GP_VECTOR, err, true);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int emulate_gp(struct x86_emulate_ctxt *ctxt, int err)\n{\n\treturn emulate_exception(ctxt, GP_VECTOR, err, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ctxt->ops->set_msr",
          "args": [
            "ctxt",
            "reg_read(ctxt, VCPU_REGS_RCX)",
            "msr_data"
          ],
          "line": 3562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reg_read",
          "args": [
            "ctxt",
            "VCPU_REGS_RCX"
          ],
          "line": 3562
        },
        "resolved": true,
        "details": {
          "function_name": "reg_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "261-268",
          "snippet": "static ulong reg_read(struct x86_emulate_ctxt *ctxt, unsigned nr)\n{\n\tif (!(ctxt->regs_valid & (1 << nr))) {\n\t\tctxt->regs_valid |= 1 << nr;\n\t\tctxt->_regs[nr] = ctxt->ops->read_gpr(ctxt, nr);\n\t}\n\treturn ctxt->_regs[nr];\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic ulong reg_read(struct x86_emulate_ctxt *ctxt, unsigned nr)\n{\n\tif (!(ctxt->regs_valid & (1 << nr))) {\n\t\tctxt->regs_valid |= 1 << nr;\n\t\tctxt->_regs[nr] = ctxt->ops->read_gpr(ctxt, nr);\n\t}\n\treturn ctxt->_regs[nr];\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int em_wrmsr(struct x86_emulate_ctxt *ctxt)\n{\n\tu64 msr_data;\n\n\tmsr_data = (u32)reg_read(ctxt, VCPU_REGS_RAX)\n\t\t| ((u64)reg_read(ctxt, VCPU_REGS_RDX) << 32);\n\tif (ctxt->ops->set_msr(ctxt, reg_read(ctxt, VCPU_REGS_RCX), msr_data))\n\t\treturn emulate_gp(ctxt, 0);\n\n\treturn X86EMUL_CONTINUE;\n}"
  },
  {
    "function_name": "em_dr_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "3538-3554",
    "snippet": "static int em_dr_write(struct x86_emulate_ctxt *ctxt)\n{\n\tunsigned long val;\n\n\tif (ctxt->mode == X86EMUL_MODE_PROT64)\n\t\tval = ctxt->src.val & ~0ULL;\n\telse\n\t\tval = ctxt->src.val & ~0U;\n\n\t/* #UD condition is already handled. */\n\tif (ctxt->ops->set_dr(ctxt, ctxt->modrm_reg, val) < 0)\n\t\treturn emulate_gp(ctxt, 0);\n\n\t/* Disable writeback. */\n\tctxt->dst.type = OP_NONE;\n\treturn X86EMUL_CONTINUE;\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "emulate_gp",
          "args": [
            "ctxt",
            "0"
          ],
          "line": 3549
        },
        "resolved": true,
        "details": {
          "function_name": "emulate_gp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "580-583",
          "snippet": "static int emulate_gp(struct x86_emulate_ctxt *ctxt, int err)\n{\n\treturn emulate_exception(ctxt, GP_VECTOR, err, true);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int emulate_gp(struct x86_emulate_ctxt *ctxt, int err)\n{\n\treturn emulate_exception(ctxt, GP_VECTOR, err, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ctxt->ops->set_dr",
          "args": [
            "ctxt",
            "ctxt->modrm_reg",
            "val"
          ],
          "line": 3548
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int em_dr_write(struct x86_emulate_ctxt *ctxt)\n{\n\tunsigned long val;\n\n\tif (ctxt->mode == X86EMUL_MODE_PROT64)\n\t\tval = ctxt->src.val & ~0ULL;\n\telse\n\t\tval = ctxt->src.val & ~0U;\n\n\t/* #UD condition is already handled. */\n\tif (ctxt->ops->set_dr(ctxt, ctxt->modrm_reg, val) < 0)\n\t\treturn emulate_gp(ctxt, 0);\n\n\t/* Disable writeback. */\n\tctxt->dst.type = OP_NONE;\n\treturn X86EMUL_CONTINUE;\n}"
  },
  {
    "function_name": "em_cr_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "3528-3536",
    "snippet": "static int em_cr_write(struct x86_emulate_ctxt *ctxt)\n{\n\tif (ctxt->ops->set_cr(ctxt, ctxt->modrm_reg, ctxt->src.val))\n\t\treturn emulate_gp(ctxt, 0);\n\n\t/* Disable writeback. */\n\tctxt->dst.type = OP_NONE;\n\treturn X86EMUL_CONTINUE;\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "emulate_gp",
          "args": [
            "ctxt",
            "0"
          ],
          "line": 3531
        },
        "resolved": true,
        "details": {
          "function_name": "emulate_gp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "580-583",
          "snippet": "static int emulate_gp(struct x86_emulate_ctxt *ctxt, int err)\n{\n\treturn emulate_exception(ctxt, GP_VECTOR, err, true);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int emulate_gp(struct x86_emulate_ctxt *ctxt, int err)\n{\n\treturn emulate_exception(ctxt, GP_VECTOR, err, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ctxt->ops->set_cr",
          "args": [
            "ctxt",
            "ctxt->modrm_reg",
            "ctxt->src.val"
          ],
          "line": 3530
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int em_cr_write(struct x86_emulate_ctxt *ctxt)\n{\n\tif (ctxt->ops->set_cr(ctxt, ctxt->modrm_reg, ctxt->src.val))\n\t\treturn emulate_gp(ctxt, 0);\n\n\t/* Disable writeback. */\n\tctxt->dst.type = OP_NONE;\n\treturn X86EMUL_CONTINUE;\n}"
  },
  {
    "function_name": "em_movbe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "3490-3526",
    "snippet": "static int em_movbe(struct x86_emulate_ctxt *ctxt)\n{\n\tu32 ebx, ecx, edx, eax = 1;\n\tu16 tmp;\n\n\t/*\n\t * Check MOVBE is set in the guest-visible CPUID leaf.\n\t */\n\tctxt->ops->get_cpuid(ctxt, &eax, &ebx, &ecx, &edx);\n\tif (!(ecx & FFL(MOVBE)))\n\t\treturn emulate_ud(ctxt);\n\n\tswitch (ctxt->op_bytes) {\n\tcase 2:\n\t\t/*\n\t\t * From MOVBE definition: \"...When the operand size is 16 bits,\n\t\t * the upper word of the destination register remains unchanged\n\t\t * ...\"\n\t\t *\n\t\t * Both casting ->valptr and ->val to u16 breaks strict aliasing\n\t\t * rules so we have to do the operation almost per hand.\n\t\t */\n\t\ttmp = (u16)ctxt->src.val;\n\t\tctxt->dst.val &= ~0xffffUL;\n\t\tctxt->dst.val |= (unsigned long)swab16(tmp);\n\t\tbreak;\n\tcase 4:\n\t\tctxt->dst.val = swab32((u32)ctxt->src.val);\n\t\tbreak;\n\tcase 8:\n\t\tctxt->dst.val = swab64(ctxt->src.val);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\treturn X86EMUL_CONTINUE;\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 3523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swab64",
          "args": [
            "ctxt->src.val"
          ],
          "line": 3520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swab32",
          "args": [
            "(u32)ctxt->src.val"
          ],
          "line": 3517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swab16",
          "args": [
            "tmp"
          ],
          "line": 3514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "emulate_ud",
          "args": [
            "ctxt"
          ],
          "line": 3500
        },
        "resolved": true,
        "details": {
          "function_name": "emulate_ud",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "590-593",
          "snippet": "static int emulate_ud(struct x86_emulate_ctxt *ctxt)\n{\n\treturn emulate_exception(ctxt, UD_VECTOR, 0, false);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int emulate_ud(struct x86_emulate_ctxt *ctxt)\n{\n\treturn emulate_exception(ctxt, UD_VECTOR, 0, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "FFL",
          "args": [
            "MOVBE"
          ],
          "line": 3499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ctxt->ops->get_cpuid",
          "args": [
            "ctxt",
            "&eax",
            "&ebx",
            "&ecx",
            "&edx"
          ],
          "line": 3498
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int em_movbe(struct x86_emulate_ctxt *ctxt)\n{\n\tu32 ebx, ecx, edx, eax = 1;\n\tu16 tmp;\n\n\t/*\n\t * Check MOVBE is set in the guest-visible CPUID leaf.\n\t */\n\tctxt->ops->get_cpuid(ctxt, &eax, &ebx, &ecx, &edx);\n\tif (!(ecx & FFL(MOVBE)))\n\t\treturn emulate_ud(ctxt);\n\n\tswitch (ctxt->op_bytes) {\n\tcase 2:\n\t\t/*\n\t\t * From MOVBE definition: \"...When the operand size is 16 bits,\n\t\t * the upper word of the destination register remains unchanged\n\t\t * ...\"\n\t\t *\n\t\t * Both casting ->valptr and ->val to u16 breaks strict aliasing\n\t\t * rules so we have to do the operation almost per hand.\n\t\t */\n\t\ttmp = (u16)ctxt->src.val;\n\t\tctxt->dst.val &= ~0xffffUL;\n\t\tctxt->dst.val |= (unsigned long)swab16(tmp);\n\t\tbreak;\n\tcase 4:\n\t\tctxt->dst.val = swab32((u32)ctxt->src.val);\n\t\tbreak;\n\tcase 8:\n\t\tctxt->dst.val = swab64(ctxt->src.val);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\treturn X86EMUL_CONTINUE;\n}"
  },
  {
    "function_name": "em_mov",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "3482-3486",
    "snippet": "static int em_mov(struct x86_emulate_ctxt *ctxt)\n{\n\tmemcpy(ctxt->dst.valptr, ctxt->src.valptr, sizeof(ctxt->src.valptr));\n\treturn X86EMUL_CONTINUE;\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ctxt->dst.valptr",
            "ctxt->src.valptr",
            "sizeof(ctxt->src.valptr)"
          ],
          "line": 3484
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int em_mov(struct x86_emulate_ctxt *ctxt)\n{\n\tmemcpy(ctxt->dst.valptr, ctxt->src.valptr, sizeof(ctxt->src.valptr));\n\treturn X86EMUL_CONTINUE;\n}"
  },
  {
    "function_name": "em_rdpmc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "3471-3480",
    "snippet": "static int em_rdpmc(struct x86_emulate_ctxt *ctxt)\n{\n\tu64 pmc;\n\n\tif (ctxt->ops->read_pmc(ctxt, reg_read(ctxt, VCPU_REGS_RCX), &pmc))\n\t\treturn emulate_gp(ctxt, 0);\n\t*reg_write(ctxt, VCPU_REGS_RAX) = (u32)pmc;\n\t*reg_write(ctxt, VCPU_REGS_RDX) = pmc >> 32;\n\treturn X86EMUL_CONTINUE;\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reg_write",
          "args": [
            "ctxt",
            "VCPU_REGS_RDX"
          ],
          "line": 3478
        },
        "resolved": true,
        "details": {
          "function_name": "reg_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "270-275",
          "snippet": "static ulong *reg_write(struct x86_emulate_ctxt *ctxt, unsigned nr)\n{\n\tctxt->regs_valid |= 1 << nr;\n\tctxt->regs_dirty |= 1 << nr;\n\treturn &ctxt->_regs[nr];\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic ulong *reg_write(struct x86_emulate_ctxt *ctxt, unsigned nr)\n{\n\tctxt->regs_valid |= 1 << nr;\n\tctxt->regs_dirty |= 1 << nr;\n\treturn &ctxt->_regs[nr];\n}"
        }
      },
      {
        "call_info": {
          "callee": "emulate_gp",
          "args": [
            "ctxt",
            "0"
          ],
          "line": 3476
        },
        "resolved": true,
        "details": {
          "function_name": "emulate_gp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "580-583",
          "snippet": "static int emulate_gp(struct x86_emulate_ctxt *ctxt, int err)\n{\n\treturn emulate_exception(ctxt, GP_VECTOR, err, true);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int emulate_gp(struct x86_emulate_ctxt *ctxt, int err)\n{\n\treturn emulate_exception(ctxt, GP_VECTOR, err, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ctxt->ops->read_pmc",
          "args": [
            "ctxt",
            "reg_read(ctxt, VCPU_REGS_RCX)",
            "&pmc"
          ],
          "line": 3475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reg_read",
          "args": [
            "ctxt",
            "VCPU_REGS_RCX"
          ],
          "line": 3475
        },
        "resolved": true,
        "details": {
          "function_name": "reg_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "261-268",
          "snippet": "static ulong reg_read(struct x86_emulate_ctxt *ctxt, unsigned nr)\n{\n\tif (!(ctxt->regs_valid & (1 << nr))) {\n\t\tctxt->regs_valid |= 1 << nr;\n\t\tctxt->_regs[nr] = ctxt->ops->read_gpr(ctxt, nr);\n\t}\n\treturn ctxt->_regs[nr];\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic ulong reg_read(struct x86_emulate_ctxt *ctxt, unsigned nr)\n{\n\tif (!(ctxt->regs_valid & (1 << nr))) {\n\t\tctxt->regs_valid |= 1 << nr;\n\t\tctxt->_regs[nr] = ctxt->ops->read_gpr(ctxt, nr);\n\t}\n\treturn ctxt->_regs[nr];\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int em_rdpmc(struct x86_emulate_ctxt *ctxt)\n{\n\tu64 pmc;\n\n\tif (ctxt->ops->read_pmc(ctxt, reg_read(ctxt, VCPU_REGS_RCX), &pmc))\n\t\treturn emulate_gp(ctxt, 0);\n\t*reg_write(ctxt, VCPU_REGS_RAX) = (u32)pmc;\n\t*reg_write(ctxt, VCPU_REGS_RDX) = pmc >> 32;\n\treturn X86EMUL_CONTINUE;\n}"
  },
  {
    "function_name": "em_rdtsc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "3461-3469",
    "snippet": "static int em_rdtsc(struct x86_emulate_ctxt *ctxt)\n{\n\tu64 tsc = 0;\n\n\tctxt->ops->get_msr(ctxt, MSR_IA32_TSC, &tsc);\n\t*reg_write(ctxt, VCPU_REGS_RAX) = (u32)tsc;\n\t*reg_write(ctxt, VCPU_REGS_RDX) = tsc >> 32;\n\treturn X86EMUL_CONTINUE;\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reg_write",
          "args": [
            "ctxt",
            "VCPU_REGS_RDX"
          ],
          "line": 3467
        },
        "resolved": true,
        "details": {
          "function_name": "reg_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "270-275",
          "snippet": "static ulong *reg_write(struct x86_emulate_ctxt *ctxt, unsigned nr)\n{\n\tctxt->regs_valid |= 1 << nr;\n\tctxt->regs_dirty |= 1 << nr;\n\treturn &ctxt->_regs[nr];\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic ulong *reg_write(struct x86_emulate_ctxt *ctxt, unsigned nr)\n{\n\tctxt->regs_valid |= 1 << nr;\n\tctxt->regs_dirty |= 1 << nr;\n\treturn &ctxt->_regs[nr];\n}"
        }
      },
      {
        "call_info": {
          "callee": "ctxt->ops->get_msr",
          "args": [
            "ctxt",
            "MSR_IA32_TSC",
            "&tsc"
          ],
          "line": 3465
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int em_rdtsc(struct x86_emulate_ctxt *ctxt)\n{\n\tu64 tsc = 0;\n\n\tctxt->ops->get_msr(ctxt, MSR_IA32_TSC, &tsc);\n\t*reg_write(ctxt, VCPU_REGS_RAX) = (u32)tsc;\n\t*reg_write(ctxt, VCPU_REGS_RDX) = tsc >> 32;\n\treturn X86EMUL_CONTINUE;\n}"
  },
  {
    "function_name": "em_cwd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "3451-3459",
    "snippet": "static int em_cwd(struct x86_emulate_ctxt *ctxt)\n{\n\tctxt->dst.type = OP_REG;\n\tctxt->dst.bytes = ctxt->src.bytes;\n\tctxt->dst.addr.reg = reg_rmw(ctxt, VCPU_REGS_RDX);\n\tctxt->dst.val = ~((ctxt->src.val >> (ctxt->src.bytes * 8 - 1)) - 1);\n\n\treturn X86EMUL_CONTINUE;\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reg_rmw",
          "args": [
            "ctxt",
            "VCPU_REGS_RDX"
          ],
          "line": 3455
        },
        "resolved": true,
        "details": {
          "function_name": "reg_rmw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "277-281",
          "snippet": "static ulong *reg_rmw(struct x86_emulate_ctxt *ctxt, unsigned nr)\n{\n\treg_read(ctxt, nr);\n\treturn reg_write(ctxt, nr);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic ulong *reg_rmw(struct x86_emulate_ctxt *ctxt, unsigned nr)\n{\n\treg_read(ctxt, nr);\n\treturn reg_write(ctxt, nr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int em_cwd(struct x86_emulate_ctxt *ctxt)\n{\n\tctxt->dst.type = OP_REG;\n\tctxt->dst.bytes = ctxt->src.bytes;\n\tctxt->dst.addr.reg = reg_rmw(ctxt, VCPU_REGS_RDX);\n\tctxt->dst.val = ~((ctxt->src.val >> (ctxt->src.bytes * 8 - 1)) - 1);\n\n\treturn X86EMUL_CONTINUE;\n}"
  },
  {
    "function_name": "em_imul_3op",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "3445-3449",
    "snippet": "static int em_imul_3op(struct x86_emulate_ctxt *ctxt)\n{\n\tctxt->dst.val = ctxt->src2.val;\n\treturn fastop(ctxt, em_imul);\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int fastop(struct x86_emulate_ctxt *ctxt, void (*fop)(struct fastop *));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fastop",
          "args": [
            "ctxt",
            "em_imul"
          ],
          "line": 3448
        },
        "resolved": true,
        "details": {
          "function_name": "fastop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "5111-5124",
          "snippet": "static int fastop(struct x86_emulate_ctxt *ctxt, void (*fop)(struct fastop *))\n{\n\tulong flags = (ctxt->eflags & EFLAGS_MASK) | X86_EFLAGS_IF;\n\tif (!(ctxt->d & ByteOp))\n\t\tfop += __ffs(ctxt->dst.bytes) * FASTOP_SIZE;\n\tasm(\"push %[flags]; popf; call *%[fastop]; pushf; pop %[flags]\\n\"\n\t    : \"+a\"(ctxt->dst.val), \"+d\"(ctxt->src.val), [flags]\"+D\"(flags),\n\t      [fastop]\"+S\"(fop)\n\t    : \"c\"(ctxt->src2.val));\n\tctxt->eflags = (ctxt->eflags & ~EFLAGS_MASK) | (flags & EFLAGS_MASK);\n\tif (!fop) /* exception is returned in fop variable */\n\t\treturn emulate_de(ctxt);\n\treturn X86EMUL_CONTINUE;\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define EFLAGS_MASK (X86_EFLAGS_OF|X86_EFLAGS_SF|X86_EFLAGS_ZF|X86_EFLAGS_AF|\\\n\t\t     X86_EFLAGS_PF|X86_EFLAGS_CF)",
            "#define FASTOP_SIZE 8",
            "#define ByteOp      (1<<0)\t/* 8-bit operands. */"
          ],
          "globals_used": [
            "static int fastop(struct x86_emulate_ctxt *ctxt, void (*fop)(struct fastop *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\n#define EFLAGS_MASK (X86_EFLAGS_OF|X86_EFLAGS_SF|X86_EFLAGS_ZF|X86_EFLAGS_AF|\\\n\t\t     X86_EFLAGS_PF|X86_EFLAGS_CF)\n#define FASTOP_SIZE 8\n#define ByteOp      (1<<0)\t/* 8-bit operands. */\n\nstatic int fastop(struct x86_emulate_ctxt *ctxt, void (*fop)(struct fastop *));\n\nstatic int fastop(struct x86_emulate_ctxt *ctxt, void (*fop)(struct fastop *))\n{\n\tulong flags = (ctxt->eflags & EFLAGS_MASK) | X86_EFLAGS_IF;\n\tif (!(ctxt->d & ByteOp))\n\t\tfop += __ffs(ctxt->dst.bytes) * FASTOP_SIZE;\n\tasm(\"push %[flags]; popf; call *%[fastop]; pushf; pop %[flags]\\n\"\n\t    : \"+a\"(ctxt->dst.val), \"+d\"(ctxt->src.val), [flags]\"+D\"(flags),\n\t      [fastop]\"+S\"(fop)\n\t    : \"c\"(ctxt->src2.val));\n\tctxt->eflags = (ctxt->eflags & ~EFLAGS_MASK) | (flags & EFLAGS_MASK);\n\tif (!fop) /* exception is returned in fop variable */\n\t\treturn emulate_de(ctxt);\n\treturn X86EMUL_CONTINUE;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int fastop(struct x86_emulate_ctxt *ctxt, void (*fop)(struct fastop *));\n\nstatic int em_imul_3op(struct x86_emulate_ctxt *ctxt)\n{\n\tctxt->dst.val = ctxt->src2.val;\n\treturn fastop(ctxt, em_imul);\n}"
  },
  {
    "function_name": "em_xchg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "3433-3443",
    "snippet": "static int em_xchg(struct x86_emulate_ctxt *ctxt)\n{\n\t/* Write back the register source. */\n\tctxt->src.val = ctxt->dst.val;\n\twrite_register_operand(&ctxt->src);\n\n\t/* Write back the memory destination with implicit LOCK prefix. */\n\tctxt->dst.val = ctxt->src.orig_val;\n\tctxt->lock_prefix = 1;\n\treturn X86EMUL_CONTINUE;\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_register_operand",
          "args": [
            "&ctxt->src"
          ],
          "line": 3437
        },
        "resolved": true,
        "details": {
          "function_name": "write_register_operand",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "1718-1721",
          "snippet": "static void write_register_operand(struct operand *op)\n{\n\treturn assign_register(op->addr.reg, op->val, op->bytes);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic void write_register_operand(struct operand *op)\n{\n\treturn assign_register(op->addr.reg, op->val, op->bytes);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int em_xchg(struct x86_emulate_ctxt *ctxt)\n{\n\t/* Write back the register source. */\n\tctxt->src.val = ctxt->dst.val;\n\twrite_register_operand(&ctxt->src);\n\n\t/* Write back the memory destination with implicit LOCK prefix. */\n\tctxt->dst.val = ctxt->src.orig_val;\n\tctxt->lock_prefix = 1;\n\treturn X86EMUL_CONTINUE;\n}"
  },
  {
    "function_name": "em_ret_near_imm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "3418-3431",
    "snippet": "static int em_ret_near_imm(struct x86_emulate_ctxt *ctxt)\n{\n\tint rc;\n\tunsigned long eip;\n\n\trc = emulate_pop(ctxt, &eip, ctxt->op_bytes);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\trc = assign_eip_near(ctxt, eip);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\trsp_increment(ctxt, ctxt->src.val);\n\treturn X86EMUL_CONTINUE;\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rsp_increment",
          "args": [
            "ctxt",
            "ctxt->src.val"
          ],
          "line": 3429
        },
        "resolved": true,
        "details": {
          "function_name": "rsp_increment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "545-548",
          "snippet": "static void rsp_increment(struct x86_emulate_ctxt *ctxt, int inc)\n{\n\tmasked_increment(reg_rmw(ctxt, VCPU_REGS_RSP), stack_mask(ctxt), inc);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic void rsp_increment(struct x86_emulate_ctxt *ctxt, int inc)\n{\n\tmasked_increment(reg_rmw(ctxt, VCPU_REGS_RSP), stack_mask(ctxt), inc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assign_eip_near",
          "args": [
            "ctxt",
            "eip"
          ],
          "line": 3426
        },
        "resolved": true,
        "details": {
          "function_name": "assign_eip_near",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "745-748",
          "snippet": "static inline int assign_eip_near(struct x86_emulate_ctxt *ctxt, ulong dst)\n{\n\treturn assign_eip(ctxt, dst, ctxt->mode);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline int assign_eip_near(struct x86_emulate_ctxt *ctxt, ulong dst)\n{\n\treturn assign_eip(ctxt, dst, ctxt->mode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "emulate_pop",
          "args": [
            "ctxt",
            "&eip",
            "ctxt->op_bytes"
          ],
          "line": 3423
        },
        "resolved": true,
        "details": {
          "function_name": "emulate_popf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "1802-1842",
          "snippet": "static int emulate_popf(struct x86_emulate_ctxt *ctxt,\n\t\t\tvoid *dest, int len)\n{\n\tint rc;\n\tunsigned long val, change_mask;\n\tint iopl = (ctxt->eflags & X86_EFLAGS_IOPL) >> X86_EFLAGS_IOPL_BIT;\n\tint cpl = ctxt->ops->cpl(ctxt);\n\n\trc = emulate_pop(ctxt, &val, len);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\tchange_mask = X86_EFLAGS_CF | X86_EFLAGS_PF | X86_EFLAGS_AF |\n\t\t      X86_EFLAGS_ZF | X86_EFLAGS_SF | X86_EFLAGS_OF |\n\t\t      X86_EFLAGS_TF | X86_EFLAGS_DF | X86_EFLAGS_NT |\n\t\t      X86_EFLAGS_AC | X86_EFLAGS_ID;\n\n\tswitch(ctxt->mode) {\n\tcase X86EMUL_MODE_PROT64:\n\tcase X86EMUL_MODE_PROT32:\n\tcase X86EMUL_MODE_PROT16:\n\t\tif (cpl == 0)\n\t\t\tchange_mask |= X86_EFLAGS_IOPL;\n\t\tif (cpl <= iopl)\n\t\t\tchange_mask |= X86_EFLAGS_IF;\n\t\tbreak;\n\tcase X86EMUL_MODE_VM86:\n\t\tif (iopl < 3)\n\t\t\treturn emulate_gp(ctxt, 0);\n\t\tchange_mask |= X86_EFLAGS_IF;\n\t\tbreak;\n\tdefault: /* real mode */\n\t\tchange_mask |= (X86_EFLAGS_IOPL | X86_EFLAGS_IF);\n\t\tbreak;\n\t}\n\n\t*(unsigned long *)dest =\n\t\t(ctxt->eflags & ~change_mask) | (val & change_mask);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int emulate_popf(struct x86_emulate_ctxt *ctxt,\n\t\t\tvoid *dest, int len)\n{\n\tint rc;\n\tunsigned long val, change_mask;\n\tint iopl = (ctxt->eflags & X86_EFLAGS_IOPL) >> X86_EFLAGS_IOPL_BIT;\n\tint cpl = ctxt->ops->cpl(ctxt);\n\n\trc = emulate_pop(ctxt, &val, len);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\tchange_mask = X86_EFLAGS_CF | X86_EFLAGS_PF | X86_EFLAGS_AF |\n\t\t      X86_EFLAGS_ZF | X86_EFLAGS_SF | X86_EFLAGS_OF |\n\t\t      X86_EFLAGS_TF | X86_EFLAGS_DF | X86_EFLAGS_NT |\n\t\t      X86_EFLAGS_AC | X86_EFLAGS_ID;\n\n\tswitch(ctxt->mode) {\n\tcase X86EMUL_MODE_PROT64:\n\tcase X86EMUL_MODE_PROT32:\n\tcase X86EMUL_MODE_PROT16:\n\t\tif (cpl == 0)\n\t\t\tchange_mask |= X86_EFLAGS_IOPL;\n\t\tif (cpl <= iopl)\n\t\t\tchange_mask |= X86_EFLAGS_IF;\n\t\tbreak;\n\tcase X86EMUL_MODE_VM86:\n\t\tif (iopl < 3)\n\t\t\treturn emulate_gp(ctxt, 0);\n\t\tchange_mask |= X86_EFLAGS_IF;\n\t\tbreak;\n\tdefault: /* real mode */\n\t\tchange_mask |= (X86_EFLAGS_IOPL | X86_EFLAGS_IF);\n\t\tbreak;\n\t}\n\n\t*(unsigned long *)dest =\n\t\t(ctxt->eflags & ~change_mask) | (val & change_mask);\n\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int em_ret_near_imm(struct x86_emulate_ctxt *ctxt)\n{\n\tint rc;\n\tunsigned long eip;\n\n\trc = emulate_pop(ctxt, &eip, ctxt->op_bytes);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\trc = assign_eip_near(ctxt, eip);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\trsp_increment(ctxt, ctxt->src.val);\n\treturn X86EMUL_CONTINUE;\n}"
  },
  {
    "function_name": "em_call_far",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "3374-3416",
    "snippet": "static int em_call_far(struct x86_emulate_ctxt *ctxt)\n{\n\tu16 sel, old_cs;\n\tulong old_eip;\n\tint rc;\n\tstruct desc_struct old_desc, new_desc;\n\tconst struct x86_emulate_ops *ops = ctxt->ops;\n\tint cpl = ctxt->ops->cpl(ctxt);\n\tenum x86emul_mode prev_mode = ctxt->mode;\n\n\told_eip = ctxt->_eip;\n\tops->get_segment(ctxt, &old_cs, &old_desc, NULL, VCPU_SREG_CS);\n\n\tmemcpy(&sel, ctxt->src.valptr + ctxt->op_bytes, 2);\n\trc = __load_segment_descriptor(ctxt, sel, VCPU_SREG_CS, cpl,\n\t\t\t\t       X86_TRANSFER_CALL_JMP, &new_desc);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\trc = assign_eip_far(ctxt, ctxt->src.val, &new_desc);\n\tif (rc != X86EMUL_CONTINUE)\n\t\tgoto fail;\n\n\tctxt->src.val = old_cs;\n\trc = em_push(ctxt);\n\tif (rc != X86EMUL_CONTINUE)\n\t\tgoto fail;\n\n\tctxt->src.val = old_eip;\n\trc = em_push(ctxt);\n\t/* If we failed, we tainted the memory, but the very least we should\n\t   restore cs */\n\tif (rc != X86EMUL_CONTINUE) {\n\t\tpr_warn_once(\"faulting far call emulation tainted memory\\n\");\n\t\tgoto fail;\n\t}\n\treturn rc;\nfail:\n\tops->set_segment(ctxt, old_cs, &old_desc, 0, VCPU_SREG_CS);\n\tctxt->mode = prev_mode;\n\treturn rc;\n\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ops->set_segment",
          "args": [
            "ctxt",
            "old_cs",
            "&old_desc",
            "0",
            "VCPU_SREG_CS"
          ],
          "line": 3412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn_once",
          "args": [
            "\"faulting far call emulation tainted memory\\n\""
          ],
          "line": 3407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "em_push",
          "args": [
            "ctxt"
          ],
          "line": 3403
        },
        "resolved": true,
        "details": {
          "function_name": "em_pushf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "1933-1937",
          "snippet": "static int em_pushf(struct x86_emulate_ctxt *ctxt)\n{\n\tctxt->src.val = (unsigned long)ctxt->eflags & ~X86_EFLAGS_VM;\n\treturn em_push(ctxt);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int em_pushf(struct x86_emulate_ctxt *ctxt)\n{\n\tctxt->src.val = (unsigned long)ctxt->eflags & ~X86_EFLAGS_VM;\n\treturn em_push(ctxt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assign_eip_far",
          "args": [
            "ctxt",
            "ctxt->src.val",
            "&new_desc"
          ],
          "line": 3393
        },
        "resolved": true,
        "details": {
          "function_name": "assign_eip_far",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "750-774",
          "snippet": "static int assign_eip_far(struct x86_emulate_ctxt *ctxt, ulong dst,\n\t\t\t  const struct desc_struct *cs_desc)\n{\n\tenum x86emul_mode mode = ctxt->mode;\n\tint rc;\n\n#ifdef CONFIG_X86_64\n\tif (ctxt->mode >= X86EMUL_MODE_PROT16) {\n\t\tif (cs_desc->l) {\n\t\t\tu64 efer = 0;\n\n\t\t\tctxt->ops->get_msr(ctxt, MSR_EFER, &efer);\n\t\t\tif (efer & EFER_LMA)\n\t\t\t\tmode = X86EMUL_MODE_PROT64;\n\t\t} else\n\t\t\tmode = X86EMUL_MODE_PROT32; /* temporary value */\n\t}\n#endif\n\tif (mode == X86EMUL_MODE_PROT16 || mode == X86EMUL_MODE_PROT32)\n\t\tmode = cs_desc->d ? X86EMUL_MODE_PROT32 : X86EMUL_MODE_PROT16;\n\trc = assign_eip(ctxt, dst, mode);\n\tif (rc == X86EMUL_CONTINUE)\n\t\tctxt->mode = mode;\n\treturn rc;\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int assign_eip_far(struct x86_emulate_ctxt *ctxt, ulong dst,\n\t\t\t  const struct desc_struct *cs_desc)\n{\n\tenum x86emul_mode mode = ctxt->mode;\n\tint rc;\n\n#ifdef CONFIG_X86_64\n\tif (ctxt->mode >= X86EMUL_MODE_PROT16) {\n\t\tif (cs_desc->l) {\n\t\t\tu64 efer = 0;\n\n\t\t\tctxt->ops->get_msr(ctxt, MSR_EFER, &efer);\n\t\t\tif (efer & EFER_LMA)\n\t\t\t\tmode = X86EMUL_MODE_PROT64;\n\t\t} else\n\t\t\tmode = X86EMUL_MODE_PROT32; /* temporary value */\n\t}\n#endif\n\tif (mode == X86EMUL_MODE_PROT16 || mode == X86EMUL_MODE_PROT32)\n\t\tmode = cs_desc->d ? X86EMUL_MODE_PROT32 : X86EMUL_MODE_PROT16;\n\trc = assign_eip(ctxt, dst, mode);\n\tif (rc == X86EMUL_CONTINUE)\n\t\tctxt->mode = mode;\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__load_segment_descriptor",
          "args": [
            "ctxt",
            "sel",
            "VCPU_SREG_CS",
            "cpl",
            "X86_TRANSFER_CALL_JMP",
            "&new_desc"
          ],
          "line": 3388
        },
        "resolved": true,
        "details": {
          "function_name": "__load_segment_descriptor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "1549-1708",
          "snippet": "static int __load_segment_descriptor(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t     u16 selector, int seg, u8 cpl,\n\t\t\t\t     enum x86_transfer_type transfer,\n\t\t\t\t     struct desc_struct *desc)\n{\n\tstruct desc_struct seg_desc, old_desc;\n\tu8 dpl, rpl;\n\tunsigned err_vec = GP_VECTOR;\n\tu32 err_code = 0;\n\tbool null_selector = !(selector & ~0x3); /* 0000-0003 are null */\n\tulong desc_addr;\n\tint ret;\n\tu16 dummy;\n\tu32 base3 = 0;\n\n\tmemset(&seg_desc, 0, sizeof seg_desc);\n\n\tif (ctxt->mode == X86EMUL_MODE_REAL) {\n\t\t/* set real mode segment descriptor (keep limit etc. for\n\t\t * unreal mode) */\n\t\tctxt->ops->get_segment(ctxt, &dummy, &seg_desc, NULL, seg);\n\t\tset_desc_base(&seg_desc, selector << 4);\n\t\tgoto load;\n\t} else if (seg <= VCPU_SREG_GS && ctxt->mode == X86EMUL_MODE_VM86) {\n\t\t/* VM86 needs a clean new segment descriptor */\n\t\tset_desc_base(&seg_desc, selector << 4);\n\t\tset_desc_limit(&seg_desc, 0xffff);\n\t\tseg_desc.type = 3;\n\t\tseg_desc.p = 1;\n\t\tseg_desc.s = 1;\n\t\tseg_desc.dpl = 3;\n\t\tgoto load;\n\t}\n\n\trpl = selector & 3;\n\n\t/* NULL selector is not valid for TR, CS and SS (except for long mode) */\n\tif ((seg == VCPU_SREG_CS\n\t     || (seg == VCPU_SREG_SS\n\t\t && (ctxt->mode != X86EMUL_MODE_PROT64 || rpl != cpl))\n\t     || seg == VCPU_SREG_TR)\n\t    && null_selector)\n\t\tgoto exception;\n\n\t/* TR should be in GDT only */\n\tif (seg == VCPU_SREG_TR && (selector & (1 << 2)))\n\t\tgoto exception;\n\n\tif (null_selector) /* for NULL selector skip all following checks */\n\t\tgoto load;\n\n\tret = read_segment_descriptor(ctxt, selector, &seg_desc, &desc_addr);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\n\terr_code = selector & 0xfffc;\n\terr_vec = (transfer == X86_TRANSFER_TASK_SWITCH) ? TS_VECTOR :\n\t\t\t\t\t\t\t   GP_VECTOR;\n\n\t/* can't load system descriptor into segment selector */\n\tif (seg <= VCPU_SREG_GS && !seg_desc.s) {\n\t\tif (transfer == X86_TRANSFER_CALL_JMP)\n\t\t\treturn X86EMUL_UNHANDLEABLE;\n\t\tgoto exception;\n\t}\n\n\tif (!seg_desc.p) {\n\t\terr_vec = (seg == VCPU_SREG_SS) ? SS_VECTOR : NP_VECTOR;\n\t\tgoto exception;\n\t}\n\n\tdpl = seg_desc.dpl;\n\n\tswitch (seg) {\n\tcase VCPU_SREG_SS:\n\t\t/*\n\t\t * segment is not a writable data segment or segment\n\t\t * selector's RPL != CPL or segment selector's RPL != CPL\n\t\t */\n\t\tif (rpl != cpl || (seg_desc.type & 0xa) != 0x2 || dpl != cpl)\n\t\t\tgoto exception;\n\t\tbreak;\n\tcase VCPU_SREG_CS:\n\t\tif (!(seg_desc.type & 8))\n\t\t\tgoto exception;\n\n\t\tif (seg_desc.type & 4) {\n\t\t\t/* conforming */\n\t\t\tif (dpl > cpl)\n\t\t\t\tgoto exception;\n\t\t} else {\n\t\t\t/* nonconforming */\n\t\t\tif (rpl > cpl || dpl != cpl)\n\t\t\t\tgoto exception;\n\t\t}\n\t\t/* in long-mode d/b must be clear if l is set */\n\t\tif (seg_desc.d && seg_desc.l) {\n\t\t\tu64 efer = 0;\n\n\t\t\tctxt->ops->get_msr(ctxt, MSR_EFER, &efer);\n\t\t\tif (efer & EFER_LMA)\n\t\t\t\tgoto exception;\n\t\t}\n\n\t\t/* CS(RPL) <- CPL */\n\t\tselector = (selector & 0xfffc) | cpl;\n\t\tbreak;\n\tcase VCPU_SREG_TR:\n\t\tif (seg_desc.s || (seg_desc.type != 1 && seg_desc.type != 9))\n\t\t\tgoto exception;\n\t\told_desc = seg_desc;\n\t\tseg_desc.type |= 2; /* busy */\n\t\tret = ctxt->ops->cmpxchg_emulated(ctxt, desc_addr, &old_desc, &seg_desc,\n\t\t\t\t\t\t  sizeof(seg_desc), &ctxt->exception);\n\t\tif (ret != X86EMUL_CONTINUE)\n\t\t\treturn ret;\n\t\tbreak;\n\tcase VCPU_SREG_LDTR:\n\t\tif (seg_desc.s || seg_desc.type != 2)\n\t\t\tgoto exception;\n\t\tbreak;\n\tdefault: /*  DS, ES, FS, or GS */\n\t\t/*\n\t\t * segment is not a data or readable code segment or\n\t\t * ((segment is a data or nonconforming code segment)\n\t\t * and (both RPL and CPL > DPL))\n\t\t */\n\t\tif ((seg_desc.type & 0xa) == 0x8 ||\n\t\t    (((seg_desc.type & 0xc) != 0xc) &&\n\t\t     (rpl > dpl && cpl > dpl)))\n\t\t\tgoto exception;\n\t\tbreak;\n\t}\n\n\tif (seg_desc.s) {\n\t\t/* mark segment as accessed */\n\t\tif (!(seg_desc.type & 1)) {\n\t\t\tseg_desc.type |= 1;\n\t\t\tret = write_segment_descriptor(ctxt, selector,\n\t\t\t\t\t\t       &seg_desc);\n\t\t\tif (ret != X86EMUL_CONTINUE)\n\t\t\t\treturn ret;\n\t\t}\n\t} else if (ctxt->mode == X86EMUL_MODE_PROT64) {\n\t\tret = ctxt->ops->read_std(ctxt, desc_addr+8, &base3,\n\t\t\t\tsizeof(base3), &ctxt->exception);\n\t\tif (ret != X86EMUL_CONTINUE)\n\t\t\treturn ret;\n\t\tif (is_noncanonical_address(get_desc_base(&seg_desc) |\n\t\t\t\t\t     ((u64)base3 << 32)))\n\t\t\treturn emulate_gp(ctxt, 0);\n\t}\nload:\n\tctxt->ops->set_segment(ctxt, selector, &seg_desc, base3, seg);\n\tif (desc)\n\t\t*desc = seg_desc;\n\treturn X86EMUL_CONTINUE;\nexception:\n\treturn emulate_exception(ctxt, err_vec, err_code, true);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int __load_segment_descriptor(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t     u16 selector, int seg, u8 cpl,\n\t\t\t\t     enum x86_transfer_type transfer,\n\t\t\t\t     struct desc_struct *desc)\n{\n\tstruct desc_struct seg_desc, old_desc;\n\tu8 dpl, rpl;\n\tunsigned err_vec = GP_VECTOR;\n\tu32 err_code = 0;\n\tbool null_selector = !(selector & ~0x3); /* 0000-0003 are null */\n\tulong desc_addr;\n\tint ret;\n\tu16 dummy;\n\tu32 base3 = 0;\n\n\tmemset(&seg_desc, 0, sizeof seg_desc);\n\n\tif (ctxt->mode == X86EMUL_MODE_REAL) {\n\t\t/* set real mode segment descriptor (keep limit etc. for\n\t\t * unreal mode) */\n\t\tctxt->ops->get_segment(ctxt, &dummy, &seg_desc, NULL, seg);\n\t\tset_desc_base(&seg_desc, selector << 4);\n\t\tgoto load;\n\t} else if (seg <= VCPU_SREG_GS && ctxt->mode == X86EMUL_MODE_VM86) {\n\t\t/* VM86 needs a clean new segment descriptor */\n\t\tset_desc_base(&seg_desc, selector << 4);\n\t\tset_desc_limit(&seg_desc, 0xffff);\n\t\tseg_desc.type = 3;\n\t\tseg_desc.p = 1;\n\t\tseg_desc.s = 1;\n\t\tseg_desc.dpl = 3;\n\t\tgoto load;\n\t}\n\n\trpl = selector & 3;\n\n\t/* NULL selector is not valid for TR, CS and SS (except for long mode) */\n\tif ((seg == VCPU_SREG_CS\n\t     || (seg == VCPU_SREG_SS\n\t\t && (ctxt->mode != X86EMUL_MODE_PROT64 || rpl != cpl))\n\t     || seg == VCPU_SREG_TR)\n\t    && null_selector)\n\t\tgoto exception;\n\n\t/* TR should be in GDT only */\n\tif (seg == VCPU_SREG_TR && (selector & (1 << 2)))\n\t\tgoto exception;\n\n\tif (null_selector) /* for NULL selector skip all following checks */\n\t\tgoto load;\n\n\tret = read_segment_descriptor(ctxt, selector, &seg_desc, &desc_addr);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\n\terr_code = selector & 0xfffc;\n\terr_vec = (transfer == X86_TRANSFER_TASK_SWITCH) ? TS_VECTOR :\n\t\t\t\t\t\t\t   GP_VECTOR;\n\n\t/* can't load system descriptor into segment selector */\n\tif (seg <= VCPU_SREG_GS && !seg_desc.s) {\n\t\tif (transfer == X86_TRANSFER_CALL_JMP)\n\t\t\treturn X86EMUL_UNHANDLEABLE;\n\t\tgoto exception;\n\t}\n\n\tif (!seg_desc.p) {\n\t\terr_vec = (seg == VCPU_SREG_SS) ? SS_VECTOR : NP_VECTOR;\n\t\tgoto exception;\n\t}\n\n\tdpl = seg_desc.dpl;\n\n\tswitch (seg) {\n\tcase VCPU_SREG_SS:\n\t\t/*\n\t\t * segment is not a writable data segment or segment\n\t\t * selector's RPL != CPL or segment selector's RPL != CPL\n\t\t */\n\t\tif (rpl != cpl || (seg_desc.type & 0xa) != 0x2 || dpl != cpl)\n\t\t\tgoto exception;\n\t\tbreak;\n\tcase VCPU_SREG_CS:\n\t\tif (!(seg_desc.type & 8))\n\t\t\tgoto exception;\n\n\t\tif (seg_desc.type & 4) {\n\t\t\t/* conforming */\n\t\t\tif (dpl > cpl)\n\t\t\t\tgoto exception;\n\t\t} else {\n\t\t\t/* nonconforming */\n\t\t\tif (rpl > cpl || dpl != cpl)\n\t\t\t\tgoto exception;\n\t\t}\n\t\t/* in long-mode d/b must be clear if l is set */\n\t\tif (seg_desc.d && seg_desc.l) {\n\t\t\tu64 efer = 0;\n\n\t\t\tctxt->ops->get_msr(ctxt, MSR_EFER, &efer);\n\t\t\tif (efer & EFER_LMA)\n\t\t\t\tgoto exception;\n\t\t}\n\n\t\t/* CS(RPL) <- CPL */\n\t\tselector = (selector & 0xfffc) | cpl;\n\t\tbreak;\n\tcase VCPU_SREG_TR:\n\t\tif (seg_desc.s || (seg_desc.type != 1 && seg_desc.type != 9))\n\t\t\tgoto exception;\n\t\told_desc = seg_desc;\n\t\tseg_desc.type |= 2; /* busy */\n\t\tret = ctxt->ops->cmpxchg_emulated(ctxt, desc_addr, &old_desc, &seg_desc,\n\t\t\t\t\t\t  sizeof(seg_desc), &ctxt->exception);\n\t\tif (ret != X86EMUL_CONTINUE)\n\t\t\treturn ret;\n\t\tbreak;\n\tcase VCPU_SREG_LDTR:\n\t\tif (seg_desc.s || seg_desc.type != 2)\n\t\t\tgoto exception;\n\t\tbreak;\n\tdefault: /*  DS, ES, FS, or GS */\n\t\t/*\n\t\t * segment is not a data or readable code segment or\n\t\t * ((segment is a data or nonconforming code segment)\n\t\t * and (both RPL and CPL > DPL))\n\t\t */\n\t\tif ((seg_desc.type & 0xa) == 0x8 ||\n\t\t    (((seg_desc.type & 0xc) != 0xc) &&\n\t\t     (rpl > dpl && cpl > dpl)))\n\t\t\tgoto exception;\n\t\tbreak;\n\t}\n\n\tif (seg_desc.s) {\n\t\t/* mark segment as accessed */\n\t\tif (!(seg_desc.type & 1)) {\n\t\t\tseg_desc.type |= 1;\n\t\t\tret = write_segment_descriptor(ctxt, selector,\n\t\t\t\t\t\t       &seg_desc);\n\t\t\tif (ret != X86EMUL_CONTINUE)\n\t\t\t\treturn ret;\n\t\t}\n\t} else if (ctxt->mode == X86EMUL_MODE_PROT64) {\n\t\tret = ctxt->ops->read_std(ctxt, desc_addr+8, &base3,\n\t\t\t\tsizeof(base3), &ctxt->exception);\n\t\tif (ret != X86EMUL_CONTINUE)\n\t\t\treturn ret;\n\t\tif (is_noncanonical_address(get_desc_base(&seg_desc) |\n\t\t\t\t\t     ((u64)base3 << 32)))\n\t\t\treturn emulate_gp(ctxt, 0);\n\t}\nload:\n\tctxt->ops->set_segment(ctxt, selector, &seg_desc, base3, seg);\n\tif (desc)\n\t\t*desc = seg_desc;\n\treturn X86EMUL_CONTINUE;\nexception:\n\treturn emulate_exception(ctxt, err_vec, err_code, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&sel",
            "ctxt->src.valptr + ctxt->op_bytes",
            "2"
          ],
          "line": 3387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ops->get_segment",
          "args": [
            "ctxt",
            "&old_cs",
            "&old_desc",
            "NULL",
            "VCPU_SREG_CS"
          ],
          "line": 3385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ctxt->ops->cpl",
          "args": [
            "ctxt"
          ],
          "line": 3381
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int em_call_far(struct x86_emulate_ctxt *ctxt)\n{\n\tu16 sel, old_cs;\n\tulong old_eip;\n\tint rc;\n\tstruct desc_struct old_desc, new_desc;\n\tconst struct x86_emulate_ops *ops = ctxt->ops;\n\tint cpl = ctxt->ops->cpl(ctxt);\n\tenum x86emul_mode prev_mode = ctxt->mode;\n\n\told_eip = ctxt->_eip;\n\tops->get_segment(ctxt, &old_cs, &old_desc, NULL, VCPU_SREG_CS);\n\n\tmemcpy(&sel, ctxt->src.valptr + ctxt->op_bytes, 2);\n\trc = __load_segment_descriptor(ctxt, sel, VCPU_SREG_CS, cpl,\n\t\t\t\t       X86_TRANSFER_CALL_JMP, &new_desc);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\trc = assign_eip_far(ctxt, ctxt->src.val, &new_desc);\n\tif (rc != X86EMUL_CONTINUE)\n\t\tgoto fail;\n\n\tctxt->src.val = old_cs;\n\trc = em_push(ctxt);\n\tif (rc != X86EMUL_CONTINUE)\n\t\tgoto fail;\n\n\tctxt->src.val = old_eip;\n\trc = em_push(ctxt);\n\t/* If we failed, we tainted the memory, but the very least we should\n\t   restore cs */\n\tif (rc != X86EMUL_CONTINUE) {\n\t\tpr_warn_once(\"faulting far call emulation tainted memory\\n\");\n\t\tgoto fail;\n\t}\n\treturn rc;\nfail:\n\tops->set_segment(ctxt, old_cs, &old_desc, 0, VCPU_SREG_CS);\n\tctxt->mode = prev_mode;\n\treturn rc;\n\n}"
  },
  {
    "function_name": "em_call",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "3362-3372",
    "snippet": "static int em_call(struct x86_emulate_ctxt *ctxt)\n{\n\tint rc;\n\tlong rel = ctxt->src.val;\n\n\tctxt->src.val = (unsigned long)ctxt->_eip;\n\trc = jmp_rel(ctxt, rel);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\treturn em_push(ctxt);\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "em_push",
          "args": [
            "ctxt"
          ],
          "line": 3371
        },
        "resolved": true,
        "details": {
          "function_name": "em_pushf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "1933-1937",
          "snippet": "static int em_pushf(struct x86_emulate_ctxt *ctxt)\n{\n\tctxt->src.val = (unsigned long)ctxt->eflags & ~X86_EFLAGS_VM;\n\treturn em_push(ctxt);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int em_pushf(struct x86_emulate_ctxt *ctxt)\n{\n\tctxt->src.val = (unsigned long)ctxt->eflags & ~X86_EFLAGS_VM;\n\treturn em_push(ctxt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jmp_rel",
          "args": [
            "ctxt",
            "rel"
          ],
          "line": 3368
        },
        "resolved": true,
        "details": {
          "function_name": "jmp_rel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "776-779",
          "snippet": "static inline int jmp_rel(struct x86_emulate_ctxt *ctxt, int rel)\n{\n\treturn assign_eip_near(ctxt, ctxt->_eip + rel);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline int jmp_rel(struct x86_emulate_ctxt *ctxt, int rel)\n{\n\treturn assign_eip_near(ctxt, ctxt->_eip + rel);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int em_call(struct x86_emulate_ctxt *ctxt)\n{\n\tint rc;\n\tlong rel = ctxt->src.val;\n\n\tctxt->src.val = (unsigned long)ctxt->_eip;\n\trc = jmp_rel(ctxt, rel);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\treturn em_push(ctxt);\n}"
  },
  {
    "function_name": "em_aad",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "3344-3360",
    "snippet": "static int em_aad(struct x86_emulate_ctxt *ctxt)\n{\n\tu8 al = ctxt->dst.val & 0xff;\n\tu8 ah = (ctxt->dst.val >> 8) & 0xff;\n\n\tal = (al + (ah * ctxt->src.val)) & 0xff;\n\n\tctxt->dst.val = (ctxt->dst.val & 0xffff0000) | al;\n\n\t/* Set PF, ZF, SF */\n\tctxt->src.type = OP_IMM;\n\tctxt->src.val = 0;\n\tctxt->src.bytes = 1;\n\tfastop(ctxt, em_or);\n\n\treturn X86EMUL_CONTINUE;\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int fastop(struct x86_emulate_ctxt *ctxt, void (*fop)(struct fastop *));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fastop",
          "args": [
            "ctxt",
            "em_or"
          ],
          "line": 3357
        },
        "resolved": true,
        "details": {
          "function_name": "fastop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "5111-5124",
          "snippet": "static int fastop(struct x86_emulate_ctxt *ctxt, void (*fop)(struct fastop *))\n{\n\tulong flags = (ctxt->eflags & EFLAGS_MASK) | X86_EFLAGS_IF;\n\tif (!(ctxt->d & ByteOp))\n\t\tfop += __ffs(ctxt->dst.bytes) * FASTOP_SIZE;\n\tasm(\"push %[flags]; popf; call *%[fastop]; pushf; pop %[flags]\\n\"\n\t    : \"+a\"(ctxt->dst.val), \"+d\"(ctxt->src.val), [flags]\"+D\"(flags),\n\t      [fastop]\"+S\"(fop)\n\t    : \"c\"(ctxt->src2.val));\n\tctxt->eflags = (ctxt->eflags & ~EFLAGS_MASK) | (flags & EFLAGS_MASK);\n\tif (!fop) /* exception is returned in fop variable */\n\t\treturn emulate_de(ctxt);\n\treturn X86EMUL_CONTINUE;\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define EFLAGS_MASK (X86_EFLAGS_OF|X86_EFLAGS_SF|X86_EFLAGS_ZF|X86_EFLAGS_AF|\\\n\t\t     X86_EFLAGS_PF|X86_EFLAGS_CF)",
            "#define FASTOP_SIZE 8",
            "#define ByteOp      (1<<0)\t/* 8-bit operands. */"
          ],
          "globals_used": [
            "static int fastop(struct x86_emulate_ctxt *ctxt, void (*fop)(struct fastop *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\n#define EFLAGS_MASK (X86_EFLAGS_OF|X86_EFLAGS_SF|X86_EFLAGS_ZF|X86_EFLAGS_AF|\\\n\t\t     X86_EFLAGS_PF|X86_EFLAGS_CF)\n#define FASTOP_SIZE 8\n#define ByteOp      (1<<0)\t/* 8-bit operands. */\n\nstatic int fastop(struct x86_emulate_ctxt *ctxt, void (*fop)(struct fastop *));\n\nstatic int fastop(struct x86_emulate_ctxt *ctxt, void (*fop)(struct fastop *))\n{\n\tulong flags = (ctxt->eflags & EFLAGS_MASK) | X86_EFLAGS_IF;\n\tif (!(ctxt->d & ByteOp))\n\t\tfop += __ffs(ctxt->dst.bytes) * FASTOP_SIZE;\n\tasm(\"push %[flags]; popf; call *%[fastop]; pushf; pop %[flags]\\n\"\n\t    : \"+a\"(ctxt->dst.val), \"+d\"(ctxt->src.val), [flags]\"+D\"(flags),\n\t      [fastop]\"+S\"(fop)\n\t    : \"c\"(ctxt->src2.val));\n\tctxt->eflags = (ctxt->eflags & ~EFLAGS_MASK) | (flags & EFLAGS_MASK);\n\tif (!fop) /* exception is returned in fop variable */\n\t\treturn emulate_de(ctxt);\n\treturn X86EMUL_CONTINUE;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int fastop(struct x86_emulate_ctxt *ctxt, void (*fop)(struct fastop *));\n\nstatic int em_aad(struct x86_emulate_ctxt *ctxt)\n{\n\tu8 al = ctxt->dst.val & 0xff;\n\tu8 ah = (ctxt->dst.val >> 8) & 0xff;\n\n\tal = (al + (ah * ctxt->src.val)) & 0xff;\n\n\tctxt->dst.val = (ctxt->dst.val & 0xffff0000) | al;\n\n\t/* Set PF, ZF, SF */\n\tctxt->src.type = OP_IMM;\n\tctxt->src.val = 0;\n\tctxt->src.bytes = 1;\n\tfastop(ctxt, em_or);\n\n\treturn X86EMUL_CONTINUE;\n}"
  },
  {
    "function_name": "em_aam",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "3322-3342",
    "snippet": "static int em_aam(struct x86_emulate_ctxt *ctxt)\n{\n\tu8 al, ah;\n\n\tif (ctxt->src.val == 0)\n\t\treturn emulate_de(ctxt);\n\n\tal = ctxt->dst.val & 0xff;\n\tah = al / ctxt->src.val;\n\tal %= ctxt->src.val;\n\n\tctxt->dst.val = (ctxt->dst.val & 0xffff0000) | al | (ah << 8);\n\n\t/* Set PF, ZF, SF */\n\tctxt->src.type = OP_IMM;\n\tctxt->src.val = 0;\n\tctxt->src.bytes = 1;\n\tfastop(ctxt, em_or);\n\n\treturn X86EMUL_CONTINUE;\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int fastop(struct x86_emulate_ctxt *ctxt, void (*fop)(struct fastop *));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fastop",
          "args": [
            "ctxt",
            "em_or"
          ],
          "line": 3339
        },
        "resolved": true,
        "details": {
          "function_name": "fastop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "5111-5124",
          "snippet": "static int fastop(struct x86_emulate_ctxt *ctxt, void (*fop)(struct fastop *))\n{\n\tulong flags = (ctxt->eflags & EFLAGS_MASK) | X86_EFLAGS_IF;\n\tif (!(ctxt->d & ByteOp))\n\t\tfop += __ffs(ctxt->dst.bytes) * FASTOP_SIZE;\n\tasm(\"push %[flags]; popf; call *%[fastop]; pushf; pop %[flags]\\n\"\n\t    : \"+a\"(ctxt->dst.val), \"+d\"(ctxt->src.val), [flags]\"+D\"(flags),\n\t      [fastop]\"+S\"(fop)\n\t    : \"c\"(ctxt->src2.val));\n\tctxt->eflags = (ctxt->eflags & ~EFLAGS_MASK) | (flags & EFLAGS_MASK);\n\tif (!fop) /* exception is returned in fop variable */\n\t\treturn emulate_de(ctxt);\n\treturn X86EMUL_CONTINUE;\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define EFLAGS_MASK (X86_EFLAGS_OF|X86_EFLAGS_SF|X86_EFLAGS_ZF|X86_EFLAGS_AF|\\\n\t\t     X86_EFLAGS_PF|X86_EFLAGS_CF)",
            "#define FASTOP_SIZE 8",
            "#define ByteOp      (1<<0)\t/* 8-bit operands. */"
          ],
          "globals_used": [
            "static int fastop(struct x86_emulate_ctxt *ctxt, void (*fop)(struct fastop *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\n#define EFLAGS_MASK (X86_EFLAGS_OF|X86_EFLAGS_SF|X86_EFLAGS_ZF|X86_EFLAGS_AF|\\\n\t\t     X86_EFLAGS_PF|X86_EFLAGS_CF)\n#define FASTOP_SIZE 8\n#define ByteOp      (1<<0)\t/* 8-bit operands. */\n\nstatic int fastop(struct x86_emulate_ctxt *ctxt, void (*fop)(struct fastop *));\n\nstatic int fastop(struct x86_emulate_ctxt *ctxt, void (*fop)(struct fastop *))\n{\n\tulong flags = (ctxt->eflags & EFLAGS_MASK) | X86_EFLAGS_IF;\n\tif (!(ctxt->d & ByteOp))\n\t\tfop += __ffs(ctxt->dst.bytes) * FASTOP_SIZE;\n\tasm(\"push %[flags]; popf; call *%[fastop]; pushf; pop %[flags]\\n\"\n\t    : \"+a\"(ctxt->dst.val), \"+d\"(ctxt->src.val), [flags]\"+D\"(flags),\n\t      [fastop]\"+S\"(fop)\n\t    : \"c\"(ctxt->src2.val));\n\tctxt->eflags = (ctxt->eflags & ~EFLAGS_MASK) | (flags & EFLAGS_MASK);\n\tif (!fop) /* exception is returned in fop variable */\n\t\treturn emulate_de(ctxt);\n\treturn X86EMUL_CONTINUE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "emulate_de",
          "args": [
            "ctxt"
          ],
          "line": 3327
        },
        "resolved": true,
        "details": {
          "function_name": "emulate_de",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "600-603",
          "snippet": "static int emulate_de(struct x86_emulate_ctxt *ctxt)\n{\n\treturn emulate_exception(ctxt, DE_VECTOR, 0, false);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int emulate_de(struct x86_emulate_ctxt *ctxt)\n{\n\treturn emulate_exception(ctxt, DE_VECTOR, 0, false);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int fastop(struct x86_emulate_ctxt *ctxt, void (*fop)(struct fastop *));\n\nstatic int em_aam(struct x86_emulate_ctxt *ctxt)\n{\n\tu8 al, ah;\n\n\tif (ctxt->src.val == 0)\n\t\treturn emulate_de(ctxt);\n\n\tal = ctxt->dst.val & 0xff;\n\tah = al / ctxt->src.val;\n\tal %= ctxt->src.val;\n\n\tctxt->dst.val = (ctxt->dst.val & 0xffff0000) | al | (ah << 8);\n\n\t/* Set PF, ZF, SF */\n\tctxt->src.type = OP_IMM;\n\tctxt->src.val = 0;\n\tctxt->src.bytes = 1;\n\tfastop(ctxt, em_or);\n\n\treturn X86EMUL_CONTINUE;\n}"
  },
  {
    "function_name": "em_das",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "3284-3320",
    "snippet": "static int em_das(struct x86_emulate_ctxt *ctxt)\n{\n\tu8 al, old_al;\n\tbool af, cf, old_cf;\n\n\tcf = ctxt->eflags & X86_EFLAGS_CF;\n\tal = ctxt->dst.val;\n\n\told_al = al;\n\told_cf = cf;\n\tcf = false;\n\taf = ctxt->eflags & X86_EFLAGS_AF;\n\tif ((al & 0x0f) > 9 || af) {\n\t\tal -= 6;\n\t\tcf = old_cf | (al >= 250);\n\t\taf = true;\n\t} else {\n\t\taf = false;\n\t}\n\tif (old_al > 0x99 || old_cf) {\n\t\tal -= 0x60;\n\t\tcf = true;\n\t}\n\n\tctxt->dst.val = al;\n\t/* Set PF, ZF, SF */\n\tctxt->src.type = OP_IMM;\n\tctxt->src.val = 0;\n\tctxt->src.bytes = 1;\n\tfastop(ctxt, em_or);\n\tctxt->eflags &= ~(X86_EFLAGS_AF | X86_EFLAGS_CF);\n\tif (cf)\n\t\tctxt->eflags |= X86_EFLAGS_CF;\n\tif (af)\n\t\tctxt->eflags |= X86_EFLAGS_AF;\n\treturn X86EMUL_CONTINUE;\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int fastop(struct x86_emulate_ctxt *ctxt, void (*fop)(struct fastop *));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fastop",
          "args": [
            "ctxt",
            "em_or"
          ],
          "line": 3313
        },
        "resolved": true,
        "details": {
          "function_name": "fastop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "5111-5124",
          "snippet": "static int fastop(struct x86_emulate_ctxt *ctxt, void (*fop)(struct fastop *))\n{\n\tulong flags = (ctxt->eflags & EFLAGS_MASK) | X86_EFLAGS_IF;\n\tif (!(ctxt->d & ByteOp))\n\t\tfop += __ffs(ctxt->dst.bytes) * FASTOP_SIZE;\n\tasm(\"push %[flags]; popf; call *%[fastop]; pushf; pop %[flags]\\n\"\n\t    : \"+a\"(ctxt->dst.val), \"+d\"(ctxt->src.val), [flags]\"+D\"(flags),\n\t      [fastop]\"+S\"(fop)\n\t    : \"c\"(ctxt->src2.val));\n\tctxt->eflags = (ctxt->eflags & ~EFLAGS_MASK) | (flags & EFLAGS_MASK);\n\tif (!fop) /* exception is returned in fop variable */\n\t\treturn emulate_de(ctxt);\n\treturn X86EMUL_CONTINUE;\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define EFLAGS_MASK (X86_EFLAGS_OF|X86_EFLAGS_SF|X86_EFLAGS_ZF|X86_EFLAGS_AF|\\\n\t\t     X86_EFLAGS_PF|X86_EFLAGS_CF)",
            "#define FASTOP_SIZE 8",
            "#define ByteOp      (1<<0)\t/* 8-bit operands. */"
          ],
          "globals_used": [
            "static int fastop(struct x86_emulate_ctxt *ctxt, void (*fop)(struct fastop *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\n#define EFLAGS_MASK (X86_EFLAGS_OF|X86_EFLAGS_SF|X86_EFLAGS_ZF|X86_EFLAGS_AF|\\\n\t\t     X86_EFLAGS_PF|X86_EFLAGS_CF)\n#define FASTOP_SIZE 8\n#define ByteOp      (1<<0)\t/* 8-bit operands. */\n\nstatic int fastop(struct x86_emulate_ctxt *ctxt, void (*fop)(struct fastop *));\n\nstatic int fastop(struct x86_emulate_ctxt *ctxt, void (*fop)(struct fastop *))\n{\n\tulong flags = (ctxt->eflags & EFLAGS_MASK) | X86_EFLAGS_IF;\n\tif (!(ctxt->d & ByteOp))\n\t\tfop += __ffs(ctxt->dst.bytes) * FASTOP_SIZE;\n\tasm(\"push %[flags]; popf; call *%[fastop]; pushf; pop %[flags]\\n\"\n\t    : \"+a\"(ctxt->dst.val), \"+d\"(ctxt->src.val), [flags]\"+D\"(flags),\n\t      [fastop]\"+S\"(fop)\n\t    : \"c\"(ctxt->src2.val));\n\tctxt->eflags = (ctxt->eflags & ~EFLAGS_MASK) | (flags & EFLAGS_MASK);\n\tif (!fop) /* exception is returned in fop variable */\n\t\treturn emulate_de(ctxt);\n\treturn X86EMUL_CONTINUE;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int fastop(struct x86_emulate_ctxt *ctxt, void (*fop)(struct fastop *));\n\nstatic int em_das(struct x86_emulate_ctxt *ctxt)\n{\n\tu8 al, old_al;\n\tbool af, cf, old_cf;\n\n\tcf = ctxt->eflags & X86_EFLAGS_CF;\n\tal = ctxt->dst.val;\n\n\told_al = al;\n\told_cf = cf;\n\tcf = false;\n\taf = ctxt->eflags & X86_EFLAGS_AF;\n\tif ((al & 0x0f) > 9 || af) {\n\t\tal -= 6;\n\t\tcf = old_cf | (al >= 250);\n\t\taf = true;\n\t} else {\n\t\taf = false;\n\t}\n\tif (old_al > 0x99 || old_cf) {\n\t\tal -= 0x60;\n\t\tcf = true;\n\t}\n\n\tctxt->dst.val = al;\n\t/* Set PF, ZF, SF */\n\tctxt->src.type = OP_IMM;\n\tctxt->src.val = 0;\n\tctxt->src.bytes = 1;\n\tfastop(ctxt, em_or);\n\tctxt->eflags &= ~(X86_EFLAGS_AF | X86_EFLAGS_CF);\n\tif (cf)\n\t\tctxt->eflags |= X86_EFLAGS_CF;\n\tif (af)\n\t\tctxt->eflags |= X86_EFLAGS_AF;\n\treturn X86EMUL_CONTINUE;\n}"
  },
  {
    "function_name": "string_addr_inc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "3275-3282",
    "snippet": "static void string_addr_inc(struct x86_emulate_ctxt *ctxt, int reg,\n\t\tstruct operand *op)\n{\n\tint df = (ctxt->eflags & X86_EFLAGS_DF) ? -op->count : op->count;\n\n\tregister_address_increment(ctxt, reg, df * op->bytes);\n\top->addr.mem.ea = register_address(ctxt, reg);\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "register_address",
          "args": [
            "ctxt",
            "reg"
          ],
          "line": 3281
        },
        "resolved": true,
        "details": {
          "function_name": "register_address",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "526-530",
          "snippet": "static inline unsigned long\nregister_address(struct x86_emulate_ctxt *ctxt, int reg)\n{\n\treturn address_mask(ctxt, reg_read(ctxt, reg));\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline unsigned long\nregister_address(struct x86_emulate_ctxt *ctxt, int reg)\n{\n\treturn address_mask(ctxt, reg_read(ctxt, reg));\n}"
        }
      },
      {
        "call_info": {
          "callee": "register_address_increment",
          "args": [
            "ctxt",
            "reg",
            "df * op->bytes"
          ],
          "line": 3280
        },
        "resolved": true,
        "details": {
          "function_name": "register_address_increment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "537-543",
          "snippet": "static inline void\nregister_address_increment(struct x86_emulate_ctxt *ctxt, int reg, int inc)\n{\n\tulong *preg = reg_rmw(ctxt, reg);\n\n\tassign_register(preg, *preg + inc, ctxt->ad_bytes);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline void\nregister_address_increment(struct x86_emulate_ctxt *ctxt, int reg, int inc)\n{\n\tulong *preg = reg_rmw(ctxt, reg);\n\n\tassign_register(preg, *preg + inc, ctxt->ad_bytes);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic void string_addr_inc(struct x86_emulate_ctxt *ctxt, int reg,\n\t\tstruct operand *op)\n{\n\tint df = (ctxt->eflags & X86_EFLAGS_DF) ? -op->count : op->count;\n\n\tregister_address_increment(ctxt, reg, df * op->bytes);\n\top->addr.mem.ea = register_address(ctxt, reg);\n}"
  },
  {
    "function_name": "emulator_task_switch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "3254-3273",
    "snippet": "int emulator_task_switch(struct x86_emulate_ctxt *ctxt,\n\t\t\t u16 tss_selector, int idt_index, int reason,\n\t\t\t bool has_error_code, u32 error_code)\n{\n\tint rc;\n\n\tinvalidate_registers(ctxt);\n\tctxt->_eip = ctxt->eip;\n\tctxt->dst.type = OP_NONE;\n\n\trc = emulator_do_task_switch(ctxt, tss_selector, idt_index, reason,\n\t\t\t\t     has_error_code, error_code);\n\n\tif (rc == X86EMUL_CONTINUE) {\n\t\tctxt->eip = ctxt->_eip;\n\t\twriteback_registers(ctxt);\n\t}\n\n\treturn (rc == X86EMUL_UNHANDLEABLE) ? EMULATION_FAILED : EMULATION_OK;\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "writeback_registers",
          "args": [
            "ctxt"
          ],
          "line": 3269
        },
        "resolved": true,
        "details": {
          "function_name": "writeback_registers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "283-289",
          "snippet": "static void writeback_registers(struct x86_emulate_ctxt *ctxt)\n{\n\tunsigned reg;\n\n\tfor_each_set_bit(reg, (ulong *)&ctxt->regs_dirty, 16)\n\t\tctxt->ops->write_gpr(ctxt, reg, ctxt->_regs[reg]);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic void writeback_registers(struct x86_emulate_ctxt *ctxt)\n{\n\tunsigned reg;\n\n\tfor_each_set_bit(reg, (ulong *)&ctxt->regs_dirty, 16)\n\t\tctxt->ops->write_gpr(ctxt, reg, ctxt->_regs[reg]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "emulator_do_task_switch",
          "args": [
            "ctxt",
            "tss_selector",
            "idt_index",
            "reason",
            "has_error_code",
            "error_code"
          ],
          "line": 3264
        },
        "resolved": true,
        "details": {
          "function_name": "emulator_do_task_switch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "3152-3252",
          "snippet": "static int emulator_do_task_switch(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t   u16 tss_selector, int idt_index, int reason,\n\t\t\t\t   bool has_error_code, u32 error_code)\n{\n\tconst struct x86_emulate_ops *ops = ctxt->ops;\n\tstruct desc_struct curr_tss_desc, next_tss_desc;\n\tint ret;\n\tu16 old_tss_sel = get_segment_selector(ctxt, VCPU_SREG_TR);\n\tulong old_tss_base =\n\t\tops->get_cached_segment_base(ctxt, VCPU_SREG_TR);\n\tu32 desc_limit;\n\tulong desc_addr, dr7;\n\n\t/* FIXME: old_tss_base == ~0 ? */\n\n\tret = read_segment_descriptor(ctxt, tss_selector, &next_tss_desc, &desc_addr);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\tret = read_segment_descriptor(ctxt, old_tss_sel, &curr_tss_desc, &desc_addr);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\n\t/* FIXME: check that next_tss_desc is tss */\n\n\t/*\n\t * Check privileges. The three cases are task switch caused by...\n\t *\n\t * 1. jmp/call/int to task gate: Check against DPL of the task gate\n\t * 2. Exception/IRQ/iret: No check is performed\n\t * 3. jmp/call to TSS/task-gate: No check is performed since the\n\t *    hardware checks it before exiting.\n\t */\n\tif (reason == TASK_SWITCH_GATE) {\n\t\tif (idt_index != -1) {\n\t\t\t/* Software interrupts */\n\t\t\tstruct desc_struct task_gate_desc;\n\t\t\tint dpl;\n\n\t\t\tret = read_interrupt_descriptor(ctxt, idt_index,\n\t\t\t\t\t\t\t&task_gate_desc);\n\t\t\tif (ret != X86EMUL_CONTINUE)\n\t\t\t\treturn ret;\n\n\t\t\tdpl = task_gate_desc.dpl;\n\t\t\tif ((tss_selector & 3) > dpl || ops->cpl(ctxt) > dpl)\n\t\t\t\treturn emulate_gp(ctxt, (idt_index << 3) | 0x2);\n\t\t}\n\t}\n\n\tdesc_limit = desc_limit_scaled(&next_tss_desc);\n\tif (!next_tss_desc.p ||\n\t    ((desc_limit < 0x67 && (next_tss_desc.type & 8)) ||\n\t     desc_limit < 0x2b)) {\n\t\treturn emulate_ts(ctxt, tss_selector & 0xfffc);\n\t}\n\n\tif (reason == TASK_SWITCH_IRET || reason == TASK_SWITCH_JMP) {\n\t\tcurr_tss_desc.type &= ~(1 << 1); /* clear busy flag */\n\t\twrite_segment_descriptor(ctxt, old_tss_sel, &curr_tss_desc);\n\t}\n\n\tif (reason == TASK_SWITCH_IRET)\n\t\tctxt->eflags = ctxt->eflags & ~X86_EFLAGS_NT;\n\n\t/* set back link to prev task only if NT bit is set in eflags\n\t   note that old_tss_sel is not used after this point */\n\tif (reason != TASK_SWITCH_CALL && reason != TASK_SWITCH_GATE)\n\t\told_tss_sel = 0xffff;\n\n\tif (next_tss_desc.type & 8)\n\t\tret = task_switch_32(ctxt, tss_selector, old_tss_sel,\n\t\t\t\t     old_tss_base, &next_tss_desc);\n\telse\n\t\tret = task_switch_16(ctxt, tss_selector, old_tss_sel,\n\t\t\t\t     old_tss_base, &next_tss_desc);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\n\tif (reason == TASK_SWITCH_CALL || reason == TASK_SWITCH_GATE)\n\t\tctxt->eflags = ctxt->eflags | X86_EFLAGS_NT;\n\n\tif (reason != TASK_SWITCH_IRET) {\n\t\tnext_tss_desc.type |= (1 << 1); /* set busy flag */\n\t\twrite_segment_descriptor(ctxt, tss_selector, &next_tss_desc);\n\t}\n\n\tops->set_cr(ctxt, 0,  ops->get_cr(ctxt, 0) | X86_CR0_TS);\n\tops->set_segment(ctxt, tss_selector, &next_tss_desc, 0, VCPU_SREG_TR);\n\n\tif (has_error_code) {\n\t\tctxt->op_bytes = ctxt->ad_bytes = (next_tss_desc.type & 8) ? 4 : 2;\n\t\tctxt->lock_prefix = 0;\n\t\tctxt->src.val = (unsigned long) error_code;\n\t\tret = em_push(ctxt);\n\t}\n\n\tops->get_dr(ctxt, 7, &dr7);\n\tops->set_dr(ctxt, 7, dr7 & ~(DR_LOCAL_ENABLE_MASK | DR_LOCAL_SLOWDOWN));\n\n\treturn ret;\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int emulator_do_task_switch(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t   u16 tss_selector, int idt_index, int reason,\n\t\t\t\t   bool has_error_code, u32 error_code)\n{\n\tconst struct x86_emulate_ops *ops = ctxt->ops;\n\tstruct desc_struct curr_tss_desc, next_tss_desc;\n\tint ret;\n\tu16 old_tss_sel = get_segment_selector(ctxt, VCPU_SREG_TR);\n\tulong old_tss_base =\n\t\tops->get_cached_segment_base(ctxt, VCPU_SREG_TR);\n\tu32 desc_limit;\n\tulong desc_addr, dr7;\n\n\t/* FIXME: old_tss_base == ~0 ? */\n\n\tret = read_segment_descriptor(ctxt, tss_selector, &next_tss_desc, &desc_addr);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\tret = read_segment_descriptor(ctxt, old_tss_sel, &curr_tss_desc, &desc_addr);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\n\t/* FIXME: check that next_tss_desc is tss */\n\n\t/*\n\t * Check privileges. The three cases are task switch caused by...\n\t *\n\t * 1. jmp/call/int to task gate: Check against DPL of the task gate\n\t * 2. Exception/IRQ/iret: No check is performed\n\t * 3. jmp/call to TSS/task-gate: No check is performed since the\n\t *    hardware checks it before exiting.\n\t */\n\tif (reason == TASK_SWITCH_GATE) {\n\t\tif (idt_index != -1) {\n\t\t\t/* Software interrupts */\n\t\t\tstruct desc_struct task_gate_desc;\n\t\t\tint dpl;\n\n\t\t\tret = read_interrupt_descriptor(ctxt, idt_index,\n\t\t\t\t\t\t\t&task_gate_desc);\n\t\t\tif (ret != X86EMUL_CONTINUE)\n\t\t\t\treturn ret;\n\n\t\t\tdpl = task_gate_desc.dpl;\n\t\t\tif ((tss_selector & 3) > dpl || ops->cpl(ctxt) > dpl)\n\t\t\t\treturn emulate_gp(ctxt, (idt_index << 3) | 0x2);\n\t\t}\n\t}\n\n\tdesc_limit = desc_limit_scaled(&next_tss_desc);\n\tif (!next_tss_desc.p ||\n\t    ((desc_limit < 0x67 && (next_tss_desc.type & 8)) ||\n\t     desc_limit < 0x2b)) {\n\t\treturn emulate_ts(ctxt, tss_selector & 0xfffc);\n\t}\n\n\tif (reason == TASK_SWITCH_IRET || reason == TASK_SWITCH_JMP) {\n\t\tcurr_tss_desc.type &= ~(1 << 1); /* clear busy flag */\n\t\twrite_segment_descriptor(ctxt, old_tss_sel, &curr_tss_desc);\n\t}\n\n\tif (reason == TASK_SWITCH_IRET)\n\t\tctxt->eflags = ctxt->eflags & ~X86_EFLAGS_NT;\n\n\t/* set back link to prev task only if NT bit is set in eflags\n\t   note that old_tss_sel is not used after this point */\n\tif (reason != TASK_SWITCH_CALL && reason != TASK_SWITCH_GATE)\n\t\told_tss_sel = 0xffff;\n\n\tif (next_tss_desc.type & 8)\n\t\tret = task_switch_32(ctxt, tss_selector, old_tss_sel,\n\t\t\t\t     old_tss_base, &next_tss_desc);\n\telse\n\t\tret = task_switch_16(ctxt, tss_selector, old_tss_sel,\n\t\t\t\t     old_tss_base, &next_tss_desc);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\n\tif (reason == TASK_SWITCH_CALL || reason == TASK_SWITCH_GATE)\n\t\tctxt->eflags = ctxt->eflags | X86_EFLAGS_NT;\n\n\tif (reason != TASK_SWITCH_IRET) {\n\t\tnext_tss_desc.type |= (1 << 1); /* set busy flag */\n\t\twrite_segment_descriptor(ctxt, tss_selector, &next_tss_desc);\n\t}\n\n\tops->set_cr(ctxt, 0,  ops->get_cr(ctxt, 0) | X86_CR0_TS);\n\tops->set_segment(ctxt, tss_selector, &next_tss_desc, 0, VCPU_SREG_TR);\n\n\tif (has_error_code) {\n\t\tctxt->op_bytes = ctxt->ad_bytes = (next_tss_desc.type & 8) ? 4 : 2;\n\t\tctxt->lock_prefix = 0;\n\t\tctxt->src.val = (unsigned long) error_code;\n\t\tret = em_push(ctxt);\n\t}\n\n\tops->get_dr(ctxt, 7, &dr7);\n\tops->set_dr(ctxt, 7, dr7 & ~(DR_LOCAL_ENABLE_MASK | DR_LOCAL_SLOWDOWN));\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "invalidate_registers",
          "args": [
            "ctxt"
          ],
          "line": 3260
        },
        "resolved": true,
        "details": {
          "function_name": "invalidate_registers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "291-295",
          "snippet": "static void invalidate_registers(struct x86_emulate_ctxt *ctxt)\n{\n\tctxt->regs_dirty = 0;\n\tctxt->regs_valid = 0;\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic void invalidate_registers(struct x86_emulate_ctxt *ctxt)\n{\n\tctxt->regs_dirty = 0;\n\tctxt->regs_valid = 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nint emulator_task_switch(struct x86_emulate_ctxt *ctxt,\n\t\t\t u16 tss_selector, int idt_index, int reason,\n\t\t\t bool has_error_code, u32 error_code)\n{\n\tint rc;\n\n\tinvalidate_registers(ctxt);\n\tctxt->_eip = ctxt->eip;\n\tctxt->dst.type = OP_NONE;\n\n\trc = emulator_do_task_switch(ctxt, tss_selector, idt_index, reason,\n\t\t\t\t     has_error_code, error_code);\n\n\tif (rc == X86EMUL_CONTINUE) {\n\t\tctxt->eip = ctxt->_eip;\n\t\twriteback_registers(ctxt);\n\t}\n\n\treturn (rc == X86EMUL_UNHANDLEABLE) ? EMULATION_FAILED : EMULATION_OK;\n}"
  },
  {
    "function_name": "emulator_do_task_switch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "3152-3252",
    "snippet": "static int emulator_do_task_switch(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t   u16 tss_selector, int idt_index, int reason,\n\t\t\t\t   bool has_error_code, u32 error_code)\n{\n\tconst struct x86_emulate_ops *ops = ctxt->ops;\n\tstruct desc_struct curr_tss_desc, next_tss_desc;\n\tint ret;\n\tu16 old_tss_sel = get_segment_selector(ctxt, VCPU_SREG_TR);\n\tulong old_tss_base =\n\t\tops->get_cached_segment_base(ctxt, VCPU_SREG_TR);\n\tu32 desc_limit;\n\tulong desc_addr, dr7;\n\n\t/* FIXME: old_tss_base == ~0 ? */\n\n\tret = read_segment_descriptor(ctxt, tss_selector, &next_tss_desc, &desc_addr);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\tret = read_segment_descriptor(ctxt, old_tss_sel, &curr_tss_desc, &desc_addr);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\n\t/* FIXME: check that next_tss_desc is tss */\n\n\t/*\n\t * Check privileges. The three cases are task switch caused by...\n\t *\n\t * 1. jmp/call/int to task gate: Check against DPL of the task gate\n\t * 2. Exception/IRQ/iret: No check is performed\n\t * 3. jmp/call to TSS/task-gate: No check is performed since the\n\t *    hardware checks it before exiting.\n\t */\n\tif (reason == TASK_SWITCH_GATE) {\n\t\tif (idt_index != -1) {\n\t\t\t/* Software interrupts */\n\t\t\tstruct desc_struct task_gate_desc;\n\t\t\tint dpl;\n\n\t\t\tret = read_interrupt_descriptor(ctxt, idt_index,\n\t\t\t\t\t\t\t&task_gate_desc);\n\t\t\tif (ret != X86EMUL_CONTINUE)\n\t\t\t\treturn ret;\n\n\t\t\tdpl = task_gate_desc.dpl;\n\t\t\tif ((tss_selector & 3) > dpl || ops->cpl(ctxt) > dpl)\n\t\t\t\treturn emulate_gp(ctxt, (idt_index << 3) | 0x2);\n\t\t}\n\t}\n\n\tdesc_limit = desc_limit_scaled(&next_tss_desc);\n\tif (!next_tss_desc.p ||\n\t    ((desc_limit < 0x67 && (next_tss_desc.type & 8)) ||\n\t     desc_limit < 0x2b)) {\n\t\treturn emulate_ts(ctxt, tss_selector & 0xfffc);\n\t}\n\n\tif (reason == TASK_SWITCH_IRET || reason == TASK_SWITCH_JMP) {\n\t\tcurr_tss_desc.type &= ~(1 << 1); /* clear busy flag */\n\t\twrite_segment_descriptor(ctxt, old_tss_sel, &curr_tss_desc);\n\t}\n\n\tif (reason == TASK_SWITCH_IRET)\n\t\tctxt->eflags = ctxt->eflags & ~X86_EFLAGS_NT;\n\n\t/* set back link to prev task only if NT bit is set in eflags\n\t   note that old_tss_sel is not used after this point */\n\tif (reason != TASK_SWITCH_CALL && reason != TASK_SWITCH_GATE)\n\t\told_tss_sel = 0xffff;\n\n\tif (next_tss_desc.type & 8)\n\t\tret = task_switch_32(ctxt, tss_selector, old_tss_sel,\n\t\t\t\t     old_tss_base, &next_tss_desc);\n\telse\n\t\tret = task_switch_16(ctxt, tss_selector, old_tss_sel,\n\t\t\t\t     old_tss_base, &next_tss_desc);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\n\tif (reason == TASK_SWITCH_CALL || reason == TASK_SWITCH_GATE)\n\t\tctxt->eflags = ctxt->eflags | X86_EFLAGS_NT;\n\n\tif (reason != TASK_SWITCH_IRET) {\n\t\tnext_tss_desc.type |= (1 << 1); /* set busy flag */\n\t\twrite_segment_descriptor(ctxt, tss_selector, &next_tss_desc);\n\t}\n\n\tops->set_cr(ctxt, 0,  ops->get_cr(ctxt, 0) | X86_CR0_TS);\n\tops->set_segment(ctxt, tss_selector, &next_tss_desc, 0, VCPU_SREG_TR);\n\n\tif (has_error_code) {\n\t\tctxt->op_bytes = ctxt->ad_bytes = (next_tss_desc.type & 8) ? 4 : 2;\n\t\tctxt->lock_prefix = 0;\n\t\tctxt->src.val = (unsigned long) error_code;\n\t\tret = em_push(ctxt);\n\t}\n\n\tops->get_dr(ctxt, 7, &dr7);\n\tops->set_dr(ctxt, 7, dr7 & ~(DR_LOCAL_ENABLE_MASK | DR_LOCAL_SLOWDOWN));\n\n\treturn ret;\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ops->set_dr",
          "args": [
            "ctxt",
            "7",
            "dr7 & ~(DR_LOCAL_ENABLE_MASK | DR_LOCAL_SLOWDOWN)"
          ],
          "line": 3249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ops->get_dr",
          "args": [
            "ctxt",
            "7",
            "&dr7"
          ],
          "line": 3248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "em_push",
          "args": [
            "ctxt"
          ],
          "line": 3245
        },
        "resolved": true,
        "details": {
          "function_name": "em_pushf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "1933-1937",
          "snippet": "static int em_pushf(struct x86_emulate_ctxt *ctxt)\n{\n\tctxt->src.val = (unsigned long)ctxt->eflags & ~X86_EFLAGS_VM;\n\treturn em_push(ctxt);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int em_pushf(struct x86_emulate_ctxt *ctxt)\n{\n\tctxt->src.val = (unsigned long)ctxt->eflags & ~X86_EFLAGS_VM;\n\treturn em_push(ctxt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ops->set_segment",
          "args": [
            "ctxt",
            "tss_selector",
            "&next_tss_desc",
            "0",
            "VCPU_SREG_TR"
          ],
          "line": 3239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ops->set_cr",
          "args": [
            "ctxt",
            "0",
            "ops->get_cr(ctxt, 0) | X86_CR0_TS"
          ],
          "line": 3238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ops->get_cr",
          "args": [
            "ctxt",
            "0"
          ],
          "line": 3238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_segment_descriptor",
          "args": [
            "ctxt",
            "tss_selector",
            "&next_tss_desc"
          ],
          "line": 3235
        },
        "resolved": true,
        "details": {
          "function_name": "write_segment_descriptor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "1534-1546",
          "snippet": "static int write_segment_descriptor(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t    u16 selector, struct desc_struct *desc)\n{\n\tint rc;\n\tulong addr;\n\n\trc = get_descriptor_ptr(ctxt, selector, &addr);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\treturn ctxt->ops->write_std(ctxt, addr, desc, sizeof *desc,\n\t\t\t\t    &ctxt->exception);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int write_segment_descriptor(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t    u16 selector, struct desc_struct *desc)\n{\n\tint rc;\n\tulong addr;\n\n\trc = get_descriptor_ptr(ctxt, selector, &addr);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\treturn ctxt->ops->write_std(ctxt, addr, desc, sizeof *desc,\n\t\t\t\t    &ctxt->exception);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_switch_16",
          "args": [
            "ctxt",
            "tss_selector",
            "old_tss_sel",
            "old_tss_base",
            "&next_tss_desc"
          ],
          "line": 3225
        },
        "resolved": true,
        "details": {
          "function_name": "task_switch_16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "2965-3003",
          "snippet": "static int task_switch_16(struct x86_emulate_ctxt *ctxt,\n\t\t\t  u16 tss_selector, u16 old_tss_sel,\n\t\t\t  ulong old_tss_base, struct desc_struct *new_desc)\n{\n\tconst struct x86_emulate_ops *ops = ctxt->ops;\n\tstruct tss_segment_16 tss_seg;\n\tint ret;\n\tu32 new_tss_base = get_desc_base(new_desc);\n\n\tret = ops->read_std(ctxt, old_tss_base, &tss_seg, sizeof tss_seg,\n\t\t\t    &ctxt->exception);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\n\tsave_state_to_tss16(ctxt, &tss_seg);\n\n\tret = ops->write_std(ctxt, old_tss_base, &tss_seg, sizeof tss_seg,\n\t\t\t     &ctxt->exception);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\n\tret = ops->read_std(ctxt, new_tss_base, &tss_seg, sizeof tss_seg,\n\t\t\t    &ctxt->exception);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\n\tif (old_tss_sel != 0xffff) {\n\t\ttss_seg.prev_task_link = old_tss_sel;\n\n\t\tret = ops->write_std(ctxt, new_tss_base,\n\t\t\t\t     &tss_seg.prev_task_link,\n\t\t\t\t     sizeof tss_seg.prev_task_link,\n\t\t\t\t     &ctxt->exception);\n\t\tif (ret != X86EMUL_CONTINUE)\n\t\t\treturn ret;\n\t}\n\n\treturn load_state_from_tss16(ctxt, &tss_seg);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int task_switch_16(struct x86_emulate_ctxt *ctxt,\n\t\t\t  u16 tss_selector, u16 old_tss_sel,\n\t\t\t  ulong old_tss_base, struct desc_struct *new_desc)\n{\n\tconst struct x86_emulate_ops *ops = ctxt->ops;\n\tstruct tss_segment_16 tss_seg;\n\tint ret;\n\tu32 new_tss_base = get_desc_base(new_desc);\n\n\tret = ops->read_std(ctxt, old_tss_base, &tss_seg, sizeof tss_seg,\n\t\t\t    &ctxt->exception);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\n\tsave_state_to_tss16(ctxt, &tss_seg);\n\n\tret = ops->write_std(ctxt, old_tss_base, &tss_seg, sizeof tss_seg,\n\t\t\t     &ctxt->exception);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\n\tret = ops->read_std(ctxt, new_tss_base, &tss_seg, sizeof tss_seg,\n\t\t\t    &ctxt->exception);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\n\tif (old_tss_sel != 0xffff) {\n\t\ttss_seg.prev_task_link = old_tss_sel;\n\n\t\tret = ops->write_std(ctxt, new_tss_base,\n\t\t\t\t     &tss_seg.prev_task_link,\n\t\t\t\t     sizeof tss_seg.prev_task_link,\n\t\t\t\t     &ctxt->exception);\n\t\tif (ret != X86EMUL_CONTINUE)\n\t\t\treturn ret;\n\t}\n\n\treturn load_state_from_tss16(ctxt, &tss_seg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_switch_32",
          "args": [
            "ctxt",
            "tss_selector",
            "old_tss_sel",
            "old_tss_base",
            "&next_tss_desc"
          ],
          "line": 3222
        },
        "resolved": true,
        "details": {
          "function_name": "task_switch_32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "3109-3150",
          "snippet": "static int task_switch_32(struct x86_emulate_ctxt *ctxt,\n\t\t\t  u16 tss_selector, u16 old_tss_sel,\n\t\t\t  ulong old_tss_base, struct desc_struct *new_desc)\n{\n\tconst struct x86_emulate_ops *ops = ctxt->ops;\n\tstruct tss_segment_32 tss_seg;\n\tint ret;\n\tu32 new_tss_base = get_desc_base(new_desc);\n\tu32 eip_offset = offsetof(struct tss_segment_32, eip);\n\tu32 ldt_sel_offset = offsetof(struct tss_segment_32, ldt_selector);\n\n\tret = ops->read_std(ctxt, old_tss_base, &tss_seg, sizeof tss_seg,\n\t\t\t    &ctxt->exception);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\n\tsave_state_to_tss32(ctxt, &tss_seg);\n\n\t/* Only GP registers and segment selectors are saved */\n\tret = ops->write_std(ctxt, old_tss_base + eip_offset, &tss_seg.eip,\n\t\t\t     ldt_sel_offset - eip_offset, &ctxt->exception);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\n\tret = ops->read_std(ctxt, new_tss_base, &tss_seg, sizeof tss_seg,\n\t\t\t    &ctxt->exception);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\n\tif (old_tss_sel != 0xffff) {\n\t\ttss_seg.prev_task_link = old_tss_sel;\n\n\t\tret = ops->write_std(ctxt, new_tss_base,\n\t\t\t\t     &tss_seg.prev_task_link,\n\t\t\t\t     sizeof tss_seg.prev_task_link,\n\t\t\t\t     &ctxt->exception);\n\t\tif (ret != X86EMUL_CONTINUE)\n\t\t\treturn ret;\n\t}\n\n\treturn load_state_from_tss32(ctxt, &tss_seg);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int task_switch_32(struct x86_emulate_ctxt *ctxt,\n\t\t\t  u16 tss_selector, u16 old_tss_sel,\n\t\t\t  ulong old_tss_base, struct desc_struct *new_desc)\n{\n\tconst struct x86_emulate_ops *ops = ctxt->ops;\n\tstruct tss_segment_32 tss_seg;\n\tint ret;\n\tu32 new_tss_base = get_desc_base(new_desc);\n\tu32 eip_offset = offsetof(struct tss_segment_32, eip);\n\tu32 ldt_sel_offset = offsetof(struct tss_segment_32, ldt_selector);\n\n\tret = ops->read_std(ctxt, old_tss_base, &tss_seg, sizeof tss_seg,\n\t\t\t    &ctxt->exception);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\n\tsave_state_to_tss32(ctxt, &tss_seg);\n\n\t/* Only GP registers and segment selectors are saved */\n\tret = ops->write_std(ctxt, old_tss_base + eip_offset, &tss_seg.eip,\n\t\t\t     ldt_sel_offset - eip_offset, &ctxt->exception);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\n\tret = ops->read_std(ctxt, new_tss_base, &tss_seg, sizeof tss_seg,\n\t\t\t    &ctxt->exception);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\n\tif (old_tss_sel != 0xffff) {\n\t\ttss_seg.prev_task_link = old_tss_sel;\n\n\t\tret = ops->write_std(ctxt, new_tss_base,\n\t\t\t\t     &tss_seg.prev_task_link,\n\t\t\t\t     sizeof tss_seg.prev_task_link,\n\t\t\t\t     &ctxt->exception);\n\t\tif (ret != X86EMUL_CONTINUE)\n\t\t\treturn ret;\n\t}\n\n\treturn load_state_from_tss32(ctxt, &tss_seg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "emulate_ts",
          "args": [
            "ctxt",
            "tss_selector & 0xfffc"
          ],
          "line": 3205
        },
        "resolved": true,
        "details": {
          "function_name": "emulate_ts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "595-598",
          "snippet": "static int emulate_ts(struct x86_emulate_ctxt *ctxt, int err)\n{\n\treturn emulate_exception(ctxt, TS_VECTOR, err, true);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int emulate_ts(struct x86_emulate_ctxt *ctxt, int err)\n{\n\treturn emulate_exception(ctxt, TS_VECTOR, err, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "desc_limit_scaled",
          "args": [
            "&next_tss_desc"
          ],
          "line": 3201
        },
        "resolved": true,
        "details": {
          "function_name": "desc_limit_scaled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "550-555",
          "snippet": "static u32 desc_limit_scaled(struct desc_struct *desc)\n{\n\tu32 limit = get_desc_limit(desc);\n\n\treturn desc->g ? (limit << 12) | 0xfff : limit;\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic u32 desc_limit_scaled(struct desc_struct *desc)\n{\n\tu32 limit = get_desc_limit(desc);\n\n\treturn desc->g ? (limit << 12) | 0xfff : limit;\n}"
        }
      },
      {
        "call_info": {
          "callee": "emulate_gp",
          "args": [
            "ctxt",
            "(idt_index << 3) | 0x2"
          ],
          "line": 3197
        },
        "resolved": true,
        "details": {
          "function_name": "emulate_gp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "580-583",
          "snippet": "static int emulate_gp(struct x86_emulate_ctxt *ctxt, int err)\n{\n\treturn emulate_exception(ctxt, GP_VECTOR, err, true);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int emulate_gp(struct x86_emulate_ctxt *ctxt, int err)\n{\n\treturn emulate_exception(ctxt, GP_VECTOR, err, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ops->cpl",
          "args": [
            "ctxt"
          ],
          "line": 3196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_interrupt_descriptor",
          "args": [
            "ctxt",
            "idt_index",
            "&task_gate_desc"
          ],
          "line": 3190
        },
        "resolved": true,
        "details": {
          "function_name": "read_interrupt_descriptor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "1453-1467",
          "snippet": "static int read_interrupt_descriptor(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t     u16 index, struct desc_struct *desc)\n{\n\tstruct desc_ptr dt;\n\tulong addr;\n\n\tctxt->ops->get_idt(ctxt, &dt);\n\n\tif (dt.size < index * 8 + 7)\n\t\treturn emulate_gp(ctxt, index << 3 | 0x2);\n\n\taddr = dt.address + index * 8;\n\treturn ctxt->ops->read_std(ctxt, addr, desc, sizeof *desc,\n\t\t\t\t   &ctxt->exception);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int read_interrupt_descriptor(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t     u16 index, struct desc_struct *desc)\n{\n\tstruct desc_ptr dt;\n\tulong addr;\n\n\tctxt->ops->get_idt(ctxt, &dt);\n\n\tif (dt.size < index * 8 + 7)\n\t\treturn emulate_gp(ctxt, index << 3 | 0x2);\n\n\taddr = dt.address + index * 8;\n\treturn ctxt->ops->read_std(ctxt, addr, desc, sizeof *desc,\n\t\t\t\t   &ctxt->exception);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_segment_descriptor",
          "args": [
            "ctxt",
            "old_tss_sel",
            "&curr_tss_desc",
            "&desc_addr"
          ],
          "line": 3170
        },
        "resolved": true,
        "details": {
          "function_name": "read_segment_descriptor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "1519-1531",
          "snippet": "static int read_segment_descriptor(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t   u16 selector, struct desc_struct *desc,\n\t\t\t\t   ulong *desc_addr_p)\n{\n\tint rc;\n\n\trc = get_descriptor_ptr(ctxt, selector, desc_addr_p);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\treturn ctxt->ops->read_std(ctxt, *desc_addr_p, desc, sizeof(*desc),\n\t\t\t\t   &ctxt->exception);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int read_segment_descriptor(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t   u16 selector, struct desc_struct *desc,\n\t\t\t\t   ulong *desc_addr_p)\n{\n\tint rc;\n\n\trc = get_descriptor_ptr(ctxt, selector, desc_addr_p);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\treturn ctxt->ops->read_std(ctxt, *desc_addr_p, desc, sizeof(*desc),\n\t\t\t\t   &ctxt->exception);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ops->get_cached_segment_base",
          "args": [
            "ctxt",
            "VCPU_SREG_TR"
          ],
          "line": 3161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_segment_selector",
          "args": [
            "ctxt",
            "VCPU_SREG_TR"
          ],
          "line": 3159
        },
        "resolved": true,
        "details": {
          "function_name": "get_segment_selector",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "610-617",
          "snippet": "static u16 get_segment_selector(struct x86_emulate_ctxt *ctxt, unsigned seg)\n{\n\tu16 selector;\n\tstruct desc_struct desc;\n\n\tctxt->ops->get_segment(ctxt, &selector, &desc, NULL, seg);\n\treturn selector;\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic u16 get_segment_selector(struct x86_emulate_ctxt *ctxt, unsigned seg)\n{\n\tu16 selector;\n\tstruct desc_struct desc;\n\n\tctxt->ops->get_segment(ctxt, &selector, &desc, NULL, seg);\n\treturn selector;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int emulator_do_task_switch(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t   u16 tss_selector, int idt_index, int reason,\n\t\t\t\t   bool has_error_code, u32 error_code)\n{\n\tconst struct x86_emulate_ops *ops = ctxt->ops;\n\tstruct desc_struct curr_tss_desc, next_tss_desc;\n\tint ret;\n\tu16 old_tss_sel = get_segment_selector(ctxt, VCPU_SREG_TR);\n\tulong old_tss_base =\n\t\tops->get_cached_segment_base(ctxt, VCPU_SREG_TR);\n\tu32 desc_limit;\n\tulong desc_addr, dr7;\n\n\t/* FIXME: old_tss_base == ~0 ? */\n\n\tret = read_segment_descriptor(ctxt, tss_selector, &next_tss_desc, &desc_addr);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\tret = read_segment_descriptor(ctxt, old_tss_sel, &curr_tss_desc, &desc_addr);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\n\t/* FIXME: check that next_tss_desc is tss */\n\n\t/*\n\t * Check privileges. The three cases are task switch caused by...\n\t *\n\t * 1. jmp/call/int to task gate: Check against DPL of the task gate\n\t * 2. Exception/IRQ/iret: No check is performed\n\t * 3. jmp/call to TSS/task-gate: No check is performed since the\n\t *    hardware checks it before exiting.\n\t */\n\tif (reason == TASK_SWITCH_GATE) {\n\t\tif (idt_index != -1) {\n\t\t\t/* Software interrupts */\n\t\t\tstruct desc_struct task_gate_desc;\n\t\t\tint dpl;\n\n\t\t\tret = read_interrupt_descriptor(ctxt, idt_index,\n\t\t\t\t\t\t\t&task_gate_desc);\n\t\t\tif (ret != X86EMUL_CONTINUE)\n\t\t\t\treturn ret;\n\n\t\t\tdpl = task_gate_desc.dpl;\n\t\t\tif ((tss_selector & 3) > dpl || ops->cpl(ctxt) > dpl)\n\t\t\t\treturn emulate_gp(ctxt, (idt_index << 3) | 0x2);\n\t\t}\n\t}\n\n\tdesc_limit = desc_limit_scaled(&next_tss_desc);\n\tif (!next_tss_desc.p ||\n\t    ((desc_limit < 0x67 && (next_tss_desc.type & 8)) ||\n\t     desc_limit < 0x2b)) {\n\t\treturn emulate_ts(ctxt, tss_selector & 0xfffc);\n\t}\n\n\tif (reason == TASK_SWITCH_IRET || reason == TASK_SWITCH_JMP) {\n\t\tcurr_tss_desc.type &= ~(1 << 1); /* clear busy flag */\n\t\twrite_segment_descriptor(ctxt, old_tss_sel, &curr_tss_desc);\n\t}\n\n\tif (reason == TASK_SWITCH_IRET)\n\t\tctxt->eflags = ctxt->eflags & ~X86_EFLAGS_NT;\n\n\t/* set back link to prev task only if NT bit is set in eflags\n\t   note that old_tss_sel is not used after this point */\n\tif (reason != TASK_SWITCH_CALL && reason != TASK_SWITCH_GATE)\n\t\told_tss_sel = 0xffff;\n\n\tif (next_tss_desc.type & 8)\n\t\tret = task_switch_32(ctxt, tss_selector, old_tss_sel,\n\t\t\t\t     old_tss_base, &next_tss_desc);\n\telse\n\t\tret = task_switch_16(ctxt, tss_selector, old_tss_sel,\n\t\t\t\t     old_tss_base, &next_tss_desc);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\n\tif (reason == TASK_SWITCH_CALL || reason == TASK_SWITCH_GATE)\n\t\tctxt->eflags = ctxt->eflags | X86_EFLAGS_NT;\n\n\tif (reason != TASK_SWITCH_IRET) {\n\t\tnext_tss_desc.type |= (1 << 1); /* set busy flag */\n\t\twrite_segment_descriptor(ctxt, tss_selector, &next_tss_desc);\n\t}\n\n\tops->set_cr(ctxt, 0,  ops->get_cr(ctxt, 0) | X86_CR0_TS);\n\tops->set_segment(ctxt, tss_selector, &next_tss_desc, 0, VCPU_SREG_TR);\n\n\tif (has_error_code) {\n\t\tctxt->op_bytes = ctxt->ad_bytes = (next_tss_desc.type & 8) ? 4 : 2;\n\t\tctxt->lock_prefix = 0;\n\t\tctxt->src.val = (unsigned long) error_code;\n\t\tret = em_push(ctxt);\n\t}\n\n\tops->get_dr(ctxt, 7, &dr7);\n\tops->set_dr(ctxt, 7, dr7 & ~(DR_LOCAL_ENABLE_MASK | DR_LOCAL_SLOWDOWN));\n\n\treturn ret;\n}"
  },
  {
    "function_name": "task_switch_32",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "3109-3150",
    "snippet": "static int task_switch_32(struct x86_emulate_ctxt *ctxt,\n\t\t\t  u16 tss_selector, u16 old_tss_sel,\n\t\t\t  ulong old_tss_base, struct desc_struct *new_desc)\n{\n\tconst struct x86_emulate_ops *ops = ctxt->ops;\n\tstruct tss_segment_32 tss_seg;\n\tint ret;\n\tu32 new_tss_base = get_desc_base(new_desc);\n\tu32 eip_offset = offsetof(struct tss_segment_32, eip);\n\tu32 ldt_sel_offset = offsetof(struct tss_segment_32, ldt_selector);\n\n\tret = ops->read_std(ctxt, old_tss_base, &tss_seg, sizeof tss_seg,\n\t\t\t    &ctxt->exception);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\n\tsave_state_to_tss32(ctxt, &tss_seg);\n\n\t/* Only GP registers and segment selectors are saved */\n\tret = ops->write_std(ctxt, old_tss_base + eip_offset, &tss_seg.eip,\n\t\t\t     ldt_sel_offset - eip_offset, &ctxt->exception);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\n\tret = ops->read_std(ctxt, new_tss_base, &tss_seg, sizeof tss_seg,\n\t\t\t    &ctxt->exception);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\n\tif (old_tss_sel != 0xffff) {\n\t\ttss_seg.prev_task_link = old_tss_sel;\n\n\t\tret = ops->write_std(ctxt, new_tss_base,\n\t\t\t\t     &tss_seg.prev_task_link,\n\t\t\t\t     sizeof tss_seg.prev_task_link,\n\t\t\t\t     &ctxt->exception);\n\t\tif (ret != X86EMUL_CONTINUE)\n\t\t\treturn ret;\n\t}\n\n\treturn load_state_from_tss32(ctxt, &tss_seg);\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "load_state_from_tss32",
          "args": [
            "ctxt",
            "&tss_seg"
          ],
          "line": 3149
        },
        "resolved": true,
        "details": {
          "function_name": "load_state_from_tss32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "3028-3107",
          "snippet": "static int load_state_from_tss32(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t struct tss_segment_32 *tss)\n{\n\tint ret;\n\tu8 cpl;\n\n\tif (ctxt->ops->set_cr(ctxt, 3, tss->cr3))\n\t\treturn emulate_gp(ctxt, 0);\n\tctxt->_eip = tss->eip;\n\tctxt->eflags = tss->eflags | 2;\n\n\t/* General purpose registers */\n\t*reg_write(ctxt, VCPU_REGS_RAX) = tss->eax;\n\t*reg_write(ctxt, VCPU_REGS_RCX) = tss->ecx;\n\t*reg_write(ctxt, VCPU_REGS_RDX) = tss->edx;\n\t*reg_write(ctxt, VCPU_REGS_RBX) = tss->ebx;\n\t*reg_write(ctxt, VCPU_REGS_RSP) = tss->esp;\n\t*reg_write(ctxt, VCPU_REGS_RBP) = tss->ebp;\n\t*reg_write(ctxt, VCPU_REGS_RSI) = tss->esi;\n\t*reg_write(ctxt, VCPU_REGS_RDI) = tss->edi;\n\n\t/*\n\t * SDM says that segment selectors are loaded before segment\n\t * descriptors.  This is important because CPL checks will\n\t * use CS.RPL.\n\t */\n\tset_segment_selector(ctxt, tss->ldt_selector, VCPU_SREG_LDTR);\n\tset_segment_selector(ctxt, tss->es, VCPU_SREG_ES);\n\tset_segment_selector(ctxt, tss->cs, VCPU_SREG_CS);\n\tset_segment_selector(ctxt, tss->ss, VCPU_SREG_SS);\n\tset_segment_selector(ctxt, tss->ds, VCPU_SREG_DS);\n\tset_segment_selector(ctxt, tss->fs, VCPU_SREG_FS);\n\tset_segment_selector(ctxt, tss->gs, VCPU_SREG_GS);\n\n\t/*\n\t * If we're switching between Protected Mode and VM86, we need to make\n\t * sure to update the mode before loading the segment descriptors so\n\t * that the selectors are interpreted correctly.\n\t */\n\tif (ctxt->eflags & X86_EFLAGS_VM) {\n\t\tctxt->mode = X86EMUL_MODE_VM86;\n\t\tcpl = 3;\n\t} else {\n\t\tctxt->mode = X86EMUL_MODE_PROT32;\n\t\tcpl = tss->cs & 3;\n\t}\n\n\t/*\n\t * Now load segment descriptors. If fault happenes at this stage\n\t * it is handled in a context of new task\n\t */\n\tret = __load_segment_descriptor(ctxt, tss->ldt_selector, VCPU_SREG_LDTR,\n\t\t\t\t\tcpl, X86_TRANSFER_TASK_SWITCH, NULL);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\tret = __load_segment_descriptor(ctxt, tss->es, VCPU_SREG_ES, cpl,\n\t\t\t\t\tX86_TRANSFER_TASK_SWITCH, NULL);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\tret = __load_segment_descriptor(ctxt, tss->cs, VCPU_SREG_CS, cpl,\n\t\t\t\t\tX86_TRANSFER_TASK_SWITCH, NULL);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\tret = __load_segment_descriptor(ctxt, tss->ss, VCPU_SREG_SS, cpl,\n\t\t\t\t\tX86_TRANSFER_TASK_SWITCH, NULL);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\tret = __load_segment_descriptor(ctxt, tss->ds, VCPU_SREG_DS, cpl,\n\t\t\t\t\tX86_TRANSFER_TASK_SWITCH, NULL);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\tret = __load_segment_descriptor(ctxt, tss->fs, VCPU_SREG_FS, cpl,\n\t\t\t\t\tX86_TRANSFER_TASK_SWITCH, NULL);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\tret = __load_segment_descriptor(ctxt, tss->gs, VCPU_SREG_GS, cpl,\n\t\t\t\t\tX86_TRANSFER_TASK_SWITCH, NULL);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int load_state_from_tss32(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t struct tss_segment_32 *tss)\n{\n\tint ret;\n\tu8 cpl;\n\n\tif (ctxt->ops->set_cr(ctxt, 3, tss->cr3))\n\t\treturn emulate_gp(ctxt, 0);\n\tctxt->_eip = tss->eip;\n\tctxt->eflags = tss->eflags | 2;\n\n\t/* General purpose registers */\n\t*reg_write(ctxt, VCPU_REGS_RAX) = tss->eax;\n\t*reg_write(ctxt, VCPU_REGS_RCX) = tss->ecx;\n\t*reg_write(ctxt, VCPU_REGS_RDX) = tss->edx;\n\t*reg_write(ctxt, VCPU_REGS_RBX) = tss->ebx;\n\t*reg_write(ctxt, VCPU_REGS_RSP) = tss->esp;\n\t*reg_write(ctxt, VCPU_REGS_RBP) = tss->ebp;\n\t*reg_write(ctxt, VCPU_REGS_RSI) = tss->esi;\n\t*reg_write(ctxt, VCPU_REGS_RDI) = tss->edi;\n\n\t/*\n\t * SDM says that segment selectors are loaded before segment\n\t * descriptors.  This is important because CPL checks will\n\t * use CS.RPL.\n\t */\n\tset_segment_selector(ctxt, tss->ldt_selector, VCPU_SREG_LDTR);\n\tset_segment_selector(ctxt, tss->es, VCPU_SREG_ES);\n\tset_segment_selector(ctxt, tss->cs, VCPU_SREG_CS);\n\tset_segment_selector(ctxt, tss->ss, VCPU_SREG_SS);\n\tset_segment_selector(ctxt, tss->ds, VCPU_SREG_DS);\n\tset_segment_selector(ctxt, tss->fs, VCPU_SREG_FS);\n\tset_segment_selector(ctxt, tss->gs, VCPU_SREG_GS);\n\n\t/*\n\t * If we're switching between Protected Mode and VM86, we need to make\n\t * sure to update the mode before loading the segment descriptors so\n\t * that the selectors are interpreted correctly.\n\t */\n\tif (ctxt->eflags & X86_EFLAGS_VM) {\n\t\tctxt->mode = X86EMUL_MODE_VM86;\n\t\tcpl = 3;\n\t} else {\n\t\tctxt->mode = X86EMUL_MODE_PROT32;\n\t\tcpl = tss->cs & 3;\n\t}\n\n\t/*\n\t * Now load segment descriptors. If fault happenes at this stage\n\t * it is handled in a context of new task\n\t */\n\tret = __load_segment_descriptor(ctxt, tss->ldt_selector, VCPU_SREG_LDTR,\n\t\t\t\t\tcpl, X86_TRANSFER_TASK_SWITCH, NULL);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\tret = __load_segment_descriptor(ctxt, tss->es, VCPU_SREG_ES, cpl,\n\t\t\t\t\tX86_TRANSFER_TASK_SWITCH, NULL);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\tret = __load_segment_descriptor(ctxt, tss->cs, VCPU_SREG_CS, cpl,\n\t\t\t\t\tX86_TRANSFER_TASK_SWITCH, NULL);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\tret = __load_segment_descriptor(ctxt, tss->ss, VCPU_SREG_SS, cpl,\n\t\t\t\t\tX86_TRANSFER_TASK_SWITCH, NULL);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\tret = __load_segment_descriptor(ctxt, tss->ds, VCPU_SREG_DS, cpl,\n\t\t\t\t\tX86_TRANSFER_TASK_SWITCH, NULL);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\tret = __load_segment_descriptor(ctxt, tss->fs, VCPU_SREG_FS, cpl,\n\t\t\t\t\tX86_TRANSFER_TASK_SWITCH, NULL);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\tret = __load_segment_descriptor(ctxt, tss->gs, VCPU_SREG_GS, cpl,\n\t\t\t\t\tX86_TRANSFER_TASK_SWITCH, NULL);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ops->write_std",
          "args": [
            "ctxt",
            "new_tss_base",
            "&tss_seg.prev_task_link",
            "sizeof tss_seg.prev_task_link",
            "&ctxt->exception"
          ],
          "line": 3141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ops->read_std",
          "args": [
            "ctxt",
            "new_tss_base",
            "&tss_seg",
            "sizeof tss_seg",
            "&ctxt->exception"
          ],
          "line": 3133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ops->write_std",
          "args": [
            "ctxt",
            "old_tss_base + eip_offset",
            "&tss_seg.eip",
            "ldt_sel_offset - eip_offset",
            "&ctxt->exception"
          ],
          "line": 3128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "save_state_to_tss32",
          "args": [
            "ctxt",
            "&tss_seg"
          ],
          "line": 3125
        },
        "resolved": true,
        "details": {
          "function_name": "save_state_to_tss32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "3005-3026",
          "snippet": "static void save_state_to_tss32(struct x86_emulate_ctxt *ctxt,\n\t\t\t\tstruct tss_segment_32 *tss)\n{\n\t/* CR3 and ldt selector are not saved intentionally */\n\ttss->eip = ctxt->_eip;\n\ttss->eflags = ctxt->eflags;\n\ttss->eax = reg_read(ctxt, VCPU_REGS_RAX);\n\ttss->ecx = reg_read(ctxt, VCPU_REGS_RCX);\n\ttss->edx = reg_read(ctxt, VCPU_REGS_RDX);\n\ttss->ebx = reg_read(ctxt, VCPU_REGS_RBX);\n\ttss->esp = reg_read(ctxt, VCPU_REGS_RSP);\n\ttss->ebp = reg_read(ctxt, VCPU_REGS_RBP);\n\ttss->esi = reg_read(ctxt, VCPU_REGS_RSI);\n\ttss->edi = reg_read(ctxt, VCPU_REGS_RDI);\n\n\ttss->es = get_segment_selector(ctxt, VCPU_SREG_ES);\n\ttss->cs = get_segment_selector(ctxt, VCPU_SREG_CS);\n\ttss->ss = get_segment_selector(ctxt, VCPU_SREG_SS);\n\ttss->ds = get_segment_selector(ctxt, VCPU_SREG_DS);\n\ttss->fs = get_segment_selector(ctxt, VCPU_SREG_FS);\n\ttss->gs = get_segment_selector(ctxt, VCPU_SREG_GS);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic void save_state_to_tss32(struct x86_emulate_ctxt *ctxt,\n\t\t\t\tstruct tss_segment_32 *tss)\n{\n\t/* CR3 and ldt selector are not saved intentionally */\n\ttss->eip = ctxt->_eip;\n\ttss->eflags = ctxt->eflags;\n\ttss->eax = reg_read(ctxt, VCPU_REGS_RAX);\n\ttss->ecx = reg_read(ctxt, VCPU_REGS_RCX);\n\ttss->edx = reg_read(ctxt, VCPU_REGS_RDX);\n\ttss->ebx = reg_read(ctxt, VCPU_REGS_RBX);\n\ttss->esp = reg_read(ctxt, VCPU_REGS_RSP);\n\ttss->ebp = reg_read(ctxt, VCPU_REGS_RBP);\n\ttss->esi = reg_read(ctxt, VCPU_REGS_RSI);\n\ttss->edi = reg_read(ctxt, VCPU_REGS_RDI);\n\n\ttss->es = get_segment_selector(ctxt, VCPU_SREG_ES);\n\ttss->cs = get_segment_selector(ctxt, VCPU_SREG_CS);\n\ttss->ss = get_segment_selector(ctxt, VCPU_SREG_SS);\n\ttss->ds = get_segment_selector(ctxt, VCPU_SREG_DS);\n\ttss->fs = get_segment_selector(ctxt, VCPU_SREG_FS);\n\ttss->gs = get_segment_selector(ctxt, VCPU_SREG_GS);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ops->read_std",
          "args": [
            "ctxt",
            "old_tss_base",
            "&tss_seg",
            "sizeof tss_seg",
            "&ctxt->exception"
          ],
          "line": 3120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_desc_base",
          "args": [
            "new_desc"
          ],
          "line": 3116
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int task_switch_32(struct x86_emulate_ctxt *ctxt,\n\t\t\t  u16 tss_selector, u16 old_tss_sel,\n\t\t\t  ulong old_tss_base, struct desc_struct *new_desc)\n{\n\tconst struct x86_emulate_ops *ops = ctxt->ops;\n\tstruct tss_segment_32 tss_seg;\n\tint ret;\n\tu32 new_tss_base = get_desc_base(new_desc);\n\tu32 eip_offset = offsetof(struct tss_segment_32, eip);\n\tu32 ldt_sel_offset = offsetof(struct tss_segment_32, ldt_selector);\n\n\tret = ops->read_std(ctxt, old_tss_base, &tss_seg, sizeof tss_seg,\n\t\t\t    &ctxt->exception);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\n\tsave_state_to_tss32(ctxt, &tss_seg);\n\n\t/* Only GP registers and segment selectors are saved */\n\tret = ops->write_std(ctxt, old_tss_base + eip_offset, &tss_seg.eip,\n\t\t\t     ldt_sel_offset - eip_offset, &ctxt->exception);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\n\tret = ops->read_std(ctxt, new_tss_base, &tss_seg, sizeof tss_seg,\n\t\t\t    &ctxt->exception);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\n\tif (old_tss_sel != 0xffff) {\n\t\ttss_seg.prev_task_link = old_tss_sel;\n\n\t\tret = ops->write_std(ctxt, new_tss_base,\n\t\t\t\t     &tss_seg.prev_task_link,\n\t\t\t\t     sizeof tss_seg.prev_task_link,\n\t\t\t\t     &ctxt->exception);\n\t\tif (ret != X86EMUL_CONTINUE)\n\t\t\treturn ret;\n\t}\n\n\treturn load_state_from_tss32(ctxt, &tss_seg);\n}"
  },
  {
    "function_name": "load_state_from_tss32",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "3028-3107",
    "snippet": "static int load_state_from_tss32(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t struct tss_segment_32 *tss)\n{\n\tint ret;\n\tu8 cpl;\n\n\tif (ctxt->ops->set_cr(ctxt, 3, tss->cr3))\n\t\treturn emulate_gp(ctxt, 0);\n\tctxt->_eip = tss->eip;\n\tctxt->eflags = tss->eflags | 2;\n\n\t/* General purpose registers */\n\t*reg_write(ctxt, VCPU_REGS_RAX) = tss->eax;\n\t*reg_write(ctxt, VCPU_REGS_RCX) = tss->ecx;\n\t*reg_write(ctxt, VCPU_REGS_RDX) = tss->edx;\n\t*reg_write(ctxt, VCPU_REGS_RBX) = tss->ebx;\n\t*reg_write(ctxt, VCPU_REGS_RSP) = tss->esp;\n\t*reg_write(ctxt, VCPU_REGS_RBP) = tss->ebp;\n\t*reg_write(ctxt, VCPU_REGS_RSI) = tss->esi;\n\t*reg_write(ctxt, VCPU_REGS_RDI) = tss->edi;\n\n\t/*\n\t * SDM says that segment selectors are loaded before segment\n\t * descriptors.  This is important because CPL checks will\n\t * use CS.RPL.\n\t */\n\tset_segment_selector(ctxt, tss->ldt_selector, VCPU_SREG_LDTR);\n\tset_segment_selector(ctxt, tss->es, VCPU_SREG_ES);\n\tset_segment_selector(ctxt, tss->cs, VCPU_SREG_CS);\n\tset_segment_selector(ctxt, tss->ss, VCPU_SREG_SS);\n\tset_segment_selector(ctxt, tss->ds, VCPU_SREG_DS);\n\tset_segment_selector(ctxt, tss->fs, VCPU_SREG_FS);\n\tset_segment_selector(ctxt, tss->gs, VCPU_SREG_GS);\n\n\t/*\n\t * If we're switching between Protected Mode and VM86, we need to make\n\t * sure to update the mode before loading the segment descriptors so\n\t * that the selectors are interpreted correctly.\n\t */\n\tif (ctxt->eflags & X86_EFLAGS_VM) {\n\t\tctxt->mode = X86EMUL_MODE_VM86;\n\t\tcpl = 3;\n\t} else {\n\t\tctxt->mode = X86EMUL_MODE_PROT32;\n\t\tcpl = tss->cs & 3;\n\t}\n\n\t/*\n\t * Now load segment descriptors. If fault happenes at this stage\n\t * it is handled in a context of new task\n\t */\n\tret = __load_segment_descriptor(ctxt, tss->ldt_selector, VCPU_SREG_LDTR,\n\t\t\t\t\tcpl, X86_TRANSFER_TASK_SWITCH, NULL);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\tret = __load_segment_descriptor(ctxt, tss->es, VCPU_SREG_ES, cpl,\n\t\t\t\t\tX86_TRANSFER_TASK_SWITCH, NULL);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\tret = __load_segment_descriptor(ctxt, tss->cs, VCPU_SREG_CS, cpl,\n\t\t\t\t\tX86_TRANSFER_TASK_SWITCH, NULL);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\tret = __load_segment_descriptor(ctxt, tss->ss, VCPU_SREG_SS, cpl,\n\t\t\t\t\tX86_TRANSFER_TASK_SWITCH, NULL);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\tret = __load_segment_descriptor(ctxt, tss->ds, VCPU_SREG_DS, cpl,\n\t\t\t\t\tX86_TRANSFER_TASK_SWITCH, NULL);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\tret = __load_segment_descriptor(ctxt, tss->fs, VCPU_SREG_FS, cpl,\n\t\t\t\t\tX86_TRANSFER_TASK_SWITCH, NULL);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\tret = __load_segment_descriptor(ctxt, tss->gs, VCPU_SREG_GS, cpl,\n\t\t\t\t\tX86_TRANSFER_TASK_SWITCH, NULL);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__load_segment_descriptor",
          "args": [
            "ctxt",
            "tss->gs",
            "VCPU_SREG_GS",
            "cpl",
            "X86_TRANSFER_TASK_SWITCH",
            "NULL"
          ],
          "line": 3103
        },
        "resolved": true,
        "details": {
          "function_name": "__load_segment_descriptor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "1549-1708",
          "snippet": "static int __load_segment_descriptor(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t     u16 selector, int seg, u8 cpl,\n\t\t\t\t     enum x86_transfer_type transfer,\n\t\t\t\t     struct desc_struct *desc)\n{\n\tstruct desc_struct seg_desc, old_desc;\n\tu8 dpl, rpl;\n\tunsigned err_vec = GP_VECTOR;\n\tu32 err_code = 0;\n\tbool null_selector = !(selector & ~0x3); /* 0000-0003 are null */\n\tulong desc_addr;\n\tint ret;\n\tu16 dummy;\n\tu32 base3 = 0;\n\n\tmemset(&seg_desc, 0, sizeof seg_desc);\n\n\tif (ctxt->mode == X86EMUL_MODE_REAL) {\n\t\t/* set real mode segment descriptor (keep limit etc. for\n\t\t * unreal mode) */\n\t\tctxt->ops->get_segment(ctxt, &dummy, &seg_desc, NULL, seg);\n\t\tset_desc_base(&seg_desc, selector << 4);\n\t\tgoto load;\n\t} else if (seg <= VCPU_SREG_GS && ctxt->mode == X86EMUL_MODE_VM86) {\n\t\t/* VM86 needs a clean new segment descriptor */\n\t\tset_desc_base(&seg_desc, selector << 4);\n\t\tset_desc_limit(&seg_desc, 0xffff);\n\t\tseg_desc.type = 3;\n\t\tseg_desc.p = 1;\n\t\tseg_desc.s = 1;\n\t\tseg_desc.dpl = 3;\n\t\tgoto load;\n\t}\n\n\trpl = selector & 3;\n\n\t/* NULL selector is not valid for TR, CS and SS (except for long mode) */\n\tif ((seg == VCPU_SREG_CS\n\t     || (seg == VCPU_SREG_SS\n\t\t && (ctxt->mode != X86EMUL_MODE_PROT64 || rpl != cpl))\n\t     || seg == VCPU_SREG_TR)\n\t    && null_selector)\n\t\tgoto exception;\n\n\t/* TR should be in GDT only */\n\tif (seg == VCPU_SREG_TR && (selector & (1 << 2)))\n\t\tgoto exception;\n\n\tif (null_selector) /* for NULL selector skip all following checks */\n\t\tgoto load;\n\n\tret = read_segment_descriptor(ctxt, selector, &seg_desc, &desc_addr);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\n\terr_code = selector & 0xfffc;\n\terr_vec = (transfer == X86_TRANSFER_TASK_SWITCH) ? TS_VECTOR :\n\t\t\t\t\t\t\t   GP_VECTOR;\n\n\t/* can't load system descriptor into segment selector */\n\tif (seg <= VCPU_SREG_GS && !seg_desc.s) {\n\t\tif (transfer == X86_TRANSFER_CALL_JMP)\n\t\t\treturn X86EMUL_UNHANDLEABLE;\n\t\tgoto exception;\n\t}\n\n\tif (!seg_desc.p) {\n\t\terr_vec = (seg == VCPU_SREG_SS) ? SS_VECTOR : NP_VECTOR;\n\t\tgoto exception;\n\t}\n\n\tdpl = seg_desc.dpl;\n\n\tswitch (seg) {\n\tcase VCPU_SREG_SS:\n\t\t/*\n\t\t * segment is not a writable data segment or segment\n\t\t * selector's RPL != CPL or segment selector's RPL != CPL\n\t\t */\n\t\tif (rpl != cpl || (seg_desc.type & 0xa) != 0x2 || dpl != cpl)\n\t\t\tgoto exception;\n\t\tbreak;\n\tcase VCPU_SREG_CS:\n\t\tif (!(seg_desc.type & 8))\n\t\t\tgoto exception;\n\n\t\tif (seg_desc.type & 4) {\n\t\t\t/* conforming */\n\t\t\tif (dpl > cpl)\n\t\t\t\tgoto exception;\n\t\t} else {\n\t\t\t/* nonconforming */\n\t\t\tif (rpl > cpl || dpl != cpl)\n\t\t\t\tgoto exception;\n\t\t}\n\t\t/* in long-mode d/b must be clear if l is set */\n\t\tif (seg_desc.d && seg_desc.l) {\n\t\t\tu64 efer = 0;\n\n\t\t\tctxt->ops->get_msr(ctxt, MSR_EFER, &efer);\n\t\t\tif (efer & EFER_LMA)\n\t\t\t\tgoto exception;\n\t\t}\n\n\t\t/* CS(RPL) <- CPL */\n\t\tselector = (selector & 0xfffc) | cpl;\n\t\tbreak;\n\tcase VCPU_SREG_TR:\n\t\tif (seg_desc.s || (seg_desc.type != 1 && seg_desc.type != 9))\n\t\t\tgoto exception;\n\t\told_desc = seg_desc;\n\t\tseg_desc.type |= 2; /* busy */\n\t\tret = ctxt->ops->cmpxchg_emulated(ctxt, desc_addr, &old_desc, &seg_desc,\n\t\t\t\t\t\t  sizeof(seg_desc), &ctxt->exception);\n\t\tif (ret != X86EMUL_CONTINUE)\n\t\t\treturn ret;\n\t\tbreak;\n\tcase VCPU_SREG_LDTR:\n\t\tif (seg_desc.s || seg_desc.type != 2)\n\t\t\tgoto exception;\n\t\tbreak;\n\tdefault: /*  DS, ES, FS, or GS */\n\t\t/*\n\t\t * segment is not a data or readable code segment or\n\t\t * ((segment is a data or nonconforming code segment)\n\t\t * and (both RPL and CPL > DPL))\n\t\t */\n\t\tif ((seg_desc.type & 0xa) == 0x8 ||\n\t\t    (((seg_desc.type & 0xc) != 0xc) &&\n\t\t     (rpl > dpl && cpl > dpl)))\n\t\t\tgoto exception;\n\t\tbreak;\n\t}\n\n\tif (seg_desc.s) {\n\t\t/* mark segment as accessed */\n\t\tif (!(seg_desc.type & 1)) {\n\t\t\tseg_desc.type |= 1;\n\t\t\tret = write_segment_descriptor(ctxt, selector,\n\t\t\t\t\t\t       &seg_desc);\n\t\t\tif (ret != X86EMUL_CONTINUE)\n\t\t\t\treturn ret;\n\t\t}\n\t} else if (ctxt->mode == X86EMUL_MODE_PROT64) {\n\t\tret = ctxt->ops->read_std(ctxt, desc_addr+8, &base3,\n\t\t\t\tsizeof(base3), &ctxt->exception);\n\t\tif (ret != X86EMUL_CONTINUE)\n\t\t\treturn ret;\n\t\tif (is_noncanonical_address(get_desc_base(&seg_desc) |\n\t\t\t\t\t     ((u64)base3 << 32)))\n\t\t\treturn emulate_gp(ctxt, 0);\n\t}\nload:\n\tctxt->ops->set_segment(ctxt, selector, &seg_desc, base3, seg);\n\tif (desc)\n\t\t*desc = seg_desc;\n\treturn X86EMUL_CONTINUE;\nexception:\n\treturn emulate_exception(ctxt, err_vec, err_code, true);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int __load_segment_descriptor(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t     u16 selector, int seg, u8 cpl,\n\t\t\t\t     enum x86_transfer_type transfer,\n\t\t\t\t     struct desc_struct *desc)\n{\n\tstruct desc_struct seg_desc, old_desc;\n\tu8 dpl, rpl;\n\tunsigned err_vec = GP_VECTOR;\n\tu32 err_code = 0;\n\tbool null_selector = !(selector & ~0x3); /* 0000-0003 are null */\n\tulong desc_addr;\n\tint ret;\n\tu16 dummy;\n\tu32 base3 = 0;\n\n\tmemset(&seg_desc, 0, sizeof seg_desc);\n\n\tif (ctxt->mode == X86EMUL_MODE_REAL) {\n\t\t/* set real mode segment descriptor (keep limit etc. for\n\t\t * unreal mode) */\n\t\tctxt->ops->get_segment(ctxt, &dummy, &seg_desc, NULL, seg);\n\t\tset_desc_base(&seg_desc, selector << 4);\n\t\tgoto load;\n\t} else if (seg <= VCPU_SREG_GS && ctxt->mode == X86EMUL_MODE_VM86) {\n\t\t/* VM86 needs a clean new segment descriptor */\n\t\tset_desc_base(&seg_desc, selector << 4);\n\t\tset_desc_limit(&seg_desc, 0xffff);\n\t\tseg_desc.type = 3;\n\t\tseg_desc.p = 1;\n\t\tseg_desc.s = 1;\n\t\tseg_desc.dpl = 3;\n\t\tgoto load;\n\t}\n\n\trpl = selector & 3;\n\n\t/* NULL selector is not valid for TR, CS and SS (except for long mode) */\n\tif ((seg == VCPU_SREG_CS\n\t     || (seg == VCPU_SREG_SS\n\t\t && (ctxt->mode != X86EMUL_MODE_PROT64 || rpl != cpl))\n\t     || seg == VCPU_SREG_TR)\n\t    && null_selector)\n\t\tgoto exception;\n\n\t/* TR should be in GDT only */\n\tif (seg == VCPU_SREG_TR && (selector & (1 << 2)))\n\t\tgoto exception;\n\n\tif (null_selector) /* for NULL selector skip all following checks */\n\t\tgoto load;\n\n\tret = read_segment_descriptor(ctxt, selector, &seg_desc, &desc_addr);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\n\terr_code = selector & 0xfffc;\n\terr_vec = (transfer == X86_TRANSFER_TASK_SWITCH) ? TS_VECTOR :\n\t\t\t\t\t\t\t   GP_VECTOR;\n\n\t/* can't load system descriptor into segment selector */\n\tif (seg <= VCPU_SREG_GS && !seg_desc.s) {\n\t\tif (transfer == X86_TRANSFER_CALL_JMP)\n\t\t\treturn X86EMUL_UNHANDLEABLE;\n\t\tgoto exception;\n\t}\n\n\tif (!seg_desc.p) {\n\t\terr_vec = (seg == VCPU_SREG_SS) ? SS_VECTOR : NP_VECTOR;\n\t\tgoto exception;\n\t}\n\n\tdpl = seg_desc.dpl;\n\n\tswitch (seg) {\n\tcase VCPU_SREG_SS:\n\t\t/*\n\t\t * segment is not a writable data segment or segment\n\t\t * selector's RPL != CPL or segment selector's RPL != CPL\n\t\t */\n\t\tif (rpl != cpl || (seg_desc.type & 0xa) != 0x2 || dpl != cpl)\n\t\t\tgoto exception;\n\t\tbreak;\n\tcase VCPU_SREG_CS:\n\t\tif (!(seg_desc.type & 8))\n\t\t\tgoto exception;\n\n\t\tif (seg_desc.type & 4) {\n\t\t\t/* conforming */\n\t\t\tif (dpl > cpl)\n\t\t\t\tgoto exception;\n\t\t} else {\n\t\t\t/* nonconforming */\n\t\t\tif (rpl > cpl || dpl != cpl)\n\t\t\t\tgoto exception;\n\t\t}\n\t\t/* in long-mode d/b must be clear if l is set */\n\t\tif (seg_desc.d && seg_desc.l) {\n\t\t\tu64 efer = 0;\n\n\t\t\tctxt->ops->get_msr(ctxt, MSR_EFER, &efer);\n\t\t\tif (efer & EFER_LMA)\n\t\t\t\tgoto exception;\n\t\t}\n\n\t\t/* CS(RPL) <- CPL */\n\t\tselector = (selector & 0xfffc) | cpl;\n\t\tbreak;\n\tcase VCPU_SREG_TR:\n\t\tif (seg_desc.s || (seg_desc.type != 1 && seg_desc.type != 9))\n\t\t\tgoto exception;\n\t\told_desc = seg_desc;\n\t\tseg_desc.type |= 2; /* busy */\n\t\tret = ctxt->ops->cmpxchg_emulated(ctxt, desc_addr, &old_desc, &seg_desc,\n\t\t\t\t\t\t  sizeof(seg_desc), &ctxt->exception);\n\t\tif (ret != X86EMUL_CONTINUE)\n\t\t\treturn ret;\n\t\tbreak;\n\tcase VCPU_SREG_LDTR:\n\t\tif (seg_desc.s || seg_desc.type != 2)\n\t\t\tgoto exception;\n\t\tbreak;\n\tdefault: /*  DS, ES, FS, or GS */\n\t\t/*\n\t\t * segment is not a data or readable code segment or\n\t\t * ((segment is a data or nonconforming code segment)\n\t\t * and (both RPL and CPL > DPL))\n\t\t */\n\t\tif ((seg_desc.type & 0xa) == 0x8 ||\n\t\t    (((seg_desc.type & 0xc) != 0xc) &&\n\t\t     (rpl > dpl && cpl > dpl)))\n\t\t\tgoto exception;\n\t\tbreak;\n\t}\n\n\tif (seg_desc.s) {\n\t\t/* mark segment as accessed */\n\t\tif (!(seg_desc.type & 1)) {\n\t\t\tseg_desc.type |= 1;\n\t\t\tret = write_segment_descriptor(ctxt, selector,\n\t\t\t\t\t\t       &seg_desc);\n\t\t\tif (ret != X86EMUL_CONTINUE)\n\t\t\t\treturn ret;\n\t\t}\n\t} else if (ctxt->mode == X86EMUL_MODE_PROT64) {\n\t\tret = ctxt->ops->read_std(ctxt, desc_addr+8, &base3,\n\t\t\t\tsizeof(base3), &ctxt->exception);\n\t\tif (ret != X86EMUL_CONTINUE)\n\t\t\treturn ret;\n\t\tif (is_noncanonical_address(get_desc_base(&seg_desc) |\n\t\t\t\t\t     ((u64)base3 << 32)))\n\t\t\treturn emulate_gp(ctxt, 0);\n\t}\nload:\n\tctxt->ops->set_segment(ctxt, selector, &seg_desc, base3, seg);\n\tif (desc)\n\t\t*desc = seg_desc;\n\treturn X86EMUL_CONTINUE;\nexception:\n\treturn emulate_exception(ctxt, err_vec, err_code, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_segment_selector",
          "args": [
            "ctxt",
            "tss->gs",
            "VCPU_SREG_GS"
          ],
          "line": 3060
        },
        "resolved": true,
        "details": {
          "function_name": "set_segment_selector",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "619-628",
          "snippet": "static void set_segment_selector(struct x86_emulate_ctxt *ctxt, u16 selector,\n\t\t\t\t unsigned seg)\n{\n\tu16 dummy;\n\tu32 base3;\n\tstruct desc_struct desc;\n\n\tctxt->ops->get_segment(ctxt, &dummy, &desc, &base3, seg);\n\tctxt->ops->set_segment(ctxt, selector, &desc, base3, seg);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic void set_segment_selector(struct x86_emulate_ctxt *ctxt, u16 selector,\n\t\t\t\t unsigned seg)\n{\n\tu16 dummy;\n\tu32 base3;\n\tstruct desc_struct desc;\n\n\tctxt->ops->get_segment(ctxt, &dummy, &desc, &base3, seg);\n\tctxt->ops->set_segment(ctxt, selector, &desc, base3, seg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reg_write",
          "args": [
            "ctxt",
            "VCPU_REGS_RDI"
          ],
          "line": 3047
        },
        "resolved": true,
        "details": {
          "function_name": "reg_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "270-275",
          "snippet": "static ulong *reg_write(struct x86_emulate_ctxt *ctxt, unsigned nr)\n{\n\tctxt->regs_valid |= 1 << nr;\n\tctxt->regs_dirty |= 1 << nr;\n\treturn &ctxt->_regs[nr];\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic ulong *reg_write(struct x86_emulate_ctxt *ctxt, unsigned nr)\n{\n\tctxt->regs_valid |= 1 << nr;\n\tctxt->regs_dirty |= 1 << nr;\n\treturn &ctxt->_regs[nr];\n}"
        }
      },
      {
        "call_info": {
          "callee": "emulate_gp",
          "args": [
            "ctxt",
            "0"
          ],
          "line": 3035
        },
        "resolved": true,
        "details": {
          "function_name": "emulate_gp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "580-583",
          "snippet": "static int emulate_gp(struct x86_emulate_ctxt *ctxt, int err)\n{\n\treturn emulate_exception(ctxt, GP_VECTOR, err, true);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int emulate_gp(struct x86_emulate_ctxt *ctxt, int err)\n{\n\treturn emulate_exception(ctxt, GP_VECTOR, err, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ctxt->ops->set_cr",
          "args": [
            "ctxt",
            "3",
            "tss->cr3"
          ],
          "line": 3034
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int load_state_from_tss32(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t struct tss_segment_32 *tss)\n{\n\tint ret;\n\tu8 cpl;\n\n\tif (ctxt->ops->set_cr(ctxt, 3, tss->cr3))\n\t\treturn emulate_gp(ctxt, 0);\n\tctxt->_eip = tss->eip;\n\tctxt->eflags = tss->eflags | 2;\n\n\t/* General purpose registers */\n\t*reg_write(ctxt, VCPU_REGS_RAX) = tss->eax;\n\t*reg_write(ctxt, VCPU_REGS_RCX) = tss->ecx;\n\t*reg_write(ctxt, VCPU_REGS_RDX) = tss->edx;\n\t*reg_write(ctxt, VCPU_REGS_RBX) = tss->ebx;\n\t*reg_write(ctxt, VCPU_REGS_RSP) = tss->esp;\n\t*reg_write(ctxt, VCPU_REGS_RBP) = tss->ebp;\n\t*reg_write(ctxt, VCPU_REGS_RSI) = tss->esi;\n\t*reg_write(ctxt, VCPU_REGS_RDI) = tss->edi;\n\n\t/*\n\t * SDM says that segment selectors are loaded before segment\n\t * descriptors.  This is important because CPL checks will\n\t * use CS.RPL.\n\t */\n\tset_segment_selector(ctxt, tss->ldt_selector, VCPU_SREG_LDTR);\n\tset_segment_selector(ctxt, tss->es, VCPU_SREG_ES);\n\tset_segment_selector(ctxt, tss->cs, VCPU_SREG_CS);\n\tset_segment_selector(ctxt, tss->ss, VCPU_SREG_SS);\n\tset_segment_selector(ctxt, tss->ds, VCPU_SREG_DS);\n\tset_segment_selector(ctxt, tss->fs, VCPU_SREG_FS);\n\tset_segment_selector(ctxt, tss->gs, VCPU_SREG_GS);\n\n\t/*\n\t * If we're switching between Protected Mode and VM86, we need to make\n\t * sure to update the mode before loading the segment descriptors so\n\t * that the selectors are interpreted correctly.\n\t */\n\tif (ctxt->eflags & X86_EFLAGS_VM) {\n\t\tctxt->mode = X86EMUL_MODE_VM86;\n\t\tcpl = 3;\n\t} else {\n\t\tctxt->mode = X86EMUL_MODE_PROT32;\n\t\tcpl = tss->cs & 3;\n\t}\n\n\t/*\n\t * Now load segment descriptors. If fault happenes at this stage\n\t * it is handled in a context of new task\n\t */\n\tret = __load_segment_descriptor(ctxt, tss->ldt_selector, VCPU_SREG_LDTR,\n\t\t\t\t\tcpl, X86_TRANSFER_TASK_SWITCH, NULL);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\tret = __load_segment_descriptor(ctxt, tss->es, VCPU_SREG_ES, cpl,\n\t\t\t\t\tX86_TRANSFER_TASK_SWITCH, NULL);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\tret = __load_segment_descriptor(ctxt, tss->cs, VCPU_SREG_CS, cpl,\n\t\t\t\t\tX86_TRANSFER_TASK_SWITCH, NULL);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\tret = __load_segment_descriptor(ctxt, tss->ss, VCPU_SREG_SS, cpl,\n\t\t\t\t\tX86_TRANSFER_TASK_SWITCH, NULL);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\tret = __load_segment_descriptor(ctxt, tss->ds, VCPU_SREG_DS, cpl,\n\t\t\t\t\tX86_TRANSFER_TASK_SWITCH, NULL);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\tret = __load_segment_descriptor(ctxt, tss->fs, VCPU_SREG_FS, cpl,\n\t\t\t\t\tX86_TRANSFER_TASK_SWITCH, NULL);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\tret = __load_segment_descriptor(ctxt, tss->gs, VCPU_SREG_GS, cpl,\n\t\t\t\t\tX86_TRANSFER_TASK_SWITCH, NULL);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "save_state_to_tss32",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "3005-3026",
    "snippet": "static void save_state_to_tss32(struct x86_emulate_ctxt *ctxt,\n\t\t\t\tstruct tss_segment_32 *tss)\n{\n\t/* CR3 and ldt selector are not saved intentionally */\n\ttss->eip = ctxt->_eip;\n\ttss->eflags = ctxt->eflags;\n\ttss->eax = reg_read(ctxt, VCPU_REGS_RAX);\n\ttss->ecx = reg_read(ctxt, VCPU_REGS_RCX);\n\ttss->edx = reg_read(ctxt, VCPU_REGS_RDX);\n\ttss->ebx = reg_read(ctxt, VCPU_REGS_RBX);\n\ttss->esp = reg_read(ctxt, VCPU_REGS_RSP);\n\ttss->ebp = reg_read(ctxt, VCPU_REGS_RBP);\n\ttss->esi = reg_read(ctxt, VCPU_REGS_RSI);\n\ttss->edi = reg_read(ctxt, VCPU_REGS_RDI);\n\n\ttss->es = get_segment_selector(ctxt, VCPU_SREG_ES);\n\ttss->cs = get_segment_selector(ctxt, VCPU_SREG_CS);\n\ttss->ss = get_segment_selector(ctxt, VCPU_SREG_SS);\n\ttss->ds = get_segment_selector(ctxt, VCPU_SREG_DS);\n\ttss->fs = get_segment_selector(ctxt, VCPU_SREG_FS);\n\ttss->gs = get_segment_selector(ctxt, VCPU_SREG_GS);\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_segment_selector",
          "args": [
            "ctxt",
            "VCPU_SREG_GS"
          ],
          "line": 3025
        },
        "resolved": true,
        "details": {
          "function_name": "get_segment_selector",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "610-617",
          "snippet": "static u16 get_segment_selector(struct x86_emulate_ctxt *ctxt, unsigned seg)\n{\n\tu16 selector;\n\tstruct desc_struct desc;\n\n\tctxt->ops->get_segment(ctxt, &selector, &desc, NULL, seg);\n\treturn selector;\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic u16 get_segment_selector(struct x86_emulate_ctxt *ctxt, unsigned seg)\n{\n\tu16 selector;\n\tstruct desc_struct desc;\n\n\tctxt->ops->get_segment(ctxt, &selector, &desc, NULL, seg);\n\treturn selector;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reg_read",
          "args": [
            "ctxt",
            "VCPU_REGS_RDI"
          ],
          "line": 3018
        },
        "resolved": true,
        "details": {
          "function_name": "reg_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "261-268",
          "snippet": "static ulong reg_read(struct x86_emulate_ctxt *ctxt, unsigned nr)\n{\n\tif (!(ctxt->regs_valid & (1 << nr))) {\n\t\tctxt->regs_valid |= 1 << nr;\n\t\tctxt->_regs[nr] = ctxt->ops->read_gpr(ctxt, nr);\n\t}\n\treturn ctxt->_regs[nr];\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic ulong reg_read(struct x86_emulate_ctxt *ctxt, unsigned nr)\n{\n\tif (!(ctxt->regs_valid & (1 << nr))) {\n\t\tctxt->regs_valid |= 1 << nr;\n\t\tctxt->_regs[nr] = ctxt->ops->read_gpr(ctxt, nr);\n\t}\n\treturn ctxt->_regs[nr];\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic void save_state_to_tss32(struct x86_emulate_ctxt *ctxt,\n\t\t\t\tstruct tss_segment_32 *tss)\n{\n\t/* CR3 and ldt selector are not saved intentionally */\n\ttss->eip = ctxt->_eip;\n\ttss->eflags = ctxt->eflags;\n\ttss->eax = reg_read(ctxt, VCPU_REGS_RAX);\n\ttss->ecx = reg_read(ctxt, VCPU_REGS_RCX);\n\ttss->edx = reg_read(ctxt, VCPU_REGS_RDX);\n\ttss->ebx = reg_read(ctxt, VCPU_REGS_RBX);\n\ttss->esp = reg_read(ctxt, VCPU_REGS_RSP);\n\ttss->ebp = reg_read(ctxt, VCPU_REGS_RBP);\n\ttss->esi = reg_read(ctxt, VCPU_REGS_RSI);\n\ttss->edi = reg_read(ctxt, VCPU_REGS_RDI);\n\n\ttss->es = get_segment_selector(ctxt, VCPU_SREG_ES);\n\ttss->cs = get_segment_selector(ctxt, VCPU_SREG_CS);\n\ttss->ss = get_segment_selector(ctxt, VCPU_SREG_SS);\n\ttss->ds = get_segment_selector(ctxt, VCPU_SREG_DS);\n\ttss->fs = get_segment_selector(ctxt, VCPU_SREG_FS);\n\ttss->gs = get_segment_selector(ctxt, VCPU_SREG_GS);\n}"
  },
  {
    "function_name": "task_switch_16",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "2965-3003",
    "snippet": "static int task_switch_16(struct x86_emulate_ctxt *ctxt,\n\t\t\t  u16 tss_selector, u16 old_tss_sel,\n\t\t\t  ulong old_tss_base, struct desc_struct *new_desc)\n{\n\tconst struct x86_emulate_ops *ops = ctxt->ops;\n\tstruct tss_segment_16 tss_seg;\n\tint ret;\n\tu32 new_tss_base = get_desc_base(new_desc);\n\n\tret = ops->read_std(ctxt, old_tss_base, &tss_seg, sizeof tss_seg,\n\t\t\t    &ctxt->exception);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\n\tsave_state_to_tss16(ctxt, &tss_seg);\n\n\tret = ops->write_std(ctxt, old_tss_base, &tss_seg, sizeof tss_seg,\n\t\t\t     &ctxt->exception);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\n\tret = ops->read_std(ctxt, new_tss_base, &tss_seg, sizeof tss_seg,\n\t\t\t    &ctxt->exception);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\n\tif (old_tss_sel != 0xffff) {\n\t\ttss_seg.prev_task_link = old_tss_sel;\n\n\t\tret = ops->write_std(ctxt, new_tss_base,\n\t\t\t\t     &tss_seg.prev_task_link,\n\t\t\t\t     sizeof tss_seg.prev_task_link,\n\t\t\t\t     &ctxt->exception);\n\t\tif (ret != X86EMUL_CONTINUE)\n\t\t\treturn ret;\n\t}\n\n\treturn load_state_from_tss16(ctxt, &tss_seg);\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "load_state_from_tss16",
          "args": [
            "ctxt",
            "&tss_seg"
          ],
          "line": 3002
        },
        "resolved": true,
        "details": {
          "function_name": "load_state_from_tss16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "2908-2963",
          "snippet": "static int load_state_from_tss16(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t struct tss_segment_16 *tss)\n{\n\tint ret;\n\tu8 cpl;\n\n\tctxt->_eip = tss->ip;\n\tctxt->eflags = tss->flag | 2;\n\t*reg_write(ctxt, VCPU_REGS_RAX) = tss->ax;\n\t*reg_write(ctxt, VCPU_REGS_RCX) = tss->cx;\n\t*reg_write(ctxt, VCPU_REGS_RDX) = tss->dx;\n\t*reg_write(ctxt, VCPU_REGS_RBX) = tss->bx;\n\t*reg_write(ctxt, VCPU_REGS_RSP) = tss->sp;\n\t*reg_write(ctxt, VCPU_REGS_RBP) = tss->bp;\n\t*reg_write(ctxt, VCPU_REGS_RSI) = tss->si;\n\t*reg_write(ctxt, VCPU_REGS_RDI) = tss->di;\n\n\t/*\n\t * SDM says that segment selectors are loaded before segment\n\t * descriptors\n\t */\n\tset_segment_selector(ctxt, tss->ldt, VCPU_SREG_LDTR);\n\tset_segment_selector(ctxt, tss->es, VCPU_SREG_ES);\n\tset_segment_selector(ctxt, tss->cs, VCPU_SREG_CS);\n\tset_segment_selector(ctxt, tss->ss, VCPU_SREG_SS);\n\tset_segment_selector(ctxt, tss->ds, VCPU_SREG_DS);\n\n\tcpl = tss->cs & 3;\n\n\t/*\n\t * Now load segment descriptors. If fault happens at this stage\n\t * it is handled in a context of new task\n\t */\n\tret = __load_segment_descriptor(ctxt, tss->ldt, VCPU_SREG_LDTR, cpl,\n\t\t\t\t\tX86_TRANSFER_TASK_SWITCH, NULL);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\tret = __load_segment_descriptor(ctxt, tss->es, VCPU_SREG_ES, cpl,\n\t\t\t\t\tX86_TRANSFER_TASK_SWITCH, NULL);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\tret = __load_segment_descriptor(ctxt, tss->cs, VCPU_SREG_CS, cpl,\n\t\t\t\t\tX86_TRANSFER_TASK_SWITCH, NULL);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\tret = __load_segment_descriptor(ctxt, tss->ss, VCPU_SREG_SS, cpl,\n\t\t\t\t\tX86_TRANSFER_TASK_SWITCH, NULL);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\tret = __load_segment_descriptor(ctxt, tss->ds, VCPU_SREG_DS, cpl,\n\t\t\t\t\tX86_TRANSFER_TASK_SWITCH, NULL);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\n\treturn X86EMUL_CONTINUE;\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int load_state_from_tss16(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t struct tss_segment_16 *tss)\n{\n\tint ret;\n\tu8 cpl;\n\n\tctxt->_eip = tss->ip;\n\tctxt->eflags = tss->flag | 2;\n\t*reg_write(ctxt, VCPU_REGS_RAX) = tss->ax;\n\t*reg_write(ctxt, VCPU_REGS_RCX) = tss->cx;\n\t*reg_write(ctxt, VCPU_REGS_RDX) = tss->dx;\n\t*reg_write(ctxt, VCPU_REGS_RBX) = tss->bx;\n\t*reg_write(ctxt, VCPU_REGS_RSP) = tss->sp;\n\t*reg_write(ctxt, VCPU_REGS_RBP) = tss->bp;\n\t*reg_write(ctxt, VCPU_REGS_RSI) = tss->si;\n\t*reg_write(ctxt, VCPU_REGS_RDI) = tss->di;\n\n\t/*\n\t * SDM says that segment selectors are loaded before segment\n\t * descriptors\n\t */\n\tset_segment_selector(ctxt, tss->ldt, VCPU_SREG_LDTR);\n\tset_segment_selector(ctxt, tss->es, VCPU_SREG_ES);\n\tset_segment_selector(ctxt, tss->cs, VCPU_SREG_CS);\n\tset_segment_selector(ctxt, tss->ss, VCPU_SREG_SS);\n\tset_segment_selector(ctxt, tss->ds, VCPU_SREG_DS);\n\n\tcpl = tss->cs & 3;\n\n\t/*\n\t * Now load segment descriptors. If fault happens at this stage\n\t * it is handled in a context of new task\n\t */\n\tret = __load_segment_descriptor(ctxt, tss->ldt, VCPU_SREG_LDTR, cpl,\n\t\t\t\t\tX86_TRANSFER_TASK_SWITCH, NULL);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\tret = __load_segment_descriptor(ctxt, tss->es, VCPU_SREG_ES, cpl,\n\t\t\t\t\tX86_TRANSFER_TASK_SWITCH, NULL);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\tret = __load_segment_descriptor(ctxt, tss->cs, VCPU_SREG_CS, cpl,\n\t\t\t\t\tX86_TRANSFER_TASK_SWITCH, NULL);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\tret = __load_segment_descriptor(ctxt, tss->ss, VCPU_SREG_SS, cpl,\n\t\t\t\t\tX86_TRANSFER_TASK_SWITCH, NULL);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\tret = __load_segment_descriptor(ctxt, tss->ds, VCPU_SREG_DS, cpl,\n\t\t\t\t\tX86_TRANSFER_TASK_SWITCH, NULL);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\n\treturn X86EMUL_CONTINUE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ops->write_std",
          "args": [
            "ctxt",
            "new_tss_base",
            "&tss_seg.prev_task_link",
            "sizeof tss_seg.prev_task_link",
            "&ctxt->exception"
          ],
          "line": 2994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ops->read_std",
          "args": [
            "ctxt",
            "new_tss_base",
            "&tss_seg",
            "sizeof tss_seg",
            "&ctxt->exception"
          ],
          "line": 2986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ops->write_std",
          "args": [
            "ctxt",
            "old_tss_base",
            "&tss_seg",
            "sizeof tss_seg",
            "&ctxt->exception"
          ],
          "line": 2981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "save_state_to_tss16",
          "args": [
            "ctxt",
            "&tss_seg"
          ],
          "line": 2979
        },
        "resolved": true,
        "details": {
          "function_name": "save_state_to_tss16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "2887-2906",
          "snippet": "static void save_state_to_tss16(struct x86_emulate_ctxt *ctxt,\n\t\t\t\tstruct tss_segment_16 *tss)\n{\n\ttss->ip = ctxt->_eip;\n\ttss->flag = ctxt->eflags;\n\ttss->ax = reg_read(ctxt, VCPU_REGS_RAX);\n\ttss->cx = reg_read(ctxt, VCPU_REGS_RCX);\n\ttss->dx = reg_read(ctxt, VCPU_REGS_RDX);\n\ttss->bx = reg_read(ctxt, VCPU_REGS_RBX);\n\ttss->sp = reg_read(ctxt, VCPU_REGS_RSP);\n\ttss->bp = reg_read(ctxt, VCPU_REGS_RBP);\n\ttss->si = reg_read(ctxt, VCPU_REGS_RSI);\n\ttss->di = reg_read(ctxt, VCPU_REGS_RDI);\n\n\ttss->es = get_segment_selector(ctxt, VCPU_SREG_ES);\n\ttss->cs = get_segment_selector(ctxt, VCPU_SREG_CS);\n\ttss->ss = get_segment_selector(ctxt, VCPU_SREG_SS);\n\ttss->ds = get_segment_selector(ctxt, VCPU_SREG_DS);\n\ttss->ldt = get_segment_selector(ctxt, VCPU_SREG_LDTR);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic void save_state_to_tss16(struct x86_emulate_ctxt *ctxt,\n\t\t\t\tstruct tss_segment_16 *tss)\n{\n\ttss->ip = ctxt->_eip;\n\ttss->flag = ctxt->eflags;\n\ttss->ax = reg_read(ctxt, VCPU_REGS_RAX);\n\ttss->cx = reg_read(ctxt, VCPU_REGS_RCX);\n\ttss->dx = reg_read(ctxt, VCPU_REGS_RDX);\n\ttss->bx = reg_read(ctxt, VCPU_REGS_RBX);\n\ttss->sp = reg_read(ctxt, VCPU_REGS_RSP);\n\ttss->bp = reg_read(ctxt, VCPU_REGS_RBP);\n\ttss->si = reg_read(ctxt, VCPU_REGS_RSI);\n\ttss->di = reg_read(ctxt, VCPU_REGS_RDI);\n\n\ttss->es = get_segment_selector(ctxt, VCPU_SREG_ES);\n\ttss->cs = get_segment_selector(ctxt, VCPU_SREG_CS);\n\ttss->ss = get_segment_selector(ctxt, VCPU_SREG_SS);\n\ttss->ds = get_segment_selector(ctxt, VCPU_SREG_DS);\n\ttss->ldt = get_segment_selector(ctxt, VCPU_SREG_LDTR);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ops->read_std",
          "args": [
            "ctxt",
            "old_tss_base",
            "&tss_seg",
            "sizeof tss_seg",
            "&ctxt->exception"
          ],
          "line": 2974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_desc_base",
          "args": [
            "new_desc"
          ],
          "line": 2972
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int task_switch_16(struct x86_emulate_ctxt *ctxt,\n\t\t\t  u16 tss_selector, u16 old_tss_sel,\n\t\t\t  ulong old_tss_base, struct desc_struct *new_desc)\n{\n\tconst struct x86_emulate_ops *ops = ctxt->ops;\n\tstruct tss_segment_16 tss_seg;\n\tint ret;\n\tu32 new_tss_base = get_desc_base(new_desc);\n\n\tret = ops->read_std(ctxt, old_tss_base, &tss_seg, sizeof tss_seg,\n\t\t\t    &ctxt->exception);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\n\tsave_state_to_tss16(ctxt, &tss_seg);\n\n\tret = ops->write_std(ctxt, old_tss_base, &tss_seg, sizeof tss_seg,\n\t\t\t     &ctxt->exception);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\n\tret = ops->read_std(ctxt, new_tss_base, &tss_seg, sizeof tss_seg,\n\t\t\t    &ctxt->exception);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\n\tif (old_tss_sel != 0xffff) {\n\t\ttss_seg.prev_task_link = old_tss_sel;\n\n\t\tret = ops->write_std(ctxt, new_tss_base,\n\t\t\t\t     &tss_seg.prev_task_link,\n\t\t\t\t     sizeof tss_seg.prev_task_link,\n\t\t\t\t     &ctxt->exception);\n\t\tif (ret != X86EMUL_CONTINUE)\n\t\t\treturn ret;\n\t}\n\n\treturn load_state_from_tss16(ctxt, &tss_seg);\n}"
  },
  {
    "function_name": "load_state_from_tss16",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "2908-2963",
    "snippet": "static int load_state_from_tss16(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t struct tss_segment_16 *tss)\n{\n\tint ret;\n\tu8 cpl;\n\n\tctxt->_eip = tss->ip;\n\tctxt->eflags = tss->flag | 2;\n\t*reg_write(ctxt, VCPU_REGS_RAX) = tss->ax;\n\t*reg_write(ctxt, VCPU_REGS_RCX) = tss->cx;\n\t*reg_write(ctxt, VCPU_REGS_RDX) = tss->dx;\n\t*reg_write(ctxt, VCPU_REGS_RBX) = tss->bx;\n\t*reg_write(ctxt, VCPU_REGS_RSP) = tss->sp;\n\t*reg_write(ctxt, VCPU_REGS_RBP) = tss->bp;\n\t*reg_write(ctxt, VCPU_REGS_RSI) = tss->si;\n\t*reg_write(ctxt, VCPU_REGS_RDI) = tss->di;\n\n\t/*\n\t * SDM says that segment selectors are loaded before segment\n\t * descriptors\n\t */\n\tset_segment_selector(ctxt, tss->ldt, VCPU_SREG_LDTR);\n\tset_segment_selector(ctxt, tss->es, VCPU_SREG_ES);\n\tset_segment_selector(ctxt, tss->cs, VCPU_SREG_CS);\n\tset_segment_selector(ctxt, tss->ss, VCPU_SREG_SS);\n\tset_segment_selector(ctxt, tss->ds, VCPU_SREG_DS);\n\n\tcpl = tss->cs & 3;\n\n\t/*\n\t * Now load segment descriptors. If fault happens at this stage\n\t * it is handled in a context of new task\n\t */\n\tret = __load_segment_descriptor(ctxt, tss->ldt, VCPU_SREG_LDTR, cpl,\n\t\t\t\t\tX86_TRANSFER_TASK_SWITCH, NULL);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\tret = __load_segment_descriptor(ctxt, tss->es, VCPU_SREG_ES, cpl,\n\t\t\t\t\tX86_TRANSFER_TASK_SWITCH, NULL);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\tret = __load_segment_descriptor(ctxt, tss->cs, VCPU_SREG_CS, cpl,\n\t\t\t\t\tX86_TRANSFER_TASK_SWITCH, NULL);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\tret = __load_segment_descriptor(ctxt, tss->ss, VCPU_SREG_SS, cpl,\n\t\t\t\t\tX86_TRANSFER_TASK_SWITCH, NULL);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\tret = __load_segment_descriptor(ctxt, tss->ds, VCPU_SREG_DS, cpl,\n\t\t\t\t\tX86_TRANSFER_TASK_SWITCH, NULL);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\n\treturn X86EMUL_CONTINUE;\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__load_segment_descriptor",
          "args": [
            "ctxt",
            "tss->ds",
            "VCPU_SREG_DS",
            "cpl",
            "X86_TRANSFER_TASK_SWITCH",
            "NULL"
          ],
          "line": 2957
        },
        "resolved": true,
        "details": {
          "function_name": "__load_segment_descriptor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "1549-1708",
          "snippet": "static int __load_segment_descriptor(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t     u16 selector, int seg, u8 cpl,\n\t\t\t\t     enum x86_transfer_type transfer,\n\t\t\t\t     struct desc_struct *desc)\n{\n\tstruct desc_struct seg_desc, old_desc;\n\tu8 dpl, rpl;\n\tunsigned err_vec = GP_VECTOR;\n\tu32 err_code = 0;\n\tbool null_selector = !(selector & ~0x3); /* 0000-0003 are null */\n\tulong desc_addr;\n\tint ret;\n\tu16 dummy;\n\tu32 base3 = 0;\n\n\tmemset(&seg_desc, 0, sizeof seg_desc);\n\n\tif (ctxt->mode == X86EMUL_MODE_REAL) {\n\t\t/* set real mode segment descriptor (keep limit etc. for\n\t\t * unreal mode) */\n\t\tctxt->ops->get_segment(ctxt, &dummy, &seg_desc, NULL, seg);\n\t\tset_desc_base(&seg_desc, selector << 4);\n\t\tgoto load;\n\t} else if (seg <= VCPU_SREG_GS && ctxt->mode == X86EMUL_MODE_VM86) {\n\t\t/* VM86 needs a clean new segment descriptor */\n\t\tset_desc_base(&seg_desc, selector << 4);\n\t\tset_desc_limit(&seg_desc, 0xffff);\n\t\tseg_desc.type = 3;\n\t\tseg_desc.p = 1;\n\t\tseg_desc.s = 1;\n\t\tseg_desc.dpl = 3;\n\t\tgoto load;\n\t}\n\n\trpl = selector & 3;\n\n\t/* NULL selector is not valid for TR, CS and SS (except for long mode) */\n\tif ((seg == VCPU_SREG_CS\n\t     || (seg == VCPU_SREG_SS\n\t\t && (ctxt->mode != X86EMUL_MODE_PROT64 || rpl != cpl))\n\t     || seg == VCPU_SREG_TR)\n\t    && null_selector)\n\t\tgoto exception;\n\n\t/* TR should be in GDT only */\n\tif (seg == VCPU_SREG_TR && (selector & (1 << 2)))\n\t\tgoto exception;\n\n\tif (null_selector) /* for NULL selector skip all following checks */\n\t\tgoto load;\n\n\tret = read_segment_descriptor(ctxt, selector, &seg_desc, &desc_addr);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\n\terr_code = selector & 0xfffc;\n\terr_vec = (transfer == X86_TRANSFER_TASK_SWITCH) ? TS_VECTOR :\n\t\t\t\t\t\t\t   GP_VECTOR;\n\n\t/* can't load system descriptor into segment selector */\n\tif (seg <= VCPU_SREG_GS && !seg_desc.s) {\n\t\tif (transfer == X86_TRANSFER_CALL_JMP)\n\t\t\treturn X86EMUL_UNHANDLEABLE;\n\t\tgoto exception;\n\t}\n\n\tif (!seg_desc.p) {\n\t\terr_vec = (seg == VCPU_SREG_SS) ? SS_VECTOR : NP_VECTOR;\n\t\tgoto exception;\n\t}\n\n\tdpl = seg_desc.dpl;\n\n\tswitch (seg) {\n\tcase VCPU_SREG_SS:\n\t\t/*\n\t\t * segment is not a writable data segment or segment\n\t\t * selector's RPL != CPL or segment selector's RPL != CPL\n\t\t */\n\t\tif (rpl != cpl || (seg_desc.type & 0xa) != 0x2 || dpl != cpl)\n\t\t\tgoto exception;\n\t\tbreak;\n\tcase VCPU_SREG_CS:\n\t\tif (!(seg_desc.type & 8))\n\t\t\tgoto exception;\n\n\t\tif (seg_desc.type & 4) {\n\t\t\t/* conforming */\n\t\t\tif (dpl > cpl)\n\t\t\t\tgoto exception;\n\t\t} else {\n\t\t\t/* nonconforming */\n\t\t\tif (rpl > cpl || dpl != cpl)\n\t\t\t\tgoto exception;\n\t\t}\n\t\t/* in long-mode d/b must be clear if l is set */\n\t\tif (seg_desc.d && seg_desc.l) {\n\t\t\tu64 efer = 0;\n\n\t\t\tctxt->ops->get_msr(ctxt, MSR_EFER, &efer);\n\t\t\tif (efer & EFER_LMA)\n\t\t\t\tgoto exception;\n\t\t}\n\n\t\t/* CS(RPL) <- CPL */\n\t\tselector = (selector & 0xfffc) | cpl;\n\t\tbreak;\n\tcase VCPU_SREG_TR:\n\t\tif (seg_desc.s || (seg_desc.type != 1 && seg_desc.type != 9))\n\t\t\tgoto exception;\n\t\told_desc = seg_desc;\n\t\tseg_desc.type |= 2; /* busy */\n\t\tret = ctxt->ops->cmpxchg_emulated(ctxt, desc_addr, &old_desc, &seg_desc,\n\t\t\t\t\t\t  sizeof(seg_desc), &ctxt->exception);\n\t\tif (ret != X86EMUL_CONTINUE)\n\t\t\treturn ret;\n\t\tbreak;\n\tcase VCPU_SREG_LDTR:\n\t\tif (seg_desc.s || seg_desc.type != 2)\n\t\t\tgoto exception;\n\t\tbreak;\n\tdefault: /*  DS, ES, FS, or GS */\n\t\t/*\n\t\t * segment is not a data or readable code segment or\n\t\t * ((segment is a data or nonconforming code segment)\n\t\t * and (both RPL and CPL > DPL))\n\t\t */\n\t\tif ((seg_desc.type & 0xa) == 0x8 ||\n\t\t    (((seg_desc.type & 0xc) != 0xc) &&\n\t\t     (rpl > dpl && cpl > dpl)))\n\t\t\tgoto exception;\n\t\tbreak;\n\t}\n\n\tif (seg_desc.s) {\n\t\t/* mark segment as accessed */\n\t\tif (!(seg_desc.type & 1)) {\n\t\t\tseg_desc.type |= 1;\n\t\t\tret = write_segment_descriptor(ctxt, selector,\n\t\t\t\t\t\t       &seg_desc);\n\t\t\tif (ret != X86EMUL_CONTINUE)\n\t\t\t\treturn ret;\n\t\t}\n\t} else if (ctxt->mode == X86EMUL_MODE_PROT64) {\n\t\tret = ctxt->ops->read_std(ctxt, desc_addr+8, &base3,\n\t\t\t\tsizeof(base3), &ctxt->exception);\n\t\tif (ret != X86EMUL_CONTINUE)\n\t\t\treturn ret;\n\t\tif (is_noncanonical_address(get_desc_base(&seg_desc) |\n\t\t\t\t\t     ((u64)base3 << 32)))\n\t\t\treturn emulate_gp(ctxt, 0);\n\t}\nload:\n\tctxt->ops->set_segment(ctxt, selector, &seg_desc, base3, seg);\n\tif (desc)\n\t\t*desc = seg_desc;\n\treturn X86EMUL_CONTINUE;\nexception:\n\treturn emulate_exception(ctxt, err_vec, err_code, true);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int __load_segment_descriptor(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t     u16 selector, int seg, u8 cpl,\n\t\t\t\t     enum x86_transfer_type transfer,\n\t\t\t\t     struct desc_struct *desc)\n{\n\tstruct desc_struct seg_desc, old_desc;\n\tu8 dpl, rpl;\n\tunsigned err_vec = GP_VECTOR;\n\tu32 err_code = 0;\n\tbool null_selector = !(selector & ~0x3); /* 0000-0003 are null */\n\tulong desc_addr;\n\tint ret;\n\tu16 dummy;\n\tu32 base3 = 0;\n\n\tmemset(&seg_desc, 0, sizeof seg_desc);\n\n\tif (ctxt->mode == X86EMUL_MODE_REAL) {\n\t\t/* set real mode segment descriptor (keep limit etc. for\n\t\t * unreal mode) */\n\t\tctxt->ops->get_segment(ctxt, &dummy, &seg_desc, NULL, seg);\n\t\tset_desc_base(&seg_desc, selector << 4);\n\t\tgoto load;\n\t} else if (seg <= VCPU_SREG_GS && ctxt->mode == X86EMUL_MODE_VM86) {\n\t\t/* VM86 needs a clean new segment descriptor */\n\t\tset_desc_base(&seg_desc, selector << 4);\n\t\tset_desc_limit(&seg_desc, 0xffff);\n\t\tseg_desc.type = 3;\n\t\tseg_desc.p = 1;\n\t\tseg_desc.s = 1;\n\t\tseg_desc.dpl = 3;\n\t\tgoto load;\n\t}\n\n\trpl = selector & 3;\n\n\t/* NULL selector is not valid for TR, CS and SS (except for long mode) */\n\tif ((seg == VCPU_SREG_CS\n\t     || (seg == VCPU_SREG_SS\n\t\t && (ctxt->mode != X86EMUL_MODE_PROT64 || rpl != cpl))\n\t     || seg == VCPU_SREG_TR)\n\t    && null_selector)\n\t\tgoto exception;\n\n\t/* TR should be in GDT only */\n\tif (seg == VCPU_SREG_TR && (selector & (1 << 2)))\n\t\tgoto exception;\n\n\tif (null_selector) /* for NULL selector skip all following checks */\n\t\tgoto load;\n\n\tret = read_segment_descriptor(ctxt, selector, &seg_desc, &desc_addr);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\n\terr_code = selector & 0xfffc;\n\terr_vec = (transfer == X86_TRANSFER_TASK_SWITCH) ? TS_VECTOR :\n\t\t\t\t\t\t\t   GP_VECTOR;\n\n\t/* can't load system descriptor into segment selector */\n\tif (seg <= VCPU_SREG_GS && !seg_desc.s) {\n\t\tif (transfer == X86_TRANSFER_CALL_JMP)\n\t\t\treturn X86EMUL_UNHANDLEABLE;\n\t\tgoto exception;\n\t}\n\n\tif (!seg_desc.p) {\n\t\terr_vec = (seg == VCPU_SREG_SS) ? SS_VECTOR : NP_VECTOR;\n\t\tgoto exception;\n\t}\n\n\tdpl = seg_desc.dpl;\n\n\tswitch (seg) {\n\tcase VCPU_SREG_SS:\n\t\t/*\n\t\t * segment is not a writable data segment or segment\n\t\t * selector's RPL != CPL or segment selector's RPL != CPL\n\t\t */\n\t\tif (rpl != cpl || (seg_desc.type & 0xa) != 0x2 || dpl != cpl)\n\t\t\tgoto exception;\n\t\tbreak;\n\tcase VCPU_SREG_CS:\n\t\tif (!(seg_desc.type & 8))\n\t\t\tgoto exception;\n\n\t\tif (seg_desc.type & 4) {\n\t\t\t/* conforming */\n\t\t\tif (dpl > cpl)\n\t\t\t\tgoto exception;\n\t\t} else {\n\t\t\t/* nonconforming */\n\t\t\tif (rpl > cpl || dpl != cpl)\n\t\t\t\tgoto exception;\n\t\t}\n\t\t/* in long-mode d/b must be clear if l is set */\n\t\tif (seg_desc.d && seg_desc.l) {\n\t\t\tu64 efer = 0;\n\n\t\t\tctxt->ops->get_msr(ctxt, MSR_EFER, &efer);\n\t\t\tif (efer & EFER_LMA)\n\t\t\t\tgoto exception;\n\t\t}\n\n\t\t/* CS(RPL) <- CPL */\n\t\tselector = (selector & 0xfffc) | cpl;\n\t\tbreak;\n\tcase VCPU_SREG_TR:\n\t\tif (seg_desc.s || (seg_desc.type != 1 && seg_desc.type != 9))\n\t\t\tgoto exception;\n\t\told_desc = seg_desc;\n\t\tseg_desc.type |= 2; /* busy */\n\t\tret = ctxt->ops->cmpxchg_emulated(ctxt, desc_addr, &old_desc, &seg_desc,\n\t\t\t\t\t\t  sizeof(seg_desc), &ctxt->exception);\n\t\tif (ret != X86EMUL_CONTINUE)\n\t\t\treturn ret;\n\t\tbreak;\n\tcase VCPU_SREG_LDTR:\n\t\tif (seg_desc.s || seg_desc.type != 2)\n\t\t\tgoto exception;\n\t\tbreak;\n\tdefault: /*  DS, ES, FS, or GS */\n\t\t/*\n\t\t * segment is not a data or readable code segment or\n\t\t * ((segment is a data or nonconforming code segment)\n\t\t * and (both RPL and CPL > DPL))\n\t\t */\n\t\tif ((seg_desc.type & 0xa) == 0x8 ||\n\t\t    (((seg_desc.type & 0xc) != 0xc) &&\n\t\t     (rpl > dpl && cpl > dpl)))\n\t\t\tgoto exception;\n\t\tbreak;\n\t}\n\n\tif (seg_desc.s) {\n\t\t/* mark segment as accessed */\n\t\tif (!(seg_desc.type & 1)) {\n\t\t\tseg_desc.type |= 1;\n\t\t\tret = write_segment_descriptor(ctxt, selector,\n\t\t\t\t\t\t       &seg_desc);\n\t\t\tif (ret != X86EMUL_CONTINUE)\n\t\t\t\treturn ret;\n\t\t}\n\t} else if (ctxt->mode == X86EMUL_MODE_PROT64) {\n\t\tret = ctxt->ops->read_std(ctxt, desc_addr+8, &base3,\n\t\t\t\tsizeof(base3), &ctxt->exception);\n\t\tif (ret != X86EMUL_CONTINUE)\n\t\t\treturn ret;\n\t\tif (is_noncanonical_address(get_desc_base(&seg_desc) |\n\t\t\t\t\t     ((u64)base3 << 32)))\n\t\t\treturn emulate_gp(ctxt, 0);\n\t}\nload:\n\tctxt->ops->set_segment(ctxt, selector, &seg_desc, base3, seg);\n\tif (desc)\n\t\t*desc = seg_desc;\n\treturn X86EMUL_CONTINUE;\nexception:\n\treturn emulate_exception(ctxt, err_vec, err_code, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_segment_selector",
          "args": [
            "ctxt",
            "tss->ds",
            "VCPU_SREG_DS"
          ],
          "line": 2933
        },
        "resolved": true,
        "details": {
          "function_name": "set_segment_selector",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "619-628",
          "snippet": "static void set_segment_selector(struct x86_emulate_ctxt *ctxt, u16 selector,\n\t\t\t\t unsigned seg)\n{\n\tu16 dummy;\n\tu32 base3;\n\tstruct desc_struct desc;\n\n\tctxt->ops->get_segment(ctxt, &dummy, &desc, &base3, seg);\n\tctxt->ops->set_segment(ctxt, selector, &desc, base3, seg);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic void set_segment_selector(struct x86_emulate_ctxt *ctxt, u16 selector,\n\t\t\t\t unsigned seg)\n{\n\tu16 dummy;\n\tu32 base3;\n\tstruct desc_struct desc;\n\n\tctxt->ops->get_segment(ctxt, &dummy, &desc, &base3, seg);\n\tctxt->ops->set_segment(ctxt, selector, &desc, base3, seg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reg_write",
          "args": [
            "ctxt",
            "VCPU_REGS_RDI"
          ],
          "line": 2923
        },
        "resolved": true,
        "details": {
          "function_name": "reg_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "270-275",
          "snippet": "static ulong *reg_write(struct x86_emulate_ctxt *ctxt, unsigned nr)\n{\n\tctxt->regs_valid |= 1 << nr;\n\tctxt->regs_dirty |= 1 << nr;\n\treturn &ctxt->_regs[nr];\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic ulong *reg_write(struct x86_emulate_ctxt *ctxt, unsigned nr)\n{\n\tctxt->regs_valid |= 1 << nr;\n\tctxt->regs_dirty |= 1 << nr;\n\treturn &ctxt->_regs[nr];\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int load_state_from_tss16(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t struct tss_segment_16 *tss)\n{\n\tint ret;\n\tu8 cpl;\n\n\tctxt->_eip = tss->ip;\n\tctxt->eflags = tss->flag | 2;\n\t*reg_write(ctxt, VCPU_REGS_RAX) = tss->ax;\n\t*reg_write(ctxt, VCPU_REGS_RCX) = tss->cx;\n\t*reg_write(ctxt, VCPU_REGS_RDX) = tss->dx;\n\t*reg_write(ctxt, VCPU_REGS_RBX) = tss->bx;\n\t*reg_write(ctxt, VCPU_REGS_RSP) = tss->sp;\n\t*reg_write(ctxt, VCPU_REGS_RBP) = tss->bp;\n\t*reg_write(ctxt, VCPU_REGS_RSI) = tss->si;\n\t*reg_write(ctxt, VCPU_REGS_RDI) = tss->di;\n\n\t/*\n\t * SDM says that segment selectors are loaded before segment\n\t * descriptors\n\t */\n\tset_segment_selector(ctxt, tss->ldt, VCPU_SREG_LDTR);\n\tset_segment_selector(ctxt, tss->es, VCPU_SREG_ES);\n\tset_segment_selector(ctxt, tss->cs, VCPU_SREG_CS);\n\tset_segment_selector(ctxt, tss->ss, VCPU_SREG_SS);\n\tset_segment_selector(ctxt, tss->ds, VCPU_SREG_DS);\n\n\tcpl = tss->cs & 3;\n\n\t/*\n\t * Now load segment descriptors. If fault happens at this stage\n\t * it is handled in a context of new task\n\t */\n\tret = __load_segment_descriptor(ctxt, tss->ldt, VCPU_SREG_LDTR, cpl,\n\t\t\t\t\tX86_TRANSFER_TASK_SWITCH, NULL);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\tret = __load_segment_descriptor(ctxt, tss->es, VCPU_SREG_ES, cpl,\n\t\t\t\t\tX86_TRANSFER_TASK_SWITCH, NULL);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\tret = __load_segment_descriptor(ctxt, tss->cs, VCPU_SREG_CS, cpl,\n\t\t\t\t\tX86_TRANSFER_TASK_SWITCH, NULL);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\tret = __load_segment_descriptor(ctxt, tss->ss, VCPU_SREG_SS, cpl,\n\t\t\t\t\tX86_TRANSFER_TASK_SWITCH, NULL);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\tret = __load_segment_descriptor(ctxt, tss->ds, VCPU_SREG_DS, cpl,\n\t\t\t\t\tX86_TRANSFER_TASK_SWITCH, NULL);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\n\treturn X86EMUL_CONTINUE;\n}"
  },
  {
    "function_name": "save_state_to_tss16",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "2887-2906",
    "snippet": "static void save_state_to_tss16(struct x86_emulate_ctxt *ctxt,\n\t\t\t\tstruct tss_segment_16 *tss)\n{\n\ttss->ip = ctxt->_eip;\n\ttss->flag = ctxt->eflags;\n\ttss->ax = reg_read(ctxt, VCPU_REGS_RAX);\n\ttss->cx = reg_read(ctxt, VCPU_REGS_RCX);\n\ttss->dx = reg_read(ctxt, VCPU_REGS_RDX);\n\ttss->bx = reg_read(ctxt, VCPU_REGS_RBX);\n\ttss->sp = reg_read(ctxt, VCPU_REGS_RSP);\n\ttss->bp = reg_read(ctxt, VCPU_REGS_RBP);\n\ttss->si = reg_read(ctxt, VCPU_REGS_RSI);\n\ttss->di = reg_read(ctxt, VCPU_REGS_RDI);\n\n\ttss->es = get_segment_selector(ctxt, VCPU_SREG_ES);\n\ttss->cs = get_segment_selector(ctxt, VCPU_SREG_CS);\n\ttss->ss = get_segment_selector(ctxt, VCPU_SREG_SS);\n\ttss->ds = get_segment_selector(ctxt, VCPU_SREG_DS);\n\ttss->ldt = get_segment_selector(ctxt, VCPU_SREG_LDTR);\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_segment_selector",
          "args": [
            "ctxt",
            "VCPU_SREG_LDTR"
          ],
          "line": 2905
        },
        "resolved": true,
        "details": {
          "function_name": "get_segment_selector",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "610-617",
          "snippet": "static u16 get_segment_selector(struct x86_emulate_ctxt *ctxt, unsigned seg)\n{\n\tu16 selector;\n\tstruct desc_struct desc;\n\n\tctxt->ops->get_segment(ctxt, &selector, &desc, NULL, seg);\n\treturn selector;\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic u16 get_segment_selector(struct x86_emulate_ctxt *ctxt, unsigned seg)\n{\n\tu16 selector;\n\tstruct desc_struct desc;\n\n\tctxt->ops->get_segment(ctxt, &selector, &desc, NULL, seg);\n\treturn selector;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reg_read",
          "args": [
            "ctxt",
            "VCPU_REGS_RDI"
          ],
          "line": 2899
        },
        "resolved": true,
        "details": {
          "function_name": "reg_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "261-268",
          "snippet": "static ulong reg_read(struct x86_emulate_ctxt *ctxt, unsigned nr)\n{\n\tif (!(ctxt->regs_valid & (1 << nr))) {\n\t\tctxt->regs_valid |= 1 << nr;\n\t\tctxt->_regs[nr] = ctxt->ops->read_gpr(ctxt, nr);\n\t}\n\treturn ctxt->_regs[nr];\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic ulong reg_read(struct x86_emulate_ctxt *ctxt, unsigned nr)\n{\n\tif (!(ctxt->regs_valid & (1 << nr))) {\n\t\tctxt->regs_valid |= 1 << nr;\n\t\tctxt->_regs[nr] = ctxt->ops->read_gpr(ctxt, nr);\n\t}\n\treturn ctxt->_regs[nr];\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic void save_state_to_tss16(struct x86_emulate_ctxt *ctxt,\n\t\t\t\tstruct tss_segment_16 *tss)\n{\n\ttss->ip = ctxt->_eip;\n\ttss->flag = ctxt->eflags;\n\ttss->ax = reg_read(ctxt, VCPU_REGS_RAX);\n\ttss->cx = reg_read(ctxt, VCPU_REGS_RCX);\n\ttss->dx = reg_read(ctxt, VCPU_REGS_RDX);\n\ttss->bx = reg_read(ctxt, VCPU_REGS_RBX);\n\ttss->sp = reg_read(ctxt, VCPU_REGS_RSP);\n\ttss->bp = reg_read(ctxt, VCPU_REGS_RBP);\n\ttss->si = reg_read(ctxt, VCPU_REGS_RSI);\n\ttss->di = reg_read(ctxt, VCPU_REGS_RDI);\n\n\ttss->es = get_segment_selector(ctxt, VCPU_SREG_ES);\n\ttss->cs = get_segment_selector(ctxt, VCPU_SREG_CS);\n\ttss->ss = get_segment_selector(ctxt, VCPU_SREG_SS);\n\ttss->ds = get_segment_selector(ctxt, VCPU_SREG_DS);\n\ttss->ldt = get_segment_selector(ctxt, VCPU_SREG_LDTR);\n}"
  },
  {
    "function_name": "string_registers_quirk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "2863-2885",
    "snippet": "static void string_registers_quirk(struct x86_emulate_ctxt *ctxt)\n{\n\t/*\n\t * Intel CPUs mask the counter and pointers in quite strange\n\t * manner when ECX is zero due to REP-string optimizations.\n\t */\n#ifdef CONFIG_X86_64\n\tif (ctxt->ad_bytes != 4 || !vendor_intel(ctxt))\n\t\treturn;\n\n\t*reg_write(ctxt, VCPU_REGS_RCX) = 0;\n\n\tswitch (ctxt->b) {\n\tcase 0xa4:\t/* movsb */\n\tcase 0xa5:\t/* movsd/w */\n\t\t*reg_rmw(ctxt, VCPU_REGS_RSI) &= (u32)-1;\n\t\t/* fall through */\n\tcase 0xaa:\t/* stosb */\n\tcase 0xab:\t/* stosd/w */\n\t\t*reg_rmw(ctxt, VCPU_REGS_RDI) &= (u32)-1;\n\t}\n#endif\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reg_rmw",
          "args": [
            "ctxt",
            "VCPU_REGS_RDI"
          ],
          "line": 2882
        },
        "resolved": true,
        "details": {
          "function_name": "reg_rmw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "277-281",
          "snippet": "static ulong *reg_rmw(struct x86_emulate_ctxt *ctxt, unsigned nr)\n{\n\treg_read(ctxt, nr);\n\treturn reg_write(ctxt, nr);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic ulong *reg_rmw(struct x86_emulate_ctxt *ctxt, unsigned nr)\n{\n\treg_read(ctxt, nr);\n\treturn reg_write(ctxt, nr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reg_write",
          "args": [
            "ctxt",
            "VCPU_REGS_RCX"
          ],
          "line": 2873
        },
        "resolved": true,
        "details": {
          "function_name": "reg_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "270-275",
          "snippet": "static ulong *reg_write(struct x86_emulate_ctxt *ctxt, unsigned nr)\n{\n\tctxt->regs_valid |= 1 << nr;\n\tctxt->regs_dirty |= 1 << nr;\n\treturn &ctxt->_regs[nr];\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic ulong *reg_write(struct x86_emulate_ctxt *ctxt, unsigned nr)\n{\n\tctxt->regs_valid |= 1 << nr;\n\tctxt->regs_dirty |= 1 << nr;\n\treturn &ctxt->_regs[nr];\n}"
        }
      },
      {
        "call_info": {
          "callee": "vendor_intel",
          "args": [
            "ctxt"
          ],
          "line": 2870
        },
        "resolved": true,
        "details": {
          "function_name": "vendor_intel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "2579-2588",
          "snippet": "static bool vendor_intel(struct x86_emulate_ctxt *ctxt)\n{\n\tu32 eax, ebx, ecx, edx;\n\n\teax = ecx = 0;\n\tctxt->ops->get_cpuid(ctxt, &eax, &ebx, &ecx, &edx);\n\treturn ebx == X86EMUL_CPUID_VENDOR_GenuineIntel_ebx\n\t\t&& ecx == X86EMUL_CPUID_VENDOR_GenuineIntel_ecx\n\t\t&& edx == X86EMUL_CPUID_VENDOR_GenuineIntel_edx;\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic bool vendor_intel(struct x86_emulate_ctxt *ctxt)\n{\n\tu32 eax, ebx, ecx, edx;\n\n\teax = ecx = 0;\n\tctxt->ops->get_cpuid(ctxt, &eax, &ebx, &ecx, &edx);\n\treturn ebx == X86EMUL_CPUID_VENDOR_GenuineIntel_ebx\n\t\t&& ecx == X86EMUL_CPUID_VENDOR_GenuineIntel_ecx\n\t\t&& edx == X86EMUL_CPUID_VENDOR_GenuineIntel_edx;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic void string_registers_quirk(struct x86_emulate_ctxt *ctxt)\n{\n\t/*\n\t * Intel CPUs mask the counter and pointers in quite strange\n\t * manner when ECX is zero due to REP-string optimizations.\n\t */\n#ifdef CONFIG_X86_64\n\tif (ctxt->ad_bytes != 4 || !vendor_intel(ctxt))\n\t\treturn;\n\n\t*reg_write(ctxt, VCPU_REGS_RCX) = 0;\n\n\tswitch (ctxt->b) {\n\tcase 0xa4:\t/* movsb */\n\tcase 0xa5:\t/* movsd/w */\n\t\t*reg_rmw(ctxt, VCPU_REGS_RSI) &= (u32)-1;\n\t\t/* fall through */\n\tcase 0xaa:\t/* stosb */\n\tcase 0xab:\t/* stosd/w */\n\t\t*reg_rmw(ctxt, VCPU_REGS_RDI) &= (u32)-1;\n\t}\n#endif\n}"
  },
  {
    "function_name": "emulator_io_permited",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "2848-2861",
    "snippet": "static bool emulator_io_permited(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t u16 port, u16 len)\n{\n\tif (ctxt->perm_ok)\n\t\treturn true;\n\n\tif (emulator_bad_iopl(ctxt))\n\t\tif (!emulator_io_port_access_allowed(ctxt, port, len))\n\t\t\treturn false;\n\n\tctxt->perm_ok = true;\n\n\treturn true;\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "emulator_io_port_access_allowed",
          "args": [
            "ctxt",
            "port",
            "len"
          ],
          "line": 2855
        },
        "resolved": true,
        "details": {
          "function_name": "emulator_io_port_access_allowed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "2815-2846",
          "snippet": "static bool emulator_io_port_access_allowed(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t\t    u16 port, u16 len)\n{\n\tconst struct x86_emulate_ops *ops = ctxt->ops;\n\tstruct desc_struct tr_seg;\n\tu32 base3;\n\tint r;\n\tu16 tr, io_bitmap_ptr, perm, bit_idx = port & 0x7;\n\tunsigned mask = (1 << len) - 1;\n\tunsigned long base;\n\n\tops->get_segment(ctxt, &tr, &tr_seg, &base3, VCPU_SREG_TR);\n\tif (!tr_seg.p)\n\t\treturn false;\n\tif (desc_limit_scaled(&tr_seg) < 103)\n\t\treturn false;\n\tbase = get_desc_base(&tr_seg);\n#ifdef CONFIG_X86_64\n\tbase |= ((u64)base3) << 32;\n#endif\n\tr = ops->read_std(ctxt, base + 102, &io_bitmap_ptr, 2, NULL);\n\tif (r != X86EMUL_CONTINUE)\n\t\treturn false;\n\tif (io_bitmap_ptr + port/8 > desc_limit_scaled(&tr_seg))\n\t\treturn false;\n\tr = ops->read_std(ctxt, base + io_bitmap_ptr + port/8, &perm, 2, NULL);\n\tif (r != X86EMUL_CONTINUE)\n\t\treturn false;\n\tif ((perm >> bit_idx) & mask)\n\t\treturn false;\n\treturn true;\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic bool emulator_io_port_access_allowed(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t\t    u16 port, u16 len)\n{\n\tconst struct x86_emulate_ops *ops = ctxt->ops;\n\tstruct desc_struct tr_seg;\n\tu32 base3;\n\tint r;\n\tu16 tr, io_bitmap_ptr, perm, bit_idx = port & 0x7;\n\tunsigned mask = (1 << len) - 1;\n\tunsigned long base;\n\n\tops->get_segment(ctxt, &tr, &tr_seg, &base3, VCPU_SREG_TR);\n\tif (!tr_seg.p)\n\t\treturn false;\n\tif (desc_limit_scaled(&tr_seg) < 103)\n\t\treturn false;\n\tbase = get_desc_base(&tr_seg);\n#ifdef CONFIG_X86_64\n\tbase |= ((u64)base3) << 32;\n#endif\n\tr = ops->read_std(ctxt, base + 102, &io_bitmap_ptr, 2, NULL);\n\tif (r != X86EMUL_CONTINUE)\n\t\treturn false;\n\tif (io_bitmap_ptr + port/8 > desc_limit_scaled(&tr_seg))\n\t\treturn false;\n\tr = ops->read_std(ctxt, base + io_bitmap_ptr + port/8, &perm, 2, NULL);\n\tif (r != X86EMUL_CONTINUE)\n\t\treturn false;\n\tif ((perm >> bit_idx) & mask)\n\t\treturn false;\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "emulator_bad_iopl",
          "args": [
            "ctxt"
          ],
          "line": 2854
        },
        "resolved": true,
        "details": {
          "function_name": "emulator_bad_iopl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "2804-2813",
          "snippet": "static bool emulator_bad_iopl(struct x86_emulate_ctxt *ctxt)\n{\n\tint iopl;\n\tif (ctxt->mode == X86EMUL_MODE_REAL)\n\t\treturn false;\n\tif (ctxt->mode == X86EMUL_MODE_VM86)\n\t\treturn true;\n\tiopl = (ctxt->eflags & X86_EFLAGS_IOPL) >> X86_EFLAGS_IOPL_BIT;\n\treturn ctxt->ops->cpl(ctxt) > iopl;\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic bool emulator_bad_iopl(struct x86_emulate_ctxt *ctxt)\n{\n\tint iopl;\n\tif (ctxt->mode == X86EMUL_MODE_REAL)\n\t\treturn false;\n\tif (ctxt->mode == X86EMUL_MODE_VM86)\n\t\treturn true;\n\tiopl = (ctxt->eflags & X86_EFLAGS_IOPL) >> X86_EFLAGS_IOPL_BIT;\n\treturn ctxt->ops->cpl(ctxt) > iopl;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic bool emulator_io_permited(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t u16 port, u16 len)\n{\n\tif (ctxt->perm_ok)\n\t\treturn true;\n\n\tif (emulator_bad_iopl(ctxt))\n\t\tif (!emulator_io_port_access_allowed(ctxt, port, len))\n\t\t\treturn false;\n\n\tctxt->perm_ok = true;\n\n\treturn true;\n}"
  },
  {
    "function_name": "emulator_io_port_access_allowed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "2815-2846",
    "snippet": "static bool emulator_io_port_access_allowed(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t\t    u16 port, u16 len)\n{\n\tconst struct x86_emulate_ops *ops = ctxt->ops;\n\tstruct desc_struct tr_seg;\n\tu32 base3;\n\tint r;\n\tu16 tr, io_bitmap_ptr, perm, bit_idx = port & 0x7;\n\tunsigned mask = (1 << len) - 1;\n\tunsigned long base;\n\n\tops->get_segment(ctxt, &tr, &tr_seg, &base3, VCPU_SREG_TR);\n\tif (!tr_seg.p)\n\t\treturn false;\n\tif (desc_limit_scaled(&tr_seg) < 103)\n\t\treturn false;\n\tbase = get_desc_base(&tr_seg);\n#ifdef CONFIG_X86_64\n\tbase |= ((u64)base3) << 32;\n#endif\n\tr = ops->read_std(ctxt, base + 102, &io_bitmap_ptr, 2, NULL);\n\tif (r != X86EMUL_CONTINUE)\n\t\treturn false;\n\tif (io_bitmap_ptr + port/8 > desc_limit_scaled(&tr_seg))\n\t\treturn false;\n\tr = ops->read_std(ctxt, base + io_bitmap_ptr + port/8, &perm, 2, NULL);\n\tif (r != X86EMUL_CONTINUE)\n\t\treturn false;\n\tif ((perm >> bit_idx) & mask)\n\t\treturn false;\n\treturn true;\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ops->read_std",
          "args": [
            "ctxt",
            "base + io_bitmap_ptr + port/8",
            "&perm",
            "2",
            "NULL"
          ],
          "line": 2840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "desc_limit_scaled",
          "args": [
            "&tr_seg"
          ],
          "line": 2838
        },
        "resolved": true,
        "details": {
          "function_name": "desc_limit_scaled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "550-555",
          "snippet": "static u32 desc_limit_scaled(struct desc_struct *desc)\n{\n\tu32 limit = get_desc_limit(desc);\n\n\treturn desc->g ? (limit << 12) | 0xfff : limit;\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic u32 desc_limit_scaled(struct desc_struct *desc)\n{\n\tu32 limit = get_desc_limit(desc);\n\n\treturn desc->g ? (limit << 12) | 0xfff : limit;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ops->read_std",
          "args": [
            "ctxt",
            "base + 102",
            "&io_bitmap_ptr",
            "2",
            "NULL"
          ],
          "line": 2835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_desc_base",
          "args": [
            "&tr_seg"
          ],
          "line": 2831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ops->get_segment",
          "args": [
            "ctxt",
            "&tr",
            "&tr_seg",
            "&base3",
            "VCPU_SREG_TR"
          ],
          "line": 2826
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic bool emulator_io_port_access_allowed(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t\t    u16 port, u16 len)\n{\n\tconst struct x86_emulate_ops *ops = ctxt->ops;\n\tstruct desc_struct tr_seg;\n\tu32 base3;\n\tint r;\n\tu16 tr, io_bitmap_ptr, perm, bit_idx = port & 0x7;\n\tunsigned mask = (1 << len) - 1;\n\tunsigned long base;\n\n\tops->get_segment(ctxt, &tr, &tr_seg, &base3, VCPU_SREG_TR);\n\tif (!tr_seg.p)\n\t\treturn false;\n\tif (desc_limit_scaled(&tr_seg) < 103)\n\t\treturn false;\n\tbase = get_desc_base(&tr_seg);\n#ifdef CONFIG_X86_64\n\tbase |= ((u64)base3) << 32;\n#endif\n\tr = ops->read_std(ctxt, base + 102, &io_bitmap_ptr, 2, NULL);\n\tif (r != X86EMUL_CONTINUE)\n\t\treturn false;\n\tif (io_bitmap_ptr + port/8 > desc_limit_scaled(&tr_seg))\n\t\treturn false;\n\tr = ops->read_std(ctxt, base + io_bitmap_ptr + port/8, &perm, 2, NULL);\n\tif (r != X86EMUL_CONTINUE)\n\t\treturn false;\n\tif ((perm >> bit_idx) & mask)\n\t\treturn false;\n\treturn true;\n}"
  },
  {
    "function_name": "emulator_bad_iopl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "2804-2813",
    "snippet": "static bool emulator_bad_iopl(struct x86_emulate_ctxt *ctxt)\n{\n\tint iopl;\n\tif (ctxt->mode == X86EMUL_MODE_REAL)\n\t\treturn false;\n\tif (ctxt->mode == X86EMUL_MODE_VM86)\n\t\treturn true;\n\tiopl = (ctxt->eflags & X86_EFLAGS_IOPL) >> X86_EFLAGS_IOPL_BIT;\n\treturn ctxt->ops->cpl(ctxt) > iopl;\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ctxt->ops->cpl",
          "args": [
            "ctxt"
          ],
          "line": 2812
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic bool emulator_bad_iopl(struct x86_emulate_ctxt *ctxt)\n{\n\tint iopl;\n\tif (ctxt->mode == X86EMUL_MODE_REAL)\n\t\treturn false;\n\tif (ctxt->mode == X86EMUL_MODE_VM86)\n\t\treturn true;\n\tiopl = (ctxt->eflags & X86_EFLAGS_IOPL) >> X86_EFLAGS_IOPL_BIT;\n\treturn ctxt->ops->cpl(ctxt) > iopl;\n}"
  },
  {
    "function_name": "em_sysexit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "2745-2802",
    "snippet": "static int em_sysexit(struct x86_emulate_ctxt *ctxt)\n{\n\tconst struct x86_emulate_ops *ops = ctxt->ops;\n\tstruct desc_struct cs, ss;\n\tu64 msr_data, rcx, rdx;\n\tint usermode;\n\tu16 cs_sel = 0, ss_sel = 0;\n\n\t/* inject #GP if in real mode or Virtual 8086 mode */\n\tif (ctxt->mode == X86EMUL_MODE_REAL ||\n\t    ctxt->mode == X86EMUL_MODE_VM86)\n\t\treturn emulate_gp(ctxt, 0);\n\n\tsetup_syscalls_segments(ctxt, &cs, &ss);\n\n\tif ((ctxt->rex_prefix & 0x8) != 0x0)\n\t\tusermode = X86EMUL_MODE_PROT64;\n\telse\n\t\tusermode = X86EMUL_MODE_PROT32;\n\n\trcx = reg_read(ctxt, VCPU_REGS_RCX);\n\trdx = reg_read(ctxt, VCPU_REGS_RDX);\n\n\tcs.dpl = 3;\n\tss.dpl = 3;\n\tops->get_msr(ctxt, MSR_IA32_SYSENTER_CS, &msr_data);\n\tswitch (usermode) {\n\tcase X86EMUL_MODE_PROT32:\n\t\tcs_sel = (u16)(msr_data + 16);\n\t\tif ((msr_data & 0xfffc) == 0x0)\n\t\t\treturn emulate_gp(ctxt, 0);\n\t\tss_sel = (u16)(msr_data + 24);\n\t\trcx = (u32)rcx;\n\t\trdx = (u32)rdx;\n\t\tbreak;\n\tcase X86EMUL_MODE_PROT64:\n\t\tcs_sel = (u16)(msr_data + 32);\n\t\tif (msr_data == 0x0)\n\t\t\treturn emulate_gp(ctxt, 0);\n\t\tss_sel = cs_sel + 8;\n\t\tcs.d = 0;\n\t\tcs.l = 1;\n\t\tif (is_noncanonical_address(rcx) ||\n\t\t    is_noncanonical_address(rdx))\n\t\t\treturn emulate_gp(ctxt, 0);\n\t\tbreak;\n\t}\n\tcs_sel |= SEGMENT_RPL_MASK;\n\tss_sel |= SEGMENT_RPL_MASK;\n\n\tops->set_segment(ctxt, cs_sel, &cs, 0, VCPU_SREG_CS);\n\tops->set_segment(ctxt, ss_sel, &ss, 0, VCPU_SREG_SS);\n\n\tctxt->_eip = rdx;\n\t*reg_write(ctxt, VCPU_REGS_RSP) = rcx;\n\n\treturn X86EMUL_CONTINUE;\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reg_write",
          "args": [
            "ctxt",
            "VCPU_REGS_RSP"
          ],
          "line": 2799
        },
        "resolved": true,
        "details": {
          "function_name": "reg_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "270-275",
          "snippet": "static ulong *reg_write(struct x86_emulate_ctxt *ctxt, unsigned nr)\n{\n\tctxt->regs_valid |= 1 << nr;\n\tctxt->regs_dirty |= 1 << nr;\n\treturn &ctxt->_regs[nr];\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic ulong *reg_write(struct x86_emulate_ctxt *ctxt, unsigned nr)\n{\n\tctxt->regs_valid |= 1 << nr;\n\tctxt->regs_dirty |= 1 << nr;\n\treturn &ctxt->_regs[nr];\n}"
        }
      },
      {
        "call_info": {
          "callee": "ops->set_segment",
          "args": [
            "ctxt",
            "ss_sel",
            "&ss",
            "0",
            "VCPU_SREG_SS"
          ],
          "line": 2796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ops->set_segment",
          "args": [
            "ctxt",
            "cs_sel",
            "&cs",
            "0",
            "VCPU_SREG_CS"
          ],
          "line": 2795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "emulate_gp",
          "args": [
            "ctxt",
            "0"
          ],
          "line": 2789
        },
        "resolved": true,
        "details": {
          "function_name": "emulate_gp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "580-583",
          "snippet": "static int emulate_gp(struct x86_emulate_ctxt *ctxt, int err)\n{\n\treturn emulate_exception(ctxt, GP_VECTOR, err, true);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int emulate_gp(struct x86_emulate_ctxt *ctxt, int err)\n{\n\treturn emulate_exception(ctxt, GP_VECTOR, err, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_noncanonical_address",
          "args": [
            "rdx"
          ],
          "line": 2788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_noncanonical_address",
          "args": [
            "rcx"
          ],
          "line": 2787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "msr_data + 32"
          ],
          "line": 2781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "msr_data + 24"
          ],
          "line": 2776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "msr_data + 16"
          ],
          "line": 2773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ops->get_msr",
          "args": [
            "ctxt",
            "MSR_IA32_SYSENTER_CS",
            "&msr_data"
          ],
          "line": 2770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reg_read",
          "args": [
            "ctxt",
            "VCPU_REGS_RDX"
          ],
          "line": 2766
        },
        "resolved": true,
        "details": {
          "function_name": "reg_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "261-268",
          "snippet": "static ulong reg_read(struct x86_emulate_ctxt *ctxt, unsigned nr)\n{\n\tif (!(ctxt->regs_valid & (1 << nr))) {\n\t\tctxt->regs_valid |= 1 << nr;\n\t\tctxt->_regs[nr] = ctxt->ops->read_gpr(ctxt, nr);\n\t}\n\treturn ctxt->_regs[nr];\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic ulong reg_read(struct x86_emulate_ctxt *ctxt, unsigned nr)\n{\n\tif (!(ctxt->regs_valid & (1 << nr))) {\n\t\tctxt->regs_valid |= 1 << nr;\n\t\tctxt->_regs[nr] = ctxt->ops->read_gpr(ctxt, nr);\n\t}\n\treturn ctxt->_regs[nr];\n}"
        }
      },
      {
        "call_info": {
          "callee": "setup_syscalls_segments",
          "args": [
            "ctxt",
            "&cs",
            "&ss"
          ],
          "line": 2758
        },
        "resolved": true,
        "details": {
          "function_name": "setup_syscalls_segments",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "2552-2577",
          "snippet": "static void\nsetup_syscalls_segments(struct x86_emulate_ctxt *ctxt,\n\t\t\tstruct desc_struct *cs, struct desc_struct *ss)\n{\n\tcs->l = 0;\t\t/* will be adjusted later */\n\tset_desc_base(cs, 0);\t/* flat segment */\n\tcs->g = 1;\t\t/* 4kb granularity */\n\tset_desc_limit(cs, 0xfffff);\t/* 4GB limit */\n\tcs->type = 0x0b;\t/* Read, Execute, Accessed */\n\tcs->s = 1;\n\tcs->dpl = 0;\t\t/* will be adjusted later */\n\tcs->p = 1;\n\tcs->d = 1;\n\tcs->avl = 0;\n\n\tset_desc_base(ss, 0);\t/* flat segment */\n\tset_desc_limit(ss, 0xfffff);\t/* 4GB limit */\n\tss->g = 1;\t\t/* 4kb granularity */\n\tss->s = 1;\n\tss->type = 0x03;\t/* Read/Write, Accessed */\n\tss->d = 1;\t\t/* 32bit stack segment */\n\tss->dpl = 0;\n\tss->p = 1;\n\tss->l = 0;\n\tss->avl = 0;\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic void\nsetup_syscalls_segments(struct x86_emulate_ctxt *ctxt,\n\t\t\tstruct desc_struct *cs, struct desc_struct *ss)\n{\n\tcs->l = 0;\t\t/* will be adjusted later */\n\tset_desc_base(cs, 0);\t/* flat segment */\n\tcs->g = 1;\t\t/* 4kb granularity */\n\tset_desc_limit(cs, 0xfffff);\t/* 4GB limit */\n\tcs->type = 0x0b;\t/* Read, Execute, Accessed */\n\tcs->s = 1;\n\tcs->dpl = 0;\t\t/* will be adjusted later */\n\tcs->p = 1;\n\tcs->d = 1;\n\tcs->avl = 0;\n\n\tset_desc_base(ss, 0);\t/* flat segment */\n\tset_desc_limit(ss, 0xfffff);\t/* 4GB limit */\n\tss->g = 1;\t\t/* 4kb granularity */\n\tss->s = 1;\n\tss->type = 0x03;\t/* Read/Write, Accessed */\n\tss->d = 1;\t\t/* 32bit stack segment */\n\tss->dpl = 0;\n\tss->p = 1;\n\tss->l = 0;\n\tss->avl = 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int em_sysexit(struct x86_emulate_ctxt *ctxt)\n{\n\tconst struct x86_emulate_ops *ops = ctxt->ops;\n\tstruct desc_struct cs, ss;\n\tu64 msr_data, rcx, rdx;\n\tint usermode;\n\tu16 cs_sel = 0, ss_sel = 0;\n\n\t/* inject #GP if in real mode or Virtual 8086 mode */\n\tif (ctxt->mode == X86EMUL_MODE_REAL ||\n\t    ctxt->mode == X86EMUL_MODE_VM86)\n\t\treturn emulate_gp(ctxt, 0);\n\n\tsetup_syscalls_segments(ctxt, &cs, &ss);\n\n\tif ((ctxt->rex_prefix & 0x8) != 0x0)\n\t\tusermode = X86EMUL_MODE_PROT64;\n\telse\n\t\tusermode = X86EMUL_MODE_PROT32;\n\n\trcx = reg_read(ctxt, VCPU_REGS_RCX);\n\trdx = reg_read(ctxt, VCPU_REGS_RDX);\n\n\tcs.dpl = 3;\n\tss.dpl = 3;\n\tops->get_msr(ctxt, MSR_IA32_SYSENTER_CS, &msr_data);\n\tswitch (usermode) {\n\tcase X86EMUL_MODE_PROT32:\n\t\tcs_sel = (u16)(msr_data + 16);\n\t\tif ((msr_data & 0xfffc) == 0x0)\n\t\t\treturn emulate_gp(ctxt, 0);\n\t\tss_sel = (u16)(msr_data + 24);\n\t\trcx = (u32)rcx;\n\t\trdx = (u32)rdx;\n\t\tbreak;\n\tcase X86EMUL_MODE_PROT64:\n\t\tcs_sel = (u16)(msr_data + 32);\n\t\tif (msr_data == 0x0)\n\t\t\treturn emulate_gp(ctxt, 0);\n\t\tss_sel = cs_sel + 8;\n\t\tcs.d = 0;\n\t\tcs.l = 1;\n\t\tif (is_noncanonical_address(rcx) ||\n\t\t    is_noncanonical_address(rdx))\n\t\t\treturn emulate_gp(ctxt, 0);\n\t\tbreak;\n\t}\n\tcs_sel |= SEGMENT_RPL_MASK;\n\tss_sel |= SEGMENT_RPL_MASK;\n\n\tops->set_segment(ctxt, cs_sel, &cs, 0, VCPU_SREG_CS);\n\tops->set_segment(ctxt, ss_sel, &ss, 0, VCPU_SREG_SS);\n\n\tctxt->_eip = rdx;\n\t*reg_write(ctxt, VCPU_REGS_RSP) = rcx;\n\n\treturn X86EMUL_CONTINUE;\n}"
  },
  {
    "function_name": "em_sysenter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "2693-2743",
    "snippet": "static int em_sysenter(struct x86_emulate_ctxt *ctxt)\n{\n\tconst struct x86_emulate_ops *ops = ctxt->ops;\n\tstruct desc_struct cs, ss;\n\tu64 msr_data;\n\tu16 cs_sel, ss_sel;\n\tu64 efer = 0;\n\n\tops->get_msr(ctxt, MSR_EFER, &efer);\n\t/* inject #GP if in real mode */\n\tif (ctxt->mode == X86EMUL_MODE_REAL)\n\t\treturn emulate_gp(ctxt, 0);\n\n\t/*\n\t * Not recognized on AMD in compat mode (but is recognized in legacy\n\t * mode).\n\t */\n\tif ((ctxt->mode != X86EMUL_MODE_PROT64) && (efer & EFER_LMA)\n\t    && !vendor_intel(ctxt))\n\t\treturn emulate_ud(ctxt);\n\n\t/* sysenter/sysexit have not been tested in 64bit mode. */\n\tif (ctxt->mode == X86EMUL_MODE_PROT64)\n\t\treturn X86EMUL_UNHANDLEABLE;\n\n\tsetup_syscalls_segments(ctxt, &cs, &ss);\n\n\tops->get_msr(ctxt, MSR_IA32_SYSENTER_CS, &msr_data);\n\tif ((msr_data & 0xfffc) == 0x0)\n\t\treturn emulate_gp(ctxt, 0);\n\n\tctxt->eflags &= ~(X86_EFLAGS_VM | X86_EFLAGS_IF);\n\tcs_sel = (u16)msr_data & ~SEGMENT_RPL_MASK;\n\tss_sel = cs_sel + 8;\n\tif (efer & EFER_LMA) {\n\t\tcs.d = 0;\n\t\tcs.l = 1;\n\t}\n\n\tops->set_segment(ctxt, cs_sel, &cs, 0, VCPU_SREG_CS);\n\tops->set_segment(ctxt, ss_sel, &ss, 0, VCPU_SREG_SS);\n\n\tops->get_msr(ctxt, MSR_IA32_SYSENTER_EIP, &msr_data);\n\tctxt->_eip = (efer & EFER_LMA) ? msr_data : (u32)msr_data;\n\n\tops->get_msr(ctxt, MSR_IA32_SYSENTER_ESP, &msr_data);\n\t*reg_write(ctxt, VCPU_REGS_RSP) = (efer & EFER_LMA) ? msr_data :\n\t\t\t\t\t\t\t      (u32)msr_data;\n\n\treturn X86EMUL_CONTINUE;\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reg_write",
          "args": [
            "ctxt",
            "VCPU_REGS_RSP"
          ],
          "line": 2739
        },
        "resolved": true,
        "details": {
          "function_name": "reg_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "270-275",
          "snippet": "static ulong *reg_write(struct x86_emulate_ctxt *ctxt, unsigned nr)\n{\n\tctxt->regs_valid |= 1 << nr;\n\tctxt->regs_dirty |= 1 << nr;\n\treturn &ctxt->_regs[nr];\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic ulong *reg_write(struct x86_emulate_ctxt *ctxt, unsigned nr)\n{\n\tctxt->regs_valid |= 1 << nr;\n\tctxt->regs_dirty |= 1 << nr;\n\treturn &ctxt->_regs[nr];\n}"
        }
      },
      {
        "call_info": {
          "callee": "ops->get_msr",
          "args": [
            "ctxt",
            "MSR_IA32_SYSENTER_ESP",
            "&msr_data"
          ],
          "line": 2738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ops->get_msr",
          "args": [
            "ctxt",
            "MSR_IA32_SYSENTER_EIP",
            "&msr_data"
          ],
          "line": 2735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ops->set_segment",
          "args": [
            "ctxt",
            "ss_sel",
            "&ss",
            "0",
            "VCPU_SREG_SS"
          ],
          "line": 2733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ops->set_segment",
          "args": [
            "ctxt",
            "cs_sel",
            "&cs",
            "0",
            "VCPU_SREG_CS"
          ],
          "line": 2732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "emulate_gp",
          "args": [
            "ctxt",
            "0"
          ],
          "line": 2722
        },
        "resolved": true,
        "details": {
          "function_name": "emulate_gp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "580-583",
          "snippet": "static int emulate_gp(struct x86_emulate_ctxt *ctxt, int err)\n{\n\treturn emulate_exception(ctxt, GP_VECTOR, err, true);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int emulate_gp(struct x86_emulate_ctxt *ctxt, int err)\n{\n\treturn emulate_exception(ctxt, GP_VECTOR, err, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ops->get_msr",
          "args": [
            "ctxt",
            "MSR_IA32_SYSENTER_CS",
            "&msr_data"
          ],
          "line": 2720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setup_syscalls_segments",
          "args": [
            "ctxt",
            "&cs",
            "&ss"
          ],
          "line": 2718
        },
        "resolved": true,
        "details": {
          "function_name": "setup_syscalls_segments",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "2552-2577",
          "snippet": "static void\nsetup_syscalls_segments(struct x86_emulate_ctxt *ctxt,\n\t\t\tstruct desc_struct *cs, struct desc_struct *ss)\n{\n\tcs->l = 0;\t\t/* will be adjusted later */\n\tset_desc_base(cs, 0);\t/* flat segment */\n\tcs->g = 1;\t\t/* 4kb granularity */\n\tset_desc_limit(cs, 0xfffff);\t/* 4GB limit */\n\tcs->type = 0x0b;\t/* Read, Execute, Accessed */\n\tcs->s = 1;\n\tcs->dpl = 0;\t\t/* will be adjusted later */\n\tcs->p = 1;\n\tcs->d = 1;\n\tcs->avl = 0;\n\n\tset_desc_base(ss, 0);\t/* flat segment */\n\tset_desc_limit(ss, 0xfffff);\t/* 4GB limit */\n\tss->g = 1;\t\t/* 4kb granularity */\n\tss->s = 1;\n\tss->type = 0x03;\t/* Read/Write, Accessed */\n\tss->d = 1;\t\t/* 32bit stack segment */\n\tss->dpl = 0;\n\tss->p = 1;\n\tss->l = 0;\n\tss->avl = 0;\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic void\nsetup_syscalls_segments(struct x86_emulate_ctxt *ctxt,\n\t\t\tstruct desc_struct *cs, struct desc_struct *ss)\n{\n\tcs->l = 0;\t\t/* will be adjusted later */\n\tset_desc_base(cs, 0);\t/* flat segment */\n\tcs->g = 1;\t\t/* 4kb granularity */\n\tset_desc_limit(cs, 0xfffff);\t/* 4GB limit */\n\tcs->type = 0x0b;\t/* Read, Execute, Accessed */\n\tcs->s = 1;\n\tcs->dpl = 0;\t\t/* will be adjusted later */\n\tcs->p = 1;\n\tcs->d = 1;\n\tcs->avl = 0;\n\n\tset_desc_base(ss, 0);\t/* flat segment */\n\tset_desc_limit(ss, 0xfffff);\t/* 4GB limit */\n\tss->g = 1;\t\t/* 4kb granularity */\n\tss->s = 1;\n\tss->type = 0x03;\t/* Read/Write, Accessed */\n\tss->d = 1;\t\t/* 32bit stack segment */\n\tss->dpl = 0;\n\tss->p = 1;\n\tss->l = 0;\n\tss->avl = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "emulate_ud",
          "args": [
            "ctxt"
          ],
          "line": 2712
        },
        "resolved": true,
        "details": {
          "function_name": "emulate_ud",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "590-593",
          "snippet": "static int emulate_ud(struct x86_emulate_ctxt *ctxt)\n{\n\treturn emulate_exception(ctxt, UD_VECTOR, 0, false);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int emulate_ud(struct x86_emulate_ctxt *ctxt)\n{\n\treturn emulate_exception(ctxt, UD_VECTOR, 0, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vendor_intel",
          "args": [
            "ctxt"
          ],
          "line": 2711
        },
        "resolved": true,
        "details": {
          "function_name": "vendor_intel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "2579-2588",
          "snippet": "static bool vendor_intel(struct x86_emulate_ctxt *ctxt)\n{\n\tu32 eax, ebx, ecx, edx;\n\n\teax = ecx = 0;\n\tctxt->ops->get_cpuid(ctxt, &eax, &ebx, &ecx, &edx);\n\treturn ebx == X86EMUL_CPUID_VENDOR_GenuineIntel_ebx\n\t\t&& ecx == X86EMUL_CPUID_VENDOR_GenuineIntel_ecx\n\t\t&& edx == X86EMUL_CPUID_VENDOR_GenuineIntel_edx;\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic bool vendor_intel(struct x86_emulate_ctxt *ctxt)\n{\n\tu32 eax, ebx, ecx, edx;\n\n\teax = ecx = 0;\n\tctxt->ops->get_cpuid(ctxt, &eax, &ebx, &ecx, &edx);\n\treturn ebx == X86EMUL_CPUID_VENDOR_GenuineIntel_ebx\n\t\t&& ecx == X86EMUL_CPUID_VENDOR_GenuineIntel_ecx\n\t\t&& edx == X86EMUL_CPUID_VENDOR_GenuineIntel_edx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ops->get_msr",
          "args": [
            "ctxt",
            "MSR_EFER",
            "&efer"
          ],
          "line": 2701
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int em_sysenter(struct x86_emulate_ctxt *ctxt)\n{\n\tconst struct x86_emulate_ops *ops = ctxt->ops;\n\tstruct desc_struct cs, ss;\n\tu64 msr_data;\n\tu16 cs_sel, ss_sel;\n\tu64 efer = 0;\n\n\tops->get_msr(ctxt, MSR_EFER, &efer);\n\t/* inject #GP if in real mode */\n\tif (ctxt->mode == X86EMUL_MODE_REAL)\n\t\treturn emulate_gp(ctxt, 0);\n\n\t/*\n\t * Not recognized on AMD in compat mode (but is recognized in legacy\n\t * mode).\n\t */\n\tif ((ctxt->mode != X86EMUL_MODE_PROT64) && (efer & EFER_LMA)\n\t    && !vendor_intel(ctxt))\n\t\treturn emulate_ud(ctxt);\n\n\t/* sysenter/sysexit have not been tested in 64bit mode. */\n\tif (ctxt->mode == X86EMUL_MODE_PROT64)\n\t\treturn X86EMUL_UNHANDLEABLE;\n\n\tsetup_syscalls_segments(ctxt, &cs, &ss);\n\n\tops->get_msr(ctxt, MSR_IA32_SYSENTER_CS, &msr_data);\n\tif ((msr_data & 0xfffc) == 0x0)\n\t\treturn emulate_gp(ctxt, 0);\n\n\tctxt->eflags &= ~(X86_EFLAGS_VM | X86_EFLAGS_IF);\n\tcs_sel = (u16)msr_data & ~SEGMENT_RPL_MASK;\n\tss_sel = cs_sel + 8;\n\tif (efer & EFER_LMA) {\n\t\tcs.d = 0;\n\t\tcs.l = 1;\n\t}\n\n\tops->set_segment(ctxt, cs_sel, &cs, 0, VCPU_SREG_CS);\n\tops->set_segment(ctxt, ss_sel, &ss, 0, VCPU_SREG_SS);\n\n\tops->get_msr(ctxt, MSR_IA32_SYSENTER_EIP, &msr_data);\n\tctxt->_eip = (efer & EFER_LMA) ? msr_data : (u32)msr_data;\n\n\tops->get_msr(ctxt, MSR_IA32_SYSENTER_ESP, &msr_data);\n\t*reg_write(ctxt, VCPU_REGS_RSP) = (efer & EFER_LMA) ? msr_data :\n\t\t\t\t\t\t\t      (u32)msr_data;\n\n\treturn X86EMUL_CONTINUE;\n}"
  },
  {
    "function_name": "em_syscall",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "2634-2691",
    "snippet": "static int em_syscall(struct x86_emulate_ctxt *ctxt)\n{\n\tconst struct x86_emulate_ops *ops = ctxt->ops;\n\tstruct desc_struct cs, ss;\n\tu64 msr_data;\n\tu16 cs_sel, ss_sel;\n\tu64 efer = 0;\n\n\t/* syscall is not available in real mode */\n\tif (ctxt->mode == X86EMUL_MODE_REAL ||\n\t    ctxt->mode == X86EMUL_MODE_VM86)\n\t\treturn emulate_ud(ctxt);\n\n\tif (!(em_syscall_is_enabled(ctxt)))\n\t\treturn emulate_ud(ctxt);\n\n\tops->get_msr(ctxt, MSR_EFER, &efer);\n\tsetup_syscalls_segments(ctxt, &cs, &ss);\n\n\tif (!(efer & EFER_SCE))\n\t\treturn emulate_ud(ctxt);\n\n\tops->get_msr(ctxt, MSR_STAR, &msr_data);\n\tmsr_data >>= 32;\n\tcs_sel = (u16)(msr_data & 0xfffc);\n\tss_sel = (u16)(msr_data + 8);\n\n\tif (efer & EFER_LMA) {\n\t\tcs.d = 0;\n\t\tcs.l = 1;\n\t}\n\tops->set_segment(ctxt, cs_sel, &cs, 0, VCPU_SREG_CS);\n\tops->set_segment(ctxt, ss_sel, &ss, 0, VCPU_SREG_SS);\n\n\t*reg_write(ctxt, VCPU_REGS_RCX) = ctxt->_eip;\n\tif (efer & EFER_LMA) {\n#ifdef CONFIG_X86_64\n\t\t*reg_write(ctxt, VCPU_REGS_R11) = ctxt->eflags;\n\n\t\tops->get_msr(ctxt,\n\t\t\t     ctxt->mode == X86EMUL_MODE_PROT64 ?\n\t\t\t     MSR_LSTAR : MSR_CSTAR, &msr_data);\n\t\tctxt->_eip = msr_data;\n\n\t\tops->get_msr(ctxt, MSR_SYSCALL_MASK, &msr_data);\n\t\tctxt->eflags &= ~msr_data;\n\t\tctxt->eflags |= X86_EFLAGS_FIXED;\n#endif\n\t} else {\n\t\t/* legacy mode */\n\t\tops->get_msr(ctxt, MSR_STAR, &msr_data);\n\t\tctxt->_eip = (u32)msr_data;\n\n\t\tctxt->eflags &= ~(X86_EFLAGS_VM | X86_EFLAGS_IF);\n\t}\n\n\treturn X86EMUL_CONTINUE;\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ops->get_msr",
          "args": [
            "ctxt",
            "MSR_STAR",
            "&msr_data"
          ],
          "line": 2684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ops->get_msr",
          "args": [
            "ctxt",
            "MSR_SYSCALL_MASK",
            "&msr_data"
          ],
          "line": 2678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ops->get_msr",
          "args": [
            "ctxt",
            "ctxt->mode == X86EMUL_MODE_PROT64 ?\n\t\t\t     MSR_LSTAR : MSR_CSTAR",
            "&msr_data"
          ],
          "line": 2673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reg_write",
          "args": [
            "ctxt",
            "VCPU_REGS_R11"
          ],
          "line": 2671
        },
        "resolved": true,
        "details": {
          "function_name": "reg_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "270-275",
          "snippet": "static ulong *reg_write(struct x86_emulate_ctxt *ctxt, unsigned nr)\n{\n\tctxt->regs_valid |= 1 << nr;\n\tctxt->regs_dirty |= 1 << nr;\n\treturn &ctxt->_regs[nr];\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic ulong *reg_write(struct x86_emulate_ctxt *ctxt, unsigned nr)\n{\n\tctxt->regs_valid |= 1 << nr;\n\tctxt->regs_dirty |= 1 << nr;\n\treturn &ctxt->_regs[nr];\n}"
        }
      },
      {
        "call_info": {
          "callee": "ops->set_segment",
          "args": [
            "ctxt",
            "ss_sel",
            "&ss",
            "0",
            "VCPU_SREG_SS"
          ],
          "line": 2666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ops->set_segment",
          "args": [
            "ctxt",
            "cs_sel",
            "&cs",
            "0",
            "VCPU_SREG_CS"
          ],
          "line": 2665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "msr_data + 8"
          ],
          "line": 2659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "msr_data & 0xfffc"
          ],
          "line": 2658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ops->get_msr",
          "args": [
            "ctxt",
            "MSR_STAR",
            "&msr_data"
          ],
          "line": 2656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "emulate_ud",
          "args": [
            "ctxt"
          ],
          "line": 2654
        },
        "resolved": true,
        "details": {
          "function_name": "emulate_ud",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "590-593",
          "snippet": "static int emulate_ud(struct x86_emulate_ctxt *ctxt)\n{\n\treturn emulate_exception(ctxt, UD_VECTOR, 0, false);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int emulate_ud(struct x86_emulate_ctxt *ctxt)\n{\n\treturn emulate_exception(ctxt, UD_VECTOR, 0, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "setup_syscalls_segments",
          "args": [
            "ctxt",
            "&cs",
            "&ss"
          ],
          "line": 2651
        },
        "resolved": true,
        "details": {
          "function_name": "setup_syscalls_segments",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "2552-2577",
          "snippet": "static void\nsetup_syscalls_segments(struct x86_emulate_ctxt *ctxt,\n\t\t\tstruct desc_struct *cs, struct desc_struct *ss)\n{\n\tcs->l = 0;\t\t/* will be adjusted later */\n\tset_desc_base(cs, 0);\t/* flat segment */\n\tcs->g = 1;\t\t/* 4kb granularity */\n\tset_desc_limit(cs, 0xfffff);\t/* 4GB limit */\n\tcs->type = 0x0b;\t/* Read, Execute, Accessed */\n\tcs->s = 1;\n\tcs->dpl = 0;\t\t/* will be adjusted later */\n\tcs->p = 1;\n\tcs->d = 1;\n\tcs->avl = 0;\n\n\tset_desc_base(ss, 0);\t/* flat segment */\n\tset_desc_limit(ss, 0xfffff);\t/* 4GB limit */\n\tss->g = 1;\t\t/* 4kb granularity */\n\tss->s = 1;\n\tss->type = 0x03;\t/* Read/Write, Accessed */\n\tss->d = 1;\t\t/* 32bit stack segment */\n\tss->dpl = 0;\n\tss->p = 1;\n\tss->l = 0;\n\tss->avl = 0;\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic void\nsetup_syscalls_segments(struct x86_emulate_ctxt *ctxt,\n\t\t\tstruct desc_struct *cs, struct desc_struct *ss)\n{\n\tcs->l = 0;\t\t/* will be adjusted later */\n\tset_desc_base(cs, 0);\t/* flat segment */\n\tcs->g = 1;\t\t/* 4kb granularity */\n\tset_desc_limit(cs, 0xfffff);\t/* 4GB limit */\n\tcs->type = 0x0b;\t/* Read, Execute, Accessed */\n\tcs->s = 1;\n\tcs->dpl = 0;\t\t/* will be adjusted later */\n\tcs->p = 1;\n\tcs->d = 1;\n\tcs->avl = 0;\n\n\tset_desc_base(ss, 0);\t/* flat segment */\n\tset_desc_limit(ss, 0xfffff);\t/* 4GB limit */\n\tss->g = 1;\t\t/* 4kb granularity */\n\tss->s = 1;\n\tss->type = 0x03;\t/* Read/Write, Accessed */\n\tss->d = 1;\t\t/* 32bit stack segment */\n\tss->dpl = 0;\n\tss->p = 1;\n\tss->l = 0;\n\tss->avl = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ops->get_msr",
          "args": [
            "ctxt",
            "MSR_EFER",
            "&efer"
          ],
          "line": 2650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "em_syscall_is_enabled",
          "args": [
            "ctxt"
          ],
          "line": 2647
        },
        "resolved": true,
        "details": {
          "function_name": "em_syscall_is_enabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "2590-2632",
          "snippet": "static bool em_syscall_is_enabled(struct x86_emulate_ctxt *ctxt)\n{\n\tconst struct x86_emulate_ops *ops = ctxt->ops;\n\tu32 eax, ebx, ecx, edx;\n\n\t/*\n\t * syscall should always be enabled in longmode - so only become\n\t * vendor specific (cpuid) if other modes are active...\n\t */\n\tif (ctxt->mode == X86EMUL_MODE_PROT64)\n\t\treturn true;\n\n\teax = 0x00000000;\n\tecx = 0x00000000;\n\tops->get_cpuid(ctxt, &eax, &ebx, &ecx, &edx);\n\t/*\n\t * Intel (\"GenuineIntel\")\n\t * remark: Intel CPUs only support \"syscall\" in 64bit\n\t * longmode. Also an 64bit guest with a\n\t * 32bit compat-app running will #UD !! While this\n\t * behaviour can be fixed (by emulating) into AMD\n\t * response - CPUs of AMD can't behave like Intel.\n\t */\n\tif (ebx == X86EMUL_CPUID_VENDOR_GenuineIntel_ebx &&\n\t    ecx == X86EMUL_CPUID_VENDOR_GenuineIntel_ecx &&\n\t    edx == X86EMUL_CPUID_VENDOR_GenuineIntel_edx)\n\t\treturn false;\n\n\t/* AMD (\"AuthenticAMD\") */\n\tif (ebx == X86EMUL_CPUID_VENDOR_AuthenticAMD_ebx &&\n\t    ecx == X86EMUL_CPUID_VENDOR_AuthenticAMD_ecx &&\n\t    edx == X86EMUL_CPUID_VENDOR_AuthenticAMD_edx)\n\t\treturn true;\n\n\t/* AMD (\"AMDisbetter!\") */\n\tif (ebx == X86EMUL_CPUID_VENDOR_AMDisbetterI_ebx &&\n\t    ecx == X86EMUL_CPUID_VENDOR_AMDisbetterI_ecx &&\n\t    edx == X86EMUL_CPUID_VENDOR_AMDisbetterI_edx)\n\t\treturn true;\n\n\t/* default: (not Intel, not AMD), apply Intel's stricter rules... */\n\treturn false;\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic bool em_syscall_is_enabled(struct x86_emulate_ctxt *ctxt)\n{\n\tconst struct x86_emulate_ops *ops = ctxt->ops;\n\tu32 eax, ebx, ecx, edx;\n\n\t/*\n\t * syscall should always be enabled in longmode - so only become\n\t * vendor specific (cpuid) if other modes are active...\n\t */\n\tif (ctxt->mode == X86EMUL_MODE_PROT64)\n\t\treturn true;\n\n\teax = 0x00000000;\n\tecx = 0x00000000;\n\tops->get_cpuid(ctxt, &eax, &ebx, &ecx, &edx);\n\t/*\n\t * Intel (\"GenuineIntel\")\n\t * remark: Intel CPUs only support \"syscall\" in 64bit\n\t * longmode. Also an 64bit guest with a\n\t * 32bit compat-app running will #UD !! While this\n\t * behaviour can be fixed (by emulating) into AMD\n\t * response - CPUs of AMD can't behave like Intel.\n\t */\n\tif (ebx == X86EMUL_CPUID_VENDOR_GenuineIntel_ebx &&\n\t    ecx == X86EMUL_CPUID_VENDOR_GenuineIntel_ecx &&\n\t    edx == X86EMUL_CPUID_VENDOR_GenuineIntel_edx)\n\t\treturn false;\n\n\t/* AMD (\"AuthenticAMD\") */\n\tif (ebx == X86EMUL_CPUID_VENDOR_AuthenticAMD_ebx &&\n\t    ecx == X86EMUL_CPUID_VENDOR_AuthenticAMD_ecx &&\n\t    edx == X86EMUL_CPUID_VENDOR_AuthenticAMD_edx)\n\t\treturn true;\n\n\t/* AMD (\"AMDisbetter!\") */\n\tif (ebx == X86EMUL_CPUID_VENDOR_AMDisbetterI_ebx &&\n\t    ecx == X86EMUL_CPUID_VENDOR_AMDisbetterI_ecx &&\n\t    edx == X86EMUL_CPUID_VENDOR_AMDisbetterI_edx)\n\t\treturn true;\n\n\t/* default: (not Intel, not AMD), apply Intel's stricter rules... */\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int em_syscall(struct x86_emulate_ctxt *ctxt)\n{\n\tconst struct x86_emulate_ops *ops = ctxt->ops;\n\tstruct desc_struct cs, ss;\n\tu64 msr_data;\n\tu16 cs_sel, ss_sel;\n\tu64 efer = 0;\n\n\t/* syscall is not available in real mode */\n\tif (ctxt->mode == X86EMUL_MODE_REAL ||\n\t    ctxt->mode == X86EMUL_MODE_VM86)\n\t\treturn emulate_ud(ctxt);\n\n\tif (!(em_syscall_is_enabled(ctxt)))\n\t\treturn emulate_ud(ctxt);\n\n\tops->get_msr(ctxt, MSR_EFER, &efer);\n\tsetup_syscalls_segments(ctxt, &cs, &ss);\n\n\tif (!(efer & EFER_SCE))\n\t\treturn emulate_ud(ctxt);\n\n\tops->get_msr(ctxt, MSR_STAR, &msr_data);\n\tmsr_data >>= 32;\n\tcs_sel = (u16)(msr_data & 0xfffc);\n\tss_sel = (u16)(msr_data + 8);\n\n\tif (efer & EFER_LMA) {\n\t\tcs.d = 0;\n\t\tcs.l = 1;\n\t}\n\tops->set_segment(ctxt, cs_sel, &cs, 0, VCPU_SREG_CS);\n\tops->set_segment(ctxt, ss_sel, &ss, 0, VCPU_SREG_SS);\n\n\t*reg_write(ctxt, VCPU_REGS_RCX) = ctxt->_eip;\n\tif (efer & EFER_LMA) {\n#ifdef CONFIG_X86_64\n\t\t*reg_write(ctxt, VCPU_REGS_R11) = ctxt->eflags;\n\n\t\tops->get_msr(ctxt,\n\t\t\t     ctxt->mode == X86EMUL_MODE_PROT64 ?\n\t\t\t     MSR_LSTAR : MSR_CSTAR, &msr_data);\n\t\tctxt->_eip = msr_data;\n\n\t\tops->get_msr(ctxt, MSR_SYSCALL_MASK, &msr_data);\n\t\tctxt->eflags &= ~msr_data;\n\t\tctxt->eflags |= X86_EFLAGS_FIXED;\n#endif\n\t} else {\n\t\t/* legacy mode */\n\t\tops->get_msr(ctxt, MSR_STAR, &msr_data);\n\t\tctxt->_eip = (u32)msr_data;\n\n\t\tctxt->eflags &= ~(X86_EFLAGS_VM | X86_EFLAGS_IF);\n\t}\n\n\treturn X86EMUL_CONTINUE;\n}"
  },
  {
    "function_name": "em_syscall_is_enabled",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "2590-2632",
    "snippet": "static bool em_syscall_is_enabled(struct x86_emulate_ctxt *ctxt)\n{\n\tconst struct x86_emulate_ops *ops = ctxt->ops;\n\tu32 eax, ebx, ecx, edx;\n\n\t/*\n\t * syscall should always be enabled in longmode - so only become\n\t * vendor specific (cpuid) if other modes are active...\n\t */\n\tif (ctxt->mode == X86EMUL_MODE_PROT64)\n\t\treturn true;\n\n\teax = 0x00000000;\n\tecx = 0x00000000;\n\tops->get_cpuid(ctxt, &eax, &ebx, &ecx, &edx);\n\t/*\n\t * Intel (\"GenuineIntel\")\n\t * remark: Intel CPUs only support \"syscall\" in 64bit\n\t * longmode. Also an 64bit guest with a\n\t * 32bit compat-app running will #UD !! While this\n\t * behaviour can be fixed (by emulating) into AMD\n\t * response - CPUs of AMD can't behave like Intel.\n\t */\n\tif (ebx == X86EMUL_CPUID_VENDOR_GenuineIntel_ebx &&\n\t    ecx == X86EMUL_CPUID_VENDOR_GenuineIntel_ecx &&\n\t    edx == X86EMUL_CPUID_VENDOR_GenuineIntel_edx)\n\t\treturn false;\n\n\t/* AMD (\"AuthenticAMD\") */\n\tif (ebx == X86EMUL_CPUID_VENDOR_AuthenticAMD_ebx &&\n\t    ecx == X86EMUL_CPUID_VENDOR_AuthenticAMD_ecx &&\n\t    edx == X86EMUL_CPUID_VENDOR_AuthenticAMD_edx)\n\t\treturn true;\n\n\t/* AMD (\"AMDisbetter!\") */\n\tif (ebx == X86EMUL_CPUID_VENDOR_AMDisbetterI_ebx &&\n\t    ecx == X86EMUL_CPUID_VENDOR_AMDisbetterI_ecx &&\n\t    edx == X86EMUL_CPUID_VENDOR_AMDisbetterI_edx)\n\t\treturn true;\n\n\t/* default: (not Intel, not AMD), apply Intel's stricter rules... */\n\treturn false;\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ops->get_cpuid",
          "args": [
            "ctxt",
            "&eax",
            "&ebx",
            "&ecx",
            "&edx"
          ],
          "line": 2604
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic bool em_syscall_is_enabled(struct x86_emulate_ctxt *ctxt)\n{\n\tconst struct x86_emulate_ops *ops = ctxt->ops;\n\tu32 eax, ebx, ecx, edx;\n\n\t/*\n\t * syscall should always be enabled in longmode - so only become\n\t * vendor specific (cpuid) if other modes are active...\n\t */\n\tif (ctxt->mode == X86EMUL_MODE_PROT64)\n\t\treturn true;\n\n\teax = 0x00000000;\n\tecx = 0x00000000;\n\tops->get_cpuid(ctxt, &eax, &ebx, &ecx, &edx);\n\t/*\n\t * Intel (\"GenuineIntel\")\n\t * remark: Intel CPUs only support \"syscall\" in 64bit\n\t * longmode. Also an 64bit guest with a\n\t * 32bit compat-app running will #UD !! While this\n\t * behaviour can be fixed (by emulating) into AMD\n\t * response - CPUs of AMD can't behave like Intel.\n\t */\n\tif (ebx == X86EMUL_CPUID_VENDOR_GenuineIntel_ebx &&\n\t    ecx == X86EMUL_CPUID_VENDOR_GenuineIntel_ecx &&\n\t    edx == X86EMUL_CPUID_VENDOR_GenuineIntel_edx)\n\t\treturn false;\n\n\t/* AMD (\"AuthenticAMD\") */\n\tif (ebx == X86EMUL_CPUID_VENDOR_AuthenticAMD_ebx &&\n\t    ecx == X86EMUL_CPUID_VENDOR_AuthenticAMD_ecx &&\n\t    edx == X86EMUL_CPUID_VENDOR_AuthenticAMD_edx)\n\t\treturn true;\n\n\t/* AMD (\"AMDisbetter!\") */\n\tif (ebx == X86EMUL_CPUID_VENDOR_AMDisbetterI_ebx &&\n\t    ecx == X86EMUL_CPUID_VENDOR_AMDisbetterI_ecx &&\n\t    edx == X86EMUL_CPUID_VENDOR_AMDisbetterI_edx)\n\t\treturn true;\n\n\t/* default: (not Intel, not AMD), apply Intel's stricter rules... */\n\treturn false;\n}"
  },
  {
    "function_name": "vendor_intel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "2579-2588",
    "snippet": "static bool vendor_intel(struct x86_emulate_ctxt *ctxt)\n{\n\tu32 eax, ebx, ecx, edx;\n\n\teax = ecx = 0;\n\tctxt->ops->get_cpuid(ctxt, &eax, &ebx, &ecx, &edx);\n\treturn ebx == X86EMUL_CPUID_VENDOR_GenuineIntel_ebx\n\t\t&& ecx == X86EMUL_CPUID_VENDOR_GenuineIntel_ecx\n\t\t&& edx == X86EMUL_CPUID_VENDOR_GenuineIntel_edx;\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ctxt->ops->get_cpuid",
          "args": [
            "ctxt",
            "&eax",
            "&ebx",
            "&ecx",
            "&edx"
          ],
          "line": 2584
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic bool vendor_intel(struct x86_emulate_ctxt *ctxt)\n{\n\tu32 eax, ebx, ecx, edx;\n\n\teax = ecx = 0;\n\tctxt->ops->get_cpuid(ctxt, &eax, &ebx, &ecx, &edx);\n\treturn ebx == X86EMUL_CPUID_VENDOR_GenuineIntel_ebx\n\t\t&& ecx == X86EMUL_CPUID_VENDOR_GenuineIntel_ecx\n\t\t&& edx == X86EMUL_CPUID_VENDOR_GenuineIntel_edx;\n}"
  },
  {
    "function_name": "setup_syscalls_segments",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "2552-2577",
    "snippet": "static void\nsetup_syscalls_segments(struct x86_emulate_ctxt *ctxt,\n\t\t\tstruct desc_struct *cs, struct desc_struct *ss)\n{\n\tcs->l = 0;\t\t/* will be adjusted later */\n\tset_desc_base(cs, 0);\t/* flat segment */\n\tcs->g = 1;\t\t/* 4kb granularity */\n\tset_desc_limit(cs, 0xfffff);\t/* 4GB limit */\n\tcs->type = 0x0b;\t/* Read, Execute, Accessed */\n\tcs->s = 1;\n\tcs->dpl = 0;\t\t/* will be adjusted later */\n\tcs->p = 1;\n\tcs->d = 1;\n\tcs->avl = 0;\n\n\tset_desc_base(ss, 0);\t/* flat segment */\n\tset_desc_limit(ss, 0xfffff);\t/* 4GB limit */\n\tss->g = 1;\t\t/* 4kb granularity */\n\tss->s = 1;\n\tss->type = 0x03;\t/* Read/Write, Accessed */\n\tss->d = 1;\t\t/* 32bit stack segment */\n\tss->dpl = 0;\n\tss->p = 1;\n\tss->l = 0;\n\tss->avl = 0;\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_desc_limit",
          "args": [
            "ss",
            "0xfffff"
          ],
          "line": 2568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_desc_base",
          "args": [
            "ss",
            "0"
          ],
          "line": 2567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_desc_limit",
          "args": [
            "cs",
            "0xfffff"
          ],
          "line": 2559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_desc_base",
          "args": [
            "cs",
            "0"
          ],
          "line": 2557
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic void\nsetup_syscalls_segments(struct x86_emulate_ctxt *ctxt,\n\t\t\tstruct desc_struct *cs, struct desc_struct *ss)\n{\n\tcs->l = 0;\t\t/* will be adjusted later */\n\tset_desc_base(cs, 0);\t/* flat segment */\n\tcs->g = 1;\t\t/* 4kb granularity */\n\tset_desc_limit(cs, 0xfffff);\t/* 4GB limit */\n\tcs->type = 0x0b;\t/* Read, Execute, Accessed */\n\tcs->s = 1;\n\tcs->dpl = 0;\t\t/* will be adjusted later */\n\tcs->p = 1;\n\tcs->d = 1;\n\tcs->avl = 0;\n\n\tset_desc_base(ss, 0);\t/* flat segment */\n\tset_desc_limit(ss, 0xfffff);\t/* 4GB limit */\n\tss->g = 1;\t\t/* 4kb granularity */\n\tss->s = 1;\n\tss->type = 0x03;\t/* Read/Write, Accessed */\n\tss->d = 1;\t\t/* 32bit stack segment */\n\tss->dpl = 0;\n\tss->p = 1;\n\tss->l = 0;\n\tss->avl = 0;\n}"
  },
  {
    "function_name": "em_rsm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "2489-2550",
    "snippet": "static int em_rsm(struct x86_emulate_ctxt *ctxt)\n{\n\tunsigned long cr0, cr4, efer;\n\tu64 smbase;\n\tint ret;\n\n\tif ((ctxt->emul_flags & X86EMUL_SMM_MASK) == 0)\n\t\treturn emulate_ud(ctxt);\n\n\t/*\n\t * Get back to real mode, to prepare a safe state in which to load\n\t * CR0/CR3/CR4/EFER.  It's all a bit more complicated if the vCPU\n\t * supports long mode.\n\t */\n\tcr4 = ctxt->ops->get_cr(ctxt, 4);\n\tif (emulator_has_longmode(ctxt)) {\n\t\tstruct desc_struct cs_desc;\n\n\t\t/* Zero CR4.PCIDE before CR0.PG.  */\n\t\tif (cr4 & X86_CR4_PCIDE) {\n\t\t\tctxt->ops->set_cr(ctxt, 4, cr4 & ~X86_CR4_PCIDE);\n\t\t\tcr4 &= ~X86_CR4_PCIDE;\n\t\t}\n\n\t\t/* A 32-bit code segment is required to clear EFER.LMA.  */\n\t\tmemset(&cs_desc, 0, sizeof(cs_desc));\n\t\tcs_desc.type = 0xb;\n\t\tcs_desc.s = cs_desc.g = cs_desc.p = 1;\n\t\tctxt->ops->set_segment(ctxt, 0, &cs_desc, 0, VCPU_SREG_CS);\n\t}\n\n\t/* For the 64-bit case, this will clear EFER.LMA.  */\n\tcr0 = ctxt->ops->get_cr(ctxt, 0);\n\tif (cr0 & X86_CR0_PE)\n\t\tctxt->ops->set_cr(ctxt, 0, cr0 & ~(X86_CR0_PG | X86_CR0_PE));\n\n\t/* Now clear CR4.PAE (which must be done before clearing EFER.LME).  */\n\tif (cr4 & X86_CR4_PAE)\n\t\tctxt->ops->set_cr(ctxt, 4, cr4 & ~X86_CR4_PAE);\n\n\t/* And finally go back to 32-bit mode.  */\n\tefer = 0;\n\tctxt->ops->set_msr(ctxt, MSR_EFER, efer);\n\n\tsmbase = ctxt->ops->get_smbase(ctxt);\n\tif (emulator_has_longmode(ctxt))\n\t\tret = rsm_load_state_64(ctxt, smbase + 0x8000);\n\telse\n\t\tret = rsm_load_state_32(ctxt, smbase + 0x8000);\n\n\tif (ret != X86EMUL_CONTINUE) {\n\t\t/* FIXME: should triple fault */\n\t\treturn X86EMUL_UNHANDLEABLE;\n\t}\n\n\tif ((ctxt->emul_flags & X86EMUL_SMM_INSIDE_NMI_MASK) == 0)\n\t\tctxt->ops->set_nmi_mask(ctxt, false);\n\n\tctxt->emul_flags &= ~X86EMUL_SMM_INSIDE_NMI_MASK;\n\tctxt->emul_flags &= ~X86EMUL_SMM_MASK;\n\treturn X86EMUL_CONTINUE;\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ctxt->ops->set_nmi_mask",
          "args": [
            "ctxt",
            "false"
          ],
          "line": 2545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rsm_load_state_32",
          "args": [
            "ctxt",
            "smbase + 0x8000"
          ],
          "line": 2537
        },
        "resolved": true,
        "details": {
          "function_name": "rsm_load_state_32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "2373-2425",
          "snippet": "static int rsm_load_state_32(struct x86_emulate_ctxt *ctxt, u64 smbase)\n{\n\tstruct desc_struct desc;\n\tstruct desc_ptr dt;\n\tu16 selector;\n\tu32 val, cr0, cr4;\n\tint i;\n\n\tcr0 =                      GET_SMSTATE(u32, smbase, 0x7ffc);\n\tctxt->ops->set_cr(ctxt, 3, GET_SMSTATE(u32, smbase, 0x7ff8));\n\tctxt->eflags =             GET_SMSTATE(u32, smbase, 0x7ff4) | X86_EFLAGS_FIXED;\n\tctxt->_eip =               GET_SMSTATE(u32, smbase, 0x7ff0);\n\n\tfor (i = 0; i < 8; i++)\n\t\t*reg_write(ctxt, i) = GET_SMSTATE(u32, smbase, 0x7fd0 + i * 4);\n\n\tval = GET_SMSTATE(u32, smbase, 0x7fcc);\n\tctxt->ops->set_dr(ctxt, 6, (val & DR6_VOLATILE) | DR6_FIXED_1);\n\tval = GET_SMSTATE(u32, smbase, 0x7fc8);\n\tctxt->ops->set_dr(ctxt, 7, (val & DR7_VOLATILE) | DR7_FIXED_1);\n\n\tselector =                 GET_SMSTATE(u32, smbase, 0x7fc4);\n\tset_desc_base(&desc,       GET_SMSTATE(u32, smbase, 0x7f64));\n\tset_desc_limit(&desc,      GET_SMSTATE(u32, smbase, 0x7f60));\n\trsm_set_desc_flags(&desc,  GET_SMSTATE(u32, smbase, 0x7f5c));\n\tctxt->ops->set_segment(ctxt, selector, &desc, 0, VCPU_SREG_TR);\n\n\tselector =                 GET_SMSTATE(u32, smbase, 0x7fc0);\n\tset_desc_base(&desc,       GET_SMSTATE(u32, smbase, 0x7f80));\n\tset_desc_limit(&desc,      GET_SMSTATE(u32, smbase, 0x7f7c));\n\trsm_set_desc_flags(&desc,  GET_SMSTATE(u32, smbase, 0x7f78));\n\tctxt->ops->set_segment(ctxt, selector, &desc, 0, VCPU_SREG_LDTR);\n\n\tdt.address =               GET_SMSTATE(u32, smbase, 0x7f74);\n\tdt.size =                  GET_SMSTATE(u32, smbase, 0x7f70);\n\tctxt->ops->set_gdt(ctxt, &dt);\n\n\tdt.address =               GET_SMSTATE(u32, smbase, 0x7f58);\n\tdt.size =                  GET_SMSTATE(u32, smbase, 0x7f54);\n\tctxt->ops->set_idt(ctxt, &dt);\n\n\tfor (i = 0; i < 6; i++) {\n\t\tint r = rsm_load_seg_32(ctxt, smbase, i);\n\t\tif (r != X86EMUL_CONTINUE)\n\t\t\treturn r;\n\t}\n\n\tcr4 = GET_SMSTATE(u32, smbase, 0x7f14);\n\n\tctxt->ops->set_smbase(ctxt, GET_SMSTATE(u32, smbase, 0x7ef8));\n\n\treturn rsm_enter_protected_mode(ctxt, cr0, cr4);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int rsm_load_state_32(struct x86_emulate_ctxt *ctxt, u64 smbase)\n{\n\tstruct desc_struct desc;\n\tstruct desc_ptr dt;\n\tu16 selector;\n\tu32 val, cr0, cr4;\n\tint i;\n\n\tcr0 =                      GET_SMSTATE(u32, smbase, 0x7ffc);\n\tctxt->ops->set_cr(ctxt, 3, GET_SMSTATE(u32, smbase, 0x7ff8));\n\tctxt->eflags =             GET_SMSTATE(u32, smbase, 0x7ff4) | X86_EFLAGS_FIXED;\n\tctxt->_eip =               GET_SMSTATE(u32, smbase, 0x7ff0);\n\n\tfor (i = 0; i < 8; i++)\n\t\t*reg_write(ctxt, i) = GET_SMSTATE(u32, smbase, 0x7fd0 + i * 4);\n\n\tval = GET_SMSTATE(u32, smbase, 0x7fcc);\n\tctxt->ops->set_dr(ctxt, 6, (val & DR6_VOLATILE) | DR6_FIXED_1);\n\tval = GET_SMSTATE(u32, smbase, 0x7fc8);\n\tctxt->ops->set_dr(ctxt, 7, (val & DR7_VOLATILE) | DR7_FIXED_1);\n\n\tselector =                 GET_SMSTATE(u32, smbase, 0x7fc4);\n\tset_desc_base(&desc,       GET_SMSTATE(u32, smbase, 0x7f64));\n\tset_desc_limit(&desc,      GET_SMSTATE(u32, smbase, 0x7f60));\n\trsm_set_desc_flags(&desc,  GET_SMSTATE(u32, smbase, 0x7f5c));\n\tctxt->ops->set_segment(ctxt, selector, &desc, 0, VCPU_SREG_TR);\n\n\tselector =                 GET_SMSTATE(u32, smbase, 0x7fc0);\n\tset_desc_base(&desc,       GET_SMSTATE(u32, smbase, 0x7f80));\n\tset_desc_limit(&desc,      GET_SMSTATE(u32, smbase, 0x7f7c));\n\trsm_set_desc_flags(&desc,  GET_SMSTATE(u32, smbase, 0x7f78));\n\tctxt->ops->set_segment(ctxt, selector, &desc, 0, VCPU_SREG_LDTR);\n\n\tdt.address =               GET_SMSTATE(u32, smbase, 0x7f74);\n\tdt.size =                  GET_SMSTATE(u32, smbase, 0x7f70);\n\tctxt->ops->set_gdt(ctxt, &dt);\n\n\tdt.address =               GET_SMSTATE(u32, smbase, 0x7f58);\n\tdt.size =                  GET_SMSTATE(u32, smbase, 0x7f54);\n\tctxt->ops->set_idt(ctxt, &dt);\n\n\tfor (i = 0; i < 6; i++) {\n\t\tint r = rsm_load_seg_32(ctxt, smbase, i);\n\t\tif (r != X86EMUL_CONTINUE)\n\t\t\treturn r;\n\t}\n\n\tcr4 = GET_SMSTATE(u32, smbase, 0x7f14);\n\n\tctxt->ops->set_smbase(ctxt, GET_SMSTATE(u32, smbase, 0x7ef8));\n\n\treturn rsm_enter_protected_mode(ctxt, cr0, cr4);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rsm_load_state_64",
          "args": [
            "ctxt",
            "smbase + 0x8000"
          ],
          "line": 2535
        },
        "resolved": true,
        "details": {
          "function_name": "rsm_load_state_64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "2427-2487",
          "snippet": "static int rsm_load_state_64(struct x86_emulate_ctxt *ctxt, u64 smbase)\n{\n\tstruct desc_struct desc;\n\tstruct desc_ptr dt;\n\tu64 val, cr0, cr4;\n\tu32 base3;\n\tu16 selector;\n\tint i, r;\n\n\tfor (i = 0; i < 16; i++)\n\t\t*reg_write(ctxt, i) = GET_SMSTATE(u64, smbase, 0x7ff8 - i * 8);\n\n\tctxt->_eip   = GET_SMSTATE(u64, smbase, 0x7f78);\n\tctxt->eflags = GET_SMSTATE(u32, smbase, 0x7f70) | X86_EFLAGS_FIXED;\n\n\tval = GET_SMSTATE(u32, smbase, 0x7f68);\n\tctxt->ops->set_dr(ctxt, 6, (val & DR6_VOLATILE) | DR6_FIXED_1);\n\tval = GET_SMSTATE(u32, smbase, 0x7f60);\n\tctxt->ops->set_dr(ctxt, 7, (val & DR7_VOLATILE) | DR7_FIXED_1);\n\n\tcr0 =                       GET_SMSTATE(u64, smbase, 0x7f58);\n\tctxt->ops->set_cr(ctxt, 3,  GET_SMSTATE(u64, smbase, 0x7f50));\n\tcr4 =                       GET_SMSTATE(u64, smbase, 0x7f48);\n\tctxt->ops->set_smbase(ctxt, GET_SMSTATE(u32, smbase, 0x7f00));\n\tval =                       GET_SMSTATE(u64, smbase, 0x7ed0);\n\tctxt->ops->set_msr(ctxt, MSR_EFER, val & ~EFER_LMA);\n\n\tselector =                  GET_SMSTATE(u32, smbase, 0x7e90);\n\trsm_set_desc_flags(&desc,   GET_SMSTATE(u32, smbase, 0x7e92) << 8);\n\tset_desc_limit(&desc,       GET_SMSTATE(u32, smbase, 0x7e94));\n\tset_desc_base(&desc,        GET_SMSTATE(u32, smbase, 0x7e98));\n\tbase3 =                     GET_SMSTATE(u32, smbase, 0x7e9c);\n\tctxt->ops->set_segment(ctxt, selector, &desc, base3, VCPU_SREG_TR);\n\n\tdt.size =                   GET_SMSTATE(u32, smbase, 0x7e84);\n\tdt.address =                GET_SMSTATE(u64, smbase, 0x7e88);\n\tctxt->ops->set_idt(ctxt, &dt);\n\n\tselector =                  GET_SMSTATE(u32, smbase, 0x7e70);\n\trsm_set_desc_flags(&desc,   GET_SMSTATE(u32, smbase, 0x7e72) << 8);\n\tset_desc_limit(&desc,       GET_SMSTATE(u32, smbase, 0x7e74));\n\tset_desc_base(&desc,        GET_SMSTATE(u32, smbase, 0x7e78));\n\tbase3 =                     GET_SMSTATE(u32, smbase, 0x7e7c);\n\tctxt->ops->set_segment(ctxt, selector, &desc, base3, VCPU_SREG_LDTR);\n\n\tdt.size =                   GET_SMSTATE(u32, smbase, 0x7e64);\n\tdt.address =                GET_SMSTATE(u64, smbase, 0x7e68);\n\tctxt->ops->set_gdt(ctxt, &dt);\n\n\tr = rsm_enter_protected_mode(ctxt, cr0, cr4);\n\tif (r != X86EMUL_CONTINUE)\n\t\treturn r;\n\n\tfor (i = 0; i < 6; i++) {\n\t\tr = rsm_load_seg_64(ctxt, smbase, i);\n\t\tif (r != X86EMUL_CONTINUE)\n\t\t\treturn r;\n\t}\n\n\treturn X86EMUL_CONTINUE;\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int rsm_load_state_64(struct x86_emulate_ctxt *ctxt, u64 smbase)\n{\n\tstruct desc_struct desc;\n\tstruct desc_ptr dt;\n\tu64 val, cr0, cr4;\n\tu32 base3;\n\tu16 selector;\n\tint i, r;\n\n\tfor (i = 0; i < 16; i++)\n\t\t*reg_write(ctxt, i) = GET_SMSTATE(u64, smbase, 0x7ff8 - i * 8);\n\n\tctxt->_eip   = GET_SMSTATE(u64, smbase, 0x7f78);\n\tctxt->eflags = GET_SMSTATE(u32, smbase, 0x7f70) | X86_EFLAGS_FIXED;\n\n\tval = GET_SMSTATE(u32, smbase, 0x7f68);\n\tctxt->ops->set_dr(ctxt, 6, (val & DR6_VOLATILE) | DR6_FIXED_1);\n\tval = GET_SMSTATE(u32, smbase, 0x7f60);\n\tctxt->ops->set_dr(ctxt, 7, (val & DR7_VOLATILE) | DR7_FIXED_1);\n\n\tcr0 =                       GET_SMSTATE(u64, smbase, 0x7f58);\n\tctxt->ops->set_cr(ctxt, 3,  GET_SMSTATE(u64, smbase, 0x7f50));\n\tcr4 =                       GET_SMSTATE(u64, smbase, 0x7f48);\n\tctxt->ops->set_smbase(ctxt, GET_SMSTATE(u32, smbase, 0x7f00));\n\tval =                       GET_SMSTATE(u64, smbase, 0x7ed0);\n\tctxt->ops->set_msr(ctxt, MSR_EFER, val & ~EFER_LMA);\n\n\tselector =                  GET_SMSTATE(u32, smbase, 0x7e90);\n\trsm_set_desc_flags(&desc,   GET_SMSTATE(u32, smbase, 0x7e92) << 8);\n\tset_desc_limit(&desc,       GET_SMSTATE(u32, smbase, 0x7e94));\n\tset_desc_base(&desc,        GET_SMSTATE(u32, smbase, 0x7e98));\n\tbase3 =                     GET_SMSTATE(u32, smbase, 0x7e9c);\n\tctxt->ops->set_segment(ctxt, selector, &desc, base3, VCPU_SREG_TR);\n\n\tdt.size =                   GET_SMSTATE(u32, smbase, 0x7e84);\n\tdt.address =                GET_SMSTATE(u64, smbase, 0x7e88);\n\tctxt->ops->set_idt(ctxt, &dt);\n\n\tselector =                  GET_SMSTATE(u32, smbase, 0x7e70);\n\trsm_set_desc_flags(&desc,   GET_SMSTATE(u32, smbase, 0x7e72) << 8);\n\tset_desc_limit(&desc,       GET_SMSTATE(u32, smbase, 0x7e74));\n\tset_desc_base(&desc,        GET_SMSTATE(u32, smbase, 0x7e78));\n\tbase3 =                     GET_SMSTATE(u32, smbase, 0x7e7c);\n\tctxt->ops->set_segment(ctxt, selector, &desc, base3, VCPU_SREG_LDTR);\n\n\tdt.size =                   GET_SMSTATE(u32, smbase, 0x7e64);\n\tdt.address =                GET_SMSTATE(u64, smbase, 0x7e68);\n\tctxt->ops->set_gdt(ctxt, &dt);\n\n\tr = rsm_enter_protected_mode(ctxt, cr0, cr4);\n\tif (r != X86EMUL_CONTINUE)\n\t\treturn r;\n\n\tfor (i = 0; i < 6; i++) {\n\t\tr = rsm_load_seg_64(ctxt, smbase, i);\n\t\tif (r != X86EMUL_CONTINUE)\n\t\t\treturn r;\n\t}\n\n\treturn X86EMUL_CONTINUE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "emulator_has_longmode",
          "args": [
            "ctxt"
          ],
          "line": 2534
        },
        "resolved": true,
        "details": {
          "function_name": "emulator_has_longmode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "2275-2283",
          "snippet": "static int emulator_has_longmode(struct x86_emulate_ctxt *ctxt)\n{\n\tu32 eax, ebx, ecx, edx;\n\n\teax = 0x80000001;\n\tecx = 0;\n\tctxt->ops->get_cpuid(ctxt, &eax, &ebx, &ecx, &edx);\n\treturn edx & bit(X86_FEATURE_LM);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int emulator_has_longmode(struct x86_emulate_ctxt *ctxt)\n{\n\tu32 eax, ebx, ecx, edx;\n\n\teax = 0x80000001;\n\tecx = 0;\n\tctxt->ops->get_cpuid(ctxt, &eax, &ebx, &ecx, &edx);\n\treturn edx & bit(X86_FEATURE_LM);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ctxt->ops->get_smbase",
          "args": [
            "ctxt"
          ],
          "line": 2533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ctxt->ops->set_msr",
          "args": [
            "ctxt",
            "MSR_EFER",
            "efer"
          ],
          "line": 2531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ctxt->ops->set_cr",
          "args": [
            "ctxt",
            "4",
            "cr4 & ~X86_CR4_PAE"
          ],
          "line": 2527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ctxt->ops->set_cr",
          "args": [
            "ctxt",
            "0",
            "cr0 & ~(X86_CR0_PG | X86_CR0_PE)"
          ],
          "line": 2523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ctxt->ops->get_cr",
          "args": [
            "ctxt",
            "0"
          ],
          "line": 2521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ctxt->ops->set_segment",
          "args": [
            "ctxt",
            "0",
            "&cs_desc",
            "0",
            "VCPU_SREG_CS"
          ],
          "line": 2517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&cs_desc",
            "0",
            "sizeof(cs_desc)"
          ],
          "line": 2514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ctxt->ops->set_cr",
          "args": [
            "ctxt",
            "4",
            "cr4 & ~X86_CR4_PCIDE"
          ],
          "line": 2509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ctxt->ops->get_cr",
          "args": [
            "ctxt",
            "4"
          ],
          "line": 2503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "emulate_ud",
          "args": [
            "ctxt"
          ],
          "line": 2496
        },
        "resolved": true,
        "details": {
          "function_name": "emulate_ud",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "590-593",
          "snippet": "static int emulate_ud(struct x86_emulate_ctxt *ctxt)\n{\n\treturn emulate_exception(ctxt, UD_VECTOR, 0, false);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int emulate_ud(struct x86_emulate_ctxt *ctxt)\n{\n\treturn emulate_exception(ctxt, UD_VECTOR, 0, false);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int em_rsm(struct x86_emulate_ctxt *ctxt)\n{\n\tunsigned long cr0, cr4, efer;\n\tu64 smbase;\n\tint ret;\n\n\tif ((ctxt->emul_flags & X86EMUL_SMM_MASK) == 0)\n\t\treturn emulate_ud(ctxt);\n\n\t/*\n\t * Get back to real mode, to prepare a safe state in which to load\n\t * CR0/CR3/CR4/EFER.  It's all a bit more complicated if the vCPU\n\t * supports long mode.\n\t */\n\tcr4 = ctxt->ops->get_cr(ctxt, 4);\n\tif (emulator_has_longmode(ctxt)) {\n\t\tstruct desc_struct cs_desc;\n\n\t\t/* Zero CR4.PCIDE before CR0.PG.  */\n\t\tif (cr4 & X86_CR4_PCIDE) {\n\t\t\tctxt->ops->set_cr(ctxt, 4, cr4 & ~X86_CR4_PCIDE);\n\t\t\tcr4 &= ~X86_CR4_PCIDE;\n\t\t}\n\n\t\t/* A 32-bit code segment is required to clear EFER.LMA.  */\n\t\tmemset(&cs_desc, 0, sizeof(cs_desc));\n\t\tcs_desc.type = 0xb;\n\t\tcs_desc.s = cs_desc.g = cs_desc.p = 1;\n\t\tctxt->ops->set_segment(ctxt, 0, &cs_desc, 0, VCPU_SREG_CS);\n\t}\n\n\t/* For the 64-bit case, this will clear EFER.LMA.  */\n\tcr0 = ctxt->ops->get_cr(ctxt, 0);\n\tif (cr0 & X86_CR0_PE)\n\t\tctxt->ops->set_cr(ctxt, 0, cr0 & ~(X86_CR0_PG | X86_CR0_PE));\n\n\t/* Now clear CR4.PAE (which must be done before clearing EFER.LME).  */\n\tif (cr4 & X86_CR4_PAE)\n\t\tctxt->ops->set_cr(ctxt, 4, cr4 & ~X86_CR4_PAE);\n\n\t/* And finally go back to 32-bit mode.  */\n\tefer = 0;\n\tctxt->ops->set_msr(ctxt, MSR_EFER, efer);\n\n\tsmbase = ctxt->ops->get_smbase(ctxt);\n\tif (emulator_has_longmode(ctxt))\n\t\tret = rsm_load_state_64(ctxt, smbase + 0x8000);\n\telse\n\t\tret = rsm_load_state_32(ctxt, smbase + 0x8000);\n\n\tif (ret != X86EMUL_CONTINUE) {\n\t\t/* FIXME: should triple fault */\n\t\treturn X86EMUL_UNHANDLEABLE;\n\t}\n\n\tif ((ctxt->emul_flags & X86EMUL_SMM_INSIDE_NMI_MASK) == 0)\n\t\tctxt->ops->set_nmi_mask(ctxt, false);\n\n\tctxt->emul_flags &= ~X86EMUL_SMM_INSIDE_NMI_MASK;\n\tctxt->emul_flags &= ~X86EMUL_SMM_MASK;\n\treturn X86EMUL_CONTINUE;\n}"
  },
  {
    "function_name": "rsm_load_state_64",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "2427-2487",
    "snippet": "static int rsm_load_state_64(struct x86_emulate_ctxt *ctxt, u64 smbase)\n{\n\tstruct desc_struct desc;\n\tstruct desc_ptr dt;\n\tu64 val, cr0, cr4;\n\tu32 base3;\n\tu16 selector;\n\tint i, r;\n\n\tfor (i = 0; i < 16; i++)\n\t\t*reg_write(ctxt, i) = GET_SMSTATE(u64, smbase, 0x7ff8 - i * 8);\n\n\tctxt->_eip   = GET_SMSTATE(u64, smbase, 0x7f78);\n\tctxt->eflags = GET_SMSTATE(u32, smbase, 0x7f70) | X86_EFLAGS_FIXED;\n\n\tval = GET_SMSTATE(u32, smbase, 0x7f68);\n\tctxt->ops->set_dr(ctxt, 6, (val & DR6_VOLATILE) | DR6_FIXED_1);\n\tval = GET_SMSTATE(u32, smbase, 0x7f60);\n\tctxt->ops->set_dr(ctxt, 7, (val & DR7_VOLATILE) | DR7_FIXED_1);\n\n\tcr0 =                       GET_SMSTATE(u64, smbase, 0x7f58);\n\tctxt->ops->set_cr(ctxt, 3,  GET_SMSTATE(u64, smbase, 0x7f50));\n\tcr4 =                       GET_SMSTATE(u64, smbase, 0x7f48);\n\tctxt->ops->set_smbase(ctxt, GET_SMSTATE(u32, smbase, 0x7f00));\n\tval =                       GET_SMSTATE(u64, smbase, 0x7ed0);\n\tctxt->ops->set_msr(ctxt, MSR_EFER, val & ~EFER_LMA);\n\n\tselector =                  GET_SMSTATE(u32, smbase, 0x7e90);\n\trsm_set_desc_flags(&desc,   GET_SMSTATE(u32, smbase, 0x7e92) << 8);\n\tset_desc_limit(&desc,       GET_SMSTATE(u32, smbase, 0x7e94));\n\tset_desc_base(&desc,        GET_SMSTATE(u32, smbase, 0x7e98));\n\tbase3 =                     GET_SMSTATE(u32, smbase, 0x7e9c);\n\tctxt->ops->set_segment(ctxt, selector, &desc, base3, VCPU_SREG_TR);\n\n\tdt.size =                   GET_SMSTATE(u32, smbase, 0x7e84);\n\tdt.address =                GET_SMSTATE(u64, smbase, 0x7e88);\n\tctxt->ops->set_idt(ctxt, &dt);\n\n\tselector =                  GET_SMSTATE(u32, smbase, 0x7e70);\n\trsm_set_desc_flags(&desc,   GET_SMSTATE(u32, smbase, 0x7e72) << 8);\n\tset_desc_limit(&desc,       GET_SMSTATE(u32, smbase, 0x7e74));\n\tset_desc_base(&desc,        GET_SMSTATE(u32, smbase, 0x7e78));\n\tbase3 =                     GET_SMSTATE(u32, smbase, 0x7e7c);\n\tctxt->ops->set_segment(ctxt, selector, &desc, base3, VCPU_SREG_LDTR);\n\n\tdt.size =                   GET_SMSTATE(u32, smbase, 0x7e64);\n\tdt.address =                GET_SMSTATE(u64, smbase, 0x7e68);\n\tctxt->ops->set_gdt(ctxt, &dt);\n\n\tr = rsm_enter_protected_mode(ctxt, cr0, cr4);\n\tif (r != X86EMUL_CONTINUE)\n\t\treturn r;\n\n\tfor (i = 0; i < 6; i++) {\n\t\tr = rsm_load_seg_64(ctxt, smbase, i);\n\t\tif (r != X86EMUL_CONTINUE)\n\t\t\treturn r;\n\t}\n\n\treturn X86EMUL_CONTINUE;\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rsm_load_seg_64",
          "args": [
            "ctxt",
            "smbase",
            "i"
          ],
          "line": 2481
        },
        "resolved": true,
        "details": {
          "function_name": "rsm_load_seg_64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "2327-2344",
          "snippet": "static int rsm_load_seg_64(struct x86_emulate_ctxt *ctxt, u64 smbase, int n)\n{\n\tstruct desc_struct desc;\n\tint offset;\n\tu16 selector;\n\tu32 base3;\n\n\toffset = 0x7e00 + n * 16;\n\n\tselector =                GET_SMSTATE(u16, smbase, offset);\n\trsm_set_desc_flags(&desc, GET_SMSTATE(u16, smbase, offset + 2) << 8);\n\tset_desc_limit(&desc,     GET_SMSTATE(u32, smbase, offset + 4));\n\tset_desc_base(&desc,      GET_SMSTATE(u32, smbase, offset + 8));\n\tbase3 =                   GET_SMSTATE(u32, smbase, offset + 12);\n\n\tctxt->ops->set_segment(ctxt, selector, &desc, base3, n);\n\treturn X86EMUL_CONTINUE;\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int rsm_load_seg_64(struct x86_emulate_ctxt *ctxt, u64 smbase, int n)\n{\n\tstruct desc_struct desc;\n\tint offset;\n\tu16 selector;\n\tu32 base3;\n\n\toffset = 0x7e00 + n * 16;\n\n\tselector =                GET_SMSTATE(u16, smbase, offset);\n\trsm_set_desc_flags(&desc, GET_SMSTATE(u16, smbase, offset + 2) << 8);\n\tset_desc_limit(&desc,     GET_SMSTATE(u32, smbase, offset + 4));\n\tset_desc_base(&desc,      GET_SMSTATE(u32, smbase, offset + 8));\n\tbase3 =                   GET_SMSTATE(u32, smbase, offset + 12);\n\n\tctxt->ops->set_segment(ctxt, selector, &desc, base3, n);\n\treturn X86EMUL_CONTINUE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rsm_enter_protected_mode",
          "args": [
            "ctxt",
            "cr0",
            "cr4"
          ],
          "line": 2476
        },
        "resolved": true,
        "details": {
          "function_name": "rsm_enter_protected_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "2346-2371",
          "snippet": "static int rsm_enter_protected_mode(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t     u64 cr0, u64 cr4)\n{\n\tint bad;\n\n\t/*\n\t * First enable PAE, long mode needs it before CR0.PG = 1 is set.\n\t * Then enable protected mode.\tHowever, PCID cannot be enabled\n\t * if EFER.LMA=0, so set it separately.\n\t */\n\tbad = ctxt->ops->set_cr(ctxt, 4, cr4 & ~X86_CR4_PCIDE);\n\tif (bad)\n\t\treturn X86EMUL_UNHANDLEABLE;\n\n\tbad = ctxt->ops->set_cr(ctxt, 0, cr0);\n\tif (bad)\n\t\treturn X86EMUL_UNHANDLEABLE;\n\n\tif (cr4 & X86_CR4_PCIDE) {\n\t\tbad = ctxt->ops->set_cr(ctxt, 4, cr4);\n\t\tif (bad)\n\t\t\treturn X86EMUL_UNHANDLEABLE;\n\t}\n\n\treturn X86EMUL_CONTINUE;\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int rsm_enter_protected_mode(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t     u64 cr0, u64 cr4)\n{\n\tint bad;\n\n\t/*\n\t * First enable PAE, long mode needs it before CR0.PG = 1 is set.\n\t * Then enable protected mode.\tHowever, PCID cannot be enabled\n\t * if EFER.LMA=0, so set it separately.\n\t */\n\tbad = ctxt->ops->set_cr(ctxt, 4, cr4 & ~X86_CR4_PCIDE);\n\tif (bad)\n\t\treturn X86EMUL_UNHANDLEABLE;\n\n\tbad = ctxt->ops->set_cr(ctxt, 0, cr0);\n\tif (bad)\n\t\treturn X86EMUL_UNHANDLEABLE;\n\n\tif (cr4 & X86_CR4_PCIDE) {\n\t\tbad = ctxt->ops->set_cr(ctxt, 4, cr4);\n\t\tif (bad)\n\t\t\treturn X86EMUL_UNHANDLEABLE;\n\t}\n\n\treturn X86EMUL_CONTINUE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ctxt->ops->set_gdt",
          "args": [
            "ctxt",
            "&dt"
          ],
          "line": 2474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GET_SMSTATE",
          "args": [
            "u64",
            "smbase",
            "0x7e68"
          ],
          "line": 2473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GET_SMSTATE",
          "args": [
            "u32",
            "smbase",
            "0x7e64"
          ],
          "line": 2472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ctxt->ops->set_segment",
          "args": [
            "ctxt",
            "selector",
            "&desc",
            "base3",
            "VCPU_SREG_LDTR"
          ],
          "line": 2470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GET_SMSTATE",
          "args": [
            "u32",
            "smbase",
            "0x7e7c"
          ],
          "line": 2469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_desc_base",
          "args": [
            "&desc",
            "GET_SMSTATE(u32, smbase, 0x7e78)"
          ],
          "line": 2468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GET_SMSTATE",
          "args": [
            "u32",
            "smbase",
            "0x7e78"
          ],
          "line": 2468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_desc_limit",
          "args": [
            "&desc",
            "GET_SMSTATE(u32, smbase, 0x7e74)"
          ],
          "line": 2467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GET_SMSTATE",
          "args": [
            "u32",
            "smbase",
            "0x7e74"
          ],
          "line": 2467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rsm_set_desc_flags",
          "args": [
            "&desc",
            "GET_SMSTATE(u32, smbase, 0x7e72) << 8"
          ],
          "line": 2466
        },
        "resolved": true,
        "details": {
          "function_name": "rsm_set_desc_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "2295-2305",
          "snippet": "static void rsm_set_desc_flags(struct desc_struct *desc, u32 flags)\n{\n\tdesc->g    = (flags >> 23) & 1;\n\tdesc->d    = (flags >> 22) & 1;\n\tdesc->l    = (flags >> 21) & 1;\n\tdesc->avl  = (flags >> 20) & 1;\n\tdesc->p    = (flags >> 15) & 1;\n\tdesc->dpl  = (flags >> 13) & 3;\n\tdesc->s    = (flags >> 12) & 1;\n\tdesc->type = (flags >>  8) & 15;\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic void rsm_set_desc_flags(struct desc_struct *desc, u32 flags)\n{\n\tdesc->g    = (flags >> 23) & 1;\n\tdesc->d    = (flags >> 22) & 1;\n\tdesc->l    = (flags >> 21) & 1;\n\tdesc->avl  = (flags >> 20) & 1;\n\tdesc->p    = (flags >> 15) & 1;\n\tdesc->dpl  = (flags >> 13) & 3;\n\tdesc->s    = (flags >> 12) & 1;\n\tdesc->type = (flags >>  8) & 15;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GET_SMSTATE",
          "args": [
            "u32",
            "smbase",
            "0x7e72"
          ],
          "line": 2466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GET_SMSTATE",
          "args": [
            "u32",
            "smbase",
            "0x7e70"
          ],
          "line": 2465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ctxt->ops->set_idt",
          "args": [
            "ctxt",
            "&dt"
          ],
          "line": 2463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GET_SMSTATE",
          "args": [
            "u64",
            "smbase",
            "0x7e88"
          ],
          "line": 2462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GET_SMSTATE",
          "args": [
            "u32",
            "smbase",
            "0x7e84"
          ],
          "line": 2461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ctxt->ops->set_segment",
          "args": [
            "ctxt",
            "selector",
            "&desc",
            "base3",
            "VCPU_SREG_TR"
          ],
          "line": 2459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GET_SMSTATE",
          "args": [
            "u32",
            "smbase",
            "0x7e9c"
          ],
          "line": 2458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_desc_base",
          "args": [
            "&desc",
            "GET_SMSTATE(u32, smbase, 0x7e98)"
          ],
          "line": 2457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GET_SMSTATE",
          "args": [
            "u32",
            "smbase",
            "0x7e98"
          ],
          "line": 2457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_desc_limit",
          "args": [
            "&desc",
            "GET_SMSTATE(u32, smbase, 0x7e94)"
          ],
          "line": 2456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GET_SMSTATE",
          "args": [
            "u32",
            "smbase",
            "0x7e94"
          ],
          "line": 2456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GET_SMSTATE",
          "args": [
            "u32",
            "smbase",
            "0x7e92"
          ],
          "line": 2455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GET_SMSTATE",
          "args": [
            "u32",
            "smbase",
            "0x7e90"
          ],
          "line": 2454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ctxt->ops->set_msr",
          "args": [
            "ctxt",
            "MSR_EFER",
            "val & ~EFER_LMA"
          ],
          "line": 2452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GET_SMSTATE",
          "args": [
            "u64",
            "smbase",
            "0x7ed0"
          ],
          "line": 2451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ctxt->ops->set_smbase",
          "args": [
            "ctxt",
            "GET_SMSTATE(u32, smbase, 0x7f00)"
          ],
          "line": 2450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GET_SMSTATE",
          "args": [
            "u32",
            "smbase",
            "0x7f00"
          ],
          "line": 2450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GET_SMSTATE",
          "args": [
            "u64",
            "smbase",
            "0x7f48"
          ],
          "line": 2449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ctxt->ops->set_cr",
          "args": [
            "ctxt",
            "3",
            "GET_SMSTATE(u64, smbase, 0x7f50)"
          ],
          "line": 2448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GET_SMSTATE",
          "args": [
            "u64",
            "smbase",
            "0x7f50"
          ],
          "line": 2448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GET_SMSTATE",
          "args": [
            "u64",
            "smbase",
            "0x7f58"
          ],
          "line": 2447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ctxt->ops->set_dr",
          "args": [
            "ctxt",
            "7",
            "(val & DR7_VOLATILE) | DR7_FIXED_1"
          ],
          "line": 2445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GET_SMSTATE",
          "args": [
            "u32",
            "smbase",
            "0x7f60"
          ],
          "line": 2444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ctxt->ops->set_dr",
          "args": [
            "ctxt",
            "6",
            "(val & DR6_VOLATILE) | DR6_FIXED_1"
          ],
          "line": 2443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GET_SMSTATE",
          "args": [
            "u32",
            "smbase",
            "0x7f68"
          ],
          "line": 2442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GET_SMSTATE",
          "args": [
            "u32",
            "smbase",
            "0x7f70"
          ],
          "line": 2440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GET_SMSTATE",
          "args": [
            "u64",
            "smbase",
            "0x7f78"
          ],
          "line": 2439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GET_SMSTATE",
          "args": [
            "u64",
            "smbase",
            "0x7ff8 - i * 8"
          ],
          "line": 2437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reg_write",
          "args": [
            "ctxt",
            "i"
          ],
          "line": 2437
        },
        "resolved": true,
        "details": {
          "function_name": "reg_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "270-275",
          "snippet": "static ulong *reg_write(struct x86_emulate_ctxt *ctxt, unsigned nr)\n{\n\tctxt->regs_valid |= 1 << nr;\n\tctxt->regs_dirty |= 1 << nr;\n\treturn &ctxt->_regs[nr];\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic ulong *reg_write(struct x86_emulate_ctxt *ctxt, unsigned nr)\n{\n\tctxt->regs_valid |= 1 << nr;\n\tctxt->regs_dirty |= 1 << nr;\n\treturn &ctxt->_regs[nr];\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int rsm_load_state_64(struct x86_emulate_ctxt *ctxt, u64 smbase)\n{\n\tstruct desc_struct desc;\n\tstruct desc_ptr dt;\n\tu64 val, cr0, cr4;\n\tu32 base3;\n\tu16 selector;\n\tint i, r;\n\n\tfor (i = 0; i < 16; i++)\n\t\t*reg_write(ctxt, i) = GET_SMSTATE(u64, smbase, 0x7ff8 - i * 8);\n\n\tctxt->_eip   = GET_SMSTATE(u64, smbase, 0x7f78);\n\tctxt->eflags = GET_SMSTATE(u32, smbase, 0x7f70) | X86_EFLAGS_FIXED;\n\n\tval = GET_SMSTATE(u32, smbase, 0x7f68);\n\tctxt->ops->set_dr(ctxt, 6, (val & DR6_VOLATILE) | DR6_FIXED_1);\n\tval = GET_SMSTATE(u32, smbase, 0x7f60);\n\tctxt->ops->set_dr(ctxt, 7, (val & DR7_VOLATILE) | DR7_FIXED_1);\n\n\tcr0 =                       GET_SMSTATE(u64, smbase, 0x7f58);\n\tctxt->ops->set_cr(ctxt, 3,  GET_SMSTATE(u64, smbase, 0x7f50));\n\tcr4 =                       GET_SMSTATE(u64, smbase, 0x7f48);\n\tctxt->ops->set_smbase(ctxt, GET_SMSTATE(u32, smbase, 0x7f00));\n\tval =                       GET_SMSTATE(u64, smbase, 0x7ed0);\n\tctxt->ops->set_msr(ctxt, MSR_EFER, val & ~EFER_LMA);\n\n\tselector =                  GET_SMSTATE(u32, smbase, 0x7e90);\n\trsm_set_desc_flags(&desc,   GET_SMSTATE(u32, smbase, 0x7e92) << 8);\n\tset_desc_limit(&desc,       GET_SMSTATE(u32, smbase, 0x7e94));\n\tset_desc_base(&desc,        GET_SMSTATE(u32, smbase, 0x7e98));\n\tbase3 =                     GET_SMSTATE(u32, smbase, 0x7e9c);\n\tctxt->ops->set_segment(ctxt, selector, &desc, base3, VCPU_SREG_TR);\n\n\tdt.size =                   GET_SMSTATE(u32, smbase, 0x7e84);\n\tdt.address =                GET_SMSTATE(u64, smbase, 0x7e88);\n\tctxt->ops->set_idt(ctxt, &dt);\n\n\tselector =                  GET_SMSTATE(u32, smbase, 0x7e70);\n\trsm_set_desc_flags(&desc,   GET_SMSTATE(u32, smbase, 0x7e72) << 8);\n\tset_desc_limit(&desc,       GET_SMSTATE(u32, smbase, 0x7e74));\n\tset_desc_base(&desc,        GET_SMSTATE(u32, smbase, 0x7e78));\n\tbase3 =                     GET_SMSTATE(u32, smbase, 0x7e7c);\n\tctxt->ops->set_segment(ctxt, selector, &desc, base3, VCPU_SREG_LDTR);\n\n\tdt.size =                   GET_SMSTATE(u32, smbase, 0x7e64);\n\tdt.address =                GET_SMSTATE(u64, smbase, 0x7e68);\n\tctxt->ops->set_gdt(ctxt, &dt);\n\n\tr = rsm_enter_protected_mode(ctxt, cr0, cr4);\n\tif (r != X86EMUL_CONTINUE)\n\t\treturn r;\n\n\tfor (i = 0; i < 6; i++) {\n\t\tr = rsm_load_seg_64(ctxt, smbase, i);\n\t\tif (r != X86EMUL_CONTINUE)\n\t\t\treturn r;\n\t}\n\n\treturn X86EMUL_CONTINUE;\n}"
  },
  {
    "function_name": "rsm_load_state_32",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "2373-2425",
    "snippet": "static int rsm_load_state_32(struct x86_emulate_ctxt *ctxt, u64 smbase)\n{\n\tstruct desc_struct desc;\n\tstruct desc_ptr dt;\n\tu16 selector;\n\tu32 val, cr0, cr4;\n\tint i;\n\n\tcr0 =                      GET_SMSTATE(u32, smbase, 0x7ffc);\n\tctxt->ops->set_cr(ctxt, 3, GET_SMSTATE(u32, smbase, 0x7ff8));\n\tctxt->eflags =             GET_SMSTATE(u32, smbase, 0x7ff4) | X86_EFLAGS_FIXED;\n\tctxt->_eip =               GET_SMSTATE(u32, smbase, 0x7ff0);\n\n\tfor (i = 0; i < 8; i++)\n\t\t*reg_write(ctxt, i) = GET_SMSTATE(u32, smbase, 0x7fd0 + i * 4);\n\n\tval = GET_SMSTATE(u32, smbase, 0x7fcc);\n\tctxt->ops->set_dr(ctxt, 6, (val & DR6_VOLATILE) | DR6_FIXED_1);\n\tval = GET_SMSTATE(u32, smbase, 0x7fc8);\n\tctxt->ops->set_dr(ctxt, 7, (val & DR7_VOLATILE) | DR7_FIXED_1);\n\n\tselector =                 GET_SMSTATE(u32, smbase, 0x7fc4);\n\tset_desc_base(&desc,       GET_SMSTATE(u32, smbase, 0x7f64));\n\tset_desc_limit(&desc,      GET_SMSTATE(u32, smbase, 0x7f60));\n\trsm_set_desc_flags(&desc,  GET_SMSTATE(u32, smbase, 0x7f5c));\n\tctxt->ops->set_segment(ctxt, selector, &desc, 0, VCPU_SREG_TR);\n\n\tselector =                 GET_SMSTATE(u32, smbase, 0x7fc0);\n\tset_desc_base(&desc,       GET_SMSTATE(u32, smbase, 0x7f80));\n\tset_desc_limit(&desc,      GET_SMSTATE(u32, smbase, 0x7f7c));\n\trsm_set_desc_flags(&desc,  GET_SMSTATE(u32, smbase, 0x7f78));\n\tctxt->ops->set_segment(ctxt, selector, &desc, 0, VCPU_SREG_LDTR);\n\n\tdt.address =               GET_SMSTATE(u32, smbase, 0x7f74);\n\tdt.size =                  GET_SMSTATE(u32, smbase, 0x7f70);\n\tctxt->ops->set_gdt(ctxt, &dt);\n\n\tdt.address =               GET_SMSTATE(u32, smbase, 0x7f58);\n\tdt.size =                  GET_SMSTATE(u32, smbase, 0x7f54);\n\tctxt->ops->set_idt(ctxt, &dt);\n\n\tfor (i = 0; i < 6; i++) {\n\t\tint r = rsm_load_seg_32(ctxt, smbase, i);\n\t\tif (r != X86EMUL_CONTINUE)\n\t\t\treturn r;\n\t}\n\n\tcr4 = GET_SMSTATE(u32, smbase, 0x7f14);\n\n\tctxt->ops->set_smbase(ctxt, GET_SMSTATE(u32, smbase, 0x7ef8));\n\n\treturn rsm_enter_protected_mode(ctxt, cr0, cr4);\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rsm_enter_protected_mode",
          "args": [
            "ctxt",
            "cr0",
            "cr4"
          ],
          "line": 2424
        },
        "resolved": true,
        "details": {
          "function_name": "rsm_enter_protected_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "2346-2371",
          "snippet": "static int rsm_enter_protected_mode(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t     u64 cr0, u64 cr4)\n{\n\tint bad;\n\n\t/*\n\t * First enable PAE, long mode needs it before CR0.PG = 1 is set.\n\t * Then enable protected mode.\tHowever, PCID cannot be enabled\n\t * if EFER.LMA=0, so set it separately.\n\t */\n\tbad = ctxt->ops->set_cr(ctxt, 4, cr4 & ~X86_CR4_PCIDE);\n\tif (bad)\n\t\treturn X86EMUL_UNHANDLEABLE;\n\n\tbad = ctxt->ops->set_cr(ctxt, 0, cr0);\n\tif (bad)\n\t\treturn X86EMUL_UNHANDLEABLE;\n\n\tif (cr4 & X86_CR4_PCIDE) {\n\t\tbad = ctxt->ops->set_cr(ctxt, 4, cr4);\n\t\tif (bad)\n\t\t\treturn X86EMUL_UNHANDLEABLE;\n\t}\n\n\treturn X86EMUL_CONTINUE;\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int rsm_enter_protected_mode(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t     u64 cr0, u64 cr4)\n{\n\tint bad;\n\n\t/*\n\t * First enable PAE, long mode needs it before CR0.PG = 1 is set.\n\t * Then enable protected mode.\tHowever, PCID cannot be enabled\n\t * if EFER.LMA=0, so set it separately.\n\t */\n\tbad = ctxt->ops->set_cr(ctxt, 4, cr4 & ~X86_CR4_PCIDE);\n\tif (bad)\n\t\treturn X86EMUL_UNHANDLEABLE;\n\n\tbad = ctxt->ops->set_cr(ctxt, 0, cr0);\n\tif (bad)\n\t\treturn X86EMUL_UNHANDLEABLE;\n\n\tif (cr4 & X86_CR4_PCIDE) {\n\t\tbad = ctxt->ops->set_cr(ctxt, 4, cr4);\n\t\tif (bad)\n\t\t\treturn X86EMUL_UNHANDLEABLE;\n\t}\n\n\treturn X86EMUL_CONTINUE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ctxt->ops->set_smbase",
          "args": [
            "ctxt",
            "GET_SMSTATE(u32, smbase, 0x7ef8)"
          ],
          "line": 2422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GET_SMSTATE",
          "args": [
            "u32",
            "smbase",
            "0x7ef8"
          ],
          "line": 2422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GET_SMSTATE",
          "args": [
            "u32",
            "smbase",
            "0x7f14"
          ],
          "line": 2420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rsm_load_seg_32",
          "args": [
            "ctxt",
            "smbase",
            "i"
          ],
          "line": 2415
        },
        "resolved": true,
        "details": {
          "function_name": "rsm_load_seg_32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "2307-2325",
          "snippet": "static int rsm_load_seg_32(struct x86_emulate_ctxt *ctxt, u64 smbase, int n)\n{\n\tstruct desc_struct desc;\n\tint offset;\n\tu16 selector;\n\n\tselector = GET_SMSTATE(u32, smbase, 0x7fa8 + n * 4);\n\n\tif (n < 3)\n\t\toffset = 0x7f84 + n * 12;\n\telse\n\t\toffset = 0x7f2c + (n - 3) * 12;\n\n\tset_desc_base(&desc,      GET_SMSTATE(u32, smbase, offset + 8));\n\tset_desc_limit(&desc,     GET_SMSTATE(u32, smbase, offset + 4));\n\trsm_set_desc_flags(&desc, GET_SMSTATE(u32, smbase, offset));\n\tctxt->ops->set_segment(ctxt, selector, &desc, 0, n);\n\treturn X86EMUL_CONTINUE;\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int rsm_load_seg_32(struct x86_emulate_ctxt *ctxt, u64 smbase, int n)\n{\n\tstruct desc_struct desc;\n\tint offset;\n\tu16 selector;\n\n\tselector = GET_SMSTATE(u32, smbase, 0x7fa8 + n * 4);\n\n\tif (n < 3)\n\t\toffset = 0x7f84 + n * 12;\n\telse\n\t\toffset = 0x7f2c + (n - 3) * 12;\n\n\tset_desc_base(&desc,      GET_SMSTATE(u32, smbase, offset + 8));\n\tset_desc_limit(&desc,     GET_SMSTATE(u32, smbase, offset + 4));\n\trsm_set_desc_flags(&desc, GET_SMSTATE(u32, smbase, offset));\n\tctxt->ops->set_segment(ctxt, selector, &desc, 0, n);\n\treturn X86EMUL_CONTINUE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ctxt->ops->set_idt",
          "args": [
            "ctxt",
            "&dt"
          ],
          "line": 2412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GET_SMSTATE",
          "args": [
            "u32",
            "smbase",
            "0x7f54"
          ],
          "line": 2411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GET_SMSTATE",
          "args": [
            "u32",
            "smbase",
            "0x7f58"
          ],
          "line": 2410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ctxt->ops->set_gdt",
          "args": [
            "ctxt",
            "&dt"
          ],
          "line": 2408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GET_SMSTATE",
          "args": [
            "u32",
            "smbase",
            "0x7f70"
          ],
          "line": 2407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GET_SMSTATE",
          "args": [
            "u32",
            "smbase",
            "0x7f74"
          ],
          "line": 2406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ctxt->ops->set_segment",
          "args": [
            "ctxt",
            "selector",
            "&desc",
            "0",
            "VCPU_SREG_LDTR"
          ],
          "line": 2404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rsm_set_desc_flags",
          "args": [
            "&desc",
            "GET_SMSTATE(u32, smbase, 0x7f78)"
          ],
          "line": 2403
        },
        "resolved": true,
        "details": {
          "function_name": "rsm_set_desc_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "2295-2305",
          "snippet": "static void rsm_set_desc_flags(struct desc_struct *desc, u32 flags)\n{\n\tdesc->g    = (flags >> 23) & 1;\n\tdesc->d    = (flags >> 22) & 1;\n\tdesc->l    = (flags >> 21) & 1;\n\tdesc->avl  = (flags >> 20) & 1;\n\tdesc->p    = (flags >> 15) & 1;\n\tdesc->dpl  = (flags >> 13) & 3;\n\tdesc->s    = (flags >> 12) & 1;\n\tdesc->type = (flags >>  8) & 15;\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic void rsm_set_desc_flags(struct desc_struct *desc, u32 flags)\n{\n\tdesc->g    = (flags >> 23) & 1;\n\tdesc->d    = (flags >> 22) & 1;\n\tdesc->l    = (flags >> 21) & 1;\n\tdesc->avl  = (flags >> 20) & 1;\n\tdesc->p    = (flags >> 15) & 1;\n\tdesc->dpl  = (flags >> 13) & 3;\n\tdesc->s    = (flags >> 12) & 1;\n\tdesc->type = (flags >>  8) & 15;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GET_SMSTATE",
          "args": [
            "u32",
            "smbase",
            "0x7f78"
          ],
          "line": 2403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_desc_limit",
          "args": [
            "&desc",
            "GET_SMSTATE(u32, smbase, 0x7f7c)"
          ],
          "line": 2402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GET_SMSTATE",
          "args": [
            "u32",
            "smbase",
            "0x7f7c"
          ],
          "line": 2402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_desc_base",
          "args": [
            "&desc",
            "GET_SMSTATE(u32, smbase, 0x7f80)"
          ],
          "line": 2401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GET_SMSTATE",
          "args": [
            "u32",
            "smbase",
            "0x7f80"
          ],
          "line": 2401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GET_SMSTATE",
          "args": [
            "u32",
            "smbase",
            "0x7fc0"
          ],
          "line": 2400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ctxt->ops->set_segment",
          "args": [
            "ctxt",
            "selector",
            "&desc",
            "0",
            "VCPU_SREG_TR"
          ],
          "line": 2398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GET_SMSTATE",
          "args": [
            "u32",
            "smbase",
            "0x7f5c"
          ],
          "line": 2397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_desc_limit",
          "args": [
            "&desc",
            "GET_SMSTATE(u32, smbase, 0x7f60)"
          ],
          "line": 2396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GET_SMSTATE",
          "args": [
            "u32",
            "smbase",
            "0x7f60"
          ],
          "line": 2396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_desc_base",
          "args": [
            "&desc",
            "GET_SMSTATE(u32, smbase, 0x7f64)"
          ],
          "line": 2395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GET_SMSTATE",
          "args": [
            "u32",
            "smbase",
            "0x7f64"
          ],
          "line": 2395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GET_SMSTATE",
          "args": [
            "u32",
            "smbase",
            "0x7fc4"
          ],
          "line": 2394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ctxt->ops->set_dr",
          "args": [
            "ctxt",
            "7",
            "(val & DR7_VOLATILE) | DR7_FIXED_1"
          ],
          "line": 2392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GET_SMSTATE",
          "args": [
            "u32",
            "smbase",
            "0x7fc8"
          ],
          "line": 2391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ctxt->ops->set_dr",
          "args": [
            "ctxt",
            "6",
            "(val & DR6_VOLATILE) | DR6_FIXED_1"
          ],
          "line": 2390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GET_SMSTATE",
          "args": [
            "u32",
            "smbase",
            "0x7fcc"
          ],
          "line": 2389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GET_SMSTATE",
          "args": [
            "u32",
            "smbase",
            "0x7fd0 + i * 4"
          ],
          "line": 2387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reg_write",
          "args": [
            "ctxt",
            "i"
          ],
          "line": 2387
        },
        "resolved": true,
        "details": {
          "function_name": "reg_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "270-275",
          "snippet": "static ulong *reg_write(struct x86_emulate_ctxt *ctxt, unsigned nr)\n{\n\tctxt->regs_valid |= 1 << nr;\n\tctxt->regs_dirty |= 1 << nr;\n\treturn &ctxt->_regs[nr];\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic ulong *reg_write(struct x86_emulate_ctxt *ctxt, unsigned nr)\n{\n\tctxt->regs_valid |= 1 << nr;\n\tctxt->regs_dirty |= 1 << nr;\n\treturn &ctxt->_regs[nr];\n}"
        }
      },
      {
        "call_info": {
          "callee": "GET_SMSTATE",
          "args": [
            "u32",
            "smbase",
            "0x7ff0"
          ],
          "line": 2384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GET_SMSTATE",
          "args": [
            "u32",
            "smbase",
            "0x7ff4"
          ],
          "line": 2383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ctxt->ops->set_cr",
          "args": [
            "ctxt",
            "3",
            "GET_SMSTATE(u32, smbase, 0x7ff8)"
          ],
          "line": 2382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GET_SMSTATE",
          "args": [
            "u32",
            "smbase",
            "0x7ff8"
          ],
          "line": 2382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GET_SMSTATE",
          "args": [
            "u32",
            "smbase",
            "0x7ffc"
          ],
          "line": 2381
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int rsm_load_state_32(struct x86_emulate_ctxt *ctxt, u64 smbase)\n{\n\tstruct desc_struct desc;\n\tstruct desc_ptr dt;\n\tu16 selector;\n\tu32 val, cr0, cr4;\n\tint i;\n\n\tcr0 =                      GET_SMSTATE(u32, smbase, 0x7ffc);\n\tctxt->ops->set_cr(ctxt, 3, GET_SMSTATE(u32, smbase, 0x7ff8));\n\tctxt->eflags =             GET_SMSTATE(u32, smbase, 0x7ff4) | X86_EFLAGS_FIXED;\n\tctxt->_eip =               GET_SMSTATE(u32, smbase, 0x7ff0);\n\n\tfor (i = 0; i < 8; i++)\n\t\t*reg_write(ctxt, i) = GET_SMSTATE(u32, smbase, 0x7fd0 + i * 4);\n\n\tval = GET_SMSTATE(u32, smbase, 0x7fcc);\n\tctxt->ops->set_dr(ctxt, 6, (val & DR6_VOLATILE) | DR6_FIXED_1);\n\tval = GET_SMSTATE(u32, smbase, 0x7fc8);\n\tctxt->ops->set_dr(ctxt, 7, (val & DR7_VOLATILE) | DR7_FIXED_1);\n\n\tselector =                 GET_SMSTATE(u32, smbase, 0x7fc4);\n\tset_desc_base(&desc,       GET_SMSTATE(u32, smbase, 0x7f64));\n\tset_desc_limit(&desc,      GET_SMSTATE(u32, smbase, 0x7f60));\n\trsm_set_desc_flags(&desc,  GET_SMSTATE(u32, smbase, 0x7f5c));\n\tctxt->ops->set_segment(ctxt, selector, &desc, 0, VCPU_SREG_TR);\n\n\tselector =                 GET_SMSTATE(u32, smbase, 0x7fc0);\n\tset_desc_base(&desc,       GET_SMSTATE(u32, smbase, 0x7f80));\n\tset_desc_limit(&desc,      GET_SMSTATE(u32, smbase, 0x7f7c));\n\trsm_set_desc_flags(&desc,  GET_SMSTATE(u32, smbase, 0x7f78));\n\tctxt->ops->set_segment(ctxt, selector, &desc, 0, VCPU_SREG_LDTR);\n\n\tdt.address =               GET_SMSTATE(u32, smbase, 0x7f74);\n\tdt.size =                  GET_SMSTATE(u32, smbase, 0x7f70);\n\tctxt->ops->set_gdt(ctxt, &dt);\n\n\tdt.address =               GET_SMSTATE(u32, smbase, 0x7f58);\n\tdt.size =                  GET_SMSTATE(u32, smbase, 0x7f54);\n\tctxt->ops->set_idt(ctxt, &dt);\n\n\tfor (i = 0; i < 6; i++) {\n\t\tint r = rsm_load_seg_32(ctxt, smbase, i);\n\t\tif (r != X86EMUL_CONTINUE)\n\t\t\treturn r;\n\t}\n\n\tcr4 = GET_SMSTATE(u32, smbase, 0x7f14);\n\n\tctxt->ops->set_smbase(ctxt, GET_SMSTATE(u32, smbase, 0x7ef8));\n\n\treturn rsm_enter_protected_mode(ctxt, cr0, cr4);\n}"
  },
  {
    "function_name": "rsm_enter_protected_mode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "2346-2371",
    "snippet": "static int rsm_enter_protected_mode(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t     u64 cr0, u64 cr4)\n{\n\tint bad;\n\n\t/*\n\t * First enable PAE, long mode needs it before CR0.PG = 1 is set.\n\t * Then enable protected mode.\tHowever, PCID cannot be enabled\n\t * if EFER.LMA=0, so set it separately.\n\t */\n\tbad = ctxt->ops->set_cr(ctxt, 4, cr4 & ~X86_CR4_PCIDE);\n\tif (bad)\n\t\treturn X86EMUL_UNHANDLEABLE;\n\n\tbad = ctxt->ops->set_cr(ctxt, 0, cr0);\n\tif (bad)\n\t\treturn X86EMUL_UNHANDLEABLE;\n\n\tif (cr4 & X86_CR4_PCIDE) {\n\t\tbad = ctxt->ops->set_cr(ctxt, 4, cr4);\n\t\tif (bad)\n\t\t\treturn X86EMUL_UNHANDLEABLE;\n\t}\n\n\treturn X86EMUL_CONTINUE;\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ctxt->ops->set_cr",
          "args": [
            "ctxt",
            "4",
            "cr4"
          ],
          "line": 2365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ctxt->ops->set_cr",
          "args": [
            "ctxt",
            "0",
            "cr0"
          ],
          "line": 2360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ctxt->ops->set_cr",
          "args": [
            "ctxt",
            "4",
            "cr4 & ~X86_CR4_PCIDE"
          ],
          "line": 2356
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int rsm_enter_protected_mode(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t     u64 cr0, u64 cr4)\n{\n\tint bad;\n\n\t/*\n\t * First enable PAE, long mode needs it before CR0.PG = 1 is set.\n\t * Then enable protected mode.\tHowever, PCID cannot be enabled\n\t * if EFER.LMA=0, so set it separately.\n\t */\n\tbad = ctxt->ops->set_cr(ctxt, 4, cr4 & ~X86_CR4_PCIDE);\n\tif (bad)\n\t\treturn X86EMUL_UNHANDLEABLE;\n\n\tbad = ctxt->ops->set_cr(ctxt, 0, cr0);\n\tif (bad)\n\t\treturn X86EMUL_UNHANDLEABLE;\n\n\tif (cr4 & X86_CR4_PCIDE) {\n\t\tbad = ctxt->ops->set_cr(ctxt, 4, cr4);\n\t\tif (bad)\n\t\t\treturn X86EMUL_UNHANDLEABLE;\n\t}\n\n\treturn X86EMUL_CONTINUE;\n}"
  },
  {
    "function_name": "rsm_load_seg_64",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "2327-2344",
    "snippet": "static int rsm_load_seg_64(struct x86_emulate_ctxt *ctxt, u64 smbase, int n)\n{\n\tstruct desc_struct desc;\n\tint offset;\n\tu16 selector;\n\tu32 base3;\n\n\toffset = 0x7e00 + n * 16;\n\n\tselector =                GET_SMSTATE(u16, smbase, offset);\n\trsm_set_desc_flags(&desc, GET_SMSTATE(u16, smbase, offset + 2) << 8);\n\tset_desc_limit(&desc,     GET_SMSTATE(u32, smbase, offset + 4));\n\tset_desc_base(&desc,      GET_SMSTATE(u32, smbase, offset + 8));\n\tbase3 =                   GET_SMSTATE(u32, smbase, offset + 12);\n\n\tctxt->ops->set_segment(ctxt, selector, &desc, base3, n);\n\treturn X86EMUL_CONTINUE;\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ctxt->ops->set_segment",
          "args": [
            "ctxt",
            "selector",
            "&desc",
            "base3",
            "n"
          ],
          "line": 2342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GET_SMSTATE",
          "args": [
            "u32",
            "smbase",
            "offset + 12"
          ],
          "line": 2340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_desc_base",
          "args": [
            "&desc",
            "GET_SMSTATE(u32, smbase, offset + 8)"
          ],
          "line": 2339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GET_SMSTATE",
          "args": [
            "u32",
            "smbase",
            "offset + 8"
          ],
          "line": 2339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_desc_limit",
          "args": [
            "&desc",
            "GET_SMSTATE(u32, smbase, offset + 4)"
          ],
          "line": 2338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GET_SMSTATE",
          "args": [
            "u32",
            "smbase",
            "offset + 4"
          ],
          "line": 2338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rsm_set_desc_flags",
          "args": [
            "&desc",
            "GET_SMSTATE(u16, smbase, offset + 2) << 8"
          ],
          "line": 2337
        },
        "resolved": true,
        "details": {
          "function_name": "rsm_set_desc_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "2295-2305",
          "snippet": "static void rsm_set_desc_flags(struct desc_struct *desc, u32 flags)\n{\n\tdesc->g    = (flags >> 23) & 1;\n\tdesc->d    = (flags >> 22) & 1;\n\tdesc->l    = (flags >> 21) & 1;\n\tdesc->avl  = (flags >> 20) & 1;\n\tdesc->p    = (flags >> 15) & 1;\n\tdesc->dpl  = (flags >> 13) & 3;\n\tdesc->s    = (flags >> 12) & 1;\n\tdesc->type = (flags >>  8) & 15;\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic void rsm_set_desc_flags(struct desc_struct *desc, u32 flags)\n{\n\tdesc->g    = (flags >> 23) & 1;\n\tdesc->d    = (flags >> 22) & 1;\n\tdesc->l    = (flags >> 21) & 1;\n\tdesc->avl  = (flags >> 20) & 1;\n\tdesc->p    = (flags >> 15) & 1;\n\tdesc->dpl  = (flags >> 13) & 3;\n\tdesc->s    = (flags >> 12) & 1;\n\tdesc->type = (flags >>  8) & 15;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GET_SMSTATE",
          "args": [
            "u16",
            "smbase",
            "offset + 2"
          ],
          "line": 2337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GET_SMSTATE",
          "args": [
            "u16",
            "smbase",
            "offset"
          ],
          "line": 2336
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int rsm_load_seg_64(struct x86_emulate_ctxt *ctxt, u64 smbase, int n)\n{\n\tstruct desc_struct desc;\n\tint offset;\n\tu16 selector;\n\tu32 base3;\n\n\toffset = 0x7e00 + n * 16;\n\n\tselector =                GET_SMSTATE(u16, smbase, offset);\n\trsm_set_desc_flags(&desc, GET_SMSTATE(u16, smbase, offset + 2) << 8);\n\tset_desc_limit(&desc,     GET_SMSTATE(u32, smbase, offset + 4));\n\tset_desc_base(&desc,      GET_SMSTATE(u32, smbase, offset + 8));\n\tbase3 =                   GET_SMSTATE(u32, smbase, offset + 12);\n\n\tctxt->ops->set_segment(ctxt, selector, &desc, base3, n);\n\treturn X86EMUL_CONTINUE;\n}"
  },
  {
    "function_name": "rsm_load_seg_32",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "2307-2325",
    "snippet": "static int rsm_load_seg_32(struct x86_emulate_ctxt *ctxt, u64 smbase, int n)\n{\n\tstruct desc_struct desc;\n\tint offset;\n\tu16 selector;\n\n\tselector = GET_SMSTATE(u32, smbase, 0x7fa8 + n * 4);\n\n\tif (n < 3)\n\t\toffset = 0x7f84 + n * 12;\n\telse\n\t\toffset = 0x7f2c + (n - 3) * 12;\n\n\tset_desc_base(&desc,      GET_SMSTATE(u32, smbase, offset + 8));\n\tset_desc_limit(&desc,     GET_SMSTATE(u32, smbase, offset + 4));\n\trsm_set_desc_flags(&desc, GET_SMSTATE(u32, smbase, offset));\n\tctxt->ops->set_segment(ctxt, selector, &desc, 0, n);\n\treturn X86EMUL_CONTINUE;\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ctxt->ops->set_segment",
          "args": [
            "ctxt",
            "selector",
            "&desc",
            "0",
            "n"
          ],
          "line": 2323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rsm_set_desc_flags",
          "args": [
            "&desc",
            "GET_SMSTATE(u32, smbase, offset)"
          ],
          "line": 2322
        },
        "resolved": true,
        "details": {
          "function_name": "rsm_set_desc_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "2295-2305",
          "snippet": "static void rsm_set_desc_flags(struct desc_struct *desc, u32 flags)\n{\n\tdesc->g    = (flags >> 23) & 1;\n\tdesc->d    = (flags >> 22) & 1;\n\tdesc->l    = (flags >> 21) & 1;\n\tdesc->avl  = (flags >> 20) & 1;\n\tdesc->p    = (flags >> 15) & 1;\n\tdesc->dpl  = (flags >> 13) & 3;\n\tdesc->s    = (flags >> 12) & 1;\n\tdesc->type = (flags >>  8) & 15;\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic void rsm_set_desc_flags(struct desc_struct *desc, u32 flags)\n{\n\tdesc->g    = (flags >> 23) & 1;\n\tdesc->d    = (flags >> 22) & 1;\n\tdesc->l    = (flags >> 21) & 1;\n\tdesc->avl  = (flags >> 20) & 1;\n\tdesc->p    = (flags >> 15) & 1;\n\tdesc->dpl  = (flags >> 13) & 3;\n\tdesc->s    = (flags >> 12) & 1;\n\tdesc->type = (flags >>  8) & 15;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GET_SMSTATE",
          "args": [
            "u32",
            "smbase",
            "offset"
          ],
          "line": 2322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_desc_limit",
          "args": [
            "&desc",
            "GET_SMSTATE(u32, smbase, offset + 4)"
          ],
          "line": 2321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GET_SMSTATE",
          "args": [
            "u32",
            "smbase",
            "offset + 4"
          ],
          "line": 2321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_desc_base",
          "args": [
            "&desc",
            "GET_SMSTATE(u32, smbase, offset + 8)"
          ],
          "line": 2320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GET_SMSTATE",
          "args": [
            "u32",
            "smbase",
            "offset + 8"
          ],
          "line": 2320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GET_SMSTATE",
          "args": [
            "u32",
            "smbase",
            "0x7fa8 + n * 4"
          ],
          "line": 2313
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int rsm_load_seg_32(struct x86_emulate_ctxt *ctxt, u64 smbase, int n)\n{\n\tstruct desc_struct desc;\n\tint offset;\n\tu16 selector;\n\n\tselector = GET_SMSTATE(u32, smbase, 0x7fa8 + n * 4);\n\n\tif (n < 3)\n\t\toffset = 0x7f84 + n * 12;\n\telse\n\t\toffset = 0x7f2c + (n - 3) * 12;\n\n\tset_desc_base(&desc,      GET_SMSTATE(u32, smbase, offset + 8));\n\tset_desc_limit(&desc,     GET_SMSTATE(u32, smbase, offset + 4));\n\trsm_set_desc_flags(&desc, GET_SMSTATE(u32, smbase, offset));\n\tctxt->ops->set_segment(ctxt, selector, &desc, 0, n);\n\treturn X86EMUL_CONTINUE;\n}"
  },
  {
    "function_name": "rsm_set_desc_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "2295-2305",
    "snippet": "static void rsm_set_desc_flags(struct desc_struct *desc, u32 flags)\n{\n\tdesc->g    = (flags >> 23) & 1;\n\tdesc->d    = (flags >> 22) & 1;\n\tdesc->l    = (flags >> 21) & 1;\n\tdesc->avl  = (flags >> 20) & 1;\n\tdesc->p    = (flags >> 15) & 1;\n\tdesc->dpl  = (flags >> 13) & 3;\n\tdesc->s    = (flags >> 12) & 1;\n\tdesc->type = (flags >>  8) & 15;\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic void rsm_set_desc_flags(struct desc_struct *desc, u32 flags)\n{\n\tdesc->g    = (flags >> 23) & 1;\n\tdesc->d    = (flags >> 22) & 1;\n\tdesc->l    = (flags >> 21) & 1;\n\tdesc->avl  = (flags >> 20) & 1;\n\tdesc->p    = (flags >> 15) & 1;\n\tdesc->dpl  = (flags >> 13) & 3;\n\tdesc->s    = (flags >> 12) & 1;\n\tdesc->type = (flags >>  8) & 15;\n}"
  },
  {
    "function_name": "emulator_has_longmode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "2275-2283",
    "snippet": "static int emulator_has_longmode(struct x86_emulate_ctxt *ctxt)\n{\n\tu32 eax, ebx, ecx, edx;\n\n\teax = 0x80000001;\n\tecx = 0;\n\tctxt->ops->get_cpuid(ctxt, &eax, &ebx, &ecx, &edx);\n\treturn edx & bit(X86_FEATURE_LM);\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bit",
          "args": [
            "X86_FEATURE_LM"
          ],
          "line": 2282
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_bit_operand",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "1328-1348",
          "snippet": "static void fetch_bit_operand(struct x86_emulate_ctxt *ctxt)\n{\n\tlong sv = 0, mask;\n\n\tif (ctxt->dst.type == OP_MEM && ctxt->src.type == OP_REG) {\n\t\tmask = ~((long)ctxt->dst.bytes * 8 - 1);\n\n\t\tif (ctxt->src.bytes == 2)\n\t\t\tsv = (s16)ctxt->src.val & (s16)mask;\n\t\telse if (ctxt->src.bytes == 4)\n\t\t\tsv = (s32)ctxt->src.val & (s32)mask;\n\t\telse\n\t\t\tsv = (s64)ctxt->src.val & (s64)mask;\n\n\t\tctxt->dst.addr.mem.ea = address_mask(ctxt,\n\t\t\t\t\t   ctxt->dst.addr.mem.ea + (sv >> 3));\n\t}\n\n\t/* only subword offset */\n\tctxt->src.val &= (ctxt->dst.bytes << 3) - 1;\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic void fetch_bit_operand(struct x86_emulate_ctxt *ctxt)\n{\n\tlong sv = 0, mask;\n\n\tif (ctxt->dst.type == OP_MEM && ctxt->src.type == OP_REG) {\n\t\tmask = ~((long)ctxt->dst.bytes * 8 - 1);\n\n\t\tif (ctxt->src.bytes == 2)\n\t\t\tsv = (s16)ctxt->src.val & (s16)mask;\n\t\telse if (ctxt->src.bytes == 4)\n\t\t\tsv = (s32)ctxt->src.val & (s32)mask;\n\t\telse\n\t\t\tsv = (s64)ctxt->src.val & (s64)mask;\n\n\t\tctxt->dst.addr.mem.ea = address_mask(ctxt,\n\t\t\t\t\t   ctxt->dst.addr.mem.ea + (sv >> 3));\n\t}\n\n\t/* only subword offset */\n\tctxt->src.val &= (ctxt->dst.bytes << 3) - 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ctxt->ops->get_cpuid",
          "args": [
            "ctxt",
            "&eax",
            "&ebx",
            "&ecx",
            "&edx"
          ],
          "line": 2281
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int emulator_has_longmode(struct x86_emulate_ctxt *ctxt)\n{\n\tu32 eax, ebx, ecx, edx;\n\n\teax = 0x80000001;\n\tecx = 0;\n\tctxt->ops->get_cpuid(ctxt, &eax, &ebx, &ecx, &edx);\n\treturn edx & bit(X86_FEATURE_LM);\n}"
  },
  {
    "function_name": "em_lseg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "2259-2273",
    "snippet": "static int em_lseg(struct x86_emulate_ctxt *ctxt)\n{\n\tint seg = ctxt->src2.val;\n\tunsigned short sel;\n\tint rc;\n\n\tmemcpy(&sel, ctxt->src.valptr + ctxt->op_bytes, 2);\n\n\trc = load_segment_descriptor(ctxt, sel, seg);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\tctxt->dst.val = ctxt->src.val;\n\treturn rc;\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "load_segment_descriptor",
          "args": [
            "ctxt",
            "sel",
            "seg"
          ],
          "line": 2267
        },
        "resolved": true,
        "details": {
          "function_name": "load_segment_descriptor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "1710-1716",
          "snippet": "static int load_segment_descriptor(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t   u16 selector, int seg)\n{\n\tu8 cpl = ctxt->ops->cpl(ctxt);\n\treturn __load_segment_descriptor(ctxt, selector, seg, cpl,\n\t\t\t\t\t X86_TRANSFER_NONE, NULL);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int load_segment_descriptor(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t   u16 selector, int seg)\n{\n\tu8 cpl = ctxt->ops->cpl(ctxt);\n\treturn __load_segment_descriptor(ctxt, selector, seg, cpl,\n\t\t\t\t\t X86_TRANSFER_NONE, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&sel",
            "ctxt->src.valptr + ctxt->op_bytes",
            "2"
          ],
          "line": 2265
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int em_lseg(struct x86_emulate_ctxt *ctxt)\n{\n\tint seg = ctxt->src2.val;\n\tunsigned short sel;\n\tint rc;\n\n\tmemcpy(&sel, ctxt->src.valptr + ctxt->op_bytes, 2);\n\n\trc = load_segment_descriptor(ctxt, sel, seg);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\tctxt->dst.val = ctxt->src.val;\n\treturn rc;\n}"
  },
  {
    "function_name": "em_cmpxchg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "2235-2257",
    "snippet": "static int em_cmpxchg(struct x86_emulate_ctxt *ctxt)\n{\n\t/* Save real source value, then compare EAX against destination. */\n\tctxt->dst.orig_val = ctxt->dst.val;\n\tctxt->dst.val = reg_read(ctxt, VCPU_REGS_RAX);\n\tctxt->src.orig_val = ctxt->src.val;\n\tctxt->src.val = ctxt->dst.orig_val;\n\tfastop(ctxt, em_cmp);\n\n\tif (ctxt->eflags & X86_EFLAGS_ZF) {\n\t\t/* Success: write back to memory; no update of EAX */\n\t\tctxt->src.type = OP_NONE;\n\t\tctxt->dst.val = ctxt->src.orig_val;\n\t} else {\n\t\t/* Failure: write the value we saw to EAX. */\n\t\tctxt->src.type = OP_REG;\n\t\tctxt->src.addr.reg = reg_rmw(ctxt, VCPU_REGS_RAX);\n\t\tctxt->src.val = ctxt->dst.orig_val;\n\t\t/* Create write-cycle to dest by writing the same value */\n\t\tctxt->dst.val = ctxt->dst.orig_val;\n\t}\n\treturn X86EMUL_CONTINUE;\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int fastop(struct x86_emulate_ctxt *ctxt, void (*fop)(struct fastop *));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "reg_rmw",
          "args": [
            "ctxt",
            "VCPU_REGS_RAX"
          ],
          "line": 2251
        },
        "resolved": true,
        "details": {
          "function_name": "reg_rmw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "277-281",
          "snippet": "static ulong *reg_rmw(struct x86_emulate_ctxt *ctxt, unsigned nr)\n{\n\treg_read(ctxt, nr);\n\treturn reg_write(ctxt, nr);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic ulong *reg_rmw(struct x86_emulate_ctxt *ctxt, unsigned nr)\n{\n\treg_read(ctxt, nr);\n\treturn reg_write(ctxt, nr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fastop",
          "args": [
            "ctxt",
            "em_cmp"
          ],
          "line": 2242
        },
        "resolved": true,
        "details": {
          "function_name": "fastop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "5111-5124",
          "snippet": "static int fastop(struct x86_emulate_ctxt *ctxt, void (*fop)(struct fastop *))\n{\n\tulong flags = (ctxt->eflags & EFLAGS_MASK) | X86_EFLAGS_IF;\n\tif (!(ctxt->d & ByteOp))\n\t\tfop += __ffs(ctxt->dst.bytes) * FASTOP_SIZE;\n\tasm(\"push %[flags]; popf; call *%[fastop]; pushf; pop %[flags]\\n\"\n\t    : \"+a\"(ctxt->dst.val), \"+d\"(ctxt->src.val), [flags]\"+D\"(flags),\n\t      [fastop]\"+S\"(fop)\n\t    : \"c\"(ctxt->src2.val));\n\tctxt->eflags = (ctxt->eflags & ~EFLAGS_MASK) | (flags & EFLAGS_MASK);\n\tif (!fop) /* exception is returned in fop variable */\n\t\treturn emulate_de(ctxt);\n\treturn X86EMUL_CONTINUE;\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define EFLAGS_MASK (X86_EFLAGS_OF|X86_EFLAGS_SF|X86_EFLAGS_ZF|X86_EFLAGS_AF|\\\n\t\t     X86_EFLAGS_PF|X86_EFLAGS_CF)",
            "#define FASTOP_SIZE 8",
            "#define ByteOp      (1<<0)\t/* 8-bit operands. */"
          ],
          "globals_used": [
            "static int fastop(struct x86_emulate_ctxt *ctxt, void (*fop)(struct fastop *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\n#define EFLAGS_MASK (X86_EFLAGS_OF|X86_EFLAGS_SF|X86_EFLAGS_ZF|X86_EFLAGS_AF|\\\n\t\t     X86_EFLAGS_PF|X86_EFLAGS_CF)\n#define FASTOP_SIZE 8\n#define ByteOp      (1<<0)\t/* 8-bit operands. */\n\nstatic int fastop(struct x86_emulate_ctxt *ctxt, void (*fop)(struct fastop *));\n\nstatic int fastop(struct x86_emulate_ctxt *ctxt, void (*fop)(struct fastop *))\n{\n\tulong flags = (ctxt->eflags & EFLAGS_MASK) | X86_EFLAGS_IF;\n\tif (!(ctxt->d & ByteOp))\n\t\tfop += __ffs(ctxt->dst.bytes) * FASTOP_SIZE;\n\tasm(\"push %[flags]; popf; call *%[fastop]; pushf; pop %[flags]\\n\"\n\t    : \"+a\"(ctxt->dst.val), \"+d\"(ctxt->src.val), [flags]\"+D\"(flags),\n\t      [fastop]\"+S\"(fop)\n\t    : \"c\"(ctxt->src2.val));\n\tctxt->eflags = (ctxt->eflags & ~EFLAGS_MASK) | (flags & EFLAGS_MASK);\n\tif (!fop) /* exception is returned in fop variable */\n\t\treturn emulate_de(ctxt);\n\treturn X86EMUL_CONTINUE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reg_read",
          "args": [
            "ctxt",
            "VCPU_REGS_RAX"
          ],
          "line": 2239
        },
        "resolved": true,
        "details": {
          "function_name": "reg_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "261-268",
          "snippet": "static ulong reg_read(struct x86_emulate_ctxt *ctxt, unsigned nr)\n{\n\tif (!(ctxt->regs_valid & (1 << nr))) {\n\t\tctxt->regs_valid |= 1 << nr;\n\t\tctxt->_regs[nr] = ctxt->ops->read_gpr(ctxt, nr);\n\t}\n\treturn ctxt->_regs[nr];\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic ulong reg_read(struct x86_emulate_ctxt *ctxt, unsigned nr)\n{\n\tif (!(ctxt->regs_valid & (1 << nr))) {\n\t\tctxt->regs_valid |= 1 << nr;\n\t\tctxt->_regs[nr] = ctxt->ops->read_gpr(ctxt, nr);\n\t}\n\treturn ctxt->_regs[nr];\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int fastop(struct x86_emulate_ctxt *ctxt, void (*fop)(struct fastop *));\n\nstatic int em_cmpxchg(struct x86_emulate_ctxt *ctxt)\n{\n\t/* Save real source value, then compare EAX against destination. */\n\tctxt->dst.orig_val = ctxt->dst.val;\n\tctxt->dst.val = reg_read(ctxt, VCPU_REGS_RAX);\n\tctxt->src.orig_val = ctxt->src.val;\n\tctxt->src.val = ctxt->dst.orig_val;\n\tfastop(ctxt, em_cmp);\n\n\tif (ctxt->eflags & X86_EFLAGS_ZF) {\n\t\t/* Success: write back to memory; no update of EAX */\n\t\tctxt->src.type = OP_NONE;\n\t\tctxt->dst.val = ctxt->src.orig_val;\n\t} else {\n\t\t/* Failure: write the value we saw to EAX. */\n\t\tctxt->src.type = OP_REG;\n\t\tctxt->src.addr.reg = reg_rmw(ctxt, VCPU_REGS_RAX);\n\t\tctxt->src.val = ctxt->dst.orig_val;\n\t\t/* Create write-cycle to dest by writing the same value */\n\t\tctxt->dst.val = ctxt->dst.orig_val;\n\t}\n\treturn X86EMUL_CONTINUE;\n}"
  },
  {
    "function_name": "em_ret_far_imm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "2224-2233",
    "snippet": "static int em_ret_far_imm(struct x86_emulate_ctxt *ctxt)\n{\n        int rc;\n\n        rc = em_ret_far(ctxt);\n        if (rc != X86EMUL_CONTINUE)\n                return rc;\n        rsp_increment(ctxt, ctxt->src.val);\n        return X86EMUL_CONTINUE;\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rsp_increment",
          "args": [
            "ctxt",
            "ctxt->src.val"
          ],
          "line": 2231
        },
        "resolved": true,
        "details": {
          "function_name": "rsp_increment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "545-548",
          "snippet": "static void rsp_increment(struct x86_emulate_ctxt *ctxt, int inc)\n{\n\tmasked_increment(reg_rmw(ctxt, VCPU_REGS_RSP), stack_mask(ctxt), inc);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic void rsp_increment(struct x86_emulate_ctxt *ctxt, int inc)\n{\n\tmasked_increment(reg_rmw(ctxt, VCPU_REGS_RSP), stack_mask(ctxt), inc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "em_ret_far",
          "args": [
            "ctxt"
          ],
          "line": 2228
        },
        "resolved": true,
        "details": {
          "function_name": "em_ret_far_imm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "2224-2233",
          "snippet": "static int em_ret_far_imm(struct x86_emulate_ctxt *ctxt)\n{\n        int rc;\n\n        rc = em_ret_far(ctxt);\n        if (rc != X86EMUL_CONTINUE)\n                return rc;\n        rsp_increment(ctxt, ctxt->src.val);\n        return X86EMUL_CONTINUE;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int em_ret_far_imm(struct x86_emulate_ctxt *ctxt)\n{\n        int rc;\n\n        rc = em_ret_far(ctxt);\n        if (rc != X86EMUL_CONTINUE)\n                return rc;\n        rsp_increment(ctxt, ctxt->src.val);\n        return X86EMUL_CONTINUE;\n}"
  },
  {
    "function_name": "em_ret_far",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "2189-2222",
    "snippet": "static int em_ret_far(struct x86_emulate_ctxt *ctxt)\n{\n\tint rc;\n\tunsigned long eip, cs;\n\tu16 old_cs;\n\tint cpl = ctxt->ops->cpl(ctxt);\n\tstruct desc_struct old_desc, new_desc;\n\tconst struct x86_emulate_ops *ops = ctxt->ops;\n\n\tif (ctxt->mode == X86EMUL_MODE_PROT64)\n\t\tops->get_segment(ctxt, &old_cs, &old_desc, NULL,\n\t\t\t\t VCPU_SREG_CS);\n\n\trc = emulate_pop(ctxt, &eip, ctxt->op_bytes);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\trc = emulate_pop(ctxt, &cs, ctxt->op_bytes);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\t/* Outer-privilege level return is not implemented */\n\tif (ctxt->mode >= X86EMUL_MODE_PROT16 && (cs & 3) > cpl)\n\t\treturn X86EMUL_UNHANDLEABLE;\n\trc = __load_segment_descriptor(ctxt, (u16)cs, VCPU_SREG_CS, cpl,\n\t\t\t\t       X86_TRANSFER_RET,\n\t\t\t\t       &new_desc);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\trc = assign_eip_far(ctxt, eip, &new_desc);\n\tif (rc != X86EMUL_CONTINUE) {\n\t\tWARN_ON(ctxt->mode != X86EMUL_MODE_PROT64);\n\t\tops->set_segment(ctxt, old_cs, &old_desc, 0, VCPU_SREG_CS);\n\t}\n\treturn rc;\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ops->set_segment",
          "args": [
            "ctxt",
            "old_cs",
            "&old_desc",
            "0",
            "VCPU_SREG_CS"
          ],
          "line": 2219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "ctxt->mode != X86EMUL_MODE_PROT64"
          ],
          "line": 2218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assign_eip_far",
          "args": [
            "ctxt",
            "eip",
            "&new_desc"
          ],
          "line": 2216
        },
        "resolved": true,
        "details": {
          "function_name": "assign_eip_far",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "750-774",
          "snippet": "static int assign_eip_far(struct x86_emulate_ctxt *ctxt, ulong dst,\n\t\t\t  const struct desc_struct *cs_desc)\n{\n\tenum x86emul_mode mode = ctxt->mode;\n\tint rc;\n\n#ifdef CONFIG_X86_64\n\tif (ctxt->mode >= X86EMUL_MODE_PROT16) {\n\t\tif (cs_desc->l) {\n\t\t\tu64 efer = 0;\n\n\t\t\tctxt->ops->get_msr(ctxt, MSR_EFER, &efer);\n\t\t\tif (efer & EFER_LMA)\n\t\t\t\tmode = X86EMUL_MODE_PROT64;\n\t\t} else\n\t\t\tmode = X86EMUL_MODE_PROT32; /* temporary value */\n\t}\n#endif\n\tif (mode == X86EMUL_MODE_PROT16 || mode == X86EMUL_MODE_PROT32)\n\t\tmode = cs_desc->d ? X86EMUL_MODE_PROT32 : X86EMUL_MODE_PROT16;\n\trc = assign_eip(ctxt, dst, mode);\n\tif (rc == X86EMUL_CONTINUE)\n\t\tctxt->mode = mode;\n\treturn rc;\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int assign_eip_far(struct x86_emulate_ctxt *ctxt, ulong dst,\n\t\t\t  const struct desc_struct *cs_desc)\n{\n\tenum x86emul_mode mode = ctxt->mode;\n\tint rc;\n\n#ifdef CONFIG_X86_64\n\tif (ctxt->mode >= X86EMUL_MODE_PROT16) {\n\t\tif (cs_desc->l) {\n\t\t\tu64 efer = 0;\n\n\t\t\tctxt->ops->get_msr(ctxt, MSR_EFER, &efer);\n\t\t\tif (efer & EFER_LMA)\n\t\t\t\tmode = X86EMUL_MODE_PROT64;\n\t\t} else\n\t\t\tmode = X86EMUL_MODE_PROT32; /* temporary value */\n\t}\n#endif\n\tif (mode == X86EMUL_MODE_PROT16 || mode == X86EMUL_MODE_PROT32)\n\t\tmode = cs_desc->d ? X86EMUL_MODE_PROT32 : X86EMUL_MODE_PROT16;\n\trc = assign_eip(ctxt, dst, mode);\n\tif (rc == X86EMUL_CONTINUE)\n\t\tctxt->mode = mode;\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__load_segment_descriptor",
          "args": [
            "ctxt",
            "(u16)cs",
            "VCPU_SREG_CS",
            "cpl",
            "X86_TRANSFER_RET",
            "&new_desc"
          ],
          "line": 2211
        },
        "resolved": true,
        "details": {
          "function_name": "__load_segment_descriptor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "1549-1708",
          "snippet": "static int __load_segment_descriptor(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t     u16 selector, int seg, u8 cpl,\n\t\t\t\t     enum x86_transfer_type transfer,\n\t\t\t\t     struct desc_struct *desc)\n{\n\tstruct desc_struct seg_desc, old_desc;\n\tu8 dpl, rpl;\n\tunsigned err_vec = GP_VECTOR;\n\tu32 err_code = 0;\n\tbool null_selector = !(selector & ~0x3); /* 0000-0003 are null */\n\tulong desc_addr;\n\tint ret;\n\tu16 dummy;\n\tu32 base3 = 0;\n\n\tmemset(&seg_desc, 0, sizeof seg_desc);\n\n\tif (ctxt->mode == X86EMUL_MODE_REAL) {\n\t\t/* set real mode segment descriptor (keep limit etc. for\n\t\t * unreal mode) */\n\t\tctxt->ops->get_segment(ctxt, &dummy, &seg_desc, NULL, seg);\n\t\tset_desc_base(&seg_desc, selector << 4);\n\t\tgoto load;\n\t} else if (seg <= VCPU_SREG_GS && ctxt->mode == X86EMUL_MODE_VM86) {\n\t\t/* VM86 needs a clean new segment descriptor */\n\t\tset_desc_base(&seg_desc, selector << 4);\n\t\tset_desc_limit(&seg_desc, 0xffff);\n\t\tseg_desc.type = 3;\n\t\tseg_desc.p = 1;\n\t\tseg_desc.s = 1;\n\t\tseg_desc.dpl = 3;\n\t\tgoto load;\n\t}\n\n\trpl = selector & 3;\n\n\t/* NULL selector is not valid for TR, CS and SS (except for long mode) */\n\tif ((seg == VCPU_SREG_CS\n\t     || (seg == VCPU_SREG_SS\n\t\t && (ctxt->mode != X86EMUL_MODE_PROT64 || rpl != cpl))\n\t     || seg == VCPU_SREG_TR)\n\t    && null_selector)\n\t\tgoto exception;\n\n\t/* TR should be in GDT only */\n\tif (seg == VCPU_SREG_TR && (selector & (1 << 2)))\n\t\tgoto exception;\n\n\tif (null_selector) /* for NULL selector skip all following checks */\n\t\tgoto load;\n\n\tret = read_segment_descriptor(ctxt, selector, &seg_desc, &desc_addr);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\n\terr_code = selector & 0xfffc;\n\terr_vec = (transfer == X86_TRANSFER_TASK_SWITCH) ? TS_VECTOR :\n\t\t\t\t\t\t\t   GP_VECTOR;\n\n\t/* can't load system descriptor into segment selector */\n\tif (seg <= VCPU_SREG_GS && !seg_desc.s) {\n\t\tif (transfer == X86_TRANSFER_CALL_JMP)\n\t\t\treturn X86EMUL_UNHANDLEABLE;\n\t\tgoto exception;\n\t}\n\n\tif (!seg_desc.p) {\n\t\terr_vec = (seg == VCPU_SREG_SS) ? SS_VECTOR : NP_VECTOR;\n\t\tgoto exception;\n\t}\n\n\tdpl = seg_desc.dpl;\n\n\tswitch (seg) {\n\tcase VCPU_SREG_SS:\n\t\t/*\n\t\t * segment is not a writable data segment or segment\n\t\t * selector's RPL != CPL or segment selector's RPL != CPL\n\t\t */\n\t\tif (rpl != cpl || (seg_desc.type & 0xa) != 0x2 || dpl != cpl)\n\t\t\tgoto exception;\n\t\tbreak;\n\tcase VCPU_SREG_CS:\n\t\tif (!(seg_desc.type & 8))\n\t\t\tgoto exception;\n\n\t\tif (seg_desc.type & 4) {\n\t\t\t/* conforming */\n\t\t\tif (dpl > cpl)\n\t\t\t\tgoto exception;\n\t\t} else {\n\t\t\t/* nonconforming */\n\t\t\tif (rpl > cpl || dpl != cpl)\n\t\t\t\tgoto exception;\n\t\t}\n\t\t/* in long-mode d/b must be clear if l is set */\n\t\tif (seg_desc.d && seg_desc.l) {\n\t\t\tu64 efer = 0;\n\n\t\t\tctxt->ops->get_msr(ctxt, MSR_EFER, &efer);\n\t\t\tif (efer & EFER_LMA)\n\t\t\t\tgoto exception;\n\t\t}\n\n\t\t/* CS(RPL) <- CPL */\n\t\tselector = (selector & 0xfffc) | cpl;\n\t\tbreak;\n\tcase VCPU_SREG_TR:\n\t\tif (seg_desc.s || (seg_desc.type != 1 && seg_desc.type != 9))\n\t\t\tgoto exception;\n\t\told_desc = seg_desc;\n\t\tseg_desc.type |= 2; /* busy */\n\t\tret = ctxt->ops->cmpxchg_emulated(ctxt, desc_addr, &old_desc, &seg_desc,\n\t\t\t\t\t\t  sizeof(seg_desc), &ctxt->exception);\n\t\tif (ret != X86EMUL_CONTINUE)\n\t\t\treturn ret;\n\t\tbreak;\n\tcase VCPU_SREG_LDTR:\n\t\tif (seg_desc.s || seg_desc.type != 2)\n\t\t\tgoto exception;\n\t\tbreak;\n\tdefault: /*  DS, ES, FS, or GS */\n\t\t/*\n\t\t * segment is not a data or readable code segment or\n\t\t * ((segment is a data or nonconforming code segment)\n\t\t * and (both RPL and CPL > DPL))\n\t\t */\n\t\tif ((seg_desc.type & 0xa) == 0x8 ||\n\t\t    (((seg_desc.type & 0xc) != 0xc) &&\n\t\t     (rpl > dpl && cpl > dpl)))\n\t\t\tgoto exception;\n\t\tbreak;\n\t}\n\n\tif (seg_desc.s) {\n\t\t/* mark segment as accessed */\n\t\tif (!(seg_desc.type & 1)) {\n\t\t\tseg_desc.type |= 1;\n\t\t\tret = write_segment_descriptor(ctxt, selector,\n\t\t\t\t\t\t       &seg_desc);\n\t\t\tif (ret != X86EMUL_CONTINUE)\n\t\t\t\treturn ret;\n\t\t}\n\t} else if (ctxt->mode == X86EMUL_MODE_PROT64) {\n\t\tret = ctxt->ops->read_std(ctxt, desc_addr+8, &base3,\n\t\t\t\tsizeof(base3), &ctxt->exception);\n\t\tif (ret != X86EMUL_CONTINUE)\n\t\t\treturn ret;\n\t\tif (is_noncanonical_address(get_desc_base(&seg_desc) |\n\t\t\t\t\t     ((u64)base3 << 32)))\n\t\t\treturn emulate_gp(ctxt, 0);\n\t}\nload:\n\tctxt->ops->set_segment(ctxt, selector, &seg_desc, base3, seg);\n\tif (desc)\n\t\t*desc = seg_desc;\n\treturn X86EMUL_CONTINUE;\nexception:\n\treturn emulate_exception(ctxt, err_vec, err_code, true);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int __load_segment_descriptor(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t     u16 selector, int seg, u8 cpl,\n\t\t\t\t     enum x86_transfer_type transfer,\n\t\t\t\t     struct desc_struct *desc)\n{\n\tstruct desc_struct seg_desc, old_desc;\n\tu8 dpl, rpl;\n\tunsigned err_vec = GP_VECTOR;\n\tu32 err_code = 0;\n\tbool null_selector = !(selector & ~0x3); /* 0000-0003 are null */\n\tulong desc_addr;\n\tint ret;\n\tu16 dummy;\n\tu32 base3 = 0;\n\n\tmemset(&seg_desc, 0, sizeof seg_desc);\n\n\tif (ctxt->mode == X86EMUL_MODE_REAL) {\n\t\t/* set real mode segment descriptor (keep limit etc. for\n\t\t * unreal mode) */\n\t\tctxt->ops->get_segment(ctxt, &dummy, &seg_desc, NULL, seg);\n\t\tset_desc_base(&seg_desc, selector << 4);\n\t\tgoto load;\n\t} else if (seg <= VCPU_SREG_GS && ctxt->mode == X86EMUL_MODE_VM86) {\n\t\t/* VM86 needs a clean new segment descriptor */\n\t\tset_desc_base(&seg_desc, selector << 4);\n\t\tset_desc_limit(&seg_desc, 0xffff);\n\t\tseg_desc.type = 3;\n\t\tseg_desc.p = 1;\n\t\tseg_desc.s = 1;\n\t\tseg_desc.dpl = 3;\n\t\tgoto load;\n\t}\n\n\trpl = selector & 3;\n\n\t/* NULL selector is not valid for TR, CS and SS (except for long mode) */\n\tif ((seg == VCPU_SREG_CS\n\t     || (seg == VCPU_SREG_SS\n\t\t && (ctxt->mode != X86EMUL_MODE_PROT64 || rpl != cpl))\n\t     || seg == VCPU_SREG_TR)\n\t    && null_selector)\n\t\tgoto exception;\n\n\t/* TR should be in GDT only */\n\tif (seg == VCPU_SREG_TR && (selector & (1 << 2)))\n\t\tgoto exception;\n\n\tif (null_selector) /* for NULL selector skip all following checks */\n\t\tgoto load;\n\n\tret = read_segment_descriptor(ctxt, selector, &seg_desc, &desc_addr);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\n\terr_code = selector & 0xfffc;\n\terr_vec = (transfer == X86_TRANSFER_TASK_SWITCH) ? TS_VECTOR :\n\t\t\t\t\t\t\t   GP_VECTOR;\n\n\t/* can't load system descriptor into segment selector */\n\tif (seg <= VCPU_SREG_GS && !seg_desc.s) {\n\t\tif (transfer == X86_TRANSFER_CALL_JMP)\n\t\t\treturn X86EMUL_UNHANDLEABLE;\n\t\tgoto exception;\n\t}\n\n\tif (!seg_desc.p) {\n\t\terr_vec = (seg == VCPU_SREG_SS) ? SS_VECTOR : NP_VECTOR;\n\t\tgoto exception;\n\t}\n\n\tdpl = seg_desc.dpl;\n\n\tswitch (seg) {\n\tcase VCPU_SREG_SS:\n\t\t/*\n\t\t * segment is not a writable data segment or segment\n\t\t * selector's RPL != CPL or segment selector's RPL != CPL\n\t\t */\n\t\tif (rpl != cpl || (seg_desc.type & 0xa) != 0x2 || dpl != cpl)\n\t\t\tgoto exception;\n\t\tbreak;\n\tcase VCPU_SREG_CS:\n\t\tif (!(seg_desc.type & 8))\n\t\t\tgoto exception;\n\n\t\tif (seg_desc.type & 4) {\n\t\t\t/* conforming */\n\t\t\tif (dpl > cpl)\n\t\t\t\tgoto exception;\n\t\t} else {\n\t\t\t/* nonconforming */\n\t\t\tif (rpl > cpl || dpl != cpl)\n\t\t\t\tgoto exception;\n\t\t}\n\t\t/* in long-mode d/b must be clear if l is set */\n\t\tif (seg_desc.d && seg_desc.l) {\n\t\t\tu64 efer = 0;\n\n\t\t\tctxt->ops->get_msr(ctxt, MSR_EFER, &efer);\n\t\t\tif (efer & EFER_LMA)\n\t\t\t\tgoto exception;\n\t\t}\n\n\t\t/* CS(RPL) <- CPL */\n\t\tselector = (selector & 0xfffc) | cpl;\n\t\tbreak;\n\tcase VCPU_SREG_TR:\n\t\tif (seg_desc.s || (seg_desc.type != 1 && seg_desc.type != 9))\n\t\t\tgoto exception;\n\t\told_desc = seg_desc;\n\t\tseg_desc.type |= 2; /* busy */\n\t\tret = ctxt->ops->cmpxchg_emulated(ctxt, desc_addr, &old_desc, &seg_desc,\n\t\t\t\t\t\t  sizeof(seg_desc), &ctxt->exception);\n\t\tif (ret != X86EMUL_CONTINUE)\n\t\t\treturn ret;\n\t\tbreak;\n\tcase VCPU_SREG_LDTR:\n\t\tif (seg_desc.s || seg_desc.type != 2)\n\t\t\tgoto exception;\n\t\tbreak;\n\tdefault: /*  DS, ES, FS, or GS */\n\t\t/*\n\t\t * segment is not a data or readable code segment or\n\t\t * ((segment is a data or nonconforming code segment)\n\t\t * and (both RPL and CPL > DPL))\n\t\t */\n\t\tif ((seg_desc.type & 0xa) == 0x8 ||\n\t\t    (((seg_desc.type & 0xc) != 0xc) &&\n\t\t     (rpl > dpl && cpl > dpl)))\n\t\t\tgoto exception;\n\t\tbreak;\n\t}\n\n\tif (seg_desc.s) {\n\t\t/* mark segment as accessed */\n\t\tif (!(seg_desc.type & 1)) {\n\t\t\tseg_desc.type |= 1;\n\t\t\tret = write_segment_descriptor(ctxt, selector,\n\t\t\t\t\t\t       &seg_desc);\n\t\t\tif (ret != X86EMUL_CONTINUE)\n\t\t\t\treturn ret;\n\t\t}\n\t} else if (ctxt->mode == X86EMUL_MODE_PROT64) {\n\t\tret = ctxt->ops->read_std(ctxt, desc_addr+8, &base3,\n\t\t\t\tsizeof(base3), &ctxt->exception);\n\t\tif (ret != X86EMUL_CONTINUE)\n\t\t\treturn ret;\n\t\tif (is_noncanonical_address(get_desc_base(&seg_desc) |\n\t\t\t\t\t     ((u64)base3 << 32)))\n\t\t\treturn emulate_gp(ctxt, 0);\n\t}\nload:\n\tctxt->ops->set_segment(ctxt, selector, &seg_desc, base3, seg);\n\tif (desc)\n\t\t*desc = seg_desc;\n\treturn X86EMUL_CONTINUE;\nexception:\n\treturn emulate_exception(ctxt, err_vec, err_code, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "emulate_pop",
          "args": [
            "ctxt",
            "&cs",
            "ctxt->op_bytes"
          ],
          "line": 2205
        },
        "resolved": true,
        "details": {
          "function_name": "emulate_popf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "1802-1842",
          "snippet": "static int emulate_popf(struct x86_emulate_ctxt *ctxt,\n\t\t\tvoid *dest, int len)\n{\n\tint rc;\n\tunsigned long val, change_mask;\n\tint iopl = (ctxt->eflags & X86_EFLAGS_IOPL) >> X86_EFLAGS_IOPL_BIT;\n\tint cpl = ctxt->ops->cpl(ctxt);\n\n\trc = emulate_pop(ctxt, &val, len);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\tchange_mask = X86_EFLAGS_CF | X86_EFLAGS_PF | X86_EFLAGS_AF |\n\t\t      X86_EFLAGS_ZF | X86_EFLAGS_SF | X86_EFLAGS_OF |\n\t\t      X86_EFLAGS_TF | X86_EFLAGS_DF | X86_EFLAGS_NT |\n\t\t      X86_EFLAGS_AC | X86_EFLAGS_ID;\n\n\tswitch(ctxt->mode) {\n\tcase X86EMUL_MODE_PROT64:\n\tcase X86EMUL_MODE_PROT32:\n\tcase X86EMUL_MODE_PROT16:\n\t\tif (cpl == 0)\n\t\t\tchange_mask |= X86_EFLAGS_IOPL;\n\t\tif (cpl <= iopl)\n\t\t\tchange_mask |= X86_EFLAGS_IF;\n\t\tbreak;\n\tcase X86EMUL_MODE_VM86:\n\t\tif (iopl < 3)\n\t\t\treturn emulate_gp(ctxt, 0);\n\t\tchange_mask |= X86_EFLAGS_IF;\n\t\tbreak;\n\tdefault: /* real mode */\n\t\tchange_mask |= (X86_EFLAGS_IOPL | X86_EFLAGS_IF);\n\t\tbreak;\n\t}\n\n\t*(unsigned long *)dest =\n\t\t(ctxt->eflags & ~change_mask) | (val & change_mask);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int emulate_popf(struct x86_emulate_ctxt *ctxt,\n\t\t\tvoid *dest, int len)\n{\n\tint rc;\n\tunsigned long val, change_mask;\n\tint iopl = (ctxt->eflags & X86_EFLAGS_IOPL) >> X86_EFLAGS_IOPL_BIT;\n\tint cpl = ctxt->ops->cpl(ctxt);\n\n\trc = emulate_pop(ctxt, &val, len);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\tchange_mask = X86_EFLAGS_CF | X86_EFLAGS_PF | X86_EFLAGS_AF |\n\t\t      X86_EFLAGS_ZF | X86_EFLAGS_SF | X86_EFLAGS_OF |\n\t\t      X86_EFLAGS_TF | X86_EFLAGS_DF | X86_EFLAGS_NT |\n\t\t      X86_EFLAGS_AC | X86_EFLAGS_ID;\n\n\tswitch(ctxt->mode) {\n\tcase X86EMUL_MODE_PROT64:\n\tcase X86EMUL_MODE_PROT32:\n\tcase X86EMUL_MODE_PROT16:\n\t\tif (cpl == 0)\n\t\t\tchange_mask |= X86_EFLAGS_IOPL;\n\t\tif (cpl <= iopl)\n\t\t\tchange_mask |= X86_EFLAGS_IF;\n\t\tbreak;\n\tcase X86EMUL_MODE_VM86:\n\t\tif (iopl < 3)\n\t\t\treturn emulate_gp(ctxt, 0);\n\t\tchange_mask |= X86_EFLAGS_IF;\n\t\tbreak;\n\tdefault: /* real mode */\n\t\tchange_mask |= (X86_EFLAGS_IOPL | X86_EFLAGS_IF);\n\t\tbreak;\n\t}\n\n\t*(unsigned long *)dest =\n\t\t(ctxt->eflags & ~change_mask) | (val & change_mask);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ops->get_segment",
          "args": [
            "ctxt",
            "&old_cs",
            "&old_desc",
            "NULL",
            "VCPU_SREG_CS"
          ],
          "line": 2199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ctxt->ops->cpl",
          "args": [
            "ctxt"
          ],
          "line": 2194
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int em_ret_far(struct x86_emulate_ctxt *ctxt)\n{\n\tint rc;\n\tunsigned long eip, cs;\n\tu16 old_cs;\n\tint cpl = ctxt->ops->cpl(ctxt);\n\tstruct desc_struct old_desc, new_desc;\n\tconst struct x86_emulate_ops *ops = ctxt->ops;\n\n\tif (ctxt->mode == X86EMUL_MODE_PROT64)\n\t\tops->get_segment(ctxt, &old_cs, &old_desc, NULL,\n\t\t\t\t VCPU_SREG_CS);\n\n\trc = emulate_pop(ctxt, &eip, ctxt->op_bytes);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\trc = emulate_pop(ctxt, &cs, ctxt->op_bytes);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\t/* Outer-privilege level return is not implemented */\n\tif (ctxt->mode >= X86EMUL_MODE_PROT16 && (cs & 3) > cpl)\n\t\treturn X86EMUL_UNHANDLEABLE;\n\trc = __load_segment_descriptor(ctxt, (u16)cs, VCPU_SREG_CS, cpl,\n\t\t\t\t       X86_TRANSFER_RET,\n\t\t\t\t       &new_desc);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\trc = assign_eip_far(ctxt, eip, &new_desc);\n\tif (rc != X86EMUL_CONTINUE) {\n\t\tWARN_ON(ctxt->mode != X86EMUL_MODE_PROT64);\n\t\tops->set_segment(ctxt, old_cs, &old_desc, 0, VCPU_SREG_CS);\n\t}\n\treturn rc;\n}"
  },
  {
    "function_name": "em_ret",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "2177-2187",
    "snippet": "static int em_ret(struct x86_emulate_ctxt *ctxt)\n{\n\tint rc;\n\tunsigned long eip;\n\n\trc = emulate_pop(ctxt, &eip, ctxt->op_bytes);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\treturn assign_eip_near(ctxt, eip);\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "assign_eip_near",
          "args": [
            "ctxt",
            "eip"
          ],
          "line": 2186
        },
        "resolved": true,
        "details": {
          "function_name": "assign_eip_near",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "745-748",
          "snippet": "static inline int assign_eip_near(struct x86_emulate_ctxt *ctxt, ulong dst)\n{\n\treturn assign_eip(ctxt, dst, ctxt->mode);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline int assign_eip_near(struct x86_emulate_ctxt *ctxt, ulong dst)\n{\n\treturn assign_eip(ctxt, dst, ctxt->mode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "emulate_pop",
          "args": [
            "ctxt",
            "&eip",
            "ctxt->op_bytes"
          ],
          "line": 2182
        },
        "resolved": true,
        "details": {
          "function_name": "emulate_popf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "1802-1842",
          "snippet": "static int emulate_popf(struct x86_emulate_ctxt *ctxt,\n\t\t\tvoid *dest, int len)\n{\n\tint rc;\n\tunsigned long val, change_mask;\n\tint iopl = (ctxt->eflags & X86_EFLAGS_IOPL) >> X86_EFLAGS_IOPL_BIT;\n\tint cpl = ctxt->ops->cpl(ctxt);\n\n\trc = emulate_pop(ctxt, &val, len);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\tchange_mask = X86_EFLAGS_CF | X86_EFLAGS_PF | X86_EFLAGS_AF |\n\t\t      X86_EFLAGS_ZF | X86_EFLAGS_SF | X86_EFLAGS_OF |\n\t\t      X86_EFLAGS_TF | X86_EFLAGS_DF | X86_EFLAGS_NT |\n\t\t      X86_EFLAGS_AC | X86_EFLAGS_ID;\n\n\tswitch(ctxt->mode) {\n\tcase X86EMUL_MODE_PROT64:\n\tcase X86EMUL_MODE_PROT32:\n\tcase X86EMUL_MODE_PROT16:\n\t\tif (cpl == 0)\n\t\t\tchange_mask |= X86_EFLAGS_IOPL;\n\t\tif (cpl <= iopl)\n\t\t\tchange_mask |= X86_EFLAGS_IF;\n\t\tbreak;\n\tcase X86EMUL_MODE_VM86:\n\t\tif (iopl < 3)\n\t\t\treturn emulate_gp(ctxt, 0);\n\t\tchange_mask |= X86_EFLAGS_IF;\n\t\tbreak;\n\tdefault: /* real mode */\n\t\tchange_mask |= (X86_EFLAGS_IOPL | X86_EFLAGS_IF);\n\t\tbreak;\n\t}\n\n\t*(unsigned long *)dest =\n\t\t(ctxt->eflags & ~change_mask) | (val & change_mask);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int emulate_popf(struct x86_emulate_ctxt *ctxt,\n\t\t\tvoid *dest, int len)\n{\n\tint rc;\n\tunsigned long val, change_mask;\n\tint iopl = (ctxt->eflags & X86_EFLAGS_IOPL) >> X86_EFLAGS_IOPL_BIT;\n\tint cpl = ctxt->ops->cpl(ctxt);\n\n\trc = emulate_pop(ctxt, &val, len);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\tchange_mask = X86_EFLAGS_CF | X86_EFLAGS_PF | X86_EFLAGS_AF |\n\t\t      X86_EFLAGS_ZF | X86_EFLAGS_SF | X86_EFLAGS_OF |\n\t\t      X86_EFLAGS_TF | X86_EFLAGS_DF | X86_EFLAGS_NT |\n\t\t      X86_EFLAGS_AC | X86_EFLAGS_ID;\n\n\tswitch(ctxt->mode) {\n\tcase X86EMUL_MODE_PROT64:\n\tcase X86EMUL_MODE_PROT32:\n\tcase X86EMUL_MODE_PROT16:\n\t\tif (cpl == 0)\n\t\t\tchange_mask |= X86_EFLAGS_IOPL;\n\t\tif (cpl <= iopl)\n\t\t\tchange_mask |= X86_EFLAGS_IF;\n\t\tbreak;\n\tcase X86EMUL_MODE_VM86:\n\t\tif (iopl < 3)\n\t\t\treturn emulate_gp(ctxt, 0);\n\t\tchange_mask |= X86_EFLAGS_IF;\n\t\tbreak;\n\tdefault: /* real mode */\n\t\tchange_mask |= (X86_EFLAGS_IOPL | X86_EFLAGS_IF);\n\t\tbreak;\n\t}\n\n\t*(unsigned long *)dest =\n\t\t(ctxt->eflags & ~change_mask) | (val & change_mask);\n\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int em_ret(struct x86_emulate_ctxt *ctxt)\n{\n\tint rc;\n\tunsigned long eip;\n\n\trc = emulate_pop(ctxt, &eip, ctxt->op_bytes);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\treturn assign_eip_near(ctxt, eip);\n}"
  },
  {
    "function_name": "em_cmpxchg8b",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "2156-2175",
    "snippet": "static int em_cmpxchg8b(struct x86_emulate_ctxt *ctxt)\n{\n\tu64 old = ctxt->dst.orig_val64;\n\n\tif (ctxt->dst.bytes == 16)\n\t\treturn X86EMUL_UNHANDLEABLE;\n\n\tif (((u32) (old >> 0) != (u32) reg_read(ctxt, VCPU_REGS_RAX)) ||\n\t    ((u32) (old >> 32) != (u32) reg_read(ctxt, VCPU_REGS_RDX))) {\n\t\t*reg_write(ctxt, VCPU_REGS_RAX) = (u32) (old >> 0);\n\t\t*reg_write(ctxt, VCPU_REGS_RDX) = (u32) (old >> 32);\n\t\tctxt->eflags &= ~X86_EFLAGS_ZF;\n\t} else {\n\t\tctxt->dst.val64 = ((u64)reg_read(ctxt, VCPU_REGS_RCX) << 32) |\n\t\t\t(u32) reg_read(ctxt, VCPU_REGS_RBX);\n\n\t\tctxt->eflags |= X86_EFLAGS_ZF;\n\t}\n\treturn X86EMUL_CONTINUE;\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reg_read",
          "args": [
            "ctxt",
            "VCPU_REGS_RBX"
          ],
          "line": 2170
        },
        "resolved": true,
        "details": {
          "function_name": "reg_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "261-268",
          "snippet": "static ulong reg_read(struct x86_emulate_ctxt *ctxt, unsigned nr)\n{\n\tif (!(ctxt->regs_valid & (1 << nr))) {\n\t\tctxt->regs_valid |= 1 << nr;\n\t\tctxt->_regs[nr] = ctxt->ops->read_gpr(ctxt, nr);\n\t}\n\treturn ctxt->_regs[nr];\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic ulong reg_read(struct x86_emulate_ctxt *ctxt, unsigned nr)\n{\n\tif (!(ctxt->regs_valid & (1 << nr))) {\n\t\tctxt->regs_valid |= 1 << nr;\n\t\tctxt->_regs[nr] = ctxt->ops->read_gpr(ctxt, nr);\n\t}\n\treturn ctxt->_regs[nr];\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "old >> 32"
          ],
          "line": 2166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reg_write",
          "args": [
            "ctxt",
            "VCPU_REGS_RDX"
          ],
          "line": 2166
        },
        "resolved": true,
        "details": {
          "function_name": "reg_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "270-275",
          "snippet": "static ulong *reg_write(struct x86_emulate_ctxt *ctxt, unsigned nr)\n{\n\tctxt->regs_valid |= 1 << nr;\n\tctxt->regs_dirty |= 1 << nr;\n\treturn &ctxt->_regs[nr];\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic ulong *reg_write(struct x86_emulate_ctxt *ctxt, unsigned nr)\n{\n\tctxt->regs_valid |= 1 << nr;\n\tctxt->regs_dirty |= 1 << nr;\n\treturn &ctxt->_regs[nr];\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "old >> 0"
          ],
          "line": 2165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "old >> 32"
          ],
          "line": 2164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "old >> 0"
          ],
          "line": 2163
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int em_cmpxchg8b(struct x86_emulate_ctxt *ctxt)\n{\n\tu64 old = ctxt->dst.orig_val64;\n\n\tif (ctxt->dst.bytes == 16)\n\t\treturn X86EMUL_UNHANDLEABLE;\n\n\tif (((u32) (old >> 0) != (u32) reg_read(ctxt, VCPU_REGS_RAX)) ||\n\t    ((u32) (old >> 32) != (u32) reg_read(ctxt, VCPU_REGS_RDX))) {\n\t\t*reg_write(ctxt, VCPU_REGS_RAX) = (u32) (old >> 0);\n\t\t*reg_write(ctxt, VCPU_REGS_RDX) = (u32) (old >> 32);\n\t\tctxt->eflags &= ~X86_EFLAGS_ZF;\n\t} else {\n\t\tctxt->dst.val64 = ((u64)reg_read(ctxt, VCPU_REGS_RCX) << 32) |\n\t\t\t(u32) reg_read(ctxt, VCPU_REGS_RBX);\n\n\t\tctxt->eflags |= X86_EFLAGS_ZF;\n\t}\n\treturn X86EMUL_CONTINUE;\n}"
  },
  {
    "function_name": "em_call_near_abs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "2142-2154",
    "snippet": "static int em_call_near_abs(struct x86_emulate_ctxt *ctxt)\n{\n\tint rc;\n\tlong int old_eip;\n\n\told_eip = ctxt->_eip;\n\trc = assign_eip_near(ctxt, ctxt->src.val);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\tctxt->src.val = old_eip;\n\trc = em_push(ctxt);\n\treturn rc;\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "em_push",
          "args": [
            "ctxt"
          ],
          "line": 2152
        },
        "resolved": true,
        "details": {
          "function_name": "em_pushf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "1933-1937",
          "snippet": "static int em_pushf(struct x86_emulate_ctxt *ctxt)\n{\n\tctxt->src.val = (unsigned long)ctxt->eflags & ~X86_EFLAGS_VM;\n\treturn em_push(ctxt);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int em_pushf(struct x86_emulate_ctxt *ctxt)\n{\n\tctxt->src.val = (unsigned long)ctxt->eflags & ~X86_EFLAGS_VM;\n\treturn em_push(ctxt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assign_eip_near",
          "args": [
            "ctxt",
            "ctxt->src.val"
          ],
          "line": 2148
        },
        "resolved": true,
        "details": {
          "function_name": "assign_eip_near",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "745-748",
          "snippet": "static inline int assign_eip_near(struct x86_emulate_ctxt *ctxt, ulong dst)\n{\n\treturn assign_eip(ctxt, dst, ctxt->mode);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline int assign_eip_near(struct x86_emulate_ctxt *ctxt, ulong dst)\n{\n\treturn assign_eip(ctxt, dst, ctxt->mode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int em_call_near_abs(struct x86_emulate_ctxt *ctxt)\n{\n\tint rc;\n\tlong int old_eip;\n\n\told_eip = ctxt->_eip;\n\trc = assign_eip_near(ctxt, ctxt->src.val);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\tctxt->src.val = old_eip;\n\trc = em_push(ctxt);\n\treturn rc;\n}"
  },
  {
    "function_name": "em_jmp_abs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "2137-2140",
    "snippet": "static int em_jmp_abs(struct x86_emulate_ctxt *ctxt)\n{\n\treturn assign_eip_near(ctxt, ctxt->src.val);\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "assign_eip_near",
          "args": [
            "ctxt",
            "ctxt->src.val"
          ],
          "line": 2139
        },
        "resolved": true,
        "details": {
          "function_name": "assign_eip_near",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "745-748",
          "snippet": "static inline int assign_eip_near(struct x86_emulate_ctxt *ctxt, ulong dst)\n{\n\treturn assign_eip(ctxt, dst, ctxt->mode);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline int assign_eip_near(struct x86_emulate_ctxt *ctxt, ulong dst)\n{\n\treturn assign_eip(ctxt, dst, ctxt->mode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int em_jmp_abs(struct x86_emulate_ctxt *ctxt)\n{\n\treturn assign_eip_near(ctxt, ctxt->src.val);\n}"
  },
  {
    "function_name": "em_jmp_far",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "2106-2135",
    "snippet": "static int em_jmp_far(struct x86_emulate_ctxt *ctxt)\n{\n\tint rc;\n\tunsigned short sel, old_sel;\n\tstruct desc_struct old_desc, new_desc;\n\tconst struct x86_emulate_ops *ops = ctxt->ops;\n\tu8 cpl = ctxt->ops->cpl(ctxt);\n\n\t/* Assignment of RIP may only fail in 64-bit mode */\n\tif (ctxt->mode == X86EMUL_MODE_PROT64)\n\t\tops->get_segment(ctxt, &old_sel, &old_desc, NULL,\n\t\t\t\t VCPU_SREG_CS);\n\n\tmemcpy(&sel, ctxt->src.valptr + ctxt->op_bytes, 2);\n\n\trc = __load_segment_descriptor(ctxt, sel, VCPU_SREG_CS, cpl,\n\t\t\t\t       X86_TRANSFER_CALL_JMP,\n\t\t\t\t       &new_desc);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\trc = assign_eip_far(ctxt, ctxt->src.val, &new_desc);\n\tif (rc != X86EMUL_CONTINUE) {\n\t\tWARN_ON(ctxt->mode != X86EMUL_MODE_PROT64);\n\t\t/* assigning eip failed; restore the old cs */\n\t\tops->set_segment(ctxt, old_sel, &old_desc, 0, VCPU_SREG_CS);\n\t\treturn rc;\n\t}\n\treturn rc;\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ops->set_segment",
          "args": [
            "ctxt",
            "old_sel",
            "&old_desc",
            "0",
            "VCPU_SREG_CS"
          ],
          "line": 2131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "ctxt->mode != X86EMUL_MODE_PROT64"
          ],
          "line": 2129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assign_eip_far",
          "args": [
            "ctxt",
            "ctxt->src.val",
            "&new_desc"
          ],
          "line": 2127
        },
        "resolved": true,
        "details": {
          "function_name": "assign_eip_far",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "750-774",
          "snippet": "static int assign_eip_far(struct x86_emulate_ctxt *ctxt, ulong dst,\n\t\t\t  const struct desc_struct *cs_desc)\n{\n\tenum x86emul_mode mode = ctxt->mode;\n\tint rc;\n\n#ifdef CONFIG_X86_64\n\tif (ctxt->mode >= X86EMUL_MODE_PROT16) {\n\t\tif (cs_desc->l) {\n\t\t\tu64 efer = 0;\n\n\t\t\tctxt->ops->get_msr(ctxt, MSR_EFER, &efer);\n\t\t\tif (efer & EFER_LMA)\n\t\t\t\tmode = X86EMUL_MODE_PROT64;\n\t\t} else\n\t\t\tmode = X86EMUL_MODE_PROT32; /* temporary value */\n\t}\n#endif\n\tif (mode == X86EMUL_MODE_PROT16 || mode == X86EMUL_MODE_PROT32)\n\t\tmode = cs_desc->d ? X86EMUL_MODE_PROT32 : X86EMUL_MODE_PROT16;\n\trc = assign_eip(ctxt, dst, mode);\n\tif (rc == X86EMUL_CONTINUE)\n\t\tctxt->mode = mode;\n\treturn rc;\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int assign_eip_far(struct x86_emulate_ctxt *ctxt, ulong dst,\n\t\t\t  const struct desc_struct *cs_desc)\n{\n\tenum x86emul_mode mode = ctxt->mode;\n\tint rc;\n\n#ifdef CONFIG_X86_64\n\tif (ctxt->mode >= X86EMUL_MODE_PROT16) {\n\t\tif (cs_desc->l) {\n\t\t\tu64 efer = 0;\n\n\t\t\tctxt->ops->get_msr(ctxt, MSR_EFER, &efer);\n\t\t\tif (efer & EFER_LMA)\n\t\t\t\tmode = X86EMUL_MODE_PROT64;\n\t\t} else\n\t\t\tmode = X86EMUL_MODE_PROT32; /* temporary value */\n\t}\n#endif\n\tif (mode == X86EMUL_MODE_PROT16 || mode == X86EMUL_MODE_PROT32)\n\t\tmode = cs_desc->d ? X86EMUL_MODE_PROT32 : X86EMUL_MODE_PROT16;\n\trc = assign_eip(ctxt, dst, mode);\n\tif (rc == X86EMUL_CONTINUE)\n\t\tctxt->mode = mode;\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__load_segment_descriptor",
          "args": [
            "ctxt",
            "sel",
            "VCPU_SREG_CS",
            "cpl",
            "X86_TRANSFER_CALL_JMP",
            "&new_desc"
          ],
          "line": 2121
        },
        "resolved": true,
        "details": {
          "function_name": "__load_segment_descriptor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "1549-1708",
          "snippet": "static int __load_segment_descriptor(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t     u16 selector, int seg, u8 cpl,\n\t\t\t\t     enum x86_transfer_type transfer,\n\t\t\t\t     struct desc_struct *desc)\n{\n\tstruct desc_struct seg_desc, old_desc;\n\tu8 dpl, rpl;\n\tunsigned err_vec = GP_VECTOR;\n\tu32 err_code = 0;\n\tbool null_selector = !(selector & ~0x3); /* 0000-0003 are null */\n\tulong desc_addr;\n\tint ret;\n\tu16 dummy;\n\tu32 base3 = 0;\n\n\tmemset(&seg_desc, 0, sizeof seg_desc);\n\n\tif (ctxt->mode == X86EMUL_MODE_REAL) {\n\t\t/* set real mode segment descriptor (keep limit etc. for\n\t\t * unreal mode) */\n\t\tctxt->ops->get_segment(ctxt, &dummy, &seg_desc, NULL, seg);\n\t\tset_desc_base(&seg_desc, selector << 4);\n\t\tgoto load;\n\t} else if (seg <= VCPU_SREG_GS && ctxt->mode == X86EMUL_MODE_VM86) {\n\t\t/* VM86 needs a clean new segment descriptor */\n\t\tset_desc_base(&seg_desc, selector << 4);\n\t\tset_desc_limit(&seg_desc, 0xffff);\n\t\tseg_desc.type = 3;\n\t\tseg_desc.p = 1;\n\t\tseg_desc.s = 1;\n\t\tseg_desc.dpl = 3;\n\t\tgoto load;\n\t}\n\n\trpl = selector & 3;\n\n\t/* NULL selector is not valid for TR, CS and SS (except for long mode) */\n\tif ((seg == VCPU_SREG_CS\n\t     || (seg == VCPU_SREG_SS\n\t\t && (ctxt->mode != X86EMUL_MODE_PROT64 || rpl != cpl))\n\t     || seg == VCPU_SREG_TR)\n\t    && null_selector)\n\t\tgoto exception;\n\n\t/* TR should be in GDT only */\n\tif (seg == VCPU_SREG_TR && (selector & (1 << 2)))\n\t\tgoto exception;\n\n\tif (null_selector) /* for NULL selector skip all following checks */\n\t\tgoto load;\n\n\tret = read_segment_descriptor(ctxt, selector, &seg_desc, &desc_addr);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\n\terr_code = selector & 0xfffc;\n\terr_vec = (transfer == X86_TRANSFER_TASK_SWITCH) ? TS_VECTOR :\n\t\t\t\t\t\t\t   GP_VECTOR;\n\n\t/* can't load system descriptor into segment selector */\n\tif (seg <= VCPU_SREG_GS && !seg_desc.s) {\n\t\tif (transfer == X86_TRANSFER_CALL_JMP)\n\t\t\treturn X86EMUL_UNHANDLEABLE;\n\t\tgoto exception;\n\t}\n\n\tif (!seg_desc.p) {\n\t\terr_vec = (seg == VCPU_SREG_SS) ? SS_VECTOR : NP_VECTOR;\n\t\tgoto exception;\n\t}\n\n\tdpl = seg_desc.dpl;\n\n\tswitch (seg) {\n\tcase VCPU_SREG_SS:\n\t\t/*\n\t\t * segment is not a writable data segment or segment\n\t\t * selector's RPL != CPL or segment selector's RPL != CPL\n\t\t */\n\t\tif (rpl != cpl || (seg_desc.type & 0xa) != 0x2 || dpl != cpl)\n\t\t\tgoto exception;\n\t\tbreak;\n\tcase VCPU_SREG_CS:\n\t\tif (!(seg_desc.type & 8))\n\t\t\tgoto exception;\n\n\t\tif (seg_desc.type & 4) {\n\t\t\t/* conforming */\n\t\t\tif (dpl > cpl)\n\t\t\t\tgoto exception;\n\t\t} else {\n\t\t\t/* nonconforming */\n\t\t\tif (rpl > cpl || dpl != cpl)\n\t\t\t\tgoto exception;\n\t\t}\n\t\t/* in long-mode d/b must be clear if l is set */\n\t\tif (seg_desc.d && seg_desc.l) {\n\t\t\tu64 efer = 0;\n\n\t\t\tctxt->ops->get_msr(ctxt, MSR_EFER, &efer);\n\t\t\tif (efer & EFER_LMA)\n\t\t\t\tgoto exception;\n\t\t}\n\n\t\t/* CS(RPL) <- CPL */\n\t\tselector = (selector & 0xfffc) | cpl;\n\t\tbreak;\n\tcase VCPU_SREG_TR:\n\t\tif (seg_desc.s || (seg_desc.type != 1 && seg_desc.type != 9))\n\t\t\tgoto exception;\n\t\told_desc = seg_desc;\n\t\tseg_desc.type |= 2; /* busy */\n\t\tret = ctxt->ops->cmpxchg_emulated(ctxt, desc_addr, &old_desc, &seg_desc,\n\t\t\t\t\t\t  sizeof(seg_desc), &ctxt->exception);\n\t\tif (ret != X86EMUL_CONTINUE)\n\t\t\treturn ret;\n\t\tbreak;\n\tcase VCPU_SREG_LDTR:\n\t\tif (seg_desc.s || seg_desc.type != 2)\n\t\t\tgoto exception;\n\t\tbreak;\n\tdefault: /*  DS, ES, FS, or GS */\n\t\t/*\n\t\t * segment is not a data or readable code segment or\n\t\t * ((segment is a data or nonconforming code segment)\n\t\t * and (both RPL and CPL > DPL))\n\t\t */\n\t\tif ((seg_desc.type & 0xa) == 0x8 ||\n\t\t    (((seg_desc.type & 0xc) != 0xc) &&\n\t\t     (rpl > dpl && cpl > dpl)))\n\t\t\tgoto exception;\n\t\tbreak;\n\t}\n\n\tif (seg_desc.s) {\n\t\t/* mark segment as accessed */\n\t\tif (!(seg_desc.type & 1)) {\n\t\t\tseg_desc.type |= 1;\n\t\t\tret = write_segment_descriptor(ctxt, selector,\n\t\t\t\t\t\t       &seg_desc);\n\t\t\tif (ret != X86EMUL_CONTINUE)\n\t\t\t\treturn ret;\n\t\t}\n\t} else if (ctxt->mode == X86EMUL_MODE_PROT64) {\n\t\tret = ctxt->ops->read_std(ctxt, desc_addr+8, &base3,\n\t\t\t\tsizeof(base3), &ctxt->exception);\n\t\tif (ret != X86EMUL_CONTINUE)\n\t\t\treturn ret;\n\t\tif (is_noncanonical_address(get_desc_base(&seg_desc) |\n\t\t\t\t\t     ((u64)base3 << 32)))\n\t\t\treturn emulate_gp(ctxt, 0);\n\t}\nload:\n\tctxt->ops->set_segment(ctxt, selector, &seg_desc, base3, seg);\n\tif (desc)\n\t\t*desc = seg_desc;\n\treturn X86EMUL_CONTINUE;\nexception:\n\treturn emulate_exception(ctxt, err_vec, err_code, true);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int __load_segment_descriptor(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t     u16 selector, int seg, u8 cpl,\n\t\t\t\t     enum x86_transfer_type transfer,\n\t\t\t\t     struct desc_struct *desc)\n{\n\tstruct desc_struct seg_desc, old_desc;\n\tu8 dpl, rpl;\n\tunsigned err_vec = GP_VECTOR;\n\tu32 err_code = 0;\n\tbool null_selector = !(selector & ~0x3); /* 0000-0003 are null */\n\tulong desc_addr;\n\tint ret;\n\tu16 dummy;\n\tu32 base3 = 0;\n\n\tmemset(&seg_desc, 0, sizeof seg_desc);\n\n\tif (ctxt->mode == X86EMUL_MODE_REAL) {\n\t\t/* set real mode segment descriptor (keep limit etc. for\n\t\t * unreal mode) */\n\t\tctxt->ops->get_segment(ctxt, &dummy, &seg_desc, NULL, seg);\n\t\tset_desc_base(&seg_desc, selector << 4);\n\t\tgoto load;\n\t} else if (seg <= VCPU_SREG_GS && ctxt->mode == X86EMUL_MODE_VM86) {\n\t\t/* VM86 needs a clean new segment descriptor */\n\t\tset_desc_base(&seg_desc, selector << 4);\n\t\tset_desc_limit(&seg_desc, 0xffff);\n\t\tseg_desc.type = 3;\n\t\tseg_desc.p = 1;\n\t\tseg_desc.s = 1;\n\t\tseg_desc.dpl = 3;\n\t\tgoto load;\n\t}\n\n\trpl = selector & 3;\n\n\t/* NULL selector is not valid for TR, CS and SS (except for long mode) */\n\tif ((seg == VCPU_SREG_CS\n\t     || (seg == VCPU_SREG_SS\n\t\t && (ctxt->mode != X86EMUL_MODE_PROT64 || rpl != cpl))\n\t     || seg == VCPU_SREG_TR)\n\t    && null_selector)\n\t\tgoto exception;\n\n\t/* TR should be in GDT only */\n\tif (seg == VCPU_SREG_TR && (selector & (1 << 2)))\n\t\tgoto exception;\n\n\tif (null_selector) /* for NULL selector skip all following checks */\n\t\tgoto load;\n\n\tret = read_segment_descriptor(ctxt, selector, &seg_desc, &desc_addr);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\n\terr_code = selector & 0xfffc;\n\terr_vec = (transfer == X86_TRANSFER_TASK_SWITCH) ? TS_VECTOR :\n\t\t\t\t\t\t\t   GP_VECTOR;\n\n\t/* can't load system descriptor into segment selector */\n\tif (seg <= VCPU_SREG_GS && !seg_desc.s) {\n\t\tif (transfer == X86_TRANSFER_CALL_JMP)\n\t\t\treturn X86EMUL_UNHANDLEABLE;\n\t\tgoto exception;\n\t}\n\n\tif (!seg_desc.p) {\n\t\terr_vec = (seg == VCPU_SREG_SS) ? SS_VECTOR : NP_VECTOR;\n\t\tgoto exception;\n\t}\n\n\tdpl = seg_desc.dpl;\n\n\tswitch (seg) {\n\tcase VCPU_SREG_SS:\n\t\t/*\n\t\t * segment is not a writable data segment or segment\n\t\t * selector's RPL != CPL or segment selector's RPL != CPL\n\t\t */\n\t\tif (rpl != cpl || (seg_desc.type & 0xa) != 0x2 || dpl != cpl)\n\t\t\tgoto exception;\n\t\tbreak;\n\tcase VCPU_SREG_CS:\n\t\tif (!(seg_desc.type & 8))\n\t\t\tgoto exception;\n\n\t\tif (seg_desc.type & 4) {\n\t\t\t/* conforming */\n\t\t\tif (dpl > cpl)\n\t\t\t\tgoto exception;\n\t\t} else {\n\t\t\t/* nonconforming */\n\t\t\tif (rpl > cpl || dpl != cpl)\n\t\t\t\tgoto exception;\n\t\t}\n\t\t/* in long-mode d/b must be clear if l is set */\n\t\tif (seg_desc.d && seg_desc.l) {\n\t\t\tu64 efer = 0;\n\n\t\t\tctxt->ops->get_msr(ctxt, MSR_EFER, &efer);\n\t\t\tif (efer & EFER_LMA)\n\t\t\t\tgoto exception;\n\t\t}\n\n\t\t/* CS(RPL) <- CPL */\n\t\tselector = (selector & 0xfffc) | cpl;\n\t\tbreak;\n\tcase VCPU_SREG_TR:\n\t\tif (seg_desc.s || (seg_desc.type != 1 && seg_desc.type != 9))\n\t\t\tgoto exception;\n\t\told_desc = seg_desc;\n\t\tseg_desc.type |= 2; /* busy */\n\t\tret = ctxt->ops->cmpxchg_emulated(ctxt, desc_addr, &old_desc, &seg_desc,\n\t\t\t\t\t\t  sizeof(seg_desc), &ctxt->exception);\n\t\tif (ret != X86EMUL_CONTINUE)\n\t\t\treturn ret;\n\t\tbreak;\n\tcase VCPU_SREG_LDTR:\n\t\tif (seg_desc.s || seg_desc.type != 2)\n\t\t\tgoto exception;\n\t\tbreak;\n\tdefault: /*  DS, ES, FS, or GS */\n\t\t/*\n\t\t * segment is not a data or readable code segment or\n\t\t * ((segment is a data or nonconforming code segment)\n\t\t * and (both RPL and CPL > DPL))\n\t\t */\n\t\tif ((seg_desc.type & 0xa) == 0x8 ||\n\t\t    (((seg_desc.type & 0xc) != 0xc) &&\n\t\t     (rpl > dpl && cpl > dpl)))\n\t\t\tgoto exception;\n\t\tbreak;\n\t}\n\n\tif (seg_desc.s) {\n\t\t/* mark segment as accessed */\n\t\tif (!(seg_desc.type & 1)) {\n\t\t\tseg_desc.type |= 1;\n\t\t\tret = write_segment_descriptor(ctxt, selector,\n\t\t\t\t\t\t       &seg_desc);\n\t\t\tif (ret != X86EMUL_CONTINUE)\n\t\t\t\treturn ret;\n\t\t}\n\t} else if (ctxt->mode == X86EMUL_MODE_PROT64) {\n\t\tret = ctxt->ops->read_std(ctxt, desc_addr+8, &base3,\n\t\t\t\tsizeof(base3), &ctxt->exception);\n\t\tif (ret != X86EMUL_CONTINUE)\n\t\t\treturn ret;\n\t\tif (is_noncanonical_address(get_desc_base(&seg_desc) |\n\t\t\t\t\t     ((u64)base3 << 32)))\n\t\t\treturn emulate_gp(ctxt, 0);\n\t}\nload:\n\tctxt->ops->set_segment(ctxt, selector, &seg_desc, base3, seg);\n\tif (desc)\n\t\t*desc = seg_desc;\n\treturn X86EMUL_CONTINUE;\nexception:\n\treturn emulate_exception(ctxt, err_vec, err_code, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&sel",
            "ctxt->src.valptr + ctxt->op_bytes",
            "2"
          ],
          "line": 2119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ops->get_segment",
          "args": [
            "ctxt",
            "&old_sel",
            "&old_desc",
            "NULL",
            "VCPU_SREG_CS"
          ],
          "line": 2116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ctxt->ops->cpl",
          "args": [
            "ctxt"
          ],
          "line": 2112
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int em_jmp_far(struct x86_emulate_ctxt *ctxt)\n{\n\tint rc;\n\tunsigned short sel, old_sel;\n\tstruct desc_struct old_desc, new_desc;\n\tconst struct x86_emulate_ops *ops = ctxt->ops;\n\tu8 cpl = ctxt->ops->cpl(ctxt);\n\n\t/* Assignment of RIP may only fail in 64-bit mode */\n\tif (ctxt->mode == X86EMUL_MODE_PROT64)\n\t\tops->get_segment(ctxt, &old_sel, &old_desc, NULL,\n\t\t\t\t VCPU_SREG_CS);\n\n\tmemcpy(&sel, ctxt->src.valptr + ctxt->op_bytes, 2);\n\n\trc = __load_segment_descriptor(ctxt, sel, VCPU_SREG_CS, cpl,\n\t\t\t\t       X86_TRANSFER_CALL_JMP,\n\t\t\t\t       &new_desc);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\trc = assign_eip_far(ctxt, ctxt->src.val, &new_desc);\n\tif (rc != X86EMUL_CONTINUE) {\n\t\tWARN_ON(ctxt->mode != X86EMUL_MODE_PROT64);\n\t\t/* assigning eip failed; restore the old cs */\n\t\tops->set_segment(ctxt, old_sel, &old_desc, 0, VCPU_SREG_CS);\n\t\treturn rc;\n\t}\n\treturn rc;\n}"
  },
  {
    "function_name": "em_iret",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "2091-2104",
    "snippet": "static int em_iret(struct x86_emulate_ctxt *ctxt)\n{\n\tswitch(ctxt->mode) {\n\tcase X86EMUL_MODE_REAL:\n\t\treturn emulate_iret_real(ctxt);\n\tcase X86EMUL_MODE_VM86:\n\tcase X86EMUL_MODE_PROT16:\n\tcase X86EMUL_MODE_PROT32:\n\tcase X86EMUL_MODE_PROT64:\n\tdefault:\n\t\t/* iret from protected mode unimplemented yet */\n\t\treturn X86EMUL_UNHANDLEABLE;\n\t}\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "emulate_iret_real",
          "args": [
            "ctxt"
          ],
          "line": 2095
        },
        "resolved": true,
        "details": {
          "function_name": "emulate_iret_real",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "2035-2089",
          "snippet": "static int emulate_iret_real(struct x86_emulate_ctxt *ctxt)\n{\n\tint rc = X86EMUL_CONTINUE;\n\tunsigned long temp_eip = 0;\n\tunsigned long temp_eflags = 0;\n\tunsigned long cs = 0;\n\tunsigned long mask = X86_EFLAGS_CF | X86_EFLAGS_PF | X86_EFLAGS_AF |\n\t\t\t     X86_EFLAGS_ZF | X86_EFLAGS_SF | X86_EFLAGS_TF |\n\t\t\t     X86_EFLAGS_IF | X86_EFLAGS_DF | X86_EFLAGS_OF |\n\t\t\t     X86_EFLAGS_IOPL | X86_EFLAGS_NT | X86_EFLAGS_RF |\n\t\t\t     X86_EFLAGS_AC | X86_EFLAGS_ID |\n\t\t\t     X86_EFLAGS_FIXED;\n\tunsigned long vm86_mask = X86_EFLAGS_VM | X86_EFLAGS_VIF |\n\t\t\t\t  X86_EFLAGS_VIP;\n\n\t/* TODO: Add stack limit check */\n\n\trc = emulate_pop(ctxt, &temp_eip, ctxt->op_bytes);\n\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\tif (temp_eip & ~0xffff)\n\t\treturn emulate_gp(ctxt, 0);\n\n\trc = emulate_pop(ctxt, &cs, ctxt->op_bytes);\n\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\trc = emulate_pop(ctxt, &temp_eflags, ctxt->op_bytes);\n\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\trc = load_segment_descriptor(ctxt, (u16)cs, VCPU_SREG_CS);\n\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\tctxt->_eip = temp_eip;\n\n\tif (ctxt->op_bytes == 4)\n\t\tctxt->eflags = ((temp_eflags & mask) | (ctxt->eflags & vm86_mask));\n\telse if (ctxt->op_bytes == 2) {\n\t\tctxt->eflags &= ~0xffff;\n\t\tctxt->eflags |= temp_eflags;\n\t}\n\n\tctxt->eflags &= ~EFLG_RESERVED_ZEROS_MASK; /* Clear reserved zeros */\n\tctxt->eflags |= X86_EFLAGS_FIXED;\n\tctxt->ops->set_nmi_mask(ctxt, false);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define EFLG_RESERVED_ZEROS_MASK 0xffc0802a"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\n#define EFLG_RESERVED_ZEROS_MASK 0xffc0802a\n\nstatic int emulate_iret_real(struct x86_emulate_ctxt *ctxt)\n{\n\tint rc = X86EMUL_CONTINUE;\n\tunsigned long temp_eip = 0;\n\tunsigned long temp_eflags = 0;\n\tunsigned long cs = 0;\n\tunsigned long mask = X86_EFLAGS_CF | X86_EFLAGS_PF | X86_EFLAGS_AF |\n\t\t\t     X86_EFLAGS_ZF | X86_EFLAGS_SF | X86_EFLAGS_TF |\n\t\t\t     X86_EFLAGS_IF | X86_EFLAGS_DF | X86_EFLAGS_OF |\n\t\t\t     X86_EFLAGS_IOPL | X86_EFLAGS_NT | X86_EFLAGS_RF |\n\t\t\t     X86_EFLAGS_AC | X86_EFLAGS_ID |\n\t\t\t     X86_EFLAGS_FIXED;\n\tunsigned long vm86_mask = X86_EFLAGS_VM | X86_EFLAGS_VIF |\n\t\t\t\t  X86_EFLAGS_VIP;\n\n\t/* TODO: Add stack limit check */\n\n\trc = emulate_pop(ctxt, &temp_eip, ctxt->op_bytes);\n\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\tif (temp_eip & ~0xffff)\n\t\treturn emulate_gp(ctxt, 0);\n\n\trc = emulate_pop(ctxt, &cs, ctxt->op_bytes);\n\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\trc = emulate_pop(ctxt, &temp_eflags, ctxt->op_bytes);\n\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\trc = load_segment_descriptor(ctxt, (u16)cs, VCPU_SREG_CS);\n\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\tctxt->_eip = temp_eip;\n\n\tif (ctxt->op_bytes == 4)\n\t\tctxt->eflags = ((temp_eflags & mask) | (ctxt->eflags & vm86_mask));\n\telse if (ctxt->op_bytes == 2) {\n\t\tctxt->eflags &= ~0xffff;\n\t\tctxt->eflags |= temp_eflags;\n\t}\n\n\tctxt->eflags &= ~EFLG_RESERVED_ZEROS_MASK; /* Clear reserved zeros */\n\tctxt->eflags |= X86_EFLAGS_FIXED;\n\tctxt->ops->set_nmi_mask(ctxt, false);\n\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int em_iret(struct x86_emulate_ctxt *ctxt)\n{\n\tswitch(ctxt->mode) {\n\tcase X86EMUL_MODE_REAL:\n\t\treturn emulate_iret_real(ctxt);\n\tcase X86EMUL_MODE_VM86:\n\tcase X86EMUL_MODE_PROT16:\n\tcase X86EMUL_MODE_PROT32:\n\tcase X86EMUL_MODE_PROT64:\n\tdefault:\n\t\t/* iret from protected mode unimplemented yet */\n\t\treturn X86EMUL_UNHANDLEABLE;\n\t}\n}"
  },
  {
    "function_name": "emulate_iret_real",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "2035-2089",
    "snippet": "static int emulate_iret_real(struct x86_emulate_ctxt *ctxt)\n{\n\tint rc = X86EMUL_CONTINUE;\n\tunsigned long temp_eip = 0;\n\tunsigned long temp_eflags = 0;\n\tunsigned long cs = 0;\n\tunsigned long mask = X86_EFLAGS_CF | X86_EFLAGS_PF | X86_EFLAGS_AF |\n\t\t\t     X86_EFLAGS_ZF | X86_EFLAGS_SF | X86_EFLAGS_TF |\n\t\t\t     X86_EFLAGS_IF | X86_EFLAGS_DF | X86_EFLAGS_OF |\n\t\t\t     X86_EFLAGS_IOPL | X86_EFLAGS_NT | X86_EFLAGS_RF |\n\t\t\t     X86_EFLAGS_AC | X86_EFLAGS_ID |\n\t\t\t     X86_EFLAGS_FIXED;\n\tunsigned long vm86_mask = X86_EFLAGS_VM | X86_EFLAGS_VIF |\n\t\t\t\t  X86_EFLAGS_VIP;\n\n\t/* TODO: Add stack limit check */\n\n\trc = emulate_pop(ctxt, &temp_eip, ctxt->op_bytes);\n\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\tif (temp_eip & ~0xffff)\n\t\treturn emulate_gp(ctxt, 0);\n\n\trc = emulate_pop(ctxt, &cs, ctxt->op_bytes);\n\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\trc = emulate_pop(ctxt, &temp_eflags, ctxt->op_bytes);\n\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\trc = load_segment_descriptor(ctxt, (u16)cs, VCPU_SREG_CS);\n\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\tctxt->_eip = temp_eip;\n\n\tif (ctxt->op_bytes == 4)\n\t\tctxt->eflags = ((temp_eflags & mask) | (ctxt->eflags & vm86_mask));\n\telse if (ctxt->op_bytes == 2) {\n\t\tctxt->eflags &= ~0xffff;\n\t\tctxt->eflags |= temp_eflags;\n\t}\n\n\tctxt->eflags &= ~EFLG_RESERVED_ZEROS_MASK; /* Clear reserved zeros */\n\tctxt->eflags |= X86_EFLAGS_FIXED;\n\tctxt->ops->set_nmi_mask(ctxt, false);\n\n\treturn rc;\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define EFLG_RESERVED_ZEROS_MASK 0xffc0802a"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ctxt->ops->set_nmi_mask",
          "args": [
            "ctxt",
            "false"
          ],
          "line": 2086
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "load_segment_descriptor",
          "args": [
            "ctxt",
            "(u16)cs",
            "VCPU_SREG_CS"
          ],
          "line": 2070
        },
        "resolved": true,
        "details": {
          "function_name": "load_segment_descriptor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "1710-1716",
          "snippet": "static int load_segment_descriptor(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t   u16 selector, int seg)\n{\n\tu8 cpl = ctxt->ops->cpl(ctxt);\n\treturn __load_segment_descriptor(ctxt, selector, seg, cpl,\n\t\t\t\t\t X86_TRANSFER_NONE, NULL);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int load_segment_descriptor(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t   u16 selector, int seg)\n{\n\tu8 cpl = ctxt->ops->cpl(ctxt);\n\treturn __load_segment_descriptor(ctxt, selector, seg, cpl,\n\t\t\t\t\t X86_TRANSFER_NONE, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "emulate_pop",
          "args": [
            "ctxt",
            "&temp_eflags",
            "ctxt->op_bytes"
          ],
          "line": 2065
        },
        "resolved": true,
        "details": {
          "function_name": "emulate_popf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "1802-1842",
          "snippet": "static int emulate_popf(struct x86_emulate_ctxt *ctxt,\n\t\t\tvoid *dest, int len)\n{\n\tint rc;\n\tunsigned long val, change_mask;\n\tint iopl = (ctxt->eflags & X86_EFLAGS_IOPL) >> X86_EFLAGS_IOPL_BIT;\n\tint cpl = ctxt->ops->cpl(ctxt);\n\n\trc = emulate_pop(ctxt, &val, len);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\tchange_mask = X86_EFLAGS_CF | X86_EFLAGS_PF | X86_EFLAGS_AF |\n\t\t      X86_EFLAGS_ZF | X86_EFLAGS_SF | X86_EFLAGS_OF |\n\t\t      X86_EFLAGS_TF | X86_EFLAGS_DF | X86_EFLAGS_NT |\n\t\t      X86_EFLAGS_AC | X86_EFLAGS_ID;\n\n\tswitch(ctxt->mode) {\n\tcase X86EMUL_MODE_PROT64:\n\tcase X86EMUL_MODE_PROT32:\n\tcase X86EMUL_MODE_PROT16:\n\t\tif (cpl == 0)\n\t\t\tchange_mask |= X86_EFLAGS_IOPL;\n\t\tif (cpl <= iopl)\n\t\t\tchange_mask |= X86_EFLAGS_IF;\n\t\tbreak;\n\tcase X86EMUL_MODE_VM86:\n\t\tif (iopl < 3)\n\t\t\treturn emulate_gp(ctxt, 0);\n\t\tchange_mask |= X86_EFLAGS_IF;\n\t\tbreak;\n\tdefault: /* real mode */\n\t\tchange_mask |= (X86_EFLAGS_IOPL | X86_EFLAGS_IF);\n\t\tbreak;\n\t}\n\n\t*(unsigned long *)dest =\n\t\t(ctxt->eflags & ~change_mask) | (val & change_mask);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int emulate_popf(struct x86_emulate_ctxt *ctxt,\n\t\t\tvoid *dest, int len)\n{\n\tint rc;\n\tunsigned long val, change_mask;\n\tint iopl = (ctxt->eflags & X86_EFLAGS_IOPL) >> X86_EFLAGS_IOPL_BIT;\n\tint cpl = ctxt->ops->cpl(ctxt);\n\n\trc = emulate_pop(ctxt, &val, len);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\tchange_mask = X86_EFLAGS_CF | X86_EFLAGS_PF | X86_EFLAGS_AF |\n\t\t      X86_EFLAGS_ZF | X86_EFLAGS_SF | X86_EFLAGS_OF |\n\t\t      X86_EFLAGS_TF | X86_EFLAGS_DF | X86_EFLAGS_NT |\n\t\t      X86_EFLAGS_AC | X86_EFLAGS_ID;\n\n\tswitch(ctxt->mode) {\n\tcase X86EMUL_MODE_PROT64:\n\tcase X86EMUL_MODE_PROT32:\n\tcase X86EMUL_MODE_PROT16:\n\t\tif (cpl == 0)\n\t\t\tchange_mask |= X86_EFLAGS_IOPL;\n\t\tif (cpl <= iopl)\n\t\t\tchange_mask |= X86_EFLAGS_IF;\n\t\tbreak;\n\tcase X86EMUL_MODE_VM86:\n\t\tif (iopl < 3)\n\t\t\treturn emulate_gp(ctxt, 0);\n\t\tchange_mask |= X86_EFLAGS_IF;\n\t\tbreak;\n\tdefault: /* real mode */\n\t\tchange_mask |= (X86_EFLAGS_IOPL | X86_EFLAGS_IF);\n\t\tbreak;\n\t}\n\n\t*(unsigned long *)dest =\n\t\t(ctxt->eflags & ~change_mask) | (val & change_mask);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "emulate_gp",
          "args": [
            "ctxt",
            "0"
          ],
          "line": 2058
        },
        "resolved": true,
        "details": {
          "function_name": "emulate_gp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "580-583",
          "snippet": "static int emulate_gp(struct x86_emulate_ctxt *ctxt, int err)\n{\n\treturn emulate_exception(ctxt, GP_VECTOR, err, true);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int emulate_gp(struct x86_emulate_ctxt *ctxt, int err)\n{\n\treturn emulate_exception(ctxt, GP_VECTOR, err, true);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\n#define EFLG_RESERVED_ZEROS_MASK 0xffc0802a\n\nstatic int emulate_iret_real(struct x86_emulate_ctxt *ctxt)\n{\n\tint rc = X86EMUL_CONTINUE;\n\tunsigned long temp_eip = 0;\n\tunsigned long temp_eflags = 0;\n\tunsigned long cs = 0;\n\tunsigned long mask = X86_EFLAGS_CF | X86_EFLAGS_PF | X86_EFLAGS_AF |\n\t\t\t     X86_EFLAGS_ZF | X86_EFLAGS_SF | X86_EFLAGS_TF |\n\t\t\t     X86_EFLAGS_IF | X86_EFLAGS_DF | X86_EFLAGS_OF |\n\t\t\t     X86_EFLAGS_IOPL | X86_EFLAGS_NT | X86_EFLAGS_RF |\n\t\t\t     X86_EFLAGS_AC | X86_EFLAGS_ID |\n\t\t\t     X86_EFLAGS_FIXED;\n\tunsigned long vm86_mask = X86_EFLAGS_VM | X86_EFLAGS_VIF |\n\t\t\t\t  X86_EFLAGS_VIP;\n\n\t/* TODO: Add stack limit check */\n\n\trc = emulate_pop(ctxt, &temp_eip, ctxt->op_bytes);\n\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\tif (temp_eip & ~0xffff)\n\t\treturn emulate_gp(ctxt, 0);\n\n\trc = emulate_pop(ctxt, &cs, ctxt->op_bytes);\n\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\trc = emulate_pop(ctxt, &temp_eflags, ctxt->op_bytes);\n\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\trc = load_segment_descriptor(ctxt, (u16)cs, VCPU_SREG_CS);\n\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\tctxt->_eip = temp_eip;\n\n\tif (ctxt->op_bytes == 4)\n\t\tctxt->eflags = ((temp_eflags & mask) | (ctxt->eflags & vm86_mask));\n\telse if (ctxt->op_bytes == 2) {\n\t\tctxt->eflags &= ~0xffff;\n\t\tctxt->eflags |= temp_eflags;\n\t}\n\n\tctxt->eflags &= ~EFLG_RESERVED_ZEROS_MASK; /* Clear reserved zeros */\n\tctxt->eflags |= X86_EFLAGS_FIXED;\n\tctxt->ops->set_nmi_mask(ctxt, false);\n\n\treturn rc;\n}"
  },
  {
    "function_name": "emulate_int",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "2020-2033",
    "snippet": "static int emulate_int(struct x86_emulate_ctxt *ctxt, int irq)\n{\n\tswitch(ctxt->mode) {\n\tcase X86EMUL_MODE_REAL:\n\t\treturn __emulate_int_real(ctxt, irq);\n\tcase X86EMUL_MODE_VM86:\n\tcase X86EMUL_MODE_PROT16:\n\tcase X86EMUL_MODE_PROT32:\n\tcase X86EMUL_MODE_PROT64:\n\tdefault:\n\t\t/* Protected mode interrupts unimplemented yet */\n\t\treturn X86EMUL_UNHANDLEABLE;\n\t}\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__emulate_int_real",
          "args": [
            "ctxt",
            "irq"
          ],
          "line": 2024
        },
        "resolved": true,
        "details": {
          "function_name": "__emulate_int_real",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "1960-2007",
          "snippet": "static int __emulate_int_real(struct x86_emulate_ctxt *ctxt, int irq)\n{\n\tconst struct x86_emulate_ops *ops = ctxt->ops;\n\tint rc;\n\tstruct desc_ptr dt;\n\tgva_t cs_addr;\n\tgva_t eip_addr;\n\tu16 cs, eip;\n\n\t/* TODO: Add limit checks */\n\tctxt->src.val = ctxt->eflags;\n\trc = em_push(ctxt);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\tctxt->eflags &= ~(X86_EFLAGS_IF | X86_EFLAGS_TF | X86_EFLAGS_AC);\n\n\tctxt->src.val = get_segment_selector(ctxt, VCPU_SREG_CS);\n\trc = em_push(ctxt);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\tctxt->src.val = ctxt->_eip;\n\trc = em_push(ctxt);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\tops->get_idt(ctxt, &dt);\n\n\teip_addr = dt.address + (irq << 2);\n\tcs_addr = dt.address + (irq << 2) + 2;\n\n\trc = ops->read_std(ctxt, cs_addr, &cs, 2, &ctxt->exception);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\trc = ops->read_std(ctxt, eip_addr, &eip, 2, &ctxt->exception);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\trc = load_segment_descriptor(ctxt, cs, VCPU_SREG_CS);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\tctxt->_eip = eip;\n\n\treturn rc;\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int __emulate_int_real(struct x86_emulate_ctxt *ctxt, int irq)\n{\n\tconst struct x86_emulate_ops *ops = ctxt->ops;\n\tint rc;\n\tstruct desc_ptr dt;\n\tgva_t cs_addr;\n\tgva_t eip_addr;\n\tu16 cs, eip;\n\n\t/* TODO: Add limit checks */\n\tctxt->src.val = ctxt->eflags;\n\trc = em_push(ctxt);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\tctxt->eflags &= ~(X86_EFLAGS_IF | X86_EFLAGS_TF | X86_EFLAGS_AC);\n\n\tctxt->src.val = get_segment_selector(ctxt, VCPU_SREG_CS);\n\trc = em_push(ctxt);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\tctxt->src.val = ctxt->_eip;\n\trc = em_push(ctxt);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\tops->get_idt(ctxt, &dt);\n\n\teip_addr = dt.address + (irq << 2);\n\tcs_addr = dt.address + (irq << 2) + 2;\n\n\trc = ops->read_std(ctxt, cs_addr, &cs, 2, &ctxt->exception);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\trc = ops->read_std(ctxt, eip_addr, &eip, 2, &ctxt->exception);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\trc = load_segment_descriptor(ctxt, cs, VCPU_SREG_CS);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\tctxt->_eip = eip;\n\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int emulate_int(struct x86_emulate_ctxt *ctxt, int irq)\n{\n\tswitch(ctxt->mode) {\n\tcase X86EMUL_MODE_REAL:\n\t\treturn __emulate_int_real(ctxt, irq);\n\tcase X86EMUL_MODE_VM86:\n\tcase X86EMUL_MODE_PROT16:\n\tcase X86EMUL_MODE_PROT32:\n\tcase X86EMUL_MODE_PROT64:\n\tdefault:\n\t\t/* Protected mode interrupts unimplemented yet */\n\t\treturn X86EMUL_UNHANDLEABLE;\n\t}\n}"
  },
  {
    "function_name": "emulate_int_real",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "2009-2018",
    "snippet": "int emulate_int_real(struct x86_emulate_ctxt *ctxt, int irq)\n{\n\tint rc;\n\n\tinvalidate_registers(ctxt);\n\trc = __emulate_int_real(ctxt, irq);\n\tif (rc == X86EMUL_CONTINUE)\n\t\twriteback_registers(ctxt);\n\treturn rc;\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "writeback_registers",
          "args": [
            "ctxt"
          ],
          "line": 2016
        },
        "resolved": true,
        "details": {
          "function_name": "writeback_registers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "283-289",
          "snippet": "static void writeback_registers(struct x86_emulate_ctxt *ctxt)\n{\n\tunsigned reg;\n\n\tfor_each_set_bit(reg, (ulong *)&ctxt->regs_dirty, 16)\n\t\tctxt->ops->write_gpr(ctxt, reg, ctxt->_regs[reg]);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic void writeback_registers(struct x86_emulate_ctxt *ctxt)\n{\n\tunsigned reg;\n\n\tfor_each_set_bit(reg, (ulong *)&ctxt->regs_dirty, 16)\n\t\tctxt->ops->write_gpr(ctxt, reg, ctxt->_regs[reg]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__emulate_int_real",
          "args": [
            "ctxt",
            "irq"
          ],
          "line": 2014
        },
        "resolved": true,
        "details": {
          "function_name": "__emulate_int_real",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "1960-2007",
          "snippet": "static int __emulate_int_real(struct x86_emulate_ctxt *ctxt, int irq)\n{\n\tconst struct x86_emulate_ops *ops = ctxt->ops;\n\tint rc;\n\tstruct desc_ptr dt;\n\tgva_t cs_addr;\n\tgva_t eip_addr;\n\tu16 cs, eip;\n\n\t/* TODO: Add limit checks */\n\tctxt->src.val = ctxt->eflags;\n\trc = em_push(ctxt);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\tctxt->eflags &= ~(X86_EFLAGS_IF | X86_EFLAGS_TF | X86_EFLAGS_AC);\n\n\tctxt->src.val = get_segment_selector(ctxt, VCPU_SREG_CS);\n\trc = em_push(ctxt);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\tctxt->src.val = ctxt->_eip;\n\trc = em_push(ctxt);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\tops->get_idt(ctxt, &dt);\n\n\teip_addr = dt.address + (irq << 2);\n\tcs_addr = dt.address + (irq << 2) + 2;\n\n\trc = ops->read_std(ctxt, cs_addr, &cs, 2, &ctxt->exception);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\trc = ops->read_std(ctxt, eip_addr, &eip, 2, &ctxt->exception);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\trc = load_segment_descriptor(ctxt, cs, VCPU_SREG_CS);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\tctxt->_eip = eip;\n\n\treturn rc;\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int __emulate_int_real(struct x86_emulate_ctxt *ctxt, int irq)\n{\n\tconst struct x86_emulate_ops *ops = ctxt->ops;\n\tint rc;\n\tstruct desc_ptr dt;\n\tgva_t cs_addr;\n\tgva_t eip_addr;\n\tu16 cs, eip;\n\n\t/* TODO: Add limit checks */\n\tctxt->src.val = ctxt->eflags;\n\trc = em_push(ctxt);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\tctxt->eflags &= ~(X86_EFLAGS_IF | X86_EFLAGS_TF | X86_EFLAGS_AC);\n\n\tctxt->src.val = get_segment_selector(ctxt, VCPU_SREG_CS);\n\trc = em_push(ctxt);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\tctxt->src.val = ctxt->_eip;\n\trc = em_push(ctxt);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\tops->get_idt(ctxt, &dt);\n\n\teip_addr = dt.address + (irq << 2);\n\tcs_addr = dt.address + (irq << 2) + 2;\n\n\trc = ops->read_std(ctxt, cs_addr, &cs, 2, &ctxt->exception);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\trc = ops->read_std(ctxt, eip_addr, &eip, 2, &ctxt->exception);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\trc = load_segment_descriptor(ctxt, cs, VCPU_SREG_CS);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\tctxt->_eip = eip;\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "invalidate_registers",
          "args": [
            "ctxt"
          ],
          "line": 2013
        },
        "resolved": true,
        "details": {
          "function_name": "invalidate_registers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "291-295",
          "snippet": "static void invalidate_registers(struct x86_emulate_ctxt *ctxt)\n{\n\tctxt->regs_dirty = 0;\n\tctxt->regs_valid = 0;\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic void invalidate_registers(struct x86_emulate_ctxt *ctxt)\n{\n\tctxt->regs_dirty = 0;\n\tctxt->regs_valid = 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nint emulate_int_real(struct x86_emulate_ctxt *ctxt, int irq)\n{\n\tint rc;\n\n\tinvalidate_registers(ctxt);\n\trc = __emulate_int_real(ctxt, irq);\n\tif (rc == X86EMUL_CONTINUE)\n\t\twriteback_registers(ctxt);\n\treturn rc;\n}"
  },
  {
    "function_name": "__emulate_int_real",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "1960-2007",
    "snippet": "static int __emulate_int_real(struct x86_emulate_ctxt *ctxt, int irq)\n{\n\tconst struct x86_emulate_ops *ops = ctxt->ops;\n\tint rc;\n\tstruct desc_ptr dt;\n\tgva_t cs_addr;\n\tgva_t eip_addr;\n\tu16 cs, eip;\n\n\t/* TODO: Add limit checks */\n\tctxt->src.val = ctxt->eflags;\n\trc = em_push(ctxt);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\tctxt->eflags &= ~(X86_EFLAGS_IF | X86_EFLAGS_TF | X86_EFLAGS_AC);\n\n\tctxt->src.val = get_segment_selector(ctxt, VCPU_SREG_CS);\n\trc = em_push(ctxt);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\tctxt->src.val = ctxt->_eip;\n\trc = em_push(ctxt);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\tops->get_idt(ctxt, &dt);\n\n\teip_addr = dt.address + (irq << 2);\n\tcs_addr = dt.address + (irq << 2) + 2;\n\n\trc = ops->read_std(ctxt, cs_addr, &cs, 2, &ctxt->exception);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\trc = ops->read_std(ctxt, eip_addr, &eip, 2, &ctxt->exception);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\trc = load_segment_descriptor(ctxt, cs, VCPU_SREG_CS);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\tctxt->_eip = eip;\n\n\treturn rc;\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "load_segment_descriptor",
          "args": [
            "ctxt",
            "cs",
            "VCPU_SREG_CS"
          ],
          "line": 2000
        },
        "resolved": true,
        "details": {
          "function_name": "load_segment_descriptor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "1710-1716",
          "snippet": "static int load_segment_descriptor(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t   u16 selector, int seg)\n{\n\tu8 cpl = ctxt->ops->cpl(ctxt);\n\treturn __load_segment_descriptor(ctxt, selector, seg, cpl,\n\t\t\t\t\t X86_TRANSFER_NONE, NULL);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int load_segment_descriptor(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t   u16 selector, int seg)\n{\n\tu8 cpl = ctxt->ops->cpl(ctxt);\n\treturn __load_segment_descriptor(ctxt, selector, seg, cpl,\n\t\t\t\t\t X86_TRANSFER_NONE, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ops->read_std",
          "args": [
            "ctxt",
            "eip_addr",
            "&eip",
            "2",
            "&ctxt->exception"
          ],
          "line": 1996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ops->read_std",
          "args": [
            "ctxt",
            "cs_addr",
            "&cs",
            "2",
            "&ctxt->exception"
          ],
          "line": 1992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ops->get_idt",
          "args": [
            "ctxt",
            "&dt"
          ],
          "line": 1987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "em_push",
          "args": [
            "ctxt"
          ],
          "line": 1983
        },
        "resolved": true,
        "details": {
          "function_name": "em_pushf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "1933-1937",
          "snippet": "static int em_pushf(struct x86_emulate_ctxt *ctxt)\n{\n\tctxt->src.val = (unsigned long)ctxt->eflags & ~X86_EFLAGS_VM;\n\treturn em_push(ctxt);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int em_pushf(struct x86_emulate_ctxt *ctxt)\n{\n\tctxt->src.val = (unsigned long)ctxt->eflags & ~X86_EFLAGS_VM;\n\treturn em_push(ctxt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_segment_selector",
          "args": [
            "ctxt",
            "VCPU_SREG_CS"
          ],
          "line": 1977
        },
        "resolved": true,
        "details": {
          "function_name": "get_segment_selector",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "610-617",
          "snippet": "static u16 get_segment_selector(struct x86_emulate_ctxt *ctxt, unsigned seg)\n{\n\tu16 selector;\n\tstruct desc_struct desc;\n\n\tctxt->ops->get_segment(ctxt, &selector, &desc, NULL, seg);\n\treturn selector;\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic u16 get_segment_selector(struct x86_emulate_ctxt *ctxt, unsigned seg)\n{\n\tu16 selector;\n\tstruct desc_struct desc;\n\n\tctxt->ops->get_segment(ctxt, &selector, &desc, NULL, seg);\n\treturn selector;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int __emulate_int_real(struct x86_emulate_ctxt *ctxt, int irq)\n{\n\tconst struct x86_emulate_ops *ops = ctxt->ops;\n\tint rc;\n\tstruct desc_ptr dt;\n\tgva_t cs_addr;\n\tgva_t eip_addr;\n\tu16 cs, eip;\n\n\t/* TODO: Add limit checks */\n\tctxt->src.val = ctxt->eflags;\n\trc = em_push(ctxt);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\tctxt->eflags &= ~(X86_EFLAGS_IF | X86_EFLAGS_TF | X86_EFLAGS_AC);\n\n\tctxt->src.val = get_segment_selector(ctxt, VCPU_SREG_CS);\n\trc = em_push(ctxt);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\tctxt->src.val = ctxt->_eip;\n\trc = em_push(ctxt);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\tops->get_idt(ctxt, &dt);\n\n\teip_addr = dt.address + (irq << 2);\n\tcs_addr = dt.address + (irq << 2) + 2;\n\n\trc = ops->read_std(ctxt, cs_addr, &cs, 2, &ctxt->exception);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\trc = ops->read_std(ctxt, eip_addr, &eip, 2, &ctxt->exception);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\trc = load_segment_descriptor(ctxt, cs, VCPU_SREG_CS);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\tctxt->_eip = eip;\n\n\treturn rc;\n}"
  },
  {
    "function_name": "em_popa",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "1939-1958",
    "snippet": "static int em_popa(struct x86_emulate_ctxt *ctxt)\n{\n\tint rc = X86EMUL_CONTINUE;\n\tint reg = VCPU_REGS_RDI;\n\tu32 val;\n\n\twhile (reg >= VCPU_REGS_RAX) {\n\t\tif (reg == VCPU_REGS_RSP) {\n\t\t\trsp_increment(ctxt, ctxt->op_bytes);\n\t\t\t--reg;\n\t\t}\n\n\t\trc = emulate_pop(ctxt, &val, ctxt->op_bytes);\n\t\tif (rc != X86EMUL_CONTINUE)\n\t\t\tbreak;\n\t\tassign_register(reg_rmw(ctxt, reg), val, ctxt->op_bytes);\n\t\t--reg;\n\t}\n\treturn rc;\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "assign_register",
          "args": [
            "reg_rmw(ctxt, reg)",
            "val",
            "ctxt->op_bytes"
          ],
          "line": 1954
        },
        "resolved": true,
        "details": {
          "function_name": "assign_register",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "476-493",
          "snippet": "static void assign_register(unsigned long *reg, u64 val, int bytes)\n{\n\t/* The 4-byte case *is* correct: in 64-bit mode we zero-extend. */\n\tswitch (bytes) {\n\tcase 1:\n\t\t*(u8 *)reg = (u8)val;\n\t\tbreak;\n\tcase 2:\n\t\t*(u16 *)reg = (u16)val;\n\t\tbreak;\n\tcase 4:\n\t\t*reg = (u32)val;\n\t\tbreak;\t/* 64b: zero-extend */\n\tcase 8:\n\t\t*reg = val;\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic void assign_register(unsigned long *reg, u64 val, int bytes)\n{\n\t/* The 4-byte case *is* correct: in 64-bit mode we zero-extend. */\n\tswitch (bytes) {\n\tcase 1:\n\t\t*(u8 *)reg = (u8)val;\n\t\tbreak;\n\tcase 2:\n\t\t*(u16 *)reg = (u16)val;\n\t\tbreak;\n\tcase 4:\n\t\t*reg = (u32)val;\n\t\tbreak;\t/* 64b: zero-extend */\n\tcase 8:\n\t\t*reg = val;\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "reg_rmw",
          "args": [
            "ctxt",
            "reg"
          ],
          "line": 1954
        },
        "resolved": true,
        "details": {
          "function_name": "reg_rmw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "277-281",
          "snippet": "static ulong *reg_rmw(struct x86_emulate_ctxt *ctxt, unsigned nr)\n{\n\treg_read(ctxt, nr);\n\treturn reg_write(ctxt, nr);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic ulong *reg_rmw(struct x86_emulate_ctxt *ctxt, unsigned nr)\n{\n\treg_read(ctxt, nr);\n\treturn reg_write(ctxt, nr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "emulate_pop",
          "args": [
            "ctxt",
            "&val",
            "ctxt->op_bytes"
          ],
          "line": 1951
        },
        "resolved": true,
        "details": {
          "function_name": "emulate_popf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "1802-1842",
          "snippet": "static int emulate_popf(struct x86_emulate_ctxt *ctxt,\n\t\t\tvoid *dest, int len)\n{\n\tint rc;\n\tunsigned long val, change_mask;\n\tint iopl = (ctxt->eflags & X86_EFLAGS_IOPL) >> X86_EFLAGS_IOPL_BIT;\n\tint cpl = ctxt->ops->cpl(ctxt);\n\n\trc = emulate_pop(ctxt, &val, len);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\tchange_mask = X86_EFLAGS_CF | X86_EFLAGS_PF | X86_EFLAGS_AF |\n\t\t      X86_EFLAGS_ZF | X86_EFLAGS_SF | X86_EFLAGS_OF |\n\t\t      X86_EFLAGS_TF | X86_EFLAGS_DF | X86_EFLAGS_NT |\n\t\t      X86_EFLAGS_AC | X86_EFLAGS_ID;\n\n\tswitch(ctxt->mode) {\n\tcase X86EMUL_MODE_PROT64:\n\tcase X86EMUL_MODE_PROT32:\n\tcase X86EMUL_MODE_PROT16:\n\t\tif (cpl == 0)\n\t\t\tchange_mask |= X86_EFLAGS_IOPL;\n\t\tif (cpl <= iopl)\n\t\t\tchange_mask |= X86_EFLAGS_IF;\n\t\tbreak;\n\tcase X86EMUL_MODE_VM86:\n\t\tif (iopl < 3)\n\t\t\treturn emulate_gp(ctxt, 0);\n\t\tchange_mask |= X86_EFLAGS_IF;\n\t\tbreak;\n\tdefault: /* real mode */\n\t\tchange_mask |= (X86_EFLAGS_IOPL | X86_EFLAGS_IF);\n\t\tbreak;\n\t}\n\n\t*(unsigned long *)dest =\n\t\t(ctxt->eflags & ~change_mask) | (val & change_mask);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int emulate_popf(struct x86_emulate_ctxt *ctxt,\n\t\t\tvoid *dest, int len)\n{\n\tint rc;\n\tunsigned long val, change_mask;\n\tint iopl = (ctxt->eflags & X86_EFLAGS_IOPL) >> X86_EFLAGS_IOPL_BIT;\n\tint cpl = ctxt->ops->cpl(ctxt);\n\n\trc = emulate_pop(ctxt, &val, len);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\tchange_mask = X86_EFLAGS_CF | X86_EFLAGS_PF | X86_EFLAGS_AF |\n\t\t      X86_EFLAGS_ZF | X86_EFLAGS_SF | X86_EFLAGS_OF |\n\t\t      X86_EFLAGS_TF | X86_EFLAGS_DF | X86_EFLAGS_NT |\n\t\t      X86_EFLAGS_AC | X86_EFLAGS_ID;\n\n\tswitch(ctxt->mode) {\n\tcase X86EMUL_MODE_PROT64:\n\tcase X86EMUL_MODE_PROT32:\n\tcase X86EMUL_MODE_PROT16:\n\t\tif (cpl == 0)\n\t\t\tchange_mask |= X86_EFLAGS_IOPL;\n\t\tif (cpl <= iopl)\n\t\t\tchange_mask |= X86_EFLAGS_IF;\n\t\tbreak;\n\tcase X86EMUL_MODE_VM86:\n\t\tif (iopl < 3)\n\t\t\treturn emulate_gp(ctxt, 0);\n\t\tchange_mask |= X86_EFLAGS_IF;\n\t\tbreak;\n\tdefault: /* real mode */\n\t\tchange_mask |= (X86_EFLAGS_IOPL | X86_EFLAGS_IF);\n\t\tbreak;\n\t}\n\n\t*(unsigned long *)dest =\n\t\t(ctxt->eflags & ~change_mask) | (val & change_mask);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rsp_increment",
          "args": [
            "ctxt",
            "ctxt->op_bytes"
          ],
          "line": 1947
        },
        "resolved": true,
        "details": {
          "function_name": "rsp_increment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "545-548",
          "snippet": "static void rsp_increment(struct x86_emulate_ctxt *ctxt, int inc)\n{\n\tmasked_increment(reg_rmw(ctxt, VCPU_REGS_RSP), stack_mask(ctxt), inc);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic void rsp_increment(struct x86_emulate_ctxt *ctxt, int inc)\n{\n\tmasked_increment(reg_rmw(ctxt, VCPU_REGS_RSP), stack_mask(ctxt), inc);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int em_popa(struct x86_emulate_ctxt *ctxt)\n{\n\tint rc = X86EMUL_CONTINUE;\n\tint reg = VCPU_REGS_RDI;\n\tu32 val;\n\n\twhile (reg >= VCPU_REGS_RAX) {\n\t\tif (reg == VCPU_REGS_RSP) {\n\t\t\trsp_increment(ctxt, ctxt->op_bytes);\n\t\t\t--reg;\n\t\t}\n\n\t\trc = emulate_pop(ctxt, &val, ctxt->op_bytes);\n\t\tif (rc != X86EMUL_CONTINUE)\n\t\t\tbreak;\n\t\tassign_register(reg_rmw(ctxt, reg), val, ctxt->op_bytes);\n\t\t--reg;\n\t}\n\treturn rc;\n}"
  },
  {
    "function_name": "em_pushf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "1933-1937",
    "snippet": "static int em_pushf(struct x86_emulate_ctxt *ctxt)\n{\n\tctxt->src.val = (unsigned long)ctxt->eflags & ~X86_EFLAGS_VM;\n\treturn em_push(ctxt);\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "em_push",
          "args": [
            "ctxt"
          ],
          "line": 1936
        },
        "resolved": true,
        "details": {
          "function_name": "em_pushf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "1933-1937",
          "snippet": "static int em_pushf(struct x86_emulate_ctxt *ctxt)\n{\n\tctxt->src.val = (unsigned long)ctxt->eflags & ~X86_EFLAGS_VM;\n\treturn em_push(ctxt);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int em_pushf(struct x86_emulate_ctxt *ctxt)\n{\n\tctxt->src.val = (unsigned long)ctxt->eflags & ~X86_EFLAGS_VM;\n\treturn em_push(ctxt);\n}"
  },
  {
    "function_name": "em_pusha",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "1913-1931",
    "snippet": "static int em_pusha(struct x86_emulate_ctxt *ctxt)\n{\n\tunsigned long old_esp = reg_read(ctxt, VCPU_REGS_RSP);\n\tint rc = X86EMUL_CONTINUE;\n\tint reg = VCPU_REGS_RAX;\n\n\twhile (reg <= VCPU_REGS_RDI) {\n\t\t(reg == VCPU_REGS_RSP) ?\n\t\t(ctxt->src.val = old_esp) : (ctxt->src.val = reg_read(ctxt, reg));\n\n\t\trc = em_push(ctxt);\n\t\tif (rc != X86EMUL_CONTINUE)\n\t\t\treturn rc;\n\n\t\t++reg;\n\t}\n\n\treturn rc;\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "em_push",
          "args": [
            "ctxt"
          ],
          "line": 1923
        },
        "resolved": true,
        "details": {
          "function_name": "em_pushf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "1933-1937",
          "snippet": "static int em_pushf(struct x86_emulate_ctxt *ctxt)\n{\n\tctxt->src.val = (unsigned long)ctxt->eflags & ~X86_EFLAGS_VM;\n\treturn em_push(ctxt);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int em_pushf(struct x86_emulate_ctxt *ctxt)\n{\n\tctxt->src.val = (unsigned long)ctxt->eflags & ~X86_EFLAGS_VM;\n\treturn em_push(ctxt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reg_read",
          "args": [
            "ctxt",
            "reg"
          ],
          "line": 1921
        },
        "resolved": true,
        "details": {
          "function_name": "reg_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "261-268",
          "snippet": "static ulong reg_read(struct x86_emulate_ctxt *ctxt, unsigned nr)\n{\n\tif (!(ctxt->regs_valid & (1 << nr))) {\n\t\tctxt->regs_valid |= 1 << nr;\n\t\tctxt->_regs[nr] = ctxt->ops->read_gpr(ctxt, nr);\n\t}\n\treturn ctxt->_regs[nr];\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic ulong reg_read(struct x86_emulate_ctxt *ctxt, unsigned nr)\n{\n\tif (!(ctxt->regs_valid & (1 << nr))) {\n\t\tctxt->regs_valid |= 1 << nr;\n\t\tctxt->_regs[nr] = ctxt->ops->read_gpr(ctxt, nr);\n\t}\n\treturn ctxt->_regs[nr];\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int em_pusha(struct x86_emulate_ctxt *ctxt)\n{\n\tunsigned long old_esp = reg_read(ctxt, VCPU_REGS_RSP);\n\tint rc = X86EMUL_CONTINUE;\n\tint reg = VCPU_REGS_RAX;\n\n\twhile (reg <= VCPU_REGS_RDI) {\n\t\t(reg == VCPU_REGS_RSP) ?\n\t\t(ctxt->src.val = old_esp) : (ctxt->src.val = reg_read(ctxt, reg));\n\n\t\trc = em_push(ctxt);\n\t\tif (rc != X86EMUL_CONTINUE)\n\t\t\treturn rc;\n\n\t\t++reg;\n\t}\n\n\treturn rc;\n}"
  },
  {
    "function_name": "em_pop_sreg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "1894-1911",
    "snippet": "static int em_pop_sreg(struct x86_emulate_ctxt *ctxt)\n{\n\tint seg = ctxt->src2.val;\n\tunsigned long selector;\n\tint rc;\n\n\trc = emulate_pop(ctxt, &selector, 2);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\tif (ctxt->modrm_reg == VCPU_SREG_SS)\n\t\tctxt->interruptibility = KVM_X86_SHADOW_INT_MOV_SS;\n\tif (ctxt->op_bytes > 2)\n\t\trsp_increment(ctxt, ctxt->op_bytes - 2);\n\n\trc = load_segment_descriptor(ctxt, (u16)selector, seg);\n\treturn rc;\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "load_segment_descriptor",
          "args": [
            "ctxt",
            "(u16)selector",
            "seg"
          ],
          "line": 1909
        },
        "resolved": true,
        "details": {
          "function_name": "load_segment_descriptor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "1710-1716",
          "snippet": "static int load_segment_descriptor(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t   u16 selector, int seg)\n{\n\tu8 cpl = ctxt->ops->cpl(ctxt);\n\treturn __load_segment_descriptor(ctxt, selector, seg, cpl,\n\t\t\t\t\t X86_TRANSFER_NONE, NULL);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int load_segment_descriptor(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t   u16 selector, int seg)\n{\n\tu8 cpl = ctxt->ops->cpl(ctxt);\n\treturn __load_segment_descriptor(ctxt, selector, seg, cpl,\n\t\t\t\t\t X86_TRANSFER_NONE, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rsp_increment",
          "args": [
            "ctxt",
            "ctxt->op_bytes - 2"
          ],
          "line": 1907
        },
        "resolved": true,
        "details": {
          "function_name": "rsp_increment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "545-548",
          "snippet": "static void rsp_increment(struct x86_emulate_ctxt *ctxt, int inc)\n{\n\tmasked_increment(reg_rmw(ctxt, VCPU_REGS_RSP), stack_mask(ctxt), inc);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic void rsp_increment(struct x86_emulate_ctxt *ctxt, int inc)\n{\n\tmasked_increment(reg_rmw(ctxt, VCPU_REGS_RSP), stack_mask(ctxt), inc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "emulate_pop",
          "args": [
            "ctxt",
            "&selector",
            "2"
          ],
          "line": 1900
        },
        "resolved": true,
        "details": {
          "function_name": "emulate_popf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "1802-1842",
          "snippet": "static int emulate_popf(struct x86_emulate_ctxt *ctxt,\n\t\t\tvoid *dest, int len)\n{\n\tint rc;\n\tunsigned long val, change_mask;\n\tint iopl = (ctxt->eflags & X86_EFLAGS_IOPL) >> X86_EFLAGS_IOPL_BIT;\n\tint cpl = ctxt->ops->cpl(ctxt);\n\n\trc = emulate_pop(ctxt, &val, len);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\tchange_mask = X86_EFLAGS_CF | X86_EFLAGS_PF | X86_EFLAGS_AF |\n\t\t      X86_EFLAGS_ZF | X86_EFLAGS_SF | X86_EFLAGS_OF |\n\t\t      X86_EFLAGS_TF | X86_EFLAGS_DF | X86_EFLAGS_NT |\n\t\t      X86_EFLAGS_AC | X86_EFLAGS_ID;\n\n\tswitch(ctxt->mode) {\n\tcase X86EMUL_MODE_PROT64:\n\tcase X86EMUL_MODE_PROT32:\n\tcase X86EMUL_MODE_PROT16:\n\t\tif (cpl == 0)\n\t\t\tchange_mask |= X86_EFLAGS_IOPL;\n\t\tif (cpl <= iopl)\n\t\t\tchange_mask |= X86_EFLAGS_IF;\n\t\tbreak;\n\tcase X86EMUL_MODE_VM86:\n\t\tif (iopl < 3)\n\t\t\treturn emulate_gp(ctxt, 0);\n\t\tchange_mask |= X86_EFLAGS_IF;\n\t\tbreak;\n\tdefault: /* real mode */\n\t\tchange_mask |= (X86_EFLAGS_IOPL | X86_EFLAGS_IF);\n\t\tbreak;\n\t}\n\n\t*(unsigned long *)dest =\n\t\t(ctxt->eflags & ~change_mask) | (val & change_mask);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int emulate_popf(struct x86_emulate_ctxt *ctxt,\n\t\t\tvoid *dest, int len)\n{\n\tint rc;\n\tunsigned long val, change_mask;\n\tint iopl = (ctxt->eflags & X86_EFLAGS_IOPL) >> X86_EFLAGS_IOPL_BIT;\n\tint cpl = ctxt->ops->cpl(ctxt);\n\n\trc = emulate_pop(ctxt, &val, len);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\tchange_mask = X86_EFLAGS_CF | X86_EFLAGS_PF | X86_EFLAGS_AF |\n\t\t      X86_EFLAGS_ZF | X86_EFLAGS_SF | X86_EFLAGS_OF |\n\t\t      X86_EFLAGS_TF | X86_EFLAGS_DF | X86_EFLAGS_NT |\n\t\t      X86_EFLAGS_AC | X86_EFLAGS_ID;\n\n\tswitch(ctxt->mode) {\n\tcase X86EMUL_MODE_PROT64:\n\tcase X86EMUL_MODE_PROT32:\n\tcase X86EMUL_MODE_PROT16:\n\t\tif (cpl == 0)\n\t\t\tchange_mask |= X86_EFLAGS_IOPL;\n\t\tif (cpl <= iopl)\n\t\t\tchange_mask |= X86_EFLAGS_IF;\n\t\tbreak;\n\tcase X86EMUL_MODE_VM86:\n\t\tif (iopl < 3)\n\t\t\treturn emulate_gp(ctxt, 0);\n\t\tchange_mask |= X86_EFLAGS_IF;\n\t\tbreak;\n\tdefault: /* real mode */\n\t\tchange_mask |= (X86_EFLAGS_IOPL | X86_EFLAGS_IF);\n\t\tbreak;\n\t}\n\n\t*(unsigned long *)dest =\n\t\t(ctxt->eflags & ~change_mask) | (val & change_mask);\n\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int em_pop_sreg(struct x86_emulate_ctxt *ctxt)\n{\n\tint seg = ctxt->src2.val;\n\tunsigned long selector;\n\tint rc;\n\n\trc = emulate_pop(ctxt, &selector, 2);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\tif (ctxt->modrm_reg == VCPU_SREG_SS)\n\t\tctxt->interruptibility = KVM_X86_SHADOW_INT_MOV_SS;\n\tif (ctxt->op_bytes > 2)\n\t\trsp_increment(ctxt, ctxt->op_bytes - 2);\n\n\trc = load_segment_descriptor(ctxt, (u16)selector, seg);\n\treturn rc;\n}"
  },
  {
    "function_name": "em_push_sreg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "1881-1892",
    "snippet": "static int em_push_sreg(struct x86_emulate_ctxt *ctxt)\n{\n\tint seg = ctxt->src2.val;\n\n\tctxt->src.val = get_segment_selector(ctxt, seg);\n\tif (ctxt->op_bytes == 4) {\n\t\trsp_increment(ctxt, -2);\n\t\tctxt->op_bytes = 2;\n\t}\n\n\treturn em_push(ctxt);\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "em_push",
          "args": [
            "ctxt"
          ],
          "line": 1891
        },
        "resolved": true,
        "details": {
          "function_name": "em_pushf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "1933-1937",
          "snippet": "static int em_pushf(struct x86_emulate_ctxt *ctxt)\n{\n\tctxt->src.val = (unsigned long)ctxt->eflags & ~X86_EFLAGS_VM;\n\treturn em_push(ctxt);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int em_pushf(struct x86_emulate_ctxt *ctxt)\n{\n\tctxt->src.val = (unsigned long)ctxt->eflags & ~X86_EFLAGS_VM;\n\treturn em_push(ctxt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rsp_increment",
          "args": [
            "ctxt",
            "-2"
          ],
          "line": 1887
        },
        "resolved": true,
        "details": {
          "function_name": "rsp_increment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "545-548",
          "snippet": "static void rsp_increment(struct x86_emulate_ctxt *ctxt, int inc)\n{\n\tmasked_increment(reg_rmw(ctxt, VCPU_REGS_RSP), stack_mask(ctxt), inc);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic void rsp_increment(struct x86_emulate_ctxt *ctxt, int inc)\n{\n\tmasked_increment(reg_rmw(ctxt, VCPU_REGS_RSP), stack_mask(ctxt), inc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_segment_selector",
          "args": [
            "ctxt",
            "seg"
          ],
          "line": 1885
        },
        "resolved": true,
        "details": {
          "function_name": "get_segment_selector",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "610-617",
          "snippet": "static u16 get_segment_selector(struct x86_emulate_ctxt *ctxt, unsigned seg)\n{\n\tu16 selector;\n\tstruct desc_struct desc;\n\n\tctxt->ops->get_segment(ctxt, &selector, &desc, NULL, seg);\n\treturn selector;\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic u16 get_segment_selector(struct x86_emulate_ctxt *ctxt, unsigned seg)\n{\n\tu16 selector;\n\tstruct desc_struct desc;\n\n\tctxt->ops->get_segment(ctxt, &selector, &desc, NULL, seg);\n\treturn selector;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int em_push_sreg(struct x86_emulate_ctxt *ctxt)\n{\n\tint seg = ctxt->src2.val;\n\n\tctxt->src.val = get_segment_selector(ctxt, seg);\n\tif (ctxt->op_bytes == 4) {\n\t\trsp_increment(ctxt, -2);\n\t\tctxt->op_bytes = 2;\n\t}\n\n\treturn em_push(ctxt);\n}"
  },
  {
    "function_name": "em_leave",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "1874-1879",
    "snippet": "static int em_leave(struct x86_emulate_ctxt *ctxt)\n{\n\tassign_masked(reg_rmw(ctxt, VCPU_REGS_RSP), reg_read(ctxt, VCPU_REGS_RBP),\n\t\t      stack_mask(ctxt));\n\treturn emulate_pop(ctxt, reg_rmw(ctxt, VCPU_REGS_RBP), ctxt->op_bytes);\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "emulate_pop",
          "args": [
            "ctxt",
            "reg_rmw(ctxt, VCPU_REGS_RBP)",
            "ctxt->op_bytes"
          ],
          "line": 1878
        },
        "resolved": true,
        "details": {
          "function_name": "emulate_popf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "1802-1842",
          "snippet": "static int emulate_popf(struct x86_emulate_ctxt *ctxt,\n\t\t\tvoid *dest, int len)\n{\n\tint rc;\n\tunsigned long val, change_mask;\n\tint iopl = (ctxt->eflags & X86_EFLAGS_IOPL) >> X86_EFLAGS_IOPL_BIT;\n\tint cpl = ctxt->ops->cpl(ctxt);\n\n\trc = emulate_pop(ctxt, &val, len);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\tchange_mask = X86_EFLAGS_CF | X86_EFLAGS_PF | X86_EFLAGS_AF |\n\t\t      X86_EFLAGS_ZF | X86_EFLAGS_SF | X86_EFLAGS_OF |\n\t\t      X86_EFLAGS_TF | X86_EFLAGS_DF | X86_EFLAGS_NT |\n\t\t      X86_EFLAGS_AC | X86_EFLAGS_ID;\n\n\tswitch(ctxt->mode) {\n\tcase X86EMUL_MODE_PROT64:\n\tcase X86EMUL_MODE_PROT32:\n\tcase X86EMUL_MODE_PROT16:\n\t\tif (cpl == 0)\n\t\t\tchange_mask |= X86_EFLAGS_IOPL;\n\t\tif (cpl <= iopl)\n\t\t\tchange_mask |= X86_EFLAGS_IF;\n\t\tbreak;\n\tcase X86EMUL_MODE_VM86:\n\t\tif (iopl < 3)\n\t\t\treturn emulate_gp(ctxt, 0);\n\t\tchange_mask |= X86_EFLAGS_IF;\n\t\tbreak;\n\tdefault: /* real mode */\n\t\tchange_mask |= (X86_EFLAGS_IOPL | X86_EFLAGS_IF);\n\t\tbreak;\n\t}\n\n\t*(unsigned long *)dest =\n\t\t(ctxt->eflags & ~change_mask) | (val & change_mask);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int emulate_popf(struct x86_emulate_ctxt *ctxt,\n\t\t\tvoid *dest, int len)\n{\n\tint rc;\n\tunsigned long val, change_mask;\n\tint iopl = (ctxt->eflags & X86_EFLAGS_IOPL) >> X86_EFLAGS_IOPL_BIT;\n\tint cpl = ctxt->ops->cpl(ctxt);\n\n\trc = emulate_pop(ctxt, &val, len);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\tchange_mask = X86_EFLAGS_CF | X86_EFLAGS_PF | X86_EFLAGS_AF |\n\t\t      X86_EFLAGS_ZF | X86_EFLAGS_SF | X86_EFLAGS_OF |\n\t\t      X86_EFLAGS_TF | X86_EFLAGS_DF | X86_EFLAGS_NT |\n\t\t      X86_EFLAGS_AC | X86_EFLAGS_ID;\n\n\tswitch(ctxt->mode) {\n\tcase X86EMUL_MODE_PROT64:\n\tcase X86EMUL_MODE_PROT32:\n\tcase X86EMUL_MODE_PROT16:\n\t\tif (cpl == 0)\n\t\t\tchange_mask |= X86_EFLAGS_IOPL;\n\t\tif (cpl <= iopl)\n\t\t\tchange_mask |= X86_EFLAGS_IF;\n\t\tbreak;\n\tcase X86EMUL_MODE_VM86:\n\t\tif (iopl < 3)\n\t\t\treturn emulate_gp(ctxt, 0);\n\t\tchange_mask |= X86_EFLAGS_IF;\n\t\tbreak;\n\tdefault: /* real mode */\n\t\tchange_mask |= (X86_EFLAGS_IOPL | X86_EFLAGS_IF);\n\t\tbreak;\n\t}\n\n\t*(unsigned long *)dest =\n\t\t(ctxt->eflags & ~change_mask) | (val & change_mask);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reg_rmw",
          "args": [
            "ctxt",
            "VCPU_REGS_RBP"
          ],
          "line": 1878
        },
        "resolved": true,
        "details": {
          "function_name": "reg_rmw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "277-281",
          "snippet": "static ulong *reg_rmw(struct x86_emulate_ctxt *ctxt, unsigned nr)\n{\n\treg_read(ctxt, nr);\n\treturn reg_write(ctxt, nr);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic ulong *reg_rmw(struct x86_emulate_ctxt *ctxt, unsigned nr)\n{\n\treg_read(ctxt, nr);\n\treturn reg_write(ctxt, nr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assign_masked",
          "args": [
            "reg_rmw(ctxt, VCPU_REGS_RSP)",
            "reg_read(ctxt, VCPU_REGS_RBP)",
            "stack_mask(ctxt)"
          ],
          "line": 1876
        },
        "resolved": true,
        "details": {
          "function_name": "assign_masked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "471-474",
          "snippet": "static void assign_masked(ulong *dest, ulong src, ulong mask)\n{\n\t*dest = (*dest & ~mask) | (src & mask);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic void assign_masked(ulong *dest, ulong src, ulong mask)\n{\n\t*dest = (*dest & ~mask) | (src & mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "stack_mask",
          "args": [
            "ctxt"
          ],
          "line": 1877
        },
        "resolved": true,
        "details": {
          "function_name": "stack_mask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "500-509",
          "snippet": "static ulong stack_mask(struct x86_emulate_ctxt *ctxt)\n{\n\tu16 sel;\n\tstruct desc_struct ss;\n\n\tif (ctxt->mode == X86EMUL_MODE_PROT64)\n\t\treturn ~0UL;\n\tctxt->ops->get_segment(ctxt, &sel, &ss, NULL, VCPU_SREG_SS);\n\treturn ~0U >> ((ss.d ^ 1) * 16);  /* d=0: 0xffff; d=1: 0xffffffff */\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic ulong stack_mask(struct x86_emulate_ctxt *ctxt)\n{\n\tu16 sel;\n\tstruct desc_struct ss;\n\n\tif (ctxt->mode == X86EMUL_MODE_PROT64)\n\t\treturn ~0UL;\n\tctxt->ops->get_segment(ctxt, &sel, &ss, NULL, VCPU_SREG_SS);\n\treturn ~0U >> ((ss.d ^ 1) * 16);  /* d=0: 0xffff; d=1: 0xffffffff */\n}"
        }
      },
      {
        "call_info": {
          "callee": "reg_read",
          "args": [
            "ctxt",
            "VCPU_REGS_RBP"
          ],
          "line": 1876
        },
        "resolved": true,
        "details": {
          "function_name": "reg_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "261-268",
          "snippet": "static ulong reg_read(struct x86_emulate_ctxt *ctxt, unsigned nr)\n{\n\tif (!(ctxt->regs_valid & (1 << nr))) {\n\t\tctxt->regs_valid |= 1 << nr;\n\t\tctxt->_regs[nr] = ctxt->ops->read_gpr(ctxt, nr);\n\t}\n\treturn ctxt->_regs[nr];\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic ulong reg_read(struct x86_emulate_ctxt *ctxt, unsigned nr)\n{\n\tif (!(ctxt->regs_valid & (1 << nr))) {\n\t\tctxt->regs_valid |= 1 << nr;\n\t\tctxt->_regs[nr] = ctxt->ops->read_gpr(ctxt, nr);\n\t}\n\treturn ctxt->_regs[nr];\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int em_leave(struct x86_emulate_ctxt *ctxt)\n{\n\tassign_masked(reg_rmw(ctxt, VCPU_REGS_RSP), reg_read(ctxt, VCPU_REGS_RBP),\n\t\t      stack_mask(ctxt));\n\treturn emulate_pop(ctxt, reg_rmw(ctxt, VCPU_REGS_RBP), ctxt->op_bytes);\n}"
  },
  {
    "function_name": "em_enter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "1852-1872",
    "snippet": "static int em_enter(struct x86_emulate_ctxt *ctxt)\n{\n\tint rc;\n\tunsigned frame_size = ctxt->src.val;\n\tunsigned nesting_level = ctxt->src2.val & 31;\n\tulong rbp;\n\n\tif (nesting_level)\n\t\treturn X86EMUL_UNHANDLEABLE;\n\n\trbp = reg_read(ctxt, VCPU_REGS_RBP);\n\trc = push(ctxt, &rbp, stack_size(ctxt));\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\tassign_masked(reg_rmw(ctxt, VCPU_REGS_RBP), reg_read(ctxt, VCPU_REGS_RSP),\n\t\t      stack_mask(ctxt));\n\tassign_masked(reg_rmw(ctxt, VCPU_REGS_RSP),\n\t\t      reg_read(ctxt, VCPU_REGS_RSP) - frame_size,\n\t\t      stack_mask(ctxt));\n\treturn X86EMUL_CONTINUE;\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "assign_masked",
          "args": [
            "reg_rmw(ctxt, VCPU_REGS_RSP)",
            "reg_read(ctxt, VCPU_REGS_RSP) - frame_size",
            "stack_mask(ctxt)"
          ],
          "line": 1868
        },
        "resolved": true,
        "details": {
          "function_name": "assign_masked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "471-474",
          "snippet": "static void assign_masked(ulong *dest, ulong src, ulong mask)\n{\n\t*dest = (*dest & ~mask) | (src & mask);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic void assign_masked(ulong *dest, ulong src, ulong mask)\n{\n\t*dest = (*dest & ~mask) | (src & mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "stack_mask",
          "args": [
            "ctxt"
          ],
          "line": 1870
        },
        "resolved": true,
        "details": {
          "function_name": "stack_mask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "500-509",
          "snippet": "static ulong stack_mask(struct x86_emulate_ctxt *ctxt)\n{\n\tu16 sel;\n\tstruct desc_struct ss;\n\n\tif (ctxt->mode == X86EMUL_MODE_PROT64)\n\t\treturn ~0UL;\n\tctxt->ops->get_segment(ctxt, &sel, &ss, NULL, VCPU_SREG_SS);\n\treturn ~0U >> ((ss.d ^ 1) * 16);  /* d=0: 0xffff; d=1: 0xffffffff */\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic ulong stack_mask(struct x86_emulate_ctxt *ctxt)\n{\n\tu16 sel;\n\tstruct desc_struct ss;\n\n\tif (ctxt->mode == X86EMUL_MODE_PROT64)\n\t\treturn ~0UL;\n\tctxt->ops->get_segment(ctxt, &sel, &ss, NULL, VCPU_SREG_SS);\n\treturn ~0U >> ((ss.d ^ 1) * 16);  /* d=0: 0xffff; d=1: 0xffffffff */\n}"
        }
      },
      {
        "call_info": {
          "callee": "reg_read",
          "args": [
            "ctxt",
            "VCPU_REGS_RSP"
          ],
          "line": 1869
        },
        "resolved": true,
        "details": {
          "function_name": "reg_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "261-268",
          "snippet": "static ulong reg_read(struct x86_emulate_ctxt *ctxt, unsigned nr)\n{\n\tif (!(ctxt->regs_valid & (1 << nr))) {\n\t\tctxt->regs_valid |= 1 << nr;\n\t\tctxt->_regs[nr] = ctxt->ops->read_gpr(ctxt, nr);\n\t}\n\treturn ctxt->_regs[nr];\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic ulong reg_read(struct x86_emulate_ctxt *ctxt, unsigned nr)\n{\n\tif (!(ctxt->regs_valid & (1 << nr))) {\n\t\tctxt->regs_valid |= 1 << nr;\n\t\tctxt->_regs[nr] = ctxt->ops->read_gpr(ctxt, nr);\n\t}\n\treturn ctxt->_regs[nr];\n}"
        }
      },
      {
        "call_info": {
          "callee": "reg_rmw",
          "args": [
            "ctxt",
            "VCPU_REGS_RSP"
          ],
          "line": 1868
        },
        "resolved": true,
        "details": {
          "function_name": "reg_rmw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "277-281",
          "snippet": "static ulong *reg_rmw(struct x86_emulate_ctxt *ctxt, unsigned nr)\n{\n\treg_read(ctxt, nr);\n\treturn reg_write(ctxt, nr);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic ulong *reg_rmw(struct x86_emulate_ctxt *ctxt, unsigned nr)\n{\n\treg_read(ctxt, nr);\n\treturn reg_write(ctxt, nr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "push",
          "args": [
            "ctxt",
            "&rbp",
            "stack_size(ctxt)"
          ],
          "line": 1863
        },
        "resolved": true,
        "details": {
          "function_name": "push",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "1763-1772",
          "snippet": "static int push(struct x86_emulate_ctxt *ctxt, void *data, int bytes)\n{\n\tstruct segmented_address addr;\n\n\trsp_increment(ctxt, -bytes);\n\taddr.ea = reg_read(ctxt, VCPU_REGS_RSP) & stack_mask(ctxt);\n\taddr.seg = VCPU_SREG_SS;\n\n\treturn segmented_write(ctxt, addr, data, bytes);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int push(struct x86_emulate_ctxt *ctxt, void *data, int bytes)\n{\n\tstruct segmented_address addr;\n\n\trsp_increment(ctxt, -bytes);\n\taddr.ea = reg_read(ctxt, VCPU_REGS_RSP) & stack_mask(ctxt);\n\taddr.seg = VCPU_SREG_SS;\n\n\treturn segmented_write(ctxt, addr, data, bytes);\n}"
        }
      },
      {
        "call_info": {
          "callee": "stack_size",
          "args": [
            "ctxt"
          ],
          "line": 1863
        },
        "resolved": true,
        "details": {
          "function_name": "stack_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "511-514",
          "snippet": "static int stack_size(struct x86_emulate_ctxt *ctxt)\n{\n\treturn (__fls(stack_mask(ctxt)) + 1) >> 3;\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int stack_size(struct x86_emulate_ctxt *ctxt)\n{\n\treturn (__fls(stack_mask(ctxt)) + 1) >> 3;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int em_enter(struct x86_emulate_ctxt *ctxt)\n{\n\tint rc;\n\tunsigned frame_size = ctxt->src.val;\n\tunsigned nesting_level = ctxt->src2.val & 31;\n\tulong rbp;\n\n\tif (nesting_level)\n\t\treturn X86EMUL_UNHANDLEABLE;\n\n\trbp = reg_read(ctxt, VCPU_REGS_RBP);\n\trc = push(ctxt, &rbp, stack_size(ctxt));\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\tassign_masked(reg_rmw(ctxt, VCPU_REGS_RBP), reg_read(ctxt, VCPU_REGS_RSP),\n\t\t      stack_mask(ctxt));\n\tassign_masked(reg_rmw(ctxt, VCPU_REGS_RSP),\n\t\t      reg_read(ctxt, VCPU_REGS_RSP) - frame_size,\n\t\t      stack_mask(ctxt));\n\treturn X86EMUL_CONTINUE;\n}"
  },
  {
    "function_name": "em_popf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "1844-1850",
    "snippet": "static int em_popf(struct x86_emulate_ctxt *ctxt)\n{\n\tctxt->dst.type = OP_REG;\n\tctxt->dst.addr.reg = &ctxt->eflags;\n\tctxt->dst.bytes = ctxt->op_bytes;\n\treturn emulate_popf(ctxt, &ctxt->dst.val, ctxt->op_bytes);\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "emulate_popf",
          "args": [
            "ctxt",
            "&ctxt->dst.val",
            "ctxt->op_bytes"
          ],
          "line": 1849
        },
        "resolved": true,
        "details": {
          "function_name": "emulate_popf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "1802-1842",
          "snippet": "static int emulate_popf(struct x86_emulate_ctxt *ctxt,\n\t\t\tvoid *dest, int len)\n{\n\tint rc;\n\tunsigned long val, change_mask;\n\tint iopl = (ctxt->eflags & X86_EFLAGS_IOPL) >> X86_EFLAGS_IOPL_BIT;\n\tint cpl = ctxt->ops->cpl(ctxt);\n\n\trc = emulate_pop(ctxt, &val, len);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\tchange_mask = X86_EFLAGS_CF | X86_EFLAGS_PF | X86_EFLAGS_AF |\n\t\t      X86_EFLAGS_ZF | X86_EFLAGS_SF | X86_EFLAGS_OF |\n\t\t      X86_EFLAGS_TF | X86_EFLAGS_DF | X86_EFLAGS_NT |\n\t\t      X86_EFLAGS_AC | X86_EFLAGS_ID;\n\n\tswitch(ctxt->mode) {\n\tcase X86EMUL_MODE_PROT64:\n\tcase X86EMUL_MODE_PROT32:\n\tcase X86EMUL_MODE_PROT16:\n\t\tif (cpl == 0)\n\t\t\tchange_mask |= X86_EFLAGS_IOPL;\n\t\tif (cpl <= iopl)\n\t\t\tchange_mask |= X86_EFLAGS_IF;\n\t\tbreak;\n\tcase X86EMUL_MODE_VM86:\n\t\tif (iopl < 3)\n\t\t\treturn emulate_gp(ctxt, 0);\n\t\tchange_mask |= X86_EFLAGS_IF;\n\t\tbreak;\n\tdefault: /* real mode */\n\t\tchange_mask |= (X86_EFLAGS_IOPL | X86_EFLAGS_IF);\n\t\tbreak;\n\t}\n\n\t*(unsigned long *)dest =\n\t\t(ctxt->eflags & ~change_mask) | (val & change_mask);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int emulate_popf(struct x86_emulate_ctxt *ctxt,\n\t\t\tvoid *dest, int len)\n{\n\tint rc;\n\tunsigned long val, change_mask;\n\tint iopl = (ctxt->eflags & X86_EFLAGS_IOPL) >> X86_EFLAGS_IOPL_BIT;\n\tint cpl = ctxt->ops->cpl(ctxt);\n\n\trc = emulate_pop(ctxt, &val, len);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\tchange_mask = X86_EFLAGS_CF | X86_EFLAGS_PF | X86_EFLAGS_AF |\n\t\t      X86_EFLAGS_ZF | X86_EFLAGS_SF | X86_EFLAGS_OF |\n\t\t      X86_EFLAGS_TF | X86_EFLAGS_DF | X86_EFLAGS_NT |\n\t\t      X86_EFLAGS_AC | X86_EFLAGS_ID;\n\n\tswitch(ctxt->mode) {\n\tcase X86EMUL_MODE_PROT64:\n\tcase X86EMUL_MODE_PROT32:\n\tcase X86EMUL_MODE_PROT16:\n\t\tif (cpl == 0)\n\t\t\tchange_mask |= X86_EFLAGS_IOPL;\n\t\tif (cpl <= iopl)\n\t\t\tchange_mask |= X86_EFLAGS_IF;\n\t\tbreak;\n\tcase X86EMUL_MODE_VM86:\n\t\tif (iopl < 3)\n\t\t\treturn emulate_gp(ctxt, 0);\n\t\tchange_mask |= X86_EFLAGS_IF;\n\t\tbreak;\n\tdefault: /* real mode */\n\t\tchange_mask |= (X86_EFLAGS_IOPL | X86_EFLAGS_IF);\n\t\tbreak;\n\t}\n\n\t*(unsigned long *)dest =\n\t\t(ctxt->eflags & ~change_mask) | (val & change_mask);\n\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int em_popf(struct x86_emulate_ctxt *ctxt)\n{\n\tctxt->dst.type = OP_REG;\n\tctxt->dst.addr.reg = &ctxt->eflags;\n\tctxt->dst.bytes = ctxt->op_bytes;\n\treturn emulate_popf(ctxt, &ctxt->dst.val, ctxt->op_bytes);\n}"
  },
  {
    "function_name": "emulate_popf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "1802-1842",
    "snippet": "static int emulate_popf(struct x86_emulate_ctxt *ctxt,\n\t\t\tvoid *dest, int len)\n{\n\tint rc;\n\tunsigned long val, change_mask;\n\tint iopl = (ctxt->eflags & X86_EFLAGS_IOPL) >> X86_EFLAGS_IOPL_BIT;\n\tint cpl = ctxt->ops->cpl(ctxt);\n\n\trc = emulate_pop(ctxt, &val, len);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\tchange_mask = X86_EFLAGS_CF | X86_EFLAGS_PF | X86_EFLAGS_AF |\n\t\t      X86_EFLAGS_ZF | X86_EFLAGS_SF | X86_EFLAGS_OF |\n\t\t      X86_EFLAGS_TF | X86_EFLAGS_DF | X86_EFLAGS_NT |\n\t\t      X86_EFLAGS_AC | X86_EFLAGS_ID;\n\n\tswitch(ctxt->mode) {\n\tcase X86EMUL_MODE_PROT64:\n\tcase X86EMUL_MODE_PROT32:\n\tcase X86EMUL_MODE_PROT16:\n\t\tif (cpl == 0)\n\t\t\tchange_mask |= X86_EFLAGS_IOPL;\n\t\tif (cpl <= iopl)\n\t\t\tchange_mask |= X86_EFLAGS_IF;\n\t\tbreak;\n\tcase X86EMUL_MODE_VM86:\n\t\tif (iopl < 3)\n\t\t\treturn emulate_gp(ctxt, 0);\n\t\tchange_mask |= X86_EFLAGS_IF;\n\t\tbreak;\n\tdefault: /* real mode */\n\t\tchange_mask |= (X86_EFLAGS_IOPL | X86_EFLAGS_IF);\n\t\tbreak;\n\t}\n\n\t*(unsigned long *)dest =\n\t\t(ctxt->eflags & ~change_mask) | (val & change_mask);\n\n\treturn rc;\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "emulate_gp",
          "args": [
            "ctxt",
            "0"
          ],
          "line": 1830
        },
        "resolved": true,
        "details": {
          "function_name": "emulate_gp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "580-583",
          "snippet": "static int emulate_gp(struct x86_emulate_ctxt *ctxt, int err)\n{\n\treturn emulate_exception(ctxt, GP_VECTOR, err, true);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int emulate_gp(struct x86_emulate_ctxt *ctxt, int err)\n{\n\treturn emulate_exception(ctxt, GP_VECTOR, err, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "emulate_pop",
          "args": [
            "ctxt",
            "&val",
            "len"
          ],
          "line": 1810
        },
        "resolved": true,
        "details": {
          "function_name": "emulate_popf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "1802-1842",
          "snippet": "static int emulate_popf(struct x86_emulate_ctxt *ctxt,\n\t\t\tvoid *dest, int len)\n{\n\tint rc;\n\tunsigned long val, change_mask;\n\tint iopl = (ctxt->eflags & X86_EFLAGS_IOPL) >> X86_EFLAGS_IOPL_BIT;\n\tint cpl = ctxt->ops->cpl(ctxt);\n\n\trc = emulate_pop(ctxt, &val, len);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\tchange_mask = X86_EFLAGS_CF | X86_EFLAGS_PF | X86_EFLAGS_AF |\n\t\t      X86_EFLAGS_ZF | X86_EFLAGS_SF | X86_EFLAGS_OF |\n\t\t      X86_EFLAGS_TF | X86_EFLAGS_DF | X86_EFLAGS_NT |\n\t\t      X86_EFLAGS_AC | X86_EFLAGS_ID;\n\n\tswitch(ctxt->mode) {\n\tcase X86EMUL_MODE_PROT64:\n\tcase X86EMUL_MODE_PROT32:\n\tcase X86EMUL_MODE_PROT16:\n\t\tif (cpl == 0)\n\t\t\tchange_mask |= X86_EFLAGS_IOPL;\n\t\tif (cpl <= iopl)\n\t\t\tchange_mask |= X86_EFLAGS_IF;\n\t\tbreak;\n\tcase X86EMUL_MODE_VM86:\n\t\tif (iopl < 3)\n\t\t\treturn emulate_gp(ctxt, 0);\n\t\tchange_mask |= X86_EFLAGS_IF;\n\t\tbreak;\n\tdefault: /* real mode */\n\t\tchange_mask |= (X86_EFLAGS_IOPL | X86_EFLAGS_IF);\n\t\tbreak;\n\t}\n\n\t*(unsigned long *)dest =\n\t\t(ctxt->eflags & ~change_mask) | (val & change_mask);\n\n\treturn rc;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "ctxt->ops->cpl",
          "args": [
            "ctxt"
          ],
          "line": 1808
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int emulate_popf(struct x86_emulate_ctxt *ctxt,\n\t\t\tvoid *dest, int len)\n{\n\tint rc;\n\tunsigned long val, change_mask;\n\tint iopl = (ctxt->eflags & X86_EFLAGS_IOPL) >> X86_EFLAGS_IOPL_BIT;\n\tint cpl = ctxt->ops->cpl(ctxt);\n\n\trc = emulate_pop(ctxt, &val, len);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\tchange_mask = X86_EFLAGS_CF | X86_EFLAGS_PF | X86_EFLAGS_AF |\n\t\t      X86_EFLAGS_ZF | X86_EFLAGS_SF | X86_EFLAGS_OF |\n\t\t      X86_EFLAGS_TF | X86_EFLAGS_DF | X86_EFLAGS_NT |\n\t\t      X86_EFLAGS_AC | X86_EFLAGS_ID;\n\n\tswitch(ctxt->mode) {\n\tcase X86EMUL_MODE_PROT64:\n\tcase X86EMUL_MODE_PROT32:\n\tcase X86EMUL_MODE_PROT16:\n\t\tif (cpl == 0)\n\t\t\tchange_mask |= X86_EFLAGS_IOPL;\n\t\tif (cpl <= iopl)\n\t\t\tchange_mask |= X86_EFLAGS_IF;\n\t\tbreak;\n\tcase X86EMUL_MODE_VM86:\n\t\tif (iopl < 3)\n\t\t\treturn emulate_gp(ctxt, 0);\n\t\tchange_mask |= X86_EFLAGS_IF;\n\t\tbreak;\n\tdefault: /* real mode */\n\t\tchange_mask |= (X86_EFLAGS_IOPL | X86_EFLAGS_IF);\n\t\tbreak;\n\t}\n\n\t*(unsigned long *)dest =\n\t\t(ctxt->eflags & ~change_mask) | (val & change_mask);\n\n\treturn rc;\n}"
  },
  {
    "function_name": "em_pop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "1797-1800",
    "snippet": "static int em_pop(struct x86_emulate_ctxt *ctxt)\n{\n\treturn emulate_pop(ctxt, &ctxt->dst.val, ctxt->op_bytes);\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "emulate_pop",
          "args": [
            "ctxt",
            "&ctxt->dst.val",
            "ctxt->op_bytes"
          ],
          "line": 1799
        },
        "resolved": true,
        "details": {
          "function_name": "emulate_popf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "1802-1842",
          "snippet": "static int emulate_popf(struct x86_emulate_ctxt *ctxt,\n\t\t\tvoid *dest, int len)\n{\n\tint rc;\n\tunsigned long val, change_mask;\n\tint iopl = (ctxt->eflags & X86_EFLAGS_IOPL) >> X86_EFLAGS_IOPL_BIT;\n\tint cpl = ctxt->ops->cpl(ctxt);\n\n\trc = emulate_pop(ctxt, &val, len);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\tchange_mask = X86_EFLAGS_CF | X86_EFLAGS_PF | X86_EFLAGS_AF |\n\t\t      X86_EFLAGS_ZF | X86_EFLAGS_SF | X86_EFLAGS_OF |\n\t\t      X86_EFLAGS_TF | X86_EFLAGS_DF | X86_EFLAGS_NT |\n\t\t      X86_EFLAGS_AC | X86_EFLAGS_ID;\n\n\tswitch(ctxt->mode) {\n\tcase X86EMUL_MODE_PROT64:\n\tcase X86EMUL_MODE_PROT32:\n\tcase X86EMUL_MODE_PROT16:\n\t\tif (cpl == 0)\n\t\t\tchange_mask |= X86_EFLAGS_IOPL;\n\t\tif (cpl <= iopl)\n\t\t\tchange_mask |= X86_EFLAGS_IF;\n\t\tbreak;\n\tcase X86EMUL_MODE_VM86:\n\t\tif (iopl < 3)\n\t\t\treturn emulate_gp(ctxt, 0);\n\t\tchange_mask |= X86_EFLAGS_IF;\n\t\tbreak;\n\tdefault: /* real mode */\n\t\tchange_mask |= (X86_EFLAGS_IOPL | X86_EFLAGS_IF);\n\t\tbreak;\n\t}\n\n\t*(unsigned long *)dest =\n\t\t(ctxt->eflags & ~change_mask) | (val & change_mask);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int emulate_popf(struct x86_emulate_ctxt *ctxt,\n\t\t\tvoid *dest, int len)\n{\n\tint rc;\n\tunsigned long val, change_mask;\n\tint iopl = (ctxt->eflags & X86_EFLAGS_IOPL) >> X86_EFLAGS_IOPL_BIT;\n\tint cpl = ctxt->ops->cpl(ctxt);\n\n\trc = emulate_pop(ctxt, &val, len);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\tchange_mask = X86_EFLAGS_CF | X86_EFLAGS_PF | X86_EFLAGS_AF |\n\t\t      X86_EFLAGS_ZF | X86_EFLAGS_SF | X86_EFLAGS_OF |\n\t\t      X86_EFLAGS_TF | X86_EFLAGS_DF | X86_EFLAGS_NT |\n\t\t      X86_EFLAGS_AC | X86_EFLAGS_ID;\n\n\tswitch(ctxt->mode) {\n\tcase X86EMUL_MODE_PROT64:\n\tcase X86EMUL_MODE_PROT32:\n\tcase X86EMUL_MODE_PROT16:\n\t\tif (cpl == 0)\n\t\t\tchange_mask |= X86_EFLAGS_IOPL;\n\t\tif (cpl <= iopl)\n\t\t\tchange_mask |= X86_EFLAGS_IF;\n\t\tbreak;\n\tcase X86EMUL_MODE_VM86:\n\t\tif (iopl < 3)\n\t\t\treturn emulate_gp(ctxt, 0);\n\t\tchange_mask |= X86_EFLAGS_IF;\n\t\tbreak;\n\tdefault: /* real mode */\n\t\tchange_mask |= (X86_EFLAGS_IOPL | X86_EFLAGS_IF);\n\t\tbreak;\n\t}\n\n\t*(unsigned long *)dest =\n\t\t(ctxt->eflags & ~change_mask) | (val & change_mask);\n\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int em_pop(struct x86_emulate_ctxt *ctxt)\n{\n\treturn emulate_pop(ctxt, &ctxt->dst.val, ctxt->op_bytes);\n}"
  },
  {
    "function_name": "emulate_pop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "1781-1795",
    "snippet": "static int emulate_pop(struct x86_emulate_ctxt *ctxt,\n\t\t       void *dest, int len)\n{\n\tint rc;\n\tstruct segmented_address addr;\n\n\taddr.ea = reg_read(ctxt, VCPU_REGS_RSP) & stack_mask(ctxt);\n\taddr.seg = VCPU_SREG_SS;\n\trc = segmented_read(ctxt, addr, dest, len);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\trsp_increment(ctxt, len);\n\treturn rc;\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rsp_increment",
          "args": [
            "ctxt",
            "len"
          ],
          "line": 1793
        },
        "resolved": true,
        "details": {
          "function_name": "rsp_increment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "545-548",
          "snippet": "static void rsp_increment(struct x86_emulate_ctxt *ctxt, int inc)\n{\n\tmasked_increment(reg_rmw(ctxt, VCPU_REGS_RSP), stack_mask(ctxt), inc);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic void rsp_increment(struct x86_emulate_ctxt *ctxt, int inc)\n{\n\tmasked_increment(reg_rmw(ctxt, VCPU_REGS_RSP), stack_mask(ctxt), inc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "segmented_read",
          "args": [
            "ctxt",
            "addr",
            "dest",
            "len"
          ],
          "line": 1789
        },
        "resolved": true,
        "details": {
          "function_name": "segmented_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "1374-1386",
          "snippet": "static int segmented_read(struct x86_emulate_ctxt *ctxt,\n\t\t\t  struct segmented_address addr,\n\t\t\t  void *data,\n\t\t\t  unsigned size)\n{\n\tint rc;\n\tulong linear;\n\n\trc = linearize(ctxt, addr, size, false, &linear);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\treturn read_emulated(ctxt, linear, data, size);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int segmented_read(struct x86_emulate_ctxt *ctxt,\n\t\t\t  struct segmented_address addr,\n\t\t\t  void *data,\n\t\t\t  unsigned size)\n{\n\tint rc;\n\tulong linear;\n\n\trc = linearize(ctxt, addr, size, false, &linear);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\treturn read_emulated(ctxt, linear, data, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "stack_mask",
          "args": [
            "ctxt"
          ],
          "line": 1787
        },
        "resolved": true,
        "details": {
          "function_name": "stack_mask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "500-509",
          "snippet": "static ulong stack_mask(struct x86_emulate_ctxt *ctxt)\n{\n\tu16 sel;\n\tstruct desc_struct ss;\n\n\tif (ctxt->mode == X86EMUL_MODE_PROT64)\n\t\treturn ~0UL;\n\tctxt->ops->get_segment(ctxt, &sel, &ss, NULL, VCPU_SREG_SS);\n\treturn ~0U >> ((ss.d ^ 1) * 16);  /* d=0: 0xffff; d=1: 0xffffffff */\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic ulong stack_mask(struct x86_emulate_ctxt *ctxt)\n{\n\tu16 sel;\n\tstruct desc_struct ss;\n\n\tif (ctxt->mode == X86EMUL_MODE_PROT64)\n\t\treturn ~0UL;\n\tctxt->ops->get_segment(ctxt, &sel, &ss, NULL, VCPU_SREG_SS);\n\treturn ~0U >> ((ss.d ^ 1) * 16);  /* d=0: 0xffff; d=1: 0xffffffff */\n}"
        }
      },
      {
        "call_info": {
          "callee": "reg_read",
          "args": [
            "ctxt",
            "VCPU_REGS_RSP"
          ],
          "line": 1787
        },
        "resolved": true,
        "details": {
          "function_name": "reg_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "261-268",
          "snippet": "static ulong reg_read(struct x86_emulate_ctxt *ctxt, unsigned nr)\n{\n\tif (!(ctxt->regs_valid & (1 << nr))) {\n\t\tctxt->regs_valid |= 1 << nr;\n\t\tctxt->_regs[nr] = ctxt->ops->read_gpr(ctxt, nr);\n\t}\n\treturn ctxt->_regs[nr];\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic ulong reg_read(struct x86_emulate_ctxt *ctxt, unsigned nr)\n{\n\tif (!(ctxt->regs_valid & (1 << nr))) {\n\t\tctxt->regs_valid |= 1 << nr;\n\t\tctxt->_regs[nr] = ctxt->ops->read_gpr(ctxt, nr);\n\t}\n\treturn ctxt->_regs[nr];\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int emulate_pop(struct x86_emulate_ctxt *ctxt,\n\t\t       void *dest, int len)\n{\n\tint rc;\n\tstruct segmented_address addr;\n\n\taddr.ea = reg_read(ctxt, VCPU_REGS_RSP) & stack_mask(ctxt);\n\taddr.seg = VCPU_SREG_SS;\n\trc = segmented_read(ctxt, addr, dest, len);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\trsp_increment(ctxt, len);\n\treturn rc;\n}"
  },
  {
    "function_name": "em_push",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "1774-1779",
    "snippet": "static int em_push(struct x86_emulate_ctxt *ctxt)\n{\n\t/* Disable writeback. */\n\tctxt->dst.type = OP_NONE;\n\treturn push(ctxt, &ctxt->src.val, ctxt->op_bytes);\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "push",
          "args": [
            "ctxt",
            "&ctxt->src.val",
            "ctxt->op_bytes"
          ],
          "line": 1778
        },
        "resolved": true,
        "details": {
          "function_name": "push",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "1763-1772",
          "snippet": "static int push(struct x86_emulate_ctxt *ctxt, void *data, int bytes)\n{\n\tstruct segmented_address addr;\n\n\trsp_increment(ctxt, -bytes);\n\taddr.ea = reg_read(ctxt, VCPU_REGS_RSP) & stack_mask(ctxt);\n\taddr.seg = VCPU_SREG_SS;\n\n\treturn segmented_write(ctxt, addr, data, bytes);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int push(struct x86_emulate_ctxt *ctxt, void *data, int bytes)\n{\n\tstruct segmented_address addr;\n\n\trsp_increment(ctxt, -bytes);\n\taddr.ea = reg_read(ctxt, VCPU_REGS_RSP) & stack_mask(ctxt);\n\taddr.seg = VCPU_SREG_SS;\n\n\treturn segmented_write(ctxt, addr, data, bytes);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int em_push(struct x86_emulate_ctxt *ctxt)\n{\n\t/* Disable writeback. */\n\tctxt->dst.type = OP_NONE;\n\treturn push(ctxt, &ctxt->src.val, ctxt->op_bytes);\n}"
  },
  {
    "function_name": "push",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "1763-1772",
    "snippet": "static int push(struct x86_emulate_ctxt *ctxt, void *data, int bytes)\n{\n\tstruct segmented_address addr;\n\n\trsp_increment(ctxt, -bytes);\n\taddr.ea = reg_read(ctxt, VCPU_REGS_RSP) & stack_mask(ctxt);\n\taddr.seg = VCPU_SREG_SS;\n\n\treturn segmented_write(ctxt, addr, data, bytes);\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "segmented_write",
          "args": [
            "ctxt",
            "addr",
            "data",
            "bytes"
          ],
          "line": 1771
        },
        "resolved": true,
        "details": {
          "function_name": "segmented_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "1388-1401",
          "snippet": "static int segmented_write(struct x86_emulate_ctxt *ctxt,\n\t\t\t   struct segmented_address addr,\n\t\t\t   const void *data,\n\t\t\t   unsigned size)\n{\n\tint rc;\n\tulong linear;\n\n\trc = linearize(ctxt, addr, size, true, &linear);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\treturn ctxt->ops->write_emulated(ctxt, linear, data, size,\n\t\t\t\t\t &ctxt->exception);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int segmented_write(struct x86_emulate_ctxt *ctxt,\n\t\t\t   struct segmented_address addr,\n\t\t\t   const void *data,\n\t\t\t   unsigned size)\n{\n\tint rc;\n\tulong linear;\n\n\trc = linearize(ctxt, addr, size, true, &linear);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\treturn ctxt->ops->write_emulated(ctxt, linear, data, size,\n\t\t\t\t\t &ctxt->exception);\n}"
        }
      },
      {
        "call_info": {
          "callee": "stack_mask",
          "args": [
            "ctxt"
          ],
          "line": 1768
        },
        "resolved": true,
        "details": {
          "function_name": "stack_mask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "500-509",
          "snippet": "static ulong stack_mask(struct x86_emulate_ctxt *ctxt)\n{\n\tu16 sel;\n\tstruct desc_struct ss;\n\n\tif (ctxt->mode == X86EMUL_MODE_PROT64)\n\t\treturn ~0UL;\n\tctxt->ops->get_segment(ctxt, &sel, &ss, NULL, VCPU_SREG_SS);\n\treturn ~0U >> ((ss.d ^ 1) * 16);  /* d=0: 0xffff; d=1: 0xffffffff */\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic ulong stack_mask(struct x86_emulate_ctxt *ctxt)\n{\n\tu16 sel;\n\tstruct desc_struct ss;\n\n\tif (ctxt->mode == X86EMUL_MODE_PROT64)\n\t\treturn ~0UL;\n\tctxt->ops->get_segment(ctxt, &sel, &ss, NULL, VCPU_SREG_SS);\n\treturn ~0U >> ((ss.d ^ 1) * 16);  /* d=0: 0xffff; d=1: 0xffffffff */\n}"
        }
      },
      {
        "call_info": {
          "callee": "reg_read",
          "args": [
            "ctxt",
            "VCPU_REGS_RSP"
          ],
          "line": 1768
        },
        "resolved": true,
        "details": {
          "function_name": "reg_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "261-268",
          "snippet": "static ulong reg_read(struct x86_emulate_ctxt *ctxt, unsigned nr)\n{\n\tif (!(ctxt->regs_valid & (1 << nr))) {\n\t\tctxt->regs_valid |= 1 << nr;\n\t\tctxt->_regs[nr] = ctxt->ops->read_gpr(ctxt, nr);\n\t}\n\treturn ctxt->_regs[nr];\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic ulong reg_read(struct x86_emulate_ctxt *ctxt, unsigned nr)\n{\n\tif (!(ctxt->regs_valid & (1 << nr))) {\n\t\tctxt->regs_valid |= 1 << nr;\n\t\tctxt->_regs[nr] = ctxt->ops->read_gpr(ctxt, nr);\n\t}\n\treturn ctxt->_regs[nr];\n}"
        }
      },
      {
        "call_info": {
          "callee": "rsp_increment",
          "args": [
            "ctxt",
            "-bytes"
          ],
          "line": 1767
        },
        "resolved": true,
        "details": {
          "function_name": "rsp_increment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "545-548",
          "snippet": "static void rsp_increment(struct x86_emulate_ctxt *ctxt, int inc)\n{\n\tmasked_increment(reg_rmw(ctxt, VCPU_REGS_RSP), stack_mask(ctxt), inc);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic void rsp_increment(struct x86_emulate_ctxt *ctxt, int inc)\n{\n\tmasked_increment(reg_rmw(ctxt, VCPU_REGS_RSP), stack_mask(ctxt), inc);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int push(struct x86_emulate_ctxt *ctxt, void *data, int bytes)\n{\n\tstruct segmented_address addr;\n\n\trsp_increment(ctxt, -bytes);\n\taddr.ea = reg_read(ctxt, VCPU_REGS_RSP) & stack_mask(ctxt);\n\taddr.seg = VCPU_SREG_SS;\n\n\treturn segmented_write(ctxt, addr, data, bytes);\n}"
  },
  {
    "function_name": "writeback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "1723-1761",
    "snippet": "static int writeback(struct x86_emulate_ctxt *ctxt, struct operand *op)\n{\n\tswitch (op->type) {\n\tcase OP_REG:\n\t\twrite_register_operand(op);\n\t\tbreak;\n\tcase OP_MEM:\n\t\tif (ctxt->lock_prefix)\n\t\t\treturn segmented_cmpxchg(ctxt,\n\t\t\t\t\t\t op->addr.mem,\n\t\t\t\t\t\t &op->orig_val,\n\t\t\t\t\t\t &op->val,\n\t\t\t\t\t\t op->bytes);\n\t\telse\n\t\t\treturn segmented_write(ctxt,\n\t\t\t\t\t       op->addr.mem,\n\t\t\t\t\t       &op->val,\n\t\t\t\t\t       op->bytes);\n\t\tbreak;\n\tcase OP_MEM_STR:\n\t\treturn segmented_write(ctxt,\n\t\t\t\t       op->addr.mem,\n\t\t\t\t       op->data,\n\t\t\t\t       op->bytes * op->count);\n\t\tbreak;\n\tcase OP_XMM:\n\t\twrite_sse_reg(ctxt, &op->vec_val, op->addr.xmm);\n\t\tbreak;\n\tcase OP_MM:\n\t\twrite_mmx_reg(ctxt, &op->mm_val, op->addr.mm);\n\t\tbreak;\n\tcase OP_NONE:\n\t\t/* no writeback */\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn X86EMUL_CONTINUE;\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_mmx_reg",
          "args": [
            "ctxt",
            "&op->mm_val",
            "op->addr.mm"
          ],
          "line": 1752
        },
        "resolved": true,
        "details": {
          "function_name": "write_mmx_reg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "1073-1088",
          "snippet": "static void write_mmx_reg(struct x86_emulate_ctxt *ctxt, u64 *data, int reg)\n{\n\tctxt->ops->get_fpu(ctxt);\n\tswitch (reg) {\n\tcase 0: asm(\"movq %0, %%mm0\" : : \"m\"(*data)); break;\n\tcase 1: asm(\"movq %0, %%mm1\" : : \"m\"(*data)); break;\n\tcase 2: asm(\"movq %0, %%mm2\" : : \"m\"(*data)); break;\n\tcase 3: asm(\"movq %0, %%mm3\" : : \"m\"(*data)); break;\n\tcase 4: asm(\"movq %0, %%mm4\" : : \"m\"(*data)); break;\n\tcase 5: asm(\"movq %0, %%mm5\" : : \"m\"(*data)); break;\n\tcase 6: asm(\"movq %0, %%mm6\" : : \"m\"(*data)); break;\n\tcase 7: asm(\"movq %0, %%mm7\" : : \"m\"(*data)); break;\n\tdefault: BUG();\n\t}\n\tctxt->ops->put_fpu(ctxt);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic void write_mmx_reg(struct x86_emulate_ctxt *ctxt, u64 *data, int reg)\n{\n\tctxt->ops->get_fpu(ctxt);\n\tswitch (reg) {\n\tcase 0: asm(\"movq %0, %%mm0\" : : \"m\"(*data)); break;\n\tcase 1: asm(\"movq %0, %%mm1\" : : \"m\"(*data)); break;\n\tcase 2: asm(\"movq %0, %%mm2\" : : \"m\"(*data)); break;\n\tcase 3: asm(\"movq %0, %%mm3\" : : \"m\"(*data)); break;\n\tcase 4: asm(\"movq %0, %%mm4\" : : \"m\"(*data)); break;\n\tcase 5: asm(\"movq %0, %%mm5\" : : \"m\"(*data)); break;\n\tcase 6: asm(\"movq %0, %%mm6\" : : \"m\"(*data)); break;\n\tcase 7: asm(\"movq %0, %%mm7\" : : \"m\"(*data)); break;\n\tdefault: BUG();\n\t}\n\tctxt->ops->put_fpu(ctxt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_sse_reg",
          "args": [
            "ctxt",
            "&op->vec_val",
            "op->addr.xmm"
          ],
          "line": 1749
        },
        "resolved": true,
        "details": {
          "function_name": "write_sse_reg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "1028-1054",
          "snippet": "static void write_sse_reg(struct x86_emulate_ctxt *ctxt, sse128_t *data,\n\t\t\t  int reg)\n{\n\tctxt->ops->get_fpu(ctxt);\n\tswitch (reg) {\n\tcase 0: asm(\"movdqa %0, %%xmm0\" : : \"m\"(*data)); break;\n\tcase 1: asm(\"movdqa %0, %%xmm1\" : : \"m\"(*data)); break;\n\tcase 2: asm(\"movdqa %0, %%xmm2\" : : \"m\"(*data)); break;\n\tcase 3: asm(\"movdqa %0, %%xmm3\" : : \"m\"(*data)); break;\n\tcase 4: asm(\"movdqa %0, %%xmm4\" : : \"m\"(*data)); break;\n\tcase 5: asm(\"movdqa %0, %%xmm5\" : : \"m\"(*data)); break;\n\tcase 6: asm(\"movdqa %0, %%xmm6\" : : \"m\"(*data)); break;\n\tcase 7: asm(\"movdqa %0, %%xmm7\" : : \"m\"(*data)); break;\n#ifdef CONFIG_X86_64\n\tcase 8: asm(\"movdqa %0, %%xmm8\" : : \"m\"(*data)); break;\n\tcase 9: asm(\"movdqa %0, %%xmm9\" : : \"m\"(*data)); break;\n\tcase 10: asm(\"movdqa %0, %%xmm10\" : : \"m\"(*data)); break;\n\tcase 11: asm(\"movdqa %0, %%xmm11\" : : \"m\"(*data)); break;\n\tcase 12: asm(\"movdqa %0, %%xmm12\" : : \"m\"(*data)); break;\n\tcase 13: asm(\"movdqa %0, %%xmm13\" : : \"m\"(*data)); break;\n\tcase 14: asm(\"movdqa %0, %%xmm14\" : : \"m\"(*data)); break;\n\tcase 15: asm(\"movdqa %0, %%xmm15\" : : \"m\"(*data)); break;\n#endif\n\tdefault: BUG();\n\t}\n\tctxt->ops->put_fpu(ctxt);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic void write_sse_reg(struct x86_emulate_ctxt *ctxt, sse128_t *data,\n\t\t\t  int reg)\n{\n\tctxt->ops->get_fpu(ctxt);\n\tswitch (reg) {\n\tcase 0: asm(\"movdqa %0, %%xmm0\" : : \"m\"(*data)); break;\n\tcase 1: asm(\"movdqa %0, %%xmm1\" : : \"m\"(*data)); break;\n\tcase 2: asm(\"movdqa %0, %%xmm2\" : : \"m\"(*data)); break;\n\tcase 3: asm(\"movdqa %0, %%xmm3\" : : \"m\"(*data)); break;\n\tcase 4: asm(\"movdqa %0, %%xmm4\" : : \"m\"(*data)); break;\n\tcase 5: asm(\"movdqa %0, %%xmm5\" : : \"m\"(*data)); break;\n\tcase 6: asm(\"movdqa %0, %%xmm6\" : : \"m\"(*data)); break;\n\tcase 7: asm(\"movdqa %0, %%xmm7\" : : \"m\"(*data)); break;\n#ifdef CONFIG_X86_64\n\tcase 8: asm(\"movdqa %0, %%xmm8\" : : \"m\"(*data)); break;\n\tcase 9: asm(\"movdqa %0, %%xmm9\" : : \"m\"(*data)); break;\n\tcase 10: asm(\"movdqa %0, %%xmm10\" : : \"m\"(*data)); break;\n\tcase 11: asm(\"movdqa %0, %%xmm11\" : : \"m\"(*data)); break;\n\tcase 12: asm(\"movdqa %0, %%xmm12\" : : \"m\"(*data)); break;\n\tcase 13: asm(\"movdqa %0, %%xmm13\" : : \"m\"(*data)); break;\n\tcase 14: asm(\"movdqa %0, %%xmm14\" : : \"m\"(*data)); break;\n\tcase 15: asm(\"movdqa %0, %%xmm15\" : : \"m\"(*data)); break;\n#endif\n\tdefault: BUG();\n\t}\n\tctxt->ops->put_fpu(ctxt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "segmented_write",
          "args": [
            "ctxt",
            "op->addr.mem",
            "op->data",
            "op->bytes * op->count"
          ],
          "line": 1743
        },
        "resolved": true,
        "details": {
          "function_name": "segmented_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "1388-1401",
          "snippet": "static int segmented_write(struct x86_emulate_ctxt *ctxt,\n\t\t\t   struct segmented_address addr,\n\t\t\t   const void *data,\n\t\t\t   unsigned size)\n{\n\tint rc;\n\tulong linear;\n\n\trc = linearize(ctxt, addr, size, true, &linear);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\treturn ctxt->ops->write_emulated(ctxt, linear, data, size,\n\t\t\t\t\t &ctxt->exception);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int segmented_write(struct x86_emulate_ctxt *ctxt,\n\t\t\t   struct segmented_address addr,\n\t\t\t   const void *data,\n\t\t\t   unsigned size)\n{\n\tint rc;\n\tulong linear;\n\n\trc = linearize(ctxt, addr, size, true, &linear);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\treturn ctxt->ops->write_emulated(ctxt, linear, data, size,\n\t\t\t\t\t &ctxt->exception);\n}"
        }
      },
      {
        "call_info": {
          "callee": "segmented_cmpxchg",
          "args": [
            "ctxt",
            "op->addr.mem",
            "&op->orig_val",
            "&op->val",
            "op->bytes"
          ],
          "line": 1731
        },
        "resolved": true,
        "details": {
          "function_name": "segmented_cmpxchg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "1403-1416",
          "snippet": "static int segmented_cmpxchg(struct x86_emulate_ctxt *ctxt,\n\t\t\t     struct segmented_address addr,\n\t\t\t     const void *orig_data, const void *data,\n\t\t\t     unsigned size)\n{\n\tint rc;\n\tulong linear;\n\n\trc = linearize(ctxt, addr, size, true, &linear);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\treturn ctxt->ops->cmpxchg_emulated(ctxt, linear, orig_data, data,\n\t\t\t\t\t   size, &ctxt->exception);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int segmented_cmpxchg(struct x86_emulate_ctxt *ctxt,\n\t\t\t     struct segmented_address addr,\n\t\t\t     const void *orig_data, const void *data,\n\t\t\t     unsigned size)\n{\n\tint rc;\n\tulong linear;\n\n\trc = linearize(ctxt, addr, size, true, &linear);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\treturn ctxt->ops->cmpxchg_emulated(ctxt, linear, orig_data, data,\n\t\t\t\t\t   size, &ctxt->exception);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_register_operand",
          "args": [
            "op"
          ],
          "line": 1727
        },
        "resolved": true,
        "details": {
          "function_name": "write_register_operand",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "1718-1721",
          "snippet": "static void write_register_operand(struct operand *op)\n{\n\treturn assign_register(op->addr.reg, op->val, op->bytes);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic void write_register_operand(struct operand *op)\n{\n\treturn assign_register(op->addr.reg, op->val, op->bytes);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int writeback(struct x86_emulate_ctxt *ctxt, struct operand *op)\n{\n\tswitch (op->type) {\n\tcase OP_REG:\n\t\twrite_register_operand(op);\n\t\tbreak;\n\tcase OP_MEM:\n\t\tif (ctxt->lock_prefix)\n\t\t\treturn segmented_cmpxchg(ctxt,\n\t\t\t\t\t\t op->addr.mem,\n\t\t\t\t\t\t &op->orig_val,\n\t\t\t\t\t\t &op->val,\n\t\t\t\t\t\t op->bytes);\n\t\telse\n\t\t\treturn segmented_write(ctxt,\n\t\t\t\t\t       op->addr.mem,\n\t\t\t\t\t       &op->val,\n\t\t\t\t\t       op->bytes);\n\t\tbreak;\n\tcase OP_MEM_STR:\n\t\treturn segmented_write(ctxt,\n\t\t\t\t       op->addr.mem,\n\t\t\t\t       op->data,\n\t\t\t\t       op->bytes * op->count);\n\t\tbreak;\n\tcase OP_XMM:\n\t\twrite_sse_reg(ctxt, &op->vec_val, op->addr.xmm);\n\t\tbreak;\n\tcase OP_MM:\n\t\twrite_mmx_reg(ctxt, &op->mm_val, op->addr.mm);\n\t\tbreak;\n\tcase OP_NONE:\n\t\t/* no writeback */\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn X86EMUL_CONTINUE;\n}"
  },
  {
    "function_name": "write_register_operand",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "1718-1721",
    "snippet": "static void write_register_operand(struct operand *op)\n{\n\treturn assign_register(op->addr.reg, op->val, op->bytes);\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "assign_register",
          "args": [
            "op->addr.reg",
            "op->val",
            "op->bytes"
          ],
          "line": 1720
        },
        "resolved": true,
        "details": {
          "function_name": "assign_register",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "476-493",
          "snippet": "static void assign_register(unsigned long *reg, u64 val, int bytes)\n{\n\t/* The 4-byte case *is* correct: in 64-bit mode we zero-extend. */\n\tswitch (bytes) {\n\tcase 1:\n\t\t*(u8 *)reg = (u8)val;\n\t\tbreak;\n\tcase 2:\n\t\t*(u16 *)reg = (u16)val;\n\t\tbreak;\n\tcase 4:\n\t\t*reg = (u32)val;\n\t\tbreak;\t/* 64b: zero-extend */\n\tcase 8:\n\t\t*reg = val;\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic void assign_register(unsigned long *reg, u64 val, int bytes)\n{\n\t/* The 4-byte case *is* correct: in 64-bit mode we zero-extend. */\n\tswitch (bytes) {\n\tcase 1:\n\t\t*(u8 *)reg = (u8)val;\n\t\tbreak;\n\tcase 2:\n\t\t*(u16 *)reg = (u16)val;\n\t\tbreak;\n\tcase 4:\n\t\t*reg = (u32)val;\n\t\tbreak;\t/* 64b: zero-extend */\n\tcase 8:\n\t\t*reg = val;\n\t\tbreak;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic void write_register_operand(struct operand *op)\n{\n\treturn assign_register(op->addr.reg, op->val, op->bytes);\n}"
  },
  {
    "function_name": "load_segment_descriptor",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "1710-1716",
    "snippet": "static int load_segment_descriptor(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t   u16 selector, int seg)\n{\n\tu8 cpl = ctxt->ops->cpl(ctxt);\n\treturn __load_segment_descriptor(ctxt, selector, seg, cpl,\n\t\t\t\t\t X86_TRANSFER_NONE, NULL);\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__load_segment_descriptor",
          "args": [
            "ctxt",
            "selector",
            "seg",
            "cpl",
            "X86_TRANSFER_NONE",
            "NULL"
          ],
          "line": 1714
        },
        "resolved": true,
        "details": {
          "function_name": "__load_segment_descriptor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "1549-1708",
          "snippet": "static int __load_segment_descriptor(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t     u16 selector, int seg, u8 cpl,\n\t\t\t\t     enum x86_transfer_type transfer,\n\t\t\t\t     struct desc_struct *desc)\n{\n\tstruct desc_struct seg_desc, old_desc;\n\tu8 dpl, rpl;\n\tunsigned err_vec = GP_VECTOR;\n\tu32 err_code = 0;\n\tbool null_selector = !(selector & ~0x3); /* 0000-0003 are null */\n\tulong desc_addr;\n\tint ret;\n\tu16 dummy;\n\tu32 base3 = 0;\n\n\tmemset(&seg_desc, 0, sizeof seg_desc);\n\n\tif (ctxt->mode == X86EMUL_MODE_REAL) {\n\t\t/* set real mode segment descriptor (keep limit etc. for\n\t\t * unreal mode) */\n\t\tctxt->ops->get_segment(ctxt, &dummy, &seg_desc, NULL, seg);\n\t\tset_desc_base(&seg_desc, selector << 4);\n\t\tgoto load;\n\t} else if (seg <= VCPU_SREG_GS && ctxt->mode == X86EMUL_MODE_VM86) {\n\t\t/* VM86 needs a clean new segment descriptor */\n\t\tset_desc_base(&seg_desc, selector << 4);\n\t\tset_desc_limit(&seg_desc, 0xffff);\n\t\tseg_desc.type = 3;\n\t\tseg_desc.p = 1;\n\t\tseg_desc.s = 1;\n\t\tseg_desc.dpl = 3;\n\t\tgoto load;\n\t}\n\n\trpl = selector & 3;\n\n\t/* NULL selector is not valid for TR, CS and SS (except for long mode) */\n\tif ((seg == VCPU_SREG_CS\n\t     || (seg == VCPU_SREG_SS\n\t\t && (ctxt->mode != X86EMUL_MODE_PROT64 || rpl != cpl))\n\t     || seg == VCPU_SREG_TR)\n\t    && null_selector)\n\t\tgoto exception;\n\n\t/* TR should be in GDT only */\n\tif (seg == VCPU_SREG_TR && (selector & (1 << 2)))\n\t\tgoto exception;\n\n\tif (null_selector) /* for NULL selector skip all following checks */\n\t\tgoto load;\n\n\tret = read_segment_descriptor(ctxt, selector, &seg_desc, &desc_addr);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\n\terr_code = selector & 0xfffc;\n\terr_vec = (transfer == X86_TRANSFER_TASK_SWITCH) ? TS_VECTOR :\n\t\t\t\t\t\t\t   GP_VECTOR;\n\n\t/* can't load system descriptor into segment selector */\n\tif (seg <= VCPU_SREG_GS && !seg_desc.s) {\n\t\tif (transfer == X86_TRANSFER_CALL_JMP)\n\t\t\treturn X86EMUL_UNHANDLEABLE;\n\t\tgoto exception;\n\t}\n\n\tif (!seg_desc.p) {\n\t\terr_vec = (seg == VCPU_SREG_SS) ? SS_VECTOR : NP_VECTOR;\n\t\tgoto exception;\n\t}\n\n\tdpl = seg_desc.dpl;\n\n\tswitch (seg) {\n\tcase VCPU_SREG_SS:\n\t\t/*\n\t\t * segment is not a writable data segment or segment\n\t\t * selector's RPL != CPL or segment selector's RPL != CPL\n\t\t */\n\t\tif (rpl != cpl || (seg_desc.type & 0xa) != 0x2 || dpl != cpl)\n\t\t\tgoto exception;\n\t\tbreak;\n\tcase VCPU_SREG_CS:\n\t\tif (!(seg_desc.type & 8))\n\t\t\tgoto exception;\n\n\t\tif (seg_desc.type & 4) {\n\t\t\t/* conforming */\n\t\t\tif (dpl > cpl)\n\t\t\t\tgoto exception;\n\t\t} else {\n\t\t\t/* nonconforming */\n\t\t\tif (rpl > cpl || dpl != cpl)\n\t\t\t\tgoto exception;\n\t\t}\n\t\t/* in long-mode d/b must be clear if l is set */\n\t\tif (seg_desc.d && seg_desc.l) {\n\t\t\tu64 efer = 0;\n\n\t\t\tctxt->ops->get_msr(ctxt, MSR_EFER, &efer);\n\t\t\tif (efer & EFER_LMA)\n\t\t\t\tgoto exception;\n\t\t}\n\n\t\t/* CS(RPL) <- CPL */\n\t\tselector = (selector & 0xfffc) | cpl;\n\t\tbreak;\n\tcase VCPU_SREG_TR:\n\t\tif (seg_desc.s || (seg_desc.type != 1 && seg_desc.type != 9))\n\t\t\tgoto exception;\n\t\told_desc = seg_desc;\n\t\tseg_desc.type |= 2; /* busy */\n\t\tret = ctxt->ops->cmpxchg_emulated(ctxt, desc_addr, &old_desc, &seg_desc,\n\t\t\t\t\t\t  sizeof(seg_desc), &ctxt->exception);\n\t\tif (ret != X86EMUL_CONTINUE)\n\t\t\treturn ret;\n\t\tbreak;\n\tcase VCPU_SREG_LDTR:\n\t\tif (seg_desc.s || seg_desc.type != 2)\n\t\t\tgoto exception;\n\t\tbreak;\n\tdefault: /*  DS, ES, FS, or GS */\n\t\t/*\n\t\t * segment is not a data or readable code segment or\n\t\t * ((segment is a data or nonconforming code segment)\n\t\t * and (both RPL and CPL > DPL))\n\t\t */\n\t\tif ((seg_desc.type & 0xa) == 0x8 ||\n\t\t    (((seg_desc.type & 0xc) != 0xc) &&\n\t\t     (rpl > dpl && cpl > dpl)))\n\t\t\tgoto exception;\n\t\tbreak;\n\t}\n\n\tif (seg_desc.s) {\n\t\t/* mark segment as accessed */\n\t\tif (!(seg_desc.type & 1)) {\n\t\t\tseg_desc.type |= 1;\n\t\t\tret = write_segment_descriptor(ctxt, selector,\n\t\t\t\t\t\t       &seg_desc);\n\t\t\tif (ret != X86EMUL_CONTINUE)\n\t\t\t\treturn ret;\n\t\t}\n\t} else if (ctxt->mode == X86EMUL_MODE_PROT64) {\n\t\tret = ctxt->ops->read_std(ctxt, desc_addr+8, &base3,\n\t\t\t\tsizeof(base3), &ctxt->exception);\n\t\tif (ret != X86EMUL_CONTINUE)\n\t\t\treturn ret;\n\t\tif (is_noncanonical_address(get_desc_base(&seg_desc) |\n\t\t\t\t\t     ((u64)base3 << 32)))\n\t\t\treturn emulate_gp(ctxt, 0);\n\t}\nload:\n\tctxt->ops->set_segment(ctxt, selector, &seg_desc, base3, seg);\n\tif (desc)\n\t\t*desc = seg_desc;\n\treturn X86EMUL_CONTINUE;\nexception:\n\treturn emulate_exception(ctxt, err_vec, err_code, true);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int __load_segment_descriptor(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t     u16 selector, int seg, u8 cpl,\n\t\t\t\t     enum x86_transfer_type transfer,\n\t\t\t\t     struct desc_struct *desc)\n{\n\tstruct desc_struct seg_desc, old_desc;\n\tu8 dpl, rpl;\n\tunsigned err_vec = GP_VECTOR;\n\tu32 err_code = 0;\n\tbool null_selector = !(selector & ~0x3); /* 0000-0003 are null */\n\tulong desc_addr;\n\tint ret;\n\tu16 dummy;\n\tu32 base3 = 0;\n\n\tmemset(&seg_desc, 0, sizeof seg_desc);\n\n\tif (ctxt->mode == X86EMUL_MODE_REAL) {\n\t\t/* set real mode segment descriptor (keep limit etc. for\n\t\t * unreal mode) */\n\t\tctxt->ops->get_segment(ctxt, &dummy, &seg_desc, NULL, seg);\n\t\tset_desc_base(&seg_desc, selector << 4);\n\t\tgoto load;\n\t} else if (seg <= VCPU_SREG_GS && ctxt->mode == X86EMUL_MODE_VM86) {\n\t\t/* VM86 needs a clean new segment descriptor */\n\t\tset_desc_base(&seg_desc, selector << 4);\n\t\tset_desc_limit(&seg_desc, 0xffff);\n\t\tseg_desc.type = 3;\n\t\tseg_desc.p = 1;\n\t\tseg_desc.s = 1;\n\t\tseg_desc.dpl = 3;\n\t\tgoto load;\n\t}\n\n\trpl = selector & 3;\n\n\t/* NULL selector is not valid for TR, CS and SS (except for long mode) */\n\tif ((seg == VCPU_SREG_CS\n\t     || (seg == VCPU_SREG_SS\n\t\t && (ctxt->mode != X86EMUL_MODE_PROT64 || rpl != cpl))\n\t     || seg == VCPU_SREG_TR)\n\t    && null_selector)\n\t\tgoto exception;\n\n\t/* TR should be in GDT only */\n\tif (seg == VCPU_SREG_TR && (selector & (1 << 2)))\n\t\tgoto exception;\n\n\tif (null_selector) /* for NULL selector skip all following checks */\n\t\tgoto load;\n\n\tret = read_segment_descriptor(ctxt, selector, &seg_desc, &desc_addr);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\n\terr_code = selector & 0xfffc;\n\terr_vec = (transfer == X86_TRANSFER_TASK_SWITCH) ? TS_VECTOR :\n\t\t\t\t\t\t\t   GP_VECTOR;\n\n\t/* can't load system descriptor into segment selector */\n\tif (seg <= VCPU_SREG_GS && !seg_desc.s) {\n\t\tif (transfer == X86_TRANSFER_CALL_JMP)\n\t\t\treturn X86EMUL_UNHANDLEABLE;\n\t\tgoto exception;\n\t}\n\n\tif (!seg_desc.p) {\n\t\terr_vec = (seg == VCPU_SREG_SS) ? SS_VECTOR : NP_VECTOR;\n\t\tgoto exception;\n\t}\n\n\tdpl = seg_desc.dpl;\n\n\tswitch (seg) {\n\tcase VCPU_SREG_SS:\n\t\t/*\n\t\t * segment is not a writable data segment or segment\n\t\t * selector's RPL != CPL or segment selector's RPL != CPL\n\t\t */\n\t\tif (rpl != cpl || (seg_desc.type & 0xa) != 0x2 || dpl != cpl)\n\t\t\tgoto exception;\n\t\tbreak;\n\tcase VCPU_SREG_CS:\n\t\tif (!(seg_desc.type & 8))\n\t\t\tgoto exception;\n\n\t\tif (seg_desc.type & 4) {\n\t\t\t/* conforming */\n\t\t\tif (dpl > cpl)\n\t\t\t\tgoto exception;\n\t\t} else {\n\t\t\t/* nonconforming */\n\t\t\tif (rpl > cpl || dpl != cpl)\n\t\t\t\tgoto exception;\n\t\t}\n\t\t/* in long-mode d/b must be clear if l is set */\n\t\tif (seg_desc.d && seg_desc.l) {\n\t\t\tu64 efer = 0;\n\n\t\t\tctxt->ops->get_msr(ctxt, MSR_EFER, &efer);\n\t\t\tif (efer & EFER_LMA)\n\t\t\t\tgoto exception;\n\t\t}\n\n\t\t/* CS(RPL) <- CPL */\n\t\tselector = (selector & 0xfffc) | cpl;\n\t\tbreak;\n\tcase VCPU_SREG_TR:\n\t\tif (seg_desc.s || (seg_desc.type != 1 && seg_desc.type != 9))\n\t\t\tgoto exception;\n\t\told_desc = seg_desc;\n\t\tseg_desc.type |= 2; /* busy */\n\t\tret = ctxt->ops->cmpxchg_emulated(ctxt, desc_addr, &old_desc, &seg_desc,\n\t\t\t\t\t\t  sizeof(seg_desc), &ctxt->exception);\n\t\tif (ret != X86EMUL_CONTINUE)\n\t\t\treturn ret;\n\t\tbreak;\n\tcase VCPU_SREG_LDTR:\n\t\tif (seg_desc.s || seg_desc.type != 2)\n\t\t\tgoto exception;\n\t\tbreak;\n\tdefault: /*  DS, ES, FS, or GS */\n\t\t/*\n\t\t * segment is not a data or readable code segment or\n\t\t * ((segment is a data or nonconforming code segment)\n\t\t * and (both RPL and CPL > DPL))\n\t\t */\n\t\tif ((seg_desc.type & 0xa) == 0x8 ||\n\t\t    (((seg_desc.type & 0xc) != 0xc) &&\n\t\t     (rpl > dpl && cpl > dpl)))\n\t\t\tgoto exception;\n\t\tbreak;\n\t}\n\n\tif (seg_desc.s) {\n\t\t/* mark segment as accessed */\n\t\tif (!(seg_desc.type & 1)) {\n\t\t\tseg_desc.type |= 1;\n\t\t\tret = write_segment_descriptor(ctxt, selector,\n\t\t\t\t\t\t       &seg_desc);\n\t\t\tif (ret != X86EMUL_CONTINUE)\n\t\t\t\treturn ret;\n\t\t}\n\t} else if (ctxt->mode == X86EMUL_MODE_PROT64) {\n\t\tret = ctxt->ops->read_std(ctxt, desc_addr+8, &base3,\n\t\t\t\tsizeof(base3), &ctxt->exception);\n\t\tif (ret != X86EMUL_CONTINUE)\n\t\t\treturn ret;\n\t\tif (is_noncanonical_address(get_desc_base(&seg_desc) |\n\t\t\t\t\t     ((u64)base3 << 32)))\n\t\t\treturn emulate_gp(ctxt, 0);\n\t}\nload:\n\tctxt->ops->set_segment(ctxt, selector, &seg_desc, base3, seg);\n\tif (desc)\n\t\t*desc = seg_desc;\n\treturn X86EMUL_CONTINUE;\nexception:\n\treturn emulate_exception(ctxt, err_vec, err_code, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ctxt->ops->cpl",
          "args": [
            "ctxt"
          ],
          "line": 1713
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int load_segment_descriptor(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t   u16 selector, int seg)\n{\n\tu8 cpl = ctxt->ops->cpl(ctxt);\n\treturn __load_segment_descriptor(ctxt, selector, seg, cpl,\n\t\t\t\t\t X86_TRANSFER_NONE, NULL);\n}"
  },
  {
    "function_name": "__load_segment_descriptor",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "1549-1708",
    "snippet": "static int __load_segment_descriptor(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t     u16 selector, int seg, u8 cpl,\n\t\t\t\t     enum x86_transfer_type transfer,\n\t\t\t\t     struct desc_struct *desc)\n{\n\tstruct desc_struct seg_desc, old_desc;\n\tu8 dpl, rpl;\n\tunsigned err_vec = GP_VECTOR;\n\tu32 err_code = 0;\n\tbool null_selector = !(selector & ~0x3); /* 0000-0003 are null */\n\tulong desc_addr;\n\tint ret;\n\tu16 dummy;\n\tu32 base3 = 0;\n\n\tmemset(&seg_desc, 0, sizeof seg_desc);\n\n\tif (ctxt->mode == X86EMUL_MODE_REAL) {\n\t\t/* set real mode segment descriptor (keep limit etc. for\n\t\t * unreal mode) */\n\t\tctxt->ops->get_segment(ctxt, &dummy, &seg_desc, NULL, seg);\n\t\tset_desc_base(&seg_desc, selector << 4);\n\t\tgoto load;\n\t} else if (seg <= VCPU_SREG_GS && ctxt->mode == X86EMUL_MODE_VM86) {\n\t\t/* VM86 needs a clean new segment descriptor */\n\t\tset_desc_base(&seg_desc, selector << 4);\n\t\tset_desc_limit(&seg_desc, 0xffff);\n\t\tseg_desc.type = 3;\n\t\tseg_desc.p = 1;\n\t\tseg_desc.s = 1;\n\t\tseg_desc.dpl = 3;\n\t\tgoto load;\n\t}\n\n\trpl = selector & 3;\n\n\t/* NULL selector is not valid for TR, CS and SS (except for long mode) */\n\tif ((seg == VCPU_SREG_CS\n\t     || (seg == VCPU_SREG_SS\n\t\t && (ctxt->mode != X86EMUL_MODE_PROT64 || rpl != cpl))\n\t     || seg == VCPU_SREG_TR)\n\t    && null_selector)\n\t\tgoto exception;\n\n\t/* TR should be in GDT only */\n\tif (seg == VCPU_SREG_TR && (selector & (1 << 2)))\n\t\tgoto exception;\n\n\tif (null_selector) /* for NULL selector skip all following checks */\n\t\tgoto load;\n\n\tret = read_segment_descriptor(ctxt, selector, &seg_desc, &desc_addr);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\n\terr_code = selector & 0xfffc;\n\terr_vec = (transfer == X86_TRANSFER_TASK_SWITCH) ? TS_VECTOR :\n\t\t\t\t\t\t\t   GP_VECTOR;\n\n\t/* can't load system descriptor into segment selector */\n\tif (seg <= VCPU_SREG_GS && !seg_desc.s) {\n\t\tif (transfer == X86_TRANSFER_CALL_JMP)\n\t\t\treturn X86EMUL_UNHANDLEABLE;\n\t\tgoto exception;\n\t}\n\n\tif (!seg_desc.p) {\n\t\terr_vec = (seg == VCPU_SREG_SS) ? SS_VECTOR : NP_VECTOR;\n\t\tgoto exception;\n\t}\n\n\tdpl = seg_desc.dpl;\n\n\tswitch (seg) {\n\tcase VCPU_SREG_SS:\n\t\t/*\n\t\t * segment is not a writable data segment or segment\n\t\t * selector's RPL != CPL or segment selector's RPL != CPL\n\t\t */\n\t\tif (rpl != cpl || (seg_desc.type & 0xa) != 0x2 || dpl != cpl)\n\t\t\tgoto exception;\n\t\tbreak;\n\tcase VCPU_SREG_CS:\n\t\tif (!(seg_desc.type & 8))\n\t\t\tgoto exception;\n\n\t\tif (seg_desc.type & 4) {\n\t\t\t/* conforming */\n\t\t\tif (dpl > cpl)\n\t\t\t\tgoto exception;\n\t\t} else {\n\t\t\t/* nonconforming */\n\t\t\tif (rpl > cpl || dpl != cpl)\n\t\t\t\tgoto exception;\n\t\t}\n\t\t/* in long-mode d/b must be clear if l is set */\n\t\tif (seg_desc.d && seg_desc.l) {\n\t\t\tu64 efer = 0;\n\n\t\t\tctxt->ops->get_msr(ctxt, MSR_EFER, &efer);\n\t\t\tif (efer & EFER_LMA)\n\t\t\t\tgoto exception;\n\t\t}\n\n\t\t/* CS(RPL) <- CPL */\n\t\tselector = (selector & 0xfffc) | cpl;\n\t\tbreak;\n\tcase VCPU_SREG_TR:\n\t\tif (seg_desc.s || (seg_desc.type != 1 && seg_desc.type != 9))\n\t\t\tgoto exception;\n\t\told_desc = seg_desc;\n\t\tseg_desc.type |= 2; /* busy */\n\t\tret = ctxt->ops->cmpxchg_emulated(ctxt, desc_addr, &old_desc, &seg_desc,\n\t\t\t\t\t\t  sizeof(seg_desc), &ctxt->exception);\n\t\tif (ret != X86EMUL_CONTINUE)\n\t\t\treturn ret;\n\t\tbreak;\n\tcase VCPU_SREG_LDTR:\n\t\tif (seg_desc.s || seg_desc.type != 2)\n\t\t\tgoto exception;\n\t\tbreak;\n\tdefault: /*  DS, ES, FS, or GS */\n\t\t/*\n\t\t * segment is not a data or readable code segment or\n\t\t * ((segment is a data or nonconforming code segment)\n\t\t * and (both RPL and CPL > DPL))\n\t\t */\n\t\tif ((seg_desc.type & 0xa) == 0x8 ||\n\t\t    (((seg_desc.type & 0xc) != 0xc) &&\n\t\t     (rpl > dpl && cpl > dpl)))\n\t\t\tgoto exception;\n\t\tbreak;\n\t}\n\n\tif (seg_desc.s) {\n\t\t/* mark segment as accessed */\n\t\tif (!(seg_desc.type & 1)) {\n\t\t\tseg_desc.type |= 1;\n\t\t\tret = write_segment_descriptor(ctxt, selector,\n\t\t\t\t\t\t       &seg_desc);\n\t\t\tif (ret != X86EMUL_CONTINUE)\n\t\t\t\treturn ret;\n\t\t}\n\t} else if (ctxt->mode == X86EMUL_MODE_PROT64) {\n\t\tret = ctxt->ops->read_std(ctxt, desc_addr+8, &base3,\n\t\t\t\tsizeof(base3), &ctxt->exception);\n\t\tif (ret != X86EMUL_CONTINUE)\n\t\t\treturn ret;\n\t\tif (is_noncanonical_address(get_desc_base(&seg_desc) |\n\t\t\t\t\t     ((u64)base3 << 32)))\n\t\t\treturn emulate_gp(ctxt, 0);\n\t}\nload:\n\tctxt->ops->set_segment(ctxt, selector, &seg_desc, base3, seg);\n\tif (desc)\n\t\t*desc = seg_desc;\n\treturn X86EMUL_CONTINUE;\nexception:\n\treturn emulate_exception(ctxt, err_vec, err_code, true);\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "emulate_exception",
          "args": [
            "ctxt",
            "err_vec",
            "err_code",
            "true"
          ],
          "line": 1707
        },
        "resolved": true,
        "details": {
          "function_name": "emulate_exception",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "565-573",
          "snippet": "static int emulate_exception(struct x86_emulate_ctxt *ctxt, int vec,\n\t\t\t     u32 error, bool valid)\n{\n\tWARN_ON(vec > 0x1f);\n\tctxt->exception.vector = vec;\n\tctxt->exception.error_code = error;\n\tctxt->exception.error_code_valid = valid;\n\treturn X86EMUL_PROPAGATE_FAULT;\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int emulate_exception(struct x86_emulate_ctxt *ctxt, int vec,\n\t\t\t     u32 error, bool valid)\n{\n\tWARN_ON(vec > 0x1f);\n\tctxt->exception.vector = vec;\n\tctxt->exception.error_code = error;\n\tctxt->exception.error_code_valid = valid;\n\treturn X86EMUL_PROPAGATE_FAULT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ctxt->ops->set_segment",
          "args": [
            "ctxt",
            "selector",
            "&seg_desc",
            "base3",
            "seg"
          ],
          "line": 1702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "emulate_gp",
          "args": [
            "ctxt",
            "0"
          ],
          "line": 1699
        },
        "resolved": true,
        "details": {
          "function_name": "emulate_gp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "580-583",
          "snippet": "static int emulate_gp(struct x86_emulate_ctxt *ctxt, int err)\n{\n\treturn emulate_exception(ctxt, GP_VECTOR, err, true);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int emulate_gp(struct x86_emulate_ctxt *ctxt, int err)\n{\n\treturn emulate_exception(ctxt, GP_VECTOR, err, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_noncanonical_address",
          "args": [
            "get_desc_base(&seg_desc) |\n\t\t\t\t\t     ((u64)base3 << 32)"
          ],
          "line": 1697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_desc_base",
          "args": [
            "&seg_desc"
          ],
          "line": 1697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ctxt->ops->read_std",
          "args": [
            "ctxt",
            "desc_addr+8",
            "&base3",
            "sizeof(base3)",
            "&ctxt->exception"
          ],
          "line": 1693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_segment_descriptor",
          "args": [
            "ctxt",
            "selector",
            "&seg_desc"
          ],
          "line": 1687
        },
        "resolved": true,
        "details": {
          "function_name": "write_segment_descriptor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "1534-1546",
          "snippet": "static int write_segment_descriptor(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t    u16 selector, struct desc_struct *desc)\n{\n\tint rc;\n\tulong addr;\n\n\trc = get_descriptor_ptr(ctxt, selector, &addr);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\treturn ctxt->ops->write_std(ctxt, addr, desc, sizeof *desc,\n\t\t\t\t    &ctxt->exception);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int write_segment_descriptor(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t    u16 selector, struct desc_struct *desc)\n{\n\tint rc;\n\tulong addr;\n\n\trc = get_descriptor_ptr(ctxt, selector, &addr);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\treturn ctxt->ops->write_std(ctxt, addr, desc, sizeof *desc,\n\t\t\t\t    &ctxt->exception);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ctxt->ops->cmpxchg_emulated",
          "args": [
            "ctxt",
            "desc_addr",
            "&old_desc",
            "&seg_desc",
            "sizeof(seg_desc)",
            "&ctxt->exception"
          ],
          "line": 1661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ctxt->ops->get_msr",
          "args": [
            "ctxt",
            "MSR_EFER",
            "&efer"
          ],
          "line": 1648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_segment_descriptor",
          "args": [
            "ctxt",
            "selector",
            "&seg_desc",
            "&desc_addr"
          ],
          "line": 1600
        },
        "resolved": true,
        "details": {
          "function_name": "read_segment_descriptor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "1519-1531",
          "snippet": "static int read_segment_descriptor(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t   u16 selector, struct desc_struct *desc,\n\t\t\t\t   ulong *desc_addr_p)\n{\n\tint rc;\n\n\trc = get_descriptor_ptr(ctxt, selector, desc_addr_p);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\treturn ctxt->ops->read_std(ctxt, *desc_addr_p, desc, sizeof(*desc),\n\t\t\t\t   &ctxt->exception);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int read_segment_descriptor(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t   u16 selector, struct desc_struct *desc,\n\t\t\t\t   ulong *desc_addr_p)\n{\n\tint rc;\n\n\trc = get_descriptor_ptr(ctxt, selector, desc_addr_p);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\treturn ctxt->ops->read_std(ctxt, *desc_addr_p, desc, sizeof(*desc),\n\t\t\t\t   &ctxt->exception);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_desc_limit",
          "args": [
            "&seg_desc",
            "0xffff"
          ],
          "line": 1575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_desc_base",
          "args": [
            "&seg_desc",
            "selector << 4"
          ],
          "line": 1574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_desc_base",
          "args": [
            "&seg_desc",
            "selector << 4"
          ],
          "line": 1570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ctxt->ops->get_segment",
          "args": [
            "ctxt",
            "&dummy",
            "&seg_desc",
            "NULL",
            "seg"
          ],
          "line": 1569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&seg_desc",
            "0",
            "sizeof seg_desc"
          ],
          "line": 1564
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int __load_segment_descriptor(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t     u16 selector, int seg, u8 cpl,\n\t\t\t\t     enum x86_transfer_type transfer,\n\t\t\t\t     struct desc_struct *desc)\n{\n\tstruct desc_struct seg_desc, old_desc;\n\tu8 dpl, rpl;\n\tunsigned err_vec = GP_VECTOR;\n\tu32 err_code = 0;\n\tbool null_selector = !(selector & ~0x3); /* 0000-0003 are null */\n\tulong desc_addr;\n\tint ret;\n\tu16 dummy;\n\tu32 base3 = 0;\n\n\tmemset(&seg_desc, 0, sizeof seg_desc);\n\n\tif (ctxt->mode == X86EMUL_MODE_REAL) {\n\t\t/* set real mode segment descriptor (keep limit etc. for\n\t\t * unreal mode) */\n\t\tctxt->ops->get_segment(ctxt, &dummy, &seg_desc, NULL, seg);\n\t\tset_desc_base(&seg_desc, selector << 4);\n\t\tgoto load;\n\t} else if (seg <= VCPU_SREG_GS && ctxt->mode == X86EMUL_MODE_VM86) {\n\t\t/* VM86 needs a clean new segment descriptor */\n\t\tset_desc_base(&seg_desc, selector << 4);\n\t\tset_desc_limit(&seg_desc, 0xffff);\n\t\tseg_desc.type = 3;\n\t\tseg_desc.p = 1;\n\t\tseg_desc.s = 1;\n\t\tseg_desc.dpl = 3;\n\t\tgoto load;\n\t}\n\n\trpl = selector & 3;\n\n\t/* NULL selector is not valid for TR, CS and SS (except for long mode) */\n\tif ((seg == VCPU_SREG_CS\n\t     || (seg == VCPU_SREG_SS\n\t\t && (ctxt->mode != X86EMUL_MODE_PROT64 || rpl != cpl))\n\t     || seg == VCPU_SREG_TR)\n\t    && null_selector)\n\t\tgoto exception;\n\n\t/* TR should be in GDT only */\n\tif (seg == VCPU_SREG_TR && (selector & (1 << 2)))\n\t\tgoto exception;\n\n\tif (null_selector) /* for NULL selector skip all following checks */\n\t\tgoto load;\n\n\tret = read_segment_descriptor(ctxt, selector, &seg_desc, &desc_addr);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\n\terr_code = selector & 0xfffc;\n\terr_vec = (transfer == X86_TRANSFER_TASK_SWITCH) ? TS_VECTOR :\n\t\t\t\t\t\t\t   GP_VECTOR;\n\n\t/* can't load system descriptor into segment selector */\n\tif (seg <= VCPU_SREG_GS && !seg_desc.s) {\n\t\tif (transfer == X86_TRANSFER_CALL_JMP)\n\t\t\treturn X86EMUL_UNHANDLEABLE;\n\t\tgoto exception;\n\t}\n\n\tif (!seg_desc.p) {\n\t\terr_vec = (seg == VCPU_SREG_SS) ? SS_VECTOR : NP_VECTOR;\n\t\tgoto exception;\n\t}\n\n\tdpl = seg_desc.dpl;\n\n\tswitch (seg) {\n\tcase VCPU_SREG_SS:\n\t\t/*\n\t\t * segment is not a writable data segment or segment\n\t\t * selector's RPL != CPL or segment selector's RPL != CPL\n\t\t */\n\t\tif (rpl != cpl || (seg_desc.type & 0xa) != 0x2 || dpl != cpl)\n\t\t\tgoto exception;\n\t\tbreak;\n\tcase VCPU_SREG_CS:\n\t\tif (!(seg_desc.type & 8))\n\t\t\tgoto exception;\n\n\t\tif (seg_desc.type & 4) {\n\t\t\t/* conforming */\n\t\t\tif (dpl > cpl)\n\t\t\t\tgoto exception;\n\t\t} else {\n\t\t\t/* nonconforming */\n\t\t\tif (rpl > cpl || dpl != cpl)\n\t\t\t\tgoto exception;\n\t\t}\n\t\t/* in long-mode d/b must be clear if l is set */\n\t\tif (seg_desc.d && seg_desc.l) {\n\t\t\tu64 efer = 0;\n\n\t\t\tctxt->ops->get_msr(ctxt, MSR_EFER, &efer);\n\t\t\tif (efer & EFER_LMA)\n\t\t\t\tgoto exception;\n\t\t}\n\n\t\t/* CS(RPL) <- CPL */\n\t\tselector = (selector & 0xfffc) | cpl;\n\t\tbreak;\n\tcase VCPU_SREG_TR:\n\t\tif (seg_desc.s || (seg_desc.type != 1 && seg_desc.type != 9))\n\t\t\tgoto exception;\n\t\told_desc = seg_desc;\n\t\tseg_desc.type |= 2; /* busy */\n\t\tret = ctxt->ops->cmpxchg_emulated(ctxt, desc_addr, &old_desc, &seg_desc,\n\t\t\t\t\t\t  sizeof(seg_desc), &ctxt->exception);\n\t\tif (ret != X86EMUL_CONTINUE)\n\t\t\treturn ret;\n\t\tbreak;\n\tcase VCPU_SREG_LDTR:\n\t\tif (seg_desc.s || seg_desc.type != 2)\n\t\t\tgoto exception;\n\t\tbreak;\n\tdefault: /*  DS, ES, FS, or GS */\n\t\t/*\n\t\t * segment is not a data or readable code segment or\n\t\t * ((segment is a data or nonconforming code segment)\n\t\t * and (both RPL and CPL > DPL))\n\t\t */\n\t\tif ((seg_desc.type & 0xa) == 0x8 ||\n\t\t    (((seg_desc.type & 0xc) != 0xc) &&\n\t\t     (rpl > dpl && cpl > dpl)))\n\t\t\tgoto exception;\n\t\tbreak;\n\t}\n\n\tif (seg_desc.s) {\n\t\t/* mark segment as accessed */\n\t\tif (!(seg_desc.type & 1)) {\n\t\t\tseg_desc.type |= 1;\n\t\t\tret = write_segment_descriptor(ctxt, selector,\n\t\t\t\t\t\t       &seg_desc);\n\t\t\tif (ret != X86EMUL_CONTINUE)\n\t\t\t\treturn ret;\n\t\t}\n\t} else if (ctxt->mode == X86EMUL_MODE_PROT64) {\n\t\tret = ctxt->ops->read_std(ctxt, desc_addr+8, &base3,\n\t\t\t\tsizeof(base3), &ctxt->exception);\n\t\tif (ret != X86EMUL_CONTINUE)\n\t\t\treturn ret;\n\t\tif (is_noncanonical_address(get_desc_base(&seg_desc) |\n\t\t\t\t\t     ((u64)base3 << 32)))\n\t\t\treturn emulate_gp(ctxt, 0);\n\t}\nload:\n\tctxt->ops->set_segment(ctxt, selector, &seg_desc, base3, seg);\n\tif (desc)\n\t\t*desc = seg_desc;\n\treturn X86EMUL_CONTINUE;\nexception:\n\treturn emulate_exception(ctxt, err_vec, err_code, true);\n}"
  },
  {
    "function_name": "write_segment_descriptor",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "1534-1546",
    "snippet": "static int write_segment_descriptor(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t    u16 selector, struct desc_struct *desc)\n{\n\tint rc;\n\tulong addr;\n\n\trc = get_descriptor_ptr(ctxt, selector, &addr);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\treturn ctxt->ops->write_std(ctxt, addr, desc, sizeof *desc,\n\t\t\t\t    &ctxt->exception);\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ctxt->ops->write_std",
          "args": [
            "ctxt",
            "addr",
            "desc",
            "sizeof *desc",
            "&ctxt->exception"
          ],
          "line": 1544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_descriptor_ptr",
          "args": [
            "ctxt",
            "selector",
            "&addr"
          ],
          "line": 1540
        },
        "resolved": true,
        "details": {
          "function_name": "get_descriptor_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "1490-1516",
          "snippet": "static int get_descriptor_ptr(struct x86_emulate_ctxt *ctxt,\n\t\t\t      u16 selector, ulong *desc_addr_p)\n{\n\tstruct desc_ptr dt;\n\tu16 index = selector >> 3;\n\tulong addr;\n\n\tget_descriptor_table_ptr(ctxt, selector, &dt);\n\n\tif (dt.size < index * 8 + 7)\n\t\treturn emulate_gp(ctxt, selector & 0xfffc);\n\n\taddr = dt.address + index * 8;\n\n#ifdef CONFIG_X86_64\n\tif (addr >> 32 != 0) {\n\t\tu64 efer = 0;\n\n\t\tctxt->ops->get_msr(ctxt, MSR_EFER, &efer);\n\t\tif (!(efer & EFER_LMA))\n\t\t\taddr &= (u32)-1;\n\t}\n#endif\n\n\t*desc_addr_p = addr;\n\treturn X86EMUL_CONTINUE;\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int get_descriptor_ptr(struct x86_emulate_ctxt *ctxt,\n\t\t\t      u16 selector, ulong *desc_addr_p)\n{\n\tstruct desc_ptr dt;\n\tu16 index = selector >> 3;\n\tulong addr;\n\n\tget_descriptor_table_ptr(ctxt, selector, &dt);\n\n\tif (dt.size < index * 8 + 7)\n\t\treturn emulate_gp(ctxt, selector & 0xfffc);\n\n\taddr = dt.address + index * 8;\n\n#ifdef CONFIG_X86_64\n\tif (addr >> 32 != 0) {\n\t\tu64 efer = 0;\n\n\t\tctxt->ops->get_msr(ctxt, MSR_EFER, &efer);\n\t\tif (!(efer & EFER_LMA))\n\t\t\taddr &= (u32)-1;\n\t}\n#endif\n\n\t*desc_addr_p = addr;\n\treturn X86EMUL_CONTINUE;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int write_segment_descriptor(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t    u16 selector, struct desc_struct *desc)\n{\n\tint rc;\n\tulong addr;\n\n\trc = get_descriptor_ptr(ctxt, selector, &addr);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\treturn ctxt->ops->write_std(ctxt, addr, desc, sizeof *desc,\n\t\t\t\t    &ctxt->exception);\n}"
  },
  {
    "function_name": "read_segment_descriptor",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "1519-1531",
    "snippet": "static int read_segment_descriptor(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t   u16 selector, struct desc_struct *desc,\n\t\t\t\t   ulong *desc_addr_p)\n{\n\tint rc;\n\n\trc = get_descriptor_ptr(ctxt, selector, desc_addr_p);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\treturn ctxt->ops->read_std(ctxt, *desc_addr_p, desc, sizeof(*desc),\n\t\t\t\t   &ctxt->exception);\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ctxt->ops->read_std",
          "args": [
            "ctxt",
            "*desc_addr_p",
            "desc",
            "sizeof(*desc)",
            "&ctxt->exception"
          ],
          "line": 1529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_descriptor_ptr",
          "args": [
            "ctxt",
            "selector",
            "desc_addr_p"
          ],
          "line": 1525
        },
        "resolved": true,
        "details": {
          "function_name": "get_descriptor_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "1490-1516",
          "snippet": "static int get_descriptor_ptr(struct x86_emulate_ctxt *ctxt,\n\t\t\t      u16 selector, ulong *desc_addr_p)\n{\n\tstruct desc_ptr dt;\n\tu16 index = selector >> 3;\n\tulong addr;\n\n\tget_descriptor_table_ptr(ctxt, selector, &dt);\n\n\tif (dt.size < index * 8 + 7)\n\t\treturn emulate_gp(ctxt, selector & 0xfffc);\n\n\taddr = dt.address + index * 8;\n\n#ifdef CONFIG_X86_64\n\tif (addr >> 32 != 0) {\n\t\tu64 efer = 0;\n\n\t\tctxt->ops->get_msr(ctxt, MSR_EFER, &efer);\n\t\tif (!(efer & EFER_LMA))\n\t\t\taddr &= (u32)-1;\n\t}\n#endif\n\n\t*desc_addr_p = addr;\n\treturn X86EMUL_CONTINUE;\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int get_descriptor_ptr(struct x86_emulate_ctxt *ctxt,\n\t\t\t      u16 selector, ulong *desc_addr_p)\n{\n\tstruct desc_ptr dt;\n\tu16 index = selector >> 3;\n\tulong addr;\n\n\tget_descriptor_table_ptr(ctxt, selector, &dt);\n\n\tif (dt.size < index * 8 + 7)\n\t\treturn emulate_gp(ctxt, selector & 0xfffc);\n\n\taddr = dt.address + index * 8;\n\n#ifdef CONFIG_X86_64\n\tif (addr >> 32 != 0) {\n\t\tu64 efer = 0;\n\n\t\tctxt->ops->get_msr(ctxt, MSR_EFER, &efer);\n\t\tif (!(efer & EFER_LMA))\n\t\t\taddr &= (u32)-1;\n\t}\n#endif\n\n\t*desc_addr_p = addr;\n\treturn X86EMUL_CONTINUE;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int read_segment_descriptor(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t   u16 selector, struct desc_struct *desc,\n\t\t\t\t   ulong *desc_addr_p)\n{\n\tint rc;\n\n\trc = get_descriptor_ptr(ctxt, selector, desc_addr_p);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\treturn ctxt->ops->read_std(ctxt, *desc_addr_p, desc, sizeof(*desc),\n\t\t\t\t   &ctxt->exception);\n}"
  },
  {
    "function_name": "get_descriptor_ptr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "1490-1516",
    "snippet": "static int get_descriptor_ptr(struct x86_emulate_ctxt *ctxt,\n\t\t\t      u16 selector, ulong *desc_addr_p)\n{\n\tstruct desc_ptr dt;\n\tu16 index = selector >> 3;\n\tulong addr;\n\n\tget_descriptor_table_ptr(ctxt, selector, &dt);\n\n\tif (dt.size < index * 8 + 7)\n\t\treturn emulate_gp(ctxt, selector & 0xfffc);\n\n\taddr = dt.address + index * 8;\n\n#ifdef CONFIG_X86_64\n\tif (addr >> 32 != 0) {\n\t\tu64 efer = 0;\n\n\t\tctxt->ops->get_msr(ctxt, MSR_EFER, &efer);\n\t\tif (!(efer & EFER_LMA))\n\t\t\taddr &= (u32)-1;\n\t}\n#endif\n\n\t*desc_addr_p = addr;\n\treturn X86EMUL_CONTINUE;\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ctxt->ops->get_msr",
          "args": [
            "ctxt",
            "MSR_EFER",
            "&efer"
          ],
          "line": 1508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "emulate_gp",
          "args": [
            "ctxt",
            "selector & 0xfffc"
          ],
          "line": 1500
        },
        "resolved": true,
        "details": {
          "function_name": "emulate_gp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "580-583",
          "snippet": "static int emulate_gp(struct x86_emulate_ctxt *ctxt, int err)\n{\n\treturn emulate_exception(ctxt, GP_VECTOR, err, true);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int emulate_gp(struct x86_emulate_ctxt *ctxt, int err)\n{\n\treturn emulate_exception(ctxt, GP_VECTOR, err, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_descriptor_table_ptr",
          "args": [
            "ctxt",
            "selector",
            "&dt"
          ],
          "line": 1497
        },
        "resolved": true,
        "details": {
          "function_name": "get_descriptor_table_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "1469-1488",
          "snippet": "static void get_descriptor_table_ptr(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t     u16 selector, struct desc_ptr *dt)\n{\n\tconst struct x86_emulate_ops *ops = ctxt->ops;\n\tu32 base3 = 0;\n\n\tif (selector & 1 << 2) {\n\t\tstruct desc_struct desc;\n\t\tu16 sel;\n\n\t\tmemset (dt, 0, sizeof *dt);\n\t\tif (!ops->get_segment(ctxt, &sel, &desc, &base3,\n\t\t\t\t      VCPU_SREG_LDTR))\n\t\t\treturn;\n\n\t\tdt->size = desc_limit_scaled(&desc); /* what if limit > 65535? */\n\t\tdt->address = get_desc_base(&desc) | ((u64)base3 << 32);\n\t} else\n\t\tops->get_gdt(ctxt, dt);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic void get_descriptor_table_ptr(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t     u16 selector, struct desc_ptr *dt)\n{\n\tconst struct x86_emulate_ops *ops = ctxt->ops;\n\tu32 base3 = 0;\n\n\tif (selector & 1 << 2) {\n\t\tstruct desc_struct desc;\n\t\tu16 sel;\n\n\t\tmemset (dt, 0, sizeof *dt);\n\t\tif (!ops->get_segment(ctxt, &sel, &desc, &base3,\n\t\t\t\t      VCPU_SREG_LDTR))\n\t\t\treturn;\n\n\t\tdt->size = desc_limit_scaled(&desc); /* what if limit > 65535? */\n\t\tdt->address = get_desc_base(&desc) | ((u64)base3 << 32);\n\t} else\n\t\tops->get_gdt(ctxt, dt);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int get_descriptor_ptr(struct x86_emulate_ctxt *ctxt,\n\t\t\t      u16 selector, ulong *desc_addr_p)\n{\n\tstruct desc_ptr dt;\n\tu16 index = selector >> 3;\n\tulong addr;\n\n\tget_descriptor_table_ptr(ctxt, selector, &dt);\n\n\tif (dt.size < index * 8 + 7)\n\t\treturn emulate_gp(ctxt, selector & 0xfffc);\n\n\taddr = dt.address + index * 8;\n\n#ifdef CONFIG_X86_64\n\tif (addr >> 32 != 0) {\n\t\tu64 efer = 0;\n\n\t\tctxt->ops->get_msr(ctxt, MSR_EFER, &efer);\n\t\tif (!(efer & EFER_LMA))\n\t\t\taddr &= (u32)-1;\n\t}\n#endif\n\n\t*desc_addr_p = addr;\n\treturn X86EMUL_CONTINUE;\n}"
  },
  {
    "function_name": "get_descriptor_table_ptr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "1469-1488",
    "snippet": "static void get_descriptor_table_ptr(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t     u16 selector, struct desc_ptr *dt)\n{\n\tconst struct x86_emulate_ops *ops = ctxt->ops;\n\tu32 base3 = 0;\n\n\tif (selector & 1 << 2) {\n\t\tstruct desc_struct desc;\n\t\tu16 sel;\n\n\t\tmemset (dt, 0, sizeof *dt);\n\t\tif (!ops->get_segment(ctxt, &sel, &desc, &base3,\n\t\t\t\t      VCPU_SREG_LDTR))\n\t\t\treturn;\n\n\t\tdt->size = desc_limit_scaled(&desc); /* what if limit > 65535? */\n\t\tdt->address = get_desc_base(&desc) | ((u64)base3 << 32);\n\t} else\n\t\tops->get_gdt(ctxt, dt);\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ops->get_gdt",
          "args": [
            "ctxt",
            "dt"
          ],
          "line": 1487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_desc_base",
          "args": [
            "&desc"
          ],
          "line": 1485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "desc_limit_scaled",
          "args": [
            "&desc"
          ],
          "line": 1484
        },
        "resolved": true,
        "details": {
          "function_name": "desc_limit_scaled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "550-555",
          "snippet": "static u32 desc_limit_scaled(struct desc_struct *desc)\n{\n\tu32 limit = get_desc_limit(desc);\n\n\treturn desc->g ? (limit << 12) | 0xfff : limit;\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic u32 desc_limit_scaled(struct desc_struct *desc)\n{\n\tu32 limit = get_desc_limit(desc);\n\n\treturn desc->g ? (limit << 12) | 0xfff : limit;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ops->get_segment",
          "args": [
            "ctxt",
            "&sel",
            "&desc",
            "&base3",
            "VCPU_SREG_LDTR"
          ],
          "line": 1480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "dt",
            "0",
            "sizeof *dt"
          ],
          "line": 1479
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic void get_descriptor_table_ptr(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t     u16 selector, struct desc_ptr *dt)\n{\n\tconst struct x86_emulate_ops *ops = ctxt->ops;\n\tu32 base3 = 0;\n\n\tif (selector & 1 << 2) {\n\t\tstruct desc_struct desc;\n\t\tu16 sel;\n\n\t\tmemset (dt, 0, sizeof *dt);\n\t\tif (!ops->get_segment(ctxt, &sel, &desc, &base3,\n\t\t\t\t      VCPU_SREG_LDTR))\n\t\t\treturn;\n\n\t\tdt->size = desc_limit_scaled(&desc); /* what if limit > 65535? */\n\t\tdt->address = get_desc_base(&desc) | ((u64)base3 << 32);\n\t} else\n\t\tops->get_gdt(ctxt, dt);\n}"
  },
  {
    "function_name": "read_interrupt_descriptor",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "1453-1467",
    "snippet": "static int read_interrupt_descriptor(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t     u16 index, struct desc_struct *desc)\n{\n\tstruct desc_ptr dt;\n\tulong addr;\n\n\tctxt->ops->get_idt(ctxt, &dt);\n\n\tif (dt.size < index * 8 + 7)\n\t\treturn emulate_gp(ctxt, index << 3 | 0x2);\n\n\taddr = dt.address + index * 8;\n\treturn ctxt->ops->read_std(ctxt, addr, desc, sizeof *desc,\n\t\t\t\t   &ctxt->exception);\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ctxt->ops->read_std",
          "args": [
            "ctxt",
            "addr",
            "desc",
            "sizeof *desc",
            "&ctxt->exception"
          ],
          "line": 1465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "emulate_gp",
          "args": [
            "ctxt",
            "index << 3 | 0x2"
          ],
          "line": 1462
        },
        "resolved": true,
        "details": {
          "function_name": "emulate_gp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "580-583",
          "snippet": "static int emulate_gp(struct x86_emulate_ctxt *ctxt, int err)\n{\n\treturn emulate_exception(ctxt, GP_VECTOR, err, true);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int emulate_gp(struct x86_emulate_ctxt *ctxt, int err)\n{\n\treturn emulate_exception(ctxt, GP_VECTOR, err, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ctxt->ops->get_idt",
          "args": [
            "ctxt",
            "&dt"
          ],
          "line": 1459
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int read_interrupt_descriptor(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t     u16 index, struct desc_struct *desc)\n{\n\tstruct desc_ptr dt;\n\tulong addr;\n\n\tctxt->ops->get_idt(ctxt, &dt);\n\n\tif (dt.size < index * 8 + 7)\n\t\treturn emulate_gp(ctxt, index << 3 | 0x2);\n\n\taddr = dt.address + index * 8;\n\treturn ctxt->ops->read_std(ctxt, addr, desc, sizeof *desc,\n\t\t\t\t   &ctxt->exception);\n}"
  },
  {
    "function_name": "pio_in_emulated",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "1418-1451",
    "snippet": "static int pio_in_emulated(struct x86_emulate_ctxt *ctxt,\n\t\t\t   unsigned int size, unsigned short port,\n\t\t\t   void *dest)\n{\n\tstruct read_cache *rc = &ctxt->io_read;\n\n\tif (rc->pos == rc->end) { /* refill pio read ahead */\n\t\tunsigned int in_page, n;\n\t\tunsigned int count = ctxt->rep_prefix ?\n\t\t\taddress_mask(ctxt, reg_read(ctxt, VCPU_REGS_RCX)) : 1;\n\t\tin_page = (ctxt->eflags & X86_EFLAGS_DF) ?\n\t\t\toffset_in_page(reg_read(ctxt, VCPU_REGS_RDI)) :\n\t\t\tPAGE_SIZE - offset_in_page(reg_read(ctxt, VCPU_REGS_RDI));\n\t\tn = min3(in_page, (unsigned int)sizeof(rc->data) / size, count);\n\t\tif (n == 0)\n\t\t\tn = 1;\n\t\trc->pos = rc->end = 0;\n\t\tif (!ctxt->ops->pio_in_emulated(ctxt, size, port, rc->data, n))\n\t\t\treturn 0;\n\t\trc->end = n * size;\n\t}\n\n\tif (ctxt->rep_prefix && (ctxt->d & String) &&\n\t    !(ctxt->eflags & X86_EFLAGS_DF)) {\n\t\tctxt->dst.data = rc->data + rc->pos;\n\t\tctxt->dst.type = OP_MEM_STR;\n\t\tctxt->dst.count = (rc->end - rc->pos) / size;\n\t\trc->pos = rc->end;\n\t} else {\n\t\tmemcpy(dest, rc->data + rc->pos, size);\n\t\trc->pos += size;\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define String      (1<<13)     /* String instruction (rep capable) */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dest",
            "rc->data + rc->pos",
            "size"
          ],
          "line": 1447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ctxt->ops->pio_in_emulated",
          "args": [
            "ctxt",
            "size",
            "port",
            "rc->data",
            "n"
          ],
          "line": 1435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min3",
          "args": [
            "in_page",
            "(unsigned int)sizeof(rc->data) / size",
            "count"
          ],
          "line": 1431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "offset_in_page",
          "args": [
            "reg_read(ctxt, VCPU_REGS_RDI)"
          ],
          "line": 1430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reg_read",
          "args": [
            "ctxt",
            "VCPU_REGS_RDI"
          ],
          "line": 1430
        },
        "resolved": true,
        "details": {
          "function_name": "reg_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "261-268",
          "snippet": "static ulong reg_read(struct x86_emulate_ctxt *ctxt, unsigned nr)\n{\n\tif (!(ctxt->regs_valid & (1 << nr))) {\n\t\tctxt->regs_valid |= 1 << nr;\n\t\tctxt->_regs[nr] = ctxt->ops->read_gpr(ctxt, nr);\n\t}\n\treturn ctxt->_regs[nr];\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic ulong reg_read(struct x86_emulate_ctxt *ctxt, unsigned nr)\n{\n\tif (!(ctxt->regs_valid & (1 << nr))) {\n\t\tctxt->regs_valid |= 1 << nr;\n\t\tctxt->_regs[nr] = ctxt->ops->read_gpr(ctxt, nr);\n\t}\n\treturn ctxt->_regs[nr];\n}"
        }
      },
      {
        "call_info": {
          "callee": "offset_in_page",
          "args": [
            "reg_read(ctxt, VCPU_REGS_RDI)"
          ],
          "line": 1429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "address_mask",
          "args": [
            "ctxt",
            "reg_read(ctxt, VCPU_REGS_RCX)"
          ],
          "line": 1427
        },
        "resolved": true,
        "details": {
          "function_name": "address_mask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "517-524",
          "snippet": "static inline unsigned long\naddress_mask(struct x86_emulate_ctxt *ctxt, unsigned long reg)\n{\n\tif (ctxt->ad_bytes == sizeof(unsigned long))\n\t\treturn reg;\n\telse\n\t\treturn reg & ad_mask(ctxt);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline unsigned long\naddress_mask(struct x86_emulate_ctxt *ctxt, unsigned long reg)\n{\n\tif (ctxt->ad_bytes == sizeof(unsigned long))\n\t\treturn reg;\n\telse\n\t\treturn reg & ad_mask(ctxt);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\n#define String      (1<<13)     /* String instruction (rep capable) */\n\nstatic int pio_in_emulated(struct x86_emulate_ctxt *ctxt,\n\t\t\t   unsigned int size, unsigned short port,\n\t\t\t   void *dest)\n{\n\tstruct read_cache *rc = &ctxt->io_read;\n\n\tif (rc->pos == rc->end) { /* refill pio read ahead */\n\t\tunsigned int in_page, n;\n\t\tunsigned int count = ctxt->rep_prefix ?\n\t\t\taddress_mask(ctxt, reg_read(ctxt, VCPU_REGS_RCX)) : 1;\n\t\tin_page = (ctxt->eflags & X86_EFLAGS_DF) ?\n\t\t\toffset_in_page(reg_read(ctxt, VCPU_REGS_RDI)) :\n\t\t\tPAGE_SIZE - offset_in_page(reg_read(ctxt, VCPU_REGS_RDI));\n\t\tn = min3(in_page, (unsigned int)sizeof(rc->data) / size, count);\n\t\tif (n == 0)\n\t\t\tn = 1;\n\t\trc->pos = rc->end = 0;\n\t\tif (!ctxt->ops->pio_in_emulated(ctxt, size, port, rc->data, n))\n\t\t\treturn 0;\n\t\trc->end = n * size;\n\t}\n\n\tif (ctxt->rep_prefix && (ctxt->d & String) &&\n\t    !(ctxt->eflags & X86_EFLAGS_DF)) {\n\t\tctxt->dst.data = rc->data + rc->pos;\n\t\tctxt->dst.type = OP_MEM_STR;\n\t\tctxt->dst.count = (rc->end - rc->pos) / size;\n\t\trc->pos = rc->end;\n\t} else {\n\t\tmemcpy(dest, rc->data + rc->pos, size);\n\t\trc->pos += size;\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "segmented_cmpxchg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "1403-1416",
    "snippet": "static int segmented_cmpxchg(struct x86_emulate_ctxt *ctxt,\n\t\t\t     struct segmented_address addr,\n\t\t\t     const void *orig_data, const void *data,\n\t\t\t     unsigned size)\n{\n\tint rc;\n\tulong linear;\n\n\trc = linearize(ctxt, addr, size, true, &linear);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\treturn ctxt->ops->cmpxchg_emulated(ctxt, linear, orig_data, data,\n\t\t\t\t\t   size, &ctxt->exception);\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ctxt->ops->cmpxchg_emulated",
          "args": [
            "ctxt",
            "linear",
            "orig_data",
            "data",
            "size",
            "&ctxt->exception"
          ],
          "line": 1414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "linearize",
          "args": [
            "ctxt",
            "addr",
            "size",
            "true",
            "&linear"
          ],
          "line": 1411
        },
        "resolved": true,
        "details": {
          "function_name": "linearize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "718-726",
          "snippet": "static int linearize(struct x86_emulate_ctxt *ctxt,\n\t\t     struct segmented_address addr,\n\t\t     unsigned size, bool write,\n\t\t     ulong *linear)\n{\n\tunsigned max_size;\n\treturn __linearize(ctxt, addr, &max_size, size, write, false,\n\t\t\t   ctxt->mode, linear);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int linearize(struct x86_emulate_ctxt *ctxt,\n\t\t     struct segmented_address addr,\n\t\t     unsigned size, bool write,\n\t\t     ulong *linear)\n{\n\tunsigned max_size;\n\treturn __linearize(ctxt, addr, &max_size, size, write, false,\n\t\t\t   ctxt->mode, linear);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int segmented_cmpxchg(struct x86_emulate_ctxt *ctxt,\n\t\t\t     struct segmented_address addr,\n\t\t\t     const void *orig_data, const void *data,\n\t\t\t     unsigned size)\n{\n\tint rc;\n\tulong linear;\n\n\trc = linearize(ctxt, addr, size, true, &linear);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\treturn ctxt->ops->cmpxchg_emulated(ctxt, linear, orig_data, data,\n\t\t\t\t\t   size, &ctxt->exception);\n}"
  },
  {
    "function_name": "segmented_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "1388-1401",
    "snippet": "static int segmented_write(struct x86_emulate_ctxt *ctxt,\n\t\t\t   struct segmented_address addr,\n\t\t\t   const void *data,\n\t\t\t   unsigned size)\n{\n\tint rc;\n\tulong linear;\n\n\trc = linearize(ctxt, addr, size, true, &linear);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\treturn ctxt->ops->write_emulated(ctxt, linear, data, size,\n\t\t\t\t\t &ctxt->exception);\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ctxt->ops->write_emulated",
          "args": [
            "ctxt",
            "linear",
            "data",
            "size",
            "&ctxt->exception"
          ],
          "line": 1399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "linearize",
          "args": [
            "ctxt",
            "addr",
            "size",
            "true",
            "&linear"
          ],
          "line": 1396
        },
        "resolved": true,
        "details": {
          "function_name": "linearize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "718-726",
          "snippet": "static int linearize(struct x86_emulate_ctxt *ctxt,\n\t\t     struct segmented_address addr,\n\t\t     unsigned size, bool write,\n\t\t     ulong *linear)\n{\n\tunsigned max_size;\n\treturn __linearize(ctxt, addr, &max_size, size, write, false,\n\t\t\t   ctxt->mode, linear);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int linearize(struct x86_emulate_ctxt *ctxt,\n\t\t     struct segmented_address addr,\n\t\t     unsigned size, bool write,\n\t\t     ulong *linear)\n{\n\tunsigned max_size;\n\treturn __linearize(ctxt, addr, &max_size, size, write, false,\n\t\t\t   ctxt->mode, linear);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int segmented_write(struct x86_emulate_ctxt *ctxt,\n\t\t\t   struct segmented_address addr,\n\t\t\t   const void *data,\n\t\t\t   unsigned size)\n{\n\tint rc;\n\tulong linear;\n\n\trc = linearize(ctxt, addr, size, true, &linear);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\treturn ctxt->ops->write_emulated(ctxt, linear, data, size,\n\t\t\t\t\t &ctxt->exception);\n}"
  },
  {
    "function_name": "segmented_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "1374-1386",
    "snippet": "static int segmented_read(struct x86_emulate_ctxt *ctxt,\n\t\t\t  struct segmented_address addr,\n\t\t\t  void *data,\n\t\t\t  unsigned size)\n{\n\tint rc;\n\tulong linear;\n\n\trc = linearize(ctxt, addr, size, false, &linear);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\treturn read_emulated(ctxt, linear, data, size);\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_emulated",
          "args": [
            "ctxt",
            "linear",
            "data",
            "size"
          ],
          "line": 1385
        },
        "resolved": true,
        "details": {
          "function_name": "read_emulated",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "1350-1372",
          "snippet": "static int read_emulated(struct x86_emulate_ctxt *ctxt,\n\t\t\t unsigned long addr, void *dest, unsigned size)\n{\n\tint rc;\n\tstruct read_cache *mc = &ctxt->mem_read;\n\n\tif (mc->pos < mc->end)\n\t\tgoto read_cached;\n\n\tWARN_ON((mc->end + size) >= sizeof(mc->data));\n\n\trc = ctxt->ops->read_emulated(ctxt, addr, mc->data + mc->end, size,\n\t\t\t\t      &ctxt->exception);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\tmc->end += size;\n\nread_cached:\n\tmemcpy(dest, mc->data + mc->pos, size);\n\tmc->pos += size;\n\treturn X86EMUL_CONTINUE;\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int read_emulated(struct x86_emulate_ctxt *ctxt,\n\t\t\t unsigned long addr, void *dest, unsigned size)\n{\n\tint rc;\n\tstruct read_cache *mc = &ctxt->mem_read;\n\n\tif (mc->pos < mc->end)\n\t\tgoto read_cached;\n\n\tWARN_ON((mc->end + size) >= sizeof(mc->data));\n\n\trc = ctxt->ops->read_emulated(ctxt, addr, mc->data + mc->end, size,\n\t\t\t\t      &ctxt->exception);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\tmc->end += size;\n\nread_cached:\n\tmemcpy(dest, mc->data + mc->pos, size);\n\tmc->pos += size;\n\treturn X86EMUL_CONTINUE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "linearize",
          "args": [
            "ctxt",
            "addr",
            "size",
            "false",
            "&linear"
          ],
          "line": 1382
        },
        "resolved": true,
        "details": {
          "function_name": "linearize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "718-726",
          "snippet": "static int linearize(struct x86_emulate_ctxt *ctxt,\n\t\t     struct segmented_address addr,\n\t\t     unsigned size, bool write,\n\t\t     ulong *linear)\n{\n\tunsigned max_size;\n\treturn __linearize(ctxt, addr, &max_size, size, write, false,\n\t\t\t   ctxt->mode, linear);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int linearize(struct x86_emulate_ctxt *ctxt,\n\t\t     struct segmented_address addr,\n\t\t     unsigned size, bool write,\n\t\t     ulong *linear)\n{\n\tunsigned max_size;\n\treturn __linearize(ctxt, addr, &max_size, size, write, false,\n\t\t\t   ctxt->mode, linear);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int segmented_read(struct x86_emulate_ctxt *ctxt,\n\t\t\t  struct segmented_address addr,\n\t\t\t  void *data,\n\t\t\t  unsigned size)\n{\n\tint rc;\n\tulong linear;\n\n\trc = linearize(ctxt, addr, size, false, &linear);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\treturn read_emulated(ctxt, linear, data, size);\n}"
  },
  {
    "function_name": "read_emulated",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "1350-1372",
    "snippet": "static int read_emulated(struct x86_emulate_ctxt *ctxt,\n\t\t\t unsigned long addr, void *dest, unsigned size)\n{\n\tint rc;\n\tstruct read_cache *mc = &ctxt->mem_read;\n\n\tif (mc->pos < mc->end)\n\t\tgoto read_cached;\n\n\tWARN_ON((mc->end + size) >= sizeof(mc->data));\n\n\trc = ctxt->ops->read_emulated(ctxt, addr, mc->data + mc->end, size,\n\t\t\t\t      &ctxt->exception);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\tmc->end += size;\n\nread_cached:\n\tmemcpy(dest, mc->data + mc->pos, size);\n\tmc->pos += size;\n\treturn X86EMUL_CONTINUE;\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dest",
            "mc->data + mc->pos",
            "size"
          ],
          "line": 1369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ctxt->ops->read_emulated",
          "args": [
            "ctxt",
            "addr",
            "mc->data + mc->end",
            "size",
            "&ctxt->exception"
          ],
          "line": 1361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "(mc->end + size) >= sizeof(mc->data)"
          ],
          "line": 1359
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int read_emulated(struct x86_emulate_ctxt *ctxt,\n\t\t\t unsigned long addr, void *dest, unsigned size)\n{\n\tint rc;\n\tstruct read_cache *mc = &ctxt->mem_read;\n\n\tif (mc->pos < mc->end)\n\t\tgoto read_cached;\n\n\tWARN_ON((mc->end + size) >= sizeof(mc->data));\n\n\trc = ctxt->ops->read_emulated(ctxt, addr, mc->data + mc->end, size,\n\t\t\t\t      &ctxt->exception);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\tmc->end += size;\n\nread_cached:\n\tmemcpy(dest, mc->data + mc->pos, size);\n\tmc->pos += size;\n\treturn X86EMUL_CONTINUE;\n}"
  },
  {
    "function_name": "fetch_bit_operand",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "1328-1348",
    "snippet": "static void fetch_bit_operand(struct x86_emulate_ctxt *ctxt)\n{\n\tlong sv = 0, mask;\n\n\tif (ctxt->dst.type == OP_MEM && ctxt->src.type == OP_REG) {\n\t\tmask = ~((long)ctxt->dst.bytes * 8 - 1);\n\n\t\tif (ctxt->src.bytes == 2)\n\t\t\tsv = (s16)ctxt->src.val & (s16)mask;\n\t\telse if (ctxt->src.bytes == 4)\n\t\t\tsv = (s32)ctxt->src.val & (s32)mask;\n\t\telse\n\t\t\tsv = (s64)ctxt->src.val & (s64)mask;\n\n\t\tctxt->dst.addr.mem.ea = address_mask(ctxt,\n\t\t\t\t\t   ctxt->dst.addr.mem.ea + (sv >> 3));\n\t}\n\n\t/* only subword offset */\n\tctxt->src.val &= (ctxt->dst.bytes << 3) - 1;\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "address_mask",
          "args": [
            "ctxt",
            "ctxt->dst.addr.mem.ea + (sv >> 3)"
          ],
          "line": 1342
        },
        "resolved": true,
        "details": {
          "function_name": "address_mask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "517-524",
          "snippet": "static inline unsigned long\naddress_mask(struct x86_emulate_ctxt *ctxt, unsigned long reg)\n{\n\tif (ctxt->ad_bytes == sizeof(unsigned long))\n\t\treturn reg;\n\telse\n\t\treturn reg & ad_mask(ctxt);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline unsigned long\naddress_mask(struct x86_emulate_ctxt *ctxt, unsigned long reg)\n{\n\tif (ctxt->ad_bytes == sizeof(unsigned long))\n\t\treturn reg;\n\telse\n\t\treturn reg & ad_mask(ctxt);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic void fetch_bit_operand(struct x86_emulate_ctxt *ctxt)\n{\n\tlong sv = 0, mask;\n\n\tif (ctxt->dst.type == OP_MEM && ctxt->src.type == OP_REG) {\n\t\tmask = ~((long)ctxt->dst.bytes * 8 - 1);\n\n\t\tif (ctxt->src.bytes == 2)\n\t\t\tsv = (s16)ctxt->src.val & (s16)mask;\n\t\telse if (ctxt->src.bytes == 4)\n\t\t\tsv = (s32)ctxt->src.val & (s32)mask;\n\t\telse\n\t\t\tsv = (s64)ctxt->src.val & (s64)mask;\n\n\t\tctxt->dst.addr.mem.ea = address_mask(ctxt,\n\t\t\t\t\t   ctxt->dst.addr.mem.ea + (sv >> 3));\n\t}\n\n\t/* only subword offset */\n\tctxt->src.val &= (ctxt->dst.bytes << 3) - 1;\n}"
  },
  {
    "function_name": "decode_abs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "1307-1326",
    "snippet": "static int decode_abs(struct x86_emulate_ctxt *ctxt,\n\t\t      struct operand *op)\n{\n\tint rc = X86EMUL_CONTINUE;\n\n\top->type = OP_MEM;\n\tswitch (ctxt->ad_bytes) {\n\tcase 2:\n\t\top->addr.mem.ea = insn_fetch(u16, ctxt);\n\t\tbreak;\n\tcase 4:\n\t\top->addr.mem.ea = insn_fetch(u32, ctxt);\n\t\tbreak;\n\tcase 8:\n\t\top->addr.mem.ea = insn_fetch(u64, ctxt);\n\t\tbreak;\n\t}\ndone:\n\treturn rc;\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "insn_fetch",
          "args": [
            "u64",
            "ctxt"
          ],
          "line": 1321
        },
        "resolved": true,
        "details": {
          "function_name": "do_insn_fetch_bytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "843-852",
          "snippet": "static __always_inline int do_insn_fetch_bytes(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t\t       unsigned size)\n{\n\tunsigned done_size = ctxt->fetch.end - ctxt->fetch.ptr;\n\n\tif (unlikely(done_size < size))\n\t\treturn __do_insn_fetch_bytes(ctxt, size - done_size);\n\telse\n\t\treturn X86EMUL_CONTINUE;\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic __always_inline int do_insn_fetch_bytes(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t\t       unsigned size)\n{\n\tunsigned done_size = ctxt->fetch.end - ctxt->fetch.ptr;\n\n\tif (unlikely(done_size < size))\n\t\treturn __do_insn_fetch_bytes(ctxt, size - done_size);\n\telse\n\t\treturn X86EMUL_CONTINUE;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int decode_abs(struct x86_emulate_ctxt *ctxt,\n\t\t      struct operand *op)\n{\n\tint rc = X86EMUL_CONTINUE;\n\n\top->type = OP_MEM;\n\tswitch (ctxt->ad_bytes) {\n\tcase 2:\n\t\top->addr.mem.ea = insn_fetch(u16, ctxt);\n\t\tbreak;\n\tcase 4:\n\t\top->addr.mem.ea = insn_fetch(u32, ctxt);\n\t\tbreak;\n\tcase 8:\n\t\top->addr.mem.ea = insn_fetch(u64, ctxt);\n\t\tbreak;\n\t}\ndone:\n\treturn rc;\n}"
  },
  {
    "function_name": "decode_modrm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "1170-1305",
    "snippet": "static int decode_modrm(struct x86_emulate_ctxt *ctxt,\n\t\t\tstruct operand *op)\n{\n\tu8 sib;\n\tint index_reg, base_reg, scale;\n\tint rc = X86EMUL_CONTINUE;\n\tulong modrm_ea = 0;\n\n\tctxt->modrm_reg = ((ctxt->rex_prefix << 1) & 8); /* REX.R */\n\tindex_reg = (ctxt->rex_prefix << 2) & 8; /* REX.X */\n\tbase_reg = (ctxt->rex_prefix << 3) & 8; /* REX.B */\n\n\tctxt->modrm_mod = (ctxt->modrm & 0xc0) >> 6;\n\tctxt->modrm_reg |= (ctxt->modrm & 0x38) >> 3;\n\tctxt->modrm_rm = base_reg | (ctxt->modrm & 0x07);\n\tctxt->modrm_seg = VCPU_SREG_DS;\n\n\tif (ctxt->modrm_mod == 3 || (ctxt->d & NoMod)) {\n\t\top->type = OP_REG;\n\t\top->bytes = (ctxt->d & ByteOp) ? 1 : ctxt->op_bytes;\n\t\top->addr.reg = decode_register(ctxt, ctxt->modrm_rm,\n\t\t\t\tctxt->d & ByteOp);\n\t\tif (ctxt->d & Sse) {\n\t\t\top->type = OP_XMM;\n\t\t\top->bytes = 16;\n\t\t\top->addr.xmm = ctxt->modrm_rm;\n\t\t\tread_sse_reg(ctxt, &op->vec_val, ctxt->modrm_rm);\n\t\t\treturn rc;\n\t\t}\n\t\tif (ctxt->d & Mmx) {\n\t\t\top->type = OP_MM;\n\t\t\top->bytes = 8;\n\t\t\top->addr.mm = ctxt->modrm_rm & 7;\n\t\t\treturn rc;\n\t\t}\n\t\tfetch_register_operand(op);\n\t\treturn rc;\n\t}\n\n\top->type = OP_MEM;\n\n\tif (ctxt->ad_bytes == 2) {\n\t\tunsigned bx = reg_read(ctxt, VCPU_REGS_RBX);\n\t\tunsigned bp = reg_read(ctxt, VCPU_REGS_RBP);\n\t\tunsigned si = reg_read(ctxt, VCPU_REGS_RSI);\n\t\tunsigned di = reg_read(ctxt, VCPU_REGS_RDI);\n\n\t\t/* 16-bit ModR/M decode. */\n\t\tswitch (ctxt->modrm_mod) {\n\t\tcase 0:\n\t\t\tif (ctxt->modrm_rm == 6)\n\t\t\t\tmodrm_ea += insn_fetch(u16, ctxt);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tmodrm_ea += insn_fetch(s8, ctxt);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tmodrm_ea += insn_fetch(u16, ctxt);\n\t\t\tbreak;\n\t\t}\n\t\tswitch (ctxt->modrm_rm) {\n\t\tcase 0:\n\t\t\tmodrm_ea += bx + si;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tmodrm_ea += bx + di;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tmodrm_ea += bp + si;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tmodrm_ea += bp + di;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tmodrm_ea += si;\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tmodrm_ea += di;\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\tif (ctxt->modrm_mod != 0)\n\t\t\t\tmodrm_ea += bp;\n\t\t\tbreak;\n\t\tcase 7:\n\t\t\tmodrm_ea += bx;\n\t\t\tbreak;\n\t\t}\n\t\tif (ctxt->modrm_rm == 2 || ctxt->modrm_rm == 3 ||\n\t\t    (ctxt->modrm_rm == 6 && ctxt->modrm_mod != 0))\n\t\t\tctxt->modrm_seg = VCPU_SREG_SS;\n\t\tmodrm_ea = (u16)modrm_ea;\n\t} else {\n\t\t/* 32/64-bit ModR/M decode. */\n\t\tif ((ctxt->modrm_rm & 7) == 4) {\n\t\t\tsib = insn_fetch(u8, ctxt);\n\t\t\tindex_reg |= (sib >> 3) & 7;\n\t\t\tbase_reg |= sib & 7;\n\t\t\tscale = sib >> 6;\n\n\t\t\tif ((base_reg & 7) == 5 && ctxt->modrm_mod == 0)\n\t\t\t\tmodrm_ea += insn_fetch(s32, ctxt);\n\t\t\telse {\n\t\t\t\tmodrm_ea += reg_read(ctxt, base_reg);\n\t\t\t\tadjust_modrm_seg(ctxt, base_reg);\n\t\t\t\t/* Increment ESP on POP [ESP] */\n\t\t\t\tif ((ctxt->d & IncSP) &&\n\t\t\t\t    base_reg == VCPU_REGS_RSP)\n\t\t\t\t\tmodrm_ea += ctxt->op_bytes;\n\t\t\t}\n\t\t\tif (index_reg != 4)\n\t\t\t\tmodrm_ea += reg_read(ctxt, index_reg) << scale;\n\t\t} else if ((ctxt->modrm_rm & 7) == 5 && ctxt->modrm_mod == 0) {\n\t\t\tmodrm_ea += insn_fetch(s32, ctxt);\n\t\t\tif (ctxt->mode == X86EMUL_MODE_PROT64)\n\t\t\t\tctxt->rip_relative = 1;\n\t\t} else {\n\t\t\tbase_reg = ctxt->modrm_rm;\n\t\t\tmodrm_ea += reg_read(ctxt, base_reg);\n\t\t\tadjust_modrm_seg(ctxt, base_reg);\n\t\t}\n\t\tswitch (ctxt->modrm_mod) {\n\t\tcase 1:\n\t\t\tmodrm_ea += insn_fetch(s8, ctxt);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tmodrm_ea += insn_fetch(s32, ctxt);\n\t\t\tbreak;\n\t\t}\n\t}\n\top->addr.mem.ea = modrm_ea;\n\tif (ctxt->ad_bytes != 8)\n\t\tctxt->memop.addr.mem.ea = (u32)ctxt->memop.addr.mem.ea;\n\ndone:\n\treturn rc;\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define IncSP       ((u64)1 << 54)  /* SP is incremented before ModRM calc */",
      "#define NoMod\t    ((u64)1 << 47)  /* Mod field is ignored */",
      "#define Mmx         ((u64)1 << 40)  /* MMX Vector instruction */",
      "#define Sse         (1<<18)     /* SSE Vector instruction */",
      "#define ByteOp      (1<<0)\t/* 8-bit operands. */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "insn_fetch",
          "args": [
            "s32",
            "ctxt"
          ],
          "line": 1295
        },
        "resolved": true,
        "details": {
          "function_name": "do_insn_fetch_bytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "843-852",
          "snippet": "static __always_inline int do_insn_fetch_bytes(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t\t       unsigned size)\n{\n\tunsigned done_size = ctxt->fetch.end - ctxt->fetch.ptr;\n\n\tif (unlikely(done_size < size))\n\t\treturn __do_insn_fetch_bytes(ctxt, size - done_size);\n\telse\n\t\treturn X86EMUL_CONTINUE;\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic __always_inline int do_insn_fetch_bytes(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t\t       unsigned size)\n{\n\tunsigned done_size = ctxt->fetch.end - ctxt->fetch.ptr;\n\n\tif (unlikely(done_size < size))\n\t\treturn __do_insn_fetch_bytes(ctxt, size - done_size);\n\telse\n\t\treturn X86EMUL_CONTINUE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "adjust_modrm_seg",
          "args": [
            "ctxt",
            "base_reg"
          ],
          "line": 1288
        },
        "resolved": true,
        "details": {
          "function_name": "adjust_modrm_seg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "1164-1168",
          "snippet": "static void adjust_modrm_seg(struct x86_emulate_ctxt *ctxt, int base_reg)\n{\n\tif (base_reg == VCPU_REGS_RSP || base_reg == VCPU_REGS_RBP)\n\t\tctxt->modrm_seg = VCPU_SREG_SS;\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic void adjust_modrm_seg(struct x86_emulate_ctxt *ctxt, int base_reg)\n{\n\tif (base_reg == VCPU_REGS_RSP || base_reg == VCPU_REGS_RBP)\n\t\tctxt->modrm_seg = VCPU_SREG_SS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reg_read",
          "args": [
            "ctxt",
            "base_reg"
          ],
          "line": 1287
        },
        "resolved": true,
        "details": {
          "function_name": "reg_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "261-268",
          "snippet": "static ulong reg_read(struct x86_emulate_ctxt *ctxt, unsigned nr)\n{\n\tif (!(ctxt->regs_valid & (1 << nr))) {\n\t\tctxt->regs_valid |= 1 << nr;\n\t\tctxt->_regs[nr] = ctxt->ops->read_gpr(ctxt, nr);\n\t}\n\treturn ctxt->_regs[nr];\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic ulong reg_read(struct x86_emulate_ctxt *ctxt, unsigned nr)\n{\n\tif (!(ctxt->regs_valid & (1 << nr))) {\n\t\tctxt->regs_valid |= 1 << nr;\n\t\tctxt->_regs[nr] = ctxt->ops->read_gpr(ctxt, nr);\n\t}\n\treturn ctxt->_regs[nr];\n}"
        }
      },
      {
        "call_info": {
          "callee": "fetch_register_operand",
          "args": [
            "op"
          ],
          "line": 1205
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_register_operand",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "983-999",
          "snippet": "static void fetch_register_operand(struct operand *op)\n{\n\tswitch (op->bytes) {\n\tcase 1:\n\t\top->val = *(u8 *)op->addr.reg;\n\t\tbreak;\n\tcase 2:\n\t\top->val = *(u16 *)op->addr.reg;\n\t\tbreak;\n\tcase 4:\n\t\top->val = *(u32 *)op->addr.reg;\n\t\tbreak;\n\tcase 8:\n\t\top->val = *(u64 *)op->addr.reg;\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic void fetch_register_operand(struct operand *op)\n{\n\tswitch (op->bytes) {\n\tcase 1:\n\t\top->val = *(u8 *)op->addr.reg;\n\t\tbreak;\n\tcase 2:\n\t\top->val = *(u16 *)op->addr.reg;\n\t\tbreak;\n\tcase 4:\n\t\top->val = *(u32 *)op->addr.reg;\n\t\tbreak;\n\tcase 8:\n\t\top->val = *(u64 *)op->addr.reg;\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_sse_reg",
          "args": [
            "ctxt",
            "&op->vec_val",
            "ctxt->modrm_rm"
          ],
          "line": 1196
        },
        "resolved": true,
        "details": {
          "function_name": "read_sse_reg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "1001-1026",
          "snippet": "static void read_sse_reg(struct x86_emulate_ctxt *ctxt, sse128_t *data, int reg)\n{\n\tctxt->ops->get_fpu(ctxt);\n\tswitch (reg) {\n\tcase 0: asm(\"movdqa %%xmm0, %0\" : \"=m\"(*data)); break;\n\tcase 1: asm(\"movdqa %%xmm1, %0\" : \"=m\"(*data)); break;\n\tcase 2: asm(\"movdqa %%xmm2, %0\" : \"=m\"(*data)); break;\n\tcase 3: asm(\"movdqa %%xmm3, %0\" : \"=m\"(*data)); break;\n\tcase 4: asm(\"movdqa %%xmm4, %0\" : \"=m\"(*data)); break;\n\tcase 5: asm(\"movdqa %%xmm5, %0\" : \"=m\"(*data)); break;\n\tcase 6: asm(\"movdqa %%xmm6, %0\" : \"=m\"(*data)); break;\n\tcase 7: asm(\"movdqa %%xmm7, %0\" : \"=m\"(*data)); break;\n#ifdef CONFIG_X86_64\n\tcase 8: asm(\"movdqa %%xmm8, %0\" : \"=m\"(*data)); break;\n\tcase 9: asm(\"movdqa %%xmm9, %0\" : \"=m\"(*data)); break;\n\tcase 10: asm(\"movdqa %%xmm10, %0\" : \"=m\"(*data)); break;\n\tcase 11: asm(\"movdqa %%xmm11, %0\" : \"=m\"(*data)); break;\n\tcase 12: asm(\"movdqa %%xmm12, %0\" : \"=m\"(*data)); break;\n\tcase 13: asm(\"movdqa %%xmm13, %0\" : \"=m\"(*data)); break;\n\tcase 14: asm(\"movdqa %%xmm14, %0\" : \"=m\"(*data)); break;\n\tcase 15: asm(\"movdqa %%xmm15, %0\" : \"=m\"(*data)); break;\n#endif\n\tdefault: BUG();\n\t}\n\tctxt->ops->put_fpu(ctxt);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic void read_sse_reg(struct x86_emulate_ctxt *ctxt, sse128_t *data, int reg)\n{\n\tctxt->ops->get_fpu(ctxt);\n\tswitch (reg) {\n\tcase 0: asm(\"movdqa %%xmm0, %0\" : \"=m\"(*data)); break;\n\tcase 1: asm(\"movdqa %%xmm1, %0\" : \"=m\"(*data)); break;\n\tcase 2: asm(\"movdqa %%xmm2, %0\" : \"=m\"(*data)); break;\n\tcase 3: asm(\"movdqa %%xmm3, %0\" : \"=m\"(*data)); break;\n\tcase 4: asm(\"movdqa %%xmm4, %0\" : \"=m\"(*data)); break;\n\tcase 5: asm(\"movdqa %%xmm5, %0\" : \"=m\"(*data)); break;\n\tcase 6: asm(\"movdqa %%xmm6, %0\" : \"=m\"(*data)); break;\n\tcase 7: asm(\"movdqa %%xmm7, %0\" : \"=m\"(*data)); break;\n#ifdef CONFIG_X86_64\n\tcase 8: asm(\"movdqa %%xmm8, %0\" : \"=m\"(*data)); break;\n\tcase 9: asm(\"movdqa %%xmm9, %0\" : \"=m\"(*data)); break;\n\tcase 10: asm(\"movdqa %%xmm10, %0\" : \"=m\"(*data)); break;\n\tcase 11: asm(\"movdqa %%xmm11, %0\" : \"=m\"(*data)); break;\n\tcase 12: asm(\"movdqa %%xmm12, %0\" : \"=m\"(*data)); break;\n\tcase 13: asm(\"movdqa %%xmm13, %0\" : \"=m\"(*data)); break;\n\tcase 14: asm(\"movdqa %%xmm14, %0\" : \"=m\"(*data)); break;\n\tcase 15: asm(\"movdqa %%xmm15, %0\" : \"=m\"(*data)); break;\n#endif\n\tdefault: BUG();\n\t}\n\tctxt->ops->put_fpu(ctxt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "decode_register",
          "args": [
            "ctxt",
            "ctxt->modrm_rm",
            "ctxt->d & ByteOp"
          ],
          "line": 1190
        },
        "resolved": true,
        "details": {
          "function_name": "decode_register",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "882-893",
          "snippet": "static void *decode_register(struct x86_emulate_ctxt *ctxt, u8 modrm_reg,\n\t\t\t     int byteop)\n{\n\tvoid *p;\n\tint highbyte_regs = (ctxt->rex_prefix == 0) && byteop;\n\n\tif (highbyte_regs && modrm_reg >= 4 && modrm_reg < 8)\n\t\tp = (unsigned char *)reg_rmw(ctxt, modrm_reg & 3) + 1;\n\telse\n\t\tp = reg_rmw(ctxt, modrm_reg);\n\treturn p;\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic void *decode_register(struct x86_emulate_ctxt *ctxt, u8 modrm_reg,\n\t\t\t     int byteop)\n{\n\tvoid *p;\n\tint highbyte_regs = (ctxt->rex_prefix == 0) && byteop;\n\n\tif (highbyte_regs && modrm_reg >= 4 && modrm_reg < 8)\n\t\tp = (unsigned char *)reg_rmw(ctxt, modrm_reg & 3) + 1;\n\telse\n\t\tp = reg_rmw(ctxt, modrm_reg);\n\treturn p;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\n#define IncSP       ((u64)1 << 54)  /* SP is incremented before ModRM calc */\n#define NoMod\t    ((u64)1 << 47)  /* Mod field is ignored */\n#define Mmx         ((u64)1 << 40)  /* MMX Vector instruction */\n#define Sse         (1<<18)     /* SSE Vector instruction */\n#define ByteOp      (1<<0)\t/* 8-bit operands. */\n\nstatic int decode_modrm(struct x86_emulate_ctxt *ctxt,\n\t\t\tstruct operand *op)\n{\n\tu8 sib;\n\tint index_reg, base_reg, scale;\n\tint rc = X86EMUL_CONTINUE;\n\tulong modrm_ea = 0;\n\n\tctxt->modrm_reg = ((ctxt->rex_prefix << 1) & 8); /* REX.R */\n\tindex_reg = (ctxt->rex_prefix << 2) & 8; /* REX.X */\n\tbase_reg = (ctxt->rex_prefix << 3) & 8; /* REX.B */\n\n\tctxt->modrm_mod = (ctxt->modrm & 0xc0) >> 6;\n\tctxt->modrm_reg |= (ctxt->modrm & 0x38) >> 3;\n\tctxt->modrm_rm = base_reg | (ctxt->modrm & 0x07);\n\tctxt->modrm_seg = VCPU_SREG_DS;\n\n\tif (ctxt->modrm_mod == 3 || (ctxt->d & NoMod)) {\n\t\top->type = OP_REG;\n\t\top->bytes = (ctxt->d & ByteOp) ? 1 : ctxt->op_bytes;\n\t\top->addr.reg = decode_register(ctxt, ctxt->modrm_rm,\n\t\t\t\tctxt->d & ByteOp);\n\t\tif (ctxt->d & Sse) {\n\t\t\top->type = OP_XMM;\n\t\t\top->bytes = 16;\n\t\t\top->addr.xmm = ctxt->modrm_rm;\n\t\t\tread_sse_reg(ctxt, &op->vec_val, ctxt->modrm_rm);\n\t\t\treturn rc;\n\t\t}\n\t\tif (ctxt->d & Mmx) {\n\t\t\top->type = OP_MM;\n\t\t\top->bytes = 8;\n\t\t\top->addr.mm = ctxt->modrm_rm & 7;\n\t\t\treturn rc;\n\t\t}\n\t\tfetch_register_operand(op);\n\t\treturn rc;\n\t}\n\n\top->type = OP_MEM;\n\n\tif (ctxt->ad_bytes == 2) {\n\t\tunsigned bx = reg_read(ctxt, VCPU_REGS_RBX);\n\t\tunsigned bp = reg_read(ctxt, VCPU_REGS_RBP);\n\t\tunsigned si = reg_read(ctxt, VCPU_REGS_RSI);\n\t\tunsigned di = reg_read(ctxt, VCPU_REGS_RDI);\n\n\t\t/* 16-bit ModR/M decode. */\n\t\tswitch (ctxt->modrm_mod) {\n\t\tcase 0:\n\t\t\tif (ctxt->modrm_rm == 6)\n\t\t\t\tmodrm_ea += insn_fetch(u16, ctxt);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tmodrm_ea += insn_fetch(s8, ctxt);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tmodrm_ea += insn_fetch(u16, ctxt);\n\t\t\tbreak;\n\t\t}\n\t\tswitch (ctxt->modrm_rm) {\n\t\tcase 0:\n\t\t\tmodrm_ea += bx + si;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tmodrm_ea += bx + di;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tmodrm_ea += bp + si;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tmodrm_ea += bp + di;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tmodrm_ea += si;\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tmodrm_ea += di;\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\tif (ctxt->modrm_mod != 0)\n\t\t\t\tmodrm_ea += bp;\n\t\t\tbreak;\n\t\tcase 7:\n\t\t\tmodrm_ea += bx;\n\t\t\tbreak;\n\t\t}\n\t\tif (ctxt->modrm_rm == 2 || ctxt->modrm_rm == 3 ||\n\t\t    (ctxt->modrm_rm == 6 && ctxt->modrm_mod != 0))\n\t\t\tctxt->modrm_seg = VCPU_SREG_SS;\n\t\tmodrm_ea = (u16)modrm_ea;\n\t} else {\n\t\t/* 32/64-bit ModR/M decode. */\n\t\tif ((ctxt->modrm_rm & 7) == 4) {\n\t\t\tsib = insn_fetch(u8, ctxt);\n\t\t\tindex_reg |= (sib >> 3) & 7;\n\t\t\tbase_reg |= sib & 7;\n\t\t\tscale = sib >> 6;\n\n\t\t\tif ((base_reg & 7) == 5 && ctxt->modrm_mod == 0)\n\t\t\t\tmodrm_ea += insn_fetch(s32, ctxt);\n\t\t\telse {\n\t\t\t\tmodrm_ea += reg_read(ctxt, base_reg);\n\t\t\t\tadjust_modrm_seg(ctxt, base_reg);\n\t\t\t\t/* Increment ESP on POP [ESP] */\n\t\t\t\tif ((ctxt->d & IncSP) &&\n\t\t\t\t    base_reg == VCPU_REGS_RSP)\n\t\t\t\t\tmodrm_ea += ctxt->op_bytes;\n\t\t\t}\n\t\t\tif (index_reg != 4)\n\t\t\t\tmodrm_ea += reg_read(ctxt, index_reg) << scale;\n\t\t} else if ((ctxt->modrm_rm & 7) == 5 && ctxt->modrm_mod == 0) {\n\t\t\tmodrm_ea += insn_fetch(s32, ctxt);\n\t\t\tif (ctxt->mode == X86EMUL_MODE_PROT64)\n\t\t\t\tctxt->rip_relative = 1;\n\t\t} else {\n\t\t\tbase_reg = ctxt->modrm_rm;\n\t\t\tmodrm_ea += reg_read(ctxt, base_reg);\n\t\t\tadjust_modrm_seg(ctxt, base_reg);\n\t\t}\n\t\tswitch (ctxt->modrm_mod) {\n\t\tcase 1:\n\t\t\tmodrm_ea += insn_fetch(s8, ctxt);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tmodrm_ea += insn_fetch(s32, ctxt);\n\t\t\tbreak;\n\t\t}\n\t}\n\top->addr.mem.ea = modrm_ea;\n\tif (ctxt->ad_bytes != 8)\n\t\tctxt->memop.addr.mem.ea = (u32)ctxt->memop.addr.mem.ea;\n\ndone:\n\treturn rc;\n}"
  },
  {
    "function_name": "adjust_modrm_seg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "1164-1168",
    "snippet": "static void adjust_modrm_seg(struct x86_emulate_ctxt *ctxt, int base_reg)\n{\n\tif (base_reg == VCPU_REGS_RSP || base_reg == VCPU_REGS_RBP)\n\t\tctxt->modrm_seg = VCPU_SREG_SS;\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic void adjust_modrm_seg(struct x86_emulate_ctxt *ctxt, int base_reg)\n{\n\tif (base_reg == VCPU_REGS_RSP || base_reg == VCPU_REGS_RBP)\n\t\tctxt->modrm_seg = VCPU_SREG_SS;\n}"
  },
  {
    "function_name": "decode_register_operand",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "1133-1162",
    "snippet": "static void decode_register_operand(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t    struct operand *op)\n{\n\tunsigned reg = ctxt->modrm_reg;\n\n\tif (!(ctxt->d & ModRM))\n\t\treg = (ctxt->b & 7) | ((ctxt->rex_prefix & 1) << 3);\n\n\tif (ctxt->d & Sse) {\n\t\top->type = OP_XMM;\n\t\top->bytes = 16;\n\t\top->addr.xmm = reg;\n\t\tread_sse_reg(ctxt, &op->vec_val, reg);\n\t\treturn;\n\t}\n\tif (ctxt->d & Mmx) {\n\t\treg &= 7;\n\t\top->type = OP_MM;\n\t\top->bytes = 8;\n\t\top->addr.mm = reg;\n\t\treturn;\n\t}\n\n\top->type = OP_REG;\n\top->bytes = (ctxt->d & ByteOp) ? 1 : ctxt->op_bytes;\n\top->addr.reg = decode_register(ctxt, reg, ctxt->d & ByteOp);\n\n\tfetch_register_operand(op);\n\top->orig_val = op->val;\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define Mmx         ((u64)1 << 40)  /* MMX Vector instruction */",
      "#define ModRM       (1<<19)",
      "#define Sse         (1<<18)     /* SSE Vector instruction */",
      "#define ByteOp      (1<<0)\t/* 8-bit operands. */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fetch_register_operand",
          "args": [
            "op"
          ],
          "line": 1160
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_register_operand",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "983-999",
          "snippet": "static void fetch_register_operand(struct operand *op)\n{\n\tswitch (op->bytes) {\n\tcase 1:\n\t\top->val = *(u8 *)op->addr.reg;\n\t\tbreak;\n\tcase 2:\n\t\top->val = *(u16 *)op->addr.reg;\n\t\tbreak;\n\tcase 4:\n\t\top->val = *(u32 *)op->addr.reg;\n\t\tbreak;\n\tcase 8:\n\t\top->val = *(u64 *)op->addr.reg;\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic void fetch_register_operand(struct operand *op)\n{\n\tswitch (op->bytes) {\n\tcase 1:\n\t\top->val = *(u8 *)op->addr.reg;\n\t\tbreak;\n\tcase 2:\n\t\top->val = *(u16 *)op->addr.reg;\n\t\tbreak;\n\tcase 4:\n\t\top->val = *(u32 *)op->addr.reg;\n\t\tbreak;\n\tcase 8:\n\t\top->val = *(u64 *)op->addr.reg;\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "decode_register",
          "args": [
            "ctxt",
            "reg",
            "ctxt->d & ByteOp"
          ],
          "line": 1158
        },
        "resolved": true,
        "details": {
          "function_name": "decode_register",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "882-893",
          "snippet": "static void *decode_register(struct x86_emulate_ctxt *ctxt, u8 modrm_reg,\n\t\t\t     int byteop)\n{\n\tvoid *p;\n\tint highbyte_regs = (ctxt->rex_prefix == 0) && byteop;\n\n\tif (highbyte_regs && modrm_reg >= 4 && modrm_reg < 8)\n\t\tp = (unsigned char *)reg_rmw(ctxt, modrm_reg & 3) + 1;\n\telse\n\t\tp = reg_rmw(ctxt, modrm_reg);\n\treturn p;\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic void *decode_register(struct x86_emulate_ctxt *ctxt, u8 modrm_reg,\n\t\t\t     int byteop)\n{\n\tvoid *p;\n\tint highbyte_regs = (ctxt->rex_prefix == 0) && byteop;\n\n\tif (highbyte_regs && modrm_reg >= 4 && modrm_reg < 8)\n\t\tp = (unsigned char *)reg_rmw(ctxt, modrm_reg & 3) + 1;\n\telse\n\t\tp = reg_rmw(ctxt, modrm_reg);\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_sse_reg",
          "args": [
            "ctxt",
            "&op->vec_val",
            "reg"
          ],
          "line": 1145
        },
        "resolved": true,
        "details": {
          "function_name": "read_sse_reg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "1001-1026",
          "snippet": "static void read_sse_reg(struct x86_emulate_ctxt *ctxt, sse128_t *data, int reg)\n{\n\tctxt->ops->get_fpu(ctxt);\n\tswitch (reg) {\n\tcase 0: asm(\"movdqa %%xmm0, %0\" : \"=m\"(*data)); break;\n\tcase 1: asm(\"movdqa %%xmm1, %0\" : \"=m\"(*data)); break;\n\tcase 2: asm(\"movdqa %%xmm2, %0\" : \"=m\"(*data)); break;\n\tcase 3: asm(\"movdqa %%xmm3, %0\" : \"=m\"(*data)); break;\n\tcase 4: asm(\"movdqa %%xmm4, %0\" : \"=m\"(*data)); break;\n\tcase 5: asm(\"movdqa %%xmm5, %0\" : \"=m\"(*data)); break;\n\tcase 6: asm(\"movdqa %%xmm6, %0\" : \"=m\"(*data)); break;\n\tcase 7: asm(\"movdqa %%xmm7, %0\" : \"=m\"(*data)); break;\n#ifdef CONFIG_X86_64\n\tcase 8: asm(\"movdqa %%xmm8, %0\" : \"=m\"(*data)); break;\n\tcase 9: asm(\"movdqa %%xmm9, %0\" : \"=m\"(*data)); break;\n\tcase 10: asm(\"movdqa %%xmm10, %0\" : \"=m\"(*data)); break;\n\tcase 11: asm(\"movdqa %%xmm11, %0\" : \"=m\"(*data)); break;\n\tcase 12: asm(\"movdqa %%xmm12, %0\" : \"=m\"(*data)); break;\n\tcase 13: asm(\"movdqa %%xmm13, %0\" : \"=m\"(*data)); break;\n\tcase 14: asm(\"movdqa %%xmm14, %0\" : \"=m\"(*data)); break;\n\tcase 15: asm(\"movdqa %%xmm15, %0\" : \"=m\"(*data)); break;\n#endif\n\tdefault: BUG();\n\t}\n\tctxt->ops->put_fpu(ctxt);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic void read_sse_reg(struct x86_emulate_ctxt *ctxt, sse128_t *data, int reg)\n{\n\tctxt->ops->get_fpu(ctxt);\n\tswitch (reg) {\n\tcase 0: asm(\"movdqa %%xmm0, %0\" : \"=m\"(*data)); break;\n\tcase 1: asm(\"movdqa %%xmm1, %0\" : \"=m\"(*data)); break;\n\tcase 2: asm(\"movdqa %%xmm2, %0\" : \"=m\"(*data)); break;\n\tcase 3: asm(\"movdqa %%xmm3, %0\" : \"=m\"(*data)); break;\n\tcase 4: asm(\"movdqa %%xmm4, %0\" : \"=m\"(*data)); break;\n\tcase 5: asm(\"movdqa %%xmm5, %0\" : \"=m\"(*data)); break;\n\tcase 6: asm(\"movdqa %%xmm6, %0\" : \"=m\"(*data)); break;\n\tcase 7: asm(\"movdqa %%xmm7, %0\" : \"=m\"(*data)); break;\n#ifdef CONFIG_X86_64\n\tcase 8: asm(\"movdqa %%xmm8, %0\" : \"=m\"(*data)); break;\n\tcase 9: asm(\"movdqa %%xmm9, %0\" : \"=m\"(*data)); break;\n\tcase 10: asm(\"movdqa %%xmm10, %0\" : \"=m\"(*data)); break;\n\tcase 11: asm(\"movdqa %%xmm11, %0\" : \"=m\"(*data)); break;\n\tcase 12: asm(\"movdqa %%xmm12, %0\" : \"=m\"(*data)); break;\n\tcase 13: asm(\"movdqa %%xmm13, %0\" : \"=m\"(*data)); break;\n\tcase 14: asm(\"movdqa %%xmm14, %0\" : \"=m\"(*data)); break;\n\tcase 15: asm(\"movdqa %%xmm15, %0\" : \"=m\"(*data)); break;\n#endif\n\tdefault: BUG();\n\t}\n\tctxt->ops->put_fpu(ctxt);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\n#define Mmx         ((u64)1 << 40)  /* MMX Vector instruction */\n#define ModRM       (1<<19)\n#define Sse         (1<<18)     /* SSE Vector instruction */\n#define ByteOp      (1<<0)\t/* 8-bit operands. */\n\nstatic void decode_register_operand(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t    struct operand *op)\n{\n\tunsigned reg = ctxt->modrm_reg;\n\n\tif (!(ctxt->d & ModRM))\n\t\treg = (ctxt->b & 7) | ((ctxt->rex_prefix & 1) << 3);\n\n\tif (ctxt->d & Sse) {\n\t\top->type = OP_XMM;\n\t\top->bytes = 16;\n\t\top->addr.xmm = reg;\n\t\tread_sse_reg(ctxt, &op->vec_val, reg);\n\t\treturn;\n\t}\n\tif (ctxt->d & Mmx) {\n\t\treg &= 7;\n\t\top->type = OP_MM;\n\t\top->bytes = 8;\n\t\top->addr.mm = reg;\n\t\treturn;\n\t}\n\n\top->type = OP_REG;\n\top->bytes = (ctxt->d & ByteOp) ? 1 : ctxt->op_bytes;\n\top->addr.reg = decode_register(ctxt, reg, ctxt->d & ByteOp);\n\n\tfetch_register_operand(op);\n\top->orig_val = op->val;\n}"
  },
  {
    "function_name": "em_fnstsw",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "1117-1131",
    "snippet": "static int em_fnstsw(struct x86_emulate_ctxt *ctxt)\n{\n\tu16 fsw;\n\n\tif (ctxt->ops->get_cr(ctxt, 0) & (X86_CR0_TS | X86_CR0_EM))\n\t\treturn emulate_nm(ctxt);\n\n\tctxt->ops->get_fpu(ctxt);\n\tasm volatile(\"fnstsw %0\": \"+m\"(fsw));\n\tctxt->ops->put_fpu(ctxt);\n\n\tctxt->dst.val = fsw;\n\n\treturn X86EMUL_CONTINUE;\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ctxt->ops->put_fpu",
          "args": [
            "ctxt"
          ],
          "line": 1126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ctxt->ops->get_fpu",
          "args": [
            "ctxt"
          ],
          "line": 1124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "emulate_nm",
          "args": [
            "ctxt"
          ],
          "line": 1122
        },
        "resolved": true,
        "details": {
          "function_name": "emulate_nm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "605-608",
          "snippet": "static int emulate_nm(struct x86_emulate_ctxt *ctxt)\n{\n\treturn emulate_exception(ctxt, NM_VECTOR, 0, false);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int emulate_nm(struct x86_emulate_ctxt *ctxt)\n{\n\treturn emulate_exception(ctxt, NM_VECTOR, 0, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ctxt->ops->get_cr",
          "args": [
            "ctxt",
            "0"
          ],
          "line": 1121
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int em_fnstsw(struct x86_emulate_ctxt *ctxt)\n{\n\tu16 fsw;\n\n\tif (ctxt->ops->get_cr(ctxt, 0) & (X86_CR0_TS | X86_CR0_EM))\n\t\treturn emulate_nm(ctxt);\n\n\tctxt->ops->get_fpu(ctxt);\n\tasm volatile(\"fnstsw %0\": \"+m\"(fsw));\n\tctxt->ops->put_fpu(ctxt);\n\n\tctxt->dst.val = fsw;\n\n\treturn X86EMUL_CONTINUE;\n}"
  },
  {
    "function_name": "em_fnstcw",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "1101-1115",
    "snippet": "static int em_fnstcw(struct x86_emulate_ctxt *ctxt)\n{\n\tu16 fcw;\n\n\tif (ctxt->ops->get_cr(ctxt, 0) & (X86_CR0_TS | X86_CR0_EM))\n\t\treturn emulate_nm(ctxt);\n\n\tctxt->ops->get_fpu(ctxt);\n\tasm volatile(\"fnstcw %0\": \"+m\"(fcw));\n\tctxt->ops->put_fpu(ctxt);\n\n\tctxt->dst.val = fcw;\n\n\treturn X86EMUL_CONTINUE;\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ctxt->ops->put_fpu",
          "args": [
            "ctxt"
          ],
          "line": 1110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ctxt->ops->get_fpu",
          "args": [
            "ctxt"
          ],
          "line": 1108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "emulate_nm",
          "args": [
            "ctxt"
          ],
          "line": 1106
        },
        "resolved": true,
        "details": {
          "function_name": "emulate_nm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "605-608",
          "snippet": "static int emulate_nm(struct x86_emulate_ctxt *ctxt)\n{\n\treturn emulate_exception(ctxt, NM_VECTOR, 0, false);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int emulate_nm(struct x86_emulate_ctxt *ctxt)\n{\n\treturn emulate_exception(ctxt, NM_VECTOR, 0, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ctxt->ops->get_cr",
          "args": [
            "ctxt",
            "0"
          ],
          "line": 1105
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int em_fnstcw(struct x86_emulate_ctxt *ctxt)\n{\n\tu16 fcw;\n\n\tif (ctxt->ops->get_cr(ctxt, 0) & (X86_CR0_TS | X86_CR0_EM))\n\t\treturn emulate_nm(ctxt);\n\n\tctxt->ops->get_fpu(ctxt);\n\tasm volatile(\"fnstcw %0\": \"+m\"(fcw));\n\tctxt->ops->put_fpu(ctxt);\n\n\tctxt->dst.val = fcw;\n\n\treturn X86EMUL_CONTINUE;\n}"
  },
  {
    "function_name": "em_fninit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "1090-1099",
    "snippet": "static int em_fninit(struct x86_emulate_ctxt *ctxt)\n{\n\tif (ctxt->ops->get_cr(ctxt, 0) & (X86_CR0_TS | X86_CR0_EM))\n\t\treturn emulate_nm(ctxt);\n\n\tctxt->ops->get_fpu(ctxt);\n\tasm volatile(\"fninit\");\n\tctxt->ops->put_fpu(ctxt);\n\treturn X86EMUL_CONTINUE;\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ctxt->ops->put_fpu",
          "args": [
            "ctxt"
          ],
          "line": 1097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ctxt->ops->get_fpu",
          "args": [
            "ctxt"
          ],
          "line": 1095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "emulate_nm",
          "args": [
            "ctxt"
          ],
          "line": 1093
        },
        "resolved": true,
        "details": {
          "function_name": "emulate_nm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "605-608",
          "snippet": "static int emulate_nm(struct x86_emulate_ctxt *ctxt)\n{\n\treturn emulate_exception(ctxt, NM_VECTOR, 0, false);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int emulate_nm(struct x86_emulate_ctxt *ctxt)\n{\n\treturn emulate_exception(ctxt, NM_VECTOR, 0, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ctxt->ops->get_cr",
          "args": [
            "ctxt",
            "0"
          ],
          "line": 1092
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int em_fninit(struct x86_emulate_ctxt *ctxt)\n{\n\tif (ctxt->ops->get_cr(ctxt, 0) & (X86_CR0_TS | X86_CR0_EM))\n\t\treturn emulate_nm(ctxt);\n\n\tctxt->ops->get_fpu(ctxt);\n\tasm volatile(\"fninit\");\n\tctxt->ops->put_fpu(ctxt);\n\treturn X86EMUL_CONTINUE;\n}"
  },
  {
    "function_name": "write_mmx_reg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "1073-1088",
    "snippet": "static void write_mmx_reg(struct x86_emulate_ctxt *ctxt, u64 *data, int reg)\n{\n\tctxt->ops->get_fpu(ctxt);\n\tswitch (reg) {\n\tcase 0: asm(\"movq %0, %%mm0\" : : \"m\"(*data)); break;\n\tcase 1: asm(\"movq %0, %%mm1\" : : \"m\"(*data)); break;\n\tcase 2: asm(\"movq %0, %%mm2\" : : \"m\"(*data)); break;\n\tcase 3: asm(\"movq %0, %%mm3\" : : \"m\"(*data)); break;\n\tcase 4: asm(\"movq %0, %%mm4\" : : \"m\"(*data)); break;\n\tcase 5: asm(\"movq %0, %%mm5\" : : \"m\"(*data)); break;\n\tcase 6: asm(\"movq %0, %%mm6\" : : \"m\"(*data)); break;\n\tcase 7: asm(\"movq %0, %%mm7\" : : \"m\"(*data)); break;\n\tdefault: BUG();\n\t}\n\tctxt->ops->put_fpu(ctxt);\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ctxt->ops->put_fpu",
          "args": [
            "ctxt"
          ],
          "line": 1087
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 1085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ctxt->ops->get_fpu",
          "args": [
            "ctxt"
          ],
          "line": 1075
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic void write_mmx_reg(struct x86_emulate_ctxt *ctxt, u64 *data, int reg)\n{\n\tctxt->ops->get_fpu(ctxt);\n\tswitch (reg) {\n\tcase 0: asm(\"movq %0, %%mm0\" : : \"m\"(*data)); break;\n\tcase 1: asm(\"movq %0, %%mm1\" : : \"m\"(*data)); break;\n\tcase 2: asm(\"movq %0, %%mm2\" : : \"m\"(*data)); break;\n\tcase 3: asm(\"movq %0, %%mm3\" : : \"m\"(*data)); break;\n\tcase 4: asm(\"movq %0, %%mm4\" : : \"m\"(*data)); break;\n\tcase 5: asm(\"movq %0, %%mm5\" : : \"m\"(*data)); break;\n\tcase 6: asm(\"movq %0, %%mm6\" : : \"m\"(*data)); break;\n\tcase 7: asm(\"movq %0, %%mm7\" : : \"m\"(*data)); break;\n\tdefault: BUG();\n\t}\n\tctxt->ops->put_fpu(ctxt);\n}"
  },
  {
    "function_name": "read_mmx_reg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "1056-1071",
    "snippet": "static void read_mmx_reg(struct x86_emulate_ctxt *ctxt, u64 *data, int reg)\n{\n\tctxt->ops->get_fpu(ctxt);\n\tswitch (reg) {\n\tcase 0: asm(\"movq %%mm0, %0\" : \"=m\"(*data)); break;\n\tcase 1: asm(\"movq %%mm1, %0\" : \"=m\"(*data)); break;\n\tcase 2: asm(\"movq %%mm2, %0\" : \"=m\"(*data)); break;\n\tcase 3: asm(\"movq %%mm3, %0\" : \"=m\"(*data)); break;\n\tcase 4: asm(\"movq %%mm4, %0\" : \"=m\"(*data)); break;\n\tcase 5: asm(\"movq %%mm5, %0\" : \"=m\"(*data)); break;\n\tcase 6: asm(\"movq %%mm6, %0\" : \"=m\"(*data)); break;\n\tcase 7: asm(\"movq %%mm7, %0\" : \"=m\"(*data)); break;\n\tdefault: BUG();\n\t}\n\tctxt->ops->put_fpu(ctxt);\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ctxt->ops->put_fpu",
          "args": [
            "ctxt"
          ],
          "line": 1070
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 1068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ctxt->ops->get_fpu",
          "args": [
            "ctxt"
          ],
          "line": 1058
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic void read_mmx_reg(struct x86_emulate_ctxt *ctxt, u64 *data, int reg)\n{\n\tctxt->ops->get_fpu(ctxt);\n\tswitch (reg) {\n\tcase 0: asm(\"movq %%mm0, %0\" : \"=m\"(*data)); break;\n\tcase 1: asm(\"movq %%mm1, %0\" : \"=m\"(*data)); break;\n\tcase 2: asm(\"movq %%mm2, %0\" : \"=m\"(*data)); break;\n\tcase 3: asm(\"movq %%mm3, %0\" : \"=m\"(*data)); break;\n\tcase 4: asm(\"movq %%mm4, %0\" : \"=m\"(*data)); break;\n\tcase 5: asm(\"movq %%mm5, %0\" : \"=m\"(*data)); break;\n\tcase 6: asm(\"movq %%mm6, %0\" : \"=m\"(*data)); break;\n\tcase 7: asm(\"movq %%mm7, %0\" : \"=m\"(*data)); break;\n\tdefault: BUG();\n\t}\n\tctxt->ops->put_fpu(ctxt);\n}"
  },
  {
    "function_name": "write_sse_reg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "1028-1054",
    "snippet": "static void write_sse_reg(struct x86_emulate_ctxt *ctxt, sse128_t *data,\n\t\t\t  int reg)\n{\n\tctxt->ops->get_fpu(ctxt);\n\tswitch (reg) {\n\tcase 0: asm(\"movdqa %0, %%xmm0\" : : \"m\"(*data)); break;\n\tcase 1: asm(\"movdqa %0, %%xmm1\" : : \"m\"(*data)); break;\n\tcase 2: asm(\"movdqa %0, %%xmm2\" : : \"m\"(*data)); break;\n\tcase 3: asm(\"movdqa %0, %%xmm3\" : : \"m\"(*data)); break;\n\tcase 4: asm(\"movdqa %0, %%xmm4\" : : \"m\"(*data)); break;\n\tcase 5: asm(\"movdqa %0, %%xmm5\" : : \"m\"(*data)); break;\n\tcase 6: asm(\"movdqa %0, %%xmm6\" : : \"m\"(*data)); break;\n\tcase 7: asm(\"movdqa %0, %%xmm7\" : : \"m\"(*data)); break;\n#ifdef CONFIG_X86_64\n\tcase 8: asm(\"movdqa %0, %%xmm8\" : : \"m\"(*data)); break;\n\tcase 9: asm(\"movdqa %0, %%xmm9\" : : \"m\"(*data)); break;\n\tcase 10: asm(\"movdqa %0, %%xmm10\" : : \"m\"(*data)); break;\n\tcase 11: asm(\"movdqa %0, %%xmm11\" : : \"m\"(*data)); break;\n\tcase 12: asm(\"movdqa %0, %%xmm12\" : : \"m\"(*data)); break;\n\tcase 13: asm(\"movdqa %0, %%xmm13\" : : \"m\"(*data)); break;\n\tcase 14: asm(\"movdqa %0, %%xmm14\" : : \"m\"(*data)); break;\n\tcase 15: asm(\"movdqa %0, %%xmm15\" : : \"m\"(*data)); break;\n#endif\n\tdefault: BUG();\n\t}\n\tctxt->ops->put_fpu(ctxt);\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ctxt->ops->put_fpu",
          "args": [
            "ctxt"
          ],
          "line": 1053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 1051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ctxt->ops->get_fpu",
          "args": [
            "ctxt"
          ],
          "line": 1031
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic void write_sse_reg(struct x86_emulate_ctxt *ctxt, sse128_t *data,\n\t\t\t  int reg)\n{\n\tctxt->ops->get_fpu(ctxt);\n\tswitch (reg) {\n\tcase 0: asm(\"movdqa %0, %%xmm0\" : : \"m\"(*data)); break;\n\tcase 1: asm(\"movdqa %0, %%xmm1\" : : \"m\"(*data)); break;\n\tcase 2: asm(\"movdqa %0, %%xmm2\" : : \"m\"(*data)); break;\n\tcase 3: asm(\"movdqa %0, %%xmm3\" : : \"m\"(*data)); break;\n\tcase 4: asm(\"movdqa %0, %%xmm4\" : : \"m\"(*data)); break;\n\tcase 5: asm(\"movdqa %0, %%xmm5\" : : \"m\"(*data)); break;\n\tcase 6: asm(\"movdqa %0, %%xmm6\" : : \"m\"(*data)); break;\n\tcase 7: asm(\"movdqa %0, %%xmm7\" : : \"m\"(*data)); break;\n#ifdef CONFIG_X86_64\n\tcase 8: asm(\"movdqa %0, %%xmm8\" : : \"m\"(*data)); break;\n\tcase 9: asm(\"movdqa %0, %%xmm9\" : : \"m\"(*data)); break;\n\tcase 10: asm(\"movdqa %0, %%xmm10\" : : \"m\"(*data)); break;\n\tcase 11: asm(\"movdqa %0, %%xmm11\" : : \"m\"(*data)); break;\n\tcase 12: asm(\"movdqa %0, %%xmm12\" : : \"m\"(*data)); break;\n\tcase 13: asm(\"movdqa %0, %%xmm13\" : : \"m\"(*data)); break;\n\tcase 14: asm(\"movdqa %0, %%xmm14\" : : \"m\"(*data)); break;\n\tcase 15: asm(\"movdqa %0, %%xmm15\" : : \"m\"(*data)); break;\n#endif\n\tdefault: BUG();\n\t}\n\tctxt->ops->put_fpu(ctxt);\n}"
  },
  {
    "function_name": "read_sse_reg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "1001-1026",
    "snippet": "static void read_sse_reg(struct x86_emulate_ctxt *ctxt, sse128_t *data, int reg)\n{\n\tctxt->ops->get_fpu(ctxt);\n\tswitch (reg) {\n\tcase 0: asm(\"movdqa %%xmm0, %0\" : \"=m\"(*data)); break;\n\tcase 1: asm(\"movdqa %%xmm1, %0\" : \"=m\"(*data)); break;\n\tcase 2: asm(\"movdqa %%xmm2, %0\" : \"=m\"(*data)); break;\n\tcase 3: asm(\"movdqa %%xmm3, %0\" : \"=m\"(*data)); break;\n\tcase 4: asm(\"movdqa %%xmm4, %0\" : \"=m\"(*data)); break;\n\tcase 5: asm(\"movdqa %%xmm5, %0\" : \"=m\"(*data)); break;\n\tcase 6: asm(\"movdqa %%xmm6, %0\" : \"=m\"(*data)); break;\n\tcase 7: asm(\"movdqa %%xmm7, %0\" : \"=m\"(*data)); break;\n#ifdef CONFIG_X86_64\n\tcase 8: asm(\"movdqa %%xmm8, %0\" : \"=m\"(*data)); break;\n\tcase 9: asm(\"movdqa %%xmm9, %0\" : \"=m\"(*data)); break;\n\tcase 10: asm(\"movdqa %%xmm10, %0\" : \"=m\"(*data)); break;\n\tcase 11: asm(\"movdqa %%xmm11, %0\" : \"=m\"(*data)); break;\n\tcase 12: asm(\"movdqa %%xmm12, %0\" : \"=m\"(*data)); break;\n\tcase 13: asm(\"movdqa %%xmm13, %0\" : \"=m\"(*data)); break;\n\tcase 14: asm(\"movdqa %%xmm14, %0\" : \"=m\"(*data)); break;\n\tcase 15: asm(\"movdqa %%xmm15, %0\" : \"=m\"(*data)); break;\n#endif\n\tdefault: BUG();\n\t}\n\tctxt->ops->put_fpu(ctxt);\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ctxt->ops->put_fpu",
          "args": [
            "ctxt"
          ],
          "line": 1025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 1023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ctxt->ops->get_fpu",
          "args": [
            "ctxt"
          ],
          "line": 1003
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic void read_sse_reg(struct x86_emulate_ctxt *ctxt, sse128_t *data, int reg)\n{\n\tctxt->ops->get_fpu(ctxt);\n\tswitch (reg) {\n\tcase 0: asm(\"movdqa %%xmm0, %0\" : \"=m\"(*data)); break;\n\tcase 1: asm(\"movdqa %%xmm1, %0\" : \"=m\"(*data)); break;\n\tcase 2: asm(\"movdqa %%xmm2, %0\" : \"=m\"(*data)); break;\n\tcase 3: asm(\"movdqa %%xmm3, %0\" : \"=m\"(*data)); break;\n\tcase 4: asm(\"movdqa %%xmm4, %0\" : \"=m\"(*data)); break;\n\tcase 5: asm(\"movdqa %%xmm5, %0\" : \"=m\"(*data)); break;\n\tcase 6: asm(\"movdqa %%xmm6, %0\" : \"=m\"(*data)); break;\n\tcase 7: asm(\"movdqa %%xmm7, %0\" : \"=m\"(*data)); break;\n#ifdef CONFIG_X86_64\n\tcase 8: asm(\"movdqa %%xmm8, %0\" : \"=m\"(*data)); break;\n\tcase 9: asm(\"movdqa %%xmm9, %0\" : \"=m\"(*data)); break;\n\tcase 10: asm(\"movdqa %%xmm10, %0\" : \"=m\"(*data)); break;\n\tcase 11: asm(\"movdqa %%xmm11, %0\" : \"=m\"(*data)); break;\n\tcase 12: asm(\"movdqa %%xmm12, %0\" : \"=m\"(*data)); break;\n\tcase 13: asm(\"movdqa %%xmm13, %0\" : \"=m\"(*data)); break;\n\tcase 14: asm(\"movdqa %%xmm14, %0\" : \"=m\"(*data)); break;\n\tcase 15: asm(\"movdqa %%xmm15, %0\" : \"=m\"(*data)); break;\n#endif\n\tdefault: BUG();\n\t}\n\tctxt->ops->put_fpu(ctxt);\n}"
  },
  {
    "function_name": "fetch_register_operand",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "983-999",
    "snippet": "static void fetch_register_operand(struct operand *op)\n{\n\tswitch (op->bytes) {\n\tcase 1:\n\t\top->val = *(u8 *)op->addr.reg;\n\t\tbreak;\n\tcase 2:\n\t\top->val = *(u16 *)op->addr.reg;\n\t\tbreak;\n\tcase 4:\n\t\top->val = *(u32 *)op->addr.reg;\n\t\tbreak;\n\tcase 8:\n\t\top->val = *(u64 *)op->addr.reg;\n\t\tbreak;\n\t}\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic void fetch_register_operand(struct operand *op)\n{\n\tswitch (op->bytes) {\n\tcase 1:\n\t\top->val = *(u8 *)op->addr.reg;\n\t\tbreak;\n\tcase 2:\n\t\top->val = *(u16 *)op->addr.reg;\n\t\tbreak;\n\tcase 4:\n\t\top->val = *(u32 *)op->addr.reg;\n\t\tbreak;\n\tcase 8:\n\t\top->val = *(u64 *)op->addr.reg;\n\t\tbreak;\n\t}\n}"
  },
  {
    "function_name": "test_cc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "972-981",
    "snippet": "static __always_inline u8 test_cc(unsigned int condition, unsigned long flags)\n{\n\tu8 rc;\n\tvoid (*fop)(void) = (void *)em_setcc + 4 * (condition & 0xf);\n\n\tflags = (flags & EFLAGS_MASK) | X86_EFLAGS_IF;\n\tasm(\"push %[flags]; popf; call *%[fastop]\"\n\t    : \"=a\"(rc) : [fastop]\"r\"(fop), [flags]\"r\"(flags));\n\treturn rc;\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define EFLAGS_MASK (X86_EFLAGS_OF|X86_EFLAGS_SF|X86_EFLAGS_ZF|X86_EFLAGS_AF|\\\n\t\t     X86_EFLAGS_PF|X86_EFLAGS_CF)"
    ],
    "globals_used": [
      "static int fastop(struct x86_emulate_ctxt *ctxt, void (*fop)(struct fastop *));"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\n#define EFLAGS_MASK (X86_EFLAGS_OF|X86_EFLAGS_SF|X86_EFLAGS_ZF|X86_EFLAGS_AF|\\\n\t\t     X86_EFLAGS_PF|X86_EFLAGS_CF)\n\nstatic int fastop(struct x86_emulate_ctxt *ctxt, void (*fop)(struct fastop *));\n\nstatic __always_inline u8 test_cc(unsigned int condition, unsigned long flags)\n{\n\tu8 rc;\n\tvoid (*fop)(void) = (void *)em_setcc + 4 * (condition & 0xf);\n\n\tflags = (flags & EFLAGS_MASK) | X86_EFLAGS_IF;\n\tasm(\"push %[flags]; popf; call *%[fastop]\"\n\t    : \"=a\"(rc) : [fastop]\"r\"(fop), [flags]\"r\"(flags));\n\treturn rc;\n}"
  },
  {
    "function_name": "em_bsr_c",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "964-970",
    "snippet": "static int em_bsr_c(struct x86_emulate_ctxt *ctxt)\n{\n\t/* If src is zero, do not writeback, but update flags */\n\tif (ctxt->src.val == 0)\n\t\tctxt->dst.type = OP_NONE;\n\treturn fastop(ctxt, em_bsr);\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int fastop(struct x86_emulate_ctxt *ctxt, void (*fop)(struct fastop *));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fastop",
          "args": [
            "ctxt",
            "em_bsr"
          ],
          "line": 969
        },
        "resolved": true,
        "details": {
          "function_name": "fastop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "5111-5124",
          "snippet": "static int fastop(struct x86_emulate_ctxt *ctxt, void (*fop)(struct fastop *))\n{\n\tulong flags = (ctxt->eflags & EFLAGS_MASK) | X86_EFLAGS_IF;\n\tif (!(ctxt->d & ByteOp))\n\t\tfop += __ffs(ctxt->dst.bytes) * FASTOP_SIZE;\n\tasm(\"push %[flags]; popf; call *%[fastop]; pushf; pop %[flags]\\n\"\n\t    : \"+a\"(ctxt->dst.val), \"+d\"(ctxt->src.val), [flags]\"+D\"(flags),\n\t      [fastop]\"+S\"(fop)\n\t    : \"c\"(ctxt->src2.val));\n\tctxt->eflags = (ctxt->eflags & ~EFLAGS_MASK) | (flags & EFLAGS_MASK);\n\tif (!fop) /* exception is returned in fop variable */\n\t\treturn emulate_de(ctxt);\n\treturn X86EMUL_CONTINUE;\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define EFLAGS_MASK (X86_EFLAGS_OF|X86_EFLAGS_SF|X86_EFLAGS_ZF|X86_EFLAGS_AF|\\\n\t\t     X86_EFLAGS_PF|X86_EFLAGS_CF)",
            "#define FASTOP_SIZE 8",
            "#define ByteOp      (1<<0)\t/* 8-bit operands. */"
          ],
          "globals_used": [
            "static int fastop(struct x86_emulate_ctxt *ctxt, void (*fop)(struct fastop *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\n#define EFLAGS_MASK (X86_EFLAGS_OF|X86_EFLAGS_SF|X86_EFLAGS_ZF|X86_EFLAGS_AF|\\\n\t\t     X86_EFLAGS_PF|X86_EFLAGS_CF)\n#define FASTOP_SIZE 8\n#define ByteOp      (1<<0)\t/* 8-bit operands. */\n\nstatic int fastop(struct x86_emulate_ctxt *ctxt, void (*fop)(struct fastop *));\n\nstatic int fastop(struct x86_emulate_ctxt *ctxt, void (*fop)(struct fastop *))\n{\n\tulong flags = (ctxt->eflags & EFLAGS_MASK) | X86_EFLAGS_IF;\n\tif (!(ctxt->d & ByteOp))\n\t\tfop += __ffs(ctxt->dst.bytes) * FASTOP_SIZE;\n\tasm(\"push %[flags]; popf; call *%[fastop]; pushf; pop %[flags]\\n\"\n\t    : \"+a\"(ctxt->dst.val), \"+d\"(ctxt->src.val), [flags]\"+D\"(flags),\n\t      [fastop]\"+S\"(fop)\n\t    : \"c\"(ctxt->src2.val));\n\tctxt->eflags = (ctxt->eflags & ~EFLAGS_MASK) | (flags & EFLAGS_MASK);\n\tif (!fop) /* exception is returned in fop variable */\n\t\treturn emulate_de(ctxt);\n\treturn X86EMUL_CONTINUE;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int fastop(struct x86_emulate_ctxt *ctxt, void (*fop)(struct fastop *));\n\nstatic int em_bsr_c(struct x86_emulate_ctxt *ctxt)\n{\n\t/* If src is zero, do not writeback, but update flags */\n\tif (ctxt->src.val == 0)\n\t\tctxt->dst.type = OP_NONE;\n\treturn fastop(ctxt, em_bsr);\n}"
  },
  {
    "function_name": "em_bsf_c",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "956-962",
    "snippet": "static int em_bsf_c(struct x86_emulate_ctxt *ctxt)\n{\n\t/* If src is zero, do not writeback, but update flags */\n\tif (ctxt->src.val == 0)\n\t\tctxt->dst.type = OP_NONE;\n\treturn fastop(ctxt, em_bsf);\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int fastop(struct x86_emulate_ctxt *ctxt, void (*fop)(struct fastop *));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fastop",
          "args": [
            "ctxt",
            "em_bsf"
          ],
          "line": 961
        },
        "resolved": true,
        "details": {
          "function_name": "fastop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "5111-5124",
          "snippet": "static int fastop(struct x86_emulate_ctxt *ctxt, void (*fop)(struct fastop *))\n{\n\tulong flags = (ctxt->eflags & EFLAGS_MASK) | X86_EFLAGS_IF;\n\tif (!(ctxt->d & ByteOp))\n\t\tfop += __ffs(ctxt->dst.bytes) * FASTOP_SIZE;\n\tasm(\"push %[flags]; popf; call *%[fastop]; pushf; pop %[flags]\\n\"\n\t    : \"+a\"(ctxt->dst.val), \"+d\"(ctxt->src.val), [flags]\"+D\"(flags),\n\t      [fastop]\"+S\"(fop)\n\t    : \"c\"(ctxt->src2.val));\n\tctxt->eflags = (ctxt->eflags & ~EFLAGS_MASK) | (flags & EFLAGS_MASK);\n\tif (!fop) /* exception is returned in fop variable */\n\t\treturn emulate_de(ctxt);\n\treturn X86EMUL_CONTINUE;\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define EFLAGS_MASK (X86_EFLAGS_OF|X86_EFLAGS_SF|X86_EFLAGS_ZF|X86_EFLAGS_AF|\\\n\t\t     X86_EFLAGS_PF|X86_EFLAGS_CF)",
            "#define FASTOP_SIZE 8",
            "#define ByteOp      (1<<0)\t/* 8-bit operands. */"
          ],
          "globals_used": [
            "static int fastop(struct x86_emulate_ctxt *ctxt, void (*fop)(struct fastop *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\n#define EFLAGS_MASK (X86_EFLAGS_OF|X86_EFLAGS_SF|X86_EFLAGS_ZF|X86_EFLAGS_AF|\\\n\t\t     X86_EFLAGS_PF|X86_EFLAGS_CF)\n#define FASTOP_SIZE 8\n#define ByteOp      (1<<0)\t/* 8-bit operands. */\n\nstatic int fastop(struct x86_emulate_ctxt *ctxt, void (*fop)(struct fastop *));\n\nstatic int fastop(struct x86_emulate_ctxt *ctxt, void (*fop)(struct fastop *))\n{\n\tulong flags = (ctxt->eflags & EFLAGS_MASK) | X86_EFLAGS_IF;\n\tif (!(ctxt->d & ByteOp))\n\t\tfop += __ffs(ctxt->dst.bytes) * FASTOP_SIZE;\n\tasm(\"push %[flags]; popf; call *%[fastop]; pushf; pop %[flags]\\n\"\n\t    : \"+a\"(ctxt->dst.val), \"+d\"(ctxt->src.val), [flags]\"+D\"(flags),\n\t      [fastop]\"+S\"(fop)\n\t    : \"c\"(ctxt->src2.val));\n\tctxt->eflags = (ctxt->eflags & ~EFLAGS_MASK) | (flags & EFLAGS_MASK);\n\tif (!fop) /* exception is returned in fop variable */\n\t\treturn emulate_de(ctxt);\n\treturn X86EMUL_CONTINUE;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int fastop(struct x86_emulate_ctxt *ctxt, void (*fop)(struct fastop *));\n\nstatic int em_bsf_c(struct x86_emulate_ctxt *ctxt)\n{\n\t/* If src is zero, do not writeback, but update flags */\n\tif (ctxt->src.val == 0)\n\t\tctxt->dst.type = OP_NONE;\n\treturn fastop(ctxt, em_bsf);\n}"
  },
  {
    "function_name": "read_descriptor",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "895-910",
    "snippet": "static int read_descriptor(struct x86_emulate_ctxt *ctxt,\n\t\t\t   struct segmented_address addr,\n\t\t\t   u16 *size, unsigned long *address, int op_bytes)\n{\n\tint rc;\n\n\tif (op_bytes == 2)\n\t\top_bytes = 3;\n\t*address = 0;\n\trc = segmented_read_std(ctxt, addr, size, 2);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\taddr.ea += 2;\n\trc = segmented_read_std(ctxt, addr, address, op_bytes);\n\treturn rc;\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "segmented_read_std",
          "args": [
            "ctxt",
            "addr",
            "address",
            "op_bytes"
          ],
          "line": 908
        },
        "resolved": true,
        "details": {
          "function_name": "segmented_read_std",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "781-793",
          "snippet": "static int segmented_read_std(struct x86_emulate_ctxt *ctxt,\n\t\t\t      struct segmented_address addr,\n\t\t\t      void *data,\n\t\t\t      unsigned size)\n{\n\tint rc;\n\tulong linear;\n\n\trc = linearize(ctxt, addr, size, false, &linear);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\treturn ctxt->ops->read_std(ctxt, linear, data, size, &ctxt->exception);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int segmented_read_std(struct x86_emulate_ctxt *ctxt,\n\t\t\t      struct segmented_address addr,\n\t\t\t      void *data,\n\t\t\t      unsigned size)\n{\n\tint rc;\n\tulong linear;\n\n\trc = linearize(ctxt, addr, size, false, &linear);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\treturn ctxt->ops->read_std(ctxt, linear, data, size, &ctxt->exception);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int read_descriptor(struct x86_emulate_ctxt *ctxt,\n\t\t\t   struct segmented_address addr,\n\t\t\t   u16 *size, unsigned long *address, int op_bytes)\n{\n\tint rc;\n\n\tif (op_bytes == 2)\n\t\top_bytes = 3;\n\t*address = 0;\n\trc = segmented_read_std(ctxt, addr, size, 2);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\taddr.ea += 2;\n\trc = segmented_read_std(ctxt, addr, address, op_bytes);\n\treturn rc;\n}"
  },
  {
    "function_name": "decode_register",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "882-893",
    "snippet": "static void *decode_register(struct x86_emulate_ctxt *ctxt, u8 modrm_reg,\n\t\t\t     int byteop)\n{\n\tvoid *p;\n\tint highbyte_regs = (ctxt->rex_prefix == 0) && byteop;\n\n\tif (highbyte_regs && modrm_reg >= 4 && modrm_reg < 8)\n\t\tp = (unsigned char *)reg_rmw(ctxt, modrm_reg & 3) + 1;\n\telse\n\t\tp = reg_rmw(ctxt, modrm_reg);\n\treturn p;\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reg_rmw",
          "args": [
            "ctxt",
            "modrm_reg"
          ],
          "line": 891
        },
        "resolved": true,
        "details": {
          "function_name": "reg_rmw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "277-281",
          "snippet": "static ulong *reg_rmw(struct x86_emulate_ctxt *ctxt, unsigned nr)\n{\n\treg_read(ctxt, nr);\n\treturn reg_write(ctxt, nr);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic ulong *reg_rmw(struct x86_emulate_ctxt *ctxt, unsigned nr)\n{\n\treg_read(ctxt, nr);\n\treturn reg_write(ctxt, nr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic void *decode_register(struct x86_emulate_ctxt *ctxt, u8 modrm_reg,\n\t\t\t     int byteop)\n{\n\tvoid *p;\n\tint highbyte_regs = (ctxt->rex_prefix == 0) && byteop;\n\n\tif (highbyte_regs && modrm_reg >= 4 && modrm_reg < 8)\n\t\tp = (unsigned char *)reg_rmw(ctxt, modrm_reg & 3) + 1;\n\telse\n\t\tp = reg_rmw(ctxt, modrm_reg);\n\treturn p;\n}"
  },
  {
    "function_name": "do_insn_fetch_bytes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "843-852",
    "snippet": "static __always_inline int do_insn_fetch_bytes(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t\t       unsigned size)\n{\n\tunsigned done_size = ctxt->fetch.end - ctxt->fetch.ptr;\n\n\tif (unlikely(done_size < size))\n\t\treturn __do_insn_fetch_bytes(ctxt, size - done_size);\n\telse\n\t\treturn X86EMUL_CONTINUE;\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__do_insn_fetch_bytes",
          "args": [
            "ctxt",
            "size - done_size"
          ],
          "line": 849
        },
        "resolved": true,
        "details": {
          "function_name": "__do_insn_fetch_bytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "799-841",
          "snippet": "static int __do_insn_fetch_bytes(struct x86_emulate_ctxt *ctxt, int op_size)\n{\n\tint rc;\n\tunsigned size, max_size;\n\tunsigned long linear;\n\tint cur_size = ctxt->fetch.end - ctxt->fetch.data;\n\tstruct segmented_address addr = { .seg = VCPU_SREG_CS,\n\t\t\t\t\t   .ea = ctxt->eip + cur_size };\n\n\t/*\n\t * We do not know exactly how many bytes will be needed, and\n\t * __linearize is expensive, so fetch as much as possible.  We\n\t * just have to avoid going beyond the 15 byte limit, the end\n\t * of the segment, or the end of the page.\n\t *\n\t * __linearize is called with size 0 so that it does not do any\n\t * boundary check itself.  Instead, we use max_size to check\n\t * against op_size.\n\t */\n\trc = __linearize(ctxt, addr, &max_size, 0, false, true, ctxt->mode,\n\t\t\t &linear);\n\tif (unlikely(rc != X86EMUL_CONTINUE))\n\t\treturn rc;\n\n\tsize = min_t(unsigned, 15UL ^ cur_size, max_size);\n\tsize = min_t(unsigned, size, PAGE_SIZE - offset_in_page(linear));\n\n\t/*\n\t * One instruction can only straddle two pages,\n\t * and one has been loaded at the beginning of\n\t * x86_decode_insn.  So, if not enough bytes\n\t * still, we must have hit the 15-byte boundary.\n\t */\n\tif (unlikely(size < op_size))\n\t\treturn emulate_gp(ctxt, 0);\n\n\trc = ctxt->ops->fetch(ctxt, linear, ctxt->fetch.end,\n\t\t\t      size, &ctxt->exception);\n\tif (unlikely(rc != X86EMUL_CONTINUE))\n\t\treturn rc;\n\tctxt->fetch.end += size;\n\treturn X86EMUL_CONTINUE;\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int __do_insn_fetch_bytes(struct x86_emulate_ctxt *ctxt, int op_size)\n{\n\tint rc;\n\tunsigned size, max_size;\n\tunsigned long linear;\n\tint cur_size = ctxt->fetch.end - ctxt->fetch.data;\n\tstruct segmented_address addr = { .seg = VCPU_SREG_CS,\n\t\t\t\t\t   .ea = ctxt->eip + cur_size };\n\n\t/*\n\t * We do not know exactly how many bytes will be needed, and\n\t * __linearize is expensive, so fetch as much as possible.  We\n\t * just have to avoid going beyond the 15 byte limit, the end\n\t * of the segment, or the end of the page.\n\t *\n\t * __linearize is called with size 0 so that it does not do any\n\t * boundary check itself.  Instead, we use max_size to check\n\t * against op_size.\n\t */\n\trc = __linearize(ctxt, addr, &max_size, 0, false, true, ctxt->mode,\n\t\t\t &linear);\n\tif (unlikely(rc != X86EMUL_CONTINUE))\n\t\treturn rc;\n\n\tsize = min_t(unsigned, 15UL ^ cur_size, max_size);\n\tsize = min_t(unsigned, size, PAGE_SIZE - offset_in_page(linear));\n\n\t/*\n\t * One instruction can only straddle two pages,\n\t * and one has been loaded at the beginning of\n\t * x86_decode_insn.  So, if not enough bytes\n\t * still, we must have hit the 15-byte boundary.\n\t */\n\tif (unlikely(size < op_size))\n\t\treturn emulate_gp(ctxt, 0);\n\n\trc = ctxt->ops->fetch(ctxt, linear, ctxt->fetch.end,\n\t\t\t      size, &ctxt->exception);\n\tif (unlikely(rc != X86EMUL_CONTINUE))\n\t\treturn rc;\n\tctxt->fetch.end += size;\n\treturn X86EMUL_CONTINUE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "done_size < size"
          ],
          "line": 848
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic __always_inline int do_insn_fetch_bytes(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t\t       unsigned size)\n{\n\tunsigned done_size = ctxt->fetch.end - ctxt->fetch.ptr;\n\n\tif (unlikely(done_size < size))\n\t\treturn __do_insn_fetch_bytes(ctxt, size - done_size);\n\telse\n\t\treturn X86EMUL_CONTINUE;\n}"
  },
  {
    "function_name": "__do_insn_fetch_bytes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "799-841",
    "snippet": "static int __do_insn_fetch_bytes(struct x86_emulate_ctxt *ctxt, int op_size)\n{\n\tint rc;\n\tunsigned size, max_size;\n\tunsigned long linear;\n\tint cur_size = ctxt->fetch.end - ctxt->fetch.data;\n\tstruct segmented_address addr = { .seg = VCPU_SREG_CS,\n\t\t\t\t\t   .ea = ctxt->eip + cur_size };\n\n\t/*\n\t * We do not know exactly how many bytes will be needed, and\n\t * __linearize is expensive, so fetch as much as possible.  We\n\t * just have to avoid going beyond the 15 byte limit, the end\n\t * of the segment, or the end of the page.\n\t *\n\t * __linearize is called with size 0 so that it does not do any\n\t * boundary check itself.  Instead, we use max_size to check\n\t * against op_size.\n\t */\n\trc = __linearize(ctxt, addr, &max_size, 0, false, true, ctxt->mode,\n\t\t\t &linear);\n\tif (unlikely(rc != X86EMUL_CONTINUE))\n\t\treturn rc;\n\n\tsize = min_t(unsigned, 15UL ^ cur_size, max_size);\n\tsize = min_t(unsigned, size, PAGE_SIZE - offset_in_page(linear));\n\n\t/*\n\t * One instruction can only straddle two pages,\n\t * and one has been loaded at the beginning of\n\t * x86_decode_insn.  So, if not enough bytes\n\t * still, we must have hit the 15-byte boundary.\n\t */\n\tif (unlikely(size < op_size))\n\t\treturn emulate_gp(ctxt, 0);\n\n\trc = ctxt->ops->fetch(ctxt, linear, ctxt->fetch.end,\n\t\t\t      size, &ctxt->exception);\n\tif (unlikely(rc != X86EMUL_CONTINUE))\n\t\treturn rc;\n\tctxt->fetch.end += size;\n\treturn X86EMUL_CONTINUE;\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "rc != X86EMUL_CONTINUE"
          ],
          "line": 837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ctxt->ops->fetch",
          "args": [
            "ctxt",
            "linear",
            "ctxt->fetch.end",
            "size",
            "&ctxt->exception"
          ],
          "line": 835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "emulate_gp",
          "args": [
            "ctxt",
            "0"
          ],
          "line": 833
        },
        "resolved": true,
        "details": {
          "function_name": "emulate_gp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "580-583",
          "snippet": "static int emulate_gp(struct x86_emulate_ctxt *ctxt, int err)\n{\n\treturn emulate_exception(ctxt, GP_VECTOR, err, true);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int emulate_gp(struct x86_emulate_ctxt *ctxt, int err)\n{\n\treturn emulate_exception(ctxt, GP_VECTOR, err, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "size < op_size"
          ],
          "line": 832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "unsigned",
            "size",
            "PAGE_SIZE - offset_in_page(linear)"
          ],
          "line": 824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "offset_in_page",
          "args": [
            "linear"
          ],
          "line": 824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "unsigned",
            "15UL ^ cur_size",
            "max_size"
          ],
          "line": 823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "rc != X86EMUL_CONTINUE"
          ],
          "line": 820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__linearize",
          "args": [
            "ctxt",
            "addr",
            "&max_size",
            "0",
            "false",
            "true",
            "ctxt->mode",
            "&linear"
          ],
          "line": 818
        },
        "resolved": true,
        "details": {
          "function_name": "__linearize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "653-716",
          "snippet": "static __always_inline int __linearize(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t       struct segmented_address addr,\n\t\t\t\t       unsigned *max_size, unsigned size,\n\t\t\t\t       bool write, bool fetch,\n\t\t\t\t       enum x86emul_mode mode, ulong *linear)\n{\n\tstruct desc_struct desc;\n\tbool usable;\n\tulong la;\n\tu32 lim;\n\tu16 sel;\n\n\tla = seg_base(ctxt, addr.seg) + addr.ea;\n\t*max_size = 0;\n\tswitch (mode) {\n\tcase X86EMUL_MODE_PROT64:\n\t\t*linear = la;\n\t\tif (is_noncanonical_address(la))\n\t\t\tgoto bad;\n\n\t\t*max_size = min_t(u64, ~0u, (1ull << 48) - la);\n\t\tif (size > *max_size)\n\t\t\tgoto bad;\n\t\tbreak;\n\tdefault:\n\t\t*linear = la = (u32)la;\n\t\tusable = ctxt->ops->get_segment(ctxt, &sel, &desc, NULL,\n\t\t\t\t\t\taddr.seg);\n\t\tif (!usable)\n\t\t\tgoto bad;\n\t\t/* code segment in protected mode or read-only data segment */\n\t\tif ((((ctxt->mode != X86EMUL_MODE_REAL) && (desc.type & 8))\n\t\t\t\t\t|| !(desc.type & 2)) && write)\n\t\t\tgoto bad;\n\t\t/* unreadable code segment */\n\t\tif (!fetch && (desc.type & 8) && !(desc.type & 2))\n\t\t\tgoto bad;\n\t\tlim = desc_limit_scaled(&desc);\n\t\tif (!(desc.type & 8) && (desc.type & 4)) {\n\t\t\t/* expand-down segment */\n\t\t\tif (addr.ea <= lim)\n\t\t\t\tgoto bad;\n\t\t\tlim = desc.d ? 0xffffffff : 0xffff;\n\t\t}\n\t\tif (addr.ea > lim)\n\t\t\tgoto bad;\n\t\tif (lim == 0xffffffff)\n\t\t\t*max_size = ~0u;\n\t\telse {\n\t\t\t*max_size = (u64)lim + 1 - addr.ea;\n\t\t\tif (size > *max_size)\n\t\t\t\tgoto bad;\n\t\t}\n\t\tbreak;\n\t}\n\tif (insn_aligned(ctxt, size) && ((la & (size - 1)) != 0))\n\t\treturn emulate_gp(ctxt, 0);\n\treturn X86EMUL_CONTINUE;\nbad:\n\tif (addr.seg == VCPU_SREG_SS)\n\t\treturn emulate_ss(ctxt, 0);\n\telse\n\t\treturn emulate_gp(ctxt, 0);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic __always_inline int __linearize(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t       struct segmented_address addr,\n\t\t\t\t       unsigned *max_size, unsigned size,\n\t\t\t\t       bool write, bool fetch,\n\t\t\t\t       enum x86emul_mode mode, ulong *linear)\n{\n\tstruct desc_struct desc;\n\tbool usable;\n\tulong la;\n\tu32 lim;\n\tu16 sel;\n\n\tla = seg_base(ctxt, addr.seg) + addr.ea;\n\t*max_size = 0;\n\tswitch (mode) {\n\tcase X86EMUL_MODE_PROT64:\n\t\t*linear = la;\n\t\tif (is_noncanonical_address(la))\n\t\t\tgoto bad;\n\n\t\t*max_size = min_t(u64, ~0u, (1ull << 48) - la);\n\t\tif (size > *max_size)\n\t\t\tgoto bad;\n\t\tbreak;\n\tdefault:\n\t\t*linear = la = (u32)la;\n\t\tusable = ctxt->ops->get_segment(ctxt, &sel, &desc, NULL,\n\t\t\t\t\t\taddr.seg);\n\t\tif (!usable)\n\t\t\tgoto bad;\n\t\t/* code segment in protected mode or read-only data segment */\n\t\tif ((((ctxt->mode != X86EMUL_MODE_REAL) && (desc.type & 8))\n\t\t\t\t\t|| !(desc.type & 2)) && write)\n\t\t\tgoto bad;\n\t\t/* unreadable code segment */\n\t\tif (!fetch && (desc.type & 8) && !(desc.type & 2))\n\t\t\tgoto bad;\n\t\tlim = desc_limit_scaled(&desc);\n\t\tif (!(desc.type & 8) && (desc.type & 4)) {\n\t\t\t/* expand-down segment */\n\t\t\tif (addr.ea <= lim)\n\t\t\t\tgoto bad;\n\t\t\tlim = desc.d ? 0xffffffff : 0xffff;\n\t\t}\n\t\tif (addr.ea > lim)\n\t\t\tgoto bad;\n\t\tif (lim == 0xffffffff)\n\t\t\t*max_size = ~0u;\n\t\telse {\n\t\t\t*max_size = (u64)lim + 1 - addr.ea;\n\t\t\tif (size > *max_size)\n\t\t\t\tgoto bad;\n\t\t}\n\t\tbreak;\n\t}\n\tif (insn_aligned(ctxt, size) && ((la & (size - 1)) != 0))\n\t\treturn emulate_gp(ctxt, 0);\n\treturn X86EMUL_CONTINUE;\nbad:\n\tif (addr.seg == VCPU_SREG_SS)\n\t\treturn emulate_ss(ctxt, 0);\n\telse\n\t\treturn emulate_gp(ctxt, 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int __do_insn_fetch_bytes(struct x86_emulate_ctxt *ctxt, int op_size)\n{\n\tint rc;\n\tunsigned size, max_size;\n\tunsigned long linear;\n\tint cur_size = ctxt->fetch.end - ctxt->fetch.data;\n\tstruct segmented_address addr = { .seg = VCPU_SREG_CS,\n\t\t\t\t\t   .ea = ctxt->eip + cur_size };\n\n\t/*\n\t * We do not know exactly how many bytes will be needed, and\n\t * __linearize is expensive, so fetch as much as possible.  We\n\t * just have to avoid going beyond the 15 byte limit, the end\n\t * of the segment, or the end of the page.\n\t *\n\t * __linearize is called with size 0 so that it does not do any\n\t * boundary check itself.  Instead, we use max_size to check\n\t * against op_size.\n\t */\n\trc = __linearize(ctxt, addr, &max_size, 0, false, true, ctxt->mode,\n\t\t\t &linear);\n\tif (unlikely(rc != X86EMUL_CONTINUE))\n\t\treturn rc;\n\n\tsize = min_t(unsigned, 15UL ^ cur_size, max_size);\n\tsize = min_t(unsigned, size, PAGE_SIZE - offset_in_page(linear));\n\n\t/*\n\t * One instruction can only straddle two pages,\n\t * and one has been loaded at the beginning of\n\t * x86_decode_insn.  So, if not enough bytes\n\t * still, we must have hit the 15-byte boundary.\n\t */\n\tif (unlikely(size < op_size))\n\t\treturn emulate_gp(ctxt, 0);\n\n\trc = ctxt->ops->fetch(ctxt, linear, ctxt->fetch.end,\n\t\t\t      size, &ctxt->exception);\n\tif (unlikely(rc != X86EMUL_CONTINUE))\n\t\treturn rc;\n\tctxt->fetch.end += size;\n\treturn X86EMUL_CONTINUE;\n}"
  },
  {
    "function_name": "segmented_read_std",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "781-793",
    "snippet": "static int segmented_read_std(struct x86_emulate_ctxt *ctxt,\n\t\t\t      struct segmented_address addr,\n\t\t\t      void *data,\n\t\t\t      unsigned size)\n{\n\tint rc;\n\tulong linear;\n\n\trc = linearize(ctxt, addr, size, false, &linear);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\treturn ctxt->ops->read_std(ctxt, linear, data, size, &ctxt->exception);\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ctxt->ops->read_std",
          "args": [
            "ctxt",
            "linear",
            "data",
            "size",
            "&ctxt->exception"
          ],
          "line": 792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "linearize",
          "args": [
            "ctxt",
            "addr",
            "size",
            "false",
            "&linear"
          ],
          "line": 789
        },
        "resolved": true,
        "details": {
          "function_name": "linearize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "718-726",
          "snippet": "static int linearize(struct x86_emulate_ctxt *ctxt,\n\t\t     struct segmented_address addr,\n\t\t     unsigned size, bool write,\n\t\t     ulong *linear)\n{\n\tunsigned max_size;\n\treturn __linearize(ctxt, addr, &max_size, size, write, false,\n\t\t\t   ctxt->mode, linear);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int linearize(struct x86_emulate_ctxt *ctxt,\n\t\t     struct segmented_address addr,\n\t\t     unsigned size, bool write,\n\t\t     ulong *linear)\n{\n\tunsigned max_size;\n\treturn __linearize(ctxt, addr, &max_size, size, write, false,\n\t\t\t   ctxt->mode, linear);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int segmented_read_std(struct x86_emulate_ctxt *ctxt,\n\t\t\t      struct segmented_address addr,\n\t\t\t      void *data,\n\t\t\t      unsigned size)\n{\n\tint rc;\n\tulong linear;\n\n\trc = linearize(ctxt, addr, size, false, &linear);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\treturn ctxt->ops->read_std(ctxt, linear, data, size, &ctxt->exception);\n}"
  },
  {
    "function_name": "jmp_rel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "776-779",
    "snippet": "static inline int jmp_rel(struct x86_emulate_ctxt *ctxt, int rel)\n{\n\treturn assign_eip_near(ctxt, ctxt->_eip + rel);\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "assign_eip_near",
          "args": [
            "ctxt",
            "ctxt->_eip + rel"
          ],
          "line": 778
        },
        "resolved": true,
        "details": {
          "function_name": "assign_eip_near",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "745-748",
          "snippet": "static inline int assign_eip_near(struct x86_emulate_ctxt *ctxt, ulong dst)\n{\n\treturn assign_eip(ctxt, dst, ctxt->mode);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline int assign_eip_near(struct x86_emulate_ctxt *ctxt, ulong dst)\n{\n\treturn assign_eip(ctxt, dst, ctxt->mode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline int jmp_rel(struct x86_emulate_ctxt *ctxt, int rel)\n{\n\treturn assign_eip_near(ctxt, ctxt->_eip + rel);\n}"
  },
  {
    "function_name": "assign_eip_far",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "750-774",
    "snippet": "static int assign_eip_far(struct x86_emulate_ctxt *ctxt, ulong dst,\n\t\t\t  const struct desc_struct *cs_desc)\n{\n\tenum x86emul_mode mode = ctxt->mode;\n\tint rc;\n\n#ifdef CONFIG_X86_64\n\tif (ctxt->mode >= X86EMUL_MODE_PROT16) {\n\t\tif (cs_desc->l) {\n\t\t\tu64 efer = 0;\n\n\t\t\tctxt->ops->get_msr(ctxt, MSR_EFER, &efer);\n\t\t\tif (efer & EFER_LMA)\n\t\t\t\tmode = X86EMUL_MODE_PROT64;\n\t\t} else\n\t\t\tmode = X86EMUL_MODE_PROT32; /* temporary value */\n\t}\n#endif\n\tif (mode == X86EMUL_MODE_PROT16 || mode == X86EMUL_MODE_PROT32)\n\t\tmode = cs_desc->d ? X86EMUL_MODE_PROT32 : X86EMUL_MODE_PROT16;\n\trc = assign_eip(ctxt, dst, mode);\n\tif (rc == X86EMUL_CONTINUE)\n\t\tctxt->mode = mode;\n\treturn rc;\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "assign_eip",
          "args": [
            "ctxt",
            "dst",
            "mode"
          ],
          "line": 770
        },
        "resolved": true,
        "details": {
          "function_name": "assign_eip_far",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "750-774",
          "snippet": "static int assign_eip_far(struct x86_emulate_ctxt *ctxt, ulong dst,\n\t\t\t  const struct desc_struct *cs_desc)\n{\n\tenum x86emul_mode mode = ctxt->mode;\n\tint rc;\n\n#ifdef CONFIG_X86_64\n\tif (ctxt->mode >= X86EMUL_MODE_PROT16) {\n\t\tif (cs_desc->l) {\n\t\t\tu64 efer = 0;\n\n\t\t\tctxt->ops->get_msr(ctxt, MSR_EFER, &efer);\n\t\t\tif (efer & EFER_LMA)\n\t\t\t\tmode = X86EMUL_MODE_PROT64;\n\t\t} else\n\t\t\tmode = X86EMUL_MODE_PROT32; /* temporary value */\n\t}\n#endif\n\tif (mode == X86EMUL_MODE_PROT16 || mode == X86EMUL_MODE_PROT32)\n\t\tmode = cs_desc->d ? X86EMUL_MODE_PROT32 : X86EMUL_MODE_PROT16;\n\trc = assign_eip(ctxt, dst, mode);\n\tif (rc == X86EMUL_CONTINUE)\n\t\tctxt->mode = mode;\n\treturn rc;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "ctxt->ops->get_msr",
          "args": [
            "ctxt",
            "MSR_EFER",
            "&efer"
          ],
          "line": 761
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int assign_eip_far(struct x86_emulate_ctxt *ctxt, ulong dst,\n\t\t\t  const struct desc_struct *cs_desc)\n{\n\tenum x86emul_mode mode = ctxt->mode;\n\tint rc;\n\n#ifdef CONFIG_X86_64\n\tif (ctxt->mode >= X86EMUL_MODE_PROT16) {\n\t\tif (cs_desc->l) {\n\t\t\tu64 efer = 0;\n\n\t\t\tctxt->ops->get_msr(ctxt, MSR_EFER, &efer);\n\t\t\tif (efer & EFER_LMA)\n\t\t\t\tmode = X86EMUL_MODE_PROT64;\n\t\t} else\n\t\t\tmode = X86EMUL_MODE_PROT32; /* temporary value */\n\t}\n#endif\n\tif (mode == X86EMUL_MODE_PROT16 || mode == X86EMUL_MODE_PROT32)\n\t\tmode = cs_desc->d ? X86EMUL_MODE_PROT32 : X86EMUL_MODE_PROT16;\n\trc = assign_eip(ctxt, dst, mode);\n\tif (rc == X86EMUL_CONTINUE)\n\t\tctxt->mode = mode;\n\treturn rc;\n}"
  },
  {
    "function_name": "assign_eip_near",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "745-748",
    "snippet": "static inline int assign_eip_near(struct x86_emulate_ctxt *ctxt, ulong dst)\n{\n\treturn assign_eip(ctxt, dst, ctxt->mode);\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "assign_eip",
          "args": [
            "ctxt",
            "dst",
            "ctxt->mode"
          ],
          "line": 747
        },
        "resolved": true,
        "details": {
          "function_name": "assign_eip_far",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "750-774",
          "snippet": "static int assign_eip_far(struct x86_emulate_ctxt *ctxt, ulong dst,\n\t\t\t  const struct desc_struct *cs_desc)\n{\n\tenum x86emul_mode mode = ctxt->mode;\n\tint rc;\n\n#ifdef CONFIG_X86_64\n\tif (ctxt->mode >= X86EMUL_MODE_PROT16) {\n\t\tif (cs_desc->l) {\n\t\t\tu64 efer = 0;\n\n\t\t\tctxt->ops->get_msr(ctxt, MSR_EFER, &efer);\n\t\t\tif (efer & EFER_LMA)\n\t\t\t\tmode = X86EMUL_MODE_PROT64;\n\t\t} else\n\t\t\tmode = X86EMUL_MODE_PROT32; /* temporary value */\n\t}\n#endif\n\tif (mode == X86EMUL_MODE_PROT16 || mode == X86EMUL_MODE_PROT32)\n\t\tmode = cs_desc->d ? X86EMUL_MODE_PROT32 : X86EMUL_MODE_PROT16;\n\trc = assign_eip(ctxt, dst, mode);\n\tif (rc == X86EMUL_CONTINUE)\n\t\tctxt->mode = mode;\n\treturn rc;\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int assign_eip_far(struct x86_emulate_ctxt *ctxt, ulong dst,\n\t\t\t  const struct desc_struct *cs_desc)\n{\n\tenum x86emul_mode mode = ctxt->mode;\n\tint rc;\n\n#ifdef CONFIG_X86_64\n\tif (ctxt->mode >= X86EMUL_MODE_PROT16) {\n\t\tif (cs_desc->l) {\n\t\t\tu64 efer = 0;\n\n\t\t\tctxt->ops->get_msr(ctxt, MSR_EFER, &efer);\n\t\t\tif (efer & EFER_LMA)\n\t\t\t\tmode = X86EMUL_MODE_PROT64;\n\t\t} else\n\t\t\tmode = X86EMUL_MODE_PROT32; /* temporary value */\n\t}\n#endif\n\tif (mode == X86EMUL_MODE_PROT16 || mode == X86EMUL_MODE_PROT32)\n\t\tmode = cs_desc->d ? X86EMUL_MODE_PROT32 : X86EMUL_MODE_PROT16;\n\trc = assign_eip(ctxt, dst, mode);\n\tif (rc == X86EMUL_CONTINUE)\n\t\tctxt->mode = mode;\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline int assign_eip_near(struct x86_emulate_ctxt *ctxt, ulong dst)\n{\n\treturn assign_eip(ctxt, dst, ctxt->mode);\n}"
  },
  {
    "function_name": "assign_eip",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "728-743",
    "snippet": "static inline int assign_eip(struct x86_emulate_ctxt *ctxt, ulong dst,\n\t\t\t     enum x86emul_mode mode)\n{\n\tulong linear;\n\tint rc;\n\tunsigned max_size;\n\tstruct segmented_address addr = { .seg = VCPU_SREG_CS,\n\t\t\t\t\t   .ea = dst };\n\n\tif (ctxt->op_bytes != sizeof(unsigned long))\n\t\taddr.ea = dst & ((1UL << (ctxt->op_bytes << 3)) - 1);\n\trc = __linearize(ctxt, addr, &max_size, 1, false, true, mode, &linear);\n\tif (rc == X86EMUL_CONTINUE)\n\t\tctxt->_eip = addr.ea;\n\treturn rc;\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__linearize",
          "args": [
            "ctxt",
            "addr",
            "&max_size",
            "1",
            "false",
            "true",
            "mode",
            "&linear"
          ],
          "line": 739
        },
        "resolved": true,
        "details": {
          "function_name": "__linearize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "653-716",
          "snippet": "static __always_inline int __linearize(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t       struct segmented_address addr,\n\t\t\t\t       unsigned *max_size, unsigned size,\n\t\t\t\t       bool write, bool fetch,\n\t\t\t\t       enum x86emul_mode mode, ulong *linear)\n{\n\tstruct desc_struct desc;\n\tbool usable;\n\tulong la;\n\tu32 lim;\n\tu16 sel;\n\n\tla = seg_base(ctxt, addr.seg) + addr.ea;\n\t*max_size = 0;\n\tswitch (mode) {\n\tcase X86EMUL_MODE_PROT64:\n\t\t*linear = la;\n\t\tif (is_noncanonical_address(la))\n\t\t\tgoto bad;\n\n\t\t*max_size = min_t(u64, ~0u, (1ull << 48) - la);\n\t\tif (size > *max_size)\n\t\t\tgoto bad;\n\t\tbreak;\n\tdefault:\n\t\t*linear = la = (u32)la;\n\t\tusable = ctxt->ops->get_segment(ctxt, &sel, &desc, NULL,\n\t\t\t\t\t\taddr.seg);\n\t\tif (!usable)\n\t\t\tgoto bad;\n\t\t/* code segment in protected mode or read-only data segment */\n\t\tif ((((ctxt->mode != X86EMUL_MODE_REAL) && (desc.type & 8))\n\t\t\t\t\t|| !(desc.type & 2)) && write)\n\t\t\tgoto bad;\n\t\t/* unreadable code segment */\n\t\tif (!fetch && (desc.type & 8) && !(desc.type & 2))\n\t\t\tgoto bad;\n\t\tlim = desc_limit_scaled(&desc);\n\t\tif (!(desc.type & 8) && (desc.type & 4)) {\n\t\t\t/* expand-down segment */\n\t\t\tif (addr.ea <= lim)\n\t\t\t\tgoto bad;\n\t\t\tlim = desc.d ? 0xffffffff : 0xffff;\n\t\t}\n\t\tif (addr.ea > lim)\n\t\t\tgoto bad;\n\t\tif (lim == 0xffffffff)\n\t\t\t*max_size = ~0u;\n\t\telse {\n\t\t\t*max_size = (u64)lim + 1 - addr.ea;\n\t\t\tif (size > *max_size)\n\t\t\t\tgoto bad;\n\t\t}\n\t\tbreak;\n\t}\n\tif (insn_aligned(ctxt, size) && ((la & (size - 1)) != 0))\n\t\treturn emulate_gp(ctxt, 0);\n\treturn X86EMUL_CONTINUE;\nbad:\n\tif (addr.seg == VCPU_SREG_SS)\n\t\treturn emulate_ss(ctxt, 0);\n\telse\n\t\treturn emulate_gp(ctxt, 0);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic __always_inline int __linearize(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t       struct segmented_address addr,\n\t\t\t\t       unsigned *max_size, unsigned size,\n\t\t\t\t       bool write, bool fetch,\n\t\t\t\t       enum x86emul_mode mode, ulong *linear)\n{\n\tstruct desc_struct desc;\n\tbool usable;\n\tulong la;\n\tu32 lim;\n\tu16 sel;\n\n\tla = seg_base(ctxt, addr.seg) + addr.ea;\n\t*max_size = 0;\n\tswitch (mode) {\n\tcase X86EMUL_MODE_PROT64:\n\t\t*linear = la;\n\t\tif (is_noncanonical_address(la))\n\t\t\tgoto bad;\n\n\t\t*max_size = min_t(u64, ~0u, (1ull << 48) - la);\n\t\tif (size > *max_size)\n\t\t\tgoto bad;\n\t\tbreak;\n\tdefault:\n\t\t*linear = la = (u32)la;\n\t\tusable = ctxt->ops->get_segment(ctxt, &sel, &desc, NULL,\n\t\t\t\t\t\taddr.seg);\n\t\tif (!usable)\n\t\t\tgoto bad;\n\t\t/* code segment in protected mode or read-only data segment */\n\t\tif ((((ctxt->mode != X86EMUL_MODE_REAL) && (desc.type & 8))\n\t\t\t\t\t|| !(desc.type & 2)) && write)\n\t\t\tgoto bad;\n\t\t/* unreadable code segment */\n\t\tif (!fetch && (desc.type & 8) && !(desc.type & 2))\n\t\t\tgoto bad;\n\t\tlim = desc_limit_scaled(&desc);\n\t\tif (!(desc.type & 8) && (desc.type & 4)) {\n\t\t\t/* expand-down segment */\n\t\t\tif (addr.ea <= lim)\n\t\t\t\tgoto bad;\n\t\t\tlim = desc.d ? 0xffffffff : 0xffff;\n\t\t}\n\t\tif (addr.ea > lim)\n\t\t\tgoto bad;\n\t\tif (lim == 0xffffffff)\n\t\t\t*max_size = ~0u;\n\t\telse {\n\t\t\t*max_size = (u64)lim + 1 - addr.ea;\n\t\t\tif (size > *max_size)\n\t\t\t\tgoto bad;\n\t\t}\n\t\tbreak;\n\t}\n\tif (insn_aligned(ctxt, size) && ((la & (size - 1)) != 0))\n\t\treturn emulate_gp(ctxt, 0);\n\treturn X86EMUL_CONTINUE;\nbad:\n\tif (addr.seg == VCPU_SREG_SS)\n\t\treturn emulate_ss(ctxt, 0);\n\telse\n\t\treturn emulate_gp(ctxt, 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline int assign_eip(struct x86_emulate_ctxt *ctxt, ulong dst,\n\t\t\t     enum x86emul_mode mode)\n{\n\tulong linear;\n\tint rc;\n\tunsigned max_size;\n\tstruct segmented_address addr = { .seg = VCPU_SREG_CS,\n\t\t\t\t\t   .ea = dst };\n\n\tif (ctxt->op_bytes != sizeof(unsigned long))\n\t\taddr.ea = dst & ((1UL << (ctxt->op_bytes << 3)) - 1);\n\trc = __linearize(ctxt, addr, &max_size, 1, false, true, mode, &linear);\n\tif (rc == X86EMUL_CONTINUE)\n\t\tctxt->_eip = addr.ea;\n\treturn rc;\n}"
  },
  {
    "function_name": "linearize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "718-726",
    "snippet": "static int linearize(struct x86_emulate_ctxt *ctxt,\n\t\t     struct segmented_address addr,\n\t\t     unsigned size, bool write,\n\t\t     ulong *linear)\n{\n\tunsigned max_size;\n\treturn __linearize(ctxt, addr, &max_size, size, write, false,\n\t\t\t   ctxt->mode, linear);\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__linearize",
          "args": [
            "ctxt",
            "addr",
            "&max_size",
            "size",
            "write",
            "false",
            "ctxt->mode",
            "linear"
          ],
          "line": 724
        },
        "resolved": true,
        "details": {
          "function_name": "__linearize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "653-716",
          "snippet": "static __always_inline int __linearize(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t       struct segmented_address addr,\n\t\t\t\t       unsigned *max_size, unsigned size,\n\t\t\t\t       bool write, bool fetch,\n\t\t\t\t       enum x86emul_mode mode, ulong *linear)\n{\n\tstruct desc_struct desc;\n\tbool usable;\n\tulong la;\n\tu32 lim;\n\tu16 sel;\n\n\tla = seg_base(ctxt, addr.seg) + addr.ea;\n\t*max_size = 0;\n\tswitch (mode) {\n\tcase X86EMUL_MODE_PROT64:\n\t\t*linear = la;\n\t\tif (is_noncanonical_address(la))\n\t\t\tgoto bad;\n\n\t\t*max_size = min_t(u64, ~0u, (1ull << 48) - la);\n\t\tif (size > *max_size)\n\t\t\tgoto bad;\n\t\tbreak;\n\tdefault:\n\t\t*linear = la = (u32)la;\n\t\tusable = ctxt->ops->get_segment(ctxt, &sel, &desc, NULL,\n\t\t\t\t\t\taddr.seg);\n\t\tif (!usable)\n\t\t\tgoto bad;\n\t\t/* code segment in protected mode or read-only data segment */\n\t\tif ((((ctxt->mode != X86EMUL_MODE_REAL) && (desc.type & 8))\n\t\t\t\t\t|| !(desc.type & 2)) && write)\n\t\t\tgoto bad;\n\t\t/* unreadable code segment */\n\t\tif (!fetch && (desc.type & 8) && !(desc.type & 2))\n\t\t\tgoto bad;\n\t\tlim = desc_limit_scaled(&desc);\n\t\tif (!(desc.type & 8) && (desc.type & 4)) {\n\t\t\t/* expand-down segment */\n\t\t\tif (addr.ea <= lim)\n\t\t\t\tgoto bad;\n\t\t\tlim = desc.d ? 0xffffffff : 0xffff;\n\t\t}\n\t\tif (addr.ea > lim)\n\t\t\tgoto bad;\n\t\tif (lim == 0xffffffff)\n\t\t\t*max_size = ~0u;\n\t\telse {\n\t\t\t*max_size = (u64)lim + 1 - addr.ea;\n\t\t\tif (size > *max_size)\n\t\t\t\tgoto bad;\n\t\t}\n\t\tbreak;\n\t}\n\tif (insn_aligned(ctxt, size) && ((la & (size - 1)) != 0))\n\t\treturn emulate_gp(ctxt, 0);\n\treturn X86EMUL_CONTINUE;\nbad:\n\tif (addr.seg == VCPU_SREG_SS)\n\t\treturn emulate_ss(ctxt, 0);\n\telse\n\t\treturn emulate_gp(ctxt, 0);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic __always_inline int __linearize(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t       struct segmented_address addr,\n\t\t\t\t       unsigned *max_size, unsigned size,\n\t\t\t\t       bool write, bool fetch,\n\t\t\t\t       enum x86emul_mode mode, ulong *linear)\n{\n\tstruct desc_struct desc;\n\tbool usable;\n\tulong la;\n\tu32 lim;\n\tu16 sel;\n\n\tla = seg_base(ctxt, addr.seg) + addr.ea;\n\t*max_size = 0;\n\tswitch (mode) {\n\tcase X86EMUL_MODE_PROT64:\n\t\t*linear = la;\n\t\tif (is_noncanonical_address(la))\n\t\t\tgoto bad;\n\n\t\t*max_size = min_t(u64, ~0u, (1ull << 48) - la);\n\t\tif (size > *max_size)\n\t\t\tgoto bad;\n\t\tbreak;\n\tdefault:\n\t\t*linear = la = (u32)la;\n\t\tusable = ctxt->ops->get_segment(ctxt, &sel, &desc, NULL,\n\t\t\t\t\t\taddr.seg);\n\t\tif (!usable)\n\t\t\tgoto bad;\n\t\t/* code segment in protected mode or read-only data segment */\n\t\tif ((((ctxt->mode != X86EMUL_MODE_REAL) && (desc.type & 8))\n\t\t\t\t\t|| !(desc.type & 2)) && write)\n\t\t\tgoto bad;\n\t\t/* unreadable code segment */\n\t\tif (!fetch && (desc.type & 8) && !(desc.type & 2))\n\t\t\tgoto bad;\n\t\tlim = desc_limit_scaled(&desc);\n\t\tif (!(desc.type & 8) && (desc.type & 4)) {\n\t\t\t/* expand-down segment */\n\t\t\tif (addr.ea <= lim)\n\t\t\t\tgoto bad;\n\t\t\tlim = desc.d ? 0xffffffff : 0xffff;\n\t\t}\n\t\tif (addr.ea > lim)\n\t\t\tgoto bad;\n\t\tif (lim == 0xffffffff)\n\t\t\t*max_size = ~0u;\n\t\telse {\n\t\t\t*max_size = (u64)lim + 1 - addr.ea;\n\t\t\tif (size > *max_size)\n\t\t\t\tgoto bad;\n\t\t}\n\t\tbreak;\n\t}\n\tif (insn_aligned(ctxt, size) && ((la & (size - 1)) != 0))\n\t\treturn emulate_gp(ctxt, 0);\n\treturn X86EMUL_CONTINUE;\nbad:\n\tif (addr.seg == VCPU_SREG_SS)\n\t\treturn emulate_ss(ctxt, 0);\n\telse\n\t\treturn emulate_gp(ctxt, 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int linearize(struct x86_emulate_ctxt *ctxt,\n\t\t     struct segmented_address addr,\n\t\t     unsigned size, bool write,\n\t\t     ulong *linear)\n{\n\tunsigned max_size;\n\treturn __linearize(ctxt, addr, &max_size, size, write, false,\n\t\t\t   ctxt->mode, linear);\n}"
  },
  {
    "function_name": "__linearize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "653-716",
    "snippet": "static __always_inline int __linearize(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t       struct segmented_address addr,\n\t\t\t\t       unsigned *max_size, unsigned size,\n\t\t\t\t       bool write, bool fetch,\n\t\t\t\t       enum x86emul_mode mode, ulong *linear)\n{\n\tstruct desc_struct desc;\n\tbool usable;\n\tulong la;\n\tu32 lim;\n\tu16 sel;\n\n\tla = seg_base(ctxt, addr.seg) + addr.ea;\n\t*max_size = 0;\n\tswitch (mode) {\n\tcase X86EMUL_MODE_PROT64:\n\t\t*linear = la;\n\t\tif (is_noncanonical_address(la))\n\t\t\tgoto bad;\n\n\t\t*max_size = min_t(u64, ~0u, (1ull << 48) - la);\n\t\tif (size > *max_size)\n\t\t\tgoto bad;\n\t\tbreak;\n\tdefault:\n\t\t*linear = la = (u32)la;\n\t\tusable = ctxt->ops->get_segment(ctxt, &sel, &desc, NULL,\n\t\t\t\t\t\taddr.seg);\n\t\tif (!usable)\n\t\t\tgoto bad;\n\t\t/* code segment in protected mode or read-only data segment */\n\t\tif ((((ctxt->mode != X86EMUL_MODE_REAL) && (desc.type & 8))\n\t\t\t\t\t|| !(desc.type & 2)) && write)\n\t\t\tgoto bad;\n\t\t/* unreadable code segment */\n\t\tif (!fetch && (desc.type & 8) && !(desc.type & 2))\n\t\t\tgoto bad;\n\t\tlim = desc_limit_scaled(&desc);\n\t\tif (!(desc.type & 8) && (desc.type & 4)) {\n\t\t\t/* expand-down segment */\n\t\t\tif (addr.ea <= lim)\n\t\t\t\tgoto bad;\n\t\t\tlim = desc.d ? 0xffffffff : 0xffff;\n\t\t}\n\t\tif (addr.ea > lim)\n\t\t\tgoto bad;\n\t\tif (lim == 0xffffffff)\n\t\t\t*max_size = ~0u;\n\t\telse {\n\t\t\t*max_size = (u64)lim + 1 - addr.ea;\n\t\t\tif (size > *max_size)\n\t\t\t\tgoto bad;\n\t\t}\n\t\tbreak;\n\t}\n\tif (insn_aligned(ctxt, size) && ((la & (size - 1)) != 0))\n\t\treturn emulate_gp(ctxt, 0);\n\treturn X86EMUL_CONTINUE;\nbad:\n\tif (addr.seg == VCPU_SREG_SS)\n\t\treturn emulate_ss(ctxt, 0);\n\telse\n\t\treturn emulate_gp(ctxt, 0);\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "emulate_gp",
          "args": [
            "ctxt",
            "0"
          ],
          "line": 715
        },
        "resolved": true,
        "details": {
          "function_name": "emulate_gp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "580-583",
          "snippet": "static int emulate_gp(struct x86_emulate_ctxt *ctxt, int err)\n{\n\treturn emulate_exception(ctxt, GP_VECTOR, err, true);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int emulate_gp(struct x86_emulate_ctxt *ctxt, int err)\n{\n\treturn emulate_exception(ctxt, GP_VECTOR, err, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "emulate_ss",
          "args": [
            "ctxt",
            "0"
          ],
          "line": 713
        },
        "resolved": true,
        "details": {
          "function_name": "emulate_ss",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "585-588",
          "snippet": "static int emulate_ss(struct x86_emulate_ctxt *ctxt, int err)\n{\n\treturn emulate_exception(ctxt, SS_VECTOR, err, true);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int emulate_ss(struct x86_emulate_ctxt *ctxt, int err)\n{\n\treturn emulate_exception(ctxt, SS_VECTOR, err, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "insn_aligned",
          "args": [
            "ctxt",
            "size"
          ],
          "line": 708
        },
        "resolved": true,
        "details": {
          "function_name": "insn_aligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "638-651",
          "snippet": "static bool insn_aligned(struct x86_emulate_ctxt *ctxt, unsigned size)\n{\n\tif (likely(size < 16))\n\t\treturn false;\n\n\tif (ctxt->d & Aligned)\n\t\treturn true;\n\telse if (ctxt->d & Unaligned)\n\t\treturn false;\n\telse if (ctxt->d & Avx)\n\t\treturn false;\n\telse\n\t\treturn true;\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define Avx         ((u64)1 << 43)  /* Advanced Vector Extensions */",
            "#define Unaligned   ((u64)1 << 42)  /* Explicitly unaligned (e.g. MOVDQU) */",
            "#define Aligned     ((u64)1 << 41)  /* Explicitly aligned (e.g. MOVDQA) */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\n#define Avx         ((u64)1 << 43)  /* Advanced Vector Extensions */\n#define Unaligned   ((u64)1 << 42)  /* Explicitly unaligned (e.g. MOVDQU) */\n#define Aligned     ((u64)1 << 41)  /* Explicitly aligned (e.g. MOVDQA) */\n\nstatic bool insn_aligned(struct x86_emulate_ctxt *ctxt, unsigned size)\n{\n\tif (likely(size < 16))\n\t\treturn false;\n\n\tif (ctxt->d & Aligned)\n\t\treturn true;\n\telse if (ctxt->d & Unaligned)\n\t\treturn false;\n\telse if (ctxt->d & Avx)\n\t\treturn false;\n\telse\n\t\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "desc_limit_scaled",
          "args": [
            "&desc"
          ],
          "line": 690
        },
        "resolved": true,
        "details": {
          "function_name": "desc_limit_scaled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "550-555",
          "snippet": "static u32 desc_limit_scaled(struct desc_struct *desc)\n{\n\tu32 limit = get_desc_limit(desc);\n\n\treturn desc->g ? (limit << 12) | 0xfff : limit;\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic u32 desc_limit_scaled(struct desc_struct *desc)\n{\n\tu32 limit = get_desc_limit(desc);\n\n\treturn desc->g ? (limit << 12) | 0xfff : limit;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ctxt->ops->get_segment",
          "args": [
            "ctxt",
            "&sel",
            "&desc",
            "NULL",
            "addr.seg"
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "u64",
            "~0u",
            "(1ull << 48) - la"
          ],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_noncanonical_address",
          "args": [
            "la"
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seg_base",
          "args": [
            "ctxt",
            "addr.seg"
          ],
          "line": 665
        },
        "resolved": true,
        "details": {
          "function_name": "seg_base",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "557-563",
          "snippet": "static unsigned long seg_base(struct x86_emulate_ctxt *ctxt, int seg)\n{\n\tif (ctxt->mode == X86EMUL_MODE_PROT64 && seg < VCPU_SREG_FS)\n\t\treturn 0;\n\n\treturn ctxt->ops->get_cached_segment_base(ctxt, seg);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic unsigned long seg_base(struct x86_emulate_ctxt *ctxt, int seg)\n{\n\tif (ctxt->mode == X86EMUL_MODE_PROT64 && seg < VCPU_SREG_FS)\n\t\treturn 0;\n\n\treturn ctxt->ops->get_cached_segment_base(ctxt, seg);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic __always_inline int __linearize(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t       struct segmented_address addr,\n\t\t\t\t       unsigned *max_size, unsigned size,\n\t\t\t\t       bool write, bool fetch,\n\t\t\t\t       enum x86emul_mode mode, ulong *linear)\n{\n\tstruct desc_struct desc;\n\tbool usable;\n\tulong la;\n\tu32 lim;\n\tu16 sel;\n\n\tla = seg_base(ctxt, addr.seg) + addr.ea;\n\t*max_size = 0;\n\tswitch (mode) {\n\tcase X86EMUL_MODE_PROT64:\n\t\t*linear = la;\n\t\tif (is_noncanonical_address(la))\n\t\t\tgoto bad;\n\n\t\t*max_size = min_t(u64, ~0u, (1ull << 48) - la);\n\t\tif (size > *max_size)\n\t\t\tgoto bad;\n\t\tbreak;\n\tdefault:\n\t\t*linear = la = (u32)la;\n\t\tusable = ctxt->ops->get_segment(ctxt, &sel, &desc, NULL,\n\t\t\t\t\t\taddr.seg);\n\t\tif (!usable)\n\t\t\tgoto bad;\n\t\t/* code segment in protected mode or read-only data segment */\n\t\tif ((((ctxt->mode != X86EMUL_MODE_REAL) && (desc.type & 8))\n\t\t\t\t\t|| !(desc.type & 2)) && write)\n\t\t\tgoto bad;\n\t\t/* unreadable code segment */\n\t\tif (!fetch && (desc.type & 8) && !(desc.type & 2))\n\t\t\tgoto bad;\n\t\tlim = desc_limit_scaled(&desc);\n\t\tif (!(desc.type & 8) && (desc.type & 4)) {\n\t\t\t/* expand-down segment */\n\t\t\tif (addr.ea <= lim)\n\t\t\t\tgoto bad;\n\t\t\tlim = desc.d ? 0xffffffff : 0xffff;\n\t\t}\n\t\tif (addr.ea > lim)\n\t\t\tgoto bad;\n\t\tif (lim == 0xffffffff)\n\t\t\t*max_size = ~0u;\n\t\telse {\n\t\t\t*max_size = (u64)lim + 1 - addr.ea;\n\t\t\tif (size > *max_size)\n\t\t\t\tgoto bad;\n\t\t}\n\t\tbreak;\n\t}\n\tif (insn_aligned(ctxt, size) && ((la & (size - 1)) != 0))\n\t\treturn emulate_gp(ctxt, 0);\n\treturn X86EMUL_CONTINUE;\nbad:\n\tif (addr.seg == VCPU_SREG_SS)\n\t\treturn emulate_ss(ctxt, 0);\n\telse\n\t\treturn emulate_gp(ctxt, 0);\n}"
  },
  {
    "function_name": "insn_aligned",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "638-651",
    "snippet": "static bool insn_aligned(struct x86_emulate_ctxt *ctxt, unsigned size)\n{\n\tif (likely(size < 16))\n\t\treturn false;\n\n\tif (ctxt->d & Aligned)\n\t\treturn true;\n\telse if (ctxt->d & Unaligned)\n\t\treturn false;\n\telse if (ctxt->d & Avx)\n\t\treturn false;\n\telse\n\t\treturn true;\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define Avx         ((u64)1 << 43)  /* Advanced Vector Extensions */",
      "#define Unaligned   ((u64)1 << 42)  /* Explicitly unaligned (e.g. MOVDQU) */",
      "#define Aligned     ((u64)1 << 41)  /* Explicitly aligned (e.g. MOVDQA) */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "size < 16"
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\n#define Avx         ((u64)1 << 43)  /* Advanced Vector Extensions */\n#define Unaligned   ((u64)1 << 42)  /* Explicitly unaligned (e.g. MOVDQU) */\n#define Aligned     ((u64)1 << 41)  /* Explicitly aligned (e.g. MOVDQA) */\n\nstatic bool insn_aligned(struct x86_emulate_ctxt *ctxt, unsigned size)\n{\n\tif (likely(size < 16))\n\t\treturn false;\n\n\tif (ctxt->d & Aligned)\n\t\treturn true;\n\telse if (ctxt->d & Unaligned)\n\t\treturn false;\n\telse if (ctxt->d & Avx)\n\t\treturn false;\n\telse\n\t\treturn true;\n}"
  },
  {
    "function_name": "set_segment_selector",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "619-628",
    "snippet": "static void set_segment_selector(struct x86_emulate_ctxt *ctxt, u16 selector,\n\t\t\t\t unsigned seg)\n{\n\tu16 dummy;\n\tu32 base3;\n\tstruct desc_struct desc;\n\n\tctxt->ops->get_segment(ctxt, &dummy, &desc, &base3, seg);\n\tctxt->ops->set_segment(ctxt, selector, &desc, base3, seg);\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ctxt->ops->set_segment",
          "args": [
            "ctxt",
            "selector",
            "&desc",
            "base3",
            "seg"
          ],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ctxt->ops->get_segment",
          "args": [
            "ctxt",
            "&dummy",
            "&desc",
            "&base3",
            "seg"
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic void set_segment_selector(struct x86_emulate_ctxt *ctxt, u16 selector,\n\t\t\t\t unsigned seg)\n{\n\tu16 dummy;\n\tu32 base3;\n\tstruct desc_struct desc;\n\n\tctxt->ops->get_segment(ctxt, &dummy, &desc, &base3, seg);\n\tctxt->ops->set_segment(ctxt, selector, &desc, base3, seg);\n}"
  },
  {
    "function_name": "get_segment_selector",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "610-617",
    "snippet": "static u16 get_segment_selector(struct x86_emulate_ctxt *ctxt, unsigned seg)\n{\n\tu16 selector;\n\tstruct desc_struct desc;\n\n\tctxt->ops->get_segment(ctxt, &selector, &desc, NULL, seg);\n\treturn selector;\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ctxt->ops->get_segment",
          "args": [
            "ctxt",
            "&selector",
            "&desc",
            "NULL",
            "seg"
          ],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic u16 get_segment_selector(struct x86_emulate_ctxt *ctxt, unsigned seg)\n{\n\tu16 selector;\n\tstruct desc_struct desc;\n\n\tctxt->ops->get_segment(ctxt, &selector, &desc, NULL, seg);\n\treturn selector;\n}"
  },
  {
    "function_name": "emulate_nm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "605-608",
    "snippet": "static int emulate_nm(struct x86_emulate_ctxt *ctxt)\n{\n\treturn emulate_exception(ctxt, NM_VECTOR, 0, false);\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "emulate_exception",
          "args": [
            "ctxt",
            "NM_VECTOR",
            "0",
            "false"
          ],
          "line": 607
        },
        "resolved": true,
        "details": {
          "function_name": "emulate_exception",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "565-573",
          "snippet": "static int emulate_exception(struct x86_emulate_ctxt *ctxt, int vec,\n\t\t\t     u32 error, bool valid)\n{\n\tWARN_ON(vec > 0x1f);\n\tctxt->exception.vector = vec;\n\tctxt->exception.error_code = error;\n\tctxt->exception.error_code_valid = valid;\n\treturn X86EMUL_PROPAGATE_FAULT;\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int emulate_exception(struct x86_emulate_ctxt *ctxt, int vec,\n\t\t\t     u32 error, bool valid)\n{\n\tWARN_ON(vec > 0x1f);\n\tctxt->exception.vector = vec;\n\tctxt->exception.error_code = error;\n\tctxt->exception.error_code_valid = valid;\n\treturn X86EMUL_PROPAGATE_FAULT;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int emulate_nm(struct x86_emulate_ctxt *ctxt)\n{\n\treturn emulate_exception(ctxt, NM_VECTOR, 0, false);\n}"
  },
  {
    "function_name": "emulate_de",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "600-603",
    "snippet": "static int emulate_de(struct x86_emulate_ctxt *ctxt)\n{\n\treturn emulate_exception(ctxt, DE_VECTOR, 0, false);\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "emulate_exception",
          "args": [
            "ctxt",
            "DE_VECTOR",
            "0",
            "false"
          ],
          "line": 602
        },
        "resolved": true,
        "details": {
          "function_name": "emulate_exception",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "565-573",
          "snippet": "static int emulate_exception(struct x86_emulate_ctxt *ctxt, int vec,\n\t\t\t     u32 error, bool valid)\n{\n\tWARN_ON(vec > 0x1f);\n\tctxt->exception.vector = vec;\n\tctxt->exception.error_code = error;\n\tctxt->exception.error_code_valid = valid;\n\treturn X86EMUL_PROPAGATE_FAULT;\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int emulate_exception(struct x86_emulate_ctxt *ctxt, int vec,\n\t\t\t     u32 error, bool valid)\n{\n\tWARN_ON(vec > 0x1f);\n\tctxt->exception.vector = vec;\n\tctxt->exception.error_code = error;\n\tctxt->exception.error_code_valid = valid;\n\treturn X86EMUL_PROPAGATE_FAULT;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int emulate_de(struct x86_emulate_ctxt *ctxt)\n{\n\treturn emulate_exception(ctxt, DE_VECTOR, 0, false);\n}"
  },
  {
    "function_name": "emulate_ts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "595-598",
    "snippet": "static int emulate_ts(struct x86_emulate_ctxt *ctxt, int err)\n{\n\treturn emulate_exception(ctxt, TS_VECTOR, err, true);\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "emulate_exception",
          "args": [
            "ctxt",
            "TS_VECTOR",
            "err",
            "true"
          ],
          "line": 597
        },
        "resolved": true,
        "details": {
          "function_name": "emulate_exception",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "565-573",
          "snippet": "static int emulate_exception(struct x86_emulate_ctxt *ctxt, int vec,\n\t\t\t     u32 error, bool valid)\n{\n\tWARN_ON(vec > 0x1f);\n\tctxt->exception.vector = vec;\n\tctxt->exception.error_code = error;\n\tctxt->exception.error_code_valid = valid;\n\treturn X86EMUL_PROPAGATE_FAULT;\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int emulate_exception(struct x86_emulate_ctxt *ctxt, int vec,\n\t\t\t     u32 error, bool valid)\n{\n\tWARN_ON(vec > 0x1f);\n\tctxt->exception.vector = vec;\n\tctxt->exception.error_code = error;\n\tctxt->exception.error_code_valid = valid;\n\treturn X86EMUL_PROPAGATE_FAULT;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int emulate_ts(struct x86_emulate_ctxt *ctxt, int err)\n{\n\treturn emulate_exception(ctxt, TS_VECTOR, err, true);\n}"
  },
  {
    "function_name": "emulate_ud",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "590-593",
    "snippet": "static int emulate_ud(struct x86_emulate_ctxt *ctxt)\n{\n\treturn emulate_exception(ctxt, UD_VECTOR, 0, false);\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "emulate_exception",
          "args": [
            "ctxt",
            "UD_VECTOR",
            "0",
            "false"
          ],
          "line": 592
        },
        "resolved": true,
        "details": {
          "function_name": "emulate_exception",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "565-573",
          "snippet": "static int emulate_exception(struct x86_emulate_ctxt *ctxt, int vec,\n\t\t\t     u32 error, bool valid)\n{\n\tWARN_ON(vec > 0x1f);\n\tctxt->exception.vector = vec;\n\tctxt->exception.error_code = error;\n\tctxt->exception.error_code_valid = valid;\n\treturn X86EMUL_PROPAGATE_FAULT;\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int emulate_exception(struct x86_emulate_ctxt *ctxt, int vec,\n\t\t\t     u32 error, bool valid)\n{\n\tWARN_ON(vec > 0x1f);\n\tctxt->exception.vector = vec;\n\tctxt->exception.error_code = error;\n\tctxt->exception.error_code_valid = valid;\n\treturn X86EMUL_PROPAGATE_FAULT;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int emulate_ud(struct x86_emulate_ctxt *ctxt)\n{\n\treturn emulate_exception(ctxt, UD_VECTOR, 0, false);\n}"
  },
  {
    "function_name": "emulate_ss",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "585-588",
    "snippet": "static int emulate_ss(struct x86_emulate_ctxt *ctxt, int err)\n{\n\treturn emulate_exception(ctxt, SS_VECTOR, err, true);\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "emulate_exception",
          "args": [
            "ctxt",
            "SS_VECTOR",
            "err",
            "true"
          ],
          "line": 587
        },
        "resolved": true,
        "details": {
          "function_name": "emulate_exception",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "565-573",
          "snippet": "static int emulate_exception(struct x86_emulate_ctxt *ctxt, int vec,\n\t\t\t     u32 error, bool valid)\n{\n\tWARN_ON(vec > 0x1f);\n\tctxt->exception.vector = vec;\n\tctxt->exception.error_code = error;\n\tctxt->exception.error_code_valid = valid;\n\treturn X86EMUL_PROPAGATE_FAULT;\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int emulate_exception(struct x86_emulate_ctxt *ctxt, int vec,\n\t\t\t     u32 error, bool valid)\n{\n\tWARN_ON(vec > 0x1f);\n\tctxt->exception.vector = vec;\n\tctxt->exception.error_code = error;\n\tctxt->exception.error_code_valid = valid;\n\treturn X86EMUL_PROPAGATE_FAULT;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int emulate_ss(struct x86_emulate_ctxt *ctxt, int err)\n{\n\treturn emulate_exception(ctxt, SS_VECTOR, err, true);\n}"
  },
  {
    "function_name": "emulate_gp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "580-583",
    "snippet": "static int emulate_gp(struct x86_emulate_ctxt *ctxt, int err)\n{\n\treturn emulate_exception(ctxt, GP_VECTOR, err, true);\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "emulate_exception",
          "args": [
            "ctxt",
            "GP_VECTOR",
            "err",
            "true"
          ],
          "line": 582
        },
        "resolved": true,
        "details": {
          "function_name": "emulate_exception",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "565-573",
          "snippet": "static int emulate_exception(struct x86_emulate_ctxt *ctxt, int vec,\n\t\t\t     u32 error, bool valid)\n{\n\tWARN_ON(vec > 0x1f);\n\tctxt->exception.vector = vec;\n\tctxt->exception.error_code = error;\n\tctxt->exception.error_code_valid = valid;\n\treturn X86EMUL_PROPAGATE_FAULT;\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int emulate_exception(struct x86_emulate_ctxt *ctxt, int vec,\n\t\t\t     u32 error, bool valid)\n{\n\tWARN_ON(vec > 0x1f);\n\tctxt->exception.vector = vec;\n\tctxt->exception.error_code = error;\n\tctxt->exception.error_code_valid = valid;\n\treturn X86EMUL_PROPAGATE_FAULT;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int emulate_gp(struct x86_emulate_ctxt *ctxt, int err)\n{\n\treturn emulate_exception(ctxt, GP_VECTOR, err, true);\n}"
  },
  {
    "function_name": "emulate_db",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "575-578",
    "snippet": "static int emulate_db(struct x86_emulate_ctxt *ctxt)\n{\n\treturn emulate_exception(ctxt, DB_VECTOR, 0, false);\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "emulate_exception",
          "args": [
            "ctxt",
            "DB_VECTOR",
            "0",
            "false"
          ],
          "line": 577
        },
        "resolved": true,
        "details": {
          "function_name": "emulate_exception",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "565-573",
          "snippet": "static int emulate_exception(struct x86_emulate_ctxt *ctxt, int vec,\n\t\t\t     u32 error, bool valid)\n{\n\tWARN_ON(vec > 0x1f);\n\tctxt->exception.vector = vec;\n\tctxt->exception.error_code = error;\n\tctxt->exception.error_code_valid = valid;\n\treturn X86EMUL_PROPAGATE_FAULT;\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int emulate_exception(struct x86_emulate_ctxt *ctxt, int vec,\n\t\t\t     u32 error, bool valid)\n{\n\tWARN_ON(vec > 0x1f);\n\tctxt->exception.vector = vec;\n\tctxt->exception.error_code = error;\n\tctxt->exception.error_code_valid = valid;\n\treturn X86EMUL_PROPAGATE_FAULT;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int emulate_db(struct x86_emulate_ctxt *ctxt)\n{\n\treturn emulate_exception(ctxt, DB_VECTOR, 0, false);\n}"
  },
  {
    "function_name": "emulate_exception",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "565-573",
    "snippet": "static int emulate_exception(struct x86_emulate_ctxt *ctxt, int vec,\n\t\t\t     u32 error, bool valid)\n{\n\tWARN_ON(vec > 0x1f);\n\tctxt->exception.vector = vec;\n\tctxt->exception.error_code = error;\n\tctxt->exception.error_code_valid = valid;\n\treturn X86EMUL_PROPAGATE_FAULT;\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "vec > 0x1f"
          ],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int emulate_exception(struct x86_emulate_ctxt *ctxt, int vec,\n\t\t\t     u32 error, bool valid)\n{\n\tWARN_ON(vec > 0x1f);\n\tctxt->exception.vector = vec;\n\tctxt->exception.error_code = error;\n\tctxt->exception.error_code_valid = valid;\n\treturn X86EMUL_PROPAGATE_FAULT;\n}"
  },
  {
    "function_name": "seg_base",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "557-563",
    "snippet": "static unsigned long seg_base(struct x86_emulate_ctxt *ctxt, int seg)\n{\n\tif (ctxt->mode == X86EMUL_MODE_PROT64 && seg < VCPU_SREG_FS)\n\t\treturn 0;\n\n\treturn ctxt->ops->get_cached_segment_base(ctxt, seg);\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ctxt->ops->get_cached_segment_base",
          "args": [
            "ctxt",
            "seg"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic unsigned long seg_base(struct x86_emulate_ctxt *ctxt, int seg)\n{\n\tif (ctxt->mode == X86EMUL_MODE_PROT64 && seg < VCPU_SREG_FS)\n\t\treturn 0;\n\n\treturn ctxt->ops->get_cached_segment_base(ctxt, seg);\n}"
  },
  {
    "function_name": "desc_limit_scaled",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "550-555",
    "snippet": "static u32 desc_limit_scaled(struct desc_struct *desc)\n{\n\tu32 limit = get_desc_limit(desc);\n\n\treturn desc->g ? (limit << 12) | 0xfff : limit;\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_desc_limit",
          "args": [
            "desc"
          ],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic u32 desc_limit_scaled(struct desc_struct *desc)\n{\n\tu32 limit = get_desc_limit(desc);\n\n\treturn desc->g ? (limit << 12) | 0xfff : limit;\n}"
  },
  {
    "function_name": "rsp_increment",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "545-548",
    "snippet": "static void rsp_increment(struct x86_emulate_ctxt *ctxt, int inc)\n{\n\tmasked_increment(reg_rmw(ctxt, VCPU_REGS_RSP), stack_mask(ctxt), inc);\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "masked_increment",
          "args": [
            "reg_rmw(ctxt, VCPU_REGS_RSP)",
            "stack_mask(ctxt)",
            "inc"
          ],
          "line": 547
        },
        "resolved": true,
        "details": {
          "function_name": "masked_increment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "532-535",
          "snippet": "static void masked_increment(ulong *reg, ulong mask, int inc)\n{\n\tassign_masked(reg, *reg + inc, mask);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic void masked_increment(ulong *reg, ulong mask, int inc)\n{\n\tassign_masked(reg, *reg + inc, mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "stack_mask",
          "args": [
            "ctxt"
          ],
          "line": 547
        },
        "resolved": true,
        "details": {
          "function_name": "stack_mask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "500-509",
          "snippet": "static ulong stack_mask(struct x86_emulate_ctxt *ctxt)\n{\n\tu16 sel;\n\tstruct desc_struct ss;\n\n\tif (ctxt->mode == X86EMUL_MODE_PROT64)\n\t\treturn ~0UL;\n\tctxt->ops->get_segment(ctxt, &sel, &ss, NULL, VCPU_SREG_SS);\n\treturn ~0U >> ((ss.d ^ 1) * 16);  /* d=0: 0xffff; d=1: 0xffffffff */\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic ulong stack_mask(struct x86_emulate_ctxt *ctxt)\n{\n\tu16 sel;\n\tstruct desc_struct ss;\n\n\tif (ctxt->mode == X86EMUL_MODE_PROT64)\n\t\treturn ~0UL;\n\tctxt->ops->get_segment(ctxt, &sel, &ss, NULL, VCPU_SREG_SS);\n\treturn ~0U >> ((ss.d ^ 1) * 16);  /* d=0: 0xffff; d=1: 0xffffffff */\n}"
        }
      },
      {
        "call_info": {
          "callee": "reg_rmw",
          "args": [
            "ctxt",
            "VCPU_REGS_RSP"
          ],
          "line": 547
        },
        "resolved": true,
        "details": {
          "function_name": "reg_rmw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "277-281",
          "snippet": "static ulong *reg_rmw(struct x86_emulate_ctxt *ctxt, unsigned nr)\n{\n\treg_read(ctxt, nr);\n\treturn reg_write(ctxt, nr);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic ulong *reg_rmw(struct x86_emulate_ctxt *ctxt, unsigned nr)\n{\n\treg_read(ctxt, nr);\n\treturn reg_write(ctxt, nr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic void rsp_increment(struct x86_emulate_ctxt *ctxt, int inc)\n{\n\tmasked_increment(reg_rmw(ctxt, VCPU_REGS_RSP), stack_mask(ctxt), inc);\n}"
  },
  {
    "function_name": "register_address_increment",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "537-543",
    "snippet": "static inline void\nregister_address_increment(struct x86_emulate_ctxt *ctxt, int reg, int inc)\n{\n\tulong *preg = reg_rmw(ctxt, reg);\n\n\tassign_register(preg, *preg + inc, ctxt->ad_bytes);\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "assign_register",
          "args": [
            "preg",
            "*preg + inc",
            "ctxt->ad_bytes"
          ],
          "line": 542
        },
        "resolved": true,
        "details": {
          "function_name": "assign_register",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "476-493",
          "snippet": "static void assign_register(unsigned long *reg, u64 val, int bytes)\n{\n\t/* The 4-byte case *is* correct: in 64-bit mode we zero-extend. */\n\tswitch (bytes) {\n\tcase 1:\n\t\t*(u8 *)reg = (u8)val;\n\t\tbreak;\n\tcase 2:\n\t\t*(u16 *)reg = (u16)val;\n\t\tbreak;\n\tcase 4:\n\t\t*reg = (u32)val;\n\t\tbreak;\t/* 64b: zero-extend */\n\tcase 8:\n\t\t*reg = val;\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic void assign_register(unsigned long *reg, u64 val, int bytes)\n{\n\t/* The 4-byte case *is* correct: in 64-bit mode we zero-extend. */\n\tswitch (bytes) {\n\tcase 1:\n\t\t*(u8 *)reg = (u8)val;\n\t\tbreak;\n\tcase 2:\n\t\t*(u16 *)reg = (u16)val;\n\t\tbreak;\n\tcase 4:\n\t\t*reg = (u32)val;\n\t\tbreak;\t/* 64b: zero-extend */\n\tcase 8:\n\t\t*reg = val;\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "reg_rmw",
          "args": [
            "ctxt",
            "reg"
          ],
          "line": 540
        },
        "resolved": true,
        "details": {
          "function_name": "reg_rmw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "277-281",
          "snippet": "static ulong *reg_rmw(struct x86_emulate_ctxt *ctxt, unsigned nr)\n{\n\treg_read(ctxt, nr);\n\treturn reg_write(ctxt, nr);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic ulong *reg_rmw(struct x86_emulate_ctxt *ctxt, unsigned nr)\n{\n\treg_read(ctxt, nr);\n\treturn reg_write(ctxt, nr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline void\nregister_address_increment(struct x86_emulate_ctxt *ctxt, int reg, int inc)\n{\n\tulong *preg = reg_rmw(ctxt, reg);\n\n\tassign_register(preg, *preg + inc, ctxt->ad_bytes);\n}"
  },
  {
    "function_name": "masked_increment",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "532-535",
    "snippet": "static void masked_increment(ulong *reg, ulong mask, int inc)\n{\n\tassign_masked(reg, *reg + inc, mask);\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "assign_masked",
          "args": [
            "reg",
            "*reg + inc",
            "mask"
          ],
          "line": 534
        },
        "resolved": true,
        "details": {
          "function_name": "assign_masked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "471-474",
          "snippet": "static void assign_masked(ulong *dest, ulong src, ulong mask)\n{\n\t*dest = (*dest & ~mask) | (src & mask);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic void assign_masked(ulong *dest, ulong src, ulong mask)\n{\n\t*dest = (*dest & ~mask) | (src & mask);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic void masked_increment(ulong *reg, ulong mask, int inc)\n{\n\tassign_masked(reg, *reg + inc, mask);\n}"
  },
  {
    "function_name": "register_address",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "526-530",
    "snippet": "static inline unsigned long\nregister_address(struct x86_emulate_ctxt *ctxt, int reg)\n{\n\treturn address_mask(ctxt, reg_read(ctxt, reg));\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "address_mask",
          "args": [
            "ctxt",
            "reg_read(ctxt, reg)"
          ],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "address_mask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "517-524",
          "snippet": "static inline unsigned long\naddress_mask(struct x86_emulate_ctxt *ctxt, unsigned long reg)\n{\n\tif (ctxt->ad_bytes == sizeof(unsigned long))\n\t\treturn reg;\n\telse\n\t\treturn reg & ad_mask(ctxt);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline unsigned long\naddress_mask(struct x86_emulate_ctxt *ctxt, unsigned long reg)\n{\n\tif (ctxt->ad_bytes == sizeof(unsigned long))\n\t\treturn reg;\n\telse\n\t\treturn reg & ad_mask(ctxt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reg_read",
          "args": [
            "ctxt",
            "reg"
          ],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "reg_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "261-268",
          "snippet": "static ulong reg_read(struct x86_emulate_ctxt *ctxt, unsigned nr)\n{\n\tif (!(ctxt->regs_valid & (1 << nr))) {\n\t\tctxt->regs_valid |= 1 << nr;\n\t\tctxt->_regs[nr] = ctxt->ops->read_gpr(ctxt, nr);\n\t}\n\treturn ctxt->_regs[nr];\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic ulong reg_read(struct x86_emulate_ctxt *ctxt, unsigned nr)\n{\n\tif (!(ctxt->regs_valid & (1 << nr))) {\n\t\tctxt->regs_valid |= 1 << nr;\n\t\tctxt->_regs[nr] = ctxt->ops->read_gpr(ctxt, nr);\n\t}\n\treturn ctxt->_regs[nr];\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline unsigned long\nregister_address(struct x86_emulate_ctxt *ctxt, int reg)\n{\n\treturn address_mask(ctxt, reg_read(ctxt, reg));\n}"
  },
  {
    "function_name": "address_mask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "517-524",
    "snippet": "static inline unsigned long\naddress_mask(struct x86_emulate_ctxt *ctxt, unsigned long reg)\n{\n\tif (ctxt->ad_bytes == sizeof(unsigned long))\n\t\treturn reg;\n\telse\n\t\treturn reg & ad_mask(ctxt);\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ad_mask",
          "args": [
            "ctxt"
          ],
          "line": 523
        },
        "resolved": true,
        "details": {
          "function_name": "ad_mask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "495-498",
          "snippet": "static inline unsigned long ad_mask(struct x86_emulate_ctxt *ctxt)\n{\n\treturn (1UL << (ctxt->ad_bytes << 3)) - 1;\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline unsigned long ad_mask(struct x86_emulate_ctxt *ctxt)\n{\n\treturn (1UL << (ctxt->ad_bytes << 3)) - 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline unsigned long\naddress_mask(struct x86_emulate_ctxt *ctxt, unsigned long reg)\n{\n\tif (ctxt->ad_bytes == sizeof(unsigned long))\n\t\treturn reg;\n\telse\n\t\treturn reg & ad_mask(ctxt);\n}"
  },
  {
    "function_name": "stack_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "511-514",
    "snippet": "static int stack_size(struct x86_emulate_ctxt *ctxt)\n{\n\treturn (__fls(stack_mask(ctxt)) + 1) >> 3;\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__fls",
          "args": [
            "stack_mask(ctxt)"
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stack_mask",
          "args": [
            "ctxt"
          ],
          "line": 513
        },
        "resolved": true,
        "details": {
          "function_name": "stack_mask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "500-509",
          "snippet": "static ulong stack_mask(struct x86_emulate_ctxt *ctxt)\n{\n\tu16 sel;\n\tstruct desc_struct ss;\n\n\tif (ctxt->mode == X86EMUL_MODE_PROT64)\n\t\treturn ~0UL;\n\tctxt->ops->get_segment(ctxt, &sel, &ss, NULL, VCPU_SREG_SS);\n\treturn ~0U >> ((ss.d ^ 1) * 16);  /* d=0: 0xffff; d=1: 0xffffffff */\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic ulong stack_mask(struct x86_emulate_ctxt *ctxt)\n{\n\tu16 sel;\n\tstruct desc_struct ss;\n\n\tif (ctxt->mode == X86EMUL_MODE_PROT64)\n\t\treturn ~0UL;\n\tctxt->ops->get_segment(ctxt, &sel, &ss, NULL, VCPU_SREG_SS);\n\treturn ~0U >> ((ss.d ^ 1) * 16);  /* d=0: 0xffff; d=1: 0xffffffff */\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int stack_size(struct x86_emulate_ctxt *ctxt)\n{\n\treturn (__fls(stack_mask(ctxt)) + 1) >> 3;\n}"
  },
  {
    "function_name": "stack_mask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "500-509",
    "snippet": "static ulong stack_mask(struct x86_emulate_ctxt *ctxt)\n{\n\tu16 sel;\n\tstruct desc_struct ss;\n\n\tif (ctxt->mode == X86EMUL_MODE_PROT64)\n\t\treturn ~0UL;\n\tctxt->ops->get_segment(ctxt, &sel, &ss, NULL, VCPU_SREG_SS);\n\treturn ~0U >> ((ss.d ^ 1) * 16);  /* d=0: 0xffff; d=1: 0xffffffff */\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ctxt->ops->get_segment",
          "args": [
            "ctxt",
            "&sel",
            "&ss",
            "NULL",
            "VCPU_SREG_SS"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic ulong stack_mask(struct x86_emulate_ctxt *ctxt)\n{\n\tu16 sel;\n\tstruct desc_struct ss;\n\n\tif (ctxt->mode == X86EMUL_MODE_PROT64)\n\t\treturn ~0UL;\n\tctxt->ops->get_segment(ctxt, &sel, &ss, NULL, VCPU_SREG_SS);\n\treturn ~0U >> ((ss.d ^ 1) * 16);  /* d=0: 0xffff; d=1: 0xffffffff */\n}"
  },
  {
    "function_name": "ad_mask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "495-498",
    "snippet": "static inline unsigned long ad_mask(struct x86_emulate_ctxt *ctxt)\n{\n\treturn (1UL << (ctxt->ad_bytes << 3)) - 1;\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline unsigned long ad_mask(struct x86_emulate_ctxt *ctxt)\n{\n\treturn (1UL << (ctxt->ad_bytes << 3)) - 1;\n}"
  },
  {
    "function_name": "assign_register",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "476-493",
    "snippet": "static void assign_register(unsigned long *reg, u64 val, int bytes)\n{\n\t/* The 4-byte case *is* correct: in 64-bit mode we zero-extend. */\n\tswitch (bytes) {\n\tcase 1:\n\t\t*(u8 *)reg = (u8)val;\n\t\tbreak;\n\tcase 2:\n\t\t*(u16 *)reg = (u16)val;\n\t\tbreak;\n\tcase 4:\n\t\t*reg = (u32)val;\n\t\tbreak;\t/* 64b: zero-extend */\n\tcase 8:\n\t\t*reg = val;\n\t\tbreak;\n\t}\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic void assign_register(unsigned long *reg, u64 val, int bytes)\n{\n\t/* The 4-byte case *is* correct: in 64-bit mode we zero-extend. */\n\tswitch (bytes) {\n\tcase 1:\n\t\t*(u8 *)reg = (u8)val;\n\t\tbreak;\n\tcase 2:\n\t\t*(u16 *)reg = (u16)val;\n\t\tbreak;\n\tcase 4:\n\t\t*reg = (u32)val;\n\t\tbreak;\t/* 64b: zero-extend */\n\tcase 8:\n\t\t*reg = val;\n\t\tbreak;\n\t}\n}"
  },
  {
    "function_name": "assign_masked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "471-474",
    "snippet": "static void assign_masked(ulong *dest, ulong src, ulong mask)\n{\n\t*dest = (*dest & ~mask) | (src & mask);\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic void assign_masked(ulong *dest, ulong src, ulong mask)\n{\n\t*dest = (*dest & ~mask) | (src & mask);\n}"
  },
  {
    "function_name": "emulator_check_intercept",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "450-469",
    "snippet": "static int emulator_check_intercept(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t    enum x86_intercept intercept,\n\t\t\t\t    enum x86_intercept_stage stage)\n{\n\tstruct x86_instruction_info info = {\n\t\t.intercept  = intercept,\n\t\t.rep_prefix = ctxt->rep_prefix,\n\t\t.modrm_mod  = ctxt->modrm_mod,\n\t\t.modrm_reg  = ctxt->modrm_reg,\n\t\t.modrm_rm   = ctxt->modrm_rm,\n\t\t.src_val    = ctxt->src.val64,\n\t\t.dst_val    = ctxt->dst.val64,\n\t\t.src_bytes  = ctxt->src.bytes,\n\t\t.dst_bytes  = ctxt->dst.bytes,\n\t\t.ad_bytes   = ctxt->ad_bytes,\n\t\t.next_rip   = ctxt->eip,\n\t};\n\n\treturn ctxt->ops->intercept(ctxt, &info, stage);\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ctxt->ops->intercept",
          "args": [
            "ctxt",
            "&info",
            "stage"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int emulator_check_intercept(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t    enum x86_intercept intercept,\n\t\t\t\t    enum x86_intercept_stage stage)\n{\n\tstruct x86_instruction_info info = {\n\t\t.intercept  = intercept,\n\t\t.rep_prefix = ctxt->rep_prefix,\n\t\t.modrm_mod  = ctxt->modrm_mod,\n\t\t.modrm_reg  = ctxt->modrm_reg,\n\t\t.modrm_rm   = ctxt->modrm_rm,\n\t\t.src_val    = ctxt->src.val64,\n\t\t.dst_val    = ctxt->dst.val64,\n\t\t.src_bytes  = ctxt->src.bytes,\n\t\t.dst_bytes  = ctxt->dst.bytes,\n\t\t.ad_bytes   = ctxt->ad_bytes,\n\t\t.next_rip   = ctxt->eip,\n\t};\n\n\treturn ctxt->ops->intercept(ctxt, &info, stage);\n}"
  },
  {
    "function_name": "invalidate_registers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "291-295",
    "snippet": "static void invalidate_registers(struct x86_emulate_ctxt *ctxt)\n{\n\tctxt->regs_dirty = 0;\n\tctxt->regs_valid = 0;\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic void invalidate_registers(struct x86_emulate_ctxt *ctxt)\n{\n\tctxt->regs_dirty = 0;\n\tctxt->regs_valid = 0;\n}"
  },
  {
    "function_name": "writeback_registers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "283-289",
    "snippet": "static void writeback_registers(struct x86_emulate_ctxt *ctxt)\n{\n\tunsigned reg;\n\n\tfor_each_set_bit(reg, (ulong *)&ctxt->regs_dirty, 16)\n\t\tctxt->ops->write_gpr(ctxt, reg, ctxt->_regs[reg]);\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "for_each_set_bit",
          "args": [
            "ctxt",
            "reg",
            "ctxt->_regs[reg]"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_set_bit",
          "args": [
            "reg",
            "(ulong *)&ctxt->regs_dirty",
            "16"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic void writeback_registers(struct x86_emulate_ctxt *ctxt)\n{\n\tunsigned reg;\n\n\tfor_each_set_bit(reg, (ulong *)&ctxt->regs_dirty, 16)\n\t\tctxt->ops->write_gpr(ctxt, reg, ctxt->_regs[reg]);\n}"
  },
  {
    "function_name": "reg_rmw",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "277-281",
    "snippet": "static ulong *reg_rmw(struct x86_emulate_ctxt *ctxt, unsigned nr)\n{\n\treg_read(ctxt, nr);\n\treturn reg_write(ctxt, nr);\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reg_write",
          "args": [
            "ctxt",
            "nr"
          ],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "reg_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "270-275",
          "snippet": "static ulong *reg_write(struct x86_emulate_ctxt *ctxt, unsigned nr)\n{\n\tctxt->regs_valid |= 1 << nr;\n\tctxt->regs_dirty |= 1 << nr;\n\treturn &ctxt->_regs[nr];\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic ulong *reg_write(struct x86_emulate_ctxt *ctxt, unsigned nr)\n{\n\tctxt->regs_valid |= 1 << nr;\n\tctxt->regs_dirty |= 1 << nr;\n\treturn &ctxt->_regs[nr];\n}"
        }
      },
      {
        "call_info": {
          "callee": "reg_read",
          "args": [
            "ctxt",
            "nr"
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "reg_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "261-268",
          "snippet": "static ulong reg_read(struct x86_emulate_ctxt *ctxt, unsigned nr)\n{\n\tif (!(ctxt->regs_valid & (1 << nr))) {\n\t\tctxt->regs_valid |= 1 << nr;\n\t\tctxt->_regs[nr] = ctxt->ops->read_gpr(ctxt, nr);\n\t}\n\treturn ctxt->_regs[nr];\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic ulong reg_read(struct x86_emulate_ctxt *ctxt, unsigned nr)\n{\n\tif (!(ctxt->regs_valid & (1 << nr))) {\n\t\tctxt->regs_valid |= 1 << nr;\n\t\tctxt->_regs[nr] = ctxt->ops->read_gpr(ctxt, nr);\n\t}\n\treturn ctxt->_regs[nr];\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic ulong *reg_rmw(struct x86_emulate_ctxt *ctxt, unsigned nr)\n{\n\treg_read(ctxt, nr);\n\treturn reg_write(ctxt, nr);\n}"
  },
  {
    "function_name": "reg_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "270-275",
    "snippet": "static ulong *reg_write(struct x86_emulate_ctxt *ctxt, unsigned nr)\n{\n\tctxt->regs_valid |= 1 << nr;\n\tctxt->regs_dirty |= 1 << nr;\n\treturn &ctxt->_regs[nr];\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic ulong *reg_write(struct x86_emulate_ctxt *ctxt, unsigned nr)\n{\n\tctxt->regs_valid |= 1 << nr;\n\tctxt->regs_dirty |= 1 << nr;\n\treturn &ctxt->_regs[nr];\n}"
  },
  {
    "function_name": "reg_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
    "lines": "261-268",
    "snippet": "static ulong reg_read(struct x86_emulate_ctxt *ctxt, unsigned nr)\n{\n\tif (!(ctxt->regs_valid & (1 << nr))) {\n\t\tctxt->regs_valid |= 1 << nr;\n\t\tctxt->_regs[nr] = ctxt->ops->read_gpr(ctxt, nr);\n\t}\n\treturn ctxt->_regs[nr];\n}",
    "includes": [
      "#include \"tss.h\"",
      "#include \"x86.h\"",
      "#include <asm/debugreg.h>",
      "#include <linux/stringify.h>",
      "#include <asm/kvm_emulate.h>",
      "#include <linux/module.h>",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ctxt->ops->read_gpr",
          "args": [
            "ctxt",
            "nr"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic ulong reg_read(struct x86_emulate_ctxt *ctxt, unsigned nr)\n{\n\tif (!(ctxt->regs_valid & (1 << nr))) {\n\t\tctxt->regs_valid |= 1 << nr;\n\t\tctxt->_regs[nr] = ctxt->ops->read_gpr(ctxt, nr);\n\t}\n\treturn ctxt->_regs[nr];\n}"
  }
]