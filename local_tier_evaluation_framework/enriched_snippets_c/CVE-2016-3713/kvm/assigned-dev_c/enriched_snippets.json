[
  {
    "function_name": "kvm_vm_ioctl_assigned_device",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/assigned-dev.c",
    "lines": "968-1058",
    "snippet": "long kvm_vm_ioctl_assigned_device(struct kvm *kvm, unsigned ioctl,\n\t\t\t\t  unsigned long arg)\n{\n\tvoid __user *argp = (void __user *)arg;\n\tint r;\n\n\tswitch (ioctl) {\n\tcase KVM_ASSIGN_PCI_DEVICE: {\n\t\tstruct kvm_assigned_pci_dev assigned_dev;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&assigned_dev, argp, sizeof assigned_dev))\n\t\t\tgoto out;\n\t\tr = kvm_vm_ioctl_assign_device(kvm, &assigned_dev);\n\t\tif (r)\n\t\t\tgoto out;\n\t\tbreak;\n\t}\n\tcase KVM_ASSIGN_IRQ: {\n\t\tr = -EOPNOTSUPP;\n\t\tbreak;\n\t}\n\tcase KVM_ASSIGN_DEV_IRQ: {\n\t\tstruct kvm_assigned_irq assigned_irq;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&assigned_irq, argp, sizeof assigned_irq))\n\t\t\tgoto out;\n\t\tr = kvm_vm_ioctl_assign_irq(kvm, &assigned_irq);\n\t\tif (r)\n\t\t\tgoto out;\n\t\tbreak;\n\t}\n\tcase KVM_DEASSIGN_DEV_IRQ: {\n\t\tstruct kvm_assigned_irq assigned_irq;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&assigned_irq, argp, sizeof assigned_irq))\n\t\t\tgoto out;\n\t\tr = kvm_vm_ioctl_deassign_dev_irq(kvm, &assigned_irq);\n\t\tif (r)\n\t\t\tgoto out;\n\t\tbreak;\n\t}\n\tcase KVM_DEASSIGN_PCI_DEVICE: {\n\t\tstruct kvm_assigned_pci_dev assigned_dev;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&assigned_dev, argp, sizeof assigned_dev))\n\t\t\tgoto out;\n\t\tr = kvm_vm_ioctl_deassign_device(kvm, &assigned_dev);\n\t\tif (r)\n\t\t\tgoto out;\n\t\tbreak;\n\t}\n\tcase KVM_ASSIGN_SET_MSIX_NR: {\n\t\tstruct kvm_assigned_msix_nr entry_nr;\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&entry_nr, argp, sizeof entry_nr))\n\t\t\tgoto out;\n\t\tr = kvm_vm_ioctl_set_msix_nr(kvm, &entry_nr);\n\t\tif (r)\n\t\t\tgoto out;\n\t\tbreak;\n\t}\n\tcase KVM_ASSIGN_SET_MSIX_ENTRY: {\n\t\tstruct kvm_assigned_msix_entry entry;\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&entry, argp, sizeof entry))\n\t\t\tgoto out;\n\t\tr = kvm_vm_ioctl_set_msix_entry(kvm, &entry);\n\t\tif (r)\n\t\t\tgoto out;\n\t\tbreak;\n\t}\n\tcase KVM_ASSIGN_SET_INTX_MASK: {\n\t\tstruct kvm_assigned_pci_dev assigned_dev;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&assigned_dev, argp, sizeof assigned_dev))\n\t\t\tgoto out;\n\t\tr = kvm_vm_ioctl_set_pci_irq_mask(kvm, &assigned_dev);\n\t\tbreak;\n\t}\n\tdefault:\n\t\tr = -ENOTTY;\n\t\tbreak;\n\t}\nout:\n\treturn r;\n}",
    "includes": [
      "#include \"trace/events/kvm.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"irq.h\"",
      "#include <linux/fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/pci.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/errno.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_vm_ioctl_set_pci_irq_mask",
          "args": [
            "kvm",
            "&assigned_dev"
          ],
          "line": 1049
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_vm_ioctl_set_pci_irq_mask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/assigned-dev.c",
          "lines": "919-966",
          "snippet": "static int kvm_vm_ioctl_set_pci_irq_mask(struct kvm *kvm,\n\t\tstruct kvm_assigned_pci_dev *assigned_dev)\n{\n\tint r = 0;\n\tstruct kvm_assigned_dev_kernel *match;\n\n\tmutex_lock(&kvm->lock);\n\n\tmatch = kvm_find_assigned_dev(&kvm->arch.assigned_dev_head,\n\t\t\t\t      assigned_dev->assigned_dev_id);\n\tif (!match) {\n\t\tr = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tspin_lock(&match->intx_mask_lock);\n\n\tmatch->flags &= ~KVM_DEV_ASSIGN_MASK_INTX;\n\tmatch->flags |= assigned_dev->flags & KVM_DEV_ASSIGN_MASK_INTX;\n\n\tif (match->irq_requested_type & KVM_DEV_IRQ_GUEST_INTX) {\n\t\tif (assigned_dev->flags & KVM_DEV_ASSIGN_MASK_INTX) {\n\t\t\tkvm_set_irq(match->kvm, match->irq_source_id,\n\t\t\t\t    match->guest_irq, 0, false);\n\t\t\t/*\n\t\t\t * Masking at hardware-level is performed on demand,\n\t\t\t * i.e. when an IRQ actually arrives at the host.\n\t\t\t */\n\t\t} else if (!(assigned_dev->flags & KVM_DEV_ASSIGN_PCI_2_3)) {\n\t\t\t/*\n\t\t\t * Unmask the IRQ line if required. Unmasking at\n\t\t\t * device level will be performed by user space.\n\t\t\t */\n\t\t\tspin_lock_irq(&match->intx_lock);\n\t\t\tif (match->host_irq_disabled) {\n\t\t\t\tenable_irq(match->host_irq);\n\t\t\t\tmatch->host_irq_disabled = false;\n\t\t\t}\n\t\t\tspin_unlock_irq(&match->intx_lock);\n\t\t}\n\t}\n\n\tspin_unlock(&match->intx_mask_lock);\n\nout:\n\tmutex_unlock(&kvm->lock);\n\treturn r;\n}",
          "includes": [
            "#include \"trace/events/kvm.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"irq.h\"",
            "#include <linux/fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/pci.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/errno.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace/events/kvm.h\"\n#include \"assigned-dev.h\"\n#include \"irq.h\"\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/spinlock.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic int kvm_vm_ioctl_set_pci_irq_mask(struct kvm *kvm,\n\t\tstruct kvm_assigned_pci_dev *assigned_dev)\n{\n\tint r = 0;\n\tstruct kvm_assigned_dev_kernel *match;\n\n\tmutex_lock(&kvm->lock);\n\n\tmatch = kvm_find_assigned_dev(&kvm->arch.assigned_dev_head,\n\t\t\t\t      assigned_dev->assigned_dev_id);\n\tif (!match) {\n\t\tr = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tspin_lock(&match->intx_mask_lock);\n\n\tmatch->flags &= ~KVM_DEV_ASSIGN_MASK_INTX;\n\tmatch->flags |= assigned_dev->flags & KVM_DEV_ASSIGN_MASK_INTX;\n\n\tif (match->irq_requested_type & KVM_DEV_IRQ_GUEST_INTX) {\n\t\tif (assigned_dev->flags & KVM_DEV_ASSIGN_MASK_INTX) {\n\t\t\tkvm_set_irq(match->kvm, match->irq_source_id,\n\t\t\t\t    match->guest_irq, 0, false);\n\t\t\t/*\n\t\t\t * Masking at hardware-level is performed on demand,\n\t\t\t * i.e. when an IRQ actually arrives at the host.\n\t\t\t */\n\t\t} else if (!(assigned_dev->flags & KVM_DEV_ASSIGN_PCI_2_3)) {\n\t\t\t/*\n\t\t\t * Unmask the IRQ line if required. Unmasking at\n\t\t\t * device level will be performed by user space.\n\t\t\t */\n\t\t\tspin_lock_irq(&match->intx_lock);\n\t\t\tif (match->host_irq_disabled) {\n\t\t\t\tenable_irq(match->host_irq);\n\t\t\t\tmatch->host_irq_disabled = false;\n\t\t\t}\n\t\t\tspin_unlock_irq(&match->intx_lock);\n\t\t}\n\t}\n\n\tspin_unlock(&match->intx_mask_lock);\n\nout:\n\tmutex_unlock(&kvm->lock);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&assigned_dev",
            "argp",
            "sizeof assigned_dev"
          ],
          "line": 1047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_vm_ioctl_set_msix_entry",
          "args": [
            "kvm",
            "&entry"
          ],
          "line": 1038
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_vm_ioctl_set_msix_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/assigned-dev.c",
          "lines": "884-917",
          "snippet": "static int kvm_vm_ioctl_set_msix_entry(struct kvm *kvm,\n\t\t\t\t       struct kvm_assigned_msix_entry *entry)\n{\n\tint r = 0, i;\n\tstruct kvm_assigned_dev_kernel *adev;\n\n\tmutex_lock(&kvm->lock);\n\n\tadev = kvm_find_assigned_dev(&kvm->arch.assigned_dev_head,\n\t\t\t\t      entry->assigned_dev_id);\n\n\tif (!adev) {\n\t\tr = -EINVAL;\n\t\tgoto msix_entry_out;\n\t}\n\n\tfor (i = 0; i < adev->entries_nr; i++)\n\t\tif (adev->guest_msix_entries[i].vector == 0 ||\n\t\t    adev->guest_msix_entries[i].entry == entry->entry) {\n\t\t\tadev->guest_msix_entries[i].entry = entry->entry;\n\t\t\tadev->guest_msix_entries[i].vector = entry->gsi;\n\t\t\tadev->host_msix_entries[i].entry = entry->entry;\n\t\t\tbreak;\n\t\t}\n\tif (i == adev->entries_nr) {\n\t\tr = -ENOSPC;\n\t\tgoto msix_entry_out;\n\t}\n\nmsix_entry_out:\n\tmutex_unlock(&kvm->lock);\n\n\treturn r;\n}",
          "includes": [
            "#include \"trace/events/kvm.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"irq.h\"",
            "#include <linux/fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/pci.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/errno.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace/events/kvm.h\"\n#include \"assigned-dev.h\"\n#include \"irq.h\"\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/spinlock.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic int kvm_vm_ioctl_set_msix_entry(struct kvm *kvm,\n\t\t\t\t       struct kvm_assigned_msix_entry *entry)\n{\n\tint r = 0, i;\n\tstruct kvm_assigned_dev_kernel *adev;\n\n\tmutex_lock(&kvm->lock);\n\n\tadev = kvm_find_assigned_dev(&kvm->arch.assigned_dev_head,\n\t\t\t\t      entry->assigned_dev_id);\n\n\tif (!adev) {\n\t\tr = -EINVAL;\n\t\tgoto msix_entry_out;\n\t}\n\n\tfor (i = 0; i < adev->entries_nr; i++)\n\t\tif (adev->guest_msix_entries[i].vector == 0 ||\n\t\t    adev->guest_msix_entries[i].entry == entry->entry) {\n\t\t\tadev->guest_msix_entries[i].entry = entry->entry;\n\t\t\tadev->guest_msix_entries[i].vector = entry->gsi;\n\t\t\tadev->host_msix_entries[i].entry = entry->entry;\n\t\t\tbreak;\n\t\t}\n\tif (i == adev->entries_nr) {\n\t\tr = -ENOSPC;\n\t\tgoto msix_entry_out;\n\t}\n\nmsix_entry_out:\n\tmutex_unlock(&kvm->lock);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&entry",
            "argp",
            "sizeof entry"
          ],
          "line": 1036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_vm_ioctl_set_msix_nr",
          "args": [
            "kvm",
            "&entry_nr"
          ],
          "line": 1028
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_vm_ioctl_set_msix_nr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/assigned-dev.c",
          "lines": "839-882",
          "snippet": "static int kvm_vm_ioctl_set_msix_nr(struct kvm *kvm,\n\t\t\t\t    struct kvm_assigned_msix_nr *entry_nr)\n{\n\tint r = 0;\n\tstruct kvm_assigned_dev_kernel *adev;\n\n\tmutex_lock(&kvm->lock);\n\n\tadev = kvm_find_assigned_dev(&kvm->arch.assigned_dev_head,\n\t\t\t\t      entry_nr->assigned_dev_id);\n\tif (!adev) {\n\t\tr = -EINVAL;\n\t\tgoto msix_nr_out;\n\t}\n\n\tif (adev->entries_nr == 0) {\n\t\tadev->entries_nr = entry_nr->entry_nr;\n\t\tif (adev->entries_nr == 0 ||\n\t\t    adev->entries_nr > KVM_MAX_MSIX_PER_DEV) {\n\t\t\tr = -EINVAL;\n\t\t\tgoto msix_nr_out;\n\t\t}\n\n\t\tadev->host_msix_entries = kzalloc(sizeof(struct msix_entry) *\n\t\t\t\t\t\tentry_nr->entry_nr,\n\t\t\t\t\t\tGFP_KERNEL);\n\t\tif (!adev->host_msix_entries) {\n\t\t\tr = -ENOMEM;\n\t\t\tgoto msix_nr_out;\n\t\t}\n\t\tadev->guest_msix_entries =\n\t\t\tkzalloc(sizeof(struct msix_entry) * entry_nr->entry_nr,\n\t\t\t\tGFP_KERNEL);\n\t\tif (!adev->guest_msix_entries) {\n\t\t\tkfree(adev->host_msix_entries);\n\t\t\tr = -ENOMEM;\n\t\t\tgoto msix_nr_out;\n\t\t}\n\t} else /* Not allowed set MSI-X number twice */\n\t\tr = -EINVAL;\nmsix_nr_out:\n\tmutex_unlock(&kvm->lock);\n\treturn r;\n}",
          "includes": [
            "#include \"trace/events/kvm.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"irq.h\"",
            "#include <linux/fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/pci.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/errno.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace/events/kvm.h\"\n#include \"assigned-dev.h\"\n#include \"irq.h\"\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/spinlock.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic int kvm_vm_ioctl_set_msix_nr(struct kvm *kvm,\n\t\t\t\t    struct kvm_assigned_msix_nr *entry_nr)\n{\n\tint r = 0;\n\tstruct kvm_assigned_dev_kernel *adev;\n\n\tmutex_lock(&kvm->lock);\n\n\tadev = kvm_find_assigned_dev(&kvm->arch.assigned_dev_head,\n\t\t\t\t      entry_nr->assigned_dev_id);\n\tif (!adev) {\n\t\tr = -EINVAL;\n\t\tgoto msix_nr_out;\n\t}\n\n\tif (adev->entries_nr == 0) {\n\t\tadev->entries_nr = entry_nr->entry_nr;\n\t\tif (adev->entries_nr == 0 ||\n\t\t    adev->entries_nr > KVM_MAX_MSIX_PER_DEV) {\n\t\t\tr = -EINVAL;\n\t\t\tgoto msix_nr_out;\n\t\t}\n\n\t\tadev->host_msix_entries = kzalloc(sizeof(struct msix_entry) *\n\t\t\t\t\t\tentry_nr->entry_nr,\n\t\t\t\t\t\tGFP_KERNEL);\n\t\tif (!adev->host_msix_entries) {\n\t\t\tr = -ENOMEM;\n\t\t\tgoto msix_nr_out;\n\t\t}\n\t\tadev->guest_msix_entries =\n\t\t\tkzalloc(sizeof(struct msix_entry) * entry_nr->entry_nr,\n\t\t\t\tGFP_KERNEL);\n\t\tif (!adev->guest_msix_entries) {\n\t\t\tkfree(adev->host_msix_entries);\n\t\t\tr = -ENOMEM;\n\t\t\tgoto msix_nr_out;\n\t\t}\n\t} else /* Not allowed set MSI-X number twice */\n\t\tr = -EINVAL;\nmsix_nr_out:\n\tmutex_unlock(&kvm->lock);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&entry_nr",
            "argp",
            "sizeof entry_nr"
          ],
          "line": 1026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_vm_ioctl_deassign_device",
          "args": [
            "kvm",
            "&assigned_dev"
          ],
          "line": 1018
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_vm_ioctl_deassign_device",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/assigned-dev.c",
          "lines": "812-836",
          "snippet": "static int kvm_vm_ioctl_deassign_device(struct kvm *kvm,\n\t\tstruct kvm_assigned_pci_dev *assigned_dev)\n{\n\tint r = 0;\n\tstruct kvm_assigned_dev_kernel *match;\n\n\tmutex_lock(&kvm->lock);\n\n\tmatch = kvm_find_assigned_dev(&kvm->arch.assigned_dev_head,\n\t\t\t\t      assigned_dev->assigned_dev_id);\n\tif (!match) {\n\t\tprintk(KERN_INFO \"%s: device hasn't been assigned before, \"\n\t\t  \"so cannot be deassigned\\n\", __func__);\n\t\tr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tkvm_deassign_device(kvm, match->dev);\n\n\tkvm_free_assigned_device(kvm, match);\n\nout:\n\tmutex_unlock(&kvm->lock);\n\treturn r;\n}",
          "includes": [
            "#include \"trace/events/kvm.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"irq.h\"",
            "#include <linux/fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/pci.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/errno.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace/events/kvm.h\"\n#include \"assigned-dev.h\"\n#include \"irq.h\"\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/spinlock.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic int kvm_vm_ioctl_deassign_device(struct kvm *kvm,\n\t\tstruct kvm_assigned_pci_dev *assigned_dev)\n{\n\tint r = 0;\n\tstruct kvm_assigned_dev_kernel *match;\n\n\tmutex_lock(&kvm->lock);\n\n\tmatch = kvm_find_assigned_dev(&kvm->arch.assigned_dev_head,\n\t\t\t\t      assigned_dev->assigned_dev_id);\n\tif (!match) {\n\t\tprintk(KERN_INFO \"%s: device hasn't been assigned before, \"\n\t\t  \"so cannot be deassigned\\n\", __func__);\n\t\tr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tkvm_deassign_device(kvm, match->dev);\n\n\tkvm_free_assigned_device(kvm, match);\n\nout:\n\tmutex_unlock(&kvm->lock);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&assigned_dev",
            "argp",
            "sizeof assigned_dev"
          ],
          "line": 1016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_vm_ioctl_deassign_dev_irq",
          "args": [
            "kvm",
            "&assigned_irq"
          ],
          "line": 1007
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_vm_ioctl_deassign_dev_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/assigned-dev.c",
          "lines": "616-637",
          "snippet": "static int kvm_vm_ioctl_deassign_dev_irq(struct kvm *kvm,\n\t\t\t\t\t struct kvm_assigned_irq\n\t\t\t\t\t *assigned_irq)\n{\n\tint r = -ENODEV;\n\tstruct kvm_assigned_dev_kernel *match;\n\tunsigned long irq_type;\n\n\tmutex_lock(&kvm->lock);\n\n\tmatch = kvm_find_assigned_dev(&kvm->arch.assigned_dev_head,\n\t\t\t\t      assigned_irq->assigned_dev_id);\n\tif (!match)\n\t\tgoto out;\n\n\tirq_type = assigned_irq->flags & (KVM_DEV_IRQ_HOST_MASK |\n\t\t\t\t\t  KVM_DEV_IRQ_GUEST_MASK);\n\tr = kvm_deassign_irq(kvm, match, irq_type);\nout:\n\tmutex_unlock(&kvm->lock);\n\treturn r;\n}",
          "includes": [
            "#include \"trace/events/kvm.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"irq.h\"",
            "#include <linux/fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/pci.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/errno.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace/events/kvm.h\"\n#include \"assigned-dev.h\"\n#include \"irq.h\"\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/spinlock.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic int kvm_vm_ioctl_deassign_dev_irq(struct kvm *kvm,\n\t\t\t\t\t struct kvm_assigned_irq\n\t\t\t\t\t *assigned_irq)\n{\n\tint r = -ENODEV;\n\tstruct kvm_assigned_dev_kernel *match;\n\tunsigned long irq_type;\n\n\tmutex_lock(&kvm->lock);\n\n\tmatch = kvm_find_assigned_dev(&kvm->arch.assigned_dev_head,\n\t\t\t\t      assigned_irq->assigned_dev_id);\n\tif (!match)\n\t\tgoto out;\n\n\tirq_type = assigned_irq->flags & (KVM_DEV_IRQ_HOST_MASK |\n\t\t\t\t\t  KVM_DEV_IRQ_GUEST_MASK);\n\tr = kvm_deassign_irq(kvm, match, irq_type);\nout:\n\tmutex_unlock(&kvm->lock);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&assigned_irq",
            "argp",
            "sizeof assigned_irq"
          ],
          "line": 1005
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_vm_ioctl_assign_irq",
          "args": [
            "kvm",
            "&assigned_irq"
          ],
          "line": 996
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_vm_ioctl_assign_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/assigned-dev.c",
          "lines": "574-614",
          "snippet": "static int kvm_vm_ioctl_assign_irq(struct kvm *kvm,\n\t\t\t\t   struct kvm_assigned_irq *assigned_irq)\n{\n\tint r = -EINVAL;\n\tstruct kvm_assigned_dev_kernel *match;\n\tunsigned long host_irq_type, guest_irq_type;\n\n\tif (!irqchip_in_kernel(kvm))\n\t\treturn r;\n\n\tmutex_lock(&kvm->lock);\n\tr = -ENODEV;\n\tmatch = kvm_find_assigned_dev(&kvm->arch.assigned_dev_head,\n\t\t\t\t      assigned_irq->assigned_dev_id);\n\tif (!match)\n\t\tgoto out;\n\n\thost_irq_type = (assigned_irq->flags & KVM_DEV_IRQ_HOST_MASK);\n\tguest_irq_type = (assigned_irq->flags & KVM_DEV_IRQ_GUEST_MASK);\n\n\tr = -EINVAL;\n\t/* can only assign one type at a time */\n\tif (hweight_long(host_irq_type) > 1)\n\t\tgoto out;\n\tif (hweight_long(guest_irq_type) > 1)\n\t\tgoto out;\n\tif (host_irq_type == 0 && guest_irq_type == 0)\n\t\tgoto out;\n\n\tr = 0;\n\tif (host_irq_type)\n\t\tr = assign_host_irq(kvm, match, host_irq_type);\n\tif (r)\n\t\tgoto out;\n\n\tif (guest_irq_type)\n\t\tr = assign_guest_irq(kvm, match, assigned_irq, guest_irq_type);\nout:\n\tmutex_unlock(&kvm->lock);\n\treturn r;\n}",
          "includes": [
            "#include \"trace/events/kvm.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"irq.h\"",
            "#include <linux/fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/pci.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/errno.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace/events/kvm.h\"\n#include \"assigned-dev.h\"\n#include \"irq.h\"\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/spinlock.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic int kvm_vm_ioctl_assign_irq(struct kvm *kvm,\n\t\t\t\t   struct kvm_assigned_irq *assigned_irq)\n{\n\tint r = -EINVAL;\n\tstruct kvm_assigned_dev_kernel *match;\n\tunsigned long host_irq_type, guest_irq_type;\n\n\tif (!irqchip_in_kernel(kvm))\n\t\treturn r;\n\n\tmutex_lock(&kvm->lock);\n\tr = -ENODEV;\n\tmatch = kvm_find_assigned_dev(&kvm->arch.assigned_dev_head,\n\t\t\t\t      assigned_irq->assigned_dev_id);\n\tif (!match)\n\t\tgoto out;\n\n\thost_irq_type = (assigned_irq->flags & KVM_DEV_IRQ_HOST_MASK);\n\tguest_irq_type = (assigned_irq->flags & KVM_DEV_IRQ_GUEST_MASK);\n\n\tr = -EINVAL;\n\t/* can only assign one type at a time */\n\tif (hweight_long(host_irq_type) > 1)\n\t\tgoto out;\n\tif (hweight_long(guest_irq_type) > 1)\n\t\tgoto out;\n\tif (host_irq_type == 0 && guest_irq_type == 0)\n\t\tgoto out;\n\n\tr = 0;\n\tif (host_irq_type)\n\t\tr = assign_host_irq(kvm, match, host_irq_type);\n\tif (r)\n\t\tgoto out;\n\n\tif (guest_irq_type)\n\t\tr = assign_guest_irq(kvm, match, assigned_irq, guest_irq_type);\nout:\n\tmutex_unlock(&kvm->lock);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&assigned_irq",
            "argp",
            "sizeof assigned_irq"
          ],
          "line": 994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_vm_ioctl_assign_device",
          "args": [
            "kvm",
            "&assigned_dev"
          ],
          "line": 981
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_vm_ioctl_assign_device",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/assigned-dev.c",
          "lines": "699-810",
          "snippet": "static int kvm_vm_ioctl_assign_device(struct kvm *kvm,\n\t\t\t\t      struct kvm_assigned_pci_dev *assigned_dev)\n{\n\tint r = 0, idx;\n\tstruct kvm_assigned_dev_kernel *match;\n\tstruct pci_dev *dev;\n\n\tif (!(assigned_dev->flags & KVM_DEV_ASSIGN_ENABLE_IOMMU))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&kvm->lock);\n\tidx = srcu_read_lock(&kvm->srcu);\n\n\tmatch = kvm_find_assigned_dev(&kvm->arch.assigned_dev_head,\n\t\t\t\t      assigned_dev->assigned_dev_id);\n\tif (match) {\n\t\t/* device already assigned */\n\t\tr = -EEXIST;\n\t\tgoto out;\n\t}\n\n\tmatch = kzalloc(sizeof(struct kvm_assigned_dev_kernel), GFP_KERNEL);\n\tif (match == NULL) {\n\t\tprintk(KERN_INFO \"%s: Couldn't allocate memory\\n\",\n\t\t       __func__);\n\t\tr = -ENOMEM;\n\t\tgoto out;\n\t}\n\tdev = pci_get_domain_bus_and_slot(assigned_dev->segnr,\n\t\t\t\t   assigned_dev->busnr,\n\t\t\t\t   assigned_dev->devfn);\n\tif (!dev) {\n\t\tprintk(KERN_INFO \"%s: host device not found\\n\", __func__);\n\t\tr = -EINVAL;\n\t\tgoto out_free;\n\t}\n\n\t/* Don't allow bridges to be assigned */\n\tif (dev->hdr_type != PCI_HEADER_TYPE_NORMAL) {\n\t\tr = -EPERM;\n\t\tgoto out_put;\n\t}\n\n\tr = probe_sysfs_permissions(dev);\n\tif (r)\n\t\tgoto out_put;\n\n\tif (pci_enable_device(dev)) {\n\t\tprintk(KERN_INFO \"%s: Could not enable PCI device\\n\", __func__);\n\t\tr = -EBUSY;\n\t\tgoto out_put;\n\t}\n\tr = pci_request_regions(dev, \"kvm_assigned_device\");\n\tif (r) {\n\t\tprintk(KERN_INFO \"%s: Could not get access to device regions\\n\",\n\t\t       __func__);\n\t\tgoto out_disable;\n\t}\n\n\tpci_reset_function(dev);\n\tpci_save_state(dev);\n\tmatch->pci_saved_state = pci_store_saved_state(dev);\n\tif (!match->pci_saved_state)\n\t\tprintk(KERN_DEBUG \"%s: Couldn't store %s saved state\\n\",\n\t\t       __func__, dev_name(&dev->dev));\n\n\tif (!pci_intx_mask_supported(dev))\n\t\tassigned_dev->flags &= ~KVM_DEV_ASSIGN_PCI_2_3;\n\n\tmatch->assigned_dev_id = assigned_dev->assigned_dev_id;\n\tmatch->host_segnr = assigned_dev->segnr;\n\tmatch->host_busnr = assigned_dev->busnr;\n\tmatch->host_devfn = assigned_dev->devfn;\n\tmatch->flags = assigned_dev->flags;\n\tmatch->dev = dev;\n\tspin_lock_init(&match->intx_lock);\n\tspin_lock_init(&match->intx_mask_lock);\n\tmatch->irq_source_id = -1;\n\tmatch->kvm = kvm;\n\tmatch->ack_notifier.irq_acked = kvm_assigned_dev_ack_irq;\n\n\tlist_add(&match->list, &kvm->arch.assigned_dev_head);\n\n\tif (!kvm->arch.iommu_domain) {\n\t\tr = kvm_iommu_map_guest(kvm);\n\t\tif (r)\n\t\t\tgoto out_list_del;\n\t}\n\tr = kvm_assign_device(kvm, match->dev);\n\tif (r)\n\t\tgoto out_list_del;\n\nout:\n\tsrcu_read_unlock(&kvm->srcu, idx);\n\tmutex_unlock(&kvm->lock);\n\treturn r;\nout_list_del:\n\tif (pci_load_and_free_saved_state(dev, &match->pci_saved_state))\n\t\tprintk(KERN_INFO \"%s: Couldn't reload %s saved state\\n\",\n\t\t       __func__, dev_name(&dev->dev));\n\tlist_del(&match->list);\n\tpci_release_regions(dev);\nout_disable:\n\tpci_disable_device(dev);\nout_put:\n\tpci_dev_put(dev);\nout_free:\n\tkfree(match);\n\tsrcu_read_unlock(&kvm->srcu, idx);\n\tmutex_unlock(&kvm->lock);\n\treturn r;\n}",
          "includes": [
            "#include \"trace/events/kvm.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"irq.h\"",
            "#include <linux/fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/pci.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/errno.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace/events/kvm.h\"\n#include \"assigned-dev.h\"\n#include \"irq.h\"\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/spinlock.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic int kvm_vm_ioctl_assign_device(struct kvm *kvm,\n\t\t\t\t      struct kvm_assigned_pci_dev *assigned_dev)\n{\n\tint r = 0, idx;\n\tstruct kvm_assigned_dev_kernel *match;\n\tstruct pci_dev *dev;\n\n\tif (!(assigned_dev->flags & KVM_DEV_ASSIGN_ENABLE_IOMMU))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&kvm->lock);\n\tidx = srcu_read_lock(&kvm->srcu);\n\n\tmatch = kvm_find_assigned_dev(&kvm->arch.assigned_dev_head,\n\t\t\t\t      assigned_dev->assigned_dev_id);\n\tif (match) {\n\t\t/* device already assigned */\n\t\tr = -EEXIST;\n\t\tgoto out;\n\t}\n\n\tmatch = kzalloc(sizeof(struct kvm_assigned_dev_kernel), GFP_KERNEL);\n\tif (match == NULL) {\n\t\tprintk(KERN_INFO \"%s: Couldn't allocate memory\\n\",\n\t\t       __func__);\n\t\tr = -ENOMEM;\n\t\tgoto out;\n\t}\n\tdev = pci_get_domain_bus_and_slot(assigned_dev->segnr,\n\t\t\t\t   assigned_dev->busnr,\n\t\t\t\t   assigned_dev->devfn);\n\tif (!dev) {\n\t\tprintk(KERN_INFO \"%s: host device not found\\n\", __func__);\n\t\tr = -EINVAL;\n\t\tgoto out_free;\n\t}\n\n\t/* Don't allow bridges to be assigned */\n\tif (dev->hdr_type != PCI_HEADER_TYPE_NORMAL) {\n\t\tr = -EPERM;\n\t\tgoto out_put;\n\t}\n\n\tr = probe_sysfs_permissions(dev);\n\tif (r)\n\t\tgoto out_put;\n\n\tif (pci_enable_device(dev)) {\n\t\tprintk(KERN_INFO \"%s: Could not enable PCI device\\n\", __func__);\n\t\tr = -EBUSY;\n\t\tgoto out_put;\n\t}\n\tr = pci_request_regions(dev, \"kvm_assigned_device\");\n\tif (r) {\n\t\tprintk(KERN_INFO \"%s: Could not get access to device regions\\n\",\n\t\t       __func__);\n\t\tgoto out_disable;\n\t}\n\n\tpci_reset_function(dev);\n\tpci_save_state(dev);\n\tmatch->pci_saved_state = pci_store_saved_state(dev);\n\tif (!match->pci_saved_state)\n\t\tprintk(KERN_DEBUG \"%s: Couldn't store %s saved state\\n\",\n\t\t       __func__, dev_name(&dev->dev));\n\n\tif (!pci_intx_mask_supported(dev))\n\t\tassigned_dev->flags &= ~KVM_DEV_ASSIGN_PCI_2_3;\n\n\tmatch->assigned_dev_id = assigned_dev->assigned_dev_id;\n\tmatch->host_segnr = assigned_dev->segnr;\n\tmatch->host_busnr = assigned_dev->busnr;\n\tmatch->host_devfn = assigned_dev->devfn;\n\tmatch->flags = assigned_dev->flags;\n\tmatch->dev = dev;\n\tspin_lock_init(&match->intx_lock);\n\tspin_lock_init(&match->intx_mask_lock);\n\tmatch->irq_source_id = -1;\n\tmatch->kvm = kvm;\n\tmatch->ack_notifier.irq_acked = kvm_assigned_dev_ack_irq;\n\n\tlist_add(&match->list, &kvm->arch.assigned_dev_head);\n\n\tif (!kvm->arch.iommu_domain) {\n\t\tr = kvm_iommu_map_guest(kvm);\n\t\tif (r)\n\t\t\tgoto out_list_del;\n\t}\n\tr = kvm_assign_device(kvm, match->dev);\n\tif (r)\n\t\tgoto out_list_del;\n\nout:\n\tsrcu_read_unlock(&kvm->srcu, idx);\n\tmutex_unlock(&kvm->lock);\n\treturn r;\nout_list_del:\n\tif (pci_load_and_free_saved_state(dev, &match->pci_saved_state))\n\t\tprintk(KERN_INFO \"%s: Couldn't reload %s saved state\\n\",\n\t\t       __func__, dev_name(&dev->dev));\n\tlist_del(&match->list);\n\tpci_release_regions(dev);\nout_disable:\n\tpci_disable_device(dev);\nout_put:\n\tpci_dev_put(dev);\nout_free:\n\tkfree(match);\n\tsrcu_read_unlock(&kvm->srcu, idx);\n\tmutex_unlock(&kvm->lock);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&assigned_dev",
            "argp",
            "sizeof assigned_dev"
          ],
          "line": 979
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace/events/kvm.h\"\n#include \"assigned-dev.h\"\n#include \"irq.h\"\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/spinlock.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nlong kvm_vm_ioctl_assigned_device(struct kvm *kvm, unsigned ioctl,\n\t\t\t\t  unsigned long arg)\n{\n\tvoid __user *argp = (void __user *)arg;\n\tint r;\n\n\tswitch (ioctl) {\n\tcase KVM_ASSIGN_PCI_DEVICE: {\n\t\tstruct kvm_assigned_pci_dev assigned_dev;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&assigned_dev, argp, sizeof assigned_dev))\n\t\t\tgoto out;\n\t\tr = kvm_vm_ioctl_assign_device(kvm, &assigned_dev);\n\t\tif (r)\n\t\t\tgoto out;\n\t\tbreak;\n\t}\n\tcase KVM_ASSIGN_IRQ: {\n\t\tr = -EOPNOTSUPP;\n\t\tbreak;\n\t}\n\tcase KVM_ASSIGN_DEV_IRQ: {\n\t\tstruct kvm_assigned_irq assigned_irq;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&assigned_irq, argp, sizeof assigned_irq))\n\t\t\tgoto out;\n\t\tr = kvm_vm_ioctl_assign_irq(kvm, &assigned_irq);\n\t\tif (r)\n\t\t\tgoto out;\n\t\tbreak;\n\t}\n\tcase KVM_DEASSIGN_DEV_IRQ: {\n\t\tstruct kvm_assigned_irq assigned_irq;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&assigned_irq, argp, sizeof assigned_irq))\n\t\t\tgoto out;\n\t\tr = kvm_vm_ioctl_deassign_dev_irq(kvm, &assigned_irq);\n\t\tif (r)\n\t\t\tgoto out;\n\t\tbreak;\n\t}\n\tcase KVM_DEASSIGN_PCI_DEVICE: {\n\t\tstruct kvm_assigned_pci_dev assigned_dev;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&assigned_dev, argp, sizeof assigned_dev))\n\t\t\tgoto out;\n\t\tr = kvm_vm_ioctl_deassign_device(kvm, &assigned_dev);\n\t\tif (r)\n\t\t\tgoto out;\n\t\tbreak;\n\t}\n\tcase KVM_ASSIGN_SET_MSIX_NR: {\n\t\tstruct kvm_assigned_msix_nr entry_nr;\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&entry_nr, argp, sizeof entry_nr))\n\t\t\tgoto out;\n\t\tr = kvm_vm_ioctl_set_msix_nr(kvm, &entry_nr);\n\t\tif (r)\n\t\t\tgoto out;\n\t\tbreak;\n\t}\n\tcase KVM_ASSIGN_SET_MSIX_ENTRY: {\n\t\tstruct kvm_assigned_msix_entry entry;\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&entry, argp, sizeof entry))\n\t\t\tgoto out;\n\t\tr = kvm_vm_ioctl_set_msix_entry(kvm, &entry);\n\t\tif (r)\n\t\t\tgoto out;\n\t\tbreak;\n\t}\n\tcase KVM_ASSIGN_SET_INTX_MASK: {\n\t\tstruct kvm_assigned_pci_dev assigned_dev;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&assigned_dev, argp, sizeof assigned_dev))\n\t\t\tgoto out;\n\t\tr = kvm_vm_ioctl_set_pci_irq_mask(kvm, &assigned_dev);\n\t\tbreak;\n\t}\n\tdefault:\n\t\tr = -ENOTTY;\n\t\tbreak;\n\t}\nout:\n\treturn r;\n}"
  },
  {
    "function_name": "kvm_vm_ioctl_set_pci_irq_mask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/assigned-dev.c",
    "lines": "919-966",
    "snippet": "static int kvm_vm_ioctl_set_pci_irq_mask(struct kvm *kvm,\n\t\tstruct kvm_assigned_pci_dev *assigned_dev)\n{\n\tint r = 0;\n\tstruct kvm_assigned_dev_kernel *match;\n\n\tmutex_lock(&kvm->lock);\n\n\tmatch = kvm_find_assigned_dev(&kvm->arch.assigned_dev_head,\n\t\t\t\t      assigned_dev->assigned_dev_id);\n\tif (!match) {\n\t\tr = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tspin_lock(&match->intx_mask_lock);\n\n\tmatch->flags &= ~KVM_DEV_ASSIGN_MASK_INTX;\n\tmatch->flags |= assigned_dev->flags & KVM_DEV_ASSIGN_MASK_INTX;\n\n\tif (match->irq_requested_type & KVM_DEV_IRQ_GUEST_INTX) {\n\t\tif (assigned_dev->flags & KVM_DEV_ASSIGN_MASK_INTX) {\n\t\t\tkvm_set_irq(match->kvm, match->irq_source_id,\n\t\t\t\t    match->guest_irq, 0, false);\n\t\t\t/*\n\t\t\t * Masking at hardware-level is performed on demand,\n\t\t\t * i.e. when an IRQ actually arrives at the host.\n\t\t\t */\n\t\t} else if (!(assigned_dev->flags & KVM_DEV_ASSIGN_PCI_2_3)) {\n\t\t\t/*\n\t\t\t * Unmask the IRQ line if required. Unmasking at\n\t\t\t * device level will be performed by user space.\n\t\t\t */\n\t\t\tspin_lock_irq(&match->intx_lock);\n\t\t\tif (match->host_irq_disabled) {\n\t\t\t\tenable_irq(match->host_irq);\n\t\t\t\tmatch->host_irq_disabled = false;\n\t\t\t}\n\t\t\tspin_unlock_irq(&match->intx_lock);\n\t\t}\n\t}\n\n\tspin_unlock(&match->intx_mask_lock);\n\nout:\n\tmutex_unlock(&kvm->lock);\n\treturn r;\n}",
    "includes": [
      "#include \"trace/events/kvm.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"irq.h\"",
      "#include <linux/fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/pci.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/errno.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&kvm->lock"
          ],
          "line": 964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&match->intx_mask_lock"
          ],
          "line": 961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&match->intx_lock"
          ],
          "line": 957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "enable_irq",
          "args": [
            "match->host_irq"
          ],
          "line": 954
        },
        "resolved": true,
        "details": {
          "function_name": "enable_irq_window",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/vmx.c",
          "lines": "5085-5092",
          "snippet": "static void enable_irq_window(struct kvm_vcpu *vcpu)\n{\n\tu32 cpu_based_vm_exec_control;\n\n\tcpu_based_vm_exec_control = vmcs_read32(CPU_BASED_VM_EXEC_CONTROL);\n\tcpu_based_vm_exec_control |= CPU_BASED_VIRTUAL_INTR_PENDING;\n\tvmcs_write32(CPU_BASED_VM_EXEC_CONTROL, cpu_based_vm_exec_control);\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"trace.h\"",
            "#include <asm/irq_remapping.h>",
            "#include <asm/apic.h>",
            "#include <asm/kexec.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/mce.h>",
            "#include <asm/virtext.h>",
            "#include <asm/vmx.h>",
            "#include <asm/desc.h>",
            "#include <asm/io.h>",
            "#include <asm/cpu.h>",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/hrtimer.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include \"lapic.h\"",
            "#include \"cpuid.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long nested_ept_get_cr3(struct kvm_vcpu *vcpu);",
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);",
            "static void ept_save_pdptrs(struct kvm_vcpu *vcpu);",
            "static void vmx_decache_cr0_guest_bits(struct kvm_vcpu *vcpu);",
            "static void vmx_leave_nested(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"trace.h\"\n#include <asm/irq_remapping.h>\n#include <asm/apic.h>\n#include <asm/kexec.h>\n#include <asm/debugreg.h>\n#include <asm/perf_event.h>\n#include <asm/fpu/internal.h>\n#include <asm/mce.h>\n#include <asm/virtext.h>\n#include <asm/vmx.h>\n#include <asm/desc.h>\n#include <asm/io.h>\n#include <asm/cpu.h>\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/hrtimer.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic unsigned long nested_ept_get_cr3(struct kvm_vcpu *vcpu);\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\nstatic void ept_save_pdptrs(struct kvm_vcpu *vcpu);\nstatic void vmx_decache_cr0_guest_bits(struct kvm_vcpu *vcpu);\nstatic void vmx_leave_nested(struct kvm_vcpu *vcpu);\n\nstatic void enable_irq_window(struct kvm_vcpu *vcpu)\n{\n\tu32 cpu_based_vm_exec_control;\n\n\tcpu_based_vm_exec_control = vmcs_read32(CPU_BASED_VM_EXEC_CONTROL);\n\tcpu_based_vm_exec_control |= CPU_BASED_VIRTUAL_INTR_PENDING;\n\tvmcs_write32(CPU_BASED_VM_EXEC_CONTROL, cpu_based_vm_exec_control);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&match->intx_lock"
          ],
          "line": 952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_set_irq",
          "args": [
            "match->kvm",
            "match->irq_source_id",
            "match->guest_irq",
            "0",
            "false"
          ],
          "line": 941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&match->intx_mask_lock"
          ],
          "line": 934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_find_assigned_dev",
          "args": [
            "&kvm->arch.assigned_dev_head",
            "assigned_dev->assigned_dev_id"
          ],
          "line": 927
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_find_assigned_dev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/assigned-dev.c",
          "lines": "51-61",
          "snippet": "static struct kvm_assigned_dev_kernel *kvm_find_assigned_dev(struct list_head *head,\n\t\t\t\t\t\t      int assigned_dev_id)\n{\n\tstruct kvm_assigned_dev_kernel *match;\n\n\tlist_for_each_entry(match, head, list) {\n\t\tif (match->assigned_dev_id == assigned_dev_id)\n\t\t\treturn match;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace/events/kvm.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"irq.h\"",
            "#include <linux/fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/pci.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/errno.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace/events/kvm.h\"\n#include \"assigned-dev.h\"\n#include \"irq.h\"\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/spinlock.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic struct kvm_assigned_dev_kernel *kvm_find_assigned_dev(struct list_head *head,\n\t\t\t\t\t\t      int assigned_dev_id)\n{\n\tstruct kvm_assigned_dev_kernel *match;\n\n\tlist_for_each_entry(match, head, list) {\n\t\tif (match->assigned_dev_id == assigned_dev_id)\n\t\t\treturn match;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&kvm->lock"
          ],
          "line": 925
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace/events/kvm.h\"\n#include \"assigned-dev.h\"\n#include \"irq.h\"\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/spinlock.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic int kvm_vm_ioctl_set_pci_irq_mask(struct kvm *kvm,\n\t\tstruct kvm_assigned_pci_dev *assigned_dev)\n{\n\tint r = 0;\n\tstruct kvm_assigned_dev_kernel *match;\n\n\tmutex_lock(&kvm->lock);\n\n\tmatch = kvm_find_assigned_dev(&kvm->arch.assigned_dev_head,\n\t\t\t\t      assigned_dev->assigned_dev_id);\n\tif (!match) {\n\t\tr = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tspin_lock(&match->intx_mask_lock);\n\n\tmatch->flags &= ~KVM_DEV_ASSIGN_MASK_INTX;\n\tmatch->flags |= assigned_dev->flags & KVM_DEV_ASSIGN_MASK_INTX;\n\n\tif (match->irq_requested_type & KVM_DEV_IRQ_GUEST_INTX) {\n\t\tif (assigned_dev->flags & KVM_DEV_ASSIGN_MASK_INTX) {\n\t\t\tkvm_set_irq(match->kvm, match->irq_source_id,\n\t\t\t\t    match->guest_irq, 0, false);\n\t\t\t/*\n\t\t\t * Masking at hardware-level is performed on demand,\n\t\t\t * i.e. when an IRQ actually arrives at the host.\n\t\t\t */\n\t\t} else if (!(assigned_dev->flags & KVM_DEV_ASSIGN_PCI_2_3)) {\n\t\t\t/*\n\t\t\t * Unmask the IRQ line if required. Unmasking at\n\t\t\t * device level will be performed by user space.\n\t\t\t */\n\t\t\tspin_lock_irq(&match->intx_lock);\n\t\t\tif (match->host_irq_disabled) {\n\t\t\t\tenable_irq(match->host_irq);\n\t\t\t\tmatch->host_irq_disabled = false;\n\t\t\t}\n\t\t\tspin_unlock_irq(&match->intx_lock);\n\t\t}\n\t}\n\n\tspin_unlock(&match->intx_mask_lock);\n\nout:\n\tmutex_unlock(&kvm->lock);\n\treturn r;\n}"
  },
  {
    "function_name": "kvm_vm_ioctl_set_msix_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/assigned-dev.c",
    "lines": "884-917",
    "snippet": "static int kvm_vm_ioctl_set_msix_entry(struct kvm *kvm,\n\t\t\t\t       struct kvm_assigned_msix_entry *entry)\n{\n\tint r = 0, i;\n\tstruct kvm_assigned_dev_kernel *adev;\n\n\tmutex_lock(&kvm->lock);\n\n\tadev = kvm_find_assigned_dev(&kvm->arch.assigned_dev_head,\n\t\t\t\t      entry->assigned_dev_id);\n\n\tif (!adev) {\n\t\tr = -EINVAL;\n\t\tgoto msix_entry_out;\n\t}\n\n\tfor (i = 0; i < adev->entries_nr; i++)\n\t\tif (adev->guest_msix_entries[i].vector == 0 ||\n\t\t    adev->guest_msix_entries[i].entry == entry->entry) {\n\t\t\tadev->guest_msix_entries[i].entry = entry->entry;\n\t\t\tadev->guest_msix_entries[i].vector = entry->gsi;\n\t\t\tadev->host_msix_entries[i].entry = entry->entry;\n\t\t\tbreak;\n\t\t}\n\tif (i == adev->entries_nr) {\n\t\tr = -ENOSPC;\n\t\tgoto msix_entry_out;\n\t}\n\nmsix_entry_out:\n\tmutex_unlock(&kvm->lock);\n\n\treturn r;\n}",
    "includes": [
      "#include \"trace/events/kvm.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"irq.h\"",
      "#include <linux/fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/pci.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/errno.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&kvm->lock"
          ],
          "line": 914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_find_assigned_dev",
          "args": [
            "&kvm->arch.assigned_dev_head",
            "entry->assigned_dev_id"
          ],
          "line": 892
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_find_assigned_dev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/assigned-dev.c",
          "lines": "51-61",
          "snippet": "static struct kvm_assigned_dev_kernel *kvm_find_assigned_dev(struct list_head *head,\n\t\t\t\t\t\t      int assigned_dev_id)\n{\n\tstruct kvm_assigned_dev_kernel *match;\n\n\tlist_for_each_entry(match, head, list) {\n\t\tif (match->assigned_dev_id == assigned_dev_id)\n\t\t\treturn match;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace/events/kvm.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"irq.h\"",
            "#include <linux/fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/pci.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/errno.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace/events/kvm.h\"\n#include \"assigned-dev.h\"\n#include \"irq.h\"\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/spinlock.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic struct kvm_assigned_dev_kernel *kvm_find_assigned_dev(struct list_head *head,\n\t\t\t\t\t\t      int assigned_dev_id)\n{\n\tstruct kvm_assigned_dev_kernel *match;\n\n\tlist_for_each_entry(match, head, list) {\n\t\tif (match->assigned_dev_id == assigned_dev_id)\n\t\t\treturn match;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&kvm->lock"
          ],
          "line": 890
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace/events/kvm.h\"\n#include \"assigned-dev.h\"\n#include \"irq.h\"\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/spinlock.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic int kvm_vm_ioctl_set_msix_entry(struct kvm *kvm,\n\t\t\t\t       struct kvm_assigned_msix_entry *entry)\n{\n\tint r = 0, i;\n\tstruct kvm_assigned_dev_kernel *adev;\n\n\tmutex_lock(&kvm->lock);\n\n\tadev = kvm_find_assigned_dev(&kvm->arch.assigned_dev_head,\n\t\t\t\t      entry->assigned_dev_id);\n\n\tif (!adev) {\n\t\tr = -EINVAL;\n\t\tgoto msix_entry_out;\n\t}\n\n\tfor (i = 0; i < adev->entries_nr; i++)\n\t\tif (adev->guest_msix_entries[i].vector == 0 ||\n\t\t    adev->guest_msix_entries[i].entry == entry->entry) {\n\t\t\tadev->guest_msix_entries[i].entry = entry->entry;\n\t\t\tadev->guest_msix_entries[i].vector = entry->gsi;\n\t\t\tadev->host_msix_entries[i].entry = entry->entry;\n\t\t\tbreak;\n\t\t}\n\tif (i == adev->entries_nr) {\n\t\tr = -ENOSPC;\n\t\tgoto msix_entry_out;\n\t}\n\nmsix_entry_out:\n\tmutex_unlock(&kvm->lock);\n\n\treturn r;\n}"
  },
  {
    "function_name": "kvm_vm_ioctl_set_msix_nr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/assigned-dev.c",
    "lines": "839-882",
    "snippet": "static int kvm_vm_ioctl_set_msix_nr(struct kvm *kvm,\n\t\t\t\t    struct kvm_assigned_msix_nr *entry_nr)\n{\n\tint r = 0;\n\tstruct kvm_assigned_dev_kernel *adev;\n\n\tmutex_lock(&kvm->lock);\n\n\tadev = kvm_find_assigned_dev(&kvm->arch.assigned_dev_head,\n\t\t\t\t      entry_nr->assigned_dev_id);\n\tif (!adev) {\n\t\tr = -EINVAL;\n\t\tgoto msix_nr_out;\n\t}\n\n\tif (adev->entries_nr == 0) {\n\t\tadev->entries_nr = entry_nr->entry_nr;\n\t\tif (adev->entries_nr == 0 ||\n\t\t    adev->entries_nr > KVM_MAX_MSIX_PER_DEV) {\n\t\t\tr = -EINVAL;\n\t\t\tgoto msix_nr_out;\n\t\t}\n\n\t\tadev->host_msix_entries = kzalloc(sizeof(struct msix_entry) *\n\t\t\t\t\t\tentry_nr->entry_nr,\n\t\t\t\t\t\tGFP_KERNEL);\n\t\tif (!adev->host_msix_entries) {\n\t\t\tr = -ENOMEM;\n\t\t\tgoto msix_nr_out;\n\t\t}\n\t\tadev->guest_msix_entries =\n\t\t\tkzalloc(sizeof(struct msix_entry) * entry_nr->entry_nr,\n\t\t\t\tGFP_KERNEL);\n\t\tif (!adev->guest_msix_entries) {\n\t\t\tkfree(adev->host_msix_entries);\n\t\t\tr = -ENOMEM;\n\t\t\tgoto msix_nr_out;\n\t\t}\n\t} else /* Not allowed set MSI-X number twice */\n\t\tr = -EINVAL;\nmsix_nr_out:\n\tmutex_unlock(&kvm->lock);\n\treturn r;\n}",
    "includes": [
      "#include \"trace/events/kvm.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"irq.h\"",
      "#include <linux/fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/pci.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/errno.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&kvm->lock"
          ],
          "line": 880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "adev->host_msix_entries"
          ],
          "line": 873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct msix_entry) * entry_nr->entry_nr",
            "GFP_KERNEL"
          ],
          "line": 870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct msix_entry) *\n\t\t\t\t\t\tentry_nr->entry_nr",
            "GFP_KERNEL"
          ],
          "line": 862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_find_assigned_dev",
          "args": [
            "&kvm->arch.assigned_dev_head",
            "entry_nr->assigned_dev_id"
          ],
          "line": 847
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_find_assigned_dev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/assigned-dev.c",
          "lines": "51-61",
          "snippet": "static struct kvm_assigned_dev_kernel *kvm_find_assigned_dev(struct list_head *head,\n\t\t\t\t\t\t      int assigned_dev_id)\n{\n\tstruct kvm_assigned_dev_kernel *match;\n\n\tlist_for_each_entry(match, head, list) {\n\t\tif (match->assigned_dev_id == assigned_dev_id)\n\t\t\treturn match;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace/events/kvm.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"irq.h\"",
            "#include <linux/fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/pci.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/errno.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace/events/kvm.h\"\n#include \"assigned-dev.h\"\n#include \"irq.h\"\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/spinlock.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic struct kvm_assigned_dev_kernel *kvm_find_assigned_dev(struct list_head *head,\n\t\t\t\t\t\t      int assigned_dev_id)\n{\n\tstruct kvm_assigned_dev_kernel *match;\n\n\tlist_for_each_entry(match, head, list) {\n\t\tif (match->assigned_dev_id == assigned_dev_id)\n\t\t\treturn match;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&kvm->lock"
          ],
          "line": 845
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace/events/kvm.h\"\n#include \"assigned-dev.h\"\n#include \"irq.h\"\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/spinlock.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic int kvm_vm_ioctl_set_msix_nr(struct kvm *kvm,\n\t\t\t\t    struct kvm_assigned_msix_nr *entry_nr)\n{\n\tint r = 0;\n\tstruct kvm_assigned_dev_kernel *adev;\n\n\tmutex_lock(&kvm->lock);\n\n\tadev = kvm_find_assigned_dev(&kvm->arch.assigned_dev_head,\n\t\t\t\t      entry_nr->assigned_dev_id);\n\tif (!adev) {\n\t\tr = -EINVAL;\n\t\tgoto msix_nr_out;\n\t}\n\n\tif (adev->entries_nr == 0) {\n\t\tadev->entries_nr = entry_nr->entry_nr;\n\t\tif (adev->entries_nr == 0 ||\n\t\t    adev->entries_nr > KVM_MAX_MSIX_PER_DEV) {\n\t\t\tr = -EINVAL;\n\t\t\tgoto msix_nr_out;\n\t\t}\n\n\t\tadev->host_msix_entries = kzalloc(sizeof(struct msix_entry) *\n\t\t\t\t\t\tentry_nr->entry_nr,\n\t\t\t\t\t\tGFP_KERNEL);\n\t\tif (!adev->host_msix_entries) {\n\t\t\tr = -ENOMEM;\n\t\t\tgoto msix_nr_out;\n\t\t}\n\t\tadev->guest_msix_entries =\n\t\t\tkzalloc(sizeof(struct msix_entry) * entry_nr->entry_nr,\n\t\t\t\tGFP_KERNEL);\n\t\tif (!adev->guest_msix_entries) {\n\t\t\tkfree(adev->host_msix_entries);\n\t\t\tr = -ENOMEM;\n\t\t\tgoto msix_nr_out;\n\t\t}\n\t} else /* Not allowed set MSI-X number twice */\n\t\tr = -EINVAL;\nmsix_nr_out:\n\tmutex_unlock(&kvm->lock);\n\treturn r;\n}"
  },
  {
    "function_name": "kvm_vm_ioctl_deassign_device",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/assigned-dev.c",
    "lines": "812-836",
    "snippet": "static int kvm_vm_ioctl_deassign_device(struct kvm *kvm,\n\t\tstruct kvm_assigned_pci_dev *assigned_dev)\n{\n\tint r = 0;\n\tstruct kvm_assigned_dev_kernel *match;\n\n\tmutex_lock(&kvm->lock);\n\n\tmatch = kvm_find_assigned_dev(&kvm->arch.assigned_dev_head,\n\t\t\t\t      assigned_dev->assigned_dev_id);\n\tif (!match) {\n\t\tprintk(KERN_INFO \"%s: device hasn't been assigned before, \"\n\t\t  \"so cannot be deassigned\\n\", __func__);\n\t\tr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tkvm_deassign_device(kvm, match->dev);\n\n\tkvm_free_assigned_device(kvm, match);\n\nout:\n\tmutex_unlock(&kvm->lock);\n\treturn r;\n}",
    "includes": [
      "#include \"trace/events/kvm.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"irq.h\"",
      "#include <linux/fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/pci.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/errno.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&kvm->lock"
          ],
          "line": 834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_free_assigned_device",
          "args": [
            "kvm",
            "match"
          ],
          "line": 831
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_free_assigned_device",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/assigned-dev.c",
          "lines": "348-370",
          "snippet": "static void kvm_free_assigned_device(struct kvm *kvm,\n\t\t\t\t     struct kvm_assigned_dev_kernel\n\t\t\t\t     *assigned_dev)\n{\n\tkvm_free_assigned_irq(kvm, assigned_dev);\n\n\tpci_reset_function(assigned_dev->dev);\n\tif (pci_load_and_free_saved_state(assigned_dev->dev,\n\t\t\t\t\t  &assigned_dev->pci_saved_state))\n\t\tprintk(KERN_INFO \"%s: Couldn't reload %s saved state\\n\",\n\t\t       __func__, dev_name(&assigned_dev->dev->dev));\n\telse\n\t\tpci_restore_state(assigned_dev->dev);\n\n\tpci_clear_dev_assigned(assigned_dev->dev);\n\n\tpci_release_regions(assigned_dev->dev);\n\tpci_disable_device(assigned_dev->dev);\n\tpci_dev_put(assigned_dev->dev);\n\n\tlist_del(&assigned_dev->list);\n\tkfree(assigned_dev);\n}",
          "includes": [
            "#include \"trace/events/kvm.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"irq.h\"",
            "#include <linux/fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/pci.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/errno.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace/events/kvm.h\"\n#include \"assigned-dev.h\"\n#include \"irq.h\"\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/spinlock.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void kvm_free_assigned_device(struct kvm *kvm,\n\t\t\t\t     struct kvm_assigned_dev_kernel\n\t\t\t\t     *assigned_dev)\n{\n\tkvm_free_assigned_irq(kvm, assigned_dev);\n\n\tpci_reset_function(assigned_dev->dev);\n\tif (pci_load_and_free_saved_state(assigned_dev->dev,\n\t\t\t\t\t  &assigned_dev->pci_saved_state))\n\t\tprintk(KERN_INFO \"%s: Couldn't reload %s saved state\\n\",\n\t\t       __func__, dev_name(&assigned_dev->dev->dev));\n\telse\n\t\tpci_restore_state(assigned_dev->dev);\n\n\tpci_clear_dev_assigned(assigned_dev->dev);\n\n\tpci_release_regions(assigned_dev->dev);\n\tpci_disable_device(assigned_dev->dev);\n\tpci_dev_put(assigned_dev->dev);\n\n\tlist_del(&assigned_dev->list);\n\tkfree(assigned_dev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_deassign_device",
          "args": [
            "kvm",
            "match->dev"
          ],
          "line": 829
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_deassign_device",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/iommu.c",
          "lines": "215-234",
          "snippet": "int kvm_deassign_device(struct kvm *kvm, struct pci_dev *pdev)\n{\n\tstruct iommu_domain *domain = kvm->arch.iommu_domain;\n\n\t/* check if iommu exists and in use */\n\tif (!domain)\n\t\treturn 0;\n\n\tif (pdev == NULL)\n\t\treturn -ENODEV;\n\n\tiommu_detach_device(domain, &pdev->dev);\n\n\tpci_clear_dev_assigned(pdev);\n\tkvm_arch_end_assignment(kvm);\n\n\tdev_info(&pdev->dev, \"kvm deassign device\\n\");\n\n\treturn 0;\n}",
          "includes": [
            "#include \"assigned-dev.h\"",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/dmar.h>",
            "#include <linux/stat.h>",
            "#include <linux/pci.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int kvm_iommu_unmap_memslots(struct kvm *kvm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"assigned-dev.h\"\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/dmar.h>\n#include <linux/stat.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/list.h>\n\nstatic int kvm_iommu_unmap_memslots(struct kvm *kvm);\n\nint kvm_deassign_device(struct kvm *kvm, struct pci_dev *pdev)\n{\n\tstruct iommu_domain *domain = kvm->arch.iommu_domain;\n\n\t/* check if iommu exists and in use */\n\tif (!domain)\n\t\treturn 0;\n\n\tif (pdev == NULL)\n\t\treturn -ENODEV;\n\n\tiommu_detach_device(domain, &pdev->dev);\n\n\tpci_clear_dev_assigned(pdev);\n\tkvm_arch_end_assignment(kvm);\n\n\tdev_info(&pdev->dev, \"kvm deassign device\\n\");\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO \"%s: device hasn't been assigned before, \"\n\t\t  \"so cannot be deassigned\\n\"",
            "__func__"
          ],
          "line": 823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_find_assigned_dev",
          "args": [
            "&kvm->arch.assigned_dev_head",
            "assigned_dev->assigned_dev_id"
          ],
          "line": 820
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_find_assigned_dev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/assigned-dev.c",
          "lines": "51-61",
          "snippet": "static struct kvm_assigned_dev_kernel *kvm_find_assigned_dev(struct list_head *head,\n\t\t\t\t\t\t      int assigned_dev_id)\n{\n\tstruct kvm_assigned_dev_kernel *match;\n\n\tlist_for_each_entry(match, head, list) {\n\t\tif (match->assigned_dev_id == assigned_dev_id)\n\t\t\treturn match;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace/events/kvm.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"irq.h\"",
            "#include <linux/fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/pci.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/errno.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace/events/kvm.h\"\n#include \"assigned-dev.h\"\n#include \"irq.h\"\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/spinlock.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic struct kvm_assigned_dev_kernel *kvm_find_assigned_dev(struct list_head *head,\n\t\t\t\t\t\t      int assigned_dev_id)\n{\n\tstruct kvm_assigned_dev_kernel *match;\n\n\tlist_for_each_entry(match, head, list) {\n\t\tif (match->assigned_dev_id == assigned_dev_id)\n\t\t\treturn match;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&kvm->lock"
          ],
          "line": 818
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace/events/kvm.h\"\n#include \"assigned-dev.h\"\n#include \"irq.h\"\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/spinlock.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic int kvm_vm_ioctl_deassign_device(struct kvm *kvm,\n\t\tstruct kvm_assigned_pci_dev *assigned_dev)\n{\n\tint r = 0;\n\tstruct kvm_assigned_dev_kernel *match;\n\n\tmutex_lock(&kvm->lock);\n\n\tmatch = kvm_find_assigned_dev(&kvm->arch.assigned_dev_head,\n\t\t\t\t      assigned_dev->assigned_dev_id);\n\tif (!match) {\n\t\tprintk(KERN_INFO \"%s: device hasn't been assigned before, \"\n\t\t  \"so cannot be deassigned\\n\", __func__);\n\t\tr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tkvm_deassign_device(kvm, match->dev);\n\n\tkvm_free_assigned_device(kvm, match);\n\nout:\n\tmutex_unlock(&kvm->lock);\n\treturn r;\n}"
  },
  {
    "function_name": "kvm_vm_ioctl_assign_device",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/assigned-dev.c",
    "lines": "699-810",
    "snippet": "static int kvm_vm_ioctl_assign_device(struct kvm *kvm,\n\t\t\t\t      struct kvm_assigned_pci_dev *assigned_dev)\n{\n\tint r = 0, idx;\n\tstruct kvm_assigned_dev_kernel *match;\n\tstruct pci_dev *dev;\n\n\tif (!(assigned_dev->flags & KVM_DEV_ASSIGN_ENABLE_IOMMU))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&kvm->lock);\n\tidx = srcu_read_lock(&kvm->srcu);\n\n\tmatch = kvm_find_assigned_dev(&kvm->arch.assigned_dev_head,\n\t\t\t\t      assigned_dev->assigned_dev_id);\n\tif (match) {\n\t\t/* device already assigned */\n\t\tr = -EEXIST;\n\t\tgoto out;\n\t}\n\n\tmatch = kzalloc(sizeof(struct kvm_assigned_dev_kernel), GFP_KERNEL);\n\tif (match == NULL) {\n\t\tprintk(KERN_INFO \"%s: Couldn't allocate memory\\n\",\n\t\t       __func__);\n\t\tr = -ENOMEM;\n\t\tgoto out;\n\t}\n\tdev = pci_get_domain_bus_and_slot(assigned_dev->segnr,\n\t\t\t\t   assigned_dev->busnr,\n\t\t\t\t   assigned_dev->devfn);\n\tif (!dev) {\n\t\tprintk(KERN_INFO \"%s: host device not found\\n\", __func__);\n\t\tr = -EINVAL;\n\t\tgoto out_free;\n\t}\n\n\t/* Don't allow bridges to be assigned */\n\tif (dev->hdr_type != PCI_HEADER_TYPE_NORMAL) {\n\t\tr = -EPERM;\n\t\tgoto out_put;\n\t}\n\n\tr = probe_sysfs_permissions(dev);\n\tif (r)\n\t\tgoto out_put;\n\n\tif (pci_enable_device(dev)) {\n\t\tprintk(KERN_INFO \"%s: Could not enable PCI device\\n\", __func__);\n\t\tr = -EBUSY;\n\t\tgoto out_put;\n\t}\n\tr = pci_request_regions(dev, \"kvm_assigned_device\");\n\tif (r) {\n\t\tprintk(KERN_INFO \"%s: Could not get access to device regions\\n\",\n\t\t       __func__);\n\t\tgoto out_disable;\n\t}\n\n\tpci_reset_function(dev);\n\tpci_save_state(dev);\n\tmatch->pci_saved_state = pci_store_saved_state(dev);\n\tif (!match->pci_saved_state)\n\t\tprintk(KERN_DEBUG \"%s: Couldn't store %s saved state\\n\",\n\t\t       __func__, dev_name(&dev->dev));\n\n\tif (!pci_intx_mask_supported(dev))\n\t\tassigned_dev->flags &= ~KVM_DEV_ASSIGN_PCI_2_3;\n\n\tmatch->assigned_dev_id = assigned_dev->assigned_dev_id;\n\tmatch->host_segnr = assigned_dev->segnr;\n\tmatch->host_busnr = assigned_dev->busnr;\n\tmatch->host_devfn = assigned_dev->devfn;\n\tmatch->flags = assigned_dev->flags;\n\tmatch->dev = dev;\n\tspin_lock_init(&match->intx_lock);\n\tspin_lock_init(&match->intx_mask_lock);\n\tmatch->irq_source_id = -1;\n\tmatch->kvm = kvm;\n\tmatch->ack_notifier.irq_acked = kvm_assigned_dev_ack_irq;\n\n\tlist_add(&match->list, &kvm->arch.assigned_dev_head);\n\n\tif (!kvm->arch.iommu_domain) {\n\t\tr = kvm_iommu_map_guest(kvm);\n\t\tif (r)\n\t\t\tgoto out_list_del;\n\t}\n\tr = kvm_assign_device(kvm, match->dev);\n\tif (r)\n\t\tgoto out_list_del;\n\nout:\n\tsrcu_read_unlock(&kvm->srcu, idx);\n\tmutex_unlock(&kvm->lock);\n\treturn r;\nout_list_del:\n\tif (pci_load_and_free_saved_state(dev, &match->pci_saved_state))\n\t\tprintk(KERN_INFO \"%s: Couldn't reload %s saved state\\n\",\n\t\t       __func__, dev_name(&dev->dev));\n\tlist_del(&match->list);\n\tpci_release_regions(dev);\nout_disable:\n\tpci_disable_device(dev);\nout_put:\n\tpci_dev_put(dev);\nout_free:\n\tkfree(match);\n\tsrcu_read_unlock(&kvm->srcu, idx);\n\tmutex_unlock(&kvm->lock);\n\treturn r;\n}",
    "includes": [
      "#include \"trace/events/kvm.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"irq.h\"",
      "#include <linux/fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/pci.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/errno.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&kvm->lock"
          ],
          "line": 808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "srcu_read_unlock",
          "args": [
            "&kvm->srcu",
            "idx"
          ],
          "line": 807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "match"
          ],
          "line": 806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_dev_put",
          "args": [
            "dev"
          ],
          "line": 804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_disable_device",
          "args": [
            "dev"
          ],
          "line": 802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_release_regions",
          "args": [
            "dev"
          ],
          "line": 800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&match->list"
          ],
          "line": 799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO \"%s: Couldn't reload %s saved state\\n\"",
            "__func__",
            "dev_name(&dev->dev)"
          ],
          "line": 797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_name",
          "args": [
            "&dev->dev"
          ],
          "line": 798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_load_and_free_saved_state",
          "args": [
            "dev",
            "&match->pci_saved_state"
          ],
          "line": 796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&kvm->lock"
          ],
          "line": 793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "srcu_read_unlock",
          "args": [
            "&kvm->srcu",
            "idx"
          ],
          "line": 792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_assign_device",
          "args": [
            "kvm",
            "match->dev"
          ],
          "line": 787
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_assign_device",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/iommu.c",
          "lines": "174-213",
          "snippet": "int kvm_assign_device(struct kvm *kvm, struct pci_dev *pdev)\n{\n\tstruct iommu_domain *domain = kvm->arch.iommu_domain;\n\tint r;\n\tbool noncoherent;\n\n\t/* check if iommu exists and in use */\n\tif (!domain)\n\t\treturn 0;\n\n\tif (pdev == NULL)\n\t\treturn -ENODEV;\n\n\tr = iommu_attach_device(domain, &pdev->dev);\n\tif (r) {\n\t\tdev_err(&pdev->dev, \"kvm assign device failed ret %d\", r);\n\t\treturn r;\n\t}\n\n\tnoncoherent = !iommu_capable(&pci_bus_type, IOMMU_CAP_CACHE_COHERENCY);\n\n\t/* Check if need to update IOMMU page table for guest memory */\n\tif (noncoherent != kvm->arch.iommu_noncoherent) {\n\t\tkvm_iommu_unmap_memslots(kvm);\n\t\tkvm->arch.iommu_noncoherent = noncoherent;\n\t\tr = kvm_iommu_map_memslots(kvm);\n\t\tif (r)\n\t\t\tgoto out_unmap;\n\t}\n\n\tkvm_arch_start_assignment(kvm);\n\tpci_set_dev_assigned(pdev);\n\n\tdev_info(&pdev->dev, \"kvm assign device\\n\");\n\n\treturn 0;\nout_unmap:\n\tkvm_iommu_unmap_memslots(kvm);\n\treturn r;\n}",
          "includes": [
            "#include \"assigned-dev.h\"",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/dmar.h>",
            "#include <linux/stat.h>",
            "#include <linux/pci.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int kvm_iommu_unmap_memslots(struct kvm *kvm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"assigned-dev.h\"\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/dmar.h>\n#include <linux/stat.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/list.h>\n\nstatic int kvm_iommu_unmap_memslots(struct kvm *kvm);\n\nint kvm_assign_device(struct kvm *kvm, struct pci_dev *pdev)\n{\n\tstruct iommu_domain *domain = kvm->arch.iommu_domain;\n\tint r;\n\tbool noncoherent;\n\n\t/* check if iommu exists and in use */\n\tif (!domain)\n\t\treturn 0;\n\n\tif (pdev == NULL)\n\t\treturn -ENODEV;\n\n\tr = iommu_attach_device(domain, &pdev->dev);\n\tif (r) {\n\t\tdev_err(&pdev->dev, \"kvm assign device failed ret %d\", r);\n\t\treturn r;\n\t}\n\n\tnoncoherent = !iommu_capable(&pci_bus_type, IOMMU_CAP_CACHE_COHERENCY);\n\n\t/* Check if need to update IOMMU page table for guest memory */\n\tif (noncoherent != kvm->arch.iommu_noncoherent) {\n\t\tkvm_iommu_unmap_memslots(kvm);\n\t\tkvm->arch.iommu_noncoherent = noncoherent;\n\t\tr = kvm_iommu_map_memslots(kvm);\n\t\tif (r)\n\t\t\tgoto out_unmap;\n\t}\n\n\tkvm_arch_start_assignment(kvm);\n\tpci_set_dev_assigned(pdev);\n\n\tdev_info(&pdev->dev, \"kvm assign device\\n\");\n\n\treturn 0;\nout_unmap:\n\tkvm_iommu_unmap_memslots(kvm);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_iommu_map_guest",
          "args": [
            "kvm"
          ],
          "line": 783
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_iommu_map_guest",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/iommu.c",
          "lines": "236-272",
          "snippet": "int kvm_iommu_map_guest(struct kvm *kvm)\n{\n\tint r;\n\n\tif (!iommu_present(&pci_bus_type)) {\n\t\tprintk(KERN_ERR \"%s: iommu not found\\n\", __func__);\n\t\treturn -ENODEV;\n\t}\n\n\tmutex_lock(&kvm->slots_lock);\n\n\tkvm->arch.iommu_domain = iommu_domain_alloc(&pci_bus_type);\n\tif (!kvm->arch.iommu_domain) {\n\t\tr = -ENOMEM;\n\t\tgoto out_unlock;\n\t}\n\n\tif (!allow_unsafe_assigned_interrupts &&\n\t    !iommu_capable(&pci_bus_type, IOMMU_CAP_INTR_REMAP)) {\n\t\tprintk(KERN_WARNING \"%s: No interrupt remapping support,\"\n\t\t       \" disallowing device assignment.\"\n\t\t       \" Re-enble with \\\"allow_unsafe_assigned_interrupts=1\\\"\"\n\t\t       \" module option.\\n\", __func__);\n\t\tiommu_domain_free(kvm->arch.iommu_domain);\n\t\tkvm->arch.iommu_domain = NULL;\n\t\tr = -EPERM;\n\t\tgoto out_unlock;\n\t}\n\n\tr = kvm_iommu_map_memslots(kvm);\n\tif (r)\n\t\tkvm_iommu_unmap_memslots(kvm);\n\nout_unlock:\n\tmutex_unlock(&kvm->slots_lock);\n\treturn r;\n}",
          "includes": [
            "#include \"assigned-dev.h\"",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/dmar.h>",
            "#include <linux/stat.h>",
            "#include <linux/pci.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool allow_unsafe_assigned_interrupts;",
            "static int kvm_iommu_unmap_memslots(struct kvm *kvm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"assigned-dev.h\"\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/dmar.h>\n#include <linux/stat.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/list.h>\n\nstatic bool allow_unsafe_assigned_interrupts;\nstatic int kvm_iommu_unmap_memslots(struct kvm *kvm);\n\nint kvm_iommu_map_guest(struct kvm *kvm)\n{\n\tint r;\n\n\tif (!iommu_present(&pci_bus_type)) {\n\t\tprintk(KERN_ERR \"%s: iommu not found\\n\", __func__);\n\t\treturn -ENODEV;\n\t}\n\n\tmutex_lock(&kvm->slots_lock);\n\n\tkvm->arch.iommu_domain = iommu_domain_alloc(&pci_bus_type);\n\tif (!kvm->arch.iommu_domain) {\n\t\tr = -ENOMEM;\n\t\tgoto out_unlock;\n\t}\n\n\tif (!allow_unsafe_assigned_interrupts &&\n\t    !iommu_capable(&pci_bus_type, IOMMU_CAP_INTR_REMAP)) {\n\t\tprintk(KERN_WARNING \"%s: No interrupt remapping support,\"\n\t\t       \" disallowing device assignment.\"\n\t\t       \" Re-enble with \\\"allow_unsafe_assigned_interrupts=1\\\"\"\n\t\t       \" module option.\\n\", __func__);\n\t\tiommu_domain_free(kvm->arch.iommu_domain);\n\t\tkvm->arch.iommu_domain = NULL;\n\t\tr = -EPERM;\n\t\tgoto out_unlock;\n\t}\n\n\tr = kvm_iommu_map_memslots(kvm);\n\tif (r)\n\t\tkvm_iommu_unmap_memslots(kvm);\n\nout_unlock:\n\tmutex_unlock(&kvm->slots_lock);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&match->list",
            "&kvm->arch.assigned_dev_head"
          ],
          "line": 780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&match->intx_mask_lock"
          ],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&match->intx_lock"
          ],
          "line": 774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_intx_mask_supported",
          "args": [
            "dev"
          ],
          "line": 765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_DEBUG \"%s: Couldn't store %s saved state\\n\"",
            "__func__",
            "dev_name(&dev->dev)"
          ],
          "line": 762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_name",
          "args": [
            "&dev->dev"
          ],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_store_saved_state",
          "args": [
            "dev"
          ],
          "line": 760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_save_state",
          "args": [
            "dev"
          ],
          "line": 759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_reset_function",
          "args": [
            "dev"
          ],
          "line": 758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO \"%s: Could not get access to device regions\\n\"",
            "__func__"
          ],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_request_regions",
          "args": [
            "dev",
            "\"kvm_assigned_device\""
          ],
          "line": 751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO \"%s: Could not enable PCI device\\n\"",
            "__func__"
          ],
          "line": 747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_enable_device",
          "args": [
            "dev"
          ],
          "line": 746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "probe_sysfs_permissions",
          "args": [
            "dev"
          ],
          "line": 742
        },
        "resolved": true,
        "details": {
          "function_name": "probe_sysfs_permissions",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/assigned-dev.c",
          "lines": "649-697",
          "snippet": "static int probe_sysfs_permissions(struct pci_dev *dev)\n{\n#ifdef CONFIG_SYSFS\n\tint i;\n\tbool bar_found = false;\n\n\tfor (i = PCI_STD_RESOURCES; i <= PCI_STD_RESOURCE_END; i++) {\n\t\tchar *kpath, *syspath;\n\t\tstruct path path;\n\t\tstruct inode *inode;\n\t\tint r;\n\n\t\tif (!pci_resource_len(dev, i))\n\t\t\tcontinue;\n\n\t\tkpath = kobject_get_path(&dev->dev.kobj, GFP_KERNEL);\n\t\tif (!kpath)\n\t\t\treturn -ENOMEM;\n\n\t\t/* Per sysfs-rules, sysfs is always at /sys */\n\t\tsyspath = kasprintf(GFP_KERNEL, \"/sys%s/resource%d\", kpath, i);\n\t\tkfree(kpath);\n\t\tif (!syspath)\n\t\t\treturn -ENOMEM;\n\n\t\tr = kern_path(syspath, LOOKUP_FOLLOW, &path);\n\t\tkfree(syspath);\n\t\tif (r)\n\t\t\treturn r;\n\n\t\tinode = d_backing_inode(path.dentry);\n\n\t\tr = inode_permission(inode, MAY_READ | MAY_WRITE | MAY_ACCESS);\n\t\tpath_put(&path);\n\t\tif (r)\n\t\t\treturn r;\n\n\t\tbar_found = true;\n\t}\n\n\t/* If no resources, probably something special */\n\tif (!bar_found)\n\t\treturn -EPERM;\n\n\treturn 0;\n#else\n\treturn -EINVAL; /* No way to control the device without sysfs */\n#endif\n}",
          "includes": [
            "#include \"trace/events/kvm.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"irq.h\"",
            "#include <linux/fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/pci.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/errno.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace/events/kvm.h\"\n#include \"assigned-dev.h\"\n#include \"irq.h\"\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/spinlock.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic int probe_sysfs_permissions(struct pci_dev *dev)\n{\n#ifdef CONFIG_SYSFS\n\tint i;\n\tbool bar_found = false;\n\n\tfor (i = PCI_STD_RESOURCES; i <= PCI_STD_RESOURCE_END; i++) {\n\t\tchar *kpath, *syspath;\n\t\tstruct path path;\n\t\tstruct inode *inode;\n\t\tint r;\n\n\t\tif (!pci_resource_len(dev, i))\n\t\t\tcontinue;\n\n\t\tkpath = kobject_get_path(&dev->dev.kobj, GFP_KERNEL);\n\t\tif (!kpath)\n\t\t\treturn -ENOMEM;\n\n\t\t/* Per sysfs-rules, sysfs is always at /sys */\n\t\tsyspath = kasprintf(GFP_KERNEL, \"/sys%s/resource%d\", kpath, i);\n\t\tkfree(kpath);\n\t\tif (!syspath)\n\t\t\treturn -ENOMEM;\n\n\t\tr = kern_path(syspath, LOOKUP_FOLLOW, &path);\n\t\tkfree(syspath);\n\t\tif (r)\n\t\t\treturn r;\n\n\t\tinode = d_backing_inode(path.dentry);\n\n\t\tr = inode_permission(inode, MAY_READ | MAY_WRITE | MAY_ACCESS);\n\t\tpath_put(&path);\n\t\tif (r)\n\t\t\treturn r;\n\n\t\tbar_found = true;\n\t}\n\n\t/* If no resources, probably something special */\n\tif (!bar_found)\n\t\treturn -EPERM;\n\n\treturn 0;\n#else\n\treturn -EINVAL; /* No way to control the device without sysfs */\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO \"%s: host device not found\\n\"",
            "__func__"
          ],
          "line": 731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_get_domain_bus_and_slot",
          "args": [
            "assigned_dev->segnr",
            "assigned_dev->busnr",
            "assigned_dev->devfn"
          ],
          "line": 727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO \"%s: Couldn't allocate memory\\n\"",
            "__func__"
          ],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct kvm_assigned_dev_kernel)",
            "GFP_KERNEL"
          ],
          "line": 720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_find_assigned_dev",
          "args": [
            "&kvm->arch.assigned_dev_head",
            "assigned_dev->assigned_dev_id"
          ],
          "line": 712
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_find_assigned_dev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/assigned-dev.c",
          "lines": "51-61",
          "snippet": "static struct kvm_assigned_dev_kernel *kvm_find_assigned_dev(struct list_head *head,\n\t\t\t\t\t\t      int assigned_dev_id)\n{\n\tstruct kvm_assigned_dev_kernel *match;\n\n\tlist_for_each_entry(match, head, list) {\n\t\tif (match->assigned_dev_id == assigned_dev_id)\n\t\t\treturn match;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace/events/kvm.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"irq.h\"",
            "#include <linux/fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/pci.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/errno.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace/events/kvm.h\"\n#include \"assigned-dev.h\"\n#include \"irq.h\"\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/spinlock.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic struct kvm_assigned_dev_kernel *kvm_find_assigned_dev(struct list_head *head,\n\t\t\t\t\t\t      int assigned_dev_id)\n{\n\tstruct kvm_assigned_dev_kernel *match;\n\n\tlist_for_each_entry(match, head, list) {\n\t\tif (match->assigned_dev_id == assigned_dev_id)\n\t\t\treturn match;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "srcu_read_lock",
          "args": [
            "&kvm->srcu"
          ],
          "line": 710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&kvm->lock"
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace/events/kvm.h\"\n#include \"assigned-dev.h\"\n#include \"irq.h\"\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/spinlock.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic int kvm_vm_ioctl_assign_device(struct kvm *kvm,\n\t\t\t\t      struct kvm_assigned_pci_dev *assigned_dev)\n{\n\tint r = 0, idx;\n\tstruct kvm_assigned_dev_kernel *match;\n\tstruct pci_dev *dev;\n\n\tif (!(assigned_dev->flags & KVM_DEV_ASSIGN_ENABLE_IOMMU))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&kvm->lock);\n\tidx = srcu_read_lock(&kvm->srcu);\n\n\tmatch = kvm_find_assigned_dev(&kvm->arch.assigned_dev_head,\n\t\t\t\t      assigned_dev->assigned_dev_id);\n\tif (match) {\n\t\t/* device already assigned */\n\t\tr = -EEXIST;\n\t\tgoto out;\n\t}\n\n\tmatch = kzalloc(sizeof(struct kvm_assigned_dev_kernel), GFP_KERNEL);\n\tif (match == NULL) {\n\t\tprintk(KERN_INFO \"%s: Couldn't allocate memory\\n\",\n\t\t       __func__);\n\t\tr = -ENOMEM;\n\t\tgoto out;\n\t}\n\tdev = pci_get_domain_bus_and_slot(assigned_dev->segnr,\n\t\t\t\t   assigned_dev->busnr,\n\t\t\t\t   assigned_dev->devfn);\n\tif (!dev) {\n\t\tprintk(KERN_INFO \"%s: host device not found\\n\", __func__);\n\t\tr = -EINVAL;\n\t\tgoto out_free;\n\t}\n\n\t/* Don't allow bridges to be assigned */\n\tif (dev->hdr_type != PCI_HEADER_TYPE_NORMAL) {\n\t\tr = -EPERM;\n\t\tgoto out_put;\n\t}\n\n\tr = probe_sysfs_permissions(dev);\n\tif (r)\n\t\tgoto out_put;\n\n\tif (pci_enable_device(dev)) {\n\t\tprintk(KERN_INFO \"%s: Could not enable PCI device\\n\", __func__);\n\t\tr = -EBUSY;\n\t\tgoto out_put;\n\t}\n\tr = pci_request_regions(dev, \"kvm_assigned_device\");\n\tif (r) {\n\t\tprintk(KERN_INFO \"%s: Could not get access to device regions\\n\",\n\t\t       __func__);\n\t\tgoto out_disable;\n\t}\n\n\tpci_reset_function(dev);\n\tpci_save_state(dev);\n\tmatch->pci_saved_state = pci_store_saved_state(dev);\n\tif (!match->pci_saved_state)\n\t\tprintk(KERN_DEBUG \"%s: Couldn't store %s saved state\\n\",\n\t\t       __func__, dev_name(&dev->dev));\n\n\tif (!pci_intx_mask_supported(dev))\n\t\tassigned_dev->flags &= ~KVM_DEV_ASSIGN_PCI_2_3;\n\n\tmatch->assigned_dev_id = assigned_dev->assigned_dev_id;\n\tmatch->host_segnr = assigned_dev->segnr;\n\tmatch->host_busnr = assigned_dev->busnr;\n\tmatch->host_devfn = assigned_dev->devfn;\n\tmatch->flags = assigned_dev->flags;\n\tmatch->dev = dev;\n\tspin_lock_init(&match->intx_lock);\n\tspin_lock_init(&match->intx_mask_lock);\n\tmatch->irq_source_id = -1;\n\tmatch->kvm = kvm;\n\tmatch->ack_notifier.irq_acked = kvm_assigned_dev_ack_irq;\n\n\tlist_add(&match->list, &kvm->arch.assigned_dev_head);\n\n\tif (!kvm->arch.iommu_domain) {\n\t\tr = kvm_iommu_map_guest(kvm);\n\t\tif (r)\n\t\t\tgoto out_list_del;\n\t}\n\tr = kvm_assign_device(kvm, match->dev);\n\tif (r)\n\t\tgoto out_list_del;\n\nout:\n\tsrcu_read_unlock(&kvm->srcu, idx);\n\tmutex_unlock(&kvm->lock);\n\treturn r;\nout_list_del:\n\tif (pci_load_and_free_saved_state(dev, &match->pci_saved_state))\n\t\tprintk(KERN_INFO \"%s: Couldn't reload %s saved state\\n\",\n\t\t       __func__, dev_name(&dev->dev));\n\tlist_del(&match->list);\n\tpci_release_regions(dev);\nout_disable:\n\tpci_disable_device(dev);\nout_put:\n\tpci_dev_put(dev);\nout_free:\n\tkfree(match);\n\tsrcu_read_unlock(&kvm->srcu, idx);\n\tmutex_unlock(&kvm->lock);\n\treturn r;\n}"
  },
  {
    "function_name": "probe_sysfs_permissions",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/assigned-dev.c",
    "lines": "649-697",
    "snippet": "static int probe_sysfs_permissions(struct pci_dev *dev)\n{\n#ifdef CONFIG_SYSFS\n\tint i;\n\tbool bar_found = false;\n\n\tfor (i = PCI_STD_RESOURCES; i <= PCI_STD_RESOURCE_END; i++) {\n\t\tchar *kpath, *syspath;\n\t\tstruct path path;\n\t\tstruct inode *inode;\n\t\tint r;\n\n\t\tif (!pci_resource_len(dev, i))\n\t\t\tcontinue;\n\n\t\tkpath = kobject_get_path(&dev->dev.kobj, GFP_KERNEL);\n\t\tif (!kpath)\n\t\t\treturn -ENOMEM;\n\n\t\t/* Per sysfs-rules, sysfs is always at /sys */\n\t\tsyspath = kasprintf(GFP_KERNEL, \"/sys%s/resource%d\", kpath, i);\n\t\tkfree(kpath);\n\t\tif (!syspath)\n\t\t\treturn -ENOMEM;\n\n\t\tr = kern_path(syspath, LOOKUP_FOLLOW, &path);\n\t\tkfree(syspath);\n\t\tif (r)\n\t\t\treturn r;\n\n\t\tinode = d_backing_inode(path.dentry);\n\n\t\tr = inode_permission(inode, MAY_READ | MAY_WRITE | MAY_ACCESS);\n\t\tpath_put(&path);\n\t\tif (r)\n\t\t\treturn r;\n\n\t\tbar_found = true;\n\t}\n\n\t/* If no resources, probably something special */\n\tif (!bar_found)\n\t\treturn -EPERM;\n\n\treturn 0;\n#else\n\treturn -EINVAL; /* No way to control the device without sysfs */\n#endif\n}",
    "includes": [
      "#include \"trace/events/kvm.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"irq.h\"",
      "#include <linux/fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/pci.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/errno.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "path_put",
          "args": [
            "&path"
          ],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_permission",
          "args": [
            "inode",
            "MAY_READ | MAY_WRITE | MAY_ACCESS"
          ],
          "line": 681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_backing_inode",
          "args": [
            "path.dentry"
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "syspath"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kern_path",
          "args": [
            "syspath",
            "LOOKUP_FOLLOW",
            "&path"
          ],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "kpath"
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kasprintf",
          "args": [
            "GFP_KERNEL",
            "\"/sys%s/resource%d\"",
            "kpath",
            "i"
          ],
          "line": 669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kobject_get_path",
          "args": [
            "&dev->dev.kobj",
            "GFP_KERNEL"
          ],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_resource_len",
          "args": [
            "dev",
            "i"
          ],
          "line": 661
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace/events/kvm.h\"\n#include \"assigned-dev.h\"\n#include \"irq.h\"\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/spinlock.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic int probe_sysfs_permissions(struct pci_dev *dev)\n{\n#ifdef CONFIG_SYSFS\n\tint i;\n\tbool bar_found = false;\n\n\tfor (i = PCI_STD_RESOURCES; i <= PCI_STD_RESOURCE_END; i++) {\n\t\tchar *kpath, *syspath;\n\t\tstruct path path;\n\t\tstruct inode *inode;\n\t\tint r;\n\n\t\tif (!pci_resource_len(dev, i))\n\t\t\tcontinue;\n\n\t\tkpath = kobject_get_path(&dev->dev.kobj, GFP_KERNEL);\n\t\tif (!kpath)\n\t\t\treturn -ENOMEM;\n\n\t\t/* Per sysfs-rules, sysfs is always at /sys */\n\t\tsyspath = kasprintf(GFP_KERNEL, \"/sys%s/resource%d\", kpath, i);\n\t\tkfree(kpath);\n\t\tif (!syspath)\n\t\t\treturn -ENOMEM;\n\n\t\tr = kern_path(syspath, LOOKUP_FOLLOW, &path);\n\t\tkfree(syspath);\n\t\tif (r)\n\t\t\treturn r;\n\n\t\tinode = d_backing_inode(path.dentry);\n\n\t\tr = inode_permission(inode, MAY_READ | MAY_WRITE | MAY_ACCESS);\n\t\tpath_put(&path);\n\t\tif (r)\n\t\t\treturn r;\n\n\t\tbar_found = true;\n\t}\n\n\t/* If no resources, probably something special */\n\tif (!bar_found)\n\t\treturn -EPERM;\n\n\treturn 0;\n#else\n\treturn -EINVAL; /* No way to control the device without sysfs */\n#endif\n}"
  },
  {
    "function_name": "kvm_vm_ioctl_deassign_dev_irq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/assigned-dev.c",
    "lines": "616-637",
    "snippet": "static int kvm_vm_ioctl_deassign_dev_irq(struct kvm *kvm,\n\t\t\t\t\t struct kvm_assigned_irq\n\t\t\t\t\t *assigned_irq)\n{\n\tint r = -ENODEV;\n\tstruct kvm_assigned_dev_kernel *match;\n\tunsigned long irq_type;\n\n\tmutex_lock(&kvm->lock);\n\n\tmatch = kvm_find_assigned_dev(&kvm->arch.assigned_dev_head,\n\t\t\t\t      assigned_irq->assigned_dev_id);\n\tif (!match)\n\t\tgoto out;\n\n\tirq_type = assigned_irq->flags & (KVM_DEV_IRQ_HOST_MASK |\n\t\t\t\t\t  KVM_DEV_IRQ_GUEST_MASK);\n\tr = kvm_deassign_irq(kvm, match, irq_type);\nout:\n\tmutex_unlock(&kvm->lock);\n\treturn r;\n}",
    "includes": [
      "#include \"trace/events/kvm.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"irq.h\"",
      "#include <linux/fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/pci.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/errno.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&kvm->lock"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_deassign_irq",
          "args": [
            "kvm",
            "match",
            "irq_type"
          ],
          "line": 633
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_deassign_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/assigned-dev.c",
          "lines": "319-340",
          "snippet": "static int kvm_deassign_irq(struct kvm *kvm,\n\t\t\t    struct kvm_assigned_dev_kernel *assigned_dev,\n\t\t\t    unsigned long irq_requested_type)\n{\n\tunsigned long guest_irq_type, host_irq_type;\n\n\tif (!irqchip_in_kernel(kvm))\n\t\treturn -EINVAL;\n\t/* no irq assignment to deassign */\n\tif (!assigned_dev->irq_requested_type)\n\t\treturn -ENXIO;\n\n\thost_irq_type = irq_requested_type & KVM_DEV_IRQ_HOST_MASK;\n\tguest_irq_type = irq_requested_type & KVM_DEV_IRQ_GUEST_MASK;\n\n\tif (host_irq_type)\n\t\tdeassign_host_irq(kvm, assigned_dev);\n\tif (guest_irq_type)\n\t\tdeassign_guest_irq(kvm, assigned_dev);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace/events/kvm.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"irq.h\"",
            "#include <linux/fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/pci.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/errno.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace/events/kvm.h\"\n#include \"assigned-dev.h\"\n#include \"irq.h\"\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/spinlock.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic int kvm_deassign_irq(struct kvm *kvm,\n\t\t\t    struct kvm_assigned_dev_kernel *assigned_dev,\n\t\t\t    unsigned long irq_requested_type)\n{\n\tunsigned long guest_irq_type, host_irq_type;\n\n\tif (!irqchip_in_kernel(kvm))\n\t\treturn -EINVAL;\n\t/* no irq assignment to deassign */\n\tif (!assigned_dev->irq_requested_type)\n\t\treturn -ENXIO;\n\n\thost_irq_type = irq_requested_type & KVM_DEV_IRQ_HOST_MASK;\n\tguest_irq_type = irq_requested_type & KVM_DEV_IRQ_GUEST_MASK;\n\n\tif (host_irq_type)\n\t\tdeassign_host_irq(kvm, assigned_dev);\n\tif (guest_irq_type)\n\t\tdeassign_guest_irq(kvm, assigned_dev);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_find_assigned_dev",
          "args": [
            "&kvm->arch.assigned_dev_head",
            "assigned_irq->assigned_dev_id"
          ],
          "line": 626
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_find_assigned_dev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/assigned-dev.c",
          "lines": "51-61",
          "snippet": "static struct kvm_assigned_dev_kernel *kvm_find_assigned_dev(struct list_head *head,\n\t\t\t\t\t\t      int assigned_dev_id)\n{\n\tstruct kvm_assigned_dev_kernel *match;\n\n\tlist_for_each_entry(match, head, list) {\n\t\tif (match->assigned_dev_id == assigned_dev_id)\n\t\t\treturn match;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace/events/kvm.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"irq.h\"",
            "#include <linux/fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/pci.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/errno.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace/events/kvm.h\"\n#include \"assigned-dev.h\"\n#include \"irq.h\"\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/spinlock.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic struct kvm_assigned_dev_kernel *kvm_find_assigned_dev(struct list_head *head,\n\t\t\t\t\t\t      int assigned_dev_id)\n{\n\tstruct kvm_assigned_dev_kernel *match;\n\n\tlist_for_each_entry(match, head, list) {\n\t\tif (match->assigned_dev_id == assigned_dev_id)\n\t\t\treturn match;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&kvm->lock"
          ],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace/events/kvm.h\"\n#include \"assigned-dev.h\"\n#include \"irq.h\"\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/spinlock.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic int kvm_vm_ioctl_deassign_dev_irq(struct kvm *kvm,\n\t\t\t\t\t struct kvm_assigned_irq\n\t\t\t\t\t *assigned_irq)\n{\n\tint r = -ENODEV;\n\tstruct kvm_assigned_dev_kernel *match;\n\tunsigned long irq_type;\n\n\tmutex_lock(&kvm->lock);\n\n\tmatch = kvm_find_assigned_dev(&kvm->arch.assigned_dev_head,\n\t\t\t\t      assigned_irq->assigned_dev_id);\n\tif (!match)\n\t\tgoto out;\n\n\tirq_type = assigned_irq->flags & (KVM_DEV_IRQ_HOST_MASK |\n\t\t\t\t\t  KVM_DEV_IRQ_GUEST_MASK);\n\tr = kvm_deassign_irq(kvm, match, irq_type);\nout:\n\tmutex_unlock(&kvm->lock);\n\treturn r;\n}"
  },
  {
    "function_name": "kvm_vm_ioctl_assign_irq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/assigned-dev.c",
    "lines": "574-614",
    "snippet": "static int kvm_vm_ioctl_assign_irq(struct kvm *kvm,\n\t\t\t\t   struct kvm_assigned_irq *assigned_irq)\n{\n\tint r = -EINVAL;\n\tstruct kvm_assigned_dev_kernel *match;\n\tunsigned long host_irq_type, guest_irq_type;\n\n\tif (!irqchip_in_kernel(kvm))\n\t\treturn r;\n\n\tmutex_lock(&kvm->lock);\n\tr = -ENODEV;\n\tmatch = kvm_find_assigned_dev(&kvm->arch.assigned_dev_head,\n\t\t\t\t      assigned_irq->assigned_dev_id);\n\tif (!match)\n\t\tgoto out;\n\n\thost_irq_type = (assigned_irq->flags & KVM_DEV_IRQ_HOST_MASK);\n\tguest_irq_type = (assigned_irq->flags & KVM_DEV_IRQ_GUEST_MASK);\n\n\tr = -EINVAL;\n\t/* can only assign one type at a time */\n\tif (hweight_long(host_irq_type) > 1)\n\t\tgoto out;\n\tif (hweight_long(guest_irq_type) > 1)\n\t\tgoto out;\n\tif (host_irq_type == 0 && guest_irq_type == 0)\n\t\tgoto out;\n\n\tr = 0;\n\tif (host_irq_type)\n\t\tr = assign_host_irq(kvm, match, host_irq_type);\n\tif (r)\n\t\tgoto out;\n\n\tif (guest_irq_type)\n\t\tr = assign_guest_irq(kvm, match, assigned_irq, guest_irq_type);\nout:\n\tmutex_unlock(&kvm->lock);\n\treturn r;\n}",
    "includes": [
      "#include \"trace/events/kvm.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"irq.h\"",
      "#include <linux/fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/pci.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/errno.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&kvm->lock"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assign_guest_irq",
          "args": [
            "kvm",
            "match",
            "assigned_irq",
            "guest_irq_type"
          ],
          "line": 610
        },
        "resolved": true,
        "details": {
          "function_name": "assign_guest_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/assigned-dev.c",
          "lines": "530-571",
          "snippet": "static int assign_guest_irq(struct kvm *kvm,\n\t\t\t    struct kvm_assigned_dev_kernel *dev,\n\t\t\t    struct kvm_assigned_irq *irq,\n\t\t\t    unsigned long guest_irq_type)\n{\n\tint id;\n\tint r = -EEXIST;\n\n\tif (dev->irq_requested_type & KVM_DEV_IRQ_GUEST_MASK)\n\t\treturn r;\n\n\tid = kvm_request_irq_source_id(kvm);\n\tif (id < 0)\n\t\treturn id;\n\n\tdev->irq_source_id = id;\n\n\tswitch (guest_irq_type) {\n\tcase KVM_DEV_IRQ_GUEST_INTX:\n\t\tr = assigned_device_enable_guest_intx(kvm, dev, irq);\n\t\tbreak;\n\tcase KVM_DEV_IRQ_GUEST_MSI:\n\t\tr = assigned_device_enable_guest_msi(kvm, dev, irq);\n\t\tbreak;\n\tcase KVM_DEV_IRQ_GUEST_MSIX:\n\t\tr = assigned_device_enable_guest_msix(kvm, dev, irq);\n\t\tbreak;\n\tdefault:\n\t\tr = -EINVAL;\n\t}\n\n\tif (!r) {\n\t\tdev->irq_requested_type |= guest_irq_type;\n\t\tif (dev->ack_notifier.gsi != -1)\n\t\t\tkvm_register_irq_ack_notifier(kvm, &dev->ack_notifier);\n\t} else {\n\t\tkvm_free_irq_source_id(kvm, dev->irq_source_id);\n\t\tdev->irq_source_id = -1;\n\t}\n\n\treturn r;\n}",
          "includes": [
            "#include \"trace/events/kvm.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"irq.h\"",
            "#include <linux/fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/pci.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/errno.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace/events/kvm.h\"\n#include \"assigned-dev.h\"\n#include \"irq.h\"\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/spinlock.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic int assign_guest_irq(struct kvm *kvm,\n\t\t\t    struct kvm_assigned_dev_kernel *dev,\n\t\t\t    struct kvm_assigned_irq *irq,\n\t\t\t    unsigned long guest_irq_type)\n{\n\tint id;\n\tint r = -EEXIST;\n\n\tif (dev->irq_requested_type & KVM_DEV_IRQ_GUEST_MASK)\n\t\treturn r;\n\n\tid = kvm_request_irq_source_id(kvm);\n\tif (id < 0)\n\t\treturn id;\n\n\tdev->irq_source_id = id;\n\n\tswitch (guest_irq_type) {\n\tcase KVM_DEV_IRQ_GUEST_INTX:\n\t\tr = assigned_device_enable_guest_intx(kvm, dev, irq);\n\t\tbreak;\n\tcase KVM_DEV_IRQ_GUEST_MSI:\n\t\tr = assigned_device_enable_guest_msi(kvm, dev, irq);\n\t\tbreak;\n\tcase KVM_DEV_IRQ_GUEST_MSIX:\n\t\tr = assigned_device_enable_guest_msix(kvm, dev, irq);\n\t\tbreak;\n\tdefault:\n\t\tr = -EINVAL;\n\t}\n\n\tif (!r) {\n\t\tdev->irq_requested_type |= guest_irq_type;\n\t\tif (dev->ack_notifier.gsi != -1)\n\t\t\tkvm_register_irq_ack_notifier(kvm, &dev->ack_notifier);\n\t} else {\n\t\tkvm_free_irq_source_id(kvm, dev->irq_source_id);\n\t\tdev->irq_source_id = -1;\n\t}\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assign_host_irq",
          "args": [
            "kvm",
            "match",
            "host_irq_type"
          ],
          "line": 605
        },
        "resolved": true,
        "details": {
          "function_name": "assign_host_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/assigned-dev.c",
          "lines": "497-528",
          "snippet": "static int assign_host_irq(struct kvm *kvm,\n\t\t\t   struct kvm_assigned_dev_kernel *dev,\n\t\t\t   __u32 host_irq_type)\n{\n\tint r = -EEXIST;\n\n\tif (dev->irq_requested_type & KVM_DEV_IRQ_HOST_MASK)\n\t\treturn r;\n\n\tsnprintf(dev->irq_name, sizeof(dev->irq_name), \"kvm:%s\",\n\t\t pci_name(dev->dev));\n\n\tswitch (host_irq_type) {\n\tcase KVM_DEV_IRQ_HOST_INTX:\n\t\tr = assigned_device_enable_host_intx(kvm, dev);\n\t\tbreak;\n\tcase KVM_DEV_IRQ_HOST_MSI:\n\t\tr = assigned_device_enable_host_msi(kvm, dev);\n\t\tbreak;\n\tcase KVM_DEV_IRQ_HOST_MSIX:\n\t\tr = assigned_device_enable_host_msix(kvm, dev);\n\t\tbreak;\n\tdefault:\n\t\tr = -EINVAL;\n\t}\n\tdev->host_irq_disabled = false;\n\n\tif (!r)\n\t\tdev->irq_requested_type |= host_irq_type;\n\n\treturn r;\n}",
          "includes": [
            "#include \"trace/events/kvm.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"irq.h\"",
            "#include <linux/fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/pci.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/errno.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace/events/kvm.h\"\n#include \"assigned-dev.h\"\n#include \"irq.h\"\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/spinlock.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic int assign_host_irq(struct kvm *kvm,\n\t\t\t   struct kvm_assigned_dev_kernel *dev,\n\t\t\t   __u32 host_irq_type)\n{\n\tint r = -EEXIST;\n\n\tif (dev->irq_requested_type & KVM_DEV_IRQ_HOST_MASK)\n\t\treturn r;\n\n\tsnprintf(dev->irq_name, sizeof(dev->irq_name), \"kvm:%s\",\n\t\t pci_name(dev->dev));\n\n\tswitch (host_irq_type) {\n\tcase KVM_DEV_IRQ_HOST_INTX:\n\t\tr = assigned_device_enable_host_intx(kvm, dev);\n\t\tbreak;\n\tcase KVM_DEV_IRQ_HOST_MSI:\n\t\tr = assigned_device_enable_host_msi(kvm, dev);\n\t\tbreak;\n\tcase KVM_DEV_IRQ_HOST_MSIX:\n\t\tr = assigned_device_enable_host_msix(kvm, dev);\n\t\tbreak;\n\tdefault:\n\t\tr = -EINVAL;\n\t}\n\tdev->host_irq_disabled = false;\n\n\tif (!r)\n\t\tdev->irq_requested_type |= host_irq_type;\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hweight_long",
          "args": [
            "guest_irq_type"
          ],
          "line": 598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hweight_long",
          "args": [
            "host_irq_type"
          ],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_find_assigned_dev",
          "args": [
            "&kvm->arch.assigned_dev_head",
            "assigned_irq->assigned_dev_id"
          ],
          "line": 586
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_find_assigned_dev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/assigned-dev.c",
          "lines": "51-61",
          "snippet": "static struct kvm_assigned_dev_kernel *kvm_find_assigned_dev(struct list_head *head,\n\t\t\t\t\t\t      int assigned_dev_id)\n{\n\tstruct kvm_assigned_dev_kernel *match;\n\n\tlist_for_each_entry(match, head, list) {\n\t\tif (match->assigned_dev_id == assigned_dev_id)\n\t\t\treturn match;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace/events/kvm.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"irq.h\"",
            "#include <linux/fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/pci.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/errno.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace/events/kvm.h\"\n#include \"assigned-dev.h\"\n#include \"irq.h\"\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/spinlock.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic struct kvm_assigned_dev_kernel *kvm_find_assigned_dev(struct list_head *head,\n\t\t\t\t\t\t      int assigned_dev_id)\n{\n\tstruct kvm_assigned_dev_kernel *match;\n\n\tlist_for_each_entry(match, head, list) {\n\t\tif (match->assigned_dev_id == assigned_dev_id)\n\t\t\treturn match;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&kvm->lock"
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irqchip_in_kernel",
          "args": [
            "kvm"
          ],
          "line": 581
        },
        "resolved": true,
        "details": {
          "function_name": "irqchip_in_kernel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/irq.h",
          "lines": "99-110",
          "snippet": "static inline int irqchip_in_kernel(struct kvm *kvm)\n{\n\tstruct kvm_pic *vpic = pic_irqchip(kvm);\n\tbool ret;\n\n\tret = (vpic != NULL);\n\tret |= irqchip_split(kvm);\n\n\t/* Read vpic before kvm->irq_routing.  */\n\tsmp_rmb();\n\treturn ret;\n}",
          "includes": [
            "#include \"lapic.h\"",
            "#include \"ioapic.h\"",
            "#include <kvm/iodev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/mm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <kvm/iodev.h>\n#include <linux/spinlock.h>\n#include <linux/kvm_host.h>\n#include <linux/hrtimer.h>\n#include <linux/mm_types.h>\n\nstatic inline int irqchip_in_kernel(struct kvm *kvm)\n{\n\tstruct kvm_pic *vpic = pic_irqchip(kvm);\n\tbool ret;\n\n\tret = (vpic != NULL);\n\tret |= irqchip_split(kvm);\n\n\t/* Read vpic before kvm->irq_routing.  */\n\tsmp_rmb();\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace/events/kvm.h\"\n#include \"assigned-dev.h\"\n#include \"irq.h\"\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/spinlock.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic int kvm_vm_ioctl_assign_irq(struct kvm *kvm,\n\t\t\t\t   struct kvm_assigned_irq *assigned_irq)\n{\n\tint r = -EINVAL;\n\tstruct kvm_assigned_dev_kernel *match;\n\tunsigned long host_irq_type, guest_irq_type;\n\n\tif (!irqchip_in_kernel(kvm))\n\t\treturn r;\n\n\tmutex_lock(&kvm->lock);\n\tr = -ENODEV;\n\tmatch = kvm_find_assigned_dev(&kvm->arch.assigned_dev_head,\n\t\t\t\t      assigned_irq->assigned_dev_id);\n\tif (!match)\n\t\tgoto out;\n\n\thost_irq_type = (assigned_irq->flags & KVM_DEV_IRQ_HOST_MASK);\n\tguest_irq_type = (assigned_irq->flags & KVM_DEV_IRQ_GUEST_MASK);\n\n\tr = -EINVAL;\n\t/* can only assign one type at a time */\n\tif (hweight_long(host_irq_type) > 1)\n\t\tgoto out;\n\tif (hweight_long(guest_irq_type) > 1)\n\t\tgoto out;\n\tif (host_irq_type == 0 && guest_irq_type == 0)\n\t\tgoto out;\n\n\tr = 0;\n\tif (host_irq_type)\n\t\tr = assign_host_irq(kvm, match, host_irq_type);\n\tif (r)\n\t\tgoto out;\n\n\tif (guest_irq_type)\n\t\tr = assign_guest_irq(kvm, match, assigned_irq, guest_irq_type);\nout:\n\tmutex_unlock(&kvm->lock);\n\treturn r;\n}"
  },
  {
    "function_name": "assign_guest_irq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/assigned-dev.c",
    "lines": "530-571",
    "snippet": "static int assign_guest_irq(struct kvm *kvm,\n\t\t\t    struct kvm_assigned_dev_kernel *dev,\n\t\t\t    struct kvm_assigned_irq *irq,\n\t\t\t    unsigned long guest_irq_type)\n{\n\tint id;\n\tint r = -EEXIST;\n\n\tif (dev->irq_requested_type & KVM_DEV_IRQ_GUEST_MASK)\n\t\treturn r;\n\n\tid = kvm_request_irq_source_id(kvm);\n\tif (id < 0)\n\t\treturn id;\n\n\tdev->irq_source_id = id;\n\n\tswitch (guest_irq_type) {\n\tcase KVM_DEV_IRQ_GUEST_INTX:\n\t\tr = assigned_device_enable_guest_intx(kvm, dev, irq);\n\t\tbreak;\n\tcase KVM_DEV_IRQ_GUEST_MSI:\n\t\tr = assigned_device_enable_guest_msi(kvm, dev, irq);\n\t\tbreak;\n\tcase KVM_DEV_IRQ_GUEST_MSIX:\n\t\tr = assigned_device_enable_guest_msix(kvm, dev, irq);\n\t\tbreak;\n\tdefault:\n\t\tr = -EINVAL;\n\t}\n\n\tif (!r) {\n\t\tdev->irq_requested_type |= guest_irq_type;\n\t\tif (dev->ack_notifier.gsi != -1)\n\t\t\tkvm_register_irq_ack_notifier(kvm, &dev->ack_notifier);\n\t} else {\n\t\tkvm_free_irq_source_id(kvm, dev->irq_source_id);\n\t\tdev->irq_source_id = -1;\n\t}\n\n\treturn r;\n}",
    "includes": [
      "#include \"trace/events/kvm.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"irq.h\"",
      "#include <linux/fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/pci.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/errno.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_free_irq_source_id",
          "args": [
            "kvm",
            "dev->irq_source_id"
          ],
          "line": 566
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_free_irq_source_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/irq_comm.c",
          "lines": "187-206",
          "snippet": "void kvm_free_irq_source_id(struct kvm *kvm, int irq_source_id)\n{\n\tASSERT(irq_source_id != KVM_USERSPACE_IRQ_SOURCE_ID);\n\tASSERT(irq_source_id != KVM_IRQFD_RESAMPLE_IRQ_SOURCE_ID);\n\n\tmutex_lock(&kvm->irq_lock);\n\tif (irq_source_id < 0 ||\n\t    irq_source_id >= BITS_PER_LONG) {\n\t\tprintk(KERN_ERR \"kvm: IRQ source ID out of range!\\n\");\n\t\tgoto unlock;\n\t}\n\tclear_bit(irq_source_id, &kvm->arch.irq_sources_bitmap);\n\tif (!ioapic_in_kernel(kvm))\n\t\tgoto unlock;\n\n\tkvm_ioapic_clear_all(kvm->arch.vioapic, irq_source_id);\n\tkvm_pic_clear_all(pic_irqchip(kvm), irq_source_id);\nunlock:\n\tmutex_unlock(&kvm->irq_lock);\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"hyperv.h\"",
            "#include \"lapic.h\"",
            "#include \"ioapic.h\"",
            "#include \"irq.h\"",
            "#include <asm/msidef.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"hyperv.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include \"irq.h\"\n#include <asm/msidef.h>\n#include <trace/events/kvm.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nvoid kvm_free_irq_source_id(struct kvm *kvm, int irq_source_id)\n{\n\tASSERT(irq_source_id != KVM_USERSPACE_IRQ_SOURCE_ID);\n\tASSERT(irq_source_id != KVM_IRQFD_RESAMPLE_IRQ_SOURCE_ID);\n\n\tmutex_lock(&kvm->irq_lock);\n\tif (irq_source_id < 0 ||\n\t    irq_source_id >= BITS_PER_LONG) {\n\t\tprintk(KERN_ERR \"kvm: IRQ source ID out of range!\\n\");\n\t\tgoto unlock;\n\t}\n\tclear_bit(irq_source_id, &kvm->arch.irq_sources_bitmap);\n\tif (!ioapic_in_kernel(kvm))\n\t\tgoto unlock;\n\n\tkvm_ioapic_clear_all(kvm->arch.vioapic, irq_source_id);\n\tkvm_pic_clear_all(pic_irqchip(kvm), irq_source_id);\nunlock:\n\tmutex_unlock(&kvm->irq_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_register_irq_ack_notifier",
          "args": [
            "kvm",
            "&dev->ack_notifier"
          ],
          "line": 564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assigned_device_enable_guest_msix",
          "args": [
            "kvm",
            "dev",
            "irq"
          ],
          "line": 555
        },
        "resolved": true,
        "details": {
          "function_name": "assigned_device_enable_guest_msix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/assigned-dev.c",
          "lines": "488-495",
          "snippet": "static int assigned_device_enable_guest_msix(struct kvm *kvm,\n\t\t\tstruct kvm_assigned_dev_kernel *dev,\n\t\t\tstruct kvm_assigned_irq *irq)\n{\n\tdev->guest_irq = irq->guest_irq;\n\tdev->ack_notifier.gsi = -1;\n\treturn 0;\n}",
          "includes": [
            "#include \"trace/events/kvm.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"irq.h\"",
            "#include <linux/fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/pci.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/errno.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace/events/kvm.h\"\n#include \"assigned-dev.h\"\n#include \"irq.h\"\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/spinlock.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic int assigned_device_enable_guest_msix(struct kvm *kvm,\n\t\t\tstruct kvm_assigned_dev_kernel *dev,\n\t\t\tstruct kvm_assigned_irq *irq)\n{\n\tdev->guest_irq = irq->guest_irq;\n\tdev->ack_notifier.gsi = -1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assigned_device_enable_guest_intx",
          "args": [
            "kvm",
            "dev",
            "irq"
          ],
          "line": 549
        },
        "resolved": true,
        "details": {
          "function_name": "assigned_device_enable_guest_intx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/assigned-dev.c",
          "lines": "470-477",
          "snippet": "static int assigned_device_enable_guest_intx(struct kvm *kvm,\n\t\t\t\tstruct kvm_assigned_dev_kernel *dev,\n\t\t\t\tstruct kvm_assigned_irq *irq)\n{\n\tdev->guest_irq = irq->guest_irq;\n\tdev->ack_notifier.gsi = irq->guest_irq;\n\treturn 0;\n}",
          "includes": [
            "#include \"trace/events/kvm.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"irq.h\"",
            "#include <linux/fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/pci.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/errno.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace/events/kvm.h\"\n#include \"assigned-dev.h\"\n#include \"irq.h\"\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/spinlock.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic int assigned_device_enable_guest_intx(struct kvm *kvm,\n\t\t\t\tstruct kvm_assigned_dev_kernel *dev,\n\t\t\t\tstruct kvm_assigned_irq *irq)\n{\n\tdev->guest_irq = irq->guest_irq;\n\tdev->ack_notifier.gsi = irq->guest_irq;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_request_irq_source_id",
          "args": [
            "kvm"
          ],
          "line": 541
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_request_irq_source_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/irq_comm.c",
          "lines": "164-185",
          "snippet": "int kvm_request_irq_source_id(struct kvm *kvm)\n{\n\tunsigned long *bitmap = &kvm->arch.irq_sources_bitmap;\n\tint irq_source_id;\n\n\tmutex_lock(&kvm->irq_lock);\n\tirq_source_id = find_first_zero_bit(bitmap, BITS_PER_LONG);\n\n\tif (irq_source_id >= BITS_PER_LONG) {\n\t\tprintk(KERN_WARNING \"kvm: exhaust allocatable IRQ sources!\\n\");\n\t\tirq_source_id = -EFAULT;\n\t\tgoto unlock;\n\t}\n\n\tASSERT(irq_source_id != KVM_USERSPACE_IRQ_SOURCE_ID);\n\tASSERT(irq_source_id != KVM_IRQFD_RESAMPLE_IRQ_SOURCE_ID);\n\tset_bit(irq_source_id, bitmap);\nunlock:\n\tmutex_unlock(&kvm->irq_lock);\n\n\treturn irq_source_id;\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"hyperv.h\"",
            "#include \"lapic.h\"",
            "#include \"ioapic.h\"",
            "#include \"irq.h\"",
            "#include <asm/msidef.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"hyperv.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include \"irq.h\"\n#include <asm/msidef.h>\n#include <trace/events/kvm.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nint kvm_request_irq_source_id(struct kvm *kvm)\n{\n\tunsigned long *bitmap = &kvm->arch.irq_sources_bitmap;\n\tint irq_source_id;\n\n\tmutex_lock(&kvm->irq_lock);\n\tirq_source_id = find_first_zero_bit(bitmap, BITS_PER_LONG);\n\n\tif (irq_source_id >= BITS_PER_LONG) {\n\t\tprintk(KERN_WARNING \"kvm: exhaust allocatable IRQ sources!\\n\");\n\t\tirq_source_id = -EFAULT;\n\t\tgoto unlock;\n\t}\n\n\tASSERT(irq_source_id != KVM_USERSPACE_IRQ_SOURCE_ID);\n\tASSERT(irq_source_id != KVM_IRQFD_RESAMPLE_IRQ_SOURCE_ID);\n\tset_bit(irq_source_id, bitmap);\nunlock:\n\tmutex_unlock(&kvm->irq_lock);\n\n\treturn irq_source_id;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace/events/kvm.h\"\n#include \"assigned-dev.h\"\n#include \"irq.h\"\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/spinlock.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic int assign_guest_irq(struct kvm *kvm,\n\t\t\t    struct kvm_assigned_dev_kernel *dev,\n\t\t\t    struct kvm_assigned_irq *irq,\n\t\t\t    unsigned long guest_irq_type)\n{\n\tint id;\n\tint r = -EEXIST;\n\n\tif (dev->irq_requested_type & KVM_DEV_IRQ_GUEST_MASK)\n\t\treturn r;\n\n\tid = kvm_request_irq_source_id(kvm);\n\tif (id < 0)\n\t\treturn id;\n\n\tdev->irq_source_id = id;\n\n\tswitch (guest_irq_type) {\n\tcase KVM_DEV_IRQ_GUEST_INTX:\n\t\tr = assigned_device_enable_guest_intx(kvm, dev, irq);\n\t\tbreak;\n\tcase KVM_DEV_IRQ_GUEST_MSI:\n\t\tr = assigned_device_enable_guest_msi(kvm, dev, irq);\n\t\tbreak;\n\tcase KVM_DEV_IRQ_GUEST_MSIX:\n\t\tr = assigned_device_enable_guest_msix(kvm, dev, irq);\n\t\tbreak;\n\tdefault:\n\t\tr = -EINVAL;\n\t}\n\n\tif (!r) {\n\t\tdev->irq_requested_type |= guest_irq_type;\n\t\tif (dev->ack_notifier.gsi != -1)\n\t\t\tkvm_register_irq_ack_notifier(kvm, &dev->ack_notifier);\n\t} else {\n\t\tkvm_free_irq_source_id(kvm, dev->irq_source_id);\n\t\tdev->irq_source_id = -1;\n\t}\n\n\treturn r;\n}"
  },
  {
    "function_name": "assign_host_irq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/assigned-dev.c",
    "lines": "497-528",
    "snippet": "static int assign_host_irq(struct kvm *kvm,\n\t\t\t   struct kvm_assigned_dev_kernel *dev,\n\t\t\t   __u32 host_irq_type)\n{\n\tint r = -EEXIST;\n\n\tif (dev->irq_requested_type & KVM_DEV_IRQ_HOST_MASK)\n\t\treturn r;\n\n\tsnprintf(dev->irq_name, sizeof(dev->irq_name), \"kvm:%s\",\n\t\t pci_name(dev->dev));\n\n\tswitch (host_irq_type) {\n\tcase KVM_DEV_IRQ_HOST_INTX:\n\t\tr = assigned_device_enable_host_intx(kvm, dev);\n\t\tbreak;\n\tcase KVM_DEV_IRQ_HOST_MSI:\n\t\tr = assigned_device_enable_host_msi(kvm, dev);\n\t\tbreak;\n\tcase KVM_DEV_IRQ_HOST_MSIX:\n\t\tr = assigned_device_enable_host_msix(kvm, dev);\n\t\tbreak;\n\tdefault:\n\t\tr = -EINVAL;\n\t}\n\tdev->host_irq_disabled = false;\n\n\tif (!r)\n\t\tdev->irq_requested_type |= host_irq_type;\n\n\treturn r;\n}",
    "includes": [
      "#include \"trace/events/kvm.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"irq.h\"",
      "#include <linux/fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/pci.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/errno.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "assigned_device_enable_host_msix",
          "args": [
            "kvm",
            "dev"
          ],
          "line": 517
        },
        "resolved": true,
        "details": {
          "function_name": "assigned_device_enable_host_msix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/assigned-dev.c",
          "lines": "438-468",
          "snippet": "static int assigned_device_enable_host_msix(struct kvm *kvm,\n\t\t\t\t\t    struct kvm_assigned_dev_kernel *dev)\n{\n\tint i, r = -EINVAL;\n\n\t/* host_msix_entries and guest_msix_entries should have been\n\t * initialized */\n\tif (dev->entries_nr == 0)\n\t\treturn r;\n\n\tr = pci_enable_msix_exact(dev->dev,\n\t\t\t\t  dev->host_msix_entries, dev->entries_nr);\n\tif (r)\n\t\treturn r;\n\n\tfor (i = 0; i < dev->entries_nr; i++) {\n\t\tr = request_threaded_irq(dev->host_msix_entries[i].vector,\n\t\t\t\t\t kvm_assigned_dev_msix,\n\t\t\t\t\t kvm_assigned_dev_thread_msix,\n\t\t\t\t\t 0, dev->irq_name, dev);\n\t\tif (r)\n\t\t\tgoto err;\n\t}\n\n\treturn 0;\nerr:\n\tfor (i -= 1; i >= 0; i--)\n\t\tfree_irq(dev->host_msix_entries[i].vector, dev);\n\tpci_disable_msix(dev->dev);\n\treturn r;\n}",
          "includes": [
            "#include \"trace/events/kvm.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"irq.h\"",
            "#include <linux/fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/pci.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/errno.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace/events/kvm.h\"\n#include \"assigned-dev.h\"\n#include \"irq.h\"\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/spinlock.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic int assigned_device_enable_host_msix(struct kvm *kvm,\n\t\t\t\t\t    struct kvm_assigned_dev_kernel *dev)\n{\n\tint i, r = -EINVAL;\n\n\t/* host_msix_entries and guest_msix_entries should have been\n\t * initialized */\n\tif (dev->entries_nr == 0)\n\t\treturn r;\n\n\tr = pci_enable_msix_exact(dev->dev,\n\t\t\t\t  dev->host_msix_entries, dev->entries_nr);\n\tif (r)\n\t\treturn r;\n\n\tfor (i = 0; i < dev->entries_nr; i++) {\n\t\tr = request_threaded_irq(dev->host_msix_entries[i].vector,\n\t\t\t\t\t kvm_assigned_dev_msix,\n\t\t\t\t\t kvm_assigned_dev_thread_msix,\n\t\t\t\t\t 0, dev->irq_name, dev);\n\t\tif (r)\n\t\t\tgoto err;\n\t}\n\n\treturn 0;\nerr:\n\tfor (i -= 1; i >= 0; i--)\n\t\tfree_irq(dev->host_msix_entries[i].vector, dev);\n\tpci_disable_msix(dev->dev);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assigned_device_enable_host_intx",
          "args": [
            "kvm",
            "dev"
          ],
          "line": 511
        },
        "resolved": true,
        "details": {
          "function_name": "assigned_device_enable_host_intx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/assigned-dev.c",
          "lines": "382-414",
          "snippet": "static int assigned_device_enable_host_intx(struct kvm *kvm,\n\t\t\t\t\t    struct kvm_assigned_dev_kernel *dev)\n{\n\tirq_handler_t irq_handler;\n\tunsigned long flags;\n\n\tdev->host_irq = dev->dev->irq;\n\n\t/*\n\t * We can only share the IRQ line with other host devices if we are\n\t * able to disable the IRQ source at device-level - independently of\n\t * the guest driver. Otherwise host devices may suffer from unbounded\n\t * IRQ latencies when the guest keeps the line asserted.\n\t */\n\tif (dev->flags & KVM_DEV_ASSIGN_PCI_2_3) {\n\t\tirq_handler = kvm_assigned_dev_intx;\n\t\tflags = IRQF_SHARED;\n\t} else {\n\t\tirq_handler = NULL;\n\t\tflags = IRQF_ONESHOT;\n\t}\n\tif (request_threaded_irq(dev->host_irq, irq_handler,\n\t\t\t\t kvm_assigned_dev_thread_intx, flags,\n\t\t\t\t dev->irq_name, dev))\n\t\treturn -EIO;\n\n\tif (dev->flags & KVM_DEV_ASSIGN_PCI_2_3) {\n\t\tspin_lock_irq(&dev->intx_lock);\n\t\tpci_intx(dev->dev, true);\n\t\tspin_unlock_irq(&dev->intx_lock);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"trace/events/kvm.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"irq.h\"",
            "#include <linux/fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/pci.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/errno.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace/events/kvm.h\"\n#include \"assigned-dev.h\"\n#include \"irq.h\"\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/spinlock.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic int assigned_device_enable_host_intx(struct kvm *kvm,\n\t\t\t\t\t    struct kvm_assigned_dev_kernel *dev)\n{\n\tirq_handler_t irq_handler;\n\tunsigned long flags;\n\n\tdev->host_irq = dev->dev->irq;\n\n\t/*\n\t * We can only share the IRQ line with other host devices if we are\n\t * able to disable the IRQ source at device-level - independently of\n\t * the guest driver. Otherwise host devices may suffer from unbounded\n\t * IRQ latencies when the guest keeps the line asserted.\n\t */\n\tif (dev->flags & KVM_DEV_ASSIGN_PCI_2_3) {\n\t\tirq_handler = kvm_assigned_dev_intx;\n\t\tflags = IRQF_SHARED;\n\t} else {\n\t\tirq_handler = NULL;\n\t\tflags = IRQF_ONESHOT;\n\t}\n\tif (request_threaded_irq(dev->host_irq, irq_handler,\n\t\t\t\t kvm_assigned_dev_thread_intx, flags,\n\t\t\t\t dev->irq_name, dev))\n\t\treturn -EIO;\n\n\tif (dev->flags & KVM_DEV_ASSIGN_PCI_2_3) {\n\t\tspin_lock_irq(&dev->intx_lock);\n\t\tpci_intx(dev->dev, true);\n\t\tspin_unlock_irq(&dev->intx_lock);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "dev->irq_name",
            "sizeof(dev->irq_name)",
            "\"kvm:%s\"",
            "pci_name(dev->dev)"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_name",
          "args": [
            "dev->dev"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace/events/kvm.h\"\n#include \"assigned-dev.h\"\n#include \"irq.h\"\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/spinlock.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic int assign_host_irq(struct kvm *kvm,\n\t\t\t   struct kvm_assigned_dev_kernel *dev,\n\t\t\t   __u32 host_irq_type)\n{\n\tint r = -EEXIST;\n\n\tif (dev->irq_requested_type & KVM_DEV_IRQ_HOST_MASK)\n\t\treturn r;\n\n\tsnprintf(dev->irq_name, sizeof(dev->irq_name), \"kvm:%s\",\n\t\t pci_name(dev->dev));\n\n\tswitch (host_irq_type) {\n\tcase KVM_DEV_IRQ_HOST_INTX:\n\t\tr = assigned_device_enable_host_intx(kvm, dev);\n\t\tbreak;\n\tcase KVM_DEV_IRQ_HOST_MSI:\n\t\tr = assigned_device_enable_host_msi(kvm, dev);\n\t\tbreak;\n\tcase KVM_DEV_IRQ_HOST_MSIX:\n\t\tr = assigned_device_enable_host_msix(kvm, dev);\n\t\tbreak;\n\tdefault:\n\t\tr = -EINVAL;\n\t}\n\tdev->host_irq_disabled = false;\n\n\tif (!r)\n\t\tdev->irq_requested_type |= host_irq_type;\n\n\treturn r;\n}"
  },
  {
    "function_name": "assigned_device_enable_guest_msix",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/assigned-dev.c",
    "lines": "488-495",
    "snippet": "static int assigned_device_enable_guest_msix(struct kvm *kvm,\n\t\t\tstruct kvm_assigned_dev_kernel *dev,\n\t\t\tstruct kvm_assigned_irq *irq)\n{\n\tdev->guest_irq = irq->guest_irq;\n\tdev->ack_notifier.gsi = -1;\n\treturn 0;\n}",
    "includes": [
      "#include \"trace/events/kvm.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"irq.h\"",
      "#include <linux/fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/pci.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/errno.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace/events/kvm.h\"\n#include \"assigned-dev.h\"\n#include \"irq.h\"\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/spinlock.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic int assigned_device_enable_guest_msix(struct kvm *kvm,\n\t\t\tstruct kvm_assigned_dev_kernel *dev,\n\t\t\tstruct kvm_assigned_irq *irq)\n{\n\tdev->guest_irq = irq->guest_irq;\n\tdev->ack_notifier.gsi = -1;\n\treturn 0;\n}"
  },
  {
    "function_name": "assigned_device_enable_guest_msi",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/assigned-dev.c",
    "lines": "479-486",
    "snippet": "static int assigned_device_enable_guest_msi(struct kvm *kvm,\n\t\t\tstruct kvm_assigned_dev_kernel *dev,\n\t\t\tstruct kvm_assigned_irq *irq)\n{\n\tdev->guest_irq = irq->guest_irq;\n\tdev->ack_notifier.gsi = -1;\n\treturn 0;\n}",
    "includes": [
      "#include \"trace/events/kvm.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"irq.h\"",
      "#include <linux/fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/pci.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/errno.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace/events/kvm.h\"\n#include \"assigned-dev.h\"\n#include \"irq.h\"\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/spinlock.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic int assigned_device_enable_guest_msi(struct kvm *kvm,\n\t\t\tstruct kvm_assigned_dev_kernel *dev,\n\t\t\tstruct kvm_assigned_irq *irq)\n{\n\tdev->guest_irq = irq->guest_irq;\n\tdev->ack_notifier.gsi = -1;\n\treturn 0;\n}"
  },
  {
    "function_name": "assigned_device_enable_guest_intx",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/assigned-dev.c",
    "lines": "470-477",
    "snippet": "static int assigned_device_enable_guest_intx(struct kvm *kvm,\n\t\t\t\tstruct kvm_assigned_dev_kernel *dev,\n\t\t\t\tstruct kvm_assigned_irq *irq)\n{\n\tdev->guest_irq = irq->guest_irq;\n\tdev->ack_notifier.gsi = irq->guest_irq;\n\treturn 0;\n}",
    "includes": [
      "#include \"trace/events/kvm.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"irq.h\"",
      "#include <linux/fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/pci.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/errno.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace/events/kvm.h\"\n#include \"assigned-dev.h\"\n#include \"irq.h\"\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/spinlock.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic int assigned_device_enable_guest_intx(struct kvm *kvm,\n\t\t\t\tstruct kvm_assigned_dev_kernel *dev,\n\t\t\t\tstruct kvm_assigned_irq *irq)\n{\n\tdev->guest_irq = irq->guest_irq;\n\tdev->ack_notifier.gsi = irq->guest_irq;\n\treturn 0;\n}"
  },
  {
    "function_name": "assigned_device_enable_host_msix",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/assigned-dev.c",
    "lines": "438-468",
    "snippet": "static int assigned_device_enable_host_msix(struct kvm *kvm,\n\t\t\t\t\t    struct kvm_assigned_dev_kernel *dev)\n{\n\tint i, r = -EINVAL;\n\n\t/* host_msix_entries and guest_msix_entries should have been\n\t * initialized */\n\tif (dev->entries_nr == 0)\n\t\treturn r;\n\n\tr = pci_enable_msix_exact(dev->dev,\n\t\t\t\t  dev->host_msix_entries, dev->entries_nr);\n\tif (r)\n\t\treturn r;\n\n\tfor (i = 0; i < dev->entries_nr; i++) {\n\t\tr = request_threaded_irq(dev->host_msix_entries[i].vector,\n\t\t\t\t\t kvm_assigned_dev_msix,\n\t\t\t\t\t kvm_assigned_dev_thread_msix,\n\t\t\t\t\t 0, dev->irq_name, dev);\n\t\tif (r)\n\t\t\tgoto err;\n\t}\n\n\treturn 0;\nerr:\n\tfor (i -= 1; i >= 0; i--)\n\t\tfree_irq(dev->host_msix_entries[i].vector, dev);\n\tpci_disable_msix(dev->dev);\n\treturn r;\n}",
    "includes": [
      "#include \"trace/events/kvm.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"irq.h\"",
      "#include <linux/fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/pci.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/errno.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pci_disable_msix",
          "args": [
            "dev->dev"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_irq",
          "args": [
            "dev->host_msix_entries[i].vector",
            "dev"
          ],
          "line": 465
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_free_irq_source_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/irq_comm.c",
          "lines": "187-206",
          "snippet": "void kvm_free_irq_source_id(struct kvm *kvm, int irq_source_id)\n{\n\tASSERT(irq_source_id != KVM_USERSPACE_IRQ_SOURCE_ID);\n\tASSERT(irq_source_id != KVM_IRQFD_RESAMPLE_IRQ_SOURCE_ID);\n\n\tmutex_lock(&kvm->irq_lock);\n\tif (irq_source_id < 0 ||\n\t    irq_source_id >= BITS_PER_LONG) {\n\t\tprintk(KERN_ERR \"kvm: IRQ source ID out of range!\\n\");\n\t\tgoto unlock;\n\t}\n\tclear_bit(irq_source_id, &kvm->arch.irq_sources_bitmap);\n\tif (!ioapic_in_kernel(kvm))\n\t\tgoto unlock;\n\n\tkvm_ioapic_clear_all(kvm->arch.vioapic, irq_source_id);\n\tkvm_pic_clear_all(pic_irqchip(kvm), irq_source_id);\nunlock:\n\tmutex_unlock(&kvm->irq_lock);\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"hyperv.h\"",
            "#include \"lapic.h\"",
            "#include \"ioapic.h\"",
            "#include \"irq.h\"",
            "#include <asm/msidef.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"hyperv.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include \"irq.h\"\n#include <asm/msidef.h>\n#include <trace/events/kvm.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nvoid kvm_free_irq_source_id(struct kvm *kvm, int irq_source_id)\n{\n\tASSERT(irq_source_id != KVM_USERSPACE_IRQ_SOURCE_ID);\n\tASSERT(irq_source_id != KVM_IRQFD_RESAMPLE_IRQ_SOURCE_ID);\n\n\tmutex_lock(&kvm->irq_lock);\n\tif (irq_source_id < 0 ||\n\t    irq_source_id >= BITS_PER_LONG) {\n\t\tprintk(KERN_ERR \"kvm: IRQ source ID out of range!\\n\");\n\t\tgoto unlock;\n\t}\n\tclear_bit(irq_source_id, &kvm->arch.irq_sources_bitmap);\n\tif (!ioapic_in_kernel(kvm))\n\t\tgoto unlock;\n\n\tkvm_ioapic_clear_all(kvm->arch.vioapic, irq_source_id);\n\tkvm_pic_clear_all(pic_irqchip(kvm), irq_source_id);\nunlock:\n\tmutex_unlock(&kvm->irq_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "request_threaded_irq",
          "args": [
            "dev->host_msix_entries[i].vector",
            "kvm_assigned_dev_msix",
            "kvm_assigned_dev_thread_msix",
            "0",
            "dev->irq_name",
            "dev"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_enable_msix_exact",
          "args": [
            "dev->dev",
            "dev->host_msix_entries",
            "dev->entries_nr"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace/events/kvm.h\"\n#include \"assigned-dev.h\"\n#include \"irq.h\"\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/spinlock.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic int assigned_device_enable_host_msix(struct kvm *kvm,\n\t\t\t\t\t    struct kvm_assigned_dev_kernel *dev)\n{\n\tint i, r = -EINVAL;\n\n\t/* host_msix_entries and guest_msix_entries should have been\n\t * initialized */\n\tif (dev->entries_nr == 0)\n\t\treturn r;\n\n\tr = pci_enable_msix_exact(dev->dev,\n\t\t\t\t  dev->host_msix_entries, dev->entries_nr);\n\tif (r)\n\t\treturn r;\n\n\tfor (i = 0; i < dev->entries_nr; i++) {\n\t\tr = request_threaded_irq(dev->host_msix_entries[i].vector,\n\t\t\t\t\t kvm_assigned_dev_msix,\n\t\t\t\t\t kvm_assigned_dev_thread_msix,\n\t\t\t\t\t 0, dev->irq_name, dev);\n\t\tif (r)\n\t\t\tgoto err;\n\t}\n\n\treturn 0;\nerr:\n\tfor (i -= 1; i >= 0; i--)\n\t\tfree_irq(dev->host_msix_entries[i].vector, dev);\n\tpci_disable_msix(dev->dev);\n\treturn r;\n}"
  },
  {
    "function_name": "assigned_device_enable_host_msi",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/assigned-dev.c",
    "lines": "416-436",
    "snippet": "static int assigned_device_enable_host_msi(struct kvm *kvm,\n\t\t\t\t\t   struct kvm_assigned_dev_kernel *dev)\n{\n\tint r;\n\n\tif (!dev->dev->msi_enabled) {\n\t\tr = pci_enable_msi(dev->dev);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\n\tdev->host_irq = dev->dev->irq;\n\tif (request_threaded_irq(dev->host_irq, kvm_assigned_dev_msi,\n\t\t\t\t kvm_assigned_dev_thread_msi, 0,\n\t\t\t\t dev->irq_name, dev)) {\n\t\tpci_disable_msi(dev->dev);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace/events/kvm.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"irq.h\"",
      "#include <linux/fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/pci.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/errno.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pci_disable_msi",
          "args": [
            "dev->dev"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request_threaded_irq",
          "args": [
            "dev->host_irq",
            "kvm_assigned_dev_msi",
            "kvm_assigned_dev_thread_msi",
            "0",
            "dev->irq_name",
            "dev"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_enable_msi",
          "args": [
            "dev->dev"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace/events/kvm.h\"\n#include \"assigned-dev.h\"\n#include \"irq.h\"\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/spinlock.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic int assigned_device_enable_host_msi(struct kvm *kvm,\n\t\t\t\t\t   struct kvm_assigned_dev_kernel *dev)\n{\n\tint r;\n\n\tif (!dev->dev->msi_enabled) {\n\t\tr = pci_enable_msi(dev->dev);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\n\tdev->host_irq = dev->dev->irq;\n\tif (request_threaded_irq(dev->host_irq, kvm_assigned_dev_msi,\n\t\t\t\t kvm_assigned_dev_thread_msi, 0,\n\t\t\t\t dev->irq_name, dev)) {\n\t\tpci_disable_msi(dev->dev);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "assigned_device_enable_host_intx",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/assigned-dev.c",
    "lines": "382-414",
    "snippet": "static int assigned_device_enable_host_intx(struct kvm *kvm,\n\t\t\t\t\t    struct kvm_assigned_dev_kernel *dev)\n{\n\tirq_handler_t irq_handler;\n\tunsigned long flags;\n\n\tdev->host_irq = dev->dev->irq;\n\n\t/*\n\t * We can only share the IRQ line with other host devices if we are\n\t * able to disable the IRQ source at device-level - independently of\n\t * the guest driver. Otherwise host devices may suffer from unbounded\n\t * IRQ latencies when the guest keeps the line asserted.\n\t */\n\tif (dev->flags & KVM_DEV_ASSIGN_PCI_2_3) {\n\t\tirq_handler = kvm_assigned_dev_intx;\n\t\tflags = IRQF_SHARED;\n\t} else {\n\t\tirq_handler = NULL;\n\t\tflags = IRQF_ONESHOT;\n\t}\n\tif (request_threaded_irq(dev->host_irq, irq_handler,\n\t\t\t\t kvm_assigned_dev_thread_intx, flags,\n\t\t\t\t dev->irq_name, dev))\n\t\treturn -EIO;\n\n\tif (dev->flags & KVM_DEV_ASSIGN_PCI_2_3) {\n\t\tspin_lock_irq(&dev->intx_lock);\n\t\tpci_intx(dev->dev, true);\n\t\tspin_unlock_irq(&dev->intx_lock);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"trace/events/kvm.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"irq.h\"",
      "#include <linux/fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/pci.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/errno.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&dev->intx_lock"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_intx",
          "args": [
            "dev->dev",
            "true"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&dev->intx_lock"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request_threaded_irq",
          "args": [
            "dev->host_irq",
            "irq_handler",
            "kvm_assigned_dev_thread_intx",
            "flags",
            "dev->irq_name",
            "dev"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace/events/kvm.h\"\n#include \"assigned-dev.h\"\n#include \"irq.h\"\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/spinlock.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic int assigned_device_enable_host_intx(struct kvm *kvm,\n\t\t\t\t\t    struct kvm_assigned_dev_kernel *dev)\n{\n\tirq_handler_t irq_handler;\n\tunsigned long flags;\n\n\tdev->host_irq = dev->dev->irq;\n\n\t/*\n\t * We can only share the IRQ line with other host devices if we are\n\t * able to disable the IRQ source at device-level - independently of\n\t * the guest driver. Otherwise host devices may suffer from unbounded\n\t * IRQ latencies when the guest keeps the line asserted.\n\t */\n\tif (dev->flags & KVM_DEV_ASSIGN_PCI_2_3) {\n\t\tirq_handler = kvm_assigned_dev_intx;\n\t\tflags = IRQF_SHARED;\n\t} else {\n\t\tirq_handler = NULL;\n\t\tflags = IRQF_ONESHOT;\n\t}\n\tif (request_threaded_irq(dev->host_irq, irq_handler,\n\t\t\t\t kvm_assigned_dev_thread_intx, flags,\n\t\t\t\t dev->irq_name, dev))\n\t\treturn -EIO;\n\n\tif (dev->flags & KVM_DEV_ASSIGN_PCI_2_3) {\n\t\tspin_lock_irq(&dev->intx_lock);\n\t\tpci_intx(dev->dev, true);\n\t\tspin_unlock_irq(&dev->intx_lock);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "kvm_free_all_assigned_devices",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/assigned-dev.c",
    "lines": "372-380",
    "snippet": "void kvm_free_all_assigned_devices(struct kvm *kvm)\n{\n\tstruct kvm_assigned_dev_kernel *assigned_dev, *tmp;\n\n\tlist_for_each_entry_safe(assigned_dev, tmp,\n\t\t\t\t &kvm->arch.assigned_dev_head, list) {\n\t\tkvm_free_assigned_device(kvm, assigned_dev);\n\t}\n}",
    "includes": [
      "#include \"trace/events/kvm.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"irq.h\"",
      "#include <linux/fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/pci.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/errno.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_free_assigned_device",
          "args": [
            "kvm",
            "assigned_dev"
          ],
          "line": 378
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_free_assigned_device",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/assigned-dev.c",
          "lines": "348-370",
          "snippet": "static void kvm_free_assigned_device(struct kvm *kvm,\n\t\t\t\t     struct kvm_assigned_dev_kernel\n\t\t\t\t     *assigned_dev)\n{\n\tkvm_free_assigned_irq(kvm, assigned_dev);\n\n\tpci_reset_function(assigned_dev->dev);\n\tif (pci_load_and_free_saved_state(assigned_dev->dev,\n\t\t\t\t\t  &assigned_dev->pci_saved_state))\n\t\tprintk(KERN_INFO \"%s: Couldn't reload %s saved state\\n\",\n\t\t       __func__, dev_name(&assigned_dev->dev->dev));\n\telse\n\t\tpci_restore_state(assigned_dev->dev);\n\n\tpci_clear_dev_assigned(assigned_dev->dev);\n\n\tpci_release_regions(assigned_dev->dev);\n\tpci_disable_device(assigned_dev->dev);\n\tpci_dev_put(assigned_dev->dev);\n\n\tlist_del(&assigned_dev->list);\n\tkfree(assigned_dev);\n}",
          "includes": [
            "#include \"trace/events/kvm.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"irq.h\"",
            "#include <linux/fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/pci.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/errno.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace/events/kvm.h\"\n#include \"assigned-dev.h\"\n#include \"irq.h\"\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/spinlock.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void kvm_free_assigned_device(struct kvm *kvm,\n\t\t\t\t     struct kvm_assigned_dev_kernel\n\t\t\t\t     *assigned_dev)\n{\n\tkvm_free_assigned_irq(kvm, assigned_dev);\n\n\tpci_reset_function(assigned_dev->dev);\n\tif (pci_load_and_free_saved_state(assigned_dev->dev,\n\t\t\t\t\t  &assigned_dev->pci_saved_state))\n\t\tprintk(KERN_INFO \"%s: Couldn't reload %s saved state\\n\",\n\t\t       __func__, dev_name(&assigned_dev->dev->dev));\n\telse\n\t\tpci_restore_state(assigned_dev->dev);\n\n\tpci_clear_dev_assigned(assigned_dev->dev);\n\n\tpci_release_regions(assigned_dev->dev);\n\tpci_disable_device(assigned_dev->dev);\n\tpci_dev_put(assigned_dev->dev);\n\n\tlist_del(&assigned_dev->list);\n\tkfree(assigned_dev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "assigned_dev",
            "tmp",
            "&kvm->arch.assigned_dev_head",
            "list"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace/events/kvm.h\"\n#include \"assigned-dev.h\"\n#include \"irq.h\"\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/spinlock.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nvoid kvm_free_all_assigned_devices(struct kvm *kvm)\n{\n\tstruct kvm_assigned_dev_kernel *assigned_dev, *tmp;\n\n\tlist_for_each_entry_safe(assigned_dev, tmp,\n\t\t\t\t &kvm->arch.assigned_dev_head, list) {\n\t\tkvm_free_assigned_device(kvm, assigned_dev);\n\t}\n}"
  },
  {
    "function_name": "kvm_free_assigned_device",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/assigned-dev.c",
    "lines": "348-370",
    "snippet": "static void kvm_free_assigned_device(struct kvm *kvm,\n\t\t\t\t     struct kvm_assigned_dev_kernel\n\t\t\t\t     *assigned_dev)\n{\n\tkvm_free_assigned_irq(kvm, assigned_dev);\n\n\tpci_reset_function(assigned_dev->dev);\n\tif (pci_load_and_free_saved_state(assigned_dev->dev,\n\t\t\t\t\t  &assigned_dev->pci_saved_state))\n\t\tprintk(KERN_INFO \"%s: Couldn't reload %s saved state\\n\",\n\t\t       __func__, dev_name(&assigned_dev->dev->dev));\n\telse\n\t\tpci_restore_state(assigned_dev->dev);\n\n\tpci_clear_dev_assigned(assigned_dev->dev);\n\n\tpci_release_regions(assigned_dev->dev);\n\tpci_disable_device(assigned_dev->dev);\n\tpci_dev_put(assigned_dev->dev);\n\n\tlist_del(&assigned_dev->list);\n\tkfree(assigned_dev);\n}",
    "includes": [
      "#include \"trace/events/kvm.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"irq.h\"",
      "#include <linux/fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/pci.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/errno.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "assigned_dev"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&assigned_dev->list"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_dev_put",
          "args": [
            "assigned_dev->dev"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_disable_device",
          "args": [
            "assigned_dev->dev"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_release_regions",
          "args": [
            "assigned_dev->dev"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_clear_dev_assigned",
          "args": [
            "assigned_dev->dev"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_restore_state",
          "args": [
            "assigned_dev->dev"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO \"%s: Couldn't reload %s saved state\\n\"",
            "__func__",
            "dev_name(&assigned_dev->dev->dev)"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_name",
          "args": [
            "&assigned_dev->dev->dev"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_load_and_free_saved_state",
          "args": [
            "assigned_dev->dev",
            "&assigned_dev->pci_saved_state"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_reset_function",
          "args": [
            "assigned_dev->dev"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_free_assigned_irq",
          "args": [
            "kvm",
            "assigned_dev"
          ],
          "line": 352
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_free_assigned_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/assigned-dev.c",
          "lines": "342-346",
          "snippet": "static void kvm_free_assigned_irq(struct kvm *kvm,\n\t\t\t\t  struct kvm_assigned_dev_kernel *assigned_dev)\n{\n\tkvm_deassign_irq(kvm, assigned_dev, assigned_dev->irq_requested_type);\n}",
          "includes": [
            "#include \"trace/events/kvm.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"irq.h\"",
            "#include <linux/fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/pci.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/errno.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace/events/kvm.h\"\n#include \"assigned-dev.h\"\n#include \"irq.h\"\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/spinlock.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void kvm_free_assigned_irq(struct kvm *kvm,\n\t\t\t\t  struct kvm_assigned_dev_kernel *assigned_dev)\n{\n\tkvm_deassign_irq(kvm, assigned_dev, assigned_dev->irq_requested_type);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace/events/kvm.h\"\n#include \"assigned-dev.h\"\n#include \"irq.h\"\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/spinlock.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void kvm_free_assigned_device(struct kvm *kvm,\n\t\t\t\t     struct kvm_assigned_dev_kernel\n\t\t\t\t     *assigned_dev)\n{\n\tkvm_free_assigned_irq(kvm, assigned_dev);\n\n\tpci_reset_function(assigned_dev->dev);\n\tif (pci_load_and_free_saved_state(assigned_dev->dev,\n\t\t\t\t\t  &assigned_dev->pci_saved_state))\n\t\tprintk(KERN_INFO \"%s: Couldn't reload %s saved state\\n\",\n\t\t       __func__, dev_name(&assigned_dev->dev->dev));\n\telse\n\t\tpci_restore_state(assigned_dev->dev);\n\n\tpci_clear_dev_assigned(assigned_dev->dev);\n\n\tpci_release_regions(assigned_dev->dev);\n\tpci_disable_device(assigned_dev->dev);\n\tpci_dev_put(assigned_dev->dev);\n\n\tlist_del(&assigned_dev->list);\n\tkfree(assigned_dev);\n}"
  },
  {
    "function_name": "kvm_free_assigned_irq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/assigned-dev.c",
    "lines": "342-346",
    "snippet": "static void kvm_free_assigned_irq(struct kvm *kvm,\n\t\t\t\t  struct kvm_assigned_dev_kernel *assigned_dev)\n{\n\tkvm_deassign_irq(kvm, assigned_dev, assigned_dev->irq_requested_type);\n}",
    "includes": [
      "#include \"trace/events/kvm.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"irq.h\"",
      "#include <linux/fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/pci.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/errno.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_deassign_irq",
          "args": [
            "kvm",
            "assigned_dev",
            "assigned_dev->irq_requested_type"
          ],
          "line": 345
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_deassign_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/assigned-dev.c",
          "lines": "319-340",
          "snippet": "static int kvm_deassign_irq(struct kvm *kvm,\n\t\t\t    struct kvm_assigned_dev_kernel *assigned_dev,\n\t\t\t    unsigned long irq_requested_type)\n{\n\tunsigned long guest_irq_type, host_irq_type;\n\n\tif (!irqchip_in_kernel(kvm))\n\t\treturn -EINVAL;\n\t/* no irq assignment to deassign */\n\tif (!assigned_dev->irq_requested_type)\n\t\treturn -ENXIO;\n\n\thost_irq_type = irq_requested_type & KVM_DEV_IRQ_HOST_MASK;\n\tguest_irq_type = irq_requested_type & KVM_DEV_IRQ_GUEST_MASK;\n\n\tif (host_irq_type)\n\t\tdeassign_host_irq(kvm, assigned_dev);\n\tif (guest_irq_type)\n\t\tdeassign_guest_irq(kvm, assigned_dev);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace/events/kvm.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"irq.h\"",
            "#include <linux/fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/pci.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/errno.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace/events/kvm.h\"\n#include \"assigned-dev.h\"\n#include \"irq.h\"\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/spinlock.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic int kvm_deassign_irq(struct kvm *kvm,\n\t\t\t    struct kvm_assigned_dev_kernel *assigned_dev,\n\t\t\t    unsigned long irq_requested_type)\n{\n\tunsigned long guest_irq_type, host_irq_type;\n\n\tif (!irqchip_in_kernel(kvm))\n\t\treturn -EINVAL;\n\t/* no irq assignment to deassign */\n\tif (!assigned_dev->irq_requested_type)\n\t\treturn -ENXIO;\n\n\thost_irq_type = irq_requested_type & KVM_DEV_IRQ_HOST_MASK;\n\tguest_irq_type = irq_requested_type & KVM_DEV_IRQ_GUEST_MASK;\n\n\tif (host_irq_type)\n\t\tdeassign_host_irq(kvm, assigned_dev);\n\tif (guest_irq_type)\n\t\tdeassign_guest_irq(kvm, assigned_dev);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace/events/kvm.h\"\n#include \"assigned-dev.h\"\n#include \"irq.h\"\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/spinlock.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void kvm_free_assigned_irq(struct kvm *kvm,\n\t\t\t\t  struct kvm_assigned_dev_kernel *assigned_dev)\n{\n\tkvm_deassign_irq(kvm, assigned_dev, assigned_dev->irq_requested_type);\n}"
  },
  {
    "function_name": "kvm_deassign_irq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/assigned-dev.c",
    "lines": "319-340",
    "snippet": "static int kvm_deassign_irq(struct kvm *kvm,\n\t\t\t    struct kvm_assigned_dev_kernel *assigned_dev,\n\t\t\t    unsigned long irq_requested_type)\n{\n\tunsigned long guest_irq_type, host_irq_type;\n\n\tif (!irqchip_in_kernel(kvm))\n\t\treturn -EINVAL;\n\t/* no irq assignment to deassign */\n\tif (!assigned_dev->irq_requested_type)\n\t\treturn -ENXIO;\n\n\thost_irq_type = irq_requested_type & KVM_DEV_IRQ_HOST_MASK;\n\tguest_irq_type = irq_requested_type & KVM_DEV_IRQ_GUEST_MASK;\n\n\tif (host_irq_type)\n\t\tdeassign_host_irq(kvm, assigned_dev);\n\tif (guest_irq_type)\n\t\tdeassign_guest_irq(kvm, assigned_dev);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace/events/kvm.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"irq.h\"",
      "#include <linux/fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/pci.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/errno.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "deassign_guest_irq",
          "args": [
            "kvm",
            "assigned_dev"
          ],
          "line": 337
        },
        "resolved": true,
        "details": {
          "function_name": "deassign_guest_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/assigned-dev.c",
          "lines": "255-269",
          "snippet": "static void deassign_guest_irq(struct kvm *kvm,\n\t\t\t       struct kvm_assigned_dev_kernel *assigned_dev)\n{\n\tif (assigned_dev->ack_notifier.gsi != -1)\n\t\tkvm_unregister_irq_ack_notifier(kvm,\n\t\t\t\t\t\t&assigned_dev->ack_notifier);\n\n\tkvm_set_irq(assigned_dev->kvm, assigned_dev->irq_source_id,\n\t\t    assigned_dev->guest_irq, 0, false);\n\n\tif (assigned_dev->irq_source_id != -1)\n\t\tkvm_free_irq_source_id(kvm, assigned_dev->irq_source_id);\n\tassigned_dev->irq_source_id = -1;\n\tassigned_dev->irq_requested_type &= ~(KVM_DEV_IRQ_GUEST_MASK);\n}",
          "includes": [
            "#include \"trace/events/kvm.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"irq.h\"",
            "#include <linux/fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/pci.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/errno.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace/events/kvm.h\"\n#include \"assigned-dev.h\"\n#include \"irq.h\"\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/spinlock.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void deassign_guest_irq(struct kvm *kvm,\n\t\t\t       struct kvm_assigned_dev_kernel *assigned_dev)\n{\n\tif (assigned_dev->ack_notifier.gsi != -1)\n\t\tkvm_unregister_irq_ack_notifier(kvm,\n\t\t\t\t\t\t&assigned_dev->ack_notifier);\n\n\tkvm_set_irq(assigned_dev->kvm, assigned_dev->irq_source_id,\n\t\t    assigned_dev->guest_irq, 0, false);\n\n\tif (assigned_dev->irq_source_id != -1)\n\t\tkvm_free_irq_source_id(kvm, assigned_dev->irq_source_id);\n\tassigned_dev->irq_source_id = -1;\n\tassigned_dev->irq_requested_type &= ~(KVM_DEV_IRQ_GUEST_MASK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "deassign_host_irq",
          "args": [
            "kvm",
            "assigned_dev"
          ],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "deassign_host_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/assigned-dev.c",
          "lines": "272-317",
          "snippet": "static void deassign_host_irq(struct kvm *kvm,\n\t\t\t      struct kvm_assigned_dev_kernel *assigned_dev)\n{\n\t/*\n\t * We disable irq here to prevent further events.\n\t *\n\t * Notice this maybe result in nested disable if the interrupt type is\n\t * INTx, but it's OK for we are going to free it.\n\t *\n\t * If this function is a part of VM destroy, please ensure that till\n\t * now, the kvm state is still legal for probably we also have to wait\n\t * on a currently running IRQ handler.\n\t */\n\tif (assigned_dev->irq_requested_type & KVM_DEV_IRQ_HOST_MSIX) {\n\t\tint i;\n\t\tfor (i = 0; i < assigned_dev->entries_nr; i++)\n\t\t\tdisable_irq(assigned_dev->host_msix_entries[i].vector);\n\n\t\tfor (i = 0; i < assigned_dev->entries_nr; i++)\n\t\t\tfree_irq(assigned_dev->host_msix_entries[i].vector,\n\t\t\t\t assigned_dev);\n\n\t\tassigned_dev->entries_nr = 0;\n\t\tkfree(assigned_dev->host_msix_entries);\n\t\tkfree(assigned_dev->guest_msix_entries);\n\t\tpci_disable_msix(assigned_dev->dev);\n\t} else {\n\t\t/* Deal with MSI and INTx */\n\t\tif ((assigned_dev->irq_requested_type &\n\t\t     KVM_DEV_IRQ_HOST_INTX) &&\n\t\t    (assigned_dev->flags & KVM_DEV_ASSIGN_PCI_2_3)) {\n\t\t\tspin_lock_irq(&assigned_dev->intx_lock);\n\t\t\tpci_intx(assigned_dev->dev, false);\n\t\t\tspin_unlock_irq(&assigned_dev->intx_lock);\n\t\t\tsynchronize_irq(assigned_dev->host_irq);\n\t\t} else\n\t\t\tdisable_irq(assigned_dev->host_irq);\n\n\t\tfree_irq(assigned_dev->host_irq, assigned_dev);\n\n\t\tif (assigned_dev->irq_requested_type & KVM_DEV_IRQ_HOST_MSI)\n\t\t\tpci_disable_msi(assigned_dev->dev);\n\t}\n\n\tassigned_dev->irq_requested_type &= ~(KVM_DEV_IRQ_HOST_MASK);\n}",
          "includes": [
            "#include \"trace/events/kvm.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"irq.h\"",
            "#include <linux/fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/pci.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/errno.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace/events/kvm.h\"\n#include \"assigned-dev.h\"\n#include \"irq.h\"\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/spinlock.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void deassign_host_irq(struct kvm *kvm,\n\t\t\t      struct kvm_assigned_dev_kernel *assigned_dev)\n{\n\t/*\n\t * We disable irq here to prevent further events.\n\t *\n\t * Notice this maybe result in nested disable if the interrupt type is\n\t * INTx, but it's OK for we are going to free it.\n\t *\n\t * If this function is a part of VM destroy, please ensure that till\n\t * now, the kvm state is still legal for probably we also have to wait\n\t * on a currently running IRQ handler.\n\t */\n\tif (assigned_dev->irq_requested_type & KVM_DEV_IRQ_HOST_MSIX) {\n\t\tint i;\n\t\tfor (i = 0; i < assigned_dev->entries_nr; i++)\n\t\t\tdisable_irq(assigned_dev->host_msix_entries[i].vector);\n\n\t\tfor (i = 0; i < assigned_dev->entries_nr; i++)\n\t\t\tfree_irq(assigned_dev->host_msix_entries[i].vector,\n\t\t\t\t assigned_dev);\n\n\t\tassigned_dev->entries_nr = 0;\n\t\tkfree(assigned_dev->host_msix_entries);\n\t\tkfree(assigned_dev->guest_msix_entries);\n\t\tpci_disable_msix(assigned_dev->dev);\n\t} else {\n\t\t/* Deal with MSI and INTx */\n\t\tif ((assigned_dev->irq_requested_type &\n\t\t     KVM_DEV_IRQ_HOST_INTX) &&\n\t\t    (assigned_dev->flags & KVM_DEV_ASSIGN_PCI_2_3)) {\n\t\t\tspin_lock_irq(&assigned_dev->intx_lock);\n\t\t\tpci_intx(assigned_dev->dev, false);\n\t\t\tspin_unlock_irq(&assigned_dev->intx_lock);\n\t\t\tsynchronize_irq(assigned_dev->host_irq);\n\t\t} else\n\t\t\tdisable_irq(assigned_dev->host_irq);\n\n\t\tfree_irq(assigned_dev->host_irq, assigned_dev);\n\n\t\tif (assigned_dev->irq_requested_type & KVM_DEV_IRQ_HOST_MSI)\n\t\t\tpci_disable_msi(assigned_dev->dev);\n\t}\n\n\tassigned_dev->irq_requested_type &= ~(KVM_DEV_IRQ_HOST_MASK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irqchip_in_kernel",
          "args": [
            "kvm"
          ],
          "line": 325
        },
        "resolved": true,
        "details": {
          "function_name": "irqchip_in_kernel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/irq.h",
          "lines": "99-110",
          "snippet": "static inline int irqchip_in_kernel(struct kvm *kvm)\n{\n\tstruct kvm_pic *vpic = pic_irqchip(kvm);\n\tbool ret;\n\n\tret = (vpic != NULL);\n\tret |= irqchip_split(kvm);\n\n\t/* Read vpic before kvm->irq_routing.  */\n\tsmp_rmb();\n\treturn ret;\n}",
          "includes": [
            "#include \"lapic.h\"",
            "#include \"ioapic.h\"",
            "#include <kvm/iodev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/mm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <kvm/iodev.h>\n#include <linux/spinlock.h>\n#include <linux/kvm_host.h>\n#include <linux/hrtimer.h>\n#include <linux/mm_types.h>\n\nstatic inline int irqchip_in_kernel(struct kvm *kvm)\n{\n\tstruct kvm_pic *vpic = pic_irqchip(kvm);\n\tbool ret;\n\n\tret = (vpic != NULL);\n\tret |= irqchip_split(kvm);\n\n\t/* Read vpic before kvm->irq_routing.  */\n\tsmp_rmb();\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace/events/kvm.h\"\n#include \"assigned-dev.h\"\n#include \"irq.h\"\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/spinlock.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic int kvm_deassign_irq(struct kvm *kvm,\n\t\t\t    struct kvm_assigned_dev_kernel *assigned_dev,\n\t\t\t    unsigned long irq_requested_type)\n{\n\tunsigned long guest_irq_type, host_irq_type;\n\n\tif (!irqchip_in_kernel(kvm))\n\t\treturn -EINVAL;\n\t/* no irq assignment to deassign */\n\tif (!assigned_dev->irq_requested_type)\n\t\treturn -ENXIO;\n\n\thost_irq_type = irq_requested_type & KVM_DEV_IRQ_HOST_MASK;\n\tguest_irq_type = irq_requested_type & KVM_DEV_IRQ_GUEST_MASK;\n\n\tif (host_irq_type)\n\t\tdeassign_host_irq(kvm, assigned_dev);\n\tif (guest_irq_type)\n\t\tdeassign_guest_irq(kvm, assigned_dev);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "deassign_host_irq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/assigned-dev.c",
    "lines": "272-317",
    "snippet": "static void deassign_host_irq(struct kvm *kvm,\n\t\t\t      struct kvm_assigned_dev_kernel *assigned_dev)\n{\n\t/*\n\t * We disable irq here to prevent further events.\n\t *\n\t * Notice this maybe result in nested disable if the interrupt type is\n\t * INTx, but it's OK for we are going to free it.\n\t *\n\t * If this function is a part of VM destroy, please ensure that till\n\t * now, the kvm state is still legal for probably we also have to wait\n\t * on a currently running IRQ handler.\n\t */\n\tif (assigned_dev->irq_requested_type & KVM_DEV_IRQ_HOST_MSIX) {\n\t\tint i;\n\t\tfor (i = 0; i < assigned_dev->entries_nr; i++)\n\t\t\tdisable_irq(assigned_dev->host_msix_entries[i].vector);\n\n\t\tfor (i = 0; i < assigned_dev->entries_nr; i++)\n\t\t\tfree_irq(assigned_dev->host_msix_entries[i].vector,\n\t\t\t\t assigned_dev);\n\n\t\tassigned_dev->entries_nr = 0;\n\t\tkfree(assigned_dev->host_msix_entries);\n\t\tkfree(assigned_dev->guest_msix_entries);\n\t\tpci_disable_msix(assigned_dev->dev);\n\t} else {\n\t\t/* Deal with MSI and INTx */\n\t\tif ((assigned_dev->irq_requested_type &\n\t\t     KVM_DEV_IRQ_HOST_INTX) &&\n\t\t    (assigned_dev->flags & KVM_DEV_ASSIGN_PCI_2_3)) {\n\t\t\tspin_lock_irq(&assigned_dev->intx_lock);\n\t\t\tpci_intx(assigned_dev->dev, false);\n\t\t\tspin_unlock_irq(&assigned_dev->intx_lock);\n\t\t\tsynchronize_irq(assigned_dev->host_irq);\n\t\t} else\n\t\t\tdisable_irq(assigned_dev->host_irq);\n\n\t\tfree_irq(assigned_dev->host_irq, assigned_dev);\n\n\t\tif (assigned_dev->irq_requested_type & KVM_DEV_IRQ_HOST_MSI)\n\t\t\tpci_disable_msi(assigned_dev->dev);\n\t}\n\n\tassigned_dev->irq_requested_type &= ~(KVM_DEV_IRQ_HOST_MASK);\n}",
    "includes": [
      "#include \"trace/events/kvm.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"irq.h\"",
      "#include <linux/fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/pci.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/errno.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pci_disable_msi",
          "args": [
            "assigned_dev->dev"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_irq",
          "args": [
            "assigned_dev->host_irq",
            "assigned_dev"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_free_irq_source_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/irq_comm.c",
          "lines": "187-206",
          "snippet": "void kvm_free_irq_source_id(struct kvm *kvm, int irq_source_id)\n{\n\tASSERT(irq_source_id != KVM_USERSPACE_IRQ_SOURCE_ID);\n\tASSERT(irq_source_id != KVM_IRQFD_RESAMPLE_IRQ_SOURCE_ID);\n\n\tmutex_lock(&kvm->irq_lock);\n\tif (irq_source_id < 0 ||\n\t    irq_source_id >= BITS_PER_LONG) {\n\t\tprintk(KERN_ERR \"kvm: IRQ source ID out of range!\\n\");\n\t\tgoto unlock;\n\t}\n\tclear_bit(irq_source_id, &kvm->arch.irq_sources_bitmap);\n\tif (!ioapic_in_kernel(kvm))\n\t\tgoto unlock;\n\n\tkvm_ioapic_clear_all(kvm->arch.vioapic, irq_source_id);\n\tkvm_pic_clear_all(pic_irqchip(kvm), irq_source_id);\nunlock:\n\tmutex_unlock(&kvm->irq_lock);\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"hyperv.h\"",
            "#include \"lapic.h\"",
            "#include \"ioapic.h\"",
            "#include \"irq.h\"",
            "#include <asm/msidef.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"hyperv.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include \"irq.h\"\n#include <asm/msidef.h>\n#include <trace/events/kvm.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nvoid kvm_free_irq_source_id(struct kvm *kvm, int irq_source_id)\n{\n\tASSERT(irq_source_id != KVM_USERSPACE_IRQ_SOURCE_ID);\n\tASSERT(irq_source_id != KVM_IRQFD_RESAMPLE_IRQ_SOURCE_ID);\n\n\tmutex_lock(&kvm->irq_lock);\n\tif (irq_source_id < 0 ||\n\t    irq_source_id >= BITS_PER_LONG) {\n\t\tprintk(KERN_ERR \"kvm: IRQ source ID out of range!\\n\");\n\t\tgoto unlock;\n\t}\n\tclear_bit(irq_source_id, &kvm->arch.irq_sources_bitmap);\n\tif (!ioapic_in_kernel(kvm))\n\t\tgoto unlock;\n\n\tkvm_ioapic_clear_all(kvm->arch.vioapic, irq_source_id);\n\tkvm_pic_clear_all(pic_irqchip(kvm), irq_source_id);\nunlock:\n\tmutex_unlock(&kvm->irq_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "disable_irq",
          "args": [
            "assigned_dev->host_irq"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "synchronize_irq",
          "args": [
            "assigned_dev->host_irq"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&assigned_dev->intx_lock"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_intx",
          "args": [
            "assigned_dev->dev",
            "false"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&assigned_dev->intx_lock"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_disable_msix",
          "args": [
            "assigned_dev->dev"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "assigned_dev->guest_msix_entries"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "assigned_dev->host_msix_entries"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "disable_irq",
          "args": [
            "assigned_dev->host_msix_entries[i].vector"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace/events/kvm.h\"\n#include \"assigned-dev.h\"\n#include \"irq.h\"\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/spinlock.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void deassign_host_irq(struct kvm *kvm,\n\t\t\t      struct kvm_assigned_dev_kernel *assigned_dev)\n{\n\t/*\n\t * We disable irq here to prevent further events.\n\t *\n\t * Notice this maybe result in nested disable if the interrupt type is\n\t * INTx, but it's OK for we are going to free it.\n\t *\n\t * If this function is a part of VM destroy, please ensure that till\n\t * now, the kvm state is still legal for probably we also have to wait\n\t * on a currently running IRQ handler.\n\t */\n\tif (assigned_dev->irq_requested_type & KVM_DEV_IRQ_HOST_MSIX) {\n\t\tint i;\n\t\tfor (i = 0; i < assigned_dev->entries_nr; i++)\n\t\t\tdisable_irq(assigned_dev->host_msix_entries[i].vector);\n\n\t\tfor (i = 0; i < assigned_dev->entries_nr; i++)\n\t\t\tfree_irq(assigned_dev->host_msix_entries[i].vector,\n\t\t\t\t assigned_dev);\n\n\t\tassigned_dev->entries_nr = 0;\n\t\tkfree(assigned_dev->host_msix_entries);\n\t\tkfree(assigned_dev->guest_msix_entries);\n\t\tpci_disable_msix(assigned_dev->dev);\n\t} else {\n\t\t/* Deal with MSI and INTx */\n\t\tif ((assigned_dev->irq_requested_type &\n\t\t     KVM_DEV_IRQ_HOST_INTX) &&\n\t\t    (assigned_dev->flags & KVM_DEV_ASSIGN_PCI_2_3)) {\n\t\t\tspin_lock_irq(&assigned_dev->intx_lock);\n\t\t\tpci_intx(assigned_dev->dev, false);\n\t\t\tspin_unlock_irq(&assigned_dev->intx_lock);\n\t\t\tsynchronize_irq(assigned_dev->host_irq);\n\t\t} else\n\t\t\tdisable_irq(assigned_dev->host_irq);\n\n\t\tfree_irq(assigned_dev->host_irq, assigned_dev);\n\n\t\tif (assigned_dev->irq_requested_type & KVM_DEV_IRQ_HOST_MSI)\n\t\t\tpci_disable_msi(assigned_dev->dev);\n\t}\n\n\tassigned_dev->irq_requested_type &= ~(KVM_DEV_IRQ_HOST_MASK);\n}"
  },
  {
    "function_name": "deassign_guest_irq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/assigned-dev.c",
    "lines": "255-269",
    "snippet": "static void deassign_guest_irq(struct kvm *kvm,\n\t\t\t       struct kvm_assigned_dev_kernel *assigned_dev)\n{\n\tif (assigned_dev->ack_notifier.gsi != -1)\n\t\tkvm_unregister_irq_ack_notifier(kvm,\n\t\t\t\t\t\t&assigned_dev->ack_notifier);\n\n\tkvm_set_irq(assigned_dev->kvm, assigned_dev->irq_source_id,\n\t\t    assigned_dev->guest_irq, 0, false);\n\n\tif (assigned_dev->irq_source_id != -1)\n\t\tkvm_free_irq_source_id(kvm, assigned_dev->irq_source_id);\n\tassigned_dev->irq_source_id = -1;\n\tassigned_dev->irq_requested_type &= ~(KVM_DEV_IRQ_GUEST_MASK);\n}",
    "includes": [
      "#include \"trace/events/kvm.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"irq.h\"",
      "#include <linux/fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/pci.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/errno.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_free_irq_source_id",
          "args": [
            "kvm",
            "assigned_dev->irq_source_id"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_free_irq_source_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/irq_comm.c",
          "lines": "187-206",
          "snippet": "void kvm_free_irq_source_id(struct kvm *kvm, int irq_source_id)\n{\n\tASSERT(irq_source_id != KVM_USERSPACE_IRQ_SOURCE_ID);\n\tASSERT(irq_source_id != KVM_IRQFD_RESAMPLE_IRQ_SOURCE_ID);\n\n\tmutex_lock(&kvm->irq_lock);\n\tif (irq_source_id < 0 ||\n\t    irq_source_id >= BITS_PER_LONG) {\n\t\tprintk(KERN_ERR \"kvm: IRQ source ID out of range!\\n\");\n\t\tgoto unlock;\n\t}\n\tclear_bit(irq_source_id, &kvm->arch.irq_sources_bitmap);\n\tif (!ioapic_in_kernel(kvm))\n\t\tgoto unlock;\n\n\tkvm_ioapic_clear_all(kvm->arch.vioapic, irq_source_id);\n\tkvm_pic_clear_all(pic_irqchip(kvm), irq_source_id);\nunlock:\n\tmutex_unlock(&kvm->irq_lock);\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"hyperv.h\"",
            "#include \"lapic.h\"",
            "#include \"ioapic.h\"",
            "#include \"irq.h\"",
            "#include <asm/msidef.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"hyperv.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include \"irq.h\"\n#include <asm/msidef.h>\n#include <trace/events/kvm.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nvoid kvm_free_irq_source_id(struct kvm *kvm, int irq_source_id)\n{\n\tASSERT(irq_source_id != KVM_USERSPACE_IRQ_SOURCE_ID);\n\tASSERT(irq_source_id != KVM_IRQFD_RESAMPLE_IRQ_SOURCE_ID);\n\n\tmutex_lock(&kvm->irq_lock);\n\tif (irq_source_id < 0 ||\n\t    irq_source_id >= BITS_PER_LONG) {\n\t\tprintk(KERN_ERR \"kvm: IRQ source ID out of range!\\n\");\n\t\tgoto unlock;\n\t}\n\tclear_bit(irq_source_id, &kvm->arch.irq_sources_bitmap);\n\tif (!ioapic_in_kernel(kvm))\n\t\tgoto unlock;\n\n\tkvm_ioapic_clear_all(kvm->arch.vioapic, irq_source_id);\n\tkvm_pic_clear_all(pic_irqchip(kvm), irq_source_id);\nunlock:\n\tmutex_unlock(&kvm->irq_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_set_irq",
          "args": [
            "assigned_dev->kvm",
            "assigned_dev->irq_source_id",
            "assigned_dev->guest_irq",
            "0",
            "false"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_unregister_irq_ack_notifier",
          "args": [
            "kvm",
            "&assigned_dev->ack_notifier"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace/events/kvm.h\"\n#include \"assigned-dev.h\"\n#include \"irq.h\"\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/spinlock.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void deassign_guest_irq(struct kvm *kvm,\n\t\t\t       struct kvm_assigned_dev_kernel *assigned_dev)\n{\n\tif (assigned_dev->ack_notifier.gsi != -1)\n\t\tkvm_unregister_irq_ack_notifier(kvm,\n\t\t\t\t\t\t&assigned_dev->ack_notifier);\n\n\tkvm_set_irq(assigned_dev->kvm, assigned_dev->irq_source_id,\n\t\t    assigned_dev->guest_irq, 0, false);\n\n\tif (assigned_dev->irq_source_id != -1)\n\t\tkvm_free_irq_source_id(kvm, assigned_dev->irq_source_id);\n\tassigned_dev->irq_source_id = -1;\n\tassigned_dev->irq_requested_type &= ~(KVM_DEV_IRQ_GUEST_MASK);\n}"
  },
  {
    "function_name": "kvm_assigned_dev_ack_irq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/assigned-dev.c",
    "lines": "220-253",
    "snippet": "static void kvm_assigned_dev_ack_irq(struct kvm_irq_ack_notifier *kian)\n{\n\tstruct kvm_assigned_dev_kernel *dev =\n\t\tcontainer_of(kian, struct kvm_assigned_dev_kernel,\n\t\t\t     ack_notifier);\n\n\tkvm_set_irq(dev->kvm, dev->irq_source_id, dev->guest_irq, 0, false);\n\n\tspin_lock(&dev->intx_mask_lock);\n\n\tif (!(dev->flags & KVM_DEV_ASSIGN_MASK_INTX)) {\n\t\tbool reassert = false;\n\n\t\tspin_lock_irq(&dev->intx_lock);\n\t\t/*\n\t\t * The guest IRQ may be shared so this ack can come from an\n\t\t * IRQ for another guest device.\n\t\t */\n\t\tif (dev->host_irq_disabled) {\n\t\t\tif (!(dev->flags & KVM_DEV_ASSIGN_PCI_2_3))\n\t\t\t\tenable_irq(dev->host_irq);\n\t\t\telse if (!pci_check_and_unmask_intx(dev->dev))\n\t\t\t\treassert = true;\n\t\t\tdev->host_irq_disabled = reassert;\n\t\t}\n\t\tspin_unlock_irq(&dev->intx_lock);\n\n\t\tif (reassert)\n\t\t\tkvm_set_irq(dev->kvm, dev->irq_source_id,\n\t\t\t\t    dev->guest_irq, 1, false);\n\t}\n\n\tspin_unlock(&dev->intx_mask_lock);\n}",
    "includes": [
      "#include \"trace/events/kvm.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"irq.h\"",
      "#include <linux/fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/pci.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/errno.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dev->intx_mask_lock"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_set_irq",
          "args": [
            "dev->kvm",
            "dev->irq_source_id",
            "dev->guest_irq",
            "1",
            "false"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&dev->intx_lock"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_check_and_unmask_intx",
          "args": [
            "dev->dev"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "enable_irq",
          "args": [
            "dev->host_irq"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "enable_irq_window",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/vmx.c",
          "lines": "5085-5092",
          "snippet": "static void enable_irq_window(struct kvm_vcpu *vcpu)\n{\n\tu32 cpu_based_vm_exec_control;\n\n\tcpu_based_vm_exec_control = vmcs_read32(CPU_BASED_VM_EXEC_CONTROL);\n\tcpu_based_vm_exec_control |= CPU_BASED_VIRTUAL_INTR_PENDING;\n\tvmcs_write32(CPU_BASED_VM_EXEC_CONTROL, cpu_based_vm_exec_control);\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"trace.h\"",
            "#include <asm/irq_remapping.h>",
            "#include <asm/apic.h>",
            "#include <asm/kexec.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/mce.h>",
            "#include <asm/virtext.h>",
            "#include <asm/vmx.h>",
            "#include <asm/desc.h>",
            "#include <asm/io.h>",
            "#include <asm/cpu.h>",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/hrtimer.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include \"lapic.h\"",
            "#include \"cpuid.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long nested_ept_get_cr3(struct kvm_vcpu *vcpu);",
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);",
            "static void ept_save_pdptrs(struct kvm_vcpu *vcpu);",
            "static void vmx_decache_cr0_guest_bits(struct kvm_vcpu *vcpu);",
            "static void vmx_leave_nested(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"trace.h\"\n#include <asm/irq_remapping.h>\n#include <asm/apic.h>\n#include <asm/kexec.h>\n#include <asm/debugreg.h>\n#include <asm/perf_event.h>\n#include <asm/fpu/internal.h>\n#include <asm/mce.h>\n#include <asm/virtext.h>\n#include <asm/vmx.h>\n#include <asm/desc.h>\n#include <asm/io.h>\n#include <asm/cpu.h>\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/hrtimer.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic unsigned long nested_ept_get_cr3(struct kvm_vcpu *vcpu);\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\nstatic void ept_save_pdptrs(struct kvm_vcpu *vcpu);\nstatic void vmx_decache_cr0_guest_bits(struct kvm_vcpu *vcpu);\nstatic void vmx_leave_nested(struct kvm_vcpu *vcpu);\n\nstatic void enable_irq_window(struct kvm_vcpu *vcpu)\n{\n\tu32 cpu_based_vm_exec_control;\n\n\tcpu_based_vm_exec_control = vmcs_read32(CPU_BASED_VM_EXEC_CONTROL);\n\tcpu_based_vm_exec_control |= CPU_BASED_VIRTUAL_INTR_PENDING;\n\tvmcs_write32(CPU_BASED_VM_EXEC_CONTROL, cpu_based_vm_exec_control);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&dev->intx_lock"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dev->intx_mask_lock"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_set_irq",
          "args": [
            "dev->kvm",
            "dev->irq_source_id",
            "dev->guest_irq",
            "0",
            "false"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "kian",
            "structkvm_assigned_dev_kernel",
            "ack_notifier"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace/events/kvm.h\"\n#include \"assigned-dev.h\"\n#include \"irq.h\"\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/spinlock.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void kvm_assigned_dev_ack_irq(struct kvm_irq_ack_notifier *kian)\n{\n\tstruct kvm_assigned_dev_kernel *dev =\n\t\tcontainer_of(kian, struct kvm_assigned_dev_kernel,\n\t\t\t     ack_notifier);\n\n\tkvm_set_irq(dev->kvm, dev->irq_source_id, dev->guest_irq, 0, false);\n\n\tspin_lock(&dev->intx_mask_lock);\n\n\tif (!(dev->flags & KVM_DEV_ASSIGN_MASK_INTX)) {\n\t\tbool reassert = false;\n\n\t\tspin_lock_irq(&dev->intx_lock);\n\t\t/*\n\t\t * The guest IRQ may be shared so this ack can come from an\n\t\t * IRQ for another guest device.\n\t\t */\n\t\tif (dev->host_irq_disabled) {\n\t\t\tif (!(dev->flags & KVM_DEV_ASSIGN_PCI_2_3))\n\t\t\t\tenable_irq(dev->host_irq);\n\t\t\telse if (!pci_check_and_unmask_intx(dev->dev))\n\t\t\t\treassert = true;\n\t\t\tdev->host_irq_disabled = reassert;\n\t\t}\n\t\tspin_unlock_irq(&dev->intx_lock);\n\n\t\tif (reassert)\n\t\t\tkvm_set_irq(dev->kvm, dev->irq_source_id,\n\t\t\t\t    dev->guest_irq, 1, false);\n\t}\n\n\tspin_unlock(&dev->intx_mask_lock);\n}"
  },
  {
    "function_name": "kvm_assigned_dev_thread_msix",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/assigned-dev.c",
    "lines": "205-217",
    "snippet": "static irqreturn_t kvm_assigned_dev_thread_msix(int irq, void *dev_id)\n{\n\tstruct kvm_assigned_dev_kernel *assigned_dev = dev_id;\n\tint index = find_index_from_host_irq(assigned_dev, irq);\n\tu32 vector;\n\n\tif (index >= 0) {\n\t\tvector = assigned_dev->guest_msix_entries[index].vector;\n\t\tkvm_assigned_dev_raise_guest_irq(assigned_dev, vector);\n\t}\n\n\treturn IRQ_HANDLED;\n}",
    "includes": [
      "#include \"trace/events/kvm.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"irq.h\"",
      "#include <linux/fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/pci.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/errno.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_assigned_dev_raise_guest_irq",
          "args": [
            "assigned_dev",
            "vector"
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_assigned_dev_raise_guest_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/assigned-dev.c",
          "lines": "99-114",
          "snippet": "static void\nkvm_assigned_dev_raise_guest_irq(struct kvm_assigned_dev_kernel *assigned_dev,\n\t\t\t\t int vector)\n{\n\tif (unlikely(assigned_dev->irq_requested_type &\n\t\t     KVM_DEV_IRQ_GUEST_INTX)) {\n\t\tspin_lock(&assigned_dev->intx_mask_lock);\n\t\tif (!(assigned_dev->flags & KVM_DEV_ASSIGN_MASK_INTX))\n\t\t\tkvm_set_irq(assigned_dev->kvm,\n\t\t\t\t    assigned_dev->irq_source_id, vector, 1,\n\t\t\t\t    false);\n\t\tspin_unlock(&assigned_dev->intx_mask_lock);\n\t} else\n\t\tkvm_set_irq(assigned_dev->kvm, assigned_dev->irq_source_id,\n\t\t\t    vector, 1, false);\n}",
          "includes": [
            "#include \"trace/events/kvm.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"irq.h\"",
            "#include <linux/fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/pci.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/errno.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace/events/kvm.h\"\n#include \"assigned-dev.h\"\n#include \"irq.h\"\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/spinlock.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void\nkvm_assigned_dev_raise_guest_irq(struct kvm_assigned_dev_kernel *assigned_dev,\n\t\t\t\t int vector)\n{\n\tif (unlikely(assigned_dev->irq_requested_type &\n\t\t     KVM_DEV_IRQ_GUEST_INTX)) {\n\t\tspin_lock(&assigned_dev->intx_mask_lock);\n\t\tif (!(assigned_dev->flags & KVM_DEV_ASSIGN_MASK_INTX))\n\t\t\tkvm_set_irq(assigned_dev->kvm,\n\t\t\t\t    assigned_dev->irq_source_id, vector, 1,\n\t\t\t\t    false);\n\t\tspin_unlock(&assigned_dev->intx_mask_lock);\n\t} else\n\t\tkvm_set_irq(assigned_dev->kvm, assigned_dev->irq_source_id,\n\t\t\t    vector, 1, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_index_from_host_irq",
          "args": [
            "assigned_dev",
            "irq"
          ],
          "line": 208
        },
        "resolved": true,
        "details": {
          "function_name": "find_index_from_host_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/assigned-dev.c",
          "lines": "63-81",
          "snippet": "static int find_index_from_host_irq(struct kvm_assigned_dev_kernel\n\t\t\t\t    *assigned_dev, int irq)\n{\n\tint i, index;\n\tstruct msix_entry *host_msix_entries;\n\n\thost_msix_entries = assigned_dev->host_msix_entries;\n\n\tindex = -1;\n\tfor (i = 0; i < assigned_dev->entries_nr; i++)\n\t\tif (irq == host_msix_entries[i].vector) {\n\t\t\tindex = i;\n\t\t\tbreak;\n\t\t}\n\tif (index < 0)\n\t\tprintk(KERN_WARNING \"Fail to find correlated MSI-X entry!\\n\");\n\n\treturn index;\n}",
          "includes": [
            "#include \"trace/events/kvm.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"irq.h\"",
            "#include <linux/fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/pci.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/errno.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace/events/kvm.h\"\n#include \"assigned-dev.h\"\n#include \"irq.h\"\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/spinlock.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic int find_index_from_host_irq(struct kvm_assigned_dev_kernel\n\t\t\t\t    *assigned_dev, int irq)\n{\n\tint i, index;\n\tstruct msix_entry *host_msix_entries;\n\n\thost_msix_entries = assigned_dev->host_msix_entries;\n\n\tindex = -1;\n\tfor (i = 0; i < assigned_dev->entries_nr; i++)\n\t\tif (irq == host_msix_entries[i].vector) {\n\t\t\tindex = i;\n\t\t\tbreak;\n\t\t}\n\tif (index < 0)\n\t\tprintk(KERN_WARNING \"Fail to find correlated MSI-X entry!\\n\");\n\n\treturn index;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace/events/kvm.h\"\n#include \"assigned-dev.h\"\n#include \"irq.h\"\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/spinlock.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic irqreturn_t kvm_assigned_dev_thread_msix(int irq, void *dev_id)\n{\n\tstruct kvm_assigned_dev_kernel *assigned_dev = dev_id;\n\tint index = find_index_from_host_irq(assigned_dev, irq);\n\tu32 vector;\n\n\tif (index >= 0) {\n\t\tvector = assigned_dev->guest_msix_entries[index].vector;\n\t\tkvm_assigned_dev_raise_guest_irq(assigned_dev, vector);\n\t}\n\n\treturn IRQ_HANDLED;\n}"
  },
  {
    "function_name": "kvm_assigned_dev_msix",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/assigned-dev.c",
    "lines": "188-203",
    "snippet": "static irqreturn_t kvm_assigned_dev_msix(int irq, void *dev_id)\n{\n\tstruct kvm_assigned_dev_kernel *assigned_dev = dev_id;\n\tint index = find_index_from_host_irq(assigned_dev, irq);\n\tu32 vector;\n\tint ret = 0;\n\n\tif (index >= 0) {\n\t\tvector = assigned_dev->guest_msix_entries[index].vector;\n\t\tret = kvm_set_irq_inatomic(assigned_dev->kvm,\n\t\t\t\t\t   assigned_dev->irq_source_id,\n\t\t\t\t\t   vector, 1);\n\t}\n\n\treturn unlikely(ret == -EWOULDBLOCK) ? IRQ_WAKE_THREAD : IRQ_HANDLED;\n}",
    "includes": [
      "#include \"trace/events/kvm.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"irq.h\"",
      "#include <linux/fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/pci.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/errno.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret == -EWOULDBLOCK"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_set_irq_inatomic",
          "args": [
            "assigned_dev->kvm",
            "assigned_dev->irq_source_id",
            "vector",
            "1"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_set_irq_inatomic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/assigned-dev.c",
          "lines": "140-166",
          "snippet": "static int kvm_set_irq_inatomic(struct kvm *kvm, int irq_source_id, u32 irq,\n\t\t\t\tint level)\n{\n\tstruct kvm_kernel_irq_routing_entry entries[KVM_NR_IRQCHIPS];\n\tstruct kvm_kernel_irq_routing_entry *e;\n\tint ret = -EINVAL;\n\tint idx;\n\n\ttrace_kvm_set_irq(irq, level, irq_source_id);\n\n\t/*\n\t * Injection into either PIC or IOAPIC might need to scan all CPUs,\n\t * which would need to be retried from thread context;  when same GSI\n\t * is connected to both PIC and IOAPIC, we'd have to report a\n\t * partial failure here.\n\t * Since there's no easy way to do this, we only support injecting MSI\n\t * which is limited to 1:1 GSI mapping.\n\t */\n\tidx = srcu_read_lock(&kvm->irq_srcu);\n\tif (kvm_irq_map_gsi(kvm, entries, irq) > 0) {\n\t\te = &entries[0];\n\t\tret = kvm_arch_set_irq_inatomic(e, kvm, irq_source_id,\n\t\t\t\t\t\tirq, level);\n\t}\n\tsrcu_read_unlock(&kvm->irq_srcu, idx);\n\treturn ret;\n}",
          "includes": [
            "#include \"trace/events/kvm.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"irq.h\"",
            "#include <linux/fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/pci.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/errno.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace/events/kvm.h\"\n#include \"assigned-dev.h\"\n#include \"irq.h\"\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/spinlock.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic int kvm_set_irq_inatomic(struct kvm *kvm, int irq_source_id, u32 irq,\n\t\t\t\tint level)\n{\n\tstruct kvm_kernel_irq_routing_entry entries[KVM_NR_IRQCHIPS];\n\tstruct kvm_kernel_irq_routing_entry *e;\n\tint ret = -EINVAL;\n\tint idx;\n\n\ttrace_kvm_set_irq(irq, level, irq_source_id);\n\n\t/*\n\t * Injection into either PIC or IOAPIC might need to scan all CPUs,\n\t * which would need to be retried from thread context;  when same GSI\n\t * is connected to both PIC and IOAPIC, we'd have to report a\n\t * partial failure here.\n\t * Since there's no easy way to do this, we only support injecting MSI\n\t * which is limited to 1:1 GSI mapping.\n\t */\n\tidx = srcu_read_lock(&kvm->irq_srcu);\n\tif (kvm_irq_map_gsi(kvm, entries, irq) > 0) {\n\t\te = &entries[0];\n\t\tret = kvm_arch_set_irq_inatomic(e, kvm, irq_source_id,\n\t\t\t\t\t\tirq, level);\n\t}\n\tsrcu_read_unlock(&kvm->irq_srcu, idx);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_index_from_host_irq",
          "args": [
            "assigned_dev",
            "irq"
          ],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "find_index_from_host_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/assigned-dev.c",
          "lines": "63-81",
          "snippet": "static int find_index_from_host_irq(struct kvm_assigned_dev_kernel\n\t\t\t\t    *assigned_dev, int irq)\n{\n\tint i, index;\n\tstruct msix_entry *host_msix_entries;\n\n\thost_msix_entries = assigned_dev->host_msix_entries;\n\n\tindex = -1;\n\tfor (i = 0; i < assigned_dev->entries_nr; i++)\n\t\tif (irq == host_msix_entries[i].vector) {\n\t\t\tindex = i;\n\t\t\tbreak;\n\t\t}\n\tif (index < 0)\n\t\tprintk(KERN_WARNING \"Fail to find correlated MSI-X entry!\\n\");\n\n\treturn index;\n}",
          "includes": [
            "#include \"trace/events/kvm.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"irq.h\"",
            "#include <linux/fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/pci.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/errno.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace/events/kvm.h\"\n#include \"assigned-dev.h\"\n#include \"irq.h\"\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/spinlock.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic int find_index_from_host_irq(struct kvm_assigned_dev_kernel\n\t\t\t\t    *assigned_dev, int irq)\n{\n\tint i, index;\n\tstruct msix_entry *host_msix_entries;\n\n\thost_msix_entries = assigned_dev->host_msix_entries;\n\n\tindex = -1;\n\tfor (i = 0; i < assigned_dev->entries_nr; i++)\n\t\tif (irq == host_msix_entries[i].vector) {\n\t\t\tindex = i;\n\t\t\tbreak;\n\t\t}\n\tif (index < 0)\n\t\tprintk(KERN_WARNING \"Fail to find correlated MSI-X entry!\\n\");\n\n\treturn index;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace/events/kvm.h\"\n#include \"assigned-dev.h\"\n#include \"irq.h\"\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/spinlock.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic irqreturn_t kvm_assigned_dev_msix(int irq, void *dev_id)\n{\n\tstruct kvm_assigned_dev_kernel *assigned_dev = dev_id;\n\tint index = find_index_from_host_irq(assigned_dev, irq);\n\tu32 vector;\n\tint ret = 0;\n\n\tif (index >= 0) {\n\t\tvector = assigned_dev->guest_msix_entries[index].vector;\n\t\tret = kvm_set_irq_inatomic(assigned_dev->kvm,\n\t\t\t\t\t   assigned_dev->irq_source_id,\n\t\t\t\t\t   vector, 1);\n\t}\n\n\treturn unlikely(ret == -EWOULDBLOCK) ? IRQ_WAKE_THREAD : IRQ_HANDLED;\n}"
  },
  {
    "function_name": "kvm_assigned_dev_thread_msi",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/assigned-dev.c",
    "lines": "178-186",
    "snippet": "static irqreturn_t kvm_assigned_dev_thread_msi(int irq, void *dev_id)\n{\n\tstruct kvm_assigned_dev_kernel *assigned_dev = dev_id;\n\n\tkvm_assigned_dev_raise_guest_irq(assigned_dev,\n\t\t\t\t\t assigned_dev->guest_irq);\n\n\treturn IRQ_HANDLED;\n}",
    "includes": [
      "#include \"trace/events/kvm.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"irq.h\"",
      "#include <linux/fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/pci.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/errno.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_assigned_dev_raise_guest_irq",
          "args": [
            "assigned_dev",
            "assigned_dev->guest_irq"
          ],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_assigned_dev_raise_guest_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/assigned-dev.c",
          "lines": "99-114",
          "snippet": "static void\nkvm_assigned_dev_raise_guest_irq(struct kvm_assigned_dev_kernel *assigned_dev,\n\t\t\t\t int vector)\n{\n\tif (unlikely(assigned_dev->irq_requested_type &\n\t\t     KVM_DEV_IRQ_GUEST_INTX)) {\n\t\tspin_lock(&assigned_dev->intx_mask_lock);\n\t\tif (!(assigned_dev->flags & KVM_DEV_ASSIGN_MASK_INTX))\n\t\t\tkvm_set_irq(assigned_dev->kvm,\n\t\t\t\t    assigned_dev->irq_source_id, vector, 1,\n\t\t\t\t    false);\n\t\tspin_unlock(&assigned_dev->intx_mask_lock);\n\t} else\n\t\tkvm_set_irq(assigned_dev->kvm, assigned_dev->irq_source_id,\n\t\t\t    vector, 1, false);\n}",
          "includes": [
            "#include \"trace/events/kvm.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"irq.h\"",
            "#include <linux/fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/pci.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/errno.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace/events/kvm.h\"\n#include \"assigned-dev.h\"\n#include \"irq.h\"\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/spinlock.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void\nkvm_assigned_dev_raise_guest_irq(struct kvm_assigned_dev_kernel *assigned_dev,\n\t\t\t\t int vector)\n{\n\tif (unlikely(assigned_dev->irq_requested_type &\n\t\t     KVM_DEV_IRQ_GUEST_INTX)) {\n\t\tspin_lock(&assigned_dev->intx_mask_lock);\n\t\tif (!(assigned_dev->flags & KVM_DEV_ASSIGN_MASK_INTX))\n\t\t\tkvm_set_irq(assigned_dev->kvm,\n\t\t\t\t    assigned_dev->irq_source_id, vector, 1,\n\t\t\t\t    false);\n\t\tspin_unlock(&assigned_dev->intx_mask_lock);\n\t} else\n\t\tkvm_set_irq(assigned_dev->kvm, assigned_dev->irq_source_id,\n\t\t\t    vector, 1, false);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace/events/kvm.h\"\n#include \"assigned-dev.h\"\n#include \"irq.h\"\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/spinlock.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic irqreturn_t kvm_assigned_dev_thread_msi(int irq, void *dev_id)\n{\n\tstruct kvm_assigned_dev_kernel *assigned_dev = dev_id;\n\n\tkvm_assigned_dev_raise_guest_irq(assigned_dev,\n\t\t\t\t\t assigned_dev->guest_irq);\n\n\treturn IRQ_HANDLED;\n}"
  },
  {
    "function_name": "kvm_assigned_dev_msi",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/assigned-dev.c",
    "lines": "169-176",
    "snippet": "static irqreturn_t kvm_assigned_dev_msi(int irq, void *dev_id)\n{\n\tstruct kvm_assigned_dev_kernel *assigned_dev = dev_id;\n\tint ret = kvm_set_irq_inatomic(assigned_dev->kvm,\n\t\t\t\t       assigned_dev->irq_source_id,\n\t\t\t\t       assigned_dev->guest_irq, 1);\n\treturn unlikely(ret == -EWOULDBLOCK) ? IRQ_WAKE_THREAD : IRQ_HANDLED;\n}",
    "includes": [
      "#include \"trace/events/kvm.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"irq.h\"",
      "#include <linux/fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/pci.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/errno.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret == -EWOULDBLOCK"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_set_irq_inatomic",
          "args": [
            "assigned_dev->kvm",
            "assigned_dev->irq_source_id",
            "assigned_dev->guest_irq",
            "1"
          ],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_set_irq_inatomic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/assigned-dev.c",
          "lines": "140-166",
          "snippet": "static int kvm_set_irq_inatomic(struct kvm *kvm, int irq_source_id, u32 irq,\n\t\t\t\tint level)\n{\n\tstruct kvm_kernel_irq_routing_entry entries[KVM_NR_IRQCHIPS];\n\tstruct kvm_kernel_irq_routing_entry *e;\n\tint ret = -EINVAL;\n\tint idx;\n\n\ttrace_kvm_set_irq(irq, level, irq_source_id);\n\n\t/*\n\t * Injection into either PIC or IOAPIC might need to scan all CPUs,\n\t * which would need to be retried from thread context;  when same GSI\n\t * is connected to both PIC and IOAPIC, we'd have to report a\n\t * partial failure here.\n\t * Since there's no easy way to do this, we only support injecting MSI\n\t * which is limited to 1:1 GSI mapping.\n\t */\n\tidx = srcu_read_lock(&kvm->irq_srcu);\n\tif (kvm_irq_map_gsi(kvm, entries, irq) > 0) {\n\t\te = &entries[0];\n\t\tret = kvm_arch_set_irq_inatomic(e, kvm, irq_source_id,\n\t\t\t\t\t\tirq, level);\n\t}\n\tsrcu_read_unlock(&kvm->irq_srcu, idx);\n\treturn ret;\n}",
          "includes": [
            "#include \"trace/events/kvm.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"irq.h\"",
            "#include <linux/fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/pci.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/errno.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace/events/kvm.h\"\n#include \"assigned-dev.h\"\n#include \"irq.h\"\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/spinlock.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic int kvm_set_irq_inatomic(struct kvm *kvm, int irq_source_id, u32 irq,\n\t\t\t\tint level)\n{\n\tstruct kvm_kernel_irq_routing_entry entries[KVM_NR_IRQCHIPS];\n\tstruct kvm_kernel_irq_routing_entry *e;\n\tint ret = -EINVAL;\n\tint idx;\n\n\ttrace_kvm_set_irq(irq, level, irq_source_id);\n\n\t/*\n\t * Injection into either PIC or IOAPIC might need to scan all CPUs,\n\t * which would need to be retried from thread context;  when same GSI\n\t * is connected to both PIC and IOAPIC, we'd have to report a\n\t * partial failure here.\n\t * Since there's no easy way to do this, we only support injecting MSI\n\t * which is limited to 1:1 GSI mapping.\n\t */\n\tidx = srcu_read_lock(&kvm->irq_srcu);\n\tif (kvm_irq_map_gsi(kvm, entries, irq) > 0) {\n\t\te = &entries[0];\n\t\tret = kvm_arch_set_irq_inatomic(e, kvm, irq_source_id,\n\t\t\t\t\t\tirq, level);\n\t}\n\tsrcu_read_unlock(&kvm->irq_srcu, idx);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace/events/kvm.h\"\n#include \"assigned-dev.h\"\n#include \"irq.h\"\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/spinlock.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic irqreturn_t kvm_assigned_dev_msi(int irq, void *dev_id)\n{\n\tstruct kvm_assigned_dev_kernel *assigned_dev = dev_id;\n\tint ret = kvm_set_irq_inatomic(assigned_dev->kvm,\n\t\t\t\t       assigned_dev->irq_source_id,\n\t\t\t\t       assigned_dev->guest_irq, 1);\n\treturn unlikely(ret == -EWOULDBLOCK) ? IRQ_WAKE_THREAD : IRQ_HANDLED;\n}"
  },
  {
    "function_name": "kvm_set_irq_inatomic",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/assigned-dev.c",
    "lines": "140-166",
    "snippet": "static int kvm_set_irq_inatomic(struct kvm *kvm, int irq_source_id, u32 irq,\n\t\t\t\tint level)\n{\n\tstruct kvm_kernel_irq_routing_entry entries[KVM_NR_IRQCHIPS];\n\tstruct kvm_kernel_irq_routing_entry *e;\n\tint ret = -EINVAL;\n\tint idx;\n\n\ttrace_kvm_set_irq(irq, level, irq_source_id);\n\n\t/*\n\t * Injection into either PIC or IOAPIC might need to scan all CPUs,\n\t * which would need to be retried from thread context;  when same GSI\n\t * is connected to both PIC and IOAPIC, we'd have to report a\n\t * partial failure here.\n\t * Since there's no easy way to do this, we only support injecting MSI\n\t * which is limited to 1:1 GSI mapping.\n\t */\n\tidx = srcu_read_lock(&kvm->irq_srcu);\n\tif (kvm_irq_map_gsi(kvm, entries, irq) > 0) {\n\t\te = &entries[0];\n\t\tret = kvm_arch_set_irq_inatomic(e, kvm, irq_source_id,\n\t\t\t\t\t\tirq, level);\n\t}\n\tsrcu_read_unlock(&kvm->irq_srcu, idx);\n\treturn ret;\n}",
    "includes": [
      "#include \"trace/events/kvm.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"irq.h\"",
      "#include <linux/fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/pci.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/errno.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "srcu_read_unlock",
          "args": [
            "&kvm->irq_srcu",
            "idx"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_arch_set_irq_inatomic",
          "args": [
            "e",
            "kvm",
            "irq_source_id",
            "irq",
            "level"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_arch_set_irq_inatomic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/irq_comm.c",
          "lines": "146-162",
          "snippet": "int kvm_arch_set_irq_inatomic(struct kvm_kernel_irq_routing_entry *e,\n\t\t\t      struct kvm *kvm, int irq_source_id, int level,\n\t\t\t      bool line_status)\n{\n\tstruct kvm_lapic_irq irq;\n\tint r;\n\n\tif (unlikely(e->type != KVM_IRQ_ROUTING_MSI))\n\t\treturn -EWOULDBLOCK;\n\n\tkvm_set_msi_irq(e, &irq);\n\n\tif (kvm_irq_delivery_to_apic_fast(kvm, NULL, &irq, &r, NULL))\n\t\treturn r;\n\telse\n\t\treturn -EWOULDBLOCK;\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"hyperv.h\"",
            "#include \"lapic.h\"",
            "#include \"ioapic.h\"",
            "#include \"irq.h\"",
            "#include <asm/msidef.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"hyperv.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include \"irq.h\"\n#include <asm/msidef.h>\n#include <trace/events/kvm.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nint kvm_arch_set_irq_inatomic(struct kvm_kernel_irq_routing_entry *e,\n\t\t\t      struct kvm *kvm, int irq_source_id, int level,\n\t\t\t      bool line_status)\n{\n\tstruct kvm_lapic_irq irq;\n\tint r;\n\n\tif (unlikely(e->type != KVM_IRQ_ROUTING_MSI))\n\t\treturn -EWOULDBLOCK;\n\n\tkvm_set_msi_irq(e, &irq);\n\n\tif (kvm_irq_delivery_to_apic_fast(kvm, NULL, &irq, &r, NULL))\n\t\treturn r;\n\telse\n\t\treturn -EWOULDBLOCK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_irq_map_gsi",
          "args": [
            "kvm",
            "entries",
            "irq"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "srcu_read_lock",
          "args": [
            "&kvm->irq_srcu"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_kvm_set_irq",
          "args": [
            "irq",
            "level",
            "irq_source_id"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace/events/kvm.h\"\n#include \"assigned-dev.h\"\n#include \"irq.h\"\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/spinlock.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic int kvm_set_irq_inatomic(struct kvm *kvm, int irq_source_id, u32 irq,\n\t\t\t\tint level)\n{\n\tstruct kvm_kernel_irq_routing_entry entries[KVM_NR_IRQCHIPS];\n\tstruct kvm_kernel_irq_routing_entry *e;\n\tint ret = -EINVAL;\n\tint idx;\n\n\ttrace_kvm_set_irq(irq, level, irq_source_id);\n\n\t/*\n\t * Injection into either PIC or IOAPIC might need to scan all CPUs,\n\t * which would need to be retried from thread context;  when same GSI\n\t * is connected to both PIC and IOAPIC, we'd have to report a\n\t * partial failure here.\n\t * Since there's no easy way to do this, we only support injecting MSI\n\t * which is limited to 1:1 GSI mapping.\n\t */\n\tidx = srcu_read_lock(&kvm->irq_srcu);\n\tif (kvm_irq_map_gsi(kvm, entries, irq) > 0) {\n\t\te = &entries[0];\n\t\tret = kvm_arch_set_irq_inatomic(e, kvm, irq_source_id,\n\t\t\t\t\t\tirq, level);\n\t}\n\tsrcu_read_unlock(&kvm->irq_srcu, idx);\n\treturn ret;\n}"
  },
  {
    "function_name": "kvm_assigned_dev_thread_intx",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/assigned-dev.c",
    "lines": "116-131",
    "snippet": "static irqreturn_t kvm_assigned_dev_thread_intx(int irq, void *dev_id)\n{\n\tstruct kvm_assigned_dev_kernel *assigned_dev = dev_id;\n\n\tif (!(assigned_dev->flags & KVM_DEV_ASSIGN_PCI_2_3)) {\n\t\tspin_lock_irq(&assigned_dev->intx_lock);\n\t\tdisable_irq_nosync(irq);\n\t\tassigned_dev->host_irq_disabled = true;\n\t\tspin_unlock_irq(&assigned_dev->intx_lock);\n\t}\n\n\tkvm_assigned_dev_raise_guest_irq(assigned_dev,\n\t\t\t\t\t assigned_dev->guest_irq);\n\n\treturn IRQ_HANDLED;\n}",
    "includes": [
      "#include \"trace/events/kvm.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"irq.h\"",
      "#include <linux/fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/pci.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/errno.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_assigned_dev_raise_guest_irq",
          "args": [
            "assigned_dev",
            "assigned_dev->guest_irq"
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_assigned_dev_raise_guest_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/assigned-dev.c",
          "lines": "99-114",
          "snippet": "static void\nkvm_assigned_dev_raise_guest_irq(struct kvm_assigned_dev_kernel *assigned_dev,\n\t\t\t\t int vector)\n{\n\tif (unlikely(assigned_dev->irq_requested_type &\n\t\t     KVM_DEV_IRQ_GUEST_INTX)) {\n\t\tspin_lock(&assigned_dev->intx_mask_lock);\n\t\tif (!(assigned_dev->flags & KVM_DEV_ASSIGN_MASK_INTX))\n\t\t\tkvm_set_irq(assigned_dev->kvm,\n\t\t\t\t    assigned_dev->irq_source_id, vector, 1,\n\t\t\t\t    false);\n\t\tspin_unlock(&assigned_dev->intx_mask_lock);\n\t} else\n\t\tkvm_set_irq(assigned_dev->kvm, assigned_dev->irq_source_id,\n\t\t\t    vector, 1, false);\n}",
          "includes": [
            "#include \"trace/events/kvm.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"irq.h\"",
            "#include <linux/fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/pci.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/errno.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace/events/kvm.h\"\n#include \"assigned-dev.h\"\n#include \"irq.h\"\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/spinlock.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void\nkvm_assigned_dev_raise_guest_irq(struct kvm_assigned_dev_kernel *assigned_dev,\n\t\t\t\t int vector)\n{\n\tif (unlikely(assigned_dev->irq_requested_type &\n\t\t     KVM_DEV_IRQ_GUEST_INTX)) {\n\t\tspin_lock(&assigned_dev->intx_mask_lock);\n\t\tif (!(assigned_dev->flags & KVM_DEV_ASSIGN_MASK_INTX))\n\t\t\tkvm_set_irq(assigned_dev->kvm,\n\t\t\t\t    assigned_dev->irq_source_id, vector, 1,\n\t\t\t\t    false);\n\t\tspin_unlock(&assigned_dev->intx_mask_lock);\n\t} else\n\t\tkvm_set_irq(assigned_dev->kvm, assigned_dev->irq_source_id,\n\t\t\t    vector, 1, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&assigned_dev->intx_lock"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "disable_irq_nosync",
          "args": [
            "irq"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&assigned_dev->intx_lock"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace/events/kvm.h\"\n#include \"assigned-dev.h\"\n#include \"irq.h\"\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/spinlock.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic irqreturn_t kvm_assigned_dev_thread_intx(int irq, void *dev_id)\n{\n\tstruct kvm_assigned_dev_kernel *assigned_dev = dev_id;\n\n\tif (!(assigned_dev->flags & KVM_DEV_ASSIGN_PCI_2_3)) {\n\t\tspin_lock_irq(&assigned_dev->intx_lock);\n\t\tdisable_irq_nosync(irq);\n\t\tassigned_dev->host_irq_disabled = true;\n\t\tspin_unlock_irq(&assigned_dev->intx_lock);\n\t}\n\n\tkvm_assigned_dev_raise_guest_irq(assigned_dev,\n\t\t\t\t\t assigned_dev->guest_irq);\n\n\treturn IRQ_HANDLED;\n}"
  },
  {
    "function_name": "kvm_assigned_dev_raise_guest_irq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/assigned-dev.c",
    "lines": "99-114",
    "snippet": "static void\nkvm_assigned_dev_raise_guest_irq(struct kvm_assigned_dev_kernel *assigned_dev,\n\t\t\t\t int vector)\n{\n\tif (unlikely(assigned_dev->irq_requested_type &\n\t\t     KVM_DEV_IRQ_GUEST_INTX)) {\n\t\tspin_lock(&assigned_dev->intx_mask_lock);\n\t\tif (!(assigned_dev->flags & KVM_DEV_ASSIGN_MASK_INTX))\n\t\t\tkvm_set_irq(assigned_dev->kvm,\n\t\t\t\t    assigned_dev->irq_source_id, vector, 1,\n\t\t\t\t    false);\n\t\tspin_unlock(&assigned_dev->intx_mask_lock);\n\t} else\n\t\tkvm_set_irq(assigned_dev->kvm, assigned_dev->irq_source_id,\n\t\t\t    vector, 1, false);\n}",
    "includes": [
      "#include \"trace/events/kvm.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"irq.h\"",
      "#include <linux/fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/pci.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/errno.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_set_irq",
          "args": [
            "assigned_dev->kvm",
            "assigned_dev->irq_source_id",
            "vector",
            "1",
            "false"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&assigned_dev->intx_mask_lock"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_set_irq",
          "args": [
            "assigned_dev->kvm",
            "assigned_dev->irq_source_id",
            "vector",
            "1",
            "false"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&assigned_dev->intx_mask_lock"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "assigned_dev->irq_requested_type &\n\t\t     KVM_DEV_IRQ_GUEST_INTX"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace/events/kvm.h\"\n#include \"assigned-dev.h\"\n#include \"irq.h\"\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/spinlock.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void\nkvm_assigned_dev_raise_guest_irq(struct kvm_assigned_dev_kernel *assigned_dev,\n\t\t\t\t int vector)\n{\n\tif (unlikely(assigned_dev->irq_requested_type &\n\t\t     KVM_DEV_IRQ_GUEST_INTX)) {\n\t\tspin_lock(&assigned_dev->intx_mask_lock);\n\t\tif (!(assigned_dev->flags & KVM_DEV_ASSIGN_MASK_INTX))\n\t\t\tkvm_set_irq(assigned_dev->kvm,\n\t\t\t\t    assigned_dev->irq_source_id, vector, 1,\n\t\t\t\t    false);\n\t\tspin_unlock(&assigned_dev->intx_mask_lock);\n\t} else\n\t\tkvm_set_irq(assigned_dev->kvm, assigned_dev->irq_source_id,\n\t\t\t    vector, 1, false);\n}"
  },
  {
    "function_name": "kvm_assigned_dev_intx",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/assigned-dev.c",
    "lines": "83-97",
    "snippet": "static irqreturn_t kvm_assigned_dev_intx(int irq, void *dev_id)\n{\n\tstruct kvm_assigned_dev_kernel *assigned_dev = dev_id;\n\tint ret;\n\n\tspin_lock(&assigned_dev->intx_lock);\n\tif (pci_check_and_mask_intx(assigned_dev->dev)) {\n\t\tassigned_dev->host_irq_disabled = true;\n\t\tret = IRQ_WAKE_THREAD;\n\t} else\n\t\tret = IRQ_NONE;\n\tspin_unlock(&assigned_dev->intx_lock);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace/events/kvm.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"irq.h\"",
      "#include <linux/fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/pci.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/errno.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&assigned_dev->intx_lock"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_check_and_mask_intx",
          "args": [
            "assigned_dev->dev"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&assigned_dev->intx_lock"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace/events/kvm.h\"\n#include \"assigned-dev.h\"\n#include \"irq.h\"\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/spinlock.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic irqreturn_t kvm_assigned_dev_intx(int irq, void *dev_id)\n{\n\tstruct kvm_assigned_dev_kernel *assigned_dev = dev_id;\n\tint ret;\n\n\tspin_lock(&assigned_dev->intx_lock);\n\tif (pci_check_and_mask_intx(assigned_dev->dev)) {\n\t\tassigned_dev->host_irq_disabled = true;\n\t\tret = IRQ_WAKE_THREAD;\n\t} else\n\t\tret = IRQ_NONE;\n\tspin_unlock(&assigned_dev->intx_lock);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "find_index_from_host_irq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/assigned-dev.c",
    "lines": "63-81",
    "snippet": "static int find_index_from_host_irq(struct kvm_assigned_dev_kernel\n\t\t\t\t    *assigned_dev, int irq)\n{\n\tint i, index;\n\tstruct msix_entry *host_msix_entries;\n\n\thost_msix_entries = assigned_dev->host_msix_entries;\n\n\tindex = -1;\n\tfor (i = 0; i < assigned_dev->entries_nr; i++)\n\t\tif (irq == host_msix_entries[i].vector) {\n\t\t\tindex = i;\n\t\t\tbreak;\n\t\t}\n\tif (index < 0)\n\t\tprintk(KERN_WARNING \"Fail to find correlated MSI-X entry!\\n\");\n\n\treturn index;\n}",
    "includes": [
      "#include \"trace/events/kvm.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"irq.h\"",
      "#include <linux/fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/pci.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/errno.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"Fail to find correlated MSI-X entry!\\n\""
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace/events/kvm.h\"\n#include \"assigned-dev.h\"\n#include \"irq.h\"\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/spinlock.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic int find_index_from_host_irq(struct kvm_assigned_dev_kernel\n\t\t\t\t    *assigned_dev, int irq)\n{\n\tint i, index;\n\tstruct msix_entry *host_msix_entries;\n\n\thost_msix_entries = assigned_dev->host_msix_entries;\n\n\tindex = -1;\n\tfor (i = 0; i < assigned_dev->entries_nr; i++)\n\t\tif (irq == host_msix_entries[i].vector) {\n\t\t\tindex = i;\n\t\t\tbreak;\n\t\t}\n\tif (index < 0)\n\t\tprintk(KERN_WARNING \"Fail to find correlated MSI-X entry!\\n\");\n\n\treturn index;\n}"
  },
  {
    "function_name": "kvm_find_assigned_dev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/assigned-dev.c",
    "lines": "51-61",
    "snippet": "static struct kvm_assigned_dev_kernel *kvm_find_assigned_dev(struct list_head *head,\n\t\t\t\t\t\t      int assigned_dev_id)\n{\n\tstruct kvm_assigned_dev_kernel *match;\n\n\tlist_for_each_entry(match, head, list) {\n\t\tif (match->assigned_dev_id == assigned_dev_id)\n\t\t\treturn match;\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include \"trace/events/kvm.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"irq.h\"",
      "#include <linux/fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/pci.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/errno.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "match",
            "head",
            "list"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace/events/kvm.h\"\n#include \"assigned-dev.h\"\n#include \"irq.h\"\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/spinlock.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic struct kvm_assigned_dev_kernel *kvm_find_assigned_dev(struct list_head *head,\n\t\t\t\t\t\t      int assigned_dev_id)\n{\n\tstruct kvm_assigned_dev_kernel *match;\n\n\tlist_for_each_entry(match, head, list) {\n\t\tif (match->assigned_dev_id == assigned_dev_id)\n\t\t\treturn match;\n\t}\n\treturn NULL;\n}"
  }
]