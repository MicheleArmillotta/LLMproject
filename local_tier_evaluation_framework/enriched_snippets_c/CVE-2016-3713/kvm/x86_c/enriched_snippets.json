[
  {
    "function_name": "kvm_vector_hashing_enabled",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "8415-8418",
    "snippet": "bool kvm_vector_hashing_enabled(void)\n{\n\treturn vector_hashing;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nbool kvm_vector_hashing_enabled(void)\n{\n\treturn vector_hashing;\n}"
  },
  {
    "function_name": "kvm_arch_update_irqfd_routing",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "8406-8413",
    "snippet": "int kvm_arch_update_irqfd_routing(struct kvm *kvm, unsigned int host_irq,\n\t\t\t\t   uint32_t guest_irq, bool set)\n{\n\tif (!kvm_x86_ops->update_pi_irte)\n\t\treturn -EINVAL;\n\n\treturn kvm_x86_ops->update_pi_irte(kvm, host_irq, guest_irq, set);\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct kvm_x86_ops *kvm_x86_ops"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_x86_ops->update_pi_irte",
          "args": [
            "kvm",
            "host_irq",
            "guest_irq",
            "set"
          ],
          "line": 8412
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstruct kvm_x86_ops *kvm_x86_ops;\n\nint kvm_arch_update_irqfd_routing(struct kvm *kvm, unsigned int host_irq,\n\t\t\t\t   uint32_t guest_irq, bool set)\n{\n\tif (!kvm_x86_ops->update_pi_irte)\n\t\treturn -EINVAL;\n\n\treturn kvm_x86_ops->update_pi_irte(kvm, host_irq, guest_irq, set);\n}"
  },
  {
    "function_name": "kvm_arch_irq_bypass_del_producer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "8384-8404",
    "snippet": "void kvm_arch_irq_bypass_del_producer(struct irq_bypass_consumer *cons,\n\t\t\t\t      struct irq_bypass_producer *prod)\n{\n\tint ret;\n\tstruct kvm_kernel_irqfd *irqfd =\n\t\tcontainer_of(cons, struct kvm_kernel_irqfd, consumer);\n\n\tWARN_ON(irqfd->producer != prod);\n\tirqfd->producer = NULL;\n\n\t/*\n\t * When producer of consumer is unregistered, we change back to\n\t * remapped mode, so we can re-use the current implementation\n\t * when the irq is masked/disabed or the consumer side (KVM\n\t * int this case doesn't want to receive the interrupts.\n\t*/\n\tret = kvm_x86_ops->update_pi_irte(irqfd->kvm, prod->irq, irqfd->gsi, 0);\n\tif (ret)\n\t\tprintk(KERN_INFO \"irq bypass consumer (token %p) unregistration\"\n\t\t       \" fails: %d\\n\", irqfd->consumer.token, ret);\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct kvm_x86_ops *kvm_x86_ops"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO \"irq bypass consumer (token %p) unregistration\"\n\t\t       \" fails: %d\\n\"",
            "irqfd->consumer.token",
            "ret"
          ],
          "line": 8402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_x86_ops->update_pi_irte",
          "args": [
            "irqfd->kvm",
            "prod->irq",
            "irqfd->gsi",
            "0"
          ],
          "line": 8400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "irqfd->producer != prod"
          ],
          "line": 8391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "cons",
            "structkvm_kernel_irqfd",
            "consumer"
          ],
          "line": 8389
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstruct kvm_x86_ops *kvm_x86_ops;\n\nvoid kvm_arch_irq_bypass_del_producer(struct irq_bypass_consumer *cons,\n\t\t\t\t      struct irq_bypass_producer *prod)\n{\n\tint ret;\n\tstruct kvm_kernel_irqfd *irqfd =\n\t\tcontainer_of(cons, struct kvm_kernel_irqfd, consumer);\n\n\tWARN_ON(irqfd->producer != prod);\n\tirqfd->producer = NULL;\n\n\t/*\n\t * When producer of consumer is unregistered, we change back to\n\t * remapped mode, so we can re-use the current implementation\n\t * when the irq is masked/disabed or the consumer side (KVM\n\t * int this case doesn't want to receive the interrupts.\n\t*/\n\tret = kvm_x86_ops->update_pi_irte(irqfd->kvm, prod->irq, irqfd->gsi, 0);\n\tif (ret)\n\t\tprintk(KERN_INFO \"irq bypass consumer (token %p) unregistration\"\n\t\t       \" fails: %d\\n\", irqfd->consumer.token, ret);\n}"
  },
  {
    "function_name": "kvm_arch_irq_bypass_add_producer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "8372-8382",
    "snippet": "int kvm_arch_irq_bypass_add_producer(struct irq_bypass_consumer *cons,\n\t\t\t\t      struct irq_bypass_producer *prod)\n{\n\tstruct kvm_kernel_irqfd *irqfd =\n\t\tcontainer_of(cons, struct kvm_kernel_irqfd, consumer);\n\n\tirqfd->producer = prod;\n\n\treturn kvm_x86_ops->update_pi_irte(irqfd->kvm,\n\t\t\t\t\t   prod->irq, irqfd->gsi, 1);\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct kvm_x86_ops *kvm_x86_ops"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_x86_ops->update_pi_irte",
          "args": [
            "irqfd->kvm",
            "prod->irq",
            "irqfd->gsi",
            "1"
          ],
          "line": 8380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "cons",
            "structkvm_kernel_irqfd",
            "consumer"
          ],
          "line": 8376
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstruct kvm_x86_ops *kvm_x86_ops;\n\nint kvm_arch_irq_bypass_add_producer(struct irq_bypass_consumer *cons,\n\t\t\t\t      struct irq_bypass_producer *prod)\n{\n\tstruct kvm_kernel_irqfd *irqfd =\n\t\tcontainer_of(cons, struct kvm_kernel_irqfd, consumer);\n\n\tirqfd->producer = prod;\n\n\treturn kvm_x86_ops->update_pi_irte(irqfd->kvm,\n\t\t\t\t\t   prod->irq, irqfd->gsi, 1);\n}"
  },
  {
    "function_name": "kvm_arch_has_irq_bypass",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "8367-8370",
    "snippet": "bool kvm_arch_has_irq_bypass(void)\n{\n\treturn kvm_x86_ops->update_pi_irte != NULL;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct kvm_x86_ops *kvm_x86_ops"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstruct kvm_x86_ops *kvm_x86_ops;\n\nbool kvm_arch_has_irq_bypass(void)\n{\n\treturn kvm_x86_ops->update_pi_irte != NULL;\n}"
  },
  {
    "function_name": "kvm_arch_has_noncoherent_dma",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "8361-8364",
    "snippet": "bool kvm_arch_has_noncoherent_dma(struct kvm *kvm)\n{\n\treturn atomic_read(&kvm->arch.noncoherent_dma_count);\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&kvm->arch.noncoherent_dma_count"
          ],
          "line": 8363
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nbool kvm_arch_has_noncoherent_dma(struct kvm *kvm)\n{\n\treturn atomic_read(&kvm->arch.noncoherent_dma_count);\n}"
  },
  {
    "function_name": "kvm_arch_unregister_noncoherent_dma",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "8355-8358",
    "snippet": "void kvm_arch_unregister_noncoherent_dma(struct kvm *kvm)\n{\n\tatomic_dec(&kvm->arch.noncoherent_dma_count);\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&kvm->arch.noncoherent_dma_count"
          ],
          "line": 8357
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nvoid kvm_arch_unregister_noncoherent_dma(struct kvm *kvm)\n{\n\tatomic_dec(&kvm->arch.noncoherent_dma_count);\n}"
  },
  {
    "function_name": "kvm_arch_register_noncoherent_dma",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "8349-8352",
    "snippet": "void kvm_arch_register_noncoherent_dma(struct kvm *kvm)\n{\n\tatomic_inc(&kvm->arch.noncoherent_dma_count);\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&kvm->arch.noncoherent_dma_count"
          ],
          "line": 8351
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nvoid kvm_arch_register_noncoherent_dma(struct kvm *kvm)\n{\n\tatomic_inc(&kvm->arch.noncoherent_dma_count);\n}"
  },
  {
    "function_name": "kvm_arch_has_assigned_device",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "8343-8346",
    "snippet": "bool kvm_arch_has_assigned_device(struct kvm *kvm)\n{\n\treturn atomic_read(&kvm->arch.assigned_device_count);\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&kvm->arch.assigned_device_count"
          ],
          "line": 8345
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nbool kvm_arch_has_assigned_device(struct kvm *kvm)\n{\n\treturn atomic_read(&kvm->arch.assigned_device_count);\n}"
  },
  {
    "function_name": "kvm_arch_end_assignment",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "8337-8340",
    "snippet": "void kvm_arch_end_assignment(struct kvm *kvm)\n{\n\tatomic_dec(&kvm->arch.assigned_device_count);\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&kvm->arch.assigned_device_count"
          ],
          "line": 8339
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nvoid kvm_arch_end_assignment(struct kvm *kvm)\n{\n\tatomic_dec(&kvm->arch.assigned_device_count);\n}"
  },
  {
    "function_name": "kvm_arch_start_assignment",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "8331-8334",
    "snippet": "void kvm_arch_start_assignment(struct kvm *kvm)\n{\n\tatomic_inc(&kvm->arch.assigned_device_count);\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&kvm->arch.assigned_device_count"
          ],
          "line": 8333
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nvoid kvm_arch_start_assignment(struct kvm *kvm)\n{\n\tatomic_inc(&kvm->arch.assigned_device_count);\n}"
  },
  {
    "function_name": "kvm_arch_can_inject_async_page_present",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "8322-8329",
    "snippet": "bool kvm_arch_can_inject_async_page_present(struct kvm_vcpu *vcpu)\n{\n\tif (!(vcpu->arch.apf.msr_val & KVM_ASYNC_PF_ENABLED))\n\t\treturn true;\n\telse\n\t\treturn !kvm_event_needs_reinjection(vcpu) &&\n\t\t\tkvm_x86_ops->interrupt_allowed(vcpu);\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);",
      "struct kvm_x86_ops *kvm_x86_ops"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_x86_ops->interrupt_allowed",
          "args": [
            "vcpu"
          ],
          "line": 8328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_event_needs_reinjection",
          "args": [
            "vcpu"
          ],
          "line": 8327
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_event_needs_reinjection",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.h",
          "lines": "27-31",
          "snippet": "static inline bool kvm_event_needs_reinjection(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.exception.pending || vcpu->arch.interrupt.pending ||\n\t\tvcpu->arch.nmi_injected;\n}",
          "includes": [
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline bool kvm_event_needs_reinjection(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.exception.pending || vcpu->arch.interrupt.pending ||\n\t\tvcpu->arch.nmi_injected;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nbool kvm_arch_can_inject_async_page_present(struct kvm_vcpu *vcpu)\n{\n\tif (!(vcpu->arch.apf.msr_val & KVM_ASYNC_PF_ENABLED))\n\t\treturn true;\n\telse\n\t\treturn !kvm_event_needs_reinjection(vcpu) &&\n\t\t\tkvm_x86_ops->interrupt_allowed(vcpu);\n}"
  },
  {
    "function_name": "kvm_arch_async_page_present",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "8298-8320",
    "snippet": "void kvm_arch_async_page_present(struct kvm_vcpu *vcpu,\n\t\t\t\t struct kvm_async_pf *work)\n{\n\tstruct x86_exception fault;\n\n\ttrace_kvm_async_pf_ready(work->arch.token, work->gva);\n\tif (work->wakeup_all)\n\t\twork->arch.token = ~0; /* broadcast wakeup */\n\telse\n\t\tkvm_del_async_pf_gfn(vcpu, work->arch.gfn);\n\n\tif ((vcpu->arch.apf.msr_val & KVM_ASYNC_PF_ENABLED) &&\n\t    !apf_put_user(vcpu, KVM_PV_REASON_PAGE_READY)) {\n\t\tfault.vector = PF_VECTOR;\n\t\tfault.error_code_valid = true;\n\t\tfault.error_code = 0;\n\t\tfault.nested_page_fault = false;\n\t\tfault.address = work->arch.token;\n\t\tkvm_inject_page_fault(vcpu, &fault);\n\t}\n\tvcpu->arch.apf.halted = false;\n\tvcpu->arch.mp_state = KVM_MP_STATE_RUNNABLE;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_inject_page_fault",
          "args": [
            "vcpu",
            "&fault"
          ],
          "line": 8316
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_inject_page_fault",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "430-435",
          "snippet": "void kvm_inject_page_fault(struct kvm_vcpu *vcpu, struct x86_exception *fault)\n{\n\t++vcpu->stat.pf_guest;\n\tvcpu->arch.cr2 = fault->address;\n\tkvm_queue_exception_e(vcpu, PF_VECTOR, fault->error_code);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nvoid kvm_inject_page_fault(struct kvm_vcpu *vcpu, struct x86_exception *fault)\n{\n\t++vcpu->stat.pf_guest;\n\tvcpu->arch.cr2 = fault->address;\n\tkvm_queue_exception_e(vcpu, PF_VECTOR, fault->error_code);\n}"
        }
      },
      {
        "call_info": {
          "callee": "apf_put_user",
          "args": [
            "vcpu",
            "KVM_PV_REASON_PAGE_READY"
          ],
          "line": 8310
        },
        "resolved": true,
        "details": {
          "function_name": "apf_put_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "8269-8274",
          "snippet": "static int apf_put_user(struct kvm_vcpu *vcpu, u32 val)\n{\n\n\treturn kvm_write_guest_cached(vcpu->kvm, &vcpu->arch.apf.data, &val,\n\t\t\t\t      sizeof(val));\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic int apf_put_user(struct kvm_vcpu *vcpu, u32 val)\n{\n\n\treturn kvm_write_guest_cached(vcpu->kvm, &vcpu->arch.apf.data, &val,\n\t\t\t\t      sizeof(val));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_del_async_pf_gfn",
          "args": [
            "vcpu",
            "work->arch.gfn"
          ],
          "line": 8307
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_del_async_pf_gfn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "8246-8267",
          "snippet": "static void kvm_del_async_pf_gfn(struct kvm_vcpu *vcpu, gfn_t gfn)\n{\n\tu32 i, j, k;\n\n\ti = j = kvm_async_pf_gfn_slot(vcpu, gfn);\n\twhile (true) {\n\t\tvcpu->arch.apf.gfns[i] = ~0;\n\t\tdo {\n\t\t\tj = kvm_async_pf_next_probe(j);\n\t\t\tif (vcpu->arch.apf.gfns[j] == ~0)\n\t\t\t\treturn;\n\t\t\tk = kvm_async_pf_hash_fn(vcpu->arch.apf.gfns[j]);\n\t\t\t/*\n\t\t\t * k lies cyclically in ]i,j]\n\t\t\t * |    i.k.j |\n\t\t\t * |....j i.k.| or  |.k..j i...|\n\t\t\t */\n\t\t} while ((i <= j) ? (i < k && k <= j) : (i < k || k <= j));\n\t\tvcpu->arch.apf.gfns[i] = vcpu->arch.apf.gfns[j];\n\t\ti = j;\n\t}\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic void kvm_del_async_pf_gfn(struct kvm_vcpu *vcpu, gfn_t gfn)\n{\n\tu32 i, j, k;\n\n\ti = j = kvm_async_pf_gfn_slot(vcpu, gfn);\n\twhile (true) {\n\t\tvcpu->arch.apf.gfns[i] = ~0;\n\t\tdo {\n\t\t\tj = kvm_async_pf_next_probe(j);\n\t\t\tif (vcpu->arch.apf.gfns[j] == ~0)\n\t\t\t\treturn;\n\t\t\tk = kvm_async_pf_hash_fn(vcpu->arch.apf.gfns[j]);\n\t\t\t/*\n\t\t\t * k lies cyclically in ]i,j]\n\t\t\t * |    i.k.j |\n\t\t\t * |....j i.k.| or  |.k..j i...|\n\t\t\t */\n\t\t} while ((i <= j) ? (i < k && k <= j) : (i < k || k <= j));\n\t\tvcpu->arch.apf.gfns[i] = vcpu->arch.apf.gfns[j];\n\t\ti = j;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_kvm_async_pf_ready",
          "args": [
            "work->arch.token",
            "work->gva"
          ],
          "line": 8303
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nvoid kvm_arch_async_page_present(struct kvm_vcpu *vcpu,\n\t\t\t\t struct kvm_async_pf *work)\n{\n\tstruct x86_exception fault;\n\n\ttrace_kvm_async_pf_ready(work->arch.token, work->gva);\n\tif (work->wakeup_all)\n\t\twork->arch.token = ~0; /* broadcast wakeup */\n\telse\n\t\tkvm_del_async_pf_gfn(vcpu, work->arch.gfn);\n\n\tif ((vcpu->arch.apf.msr_val & KVM_ASYNC_PF_ENABLED) &&\n\t    !apf_put_user(vcpu, KVM_PV_REASON_PAGE_READY)) {\n\t\tfault.vector = PF_VECTOR;\n\t\tfault.error_code_valid = true;\n\t\tfault.error_code = 0;\n\t\tfault.nested_page_fault = false;\n\t\tfault.address = work->arch.token;\n\t\tkvm_inject_page_fault(vcpu, &fault);\n\t}\n\tvcpu->arch.apf.halted = false;\n\tvcpu->arch.mp_state = KVM_MP_STATE_RUNNABLE;\n}"
  },
  {
    "function_name": "kvm_arch_async_page_not_present",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "8276-8296",
    "snippet": "void kvm_arch_async_page_not_present(struct kvm_vcpu *vcpu,\n\t\t\t\t     struct kvm_async_pf *work)\n{\n\tstruct x86_exception fault;\n\n\ttrace_kvm_async_pf_not_present(work->arch.token, work->gva);\n\tkvm_add_async_pf_gfn(vcpu, work->arch.gfn);\n\n\tif (!(vcpu->arch.apf.msr_val & KVM_ASYNC_PF_ENABLED) ||\n\t    (vcpu->arch.apf.send_user_only &&\n\t     kvm_x86_ops->get_cpl(vcpu) == 0))\n\t\tkvm_make_request(KVM_REQ_APF_HALT, vcpu);\n\telse if (!apf_put_user(vcpu, KVM_PV_REASON_PAGE_NOT_PRESENT)) {\n\t\tfault.vector = PF_VECTOR;\n\t\tfault.error_code_valid = true;\n\t\tfault.error_code = 0;\n\t\tfault.nested_page_fault = false;\n\t\tfault.address = work->arch.token;\n\t\tkvm_inject_page_fault(vcpu, &fault);\n\t}\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);",
      "struct kvm_x86_ops *kvm_x86_ops"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_inject_page_fault",
          "args": [
            "vcpu",
            "&fault"
          ],
          "line": 8294
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_inject_page_fault",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "430-435",
          "snippet": "void kvm_inject_page_fault(struct kvm_vcpu *vcpu, struct x86_exception *fault)\n{\n\t++vcpu->stat.pf_guest;\n\tvcpu->arch.cr2 = fault->address;\n\tkvm_queue_exception_e(vcpu, PF_VECTOR, fault->error_code);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nvoid kvm_inject_page_fault(struct kvm_vcpu *vcpu, struct x86_exception *fault)\n{\n\t++vcpu->stat.pf_guest;\n\tvcpu->arch.cr2 = fault->address;\n\tkvm_queue_exception_e(vcpu, PF_VECTOR, fault->error_code);\n}"
        }
      },
      {
        "call_info": {
          "callee": "apf_put_user",
          "args": [
            "vcpu",
            "KVM_PV_REASON_PAGE_NOT_PRESENT"
          ],
          "line": 8288
        },
        "resolved": true,
        "details": {
          "function_name": "apf_put_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "8269-8274",
          "snippet": "static int apf_put_user(struct kvm_vcpu *vcpu, u32 val)\n{\n\n\treturn kvm_write_guest_cached(vcpu->kvm, &vcpu->arch.apf.data, &val,\n\t\t\t\t      sizeof(val));\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic int apf_put_user(struct kvm_vcpu *vcpu, u32 val)\n{\n\n\treturn kvm_write_guest_cached(vcpu->kvm, &vcpu->arch.apf.data, &val,\n\t\t\t\t      sizeof(val));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_make_request",
          "args": [
            "KVM_REQ_APF_HALT",
            "vcpu"
          ],
          "line": 8287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_x86_ops->get_cpl",
          "args": [
            "vcpu"
          ],
          "line": 8286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_add_async_pf_gfn",
          "args": [
            "vcpu",
            "work->arch.gfn"
          ],
          "line": 8282
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_add_async_pf_gfn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "8218-8226",
          "snippet": "static void kvm_add_async_pf_gfn(struct kvm_vcpu *vcpu, gfn_t gfn)\n{\n\tu32 key = kvm_async_pf_hash_fn(gfn);\n\n\twhile (vcpu->arch.apf.gfns[key] != ~0)\n\t\tkey = kvm_async_pf_next_probe(key);\n\n\tvcpu->arch.apf.gfns[key] = gfn;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic void kvm_add_async_pf_gfn(struct kvm_vcpu *vcpu, gfn_t gfn)\n{\n\tu32 key = kvm_async_pf_hash_fn(gfn);\n\n\twhile (vcpu->arch.apf.gfns[key] != ~0)\n\t\tkey = kvm_async_pf_next_probe(key);\n\n\tvcpu->arch.apf.gfns[key] = gfn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_kvm_async_pf_not_present",
          "args": [
            "work->arch.token",
            "work->gva"
          ],
          "line": 8281
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nvoid kvm_arch_async_page_not_present(struct kvm_vcpu *vcpu,\n\t\t\t\t     struct kvm_async_pf *work)\n{\n\tstruct x86_exception fault;\n\n\ttrace_kvm_async_pf_not_present(work->arch.token, work->gva);\n\tkvm_add_async_pf_gfn(vcpu, work->arch.gfn);\n\n\tif (!(vcpu->arch.apf.msr_val & KVM_ASYNC_PF_ENABLED) ||\n\t    (vcpu->arch.apf.send_user_only &&\n\t     kvm_x86_ops->get_cpl(vcpu) == 0))\n\t\tkvm_make_request(KVM_REQ_APF_HALT, vcpu);\n\telse if (!apf_put_user(vcpu, KVM_PV_REASON_PAGE_NOT_PRESENT)) {\n\t\tfault.vector = PF_VECTOR;\n\t\tfault.error_code_valid = true;\n\t\tfault.error_code = 0;\n\t\tfault.nested_page_fault = false;\n\t\tfault.address = work->arch.token;\n\t\tkvm_inject_page_fault(vcpu, &fault);\n\t}\n}"
  },
  {
    "function_name": "apf_put_user",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "8269-8274",
    "snippet": "static int apf_put_user(struct kvm_vcpu *vcpu, u32 val)\n{\n\n\treturn kvm_write_guest_cached(vcpu->kvm, &vcpu->arch.apf.data, &val,\n\t\t\t\t      sizeof(val));\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_write_guest_cached",
          "args": [
            "vcpu->kvm",
            "&vcpu->arch.apf.data",
            "&val",
            "sizeof(val)"
          ],
          "line": 8272
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic int apf_put_user(struct kvm_vcpu *vcpu, u32 val)\n{\n\n\treturn kvm_write_guest_cached(vcpu->kvm, &vcpu->arch.apf.data, &val,\n\t\t\t\t      sizeof(val));\n}"
  },
  {
    "function_name": "kvm_del_async_pf_gfn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "8246-8267",
    "snippet": "static void kvm_del_async_pf_gfn(struct kvm_vcpu *vcpu, gfn_t gfn)\n{\n\tu32 i, j, k;\n\n\ti = j = kvm_async_pf_gfn_slot(vcpu, gfn);\n\twhile (true) {\n\t\tvcpu->arch.apf.gfns[i] = ~0;\n\t\tdo {\n\t\t\tj = kvm_async_pf_next_probe(j);\n\t\t\tif (vcpu->arch.apf.gfns[j] == ~0)\n\t\t\t\treturn;\n\t\t\tk = kvm_async_pf_hash_fn(vcpu->arch.apf.gfns[j]);\n\t\t\t/*\n\t\t\t * k lies cyclically in ]i,j]\n\t\t\t * |    i.k.j |\n\t\t\t * |....j i.k.| or  |.k..j i...|\n\t\t\t */\n\t\t} while ((i <= j) ? (i < k && k <= j) : (i < k || k <= j));\n\t\tvcpu->arch.apf.gfns[i] = vcpu->arch.apf.gfns[j];\n\t\ti = j;\n\t}\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_async_pf_hash_fn",
          "args": [
            "vcpu->arch.apf.gfns[j]"
          ],
          "line": 8257
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_async_pf_hash_fn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "8208-8211",
          "snippet": "static inline u32 kvm_async_pf_hash_fn(gfn_t gfn)\n{\n\treturn hash_32(gfn & 0xffffffff, order_base_2(ASYNC_PF_PER_VCPU));\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic inline u32 kvm_async_pf_hash_fn(gfn_t gfn)\n{\n\treturn hash_32(gfn & 0xffffffff, order_base_2(ASYNC_PF_PER_VCPU));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_async_pf_next_probe",
          "args": [
            "j"
          ],
          "line": 8254
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_async_pf_next_probe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "8213-8216",
          "snippet": "static inline u32 kvm_async_pf_next_probe(u32 key)\n{\n\treturn (key + 1) & (roundup_pow_of_two(ASYNC_PF_PER_VCPU) - 1);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic inline u32 kvm_async_pf_next_probe(u32 key)\n{\n\treturn (key + 1) & (roundup_pow_of_two(ASYNC_PF_PER_VCPU) - 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_async_pf_gfn_slot",
          "args": [
            "vcpu",
            "gfn"
          ],
          "line": 8250
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_async_pf_gfn_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "8228-8239",
          "snippet": "static u32 kvm_async_pf_gfn_slot(struct kvm_vcpu *vcpu, gfn_t gfn)\n{\n\tint i;\n\tu32 key = kvm_async_pf_hash_fn(gfn);\n\n\tfor (i = 0; i < roundup_pow_of_two(ASYNC_PF_PER_VCPU) &&\n\t\t     (vcpu->arch.apf.gfns[key] != gfn &&\n\t\t      vcpu->arch.apf.gfns[key] != ~0); i++)\n\t\tkey = kvm_async_pf_next_probe(key);\n\n\treturn key;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic u32 kvm_async_pf_gfn_slot(struct kvm_vcpu *vcpu, gfn_t gfn)\n{\n\tint i;\n\tu32 key = kvm_async_pf_hash_fn(gfn);\n\n\tfor (i = 0; i < roundup_pow_of_two(ASYNC_PF_PER_VCPU) &&\n\t\t     (vcpu->arch.apf.gfns[key] != gfn &&\n\t\t      vcpu->arch.apf.gfns[key] != ~0); i++)\n\t\tkey = kvm_async_pf_next_probe(key);\n\n\treturn key;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic void kvm_del_async_pf_gfn(struct kvm_vcpu *vcpu, gfn_t gfn)\n{\n\tu32 i, j, k;\n\n\ti = j = kvm_async_pf_gfn_slot(vcpu, gfn);\n\twhile (true) {\n\t\tvcpu->arch.apf.gfns[i] = ~0;\n\t\tdo {\n\t\t\tj = kvm_async_pf_next_probe(j);\n\t\t\tif (vcpu->arch.apf.gfns[j] == ~0)\n\t\t\t\treturn;\n\t\t\tk = kvm_async_pf_hash_fn(vcpu->arch.apf.gfns[j]);\n\t\t\t/*\n\t\t\t * k lies cyclically in ]i,j]\n\t\t\t * |    i.k.j |\n\t\t\t * |....j i.k.| or  |.k..j i...|\n\t\t\t */\n\t\t} while ((i <= j) ? (i < k && k <= j) : (i < k || k <= j));\n\t\tvcpu->arch.apf.gfns[i] = vcpu->arch.apf.gfns[j];\n\t\ti = j;\n\t}\n}"
  },
  {
    "function_name": "kvm_find_async_pf_gfn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "8241-8244",
    "snippet": "bool kvm_find_async_pf_gfn(struct kvm_vcpu *vcpu, gfn_t gfn)\n{\n\treturn vcpu->arch.apf.gfns[kvm_async_pf_gfn_slot(vcpu, gfn)] == gfn;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_async_pf_gfn_slot",
          "args": [
            "vcpu",
            "gfn"
          ],
          "line": 8243
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_async_pf_gfn_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "8228-8239",
          "snippet": "static u32 kvm_async_pf_gfn_slot(struct kvm_vcpu *vcpu, gfn_t gfn)\n{\n\tint i;\n\tu32 key = kvm_async_pf_hash_fn(gfn);\n\n\tfor (i = 0; i < roundup_pow_of_two(ASYNC_PF_PER_VCPU) &&\n\t\t     (vcpu->arch.apf.gfns[key] != gfn &&\n\t\t      vcpu->arch.apf.gfns[key] != ~0); i++)\n\t\tkey = kvm_async_pf_next_probe(key);\n\n\treturn key;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic u32 kvm_async_pf_gfn_slot(struct kvm_vcpu *vcpu, gfn_t gfn)\n{\n\tint i;\n\tu32 key = kvm_async_pf_hash_fn(gfn);\n\n\tfor (i = 0; i < roundup_pow_of_two(ASYNC_PF_PER_VCPU) &&\n\t\t     (vcpu->arch.apf.gfns[key] != gfn &&\n\t\t      vcpu->arch.apf.gfns[key] != ~0); i++)\n\t\tkey = kvm_async_pf_next_probe(key);\n\n\treturn key;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nbool kvm_find_async_pf_gfn(struct kvm_vcpu *vcpu, gfn_t gfn)\n{\n\treturn vcpu->arch.apf.gfns[kvm_async_pf_gfn_slot(vcpu, gfn)] == gfn;\n}"
  },
  {
    "function_name": "kvm_async_pf_gfn_slot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "8228-8239",
    "snippet": "static u32 kvm_async_pf_gfn_slot(struct kvm_vcpu *vcpu, gfn_t gfn)\n{\n\tint i;\n\tu32 key = kvm_async_pf_hash_fn(gfn);\n\n\tfor (i = 0; i < roundup_pow_of_two(ASYNC_PF_PER_VCPU) &&\n\t\t     (vcpu->arch.apf.gfns[key] != gfn &&\n\t\t      vcpu->arch.apf.gfns[key] != ~0); i++)\n\t\tkey = kvm_async_pf_next_probe(key);\n\n\treturn key;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_async_pf_next_probe",
          "args": [
            "key"
          ],
          "line": 8236
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_async_pf_next_probe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "8213-8216",
          "snippet": "static inline u32 kvm_async_pf_next_probe(u32 key)\n{\n\treturn (key + 1) & (roundup_pow_of_two(ASYNC_PF_PER_VCPU) - 1);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic inline u32 kvm_async_pf_next_probe(u32 key)\n{\n\treturn (key + 1) & (roundup_pow_of_two(ASYNC_PF_PER_VCPU) - 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "roundup_pow_of_two",
          "args": [
            "ASYNC_PF_PER_VCPU"
          ],
          "line": 8233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_async_pf_hash_fn",
          "args": [
            "gfn"
          ],
          "line": 8231
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_async_pf_hash_fn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "8208-8211",
          "snippet": "static inline u32 kvm_async_pf_hash_fn(gfn_t gfn)\n{\n\treturn hash_32(gfn & 0xffffffff, order_base_2(ASYNC_PF_PER_VCPU));\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic inline u32 kvm_async_pf_hash_fn(gfn_t gfn)\n{\n\treturn hash_32(gfn & 0xffffffff, order_base_2(ASYNC_PF_PER_VCPU));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic u32 kvm_async_pf_gfn_slot(struct kvm_vcpu *vcpu, gfn_t gfn)\n{\n\tint i;\n\tu32 key = kvm_async_pf_hash_fn(gfn);\n\n\tfor (i = 0; i < roundup_pow_of_two(ASYNC_PF_PER_VCPU) &&\n\t\t     (vcpu->arch.apf.gfns[key] != gfn &&\n\t\t      vcpu->arch.apf.gfns[key] != ~0); i++)\n\t\tkey = kvm_async_pf_next_probe(key);\n\n\treturn key;\n}"
  },
  {
    "function_name": "kvm_add_async_pf_gfn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "8218-8226",
    "snippet": "static void kvm_add_async_pf_gfn(struct kvm_vcpu *vcpu, gfn_t gfn)\n{\n\tu32 key = kvm_async_pf_hash_fn(gfn);\n\n\twhile (vcpu->arch.apf.gfns[key] != ~0)\n\t\tkey = kvm_async_pf_next_probe(key);\n\n\tvcpu->arch.apf.gfns[key] = gfn;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_async_pf_next_probe",
          "args": [
            "key"
          ],
          "line": 8223
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_async_pf_next_probe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "8213-8216",
          "snippet": "static inline u32 kvm_async_pf_next_probe(u32 key)\n{\n\treturn (key + 1) & (roundup_pow_of_two(ASYNC_PF_PER_VCPU) - 1);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic inline u32 kvm_async_pf_next_probe(u32 key)\n{\n\treturn (key + 1) & (roundup_pow_of_two(ASYNC_PF_PER_VCPU) - 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_async_pf_hash_fn",
          "args": [
            "gfn"
          ],
          "line": 8220
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_async_pf_hash_fn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "8208-8211",
          "snippet": "static inline u32 kvm_async_pf_hash_fn(gfn_t gfn)\n{\n\treturn hash_32(gfn & 0xffffffff, order_base_2(ASYNC_PF_PER_VCPU));\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic inline u32 kvm_async_pf_hash_fn(gfn_t gfn)\n{\n\treturn hash_32(gfn & 0xffffffff, order_base_2(ASYNC_PF_PER_VCPU));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic void kvm_add_async_pf_gfn(struct kvm_vcpu *vcpu, gfn_t gfn)\n{\n\tu32 key = kvm_async_pf_hash_fn(gfn);\n\n\twhile (vcpu->arch.apf.gfns[key] != ~0)\n\t\tkey = kvm_async_pf_next_probe(key);\n\n\tvcpu->arch.apf.gfns[key] = gfn;\n}"
  },
  {
    "function_name": "kvm_async_pf_next_probe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "8213-8216",
    "snippet": "static inline u32 kvm_async_pf_next_probe(u32 key)\n{\n\treturn (key + 1) & (roundup_pow_of_two(ASYNC_PF_PER_VCPU) - 1);\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "roundup_pow_of_two",
          "args": [
            "ASYNC_PF_PER_VCPU"
          ],
          "line": 8215
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic inline u32 kvm_async_pf_next_probe(u32 key)\n{\n\treturn (key + 1) & (roundup_pow_of_two(ASYNC_PF_PER_VCPU) - 1);\n}"
  },
  {
    "function_name": "kvm_async_pf_hash_fn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "8208-8211",
    "snippet": "static inline u32 kvm_async_pf_hash_fn(gfn_t gfn)\n{\n\treturn hash_32(gfn & 0xffffffff, order_base_2(ASYNC_PF_PER_VCPU));\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hash_32",
          "args": [
            "gfn & 0xffffffff",
            "order_base_2(ASYNC_PF_PER_VCPU)"
          ],
          "line": 8210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "order_base_2",
          "args": [
            "ASYNC_PF_PER_VCPU"
          ],
          "line": 8210
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic inline u32 kvm_async_pf_hash_fn(gfn_t gfn)\n{\n\treturn hash_32(gfn & 0xffffffff, order_base_2(ASYNC_PF_PER_VCPU));\n}"
  },
  {
    "function_name": "kvm_arch_async_page_ready",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "8189-8206",
    "snippet": "void kvm_arch_async_page_ready(struct kvm_vcpu *vcpu, struct kvm_async_pf *work)\n{\n\tint r;\n\n\tif ((vcpu->arch.mmu.direct_map != work->arch.direct_map) ||\n\t      work->wakeup_all)\n\t\treturn;\n\n\tr = kvm_mmu_reload(vcpu);\n\tif (unlikely(r))\n\t\treturn;\n\n\tif (!vcpu->arch.mmu.direct_map &&\n\t      work->arch.cr3 != vcpu->arch.mmu.get_cr3(vcpu))\n\t\treturn;\n\n\tvcpu->arch.mmu.page_fault(vcpu, work->gva, 0, true);\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vcpu->arch.mmu.page_fault",
          "args": [
            "vcpu",
            "work->gva",
            "0",
            "true"
          ],
          "line": 8205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vcpu->arch.mmu.get_cr3",
          "args": [
            "vcpu"
          ],
          "line": 8202
        },
        "resolved": true,
        "details": {
          "function_name": "get_cr3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "3609-3612",
          "snippet": "static unsigned long get_cr3(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_read_cr3(vcpu);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic unsigned long get_cr3(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_read_cr3(vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "r"
          ],
          "line": 8198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_mmu_reload",
          "args": [
            "vcpu"
          ],
          "line": 8197
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_reload",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.h",
          "lines": "88-94",
          "snippet": "static inline int kvm_mmu_reload(struct kvm_vcpu *vcpu)\n{\n\tif (likely(vcpu->arch.mmu.root_hpa != INVALID_PAGE))\n\t\treturn 0;\n\n\treturn kvm_mmu_load(vcpu);\n}",
          "includes": [
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline int kvm_mmu_reload(struct kvm_vcpu *vcpu)\n{\n\tif (likely(vcpu->arch.mmu.root_hpa != INVALID_PAGE))\n\t\treturn 0;\n\n\treturn kvm_mmu_load(vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nvoid kvm_arch_async_page_ready(struct kvm_vcpu *vcpu, struct kvm_async_pf *work)\n{\n\tint r;\n\n\tif ((vcpu->arch.mmu.direct_map != work->arch.direct_map) ||\n\t      work->wakeup_all)\n\t\treturn;\n\n\tr = kvm_mmu_reload(vcpu);\n\tif (unlikely(r))\n\t\treturn;\n\n\tif (!vcpu->arch.mmu.direct_map &&\n\t      work->arch.cr3 != vcpu->arch.mmu.get_cr3(vcpu))\n\t\treturn;\n\n\tvcpu->arch.mmu.page_fault(vcpu, work->gva, 0, true);\n}"
  },
  {
    "function_name": "kvm_set_rflags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "8182-8186",
    "snippet": "void kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags)\n{\n\t__kvm_set_rflags(vcpu, rflags);\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);",
      "static void __kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_make_request",
          "args": [
            "KVM_REQ_EVENT",
            "vcpu"
          ],
          "line": 8185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__kvm_set_rflags",
          "args": [
            "vcpu",
            "rflags"
          ],
          "line": 8184
        },
        "resolved": true,
        "details": {
          "function_name": "__kvm_set_rflags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "8174-8180",
          "snippet": "static void __kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags)\n{\n\tif (vcpu->guest_debug & KVM_GUESTDBG_SINGLESTEP &&\n\t    kvm_is_linear_rip(vcpu, vcpu->arch.singlestep_rip))\n\t\trflags |= X86_EFLAGS_TF;\n\tkvm_x86_ops->set_rflags(vcpu, rflags);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void __kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags);",
            "struct kvm_x86_ops *kvm_x86_ops"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void __kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nstatic void __kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags)\n{\n\tif (vcpu->guest_debug & KVM_GUESTDBG_SINGLESTEP &&\n\t    kvm_is_linear_rip(vcpu, vcpu->arch.singlestep_rip))\n\t\trflags |= X86_EFLAGS_TF;\n\tkvm_x86_ops->set_rflags(vcpu, rflags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void __kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags);\n\nvoid kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags)\n{\n\t__kvm_set_rflags(vcpu, rflags);\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n}"
  },
  {
    "function_name": "__kvm_set_rflags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "8174-8180",
    "snippet": "static void __kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags)\n{\n\tif (vcpu->guest_debug & KVM_GUESTDBG_SINGLESTEP &&\n\t    kvm_is_linear_rip(vcpu, vcpu->arch.singlestep_rip))\n\t\trflags |= X86_EFLAGS_TF;\n\tkvm_x86_ops->set_rflags(vcpu, rflags);\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);",
      "static void __kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags);",
      "struct kvm_x86_ops *kvm_x86_ops"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_x86_ops->set_rflags",
          "args": [
            "vcpu",
            "rflags"
          ],
          "line": 8179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_is_linear_rip",
          "args": [
            "vcpu",
            "vcpu->arch.singlestep_rip"
          ],
          "line": 8177
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_is_linear_rip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "8157-8160",
          "snippet": "bool kvm_is_linear_rip(struct kvm_vcpu *vcpu, unsigned long linear_rip)\n{\n\treturn kvm_get_linear_rip(vcpu) == linear_rip;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nbool kvm_is_linear_rip(struct kvm_vcpu *vcpu, unsigned long linear_rip)\n{\n\treturn kvm_get_linear_rip(vcpu) == linear_rip;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void __kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nstatic void __kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags)\n{\n\tif (vcpu->guest_debug & KVM_GUESTDBG_SINGLESTEP &&\n\t    kvm_is_linear_rip(vcpu, vcpu->arch.singlestep_rip))\n\t\trflags |= X86_EFLAGS_TF;\n\tkvm_x86_ops->set_rflags(vcpu, rflags);\n}"
  },
  {
    "function_name": "kvm_get_rflags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "8163-8171",
    "snippet": "unsigned long kvm_get_rflags(struct kvm_vcpu *vcpu)\n{\n\tunsigned long rflags;\n\n\trflags = kvm_x86_ops->get_rflags(vcpu);\n\tif (vcpu->guest_debug & KVM_GUESTDBG_SINGLESTEP)\n\t\trflags &= ~X86_EFLAGS_TF;\n\treturn rflags;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);",
      "static void __kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags);",
      "struct kvm_x86_ops *kvm_x86_ops"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_x86_ops->get_rflags",
          "args": [
            "vcpu"
          ],
          "line": 8167
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void __kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nunsigned long kvm_get_rflags(struct kvm_vcpu *vcpu)\n{\n\tunsigned long rflags;\n\n\trflags = kvm_x86_ops->get_rflags(vcpu);\n\tif (vcpu->guest_debug & KVM_GUESTDBG_SINGLESTEP)\n\t\trflags &= ~X86_EFLAGS_TF;\n\treturn rflags;\n}"
  },
  {
    "function_name": "kvm_is_linear_rip",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "8157-8160",
    "snippet": "bool kvm_is_linear_rip(struct kvm_vcpu *vcpu, unsigned long linear_rip)\n{\n\treturn kvm_get_linear_rip(vcpu) == linear_rip;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_get_linear_rip",
          "args": [
            "vcpu"
          ],
          "line": 8159
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_get_linear_rip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "8148-8154",
          "snippet": "unsigned long kvm_get_linear_rip(struct kvm_vcpu *vcpu)\n{\n\tif (is_64_bit_mode(vcpu))\n\t\treturn kvm_rip_read(vcpu);\n\treturn (u32)(get_segment_base(vcpu, VCPU_SREG_CS) +\n\t\t     kvm_rip_read(vcpu));\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nunsigned long kvm_get_linear_rip(struct kvm_vcpu *vcpu)\n{\n\tif (is_64_bit_mode(vcpu))\n\t\treturn kvm_rip_read(vcpu);\n\treturn (u32)(get_segment_base(vcpu, VCPU_SREG_CS) +\n\t\t     kvm_rip_read(vcpu));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nbool kvm_is_linear_rip(struct kvm_vcpu *vcpu, unsigned long linear_rip)\n{\n\treturn kvm_get_linear_rip(vcpu) == linear_rip;\n}"
  },
  {
    "function_name": "kvm_get_linear_rip",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "8148-8154",
    "snippet": "unsigned long kvm_get_linear_rip(struct kvm_vcpu *vcpu)\n{\n\tif (is_64_bit_mode(vcpu))\n\t\treturn kvm_rip_read(vcpu);\n\treturn (u32)(get_segment_base(vcpu, VCPU_SREG_CS) +\n\t\t     kvm_rip_read(vcpu));\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "get_segment_base(vcpu, VCPU_SREG_CS) +\n\t\t     kvm_rip_read(vcpu)"
          ],
          "line": 8152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_rip_read",
          "args": [
            "vcpu"
          ],
          "line": 8153
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_rip_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "27-30",
          "snippet": "static inline unsigned long kvm_rip_read(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_register_read(vcpu, VCPU_REGS_RIP);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline unsigned long kvm_rip_read(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_register_read(vcpu, VCPU_REGS_RIP);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_segment_base",
          "args": [
            "vcpu",
            "VCPU_SREG_CS"
          ],
          "line": 8152
        },
        "resolved": true,
        "details": {
          "function_name": "get_segment_base",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "4714-4717",
          "snippet": "static unsigned long get_segment_base(struct kvm_vcpu *vcpu, int seg)\n{\n\treturn kvm_x86_ops->get_segment_base(vcpu, seg);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "struct kvm_x86_ops *kvm_x86_ops"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nstatic unsigned long get_segment_base(struct kvm_vcpu *vcpu, int seg)\n{\n\treturn kvm_x86_ops->get_segment_base(vcpu, seg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_64_bit_mode",
          "args": [
            "vcpu"
          ],
          "line": 8150
        },
        "resolved": true,
        "details": {
          "function_name": "is_64_bit_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.h",
          "lines": "52-60",
          "snippet": "static inline bool is_64_bit_mode(struct kvm_vcpu *vcpu)\n{\n\tint cs_db, cs_l;\n\n\tif (!is_long_mode(vcpu))\n\t\treturn false;\n\tkvm_x86_ops->get_cs_db_l_bits(vcpu, &cs_db, &cs_l);\n\treturn cs_l;\n}",
          "includes": [
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline bool is_64_bit_mode(struct kvm_vcpu *vcpu)\n{\n\tint cs_db, cs_l;\n\n\tif (!is_long_mode(vcpu))\n\t\treturn false;\n\tkvm_x86_ops->get_cs_db_l_bits(vcpu, &cs_db, &cs_l);\n\treturn cs_l;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nunsigned long kvm_get_linear_rip(struct kvm_vcpu *vcpu)\n{\n\tif (is_64_bit_mode(vcpu))\n\t\treturn kvm_rip_read(vcpu);\n\treturn (u32)(get_segment_base(vcpu, VCPU_SREG_CS) +\n\t\t     kvm_rip_read(vcpu));\n}"
  },
  {
    "function_name": "kvm_arch_interrupt_allowed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "8143-8146",
    "snippet": "int kvm_arch_interrupt_allowed(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_x86_ops->interrupt_allowed(vcpu);\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);",
      "struct kvm_x86_ops *kvm_x86_ops"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_x86_ops->interrupt_allowed",
          "args": [
            "vcpu"
          ],
          "line": 8145
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nint kvm_arch_interrupt_allowed(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_x86_ops->interrupt_allowed(vcpu);\n}"
  },
  {
    "function_name": "kvm_arch_vcpu_should_kick",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "8138-8141",
    "snippet": "int kvm_arch_vcpu_should_kick(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_vcpu_exiting_guest_mode(vcpu) == IN_GUEST_MODE;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_vcpu_exiting_guest_mode",
          "args": [
            "vcpu"
          ],
          "line": 8140
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nint kvm_arch_vcpu_should_kick(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_vcpu_exiting_guest_mode(vcpu) == IN_GUEST_MODE;\n}"
  },
  {
    "function_name": "kvm_arch_vcpu_runnable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "8130-8136",
    "snippet": "int kvm_arch_vcpu_runnable(struct kvm_vcpu *vcpu)\n{\n\tif (is_guest_mode(vcpu) && kvm_x86_ops->check_nested_events)\n\t\tkvm_x86_ops->check_nested_events(vcpu, false);\n\n\treturn kvm_vcpu_running(vcpu) || kvm_vcpu_has_events(vcpu);\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);",
      "struct kvm_x86_ops *kvm_x86_ops"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_vcpu_has_events",
          "args": [
            "vcpu"
          ],
          "line": 8135
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_vcpu_has_events",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "8103-8128",
          "snippet": "static inline bool kvm_vcpu_has_events(struct kvm_vcpu *vcpu)\n{\n\tif (!list_empty_careful(&vcpu->async_pf.done))\n\t\treturn true;\n\n\tif (kvm_apic_has_events(vcpu))\n\t\treturn true;\n\n\tif (vcpu->arch.pv.pv_unhalted)\n\t\treturn true;\n\n\tif (atomic_read(&vcpu->arch.nmi_queued))\n\t\treturn true;\n\n\tif (test_bit(KVM_REQ_SMI, &vcpu->requests))\n\t\treturn true;\n\n\tif (kvm_arch_interrupt_allowed(vcpu) &&\n\t    kvm_cpu_has_interrupt(vcpu))\n\t\treturn true;\n\n\tif (kvm_hv_has_stimer_pending(vcpu))\n\t\treturn true;\n\n\treturn false;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic inline bool kvm_vcpu_has_events(struct kvm_vcpu *vcpu)\n{\n\tif (!list_empty_careful(&vcpu->async_pf.done))\n\t\treturn true;\n\n\tif (kvm_apic_has_events(vcpu))\n\t\treturn true;\n\n\tif (vcpu->arch.pv.pv_unhalted)\n\t\treturn true;\n\n\tif (atomic_read(&vcpu->arch.nmi_queued))\n\t\treturn true;\n\n\tif (test_bit(KVM_REQ_SMI, &vcpu->requests))\n\t\treturn true;\n\n\tif (kvm_arch_interrupt_allowed(vcpu) &&\n\t    kvm_cpu_has_interrupt(vcpu))\n\t\treturn true;\n\n\tif (kvm_hv_has_stimer_pending(vcpu))\n\t\treturn true;\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_running",
          "args": [
            "vcpu"
          ],
          "line": 8135
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_vcpu_running",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "6752-6756",
          "snippet": "static inline bool kvm_vcpu_running(struct kvm_vcpu *vcpu)\n{\n\treturn (vcpu->arch.mp_state == KVM_MP_STATE_RUNNABLE &&\n\t\t!vcpu->arch.apf.halted);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic inline bool kvm_vcpu_running(struct kvm_vcpu *vcpu)\n{\n\treturn (vcpu->arch.mp_state == KVM_MP_STATE_RUNNABLE &&\n\t\t!vcpu->arch.apf.halted);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_x86_ops->check_nested_events",
          "args": [
            "vcpu",
            "false"
          ],
          "line": 8133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_guest_mode",
          "args": [
            "vcpu"
          ],
          "line": 8132
        },
        "resolved": true,
        "details": {
          "function_name": "is_guest_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "102-105",
          "snippet": "static inline bool is_guest_mode(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.hflags & HF_GUEST_MASK;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline bool is_guest_mode(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.hflags & HF_GUEST_MASK;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nint kvm_arch_vcpu_runnable(struct kvm_vcpu *vcpu)\n{\n\tif (is_guest_mode(vcpu) && kvm_x86_ops->check_nested_events)\n\t\tkvm_x86_ops->check_nested_events(vcpu, false);\n\n\treturn kvm_vcpu_running(vcpu) || kvm_vcpu_has_events(vcpu);\n}"
  },
  {
    "function_name": "kvm_vcpu_has_events",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "8103-8128",
    "snippet": "static inline bool kvm_vcpu_has_events(struct kvm_vcpu *vcpu)\n{\n\tif (!list_empty_careful(&vcpu->async_pf.done))\n\t\treturn true;\n\n\tif (kvm_apic_has_events(vcpu))\n\t\treturn true;\n\n\tif (vcpu->arch.pv.pv_unhalted)\n\t\treturn true;\n\n\tif (atomic_read(&vcpu->arch.nmi_queued))\n\t\treturn true;\n\n\tif (test_bit(KVM_REQ_SMI, &vcpu->requests))\n\t\treturn true;\n\n\tif (kvm_arch_interrupt_allowed(vcpu) &&\n\t    kvm_cpu_has_interrupt(vcpu))\n\t\treturn true;\n\n\tif (kvm_hv_has_stimer_pending(vcpu))\n\t\treturn true;\n\n\treturn false;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_hv_has_stimer_pending",
          "args": [
            "vcpu"
          ],
          "line": 8124
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_hv_has_stimer_pending",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.h",
          "lines": "79-83",
          "snippet": "static inline bool kvm_hv_has_stimer_pending(struct kvm_vcpu *vcpu)\n{\n\treturn !bitmap_empty(vcpu->arch.hyperv.stimer_pending_bitmap,\n\t\t\t     HV_SYNIC_STIMER_COUNT);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline bool kvm_hv_has_stimer_pending(struct kvm_vcpu *vcpu)\n{\n\treturn !bitmap_empty(vcpu->arch.hyperv.stimer_pending_bitmap,\n\t\t\t     HV_SYNIC_STIMER_COUNT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_cpu_has_interrupt",
          "args": [
            "vcpu"
          ],
          "line": 8121
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_cpu_has_interrupt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/irq.c",
          "lines": "92-101",
          "snippet": "int kvm_cpu_has_interrupt(struct kvm_vcpu *v)\n{\n\tif (!lapic_in_kernel(v))\n\t\treturn v->arch.interrupt.pending;\n\n\tif (kvm_cpu_has_extint(v))\n\t\treturn 1;\n\n\treturn kvm_apic_has_interrupt(v) != -1;\t/* LAPIC */\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"i8254.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"i8254.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n#include <linux/module.h>\n\nint kvm_cpu_has_interrupt(struct kvm_vcpu *v)\n{\n\tif (!lapic_in_kernel(v))\n\t\treturn v->arch.interrupt.pending;\n\n\tif (kvm_cpu_has_extint(v))\n\t\treturn 1;\n\n\treturn kvm_apic_has_interrupt(v) != -1;\t/* LAPIC */\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_arch_interrupt_allowed",
          "args": [
            "vcpu"
          ],
          "line": 8120
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_arch_interrupt_allowed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "8143-8146",
          "snippet": "int kvm_arch_interrupt_allowed(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_x86_ops->interrupt_allowed(vcpu);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "struct kvm_x86_ops *kvm_x86_ops"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nint kvm_arch_interrupt_allowed(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_x86_ops->interrupt_allowed(vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "KVM_REQ_SMI",
            "&vcpu->requests"
          ],
          "line": 8117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&vcpu->arch.nmi_queued"
          ],
          "line": 8114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_apic_has_events",
          "args": [
            "vcpu"
          ],
          "line": 8108
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_has_events",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.h",
          "lines": "186-189",
          "snippet": "static inline bool kvm_apic_has_events(struct kvm_vcpu *vcpu)\n{\n\treturn lapic_in_kernel(vcpu) && vcpu->arch.apic->pending_events;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline bool kvm_apic_has_events(struct kvm_vcpu *vcpu)\n{\n\treturn lapic_in_kernel(vcpu) && vcpu->arch.apic->pending_events;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty_careful",
          "args": [
            "&vcpu->async_pf.done"
          ],
          "line": 8105
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic inline bool kvm_vcpu_has_events(struct kvm_vcpu *vcpu)\n{\n\tif (!list_empty_careful(&vcpu->async_pf.done))\n\t\treturn true;\n\n\tif (kvm_apic_has_events(vcpu))\n\t\treturn true;\n\n\tif (vcpu->arch.pv.pv_unhalted)\n\t\treturn true;\n\n\tif (atomic_read(&vcpu->arch.nmi_queued))\n\t\treturn true;\n\n\tif (test_bit(KVM_REQ_SMI, &vcpu->requests))\n\t\treturn true;\n\n\tif (kvm_arch_interrupt_allowed(vcpu) &&\n\t    kvm_cpu_has_interrupt(vcpu))\n\t\treturn true;\n\n\tif (kvm_hv_has_stimer_pending(vcpu))\n\t\treturn true;\n\n\treturn false;\n}"
  },
  {
    "function_name": "kvm_arch_flush_shadow_memslot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "8097-8101",
    "snippet": "void kvm_arch_flush_shadow_memslot(struct kvm *kvm,\n\t\t\t\t   struct kvm_memory_slot *slot)\n{\n\tkvm_mmu_invalidate_zap_all_pages(kvm);\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_mmu_invalidate_zap_all_pages",
          "args": [
            "kvm"
          ],
          "line": 8100
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_invalidate_zap_all_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "4921-4940",
          "snippet": "void kvm_mmu_invalidate_zap_all_pages(struct kvm *kvm)\n{\n\tspin_lock(&kvm->mmu_lock);\n\ttrace_kvm_mmu_invalidate_zap_all_pages(kvm);\n\tkvm->arch.mmu_valid_gen++;\n\n\t/*\n\t * Notify all vcpus to reload its shadow page table\n\t * and flush TLB. Then all vcpus will switch to new\n\t * shadow page table with the new mmu_valid_gen.\n\t *\n\t * Note: we should do this under the protection of\n\t * mmu-lock, otherwise, vcpu would purge shadow page\n\t * but miss tlb flush.\n\t */\n\tkvm_reload_remote_mmus(kvm);\n\n\tkvm_zap_obsolete_pages(kvm);\n\tspin_unlock(&kvm->mmu_lock);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nvoid kvm_mmu_invalidate_zap_all_pages(struct kvm *kvm)\n{\n\tspin_lock(&kvm->mmu_lock);\n\ttrace_kvm_mmu_invalidate_zap_all_pages(kvm);\n\tkvm->arch.mmu_valid_gen++;\n\n\t/*\n\t * Notify all vcpus to reload its shadow page table\n\t * and flush TLB. Then all vcpus will switch to new\n\t * shadow page table with the new mmu_valid_gen.\n\t *\n\t * Note: we should do this under the protection of\n\t * mmu-lock, otherwise, vcpu would purge shadow page\n\t * but miss tlb flush.\n\t */\n\tkvm_reload_remote_mmus(kvm);\n\n\tkvm_zap_obsolete_pages(kvm);\n\tspin_unlock(&kvm->mmu_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nvoid kvm_arch_flush_shadow_memslot(struct kvm *kvm,\n\t\t\t\t   struct kvm_memory_slot *slot)\n{\n\tkvm_mmu_invalidate_zap_all_pages(kvm);\n}"
  },
  {
    "function_name": "kvm_arch_flush_shadow_all",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "8092-8095",
    "snippet": "void kvm_arch_flush_shadow_all(struct kvm *kvm)\n{\n\tkvm_mmu_invalidate_zap_all_pages(kvm);\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_mmu_invalidate_zap_all_pages",
          "args": [
            "kvm"
          ],
          "line": 8094
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_invalidate_zap_all_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "4921-4940",
          "snippet": "void kvm_mmu_invalidate_zap_all_pages(struct kvm *kvm)\n{\n\tspin_lock(&kvm->mmu_lock);\n\ttrace_kvm_mmu_invalidate_zap_all_pages(kvm);\n\tkvm->arch.mmu_valid_gen++;\n\n\t/*\n\t * Notify all vcpus to reload its shadow page table\n\t * and flush TLB. Then all vcpus will switch to new\n\t * shadow page table with the new mmu_valid_gen.\n\t *\n\t * Note: we should do this under the protection of\n\t * mmu-lock, otherwise, vcpu would purge shadow page\n\t * but miss tlb flush.\n\t */\n\tkvm_reload_remote_mmus(kvm);\n\n\tkvm_zap_obsolete_pages(kvm);\n\tspin_unlock(&kvm->mmu_lock);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nvoid kvm_mmu_invalidate_zap_all_pages(struct kvm *kvm)\n{\n\tspin_lock(&kvm->mmu_lock);\n\ttrace_kvm_mmu_invalidate_zap_all_pages(kvm);\n\tkvm->arch.mmu_valid_gen++;\n\n\t/*\n\t * Notify all vcpus to reload its shadow page table\n\t * and flush TLB. Then all vcpus will switch to new\n\t * shadow page table with the new mmu_valid_gen.\n\t *\n\t * Note: we should do this under the protection of\n\t * mmu-lock, otherwise, vcpu would purge shadow page\n\t * but miss tlb flush.\n\t */\n\tkvm_reload_remote_mmus(kvm);\n\n\tkvm_zap_obsolete_pages(kvm);\n\tspin_unlock(&kvm->mmu_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nvoid kvm_arch_flush_shadow_all(struct kvm *kvm)\n{\n\tkvm_mmu_invalidate_zap_all_pages(kvm);\n}"
  },
  {
    "function_name": "kvm_arch_commit_memory_region",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "8047-8090",
    "snippet": "void kvm_arch_commit_memory_region(struct kvm *kvm,\n\t\t\t\tconst struct kvm_userspace_memory_region *mem,\n\t\t\t\tconst struct kvm_memory_slot *old,\n\t\t\t\tconst struct kvm_memory_slot *new,\n\t\t\t\tenum kvm_mr_change change)\n{\n\tint nr_mmu_pages = 0;\n\n\tif (!kvm->arch.n_requested_mmu_pages)\n\t\tnr_mmu_pages = kvm_mmu_calculate_mmu_pages(kvm);\n\n\tif (nr_mmu_pages)\n\t\tkvm_mmu_change_mmu_pages(kvm, nr_mmu_pages);\n\n\t/*\n\t * Dirty logging tracks sptes in 4k granularity, meaning that large\n\t * sptes have to be split.  If live migration is successful, the guest\n\t * in the source machine will be destroyed and large sptes will be\n\t * created in the destination. However, if the guest continues to run\n\t * in the source machine (for example if live migration fails), small\n\t * sptes will remain around and cause bad performance.\n\t *\n\t * Scan sptes if dirty logging has been stopped, dropping those\n\t * which can be collapsed into a single large-page spte.  Later\n\t * page faults will create the large-page sptes.\n\t */\n\tif ((change != KVM_MR_DELETE) &&\n\t\t(old->flags & KVM_MEM_LOG_DIRTY_PAGES) &&\n\t\t!(new->flags & KVM_MEM_LOG_DIRTY_PAGES))\n\t\tkvm_mmu_zap_collapsible_sptes(kvm, new);\n\n\t/*\n\t * Set up write protection and/or dirty logging for the new slot.\n\t *\n\t * For KVM_MR_DELETE and KVM_MR_MOVE, the shadow pages of old slot have\n\t * been zapped so no dirty logging staff is needed for old slot. For\n\t * KVM_MR_FLAGS_ONLY, the old slot is essentially the same one as the\n\t * new and it's also covered when dealing with the new slot.\n\t *\n\t * FIXME: const-ify all uses of struct kvm_memory_slot.\n\t */\n\tif (change != KVM_MR_DELETE)\n\t\tkvm_mmu_slot_apply_flags(kvm, (struct kvm_memory_slot *) new);\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_mmu_slot_apply_flags",
          "args": [
            "kvm",
            "(struct kvm_memory_slot *) new"
          ],
          "line": 8089
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_slot_apply_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "7997-8045",
          "snippet": "static void kvm_mmu_slot_apply_flags(struct kvm *kvm,\n\t\t\t\t     struct kvm_memory_slot *new)\n{\n\t/* Still write protect RO slot */\n\tif (new->flags & KVM_MEM_READONLY) {\n\t\tkvm_mmu_slot_remove_write_access(kvm, new);\n\t\treturn;\n\t}\n\n\t/*\n\t * Call kvm_x86_ops dirty logging hooks when they are valid.\n\t *\n\t * kvm_x86_ops->slot_disable_log_dirty is called when:\n\t *\n\t *  - KVM_MR_CREATE with dirty logging is disabled\n\t *  - KVM_MR_FLAGS_ONLY with dirty logging is disabled in new flag\n\t *\n\t * The reason is, in case of PML, we need to set D-bit for any slots\n\t * with dirty logging disabled in order to eliminate unnecessary GPA\n\t * logging in PML buffer (and potential PML buffer full VMEXT). This\n\t * guarantees leaving PML enabled during guest's lifetime won't have\n\t * any additonal overhead from PML when guest is running with dirty\n\t * logging disabled for memory slots.\n\t *\n\t * kvm_x86_ops->slot_enable_log_dirty is called when switching new slot\n\t * to dirty logging mode.\n\t *\n\t * If kvm_x86_ops dirty logging hooks are invalid, use write protect.\n\t *\n\t * In case of write protect:\n\t *\n\t * Write protect all pages for dirty logging.\n\t *\n\t * All the sptes including the large sptes which point to this\n\t * slot are set to readonly. We can not create any new large\n\t * spte on this slot until the end of the logging.\n\t *\n\t * See the comments in fast_page_fault().\n\t */\n\tif (new->flags & KVM_MEM_LOG_DIRTY_PAGES) {\n\t\tif (kvm_x86_ops->slot_enable_log_dirty)\n\t\t\tkvm_x86_ops->slot_enable_log_dirty(kvm, new);\n\t\telse\n\t\t\tkvm_mmu_slot_remove_write_access(kvm, new);\n\t} else {\n\t\tif (kvm_x86_ops->slot_disable_log_dirty)\n\t\t\tkvm_x86_ops->slot_disable_log_dirty(kvm, new);\n\t}\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct kvm_x86_ops *kvm_x86_ops"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstruct kvm_x86_ops *kvm_x86_ops;\n\nstatic void kvm_mmu_slot_apply_flags(struct kvm *kvm,\n\t\t\t\t     struct kvm_memory_slot *new)\n{\n\t/* Still write protect RO slot */\n\tif (new->flags & KVM_MEM_READONLY) {\n\t\tkvm_mmu_slot_remove_write_access(kvm, new);\n\t\treturn;\n\t}\n\n\t/*\n\t * Call kvm_x86_ops dirty logging hooks when they are valid.\n\t *\n\t * kvm_x86_ops->slot_disable_log_dirty is called when:\n\t *\n\t *  - KVM_MR_CREATE with dirty logging is disabled\n\t *  - KVM_MR_FLAGS_ONLY with dirty logging is disabled in new flag\n\t *\n\t * The reason is, in case of PML, we need to set D-bit for any slots\n\t * with dirty logging disabled in order to eliminate unnecessary GPA\n\t * logging in PML buffer (and potential PML buffer full VMEXT). This\n\t * guarantees leaving PML enabled during guest's lifetime won't have\n\t * any additonal overhead from PML when guest is running with dirty\n\t * logging disabled for memory slots.\n\t *\n\t * kvm_x86_ops->slot_enable_log_dirty is called when switching new slot\n\t * to dirty logging mode.\n\t *\n\t * If kvm_x86_ops dirty logging hooks are invalid, use write protect.\n\t *\n\t * In case of write protect:\n\t *\n\t * Write protect all pages for dirty logging.\n\t *\n\t * All the sptes including the large sptes which point to this\n\t * slot are set to readonly. We can not create any new large\n\t * spte on this slot until the end of the logging.\n\t *\n\t * See the comments in fast_page_fault().\n\t */\n\tif (new->flags & KVM_MEM_LOG_DIRTY_PAGES) {\n\t\tif (kvm_x86_ops->slot_enable_log_dirty)\n\t\t\tkvm_x86_ops->slot_enable_log_dirty(kvm, new);\n\t\telse\n\t\t\tkvm_mmu_slot_remove_write_access(kvm, new);\n\t} else {\n\t\tif (kvm_x86_ops->slot_disable_log_dirty)\n\t\t\tkvm_x86_ops->slot_disable_log_dirty(kvm, new);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_mmu_zap_collapsible_sptes",
          "args": [
            "kvm",
            "new"
          ],
          "line": 8076
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_zap_collapsible_sptes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "4794-4802",
          "snippet": "void kvm_mmu_zap_collapsible_sptes(struct kvm *kvm,\n\t\t\t\t   const struct kvm_memory_slot *memslot)\n{\n\t/* FIXME: const-ify all uses of struct kvm_memory_slot.  */\n\tspin_lock(&kvm->mmu_lock);\n\tslot_handle_leaf(kvm, (struct kvm_memory_slot *)memslot,\n\t\t\t kvm_mmu_zap_collapsible_spte, true);\n\tspin_unlock(&kvm->mmu_lock);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nvoid kvm_mmu_zap_collapsible_sptes(struct kvm *kvm,\n\t\t\t\t   const struct kvm_memory_slot *memslot)\n{\n\t/* FIXME: const-ify all uses of struct kvm_memory_slot.  */\n\tspin_lock(&kvm->mmu_lock);\n\tslot_handle_leaf(kvm, (struct kvm_memory_slot *)memslot,\n\t\t\t kvm_mmu_zap_collapsible_spte, true);\n\tspin_unlock(&kvm->mmu_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_mmu_change_mmu_pages",
          "args": [
            "kvm",
            "nr_mmu_pages"
          ],
          "line": 8059
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_change_mmu_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "2431-2450",
          "snippet": "void kvm_mmu_change_mmu_pages(struct kvm *kvm, unsigned int goal_nr_mmu_pages)\n{\n\tLIST_HEAD(invalid_list);\n\n\tspin_lock(&kvm->mmu_lock);\n\n\tif (kvm->arch.n_used_mmu_pages > goal_nr_mmu_pages) {\n\t\t/* Need to free some mmu pages to achieve the goal. */\n\t\twhile (kvm->arch.n_used_mmu_pages > goal_nr_mmu_pages)\n\t\t\tif (!prepare_zap_oldest_mmu_page(kvm, &invalid_list))\n\t\t\t\tbreak;\n\n\t\tkvm_mmu_commit_zap_page(kvm, &invalid_list);\n\t\tgoal_nr_mmu_pages = kvm->arch.n_used_mmu_pages;\n\t}\n\n\tkvm->arch.n_max_mmu_pages = goal_nr_mmu_pages;\n\n\tspin_unlock(&kvm->mmu_lock);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t    struct list_head *invalid_list);",
            "static void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t    struct list_head *invalid_list);\nstatic void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);\n\nvoid kvm_mmu_change_mmu_pages(struct kvm *kvm, unsigned int goal_nr_mmu_pages)\n{\n\tLIST_HEAD(invalid_list);\n\n\tspin_lock(&kvm->mmu_lock);\n\n\tif (kvm->arch.n_used_mmu_pages > goal_nr_mmu_pages) {\n\t\t/* Need to free some mmu pages to achieve the goal. */\n\t\twhile (kvm->arch.n_used_mmu_pages > goal_nr_mmu_pages)\n\t\t\tif (!prepare_zap_oldest_mmu_page(kvm, &invalid_list))\n\t\t\t\tbreak;\n\n\t\tkvm_mmu_commit_zap_page(kvm, &invalid_list);\n\t\tgoal_nr_mmu_pages = kvm->arch.n_used_mmu_pages;\n\t}\n\n\tkvm->arch.n_max_mmu_pages = goal_nr_mmu_pages;\n\n\tspin_unlock(&kvm->mmu_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_mmu_calculate_mmu_pages",
          "args": [
            "kvm"
          ],
          "line": 8056
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_calculate_mmu_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "5069-5089",
          "snippet": "unsigned int kvm_mmu_calculate_mmu_pages(struct kvm *kvm)\n{\n\tunsigned int nr_mmu_pages;\n\tunsigned int  nr_pages = 0;\n\tstruct kvm_memslots *slots;\n\tstruct kvm_memory_slot *memslot;\n\tint i;\n\n\tfor (i = 0; i < KVM_ADDRESS_SPACE_NUM; i++) {\n\t\tslots = __kvm_memslots(kvm, i);\n\n\t\tkvm_for_each_memslot(memslot, slots)\n\t\t\tnr_pages += memslot->npages;\n\t}\n\n\tnr_mmu_pages = nr_pages * KVM_PERMILLE_MMU_PAGES / 1000;\n\tnr_mmu_pages = max(nr_mmu_pages,\n\t\t\t   (unsigned int) KVM_MIN_ALLOC_MMU_PAGES);\n\n\treturn nr_mmu_pages;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nunsigned int kvm_mmu_calculate_mmu_pages(struct kvm *kvm)\n{\n\tunsigned int nr_mmu_pages;\n\tunsigned int  nr_pages = 0;\n\tstruct kvm_memslots *slots;\n\tstruct kvm_memory_slot *memslot;\n\tint i;\n\n\tfor (i = 0; i < KVM_ADDRESS_SPACE_NUM; i++) {\n\t\tslots = __kvm_memslots(kvm, i);\n\n\t\tkvm_for_each_memslot(memslot, slots)\n\t\t\tnr_pages += memslot->npages;\n\t}\n\n\tnr_mmu_pages = nr_pages * KVM_PERMILLE_MMU_PAGES / 1000;\n\tnr_mmu_pages = max(nr_mmu_pages,\n\t\t\t   (unsigned int) KVM_MIN_ALLOC_MMU_PAGES);\n\n\treturn nr_mmu_pages;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nvoid kvm_arch_commit_memory_region(struct kvm *kvm,\n\t\t\t\tconst struct kvm_userspace_memory_region *mem,\n\t\t\t\tconst struct kvm_memory_slot *old,\n\t\t\t\tconst struct kvm_memory_slot *new,\n\t\t\t\tenum kvm_mr_change change)\n{\n\tint nr_mmu_pages = 0;\n\n\tif (!kvm->arch.n_requested_mmu_pages)\n\t\tnr_mmu_pages = kvm_mmu_calculate_mmu_pages(kvm);\n\n\tif (nr_mmu_pages)\n\t\tkvm_mmu_change_mmu_pages(kvm, nr_mmu_pages);\n\n\t/*\n\t * Dirty logging tracks sptes in 4k granularity, meaning that large\n\t * sptes have to be split.  If live migration is successful, the guest\n\t * in the source machine will be destroyed and large sptes will be\n\t * created in the destination. However, if the guest continues to run\n\t * in the source machine (for example if live migration fails), small\n\t * sptes will remain around and cause bad performance.\n\t *\n\t * Scan sptes if dirty logging has been stopped, dropping those\n\t * which can be collapsed into a single large-page spte.  Later\n\t * page faults will create the large-page sptes.\n\t */\n\tif ((change != KVM_MR_DELETE) &&\n\t\t(old->flags & KVM_MEM_LOG_DIRTY_PAGES) &&\n\t\t!(new->flags & KVM_MEM_LOG_DIRTY_PAGES))\n\t\tkvm_mmu_zap_collapsible_sptes(kvm, new);\n\n\t/*\n\t * Set up write protection and/or dirty logging for the new slot.\n\t *\n\t * For KVM_MR_DELETE and KVM_MR_MOVE, the shadow pages of old slot have\n\t * been zapped so no dirty logging staff is needed for old slot. For\n\t * KVM_MR_FLAGS_ONLY, the old slot is essentially the same one as the\n\t * new and it's also covered when dealing with the new slot.\n\t *\n\t * FIXME: const-ify all uses of struct kvm_memory_slot.\n\t */\n\tif (change != KVM_MR_DELETE)\n\t\tkvm_mmu_slot_apply_flags(kvm, (struct kvm_memory_slot *) new);\n}"
  },
  {
    "function_name": "kvm_mmu_slot_apply_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "7997-8045",
    "snippet": "static void kvm_mmu_slot_apply_flags(struct kvm *kvm,\n\t\t\t\t     struct kvm_memory_slot *new)\n{\n\t/* Still write protect RO slot */\n\tif (new->flags & KVM_MEM_READONLY) {\n\t\tkvm_mmu_slot_remove_write_access(kvm, new);\n\t\treturn;\n\t}\n\n\t/*\n\t * Call kvm_x86_ops dirty logging hooks when they are valid.\n\t *\n\t * kvm_x86_ops->slot_disable_log_dirty is called when:\n\t *\n\t *  - KVM_MR_CREATE with dirty logging is disabled\n\t *  - KVM_MR_FLAGS_ONLY with dirty logging is disabled in new flag\n\t *\n\t * The reason is, in case of PML, we need to set D-bit for any slots\n\t * with dirty logging disabled in order to eliminate unnecessary GPA\n\t * logging in PML buffer (and potential PML buffer full VMEXT). This\n\t * guarantees leaving PML enabled during guest's lifetime won't have\n\t * any additonal overhead from PML when guest is running with dirty\n\t * logging disabled for memory slots.\n\t *\n\t * kvm_x86_ops->slot_enable_log_dirty is called when switching new slot\n\t * to dirty logging mode.\n\t *\n\t * If kvm_x86_ops dirty logging hooks are invalid, use write protect.\n\t *\n\t * In case of write protect:\n\t *\n\t * Write protect all pages for dirty logging.\n\t *\n\t * All the sptes including the large sptes which point to this\n\t * slot are set to readonly. We can not create any new large\n\t * spte on this slot until the end of the logging.\n\t *\n\t * See the comments in fast_page_fault().\n\t */\n\tif (new->flags & KVM_MEM_LOG_DIRTY_PAGES) {\n\t\tif (kvm_x86_ops->slot_enable_log_dirty)\n\t\t\tkvm_x86_ops->slot_enable_log_dirty(kvm, new);\n\t\telse\n\t\t\tkvm_mmu_slot_remove_write_access(kvm, new);\n\t} else {\n\t\tif (kvm_x86_ops->slot_disable_log_dirty)\n\t\t\tkvm_x86_ops->slot_disable_log_dirty(kvm, new);\n\t}\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct kvm_x86_ops *kvm_x86_ops"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_x86_ops->slot_disable_log_dirty",
          "args": [
            "kvm",
            "new"
          ],
          "line": 8043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_mmu_slot_remove_write_access",
          "args": [
            "kvm",
            "new"
          ],
          "line": 8040
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_slot_remove_write_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "4729-4759",
          "snippet": "void kvm_mmu_slot_remove_write_access(struct kvm *kvm,\n\t\t\t\t      struct kvm_memory_slot *memslot)\n{\n\tbool flush;\n\n\tspin_lock(&kvm->mmu_lock);\n\tflush = slot_handle_all_level(kvm, memslot, slot_rmap_write_protect,\n\t\t\t\t      false);\n\tspin_unlock(&kvm->mmu_lock);\n\n\t/*\n\t * kvm_mmu_slot_remove_write_access() and kvm_vm_ioctl_get_dirty_log()\n\t * which do tlb flush out of mmu-lock should be serialized by\n\t * kvm->slots_lock otherwise tlb flush would be missed.\n\t */\n\tlockdep_assert_held(&kvm->slots_lock);\n\n\t/*\n\t * We can flush all the TLBs out of the mmu lock without TLB\n\t * corruption since we just change the spte from writable to\n\t * readonly so that we only need to care the case of changing\n\t * spte from present to present (changing the spte from present\n\t * to nonpresent will flush all the TLBs immediately), in other\n\t * words, the only case we care is mmu_spte_update() where we\n\t * haved checked SPTE_HOST_WRITEABLE | SPTE_MMU_WRITEABLE\n\t * instead of PT_WRITABLE_MASK, that means it does not depend\n\t * on PT_WRITABLE_MASK anymore.\n\t */\n\tif (flush)\n\t\tkvm_flush_remote_tlbs(kvm);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define SPTE_MMU_WRITEABLE\t(1ULL << (PT_FIRST_AVAIL_BITS_SHIFT + 1))",
            "#define SPTE_HOST_WRITEABLE\t(1ULL << PT_FIRST_AVAIL_BITS_SHIFT)"
          ],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static void mark_unsync(u64 *spte);",
            "static bool try_async_pf(struct kvm_vcpu *vcpu, bool prefault, gfn_t gfn,\n\t\t\t gva_t gva, kvm_pfn_t *pfn, bool write, bool *writable);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define SPTE_MMU_WRITEABLE\t(1ULL << (PT_FIRST_AVAIL_BITS_SHIFT + 1))\n#define SPTE_HOST_WRITEABLE\t(1ULL << PT_FIRST_AVAIL_BITS_SHIFT)\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic void mark_unsync(u64 *spte);\nstatic bool try_async_pf(struct kvm_vcpu *vcpu, bool prefault, gfn_t gfn,\n\t\t\t gva_t gva, kvm_pfn_t *pfn, bool write, bool *writable);\n\nvoid kvm_mmu_slot_remove_write_access(struct kvm *kvm,\n\t\t\t\t      struct kvm_memory_slot *memslot)\n{\n\tbool flush;\n\n\tspin_lock(&kvm->mmu_lock);\n\tflush = slot_handle_all_level(kvm, memslot, slot_rmap_write_protect,\n\t\t\t\t      false);\n\tspin_unlock(&kvm->mmu_lock);\n\n\t/*\n\t * kvm_mmu_slot_remove_write_access() and kvm_vm_ioctl_get_dirty_log()\n\t * which do tlb flush out of mmu-lock should be serialized by\n\t * kvm->slots_lock otherwise tlb flush would be missed.\n\t */\n\tlockdep_assert_held(&kvm->slots_lock);\n\n\t/*\n\t * We can flush all the TLBs out of the mmu lock without TLB\n\t * corruption since we just change the spte from writable to\n\t * readonly so that we only need to care the case of changing\n\t * spte from present to present (changing the spte from present\n\t * to nonpresent will flush all the TLBs immediately), in other\n\t * words, the only case we care is mmu_spte_update() where we\n\t * haved checked SPTE_HOST_WRITEABLE | SPTE_MMU_WRITEABLE\n\t * instead of PT_WRITABLE_MASK, that means it does not depend\n\t * on PT_WRITABLE_MASK anymore.\n\t */\n\tif (flush)\n\t\tkvm_flush_remote_tlbs(kvm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_x86_ops->slot_enable_log_dirty",
          "args": [
            "kvm",
            "new"
          ],
          "line": 8038
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstruct kvm_x86_ops *kvm_x86_ops;\n\nstatic void kvm_mmu_slot_apply_flags(struct kvm *kvm,\n\t\t\t\t     struct kvm_memory_slot *new)\n{\n\t/* Still write protect RO slot */\n\tif (new->flags & KVM_MEM_READONLY) {\n\t\tkvm_mmu_slot_remove_write_access(kvm, new);\n\t\treturn;\n\t}\n\n\t/*\n\t * Call kvm_x86_ops dirty logging hooks when they are valid.\n\t *\n\t * kvm_x86_ops->slot_disable_log_dirty is called when:\n\t *\n\t *  - KVM_MR_CREATE with dirty logging is disabled\n\t *  - KVM_MR_FLAGS_ONLY with dirty logging is disabled in new flag\n\t *\n\t * The reason is, in case of PML, we need to set D-bit for any slots\n\t * with dirty logging disabled in order to eliminate unnecessary GPA\n\t * logging in PML buffer (and potential PML buffer full VMEXT). This\n\t * guarantees leaving PML enabled during guest's lifetime won't have\n\t * any additonal overhead from PML when guest is running with dirty\n\t * logging disabled for memory slots.\n\t *\n\t * kvm_x86_ops->slot_enable_log_dirty is called when switching new slot\n\t * to dirty logging mode.\n\t *\n\t * If kvm_x86_ops dirty logging hooks are invalid, use write protect.\n\t *\n\t * In case of write protect:\n\t *\n\t * Write protect all pages for dirty logging.\n\t *\n\t * All the sptes including the large sptes which point to this\n\t * slot are set to readonly. We can not create any new large\n\t * spte on this slot until the end of the logging.\n\t *\n\t * See the comments in fast_page_fault().\n\t */\n\tif (new->flags & KVM_MEM_LOG_DIRTY_PAGES) {\n\t\tif (kvm_x86_ops->slot_enable_log_dirty)\n\t\t\tkvm_x86_ops->slot_enable_log_dirty(kvm, new);\n\t\telse\n\t\t\tkvm_mmu_slot_remove_write_access(kvm, new);\n\t} else {\n\t\tif (kvm_x86_ops->slot_disable_log_dirty)\n\t\t\tkvm_x86_ops->slot_disable_log_dirty(kvm, new);\n\t}\n}"
  },
  {
    "function_name": "kvm_arch_prepare_memory_region",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "7989-7995",
    "snippet": "int kvm_arch_prepare_memory_region(struct kvm *kvm,\n\t\t\t\tstruct kvm_memory_slot *memslot,\n\t\t\t\tconst struct kvm_userspace_memory_region *mem,\n\t\t\t\tenum kvm_mr_change change)\n{\n\treturn 0;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nint kvm_arch_prepare_memory_region(struct kvm *kvm,\n\t\t\t\tstruct kvm_memory_slot *memslot,\n\t\t\t\tconst struct kvm_userspace_memory_region *mem,\n\t\t\t\tenum kvm_mr_change change)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "kvm_arch_memslots_updated",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "7980-7987",
    "snippet": "void kvm_arch_memslots_updated(struct kvm *kvm, struct kvm_memslots *slots)\n{\n\t/*\n\t * memslots->generation has been incremented.\n\t * mmio generation may have reached its maximum value.\n\t */\n\tkvm_mmu_invalidate_mmio_sptes(kvm, slots);\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_mmu_invalidate_mmio_sptes",
          "args": [
            "kvm",
            "slots"
          ],
          "line": 7986
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_invalidate_mmio_sptes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "4947-4957",
          "snippet": "void kvm_mmu_invalidate_mmio_sptes(struct kvm *kvm, struct kvm_memslots *slots)\n{\n\t/*\n\t * The very rare case: if the generation-number is round,\n\t * zap all shadow pages.\n\t */\n\tif (unlikely((slots->generation & MMIO_GEN_MASK) == 0)) {\n\t\tprintk_ratelimited(KERN_DEBUG \"kvm: zapping shadow pages for mmio generation wraparound\\n\");\n\t\tkvm_mmu_invalidate_zap_all_pages(kvm);\n\t}\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define MMIO_GEN_MASK\t\t\t((1 << MMIO_GEN_SHIFT) - 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define MMIO_GEN_MASK\t\t\t((1 << MMIO_GEN_SHIFT) - 1)\n\nvoid kvm_mmu_invalidate_mmio_sptes(struct kvm *kvm, struct kvm_memslots *slots)\n{\n\t/*\n\t * The very rare case: if the generation-number is round,\n\t * zap all shadow pages.\n\t */\n\tif (unlikely((slots->generation & MMIO_GEN_MASK) == 0)) {\n\t\tprintk_ratelimited(KERN_DEBUG \"kvm: zapping shadow pages for mmio generation wraparound\\n\");\n\t\tkvm_mmu_invalidate_zap_all_pages(kvm);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nvoid kvm_arch_memslots_updated(struct kvm *kvm, struct kvm_memslots *slots)\n{\n\t/*\n\t * memslots->generation has been incremented.\n\t * mmio generation may have reached its maximum value.\n\t */\n\tkvm_mmu_invalidate_mmio_sptes(kvm, slots);\n}"
  },
  {
    "function_name": "kvm_arch_create_memslot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "7916-7978",
    "snippet": "int kvm_arch_create_memslot(struct kvm *kvm, struct kvm_memory_slot *slot,\n\t\t\t    unsigned long npages)\n{\n\tint i;\n\n\tfor (i = 0; i < KVM_NR_PAGE_SIZES; ++i) {\n\t\tstruct kvm_lpage_info *linfo;\n\t\tunsigned long ugfn;\n\t\tint lpages;\n\t\tint level = i + 1;\n\n\t\tlpages = gfn_to_index(slot->base_gfn + npages - 1,\n\t\t\t\t      slot->base_gfn, level) + 1;\n\n\t\tslot->arch.rmap[i] =\n\t\t\tkvm_kvzalloc(lpages * sizeof(*slot->arch.rmap[i]));\n\t\tif (!slot->arch.rmap[i])\n\t\t\tgoto out_free;\n\t\tif (i == 0)\n\t\t\tcontinue;\n\n\t\tlinfo = kvm_kvzalloc(lpages * sizeof(*linfo));\n\t\tif (!linfo)\n\t\t\tgoto out_free;\n\n\t\tslot->arch.lpage_info[i - 1] = linfo;\n\n\t\tif (slot->base_gfn & (KVM_PAGES_PER_HPAGE(level) - 1))\n\t\t\tlinfo[0].disallow_lpage = 1;\n\t\tif ((slot->base_gfn + npages) & (KVM_PAGES_PER_HPAGE(level) - 1))\n\t\t\tlinfo[lpages - 1].disallow_lpage = 1;\n\t\tugfn = slot->userspace_addr >> PAGE_SHIFT;\n\t\t/*\n\t\t * If the gfn and userspace address are not aligned wrt each\n\t\t * other, or if explicitly asked to, disable large page\n\t\t * support for this slot\n\t\t */\n\t\tif ((slot->base_gfn ^ ugfn) & (KVM_PAGES_PER_HPAGE(level) - 1) ||\n\t\t    !kvm_largepages_enabled()) {\n\t\t\tunsigned long j;\n\n\t\t\tfor (j = 0; j < lpages; ++j)\n\t\t\t\tlinfo[j].disallow_lpage = 1;\n\t\t}\n\t}\n\n\tif (kvm_page_track_create_memslot(slot, npages))\n\t\tgoto out_free;\n\n\treturn 0;\n\nout_free:\n\tfor (i = 0; i < KVM_NR_PAGE_SIZES; ++i) {\n\t\tkvfree(slot->arch.rmap[i]);\n\t\tslot->arch.rmap[i] = NULL;\n\t\tif (i == 0)\n\t\t\tcontinue;\n\n\t\tkvfree(slot->arch.lpage_info[i - 1]);\n\t\tslot->arch.lpage_info[i - 1] = NULL;\n\t}\n\treturn -ENOMEM;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvfree",
          "args": [
            "slot->arch.lpage_info[i - 1]"
          ],
          "line": 7974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvfree",
          "args": [
            "slot->arch.rmap[i]"
          ],
          "line": 7969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_page_track_create_memslot",
          "args": [
            "slot",
            "npages"
          ],
          "line": 7962
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_page_track_create_memslot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/page_track.c",
          "lines": "35-52",
          "snippet": "int kvm_page_track_create_memslot(struct kvm_memory_slot *slot,\n\t\t\t\t  unsigned long npages)\n{\n\tint  i;\n\n\tfor (i = 0; i < KVM_PAGE_TRACK_MAX; i++) {\n\t\tslot->arch.gfn_track[i] = kvm_kvzalloc(npages *\n\t\t\t\t\t    sizeof(*slot->arch.gfn_track[i]));\n\t\tif (!slot->arch.gfn_track[i])\n\t\t\tgoto track_free;\n\t}\n\n\treturn 0;\n\ntrack_free:\n\tkvm_page_track_free_memslot(slot, NULL);\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include \"mmu.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mmu.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/kvm_host.h>\n#include <linux/kvm_host.h>\n\nint kvm_page_track_create_memslot(struct kvm_memory_slot *slot,\n\t\t\t\t  unsigned long npages)\n{\n\tint  i;\n\n\tfor (i = 0; i < KVM_PAGE_TRACK_MAX; i++) {\n\t\tslot->arch.gfn_track[i] = kvm_kvzalloc(npages *\n\t\t\t\t\t    sizeof(*slot->arch.gfn_track[i]));\n\t\tif (!slot->arch.gfn_track[i])\n\t\t\tgoto track_free;\n\t}\n\n\treturn 0;\n\ntrack_free:\n\tkvm_page_track_free_memslot(slot, NULL);\n\treturn -ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_largepages_enabled",
          "args": [],
          "line": 7954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVM_PAGES_PER_HPAGE",
          "args": [
            "level"
          ],
          "line": 7953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVM_PAGES_PER_HPAGE",
          "args": [
            "level"
          ],
          "line": 7945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVM_PAGES_PER_HPAGE",
          "args": [
            "level"
          ],
          "line": 7943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_kvzalloc",
          "args": [
            "lpages * sizeof(*linfo)"
          ],
          "line": 7937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_kvzalloc",
          "args": [
            "lpages * sizeof(*slot->arch.rmap[i])"
          ],
          "line": 7931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfn_to_index",
          "args": [
            "slot->base_gfn + npages - 1",
            "slot->base_gfn",
            "level"
          ],
          "line": 7927
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nint kvm_arch_create_memslot(struct kvm *kvm, struct kvm_memory_slot *slot,\n\t\t\t    unsigned long npages)\n{\n\tint i;\n\n\tfor (i = 0; i < KVM_NR_PAGE_SIZES; ++i) {\n\t\tstruct kvm_lpage_info *linfo;\n\t\tunsigned long ugfn;\n\t\tint lpages;\n\t\tint level = i + 1;\n\n\t\tlpages = gfn_to_index(slot->base_gfn + npages - 1,\n\t\t\t\t      slot->base_gfn, level) + 1;\n\n\t\tslot->arch.rmap[i] =\n\t\t\tkvm_kvzalloc(lpages * sizeof(*slot->arch.rmap[i]));\n\t\tif (!slot->arch.rmap[i])\n\t\t\tgoto out_free;\n\t\tif (i == 0)\n\t\t\tcontinue;\n\n\t\tlinfo = kvm_kvzalloc(lpages * sizeof(*linfo));\n\t\tif (!linfo)\n\t\t\tgoto out_free;\n\n\t\tslot->arch.lpage_info[i - 1] = linfo;\n\n\t\tif (slot->base_gfn & (KVM_PAGES_PER_HPAGE(level) - 1))\n\t\t\tlinfo[0].disallow_lpage = 1;\n\t\tif ((slot->base_gfn + npages) & (KVM_PAGES_PER_HPAGE(level) - 1))\n\t\t\tlinfo[lpages - 1].disallow_lpage = 1;\n\t\tugfn = slot->userspace_addr >> PAGE_SHIFT;\n\t\t/*\n\t\t * If the gfn and userspace address are not aligned wrt each\n\t\t * other, or if explicitly asked to, disable large page\n\t\t * support for this slot\n\t\t */\n\t\tif ((slot->base_gfn ^ ugfn) & (KVM_PAGES_PER_HPAGE(level) - 1) ||\n\t\t    !kvm_largepages_enabled()) {\n\t\t\tunsigned long j;\n\n\t\t\tfor (j = 0; j < lpages; ++j)\n\t\t\t\tlinfo[j].disallow_lpage = 1;\n\t\t}\n\t}\n\n\tif (kvm_page_track_create_memslot(slot, npages))\n\t\tgoto out_free;\n\n\treturn 0;\n\nout_free:\n\tfor (i = 0; i < KVM_NR_PAGE_SIZES; ++i) {\n\t\tkvfree(slot->arch.rmap[i]);\n\t\tslot->arch.rmap[i] = NULL;\n\t\tif (i == 0)\n\t\t\tcontinue;\n\n\t\tkvfree(slot->arch.lpage_info[i - 1]);\n\t\tslot->arch.lpage_info[i - 1] = NULL;\n\t}\n\treturn -ENOMEM;\n}"
  },
  {
    "function_name": "kvm_arch_free_memslot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "7893-7914",
    "snippet": "void kvm_arch_free_memslot(struct kvm *kvm, struct kvm_memory_slot *free,\n\t\t\t   struct kvm_memory_slot *dont)\n{\n\tint i;\n\n\tfor (i = 0; i < KVM_NR_PAGE_SIZES; ++i) {\n\t\tif (!dont || free->arch.rmap[i] != dont->arch.rmap[i]) {\n\t\t\tkvfree(free->arch.rmap[i]);\n\t\t\tfree->arch.rmap[i] = NULL;\n\t\t}\n\t\tif (i == 0)\n\t\t\tcontinue;\n\n\t\tif (!dont || free->arch.lpage_info[i - 1] !=\n\t\t\t     dont->arch.lpage_info[i - 1]) {\n\t\t\tkvfree(free->arch.lpage_info[i - 1]);\n\t\t\tfree->arch.lpage_info[i - 1] = NULL;\n\t\t}\n\t}\n\n\tkvm_page_track_free_memslot(free, dont);\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_page_track_free_memslot",
          "args": [
            "free",
            "dont"
          ],
          "line": 7913
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_page_track_free_memslot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/page_track.c",
          "lines": "22-33",
          "snippet": "void kvm_page_track_free_memslot(struct kvm_memory_slot *free,\n\t\t\t\t struct kvm_memory_slot *dont)\n{\n\tint i;\n\n\tfor (i = 0; i < KVM_PAGE_TRACK_MAX; i++)\n\t\tif (!dont || free->arch.gfn_track[i] !=\n\t\t      dont->arch.gfn_track[i]) {\n\t\t\tkvfree(free->arch.gfn_track[i]);\n\t\t\tfree->arch.gfn_track[i] = NULL;\n\t\t}\n}",
          "includes": [
            "#include \"mmu.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mmu.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/kvm_host.h>\n#include <linux/kvm_host.h>\n\nvoid kvm_page_track_free_memslot(struct kvm_memory_slot *free,\n\t\t\t\t struct kvm_memory_slot *dont)\n{\n\tint i;\n\n\tfor (i = 0; i < KVM_PAGE_TRACK_MAX; i++)\n\t\tif (!dont || free->arch.gfn_track[i] !=\n\t\t      dont->arch.gfn_track[i]) {\n\t\t\tkvfree(free->arch.gfn_track[i]);\n\t\t\tfree->arch.gfn_track[i] = NULL;\n\t\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvfree",
          "args": [
            "free->arch.lpage_info[i - 1]"
          ],
          "line": 7908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvfree",
          "args": [
            "free->arch.rmap[i]"
          ],
          "line": 7900
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nvoid kvm_arch_free_memslot(struct kvm *kvm, struct kvm_memory_slot *free,\n\t\t\t   struct kvm_memory_slot *dont)\n{\n\tint i;\n\n\tfor (i = 0; i < KVM_NR_PAGE_SIZES; ++i) {\n\t\tif (!dont || free->arch.rmap[i] != dont->arch.rmap[i]) {\n\t\t\tkvfree(free->arch.rmap[i]);\n\t\t\tfree->arch.rmap[i] = NULL;\n\t\t}\n\t\tif (i == 0)\n\t\t\tcontinue;\n\n\t\tif (!dont || free->arch.lpage_info[i - 1] !=\n\t\t\t     dont->arch.lpage_info[i - 1]) {\n\t\t\tkvfree(free->arch.lpage_info[i - 1]);\n\t\t\tfree->arch.lpage_info[i - 1] = NULL;\n\t\t}\n\t}\n\n\tkvm_page_track_free_memslot(free, dont);\n}"
  },
  {
    "function_name": "kvm_arch_destroy_vm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "7871-7891",
    "snippet": "void kvm_arch_destroy_vm(struct kvm *kvm)\n{\n\tif (current->mm == kvm->mm) {\n\t\t/*\n\t\t * Free memory regions allocated on behalf of userspace,\n\t\t * unless the the memory map has changed due to process exit\n\t\t * or fd copying.\n\t\t */\n\t\tx86_set_memory_region(kvm, APIC_ACCESS_PAGE_PRIVATE_MEMSLOT, 0, 0);\n\t\tx86_set_memory_region(kvm, IDENTITY_PAGETABLE_PRIVATE_MEMSLOT, 0, 0);\n\t\tx86_set_memory_region(kvm, TSS_PRIVATE_MEMSLOT, 0, 0);\n\t}\n\tif (kvm_x86_ops->vm_destroy)\n\t\tkvm_x86_ops->vm_destroy(kvm);\n\tkvm_iommu_unmap_guest(kvm);\n\tkfree(kvm->arch.vpic);\n\tkfree(kvm->arch.vioapic);\n\tkvm_free_vcpus(kvm);\n\tkfree(rcu_dereference_check(kvm->arch.apic_map, 1));\n\tkvm_mmu_uninit_vm(kvm);\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct kvm_x86_ops *kvm_x86_ops"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_mmu_uninit_vm",
          "args": [
            "kvm"
          ],
          "line": 7890
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_uninit_vm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "4621-4626",
          "snippet": "void kvm_mmu_uninit_vm(struct kvm *kvm)\n{\n\tstruct kvm_page_track_notifier_node *node = &kvm->arch.mmu_sp_tracker;\n\n\tkvm_page_track_unregister_notifier(kvm, node);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nvoid kvm_mmu_uninit_vm(struct kvm *kvm)\n{\n\tstruct kvm_page_track_notifier_node *node = &kvm->arch.mmu_sp_tracker;\n\n\tkvm_page_track_unregister_notifier(kvm, node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "rcu_dereference_check(kvm->arch.apic_map, 1)"
          ],
          "line": 7889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference_check",
          "args": [
            "kvm->arch.apic_map",
            "1"
          ],
          "line": 7889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_free_vcpus",
          "args": [
            "kvm"
          ],
          "line": 7888
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_free_vcpus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "7774-7795",
          "snippet": "static void kvm_free_vcpus(struct kvm *kvm)\n{\n\tunsigned int i;\n\tstruct kvm_vcpu *vcpu;\n\n\t/*\n\t * Unpin any mmu pages first.\n\t */\n\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\tkvm_clear_async_pf_completion_queue(vcpu);\n\t\tkvm_unload_vcpu_mmu(vcpu);\n\t}\n\tkvm_for_each_vcpu(i, vcpu, kvm)\n\t\tkvm_arch_vcpu_free(vcpu);\n\n\tmutex_lock(&kvm->lock);\n\tfor (i = 0; i < atomic_read(&kvm->online_vcpus); i++)\n\t\tkvm->vcpus[i] = NULL;\n\n\tatomic_set(&kvm->online_vcpus, 0);\n\tmutex_unlock(&kvm->lock);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic void kvm_free_vcpus(struct kvm *kvm)\n{\n\tunsigned int i;\n\tstruct kvm_vcpu *vcpu;\n\n\t/*\n\t * Unpin any mmu pages first.\n\t */\n\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\tkvm_clear_async_pf_completion_queue(vcpu);\n\t\tkvm_unload_vcpu_mmu(vcpu);\n\t}\n\tkvm_for_each_vcpu(i, vcpu, kvm)\n\t\tkvm_arch_vcpu_free(vcpu);\n\n\tmutex_lock(&kvm->lock);\n\tfor (i = 0; i < atomic_read(&kvm->online_vcpus); i++)\n\t\tkvm->vcpus[i] = NULL;\n\n\tatomic_set(&kvm->online_vcpus, 0);\n\tmutex_unlock(&kvm->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "kvm->arch.vioapic"
          ],
          "line": 7887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "kvm->arch.vpic"
          ],
          "line": 7886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_iommu_unmap_guest",
          "args": [
            "kvm"
          ],
          "line": 7885
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_iommu_unmap_guest",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/iommu.c",
          "lines": "342-358",
          "snippet": "int kvm_iommu_unmap_guest(struct kvm *kvm)\n{\n\tstruct iommu_domain *domain = kvm->arch.iommu_domain;\n\n\t/* check if iommu exists and in use */\n\tif (!domain)\n\t\treturn 0;\n\n\tmutex_lock(&kvm->slots_lock);\n\tkvm_iommu_unmap_memslots(kvm);\n\tkvm->arch.iommu_domain = NULL;\n\tkvm->arch.iommu_noncoherent = false;\n\tmutex_unlock(&kvm->slots_lock);\n\n\tiommu_domain_free(domain);\n\treturn 0;\n}",
          "includes": [
            "#include \"assigned-dev.h\"",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/dmar.h>",
            "#include <linux/stat.h>",
            "#include <linux/pci.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int kvm_iommu_unmap_memslots(struct kvm *kvm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"assigned-dev.h\"\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/dmar.h>\n#include <linux/stat.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/list.h>\n\nstatic int kvm_iommu_unmap_memslots(struct kvm *kvm);\n\nint kvm_iommu_unmap_guest(struct kvm *kvm)\n{\n\tstruct iommu_domain *domain = kvm->arch.iommu_domain;\n\n\t/* check if iommu exists and in use */\n\tif (!domain)\n\t\treturn 0;\n\n\tmutex_lock(&kvm->slots_lock);\n\tkvm_iommu_unmap_memslots(kvm);\n\tkvm->arch.iommu_domain = NULL;\n\tkvm->arch.iommu_noncoherent = false;\n\tmutex_unlock(&kvm->slots_lock);\n\n\tiommu_domain_free(domain);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_x86_ops->vm_destroy",
          "args": [
            "kvm"
          ],
          "line": 7884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x86_set_memory_region",
          "args": [
            "kvm",
            "TSS_PRIVATE_MEMSLOT",
            "0",
            "0"
          ],
          "line": 7881
        },
        "resolved": true,
        "details": {
          "function_name": "x86_set_memory_region",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "7859-7868",
          "snippet": "int x86_set_memory_region(struct kvm *kvm, int id, gpa_t gpa, u32 size)\n{\n\tint r;\n\n\tmutex_lock(&kvm->slots_lock);\n\tr = __x86_set_memory_region(kvm, id, gpa, size);\n\tmutex_unlock(&kvm->slots_lock);\n\n\treturn r;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nint x86_set_memory_region(struct kvm *kvm, int id, gpa_t gpa, u32 size)\n{\n\tint r;\n\n\tmutex_lock(&kvm->slots_lock);\n\tr = __x86_set_memory_region(kvm, id, gpa, size);\n\tmutex_unlock(&kvm->slots_lock);\n\n\treturn r;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstruct kvm_x86_ops *kvm_x86_ops;\n\nvoid kvm_arch_destroy_vm(struct kvm *kvm)\n{\n\tif (current->mm == kvm->mm) {\n\t\t/*\n\t\t * Free memory regions allocated on behalf of userspace,\n\t\t * unless the the memory map has changed due to process exit\n\t\t * or fd copying.\n\t\t */\n\t\tx86_set_memory_region(kvm, APIC_ACCESS_PAGE_PRIVATE_MEMSLOT, 0, 0);\n\t\tx86_set_memory_region(kvm, IDENTITY_PAGETABLE_PRIVATE_MEMSLOT, 0, 0);\n\t\tx86_set_memory_region(kvm, TSS_PRIVATE_MEMSLOT, 0, 0);\n\t}\n\tif (kvm_x86_ops->vm_destroy)\n\t\tkvm_x86_ops->vm_destroy(kvm);\n\tkvm_iommu_unmap_guest(kvm);\n\tkfree(kvm->arch.vpic);\n\tkfree(kvm->arch.vioapic);\n\tkvm_free_vcpus(kvm);\n\tkfree(rcu_dereference_check(kvm->arch.apic_map, 1));\n\tkvm_mmu_uninit_vm(kvm);\n}"
  },
  {
    "function_name": "x86_set_memory_region",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "7859-7868",
    "snippet": "int x86_set_memory_region(struct kvm *kvm, int id, gpa_t gpa, u32 size)\n{\n\tint r;\n\n\tmutex_lock(&kvm->slots_lock);\n\tr = __x86_set_memory_region(kvm, id, gpa, size);\n\tmutex_unlock(&kvm->slots_lock);\n\n\treturn r;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&kvm->slots_lock"
          ],
          "line": 7865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__x86_set_memory_region",
          "args": [
            "kvm",
            "id",
            "gpa",
            "size"
          ],
          "line": 7864
        },
        "resolved": true,
        "details": {
          "function_name": "__x86_set_memory_region",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "7805-7856",
          "snippet": "int __x86_set_memory_region(struct kvm *kvm, int id, gpa_t gpa, u32 size)\n{\n\tint i, r;\n\tunsigned long hva;\n\tstruct kvm_memslots *slots = kvm_memslots(kvm);\n\tstruct kvm_memory_slot *slot, old;\n\n\t/* Called with kvm->slots_lock held.  */\n\tif (WARN_ON(id >= KVM_MEM_SLOTS_NUM))\n\t\treturn -EINVAL;\n\n\tslot = id_to_memslot(slots, id);\n\tif (size) {\n\t\tif (WARN_ON(slot->npages))\n\t\t\treturn -EEXIST;\n\n\t\t/*\n\t\t * MAP_SHARED to prevent internal slot pages from being moved\n\t\t * by fork()/COW.\n\t\t */\n\t\thva = vm_mmap(NULL, 0, size, PROT_READ | PROT_WRITE,\n\t\t\t      MAP_SHARED | MAP_ANONYMOUS, 0);\n\t\tif (IS_ERR((void *)hva))\n\t\t\treturn PTR_ERR((void *)hva);\n\t} else {\n\t\tif (!slot->npages)\n\t\t\treturn 0;\n\n\t\thva = 0;\n\t}\n\n\told = *slot;\n\tfor (i = 0; i < KVM_ADDRESS_SPACE_NUM; i++) {\n\t\tstruct kvm_userspace_memory_region m;\n\n\t\tm.slot = id | (i << 16);\n\t\tm.flags = 0;\n\t\tm.guest_phys_addr = gpa;\n\t\tm.userspace_addr = hva;\n\t\tm.memory_size = size;\n\t\tr = __kvm_set_memory_region(kvm, &m);\n\t\tif (r < 0)\n\t\t\treturn r;\n\t}\n\n\tif (!size) {\n\t\tr = vm_munmap(old.userspace_addr, old.npages * PAGE_SIZE);\n\t\tWARN_ON(r < 0);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nint __x86_set_memory_region(struct kvm *kvm, int id, gpa_t gpa, u32 size)\n{\n\tint i, r;\n\tunsigned long hva;\n\tstruct kvm_memslots *slots = kvm_memslots(kvm);\n\tstruct kvm_memory_slot *slot, old;\n\n\t/* Called with kvm->slots_lock held.  */\n\tif (WARN_ON(id >= KVM_MEM_SLOTS_NUM))\n\t\treturn -EINVAL;\n\n\tslot = id_to_memslot(slots, id);\n\tif (size) {\n\t\tif (WARN_ON(slot->npages))\n\t\t\treturn -EEXIST;\n\n\t\t/*\n\t\t * MAP_SHARED to prevent internal slot pages from being moved\n\t\t * by fork()/COW.\n\t\t */\n\t\thva = vm_mmap(NULL, 0, size, PROT_READ | PROT_WRITE,\n\t\t\t      MAP_SHARED | MAP_ANONYMOUS, 0);\n\t\tif (IS_ERR((void *)hva))\n\t\t\treturn PTR_ERR((void *)hva);\n\t} else {\n\t\tif (!slot->npages)\n\t\t\treturn 0;\n\n\t\thva = 0;\n\t}\n\n\told = *slot;\n\tfor (i = 0; i < KVM_ADDRESS_SPACE_NUM; i++) {\n\t\tstruct kvm_userspace_memory_region m;\n\n\t\tm.slot = id | (i << 16);\n\t\tm.flags = 0;\n\t\tm.guest_phys_addr = gpa;\n\t\tm.userspace_addr = hva;\n\t\tm.memory_size = size;\n\t\tr = __kvm_set_memory_region(kvm, &m);\n\t\tif (r < 0)\n\t\t\treturn r;\n\t}\n\n\tif (!size) {\n\t\tr = vm_munmap(old.userspace_addr, old.npages * PAGE_SIZE);\n\t\tWARN_ON(r < 0);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&kvm->slots_lock"
          ],
          "line": 7863
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nint x86_set_memory_region(struct kvm *kvm, int id, gpa_t gpa, u32 size)\n{\n\tint r;\n\n\tmutex_lock(&kvm->slots_lock);\n\tr = __x86_set_memory_region(kvm, id, gpa, size);\n\tmutex_unlock(&kvm->slots_lock);\n\n\treturn r;\n}"
  },
  {
    "function_name": "__x86_set_memory_region",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "7805-7856",
    "snippet": "int __x86_set_memory_region(struct kvm *kvm, int id, gpa_t gpa, u32 size)\n{\n\tint i, r;\n\tunsigned long hva;\n\tstruct kvm_memslots *slots = kvm_memslots(kvm);\n\tstruct kvm_memory_slot *slot, old;\n\n\t/* Called with kvm->slots_lock held.  */\n\tif (WARN_ON(id >= KVM_MEM_SLOTS_NUM))\n\t\treturn -EINVAL;\n\n\tslot = id_to_memslot(slots, id);\n\tif (size) {\n\t\tif (WARN_ON(slot->npages))\n\t\t\treturn -EEXIST;\n\n\t\t/*\n\t\t * MAP_SHARED to prevent internal slot pages from being moved\n\t\t * by fork()/COW.\n\t\t */\n\t\thva = vm_mmap(NULL, 0, size, PROT_READ | PROT_WRITE,\n\t\t\t      MAP_SHARED | MAP_ANONYMOUS, 0);\n\t\tif (IS_ERR((void *)hva))\n\t\t\treturn PTR_ERR((void *)hva);\n\t} else {\n\t\tif (!slot->npages)\n\t\t\treturn 0;\n\n\t\thva = 0;\n\t}\n\n\told = *slot;\n\tfor (i = 0; i < KVM_ADDRESS_SPACE_NUM; i++) {\n\t\tstruct kvm_userspace_memory_region m;\n\n\t\tm.slot = id | (i << 16);\n\t\tm.flags = 0;\n\t\tm.guest_phys_addr = gpa;\n\t\tm.userspace_addr = hva;\n\t\tm.memory_size = size;\n\t\tr = __kvm_set_memory_region(kvm, &m);\n\t\tif (r < 0)\n\t\t\treturn r;\n\t}\n\n\tif (!size) {\n\t\tr = vm_munmap(old.userspace_addr, old.npages * PAGE_SIZE);\n\t\tWARN_ON(r < 0);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "r < 0"
          ],
          "line": 7852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vm_munmap",
          "args": [
            "old.userspace_addr",
            "old.npages * PAGE_SIZE"
          ],
          "line": 7851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__kvm_set_memory_region",
          "args": [
            "kvm",
            "&m"
          ],
          "line": 7845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "(void *)hva"
          ],
          "line": 7828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "(void *)hva"
          ],
          "line": 7827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vm_mmap",
          "args": [
            "NULL",
            "0",
            "size",
            "PROT_READ | PROT_WRITE",
            "MAP_SHARED | MAP_ANONYMOUS",
            "0"
          ],
          "line": 7825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "slot->npages"
          ],
          "line": 7818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "id_to_memslot",
          "args": [
            "slots",
            "id"
          ],
          "line": 7816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "id >= KVM_MEM_SLOTS_NUM"
          ],
          "line": 7813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_memslots",
          "args": [
            "kvm"
          ],
          "line": 7809
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nint __x86_set_memory_region(struct kvm *kvm, int id, gpa_t gpa, u32 size)\n{\n\tint i, r;\n\tunsigned long hva;\n\tstruct kvm_memslots *slots = kvm_memslots(kvm);\n\tstruct kvm_memory_slot *slot, old;\n\n\t/* Called with kvm->slots_lock held.  */\n\tif (WARN_ON(id >= KVM_MEM_SLOTS_NUM))\n\t\treturn -EINVAL;\n\n\tslot = id_to_memslot(slots, id);\n\tif (size) {\n\t\tif (WARN_ON(slot->npages))\n\t\t\treturn -EEXIST;\n\n\t\t/*\n\t\t * MAP_SHARED to prevent internal slot pages from being moved\n\t\t * by fork()/COW.\n\t\t */\n\t\thva = vm_mmap(NULL, 0, size, PROT_READ | PROT_WRITE,\n\t\t\t      MAP_SHARED | MAP_ANONYMOUS, 0);\n\t\tif (IS_ERR((void *)hva))\n\t\t\treturn PTR_ERR((void *)hva);\n\t} else {\n\t\tif (!slot->npages)\n\t\t\treturn 0;\n\n\t\thva = 0;\n\t}\n\n\told = *slot;\n\tfor (i = 0; i < KVM_ADDRESS_SPACE_NUM; i++) {\n\t\tstruct kvm_userspace_memory_region m;\n\n\t\tm.slot = id | (i << 16);\n\t\tm.flags = 0;\n\t\tm.guest_phys_addr = gpa;\n\t\tm.userspace_addr = hva;\n\t\tm.memory_size = size;\n\t\tr = __kvm_set_memory_region(kvm, &m);\n\t\tif (r < 0)\n\t\t\treturn r;\n\t}\n\n\tif (!size) {\n\t\tr = vm_munmap(old.userspace_addr, old.npages * PAGE_SIZE);\n\t\tWARN_ON(r < 0);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "kvm_arch_sync_events",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "7797-7803",
    "snippet": "void kvm_arch_sync_events(struct kvm *kvm)\n{\n\tcancel_delayed_work_sync(&kvm->arch.kvmclock_sync_work);\n\tcancel_delayed_work_sync(&kvm->arch.kvmclock_update_work);\n\tkvm_free_all_assigned_devices(kvm);\n\tkvm_free_pit(kvm);\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_free_pit",
          "args": [
            "kvm"
          ],
          "line": 7802
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_free_pit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/i8254.c",
          "lines": "722-736",
          "snippet": "void kvm_free_pit(struct kvm *kvm)\n{\n\tstruct kvm_pit *pit = kvm->arch.vpit;\n\n\tif (pit) {\n\t\tkvm_io_bus_unregister_dev(kvm, KVM_PIO_BUS, &pit->dev);\n\t\tkvm_io_bus_unregister_dev(kvm, KVM_PIO_BUS, &pit->speaker_dev);\n\t\tkvm_pit_set_reinject(pit, false);\n\t\thrtimer_cancel(&pit->pit_state.timer);\n\t\tflush_kthread_work(&pit->expired);\n\t\tkthread_stop(pit->worker_task);\n\t\tkvm_free_irq_source_id(kvm, pit->irq_source_id);\n\t\tkfree(pit);\n\t}\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"i8254.h\"",
            "#include \"irq.h\"",
            "#include \"ioapic.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"i8254.h\"\n#include \"irq.h\"\n#include \"ioapic.h\"\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nvoid kvm_free_pit(struct kvm *kvm)\n{\n\tstruct kvm_pit *pit = kvm->arch.vpit;\n\n\tif (pit) {\n\t\tkvm_io_bus_unregister_dev(kvm, KVM_PIO_BUS, &pit->dev);\n\t\tkvm_io_bus_unregister_dev(kvm, KVM_PIO_BUS, &pit->speaker_dev);\n\t\tkvm_pit_set_reinject(pit, false);\n\t\thrtimer_cancel(&pit->pit_state.timer);\n\t\tflush_kthread_work(&pit->expired);\n\t\tkthread_stop(pit->worker_task);\n\t\tkvm_free_irq_source_id(kvm, pit->irq_source_id);\n\t\tkfree(pit);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_free_all_assigned_devices",
          "args": [
            "kvm"
          ],
          "line": 7801
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_free_all_assigned_devices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/assigned-dev.c",
          "lines": "372-380",
          "snippet": "void kvm_free_all_assigned_devices(struct kvm *kvm)\n{\n\tstruct kvm_assigned_dev_kernel *assigned_dev, *tmp;\n\n\tlist_for_each_entry_safe(assigned_dev, tmp,\n\t\t\t\t &kvm->arch.assigned_dev_head, list) {\n\t\tkvm_free_assigned_device(kvm, assigned_dev);\n\t}\n}",
          "includes": [
            "#include \"trace/events/kvm.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"irq.h\"",
            "#include <linux/fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/pci.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/errno.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace/events/kvm.h\"\n#include \"assigned-dev.h\"\n#include \"irq.h\"\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/spinlock.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nvoid kvm_free_all_assigned_devices(struct kvm *kvm)\n{\n\tstruct kvm_assigned_dev_kernel *assigned_dev, *tmp;\n\n\tlist_for_each_entry_safe(assigned_dev, tmp,\n\t\t\t\t &kvm->arch.assigned_dev_head, list) {\n\t\tkvm_free_assigned_device(kvm, assigned_dev);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cancel_delayed_work_sync",
          "args": [
            "&kvm->arch.kvmclock_update_work"
          ],
          "line": 7800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cancel_delayed_work_sync",
          "args": [
            "&kvm->arch.kvmclock_sync_work"
          ],
          "line": 7799
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nvoid kvm_arch_sync_events(struct kvm *kvm)\n{\n\tcancel_delayed_work_sync(&kvm->arch.kvmclock_sync_work);\n\tcancel_delayed_work_sync(&kvm->arch.kvmclock_update_work);\n\tkvm_free_all_assigned_devices(kvm);\n\tkvm_free_pit(kvm);\n}"
  },
  {
    "function_name": "kvm_free_vcpus",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "7774-7795",
    "snippet": "static void kvm_free_vcpus(struct kvm *kvm)\n{\n\tunsigned int i;\n\tstruct kvm_vcpu *vcpu;\n\n\t/*\n\t * Unpin any mmu pages first.\n\t */\n\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\tkvm_clear_async_pf_completion_queue(vcpu);\n\t\tkvm_unload_vcpu_mmu(vcpu);\n\t}\n\tkvm_for_each_vcpu(i, vcpu, kvm)\n\t\tkvm_arch_vcpu_free(vcpu);\n\n\tmutex_lock(&kvm->lock);\n\tfor (i = 0; i < atomic_read(&kvm->online_vcpus); i++)\n\t\tkvm->vcpus[i] = NULL;\n\n\tatomic_set(&kvm->online_vcpus, 0);\n\tmutex_unlock(&kvm->lock);\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&kvm->lock"
          ],
          "line": 7794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&kvm->online_vcpus",
            "0"
          ],
          "line": 7793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&kvm->online_vcpus"
          ],
          "line": 7790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&kvm->lock"
          ],
          "line": 7789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_arch_vcpu_free",
          "args": [
            "vcpu"
          ],
          "line": 7787
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_arch_vcpu_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "7352-7358",
          "snippet": "void kvm_arch_vcpu_free(struct kvm_vcpu *vcpu)\n{\n\tkvmclock_reset(vcpu);\n\n\tfree_cpumask_var(vcpu->arch.wbinvd_dirty_mask);\n\tkvm_x86_ops->vcpu_free(vcpu);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "struct kvm_x86_ops *kvm_x86_ops"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nvoid kvm_arch_vcpu_free(struct kvm_vcpu *vcpu)\n{\n\tkvmclock_reset(vcpu);\n\n\tfree_cpumask_var(vcpu->arch.wbinvd_dirty_mask);\n\tkvm_x86_ops->vcpu_free(vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_for_each_vcpu",
          "args": [
            "i",
            "vcpu",
            "kvm"
          ],
          "line": 7786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_unload_vcpu_mmu",
          "args": [
            "vcpu"
          ],
          "line": 7784
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_unload_vcpu_mmu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "7765-7772",
          "snippet": "static void kvm_unload_vcpu_mmu(struct kvm_vcpu *vcpu)\n{\n\tint r;\n\tr = vcpu_load(vcpu);\n\tBUG_ON(r);\n\tkvm_mmu_unload(vcpu);\n\tvcpu_put(vcpu);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic void kvm_unload_vcpu_mmu(struct kvm_vcpu *vcpu)\n{\n\tint r;\n\tr = vcpu_load(vcpu);\n\tBUG_ON(r);\n\tkvm_mmu_unload(vcpu);\n\tvcpu_put(vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_clear_async_pf_completion_queue",
          "args": [
            "vcpu"
          ],
          "line": 7783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_for_each_vcpu",
          "args": [
            "i",
            "vcpu",
            "kvm"
          ],
          "line": 7782
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic void kvm_free_vcpus(struct kvm *kvm)\n{\n\tunsigned int i;\n\tstruct kvm_vcpu *vcpu;\n\n\t/*\n\t * Unpin any mmu pages first.\n\t */\n\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\tkvm_clear_async_pf_completion_queue(vcpu);\n\t\tkvm_unload_vcpu_mmu(vcpu);\n\t}\n\tkvm_for_each_vcpu(i, vcpu, kvm)\n\t\tkvm_arch_vcpu_free(vcpu);\n\n\tmutex_lock(&kvm->lock);\n\tfor (i = 0; i < atomic_read(&kvm->online_vcpus); i++)\n\t\tkvm->vcpus[i] = NULL;\n\n\tatomic_set(&kvm->online_vcpus, 0);\n\tmutex_unlock(&kvm->lock);\n}"
  },
  {
    "function_name": "kvm_unload_vcpu_mmu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "7765-7772",
    "snippet": "static void kvm_unload_vcpu_mmu(struct kvm_vcpu *vcpu)\n{\n\tint r;\n\tr = vcpu_load(vcpu);\n\tBUG_ON(r);\n\tkvm_mmu_unload(vcpu);\n\tvcpu_put(vcpu);\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vcpu_put",
          "args": [
            "vcpu"
          ],
          "line": 7771
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_arch_vcpu_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "2761-2766",
          "snippet": "void kvm_arch_vcpu_put(struct kvm_vcpu *vcpu)\n{\n\tkvm_x86_ops->vcpu_put(vcpu);\n\tkvm_put_guest_fpu(vcpu);\n\tvcpu->arch.last_host_tsc = rdtsc();\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "struct kvm_x86_ops *kvm_x86_ops"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nvoid kvm_arch_vcpu_put(struct kvm_vcpu *vcpu)\n{\n\tkvm_x86_ops->vcpu_put(vcpu);\n\tkvm_put_guest_fpu(vcpu);\n\tvcpu->arch.last_host_tsc = rdtsc();\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_mmu_unload",
          "args": [
            "vcpu"
          ],
          "line": 7770
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_unload",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "4255-4259",
          "snippet": "void kvm_mmu_unload(struct kvm_vcpu *vcpu)\n{\n\tmmu_free_roots(vcpu);\n\tWARN_ON(VALID_PAGE(vcpu->arch.mmu.root_hpa));\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nvoid kvm_mmu_unload(struct kvm_vcpu *vcpu)\n{\n\tmmu_free_roots(vcpu);\n\tWARN_ON(VALID_PAGE(vcpu->arch.mmu.root_hpa));\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "r"
          ],
          "line": 7769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vcpu_load",
          "args": [
            "vcpu"
          ],
          "line": 7768
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic void kvm_unload_vcpu_mmu(struct kvm_vcpu *vcpu)\n{\n\tint r;\n\tr = vcpu_load(vcpu);\n\tBUG_ON(r);\n\tkvm_mmu_unload(vcpu);\n\tvcpu_put(vcpu);\n}"
  },
  {
    "function_name": "kvm_arch_init_vm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "7730-7763",
    "snippet": "int kvm_arch_init_vm(struct kvm *kvm, unsigned long type)\n{\n\tif (type)\n\t\treturn -EINVAL;\n\n\tINIT_HLIST_HEAD(&kvm->arch.mask_notifier_list);\n\tINIT_LIST_HEAD(&kvm->arch.active_mmu_pages);\n\tINIT_LIST_HEAD(&kvm->arch.zapped_obsolete_pages);\n\tINIT_LIST_HEAD(&kvm->arch.assigned_dev_head);\n\tatomic_set(&kvm->arch.noncoherent_dma_count, 0);\n\n\t/* Reserve bit 0 of irq_sources_bitmap for userspace irq source */\n\tset_bit(KVM_USERSPACE_IRQ_SOURCE_ID, &kvm->arch.irq_sources_bitmap);\n\t/* Reserve bit 1 of irq_sources_bitmap for irqfd-resampler */\n\tset_bit(KVM_IRQFD_RESAMPLE_IRQ_SOURCE_ID,\n\t\t&kvm->arch.irq_sources_bitmap);\n\n\traw_spin_lock_init(&kvm->arch.tsc_write_lock);\n\tmutex_init(&kvm->arch.apic_map_lock);\n\tspin_lock_init(&kvm->arch.pvclock_gtod_sync_lock);\n\n\tpvclock_update_vm_gtod_copy(kvm);\n\n\tINIT_DELAYED_WORK(&kvm->arch.kvmclock_update_work, kvmclock_update_fn);\n\tINIT_DELAYED_WORK(&kvm->arch.kvmclock_sync_work, kvmclock_sync_fn);\n\n\tkvm_page_track_init(kvm);\n\tkvm_mmu_init_vm(kvm);\n\n\tif (kvm_x86_ops->vm_init)\n\t\treturn kvm_x86_ops->vm_init(kvm);\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct kvm_x86_ops *kvm_x86_ops"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_x86_ops->vm_init",
          "args": [
            "kvm"
          ],
          "line": 7760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_mmu_init_vm",
          "args": [
            "kvm"
          ],
          "line": 7757
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_init_vm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "4613-4619",
          "snippet": "void kvm_mmu_init_vm(struct kvm *kvm)\n{\n\tstruct kvm_page_track_notifier_node *node = &kvm->arch.mmu_sp_tracker;\n\n\tnode->track_write = kvm_mmu_pte_write;\n\tkvm_page_track_register_notifier(kvm, node);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nvoid kvm_mmu_init_vm(struct kvm *kvm)\n{\n\tstruct kvm_page_track_notifier_node *node = &kvm->arch.mmu_sp_tracker;\n\n\tnode->track_write = kvm_mmu_pte_write;\n\tkvm_page_track_register_notifier(kvm, node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_page_track_init",
          "args": [
            "kvm"
          ],
          "line": 7756
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_page_track_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/page_track.c",
          "lines": "159-166",
          "snippet": "void kvm_page_track_init(struct kvm *kvm)\n{\n\tstruct kvm_page_track_notifier_head *head;\n\n\thead = &kvm->arch.track_notifier_head;\n\tinit_srcu_struct(&head->track_srcu);\n\tINIT_HLIST_HEAD(&head->track_notifier_list);\n}",
          "includes": [
            "#include \"mmu.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mmu.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/kvm_host.h>\n#include <linux/kvm_host.h>\n\nvoid kvm_page_track_init(struct kvm *kvm)\n{\n\tstruct kvm_page_track_notifier_head *head;\n\n\thead = &kvm->arch.track_notifier_head;\n\tinit_srcu_struct(&head->track_srcu);\n\tINIT_HLIST_HEAD(&head->track_notifier_list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_DELAYED_WORK",
          "args": [
            "&kvm->arch.kvmclock_sync_work",
            "kvmclock_sync_fn"
          ],
          "line": 7754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_DELAYED_WORK",
          "args": [
            "&kvm->arch.kvmclock_update_work",
            "kvmclock_update_fn"
          ],
          "line": 7753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pvclock_update_vm_gtod_copy",
          "args": [
            "kvm"
          ],
          "line": 7751
        },
        "resolved": true,
        "details": {
          "function_name": "pvclock_update_vm_gtod_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "1658-1687",
          "snippet": "static void pvclock_update_vm_gtod_copy(struct kvm *kvm)\n{\n#ifdef CONFIG_X86_64\n\tstruct kvm_arch *ka = &kvm->arch;\n\tint vclock_mode;\n\tbool host_tsc_clocksource, vcpus_matched;\n\n\tvcpus_matched = (ka->nr_vcpus_matched_tsc + 1 ==\n\t\t\tatomic_read(&kvm->online_vcpus));\n\n\t/*\n\t * If the host uses TSC clock, then passthrough TSC as stable\n\t * to the guest.\n\t */\n\thost_tsc_clocksource = kvm_get_time_and_clockread(\n\t\t\t\t\t&ka->master_kernel_ns,\n\t\t\t\t\t&ka->master_cycle_now);\n\n\tka->use_master_clock = host_tsc_clocksource && vcpus_matched\n\t\t\t\t&& !backwards_tsc_observed\n\t\t\t\t&& !ka->boot_vcpu_runs_old_kvmclock;\n\n\tif (ka->use_master_clock)\n\t\tatomic_set(&kvm_guest_has_master_clock, 1);\n\n\tvclock_mode = pvclock_gtod_data.clock.vclock_mode;\n\ttrace_kvm_update_master_clock(ka->use_master_clock, vclock_mode,\n\t\t\t\t\tvcpus_matched);\n#endif\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void pvclock_update_vm_gtod_copy(struct kvm *kvm)\n{\n#ifdef CONFIG_X86_64\n\tstruct kvm_arch *ka = &kvm->arch;\n\tint vclock_mode;\n\tbool host_tsc_clocksource, vcpus_matched;\n\n\tvcpus_matched = (ka->nr_vcpus_matched_tsc + 1 ==\n\t\t\tatomic_read(&kvm->online_vcpus));\n\n\t/*\n\t * If the host uses TSC clock, then passthrough TSC as stable\n\t * to the guest.\n\t */\n\thost_tsc_clocksource = kvm_get_time_and_clockread(\n\t\t\t\t\t&ka->master_kernel_ns,\n\t\t\t\t\t&ka->master_cycle_now);\n\n\tka->use_master_clock = host_tsc_clocksource && vcpus_matched\n\t\t\t\t&& !backwards_tsc_observed\n\t\t\t\t&& !ka->boot_vcpu_runs_old_kvmclock;\n\n\tif (ka->use_master_clock)\n\t\tatomic_set(&kvm_guest_has_master_clock, 1);\n\n\tvclock_mode = pvclock_gtod_data.clock.vclock_mode;\n\ttrace_kvm_update_master_clock(ka->use_master_clock, vclock_mode,\n\t\t\t\t\tvcpus_matched);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&kvm->arch.pvclock_gtod_sync_lock"
          ],
          "line": 7749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&kvm->arch.apic_map_lock"
          ],
          "line": 7748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_init",
          "args": [
            "&kvm->arch.tsc_write_lock"
          ],
          "line": 7747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "KVM_IRQFD_RESAMPLE_IRQ_SOURCE_ID",
            "&kvm->arch.irq_sources_bitmap"
          ],
          "line": 7744
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_set_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/vmx.c",
          "lines": "1599-1604",
          "snippet": "static __always_inline void vmcs_set_bits(unsigned long field, u32 mask)\n{\n        BUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x2000,\n\t\t\t \"vmcs_set_bits does not support 64-bit fields\");\n\t__vmcs_writel(field, __vmcs_readl(field) | mask);\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"trace.h\"",
            "#include <asm/irq_remapping.h>",
            "#include <asm/apic.h>",
            "#include <asm/kexec.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/mce.h>",
            "#include <asm/virtext.h>",
            "#include <asm/vmx.h>",
            "#include <asm/desc.h>",
            "#include <asm/io.h>",
            "#include <asm/cpu.h>",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/hrtimer.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include \"lapic.h\"",
            "#include \"cpuid.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"trace.h\"\n#include <asm/irq_remapping.h>\n#include <asm/apic.h>\n#include <asm/kexec.h>\n#include <asm/debugreg.h>\n#include <asm/perf_event.h>\n#include <asm/fpu/internal.h>\n#include <asm/mce.h>\n#include <asm/virtext.h>\n#include <asm/vmx.h>\n#include <asm/desc.h>\n#include <asm/io.h>\n#include <asm/cpu.h>\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/hrtimer.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic __always_inline void vmcs_set_bits(unsigned long field, u32 mask)\n{\n        BUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x2000,\n\t\t\t \"vmcs_set_bits does not support 64-bit fields\");\n\t__vmcs_writel(field, __vmcs_readl(field) | mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&kvm->arch.noncoherent_dma_count",
            "0"
          ],
          "line": 7739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&kvm->arch.assigned_dev_head"
          ],
          "line": 7738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&kvm->arch.zapped_obsolete_pages"
          ],
          "line": 7737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&kvm->arch.active_mmu_pages"
          ],
          "line": 7736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_HLIST_HEAD",
          "args": [
            "&kvm->arch.mask_notifier_list"
          ],
          "line": 7735
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstruct kvm_x86_ops *kvm_x86_ops;\n\nint kvm_arch_init_vm(struct kvm *kvm, unsigned long type)\n{\n\tif (type)\n\t\treturn -EINVAL;\n\n\tINIT_HLIST_HEAD(&kvm->arch.mask_notifier_list);\n\tINIT_LIST_HEAD(&kvm->arch.active_mmu_pages);\n\tINIT_LIST_HEAD(&kvm->arch.zapped_obsolete_pages);\n\tINIT_LIST_HEAD(&kvm->arch.assigned_dev_head);\n\tatomic_set(&kvm->arch.noncoherent_dma_count, 0);\n\n\t/* Reserve bit 0 of irq_sources_bitmap for userspace irq source */\n\tset_bit(KVM_USERSPACE_IRQ_SOURCE_ID, &kvm->arch.irq_sources_bitmap);\n\t/* Reserve bit 1 of irq_sources_bitmap for irqfd-resampler */\n\tset_bit(KVM_IRQFD_RESAMPLE_IRQ_SOURCE_ID,\n\t\t&kvm->arch.irq_sources_bitmap);\n\n\traw_spin_lock_init(&kvm->arch.tsc_write_lock);\n\tmutex_init(&kvm->arch.apic_map_lock);\n\tspin_lock_init(&kvm->arch.pvclock_gtod_sync_lock);\n\n\tpvclock_update_vm_gtod_copy(kvm);\n\n\tINIT_DELAYED_WORK(&kvm->arch.kvmclock_update_work, kvmclock_update_fn);\n\tINIT_DELAYED_WORK(&kvm->arch.kvmclock_sync_work, kvmclock_sync_fn);\n\n\tkvm_page_track_init(kvm);\n\tkvm_mmu_init_vm(kvm);\n\n\tif (kvm_x86_ops->vm_init)\n\t\treturn kvm_x86_ops->vm_init(kvm);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "kvm_arch_sched_in",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "7725-7728",
    "snippet": "void kvm_arch_sched_in(struct kvm_vcpu *vcpu, int cpu)\n{\n\tkvm_x86_ops->sched_in(vcpu, cpu);\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);",
      "struct kvm_x86_ops *kvm_x86_ops"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_x86_ops->sched_in",
          "args": [
            "vcpu",
            "cpu"
          ],
          "line": 7727
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nvoid kvm_arch_sched_in(struct kvm_vcpu *vcpu, int cpu)\n{\n\tkvm_x86_ops->sched_in(vcpu, cpu);\n}"
  },
  {
    "function_name": "kvm_arch_vcpu_uninit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "7709-7723",
    "snippet": "void kvm_arch_vcpu_uninit(struct kvm_vcpu *vcpu)\n{\n\tint idx;\n\n\tkvm_hv_vcpu_uninit(vcpu);\n\tkvm_pmu_destroy(vcpu);\n\tkfree(vcpu->arch.mce_banks);\n\tkvm_free_lapic(vcpu);\n\tidx = srcu_read_lock(&vcpu->kvm->srcu);\n\tkvm_mmu_destroy(vcpu);\n\tsrcu_read_unlock(&vcpu->kvm->srcu, idx);\n\tfree_page((unsigned long)vcpu->arch.pio_data);\n\tif (!lapic_in_kernel(vcpu))\n\t\tstatic_key_slow_dec(&kvm_no_apic_vcpu);\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "static_key_slow_dec",
          "args": [
            "&kvm_no_apic_vcpu"
          ],
          "line": 7722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lapic_in_kernel",
          "args": [
            "vcpu"
          ],
          "line": 7721
        },
        "resolved": true,
        "details": {
          "function_name": "lapic_in_kernel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.h",
          "lines": "141-146",
          "snippet": "static inline bool lapic_in_kernel(struct kvm_vcpu *vcpu)\n{\n\tif (static_key_false(&kvm_no_apic_vcpu))\n\t\treturn vcpu->arch.apic;\n\treturn true;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline bool lapic_in_kernel(struct kvm_vcpu *vcpu)\n{\n\tif (static_key_false(&kvm_no_apic_vcpu))\n\t\treturn vcpu->arch.apic;\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_page",
          "args": [
            "(unsigned long)vcpu->arch.pio_data"
          ],
          "line": 7720
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_free_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "1708-1717",
          "snippet": "static void kvm_mmu_free_page(struct kvm_mmu_page *sp)\n{\n\tMMU_WARN_ON(!is_empty_shadow_page(sp->spt));\n\thlist_del(&sp->hash_link);\n\tlist_del(&sp->link);\n\tfree_page((unsigned long)sp->spt);\n\tif (!sp->role.direct)\n\t\tfree_page((unsigned long)sp->gfns);\n\tkmem_cache_free(mmu_page_header_cache, sp);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *mmu_page_header_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic struct kmem_cache *mmu_page_header_cache;\n\nstatic void kvm_mmu_free_page(struct kvm_mmu_page *sp)\n{\n\tMMU_WARN_ON(!is_empty_shadow_page(sp->spt));\n\thlist_del(&sp->hash_link);\n\tlist_del(&sp->link);\n\tfree_page((unsigned long)sp->spt);\n\tif (!sp->role.direct)\n\t\tfree_page((unsigned long)sp->gfns);\n\tkmem_cache_free(mmu_page_header_cache, sp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "srcu_read_unlock",
          "args": [
            "&vcpu->kvm->srcu",
            "idx"
          ],
          "line": 7719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_mmu_destroy",
          "args": [
            "vcpu"
          ],
          "line": 7718
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "5091-5096",
          "snippet": "void kvm_mmu_destroy(struct kvm_vcpu *vcpu)\n{\n\tkvm_mmu_unload(vcpu);\n\tfree_mmu_pages(vcpu);\n\tmmu_free_memory_caches(vcpu);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nvoid kvm_mmu_destroy(struct kvm_vcpu *vcpu)\n{\n\tkvm_mmu_unload(vcpu);\n\tfree_mmu_pages(vcpu);\n\tmmu_free_memory_caches(vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "srcu_read_lock",
          "args": [
            "&vcpu->kvm->srcu"
          ],
          "line": 7717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_free_lapic",
          "args": [
            "vcpu"
          ],
          "line": 7716
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_free_lapic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "1593-1612",
          "snippet": "void kvm_free_lapic(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tif (!vcpu->arch.apic)\n\t\treturn;\n\n\thrtimer_cancel(&apic->lapic_timer.timer);\n\n\tif (!(vcpu->arch.apic_base & MSR_IA32_APICBASE_ENABLE))\n\t\tstatic_key_slow_dec_deferred(&apic_hw_disabled);\n\n\tif (!apic->sw_enabled)\n\t\tstatic_key_slow_dec_deferred(&apic_sw_disabled);\n\n\tif (apic->regs)\n\t\tfree_page((unsigned long)apic->regs);\n\n\tkfree(apic);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct static_key_deferred apic_hw_disabled",
            "struct static_key_deferred apic_sw_disabled"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstruct static_key_deferred apic_hw_disabled;\nstruct static_key_deferred apic_sw_disabled;\n\nvoid kvm_free_lapic(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tif (!vcpu->arch.apic)\n\t\treturn;\n\n\thrtimer_cancel(&apic->lapic_timer.timer);\n\n\tif (!(vcpu->arch.apic_base & MSR_IA32_APICBASE_ENABLE))\n\t\tstatic_key_slow_dec_deferred(&apic_hw_disabled);\n\n\tif (!apic->sw_enabled)\n\t\tstatic_key_slow_dec_deferred(&apic_sw_disabled);\n\n\tif (apic->regs)\n\t\tfree_page((unsigned long)apic->regs);\n\n\tkfree(apic);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "vcpu->arch.mce_banks"
          ],
          "line": 7715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_pmu_destroy",
          "args": [
            "vcpu"
          ],
          "line": 7714
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_pmu_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/pmu.c",
          "lines": "306-309",
          "snippet": "void kvm_pmu_destroy(struct kvm_vcpu *vcpu)\n{\n\tkvm_pmu_reset(vcpu);\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"lapic.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include <asm/perf_event.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include <asm/perf_event.h>\n#include <linux/perf_event.h>\n#include <linux/kvm_host.h>\n#include <linux/types.h>\n\nvoid kvm_pmu_destroy(struct kvm_vcpu *vcpu)\n{\n\tkvm_pmu_reset(vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_hv_vcpu_uninit",
          "args": [
            "vcpu"
          ],
          "line": 7713
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_hv_vcpu_uninit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.c",
          "lines": "629-636",
          "snippet": "void kvm_hv_vcpu_uninit(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_vcpu_hv *hv_vcpu = vcpu_to_hv_vcpu(vcpu);\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(hv_vcpu->stimer); i++)\n\t\tstimer_cleanup(&hv_vcpu->stimer[i]);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nvoid kvm_hv_vcpu_uninit(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_vcpu_hv *hv_vcpu = vcpu_to_hv_vcpu(vcpu);\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(hv_vcpu->stimer); i++)\n\t\tstimer_cleanup(&hv_vcpu->stimer[i]);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nvoid kvm_arch_vcpu_uninit(struct kvm_vcpu *vcpu)\n{\n\tint idx;\n\n\tkvm_hv_vcpu_uninit(vcpu);\n\tkvm_pmu_destroy(vcpu);\n\tkfree(vcpu->arch.mce_banks);\n\tkvm_free_lapic(vcpu);\n\tidx = srcu_read_lock(&vcpu->kvm->srcu);\n\tkvm_mmu_destroy(vcpu);\n\tsrcu_read_unlock(&vcpu->kvm->srcu, idx);\n\tfree_page((unsigned long)vcpu->arch.pio_data);\n\tif (!lapic_in_kernel(vcpu))\n\t\tstatic_key_slow_dec(&kvm_no_apic_vcpu);\n}"
  },
  {
    "function_name": "kvm_arch_vcpu_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "7626-7707",
    "snippet": "int kvm_arch_vcpu_init(struct kvm_vcpu *vcpu)\n{\n\tstruct page *page;\n\tstruct kvm *kvm;\n\tint r;\n\n\tBUG_ON(vcpu->kvm == NULL);\n\tkvm = vcpu->kvm;\n\n\tvcpu->arch.apicv_active = kvm_x86_ops->get_enable_apicv();\n\tvcpu->arch.pv.pv_unhalted = false;\n\tvcpu->arch.emulate_ctxt.ops = &emulate_ops;\n\tif (!irqchip_in_kernel(kvm) || kvm_vcpu_is_reset_bsp(vcpu))\n\t\tvcpu->arch.mp_state = KVM_MP_STATE_RUNNABLE;\n\telse\n\t\tvcpu->arch.mp_state = KVM_MP_STATE_UNINITIALIZED;\n\n\tpage = alloc_page(GFP_KERNEL | __GFP_ZERO);\n\tif (!page) {\n\t\tr = -ENOMEM;\n\t\tgoto fail;\n\t}\n\tvcpu->arch.pio_data = page_address(page);\n\n\tkvm_set_tsc_khz(vcpu, max_tsc_khz);\n\n\tr = kvm_mmu_create(vcpu);\n\tif (r < 0)\n\t\tgoto fail_free_pio_data;\n\n\tif (irqchip_in_kernel(kvm)) {\n\t\tr = kvm_create_lapic(vcpu);\n\t\tif (r < 0)\n\t\t\tgoto fail_mmu_destroy;\n\t} else\n\t\tstatic_key_slow_inc(&kvm_no_apic_vcpu);\n\n\tvcpu->arch.mce_banks = kzalloc(KVM_MAX_MCE_BANKS * sizeof(u64) * 4,\n\t\t\t\t       GFP_KERNEL);\n\tif (!vcpu->arch.mce_banks) {\n\t\tr = -ENOMEM;\n\t\tgoto fail_free_lapic;\n\t}\n\tvcpu->arch.mcg_cap = KVM_MAX_MCE_BANKS;\n\n\tif (!zalloc_cpumask_var(&vcpu->arch.wbinvd_dirty_mask, GFP_KERNEL)) {\n\t\tr = -ENOMEM;\n\t\tgoto fail_free_mce_banks;\n\t}\n\n\tfx_init(vcpu);\n\n\tvcpu->arch.ia32_tsc_adjust_msr = 0x0;\n\tvcpu->arch.pv_time_enabled = false;\n\n\tvcpu->arch.guest_supported_xcr0 = 0;\n\tvcpu->arch.guest_xstate_size = XSAVE_HDR_SIZE + XSAVE_HDR_OFFSET;\n\n\tvcpu->arch.maxphyaddr = cpuid_query_maxphyaddr(vcpu);\n\n\tvcpu->arch.pat = MSR_IA32_CR_PAT_DEFAULT;\n\n\tkvm_async_pf_hash_reset(vcpu);\n\tkvm_pmu_init(vcpu);\n\n\tvcpu->arch.pending_external_vector = -1;\n\n\tkvm_hv_vcpu_init(vcpu);\n\n\treturn 0;\n\nfail_free_mce_banks:\n\tkfree(vcpu->arch.mce_banks);\nfail_free_lapic:\n\tkvm_free_lapic(vcpu);\nfail_mmu_destroy:\n\tkvm_mmu_destroy(vcpu);\nfail_free_pio_data:\n\tfree_page((unsigned long)vcpu->arch.pio_data);\nfail:\n\treturn r;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define KVM_MAX_MCE_BANKS 32"
    ],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);",
      "struct kvm_x86_ops *kvm_x86_ops",
      "static unsigned long max_tsc_khz;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_page",
          "args": [
            "(unsigned long)vcpu->arch.pio_data"
          ],
          "line": 7704
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_free_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "1708-1717",
          "snippet": "static void kvm_mmu_free_page(struct kvm_mmu_page *sp)\n{\n\tMMU_WARN_ON(!is_empty_shadow_page(sp->spt));\n\thlist_del(&sp->hash_link);\n\tlist_del(&sp->link);\n\tfree_page((unsigned long)sp->spt);\n\tif (!sp->role.direct)\n\t\tfree_page((unsigned long)sp->gfns);\n\tkmem_cache_free(mmu_page_header_cache, sp);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *mmu_page_header_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic struct kmem_cache *mmu_page_header_cache;\n\nstatic void kvm_mmu_free_page(struct kvm_mmu_page *sp)\n{\n\tMMU_WARN_ON(!is_empty_shadow_page(sp->spt));\n\thlist_del(&sp->hash_link);\n\tlist_del(&sp->link);\n\tfree_page((unsigned long)sp->spt);\n\tif (!sp->role.direct)\n\t\tfree_page((unsigned long)sp->gfns);\n\tkmem_cache_free(mmu_page_header_cache, sp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_mmu_destroy",
          "args": [
            "vcpu"
          ],
          "line": 7702
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "5091-5096",
          "snippet": "void kvm_mmu_destroy(struct kvm_vcpu *vcpu)\n{\n\tkvm_mmu_unload(vcpu);\n\tfree_mmu_pages(vcpu);\n\tmmu_free_memory_caches(vcpu);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nvoid kvm_mmu_destroy(struct kvm_vcpu *vcpu)\n{\n\tkvm_mmu_unload(vcpu);\n\tfree_mmu_pages(vcpu);\n\tmmu_free_memory_caches(vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_free_lapic",
          "args": [
            "vcpu"
          ],
          "line": 7700
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_free_lapic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "1593-1612",
          "snippet": "void kvm_free_lapic(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tif (!vcpu->arch.apic)\n\t\treturn;\n\n\thrtimer_cancel(&apic->lapic_timer.timer);\n\n\tif (!(vcpu->arch.apic_base & MSR_IA32_APICBASE_ENABLE))\n\t\tstatic_key_slow_dec_deferred(&apic_hw_disabled);\n\n\tif (!apic->sw_enabled)\n\t\tstatic_key_slow_dec_deferred(&apic_sw_disabled);\n\n\tif (apic->regs)\n\t\tfree_page((unsigned long)apic->regs);\n\n\tkfree(apic);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct static_key_deferred apic_hw_disabled",
            "struct static_key_deferred apic_sw_disabled"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstruct static_key_deferred apic_hw_disabled;\nstruct static_key_deferred apic_sw_disabled;\n\nvoid kvm_free_lapic(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tif (!vcpu->arch.apic)\n\t\treturn;\n\n\thrtimer_cancel(&apic->lapic_timer.timer);\n\n\tif (!(vcpu->arch.apic_base & MSR_IA32_APICBASE_ENABLE))\n\t\tstatic_key_slow_dec_deferred(&apic_hw_disabled);\n\n\tif (!apic->sw_enabled)\n\t\tstatic_key_slow_dec_deferred(&apic_sw_disabled);\n\n\tif (apic->regs)\n\t\tfree_page((unsigned long)apic->regs);\n\n\tkfree(apic);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "vcpu->arch.mce_banks"
          ],
          "line": 7698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_hv_vcpu_init",
          "args": [
            "vcpu"
          ],
          "line": 7693
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_hv_vcpu_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.c",
          "lines": "662-672",
          "snippet": "void kvm_hv_vcpu_init(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_vcpu_hv *hv_vcpu = vcpu_to_hv_vcpu(vcpu);\n\tint i;\n\n\tsynic_init(&hv_vcpu->synic);\n\n\tbitmap_zero(hv_vcpu->stimer_pending_bitmap, HV_SYNIC_STIMER_COUNT);\n\tfor (i = 0; i < ARRAY_SIZE(hv_vcpu->stimer); i++)\n\t\tstimer_init(&hv_vcpu->stimer[i], i);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nvoid kvm_hv_vcpu_init(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_vcpu_hv *hv_vcpu = vcpu_to_hv_vcpu(vcpu);\n\tint i;\n\n\tsynic_init(&hv_vcpu->synic);\n\n\tbitmap_zero(hv_vcpu->stimer_pending_bitmap, HV_SYNIC_STIMER_COUNT);\n\tfor (i = 0; i < ARRAY_SIZE(hv_vcpu->stimer); i++)\n\t\tstimer_init(&hv_vcpu->stimer[i], i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_pmu_init",
          "args": [
            "vcpu"
          ],
          "line": 7689
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_pmu_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/pmu.c",
          "lines": "296-304",
          "snippet": "void kvm_pmu_init(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_pmu *pmu = vcpu_to_pmu(vcpu);\n\n\tmemset(pmu, 0, sizeof(*pmu));\n\tkvm_x86_ops->pmu_ops->init(vcpu);\n\tinit_irq_work(&pmu->irq_work, kvm_pmi_trigger_fn);\n\tkvm_pmu_refresh(vcpu);\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"lapic.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include <asm/perf_event.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include <asm/perf_event.h>\n#include <linux/perf_event.h>\n#include <linux/kvm_host.h>\n#include <linux/types.h>\n\nvoid kvm_pmu_init(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_pmu *pmu = vcpu_to_pmu(vcpu);\n\n\tmemset(pmu, 0, sizeof(*pmu));\n\tkvm_x86_ops->pmu_ops->init(vcpu);\n\tinit_irq_work(&pmu->irq_work, kvm_pmi_trigger_fn);\n\tkvm_pmu_refresh(vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_async_pf_hash_reset",
          "args": [
            "vcpu"
          ],
          "line": 7688
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_async_pf_hash_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "193-198",
          "snippet": "static inline void kvm_async_pf_hash_reset(struct kvm_vcpu *vcpu)\n{\n\tint i;\n\tfor (i = 0; i < roundup_pow_of_two(ASYNC_PF_PER_VCPU); i++)\n\t\tvcpu->arch.apf.gfns[i] = ~0;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic inline void kvm_async_pf_hash_reset(struct kvm_vcpu *vcpu)\n{\n\tint i;\n\tfor (i = 0; i < roundup_pow_of_two(ASYNC_PF_PER_VCPU); i++)\n\t\tvcpu->arch.apf.gfns[i] = ~0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuid_query_maxphyaddr",
          "args": [
            "vcpu"
          ],
          "line": 7684
        },
        "resolved": true,
        "details": {
          "function_name": "cpuid_query_maxphyaddr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/cpuid.c",
          "lines": "163-175",
          "snippet": "int cpuid_query_maxphyaddr(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_cpuid_entry2 *best;\n\n\tbest = kvm_find_cpuid_entry(vcpu, 0x80000000, 0);\n\tif (!best || best->eax < 0x80000008)\n\t\tgoto not_found;\n\tbest = kvm_find_cpuid_entry(vcpu, 0x80000008, 0);\n\tif (best)\n\t\treturn best->eax & 0xff;\nnot_found:\n\treturn 36;\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"trace.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"cpuid.h\"",
            "#include <asm/fpu/xstate.h>",
            "#include <asm/user.h>",
            "#include <asm/fpu/internal.h> /* For use_eager_fpu.  Ugh! */",
            "#include <linux/uaccess.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"trace.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include <asm/fpu/xstate.h>\n#include <asm/user.h>\n#include <asm/fpu/internal.h> /* For use_eager_fpu.  Ugh! */\n#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n\nint cpuid_query_maxphyaddr(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_cpuid_entry2 *best;\n\n\tbest = kvm_find_cpuid_entry(vcpu, 0x80000000, 0);\n\tif (!best || best->eax < 0x80000008)\n\t\tgoto not_found;\n\tbest = kvm_find_cpuid_entry(vcpu, 0x80000008, 0);\n\tif (best)\n\t\treturn best->eax & 0xff;\nnot_found:\n\treturn 36;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fx_init",
          "args": [
            "vcpu"
          ],
          "line": 7676
        },
        "resolved": true,
        "details": {
          "function_name": "fx_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "7297-7310",
          "snippet": "static void fx_init(struct kvm_vcpu *vcpu)\n{\n\tfpstate_init(&vcpu->arch.guest_fpu.state);\n\tif (cpu_has_xsaves)\n\t\tvcpu->arch.guest_fpu.state.xsave.header.xcomp_bv =\n\t\t\thost_xcr0 | XSTATE_COMPACTION_ENABLED;\n\n\t/*\n\t * Ensure guest xcr0 is valid for loading\n\t */\n\tvcpu->arch.xcr0 = XFEATURE_MASK_FP;\n\n\tvcpu->arch.cr0 |= X86_CR0_ET;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define XSTATE_COMPACTION_ENABLED (1ULL << 63)"
          ],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "u64 __read_mostly host_xcr0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define XSTATE_COMPACTION_ENABLED (1ULL << 63)\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nu64 __read_mostly host_xcr0;\n\nstatic void fx_init(struct kvm_vcpu *vcpu)\n{\n\tfpstate_init(&vcpu->arch.guest_fpu.state);\n\tif (cpu_has_xsaves)\n\t\tvcpu->arch.guest_fpu.state.xsave.header.xcomp_bv =\n\t\t\thost_xcr0 | XSTATE_COMPACTION_ENABLED;\n\n\t/*\n\t * Ensure guest xcr0 is valid for loading\n\t */\n\tvcpu->arch.xcr0 = XFEATURE_MASK_FP;\n\n\tvcpu->arch.cr0 |= X86_CR0_ET;\n}"
        }
      },
      {
        "call_info": {
          "callee": "zalloc_cpumask_var",
          "args": [
            "&vcpu->arch.wbinvd_dirty_mask",
            "GFP_KERNEL"
          ],
          "line": 7671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "KVM_MAX_MCE_BANKS * sizeof(u64) * 4",
            "GFP_KERNEL"
          ],
          "line": 7663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_key_slow_inc",
          "args": [
            "&kvm_no_apic_vcpu"
          ],
          "line": 7661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_create_lapic",
          "args": [
            "vcpu"
          ],
          "line": 7657
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_create_lapic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "1828-1870",
          "snippet": "int kvm_create_lapic(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic;\n\n\tASSERT(vcpu != NULL);\n\tapic_debug(\"apic_init %d\\n\", vcpu->vcpu_id);\n\n\tapic = kzalloc(sizeof(*apic), GFP_KERNEL);\n\tif (!apic)\n\t\tgoto nomem;\n\n\tvcpu->arch.apic = apic;\n\n\tapic->regs = (void *)get_zeroed_page(GFP_KERNEL);\n\tif (!apic->regs) {\n\t\tprintk(KERN_ERR \"malloc apic regs error for vcpu %x\\n\",\n\t\t       vcpu->vcpu_id);\n\t\tgoto nomem_free_apic;\n\t}\n\tapic->vcpu = vcpu;\n\n\thrtimer_init(&apic->lapic_timer.timer, CLOCK_MONOTONIC,\n\t\t     HRTIMER_MODE_ABS_PINNED);\n\tapic->lapic_timer.timer.function = apic_timer_fn;\n\n\t/*\n\t * APIC is created enabled. This will prevent kvm_lapic_set_base from\n\t * thinking that APIC satet has changed.\n\t */\n\tvcpu->arch.apic_base = MSR_IA32_APICBASE_ENABLE;\n\tkvm_lapic_set_base(vcpu,\n\t\t\tAPIC_DEFAULT_PHYS_BASE | MSR_IA32_APICBASE_ENABLE);\n\n\tstatic_key_slow_inc(&apic_sw_disabled.key); /* sw disabled at reset */\n\tkvm_lapic_reset(vcpu, false);\n\tkvm_iodevice_init(&apic->dev, &apic_mmio_ops);\n\n\treturn 0;\nnomem_free_apic:\n\tkfree(apic);\nnomem:\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct static_key_deferred apic_sw_disabled",
            "static const struct kvm_io_device_ops apic_mmio_ops = {\n\t.read     = apic_mmio_read,\n\t.write    = apic_mmio_write,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstruct static_key_deferred apic_sw_disabled;\nstatic const struct kvm_io_device_ops apic_mmio_ops = {\n\t.read     = apic_mmio_read,\n\t.write    = apic_mmio_write,\n};\n\nint kvm_create_lapic(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic;\n\n\tASSERT(vcpu != NULL);\n\tapic_debug(\"apic_init %d\\n\", vcpu->vcpu_id);\n\n\tapic = kzalloc(sizeof(*apic), GFP_KERNEL);\n\tif (!apic)\n\t\tgoto nomem;\n\n\tvcpu->arch.apic = apic;\n\n\tapic->regs = (void *)get_zeroed_page(GFP_KERNEL);\n\tif (!apic->regs) {\n\t\tprintk(KERN_ERR \"malloc apic regs error for vcpu %x\\n\",\n\t\t       vcpu->vcpu_id);\n\t\tgoto nomem_free_apic;\n\t}\n\tapic->vcpu = vcpu;\n\n\thrtimer_init(&apic->lapic_timer.timer, CLOCK_MONOTONIC,\n\t\t     HRTIMER_MODE_ABS_PINNED);\n\tapic->lapic_timer.timer.function = apic_timer_fn;\n\n\t/*\n\t * APIC is created enabled. This will prevent kvm_lapic_set_base from\n\t * thinking that APIC satet has changed.\n\t */\n\tvcpu->arch.apic_base = MSR_IA32_APICBASE_ENABLE;\n\tkvm_lapic_set_base(vcpu,\n\t\t\tAPIC_DEFAULT_PHYS_BASE | MSR_IA32_APICBASE_ENABLE);\n\n\tstatic_key_slow_inc(&apic_sw_disabled.key); /* sw disabled at reset */\n\tkvm_lapic_reset(vcpu, false);\n\tkvm_iodevice_init(&apic->dev, &apic_mmio_ops);\n\n\treturn 0;\nnomem_free_apic:\n\tkfree(apic);\nnomem:\n\treturn -ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irqchip_in_kernel",
          "args": [
            "kvm"
          ],
          "line": 7656
        },
        "resolved": true,
        "details": {
          "function_name": "irqchip_in_kernel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/irq.h",
          "lines": "99-110",
          "snippet": "static inline int irqchip_in_kernel(struct kvm *kvm)\n{\n\tstruct kvm_pic *vpic = pic_irqchip(kvm);\n\tbool ret;\n\n\tret = (vpic != NULL);\n\tret |= irqchip_split(kvm);\n\n\t/* Read vpic before kvm->irq_routing.  */\n\tsmp_rmb();\n\treturn ret;\n}",
          "includes": [
            "#include \"lapic.h\"",
            "#include \"ioapic.h\"",
            "#include <kvm/iodev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/mm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <kvm/iodev.h>\n#include <linux/spinlock.h>\n#include <linux/kvm_host.h>\n#include <linux/hrtimer.h>\n#include <linux/mm_types.h>\n\nstatic inline int irqchip_in_kernel(struct kvm *kvm)\n{\n\tstruct kvm_pic *vpic = pic_irqchip(kvm);\n\tbool ret;\n\n\tret = (vpic != NULL);\n\tret |= irqchip_split(kvm);\n\n\t/* Read vpic before kvm->irq_routing.  */\n\tsmp_rmb();\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_mmu_create",
          "args": [
            "vcpu"
          ],
          "line": 7652
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "4596-4604",
          "snippet": "int kvm_mmu_create(struct kvm_vcpu *vcpu)\n{\n\tvcpu->arch.walk_mmu = &vcpu->arch.mmu;\n\tvcpu->arch.mmu.root_hpa = INVALID_PAGE;\n\tvcpu->arch.mmu.translate_gpa = translate_gpa;\n\tvcpu->arch.nested_mmu.translate_gpa = translate_nested_gpa;\n\n\treturn alloc_mmu_pages(vcpu);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nint kvm_mmu_create(struct kvm_vcpu *vcpu)\n{\n\tvcpu->arch.walk_mmu = &vcpu->arch.mmu;\n\tvcpu->arch.mmu.root_hpa = INVALID_PAGE;\n\tvcpu->arch.mmu.translate_gpa = translate_gpa;\n\tvcpu->arch.nested_mmu.translate_gpa = translate_nested_gpa;\n\n\treturn alloc_mmu_pages(vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_set_tsc_khz",
          "args": [
            "vcpu",
            "max_tsc_khz"
          ],
          "line": 7650
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_set_tsc_khz",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "1296-1327",
          "snippet": "static int kvm_set_tsc_khz(struct kvm_vcpu *vcpu, u32 user_tsc_khz)\n{\n\tu32 thresh_lo, thresh_hi;\n\tint use_scaling = 0;\n\n\t/* tsc_khz can be zero if TSC calibration fails */\n\tif (user_tsc_khz == 0) {\n\t\t/* set tsc_scaling_ratio to a safe value */\n\t\tvcpu->arch.tsc_scaling_ratio = kvm_default_tsc_scaling_ratio;\n\t\treturn -1;\n\t}\n\n\t/* Compute a scale to convert nanoseconds in TSC cycles */\n\tkvm_get_time_scale(user_tsc_khz * 1000LL, NSEC_PER_SEC,\n\t\t\t   &vcpu->arch.virtual_tsc_shift,\n\t\t\t   &vcpu->arch.virtual_tsc_mult);\n\tvcpu->arch.virtual_tsc_khz = user_tsc_khz;\n\n\t/*\n\t * Compute the variation in TSC rate which is acceptable\n\t * within the range of tolerance and decide if the\n\t * rate being applied is within that bounds of the hardware\n\t * rate.  If so, no scaling or compensation need be done.\n\t */\n\tthresh_lo = adjust_tsc_khz(tsc_khz, -tsc_tolerance_ppm);\n\tthresh_hi = adjust_tsc_khz(tsc_khz, tsc_tolerance_ppm);\n\tif (user_tsc_khz < thresh_lo || user_tsc_khz > thresh_hi) {\n\t\tpr_debug(\"kvm: requested TSC rate %u falls outside tolerance [%u,%u]\\n\", user_tsc_khz, thresh_lo, thresh_hi);\n\t\tuse_scaling = 1;\n\t}\n\treturn set_tsc_khz(vcpu, user_tsc_khz, use_scaling);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic int kvm_set_tsc_khz(struct kvm_vcpu *vcpu, u32 user_tsc_khz)\n{\n\tu32 thresh_lo, thresh_hi;\n\tint use_scaling = 0;\n\n\t/* tsc_khz can be zero if TSC calibration fails */\n\tif (user_tsc_khz == 0) {\n\t\t/* set tsc_scaling_ratio to a safe value */\n\t\tvcpu->arch.tsc_scaling_ratio = kvm_default_tsc_scaling_ratio;\n\t\treturn -1;\n\t}\n\n\t/* Compute a scale to convert nanoseconds in TSC cycles */\n\tkvm_get_time_scale(user_tsc_khz * 1000LL, NSEC_PER_SEC,\n\t\t\t   &vcpu->arch.virtual_tsc_shift,\n\t\t\t   &vcpu->arch.virtual_tsc_mult);\n\tvcpu->arch.virtual_tsc_khz = user_tsc_khz;\n\n\t/*\n\t * Compute the variation in TSC rate which is acceptable\n\t * within the range of tolerance and decide if the\n\t * rate being applied is within that bounds of the hardware\n\t * rate.  If so, no scaling or compensation need be done.\n\t */\n\tthresh_lo = adjust_tsc_khz(tsc_khz, -tsc_tolerance_ppm);\n\tthresh_hi = adjust_tsc_khz(tsc_khz, tsc_tolerance_ppm);\n\tif (user_tsc_khz < thresh_lo || user_tsc_khz > thresh_hi) {\n\t\tpr_debug(\"kvm: requested TSC rate %u falls outside tolerance [%u,%u]\\n\", user_tsc_khz, thresh_lo, thresh_hi);\n\t\tuse_scaling = 1;\n\t}\n\treturn set_tsc_khz(vcpu, user_tsc_khz, use_scaling);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 7648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_page",
          "args": [
            "GFP_KERNEL | __GFP_ZERO"
          ],
          "line": 7643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_is_reset_bsp",
          "args": [
            "vcpu"
          ],
          "line": 7638
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_vcpu_is_reset_bsp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "7607-7610",
          "snippet": "bool kvm_vcpu_is_reset_bsp(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->kvm->arch.bsp_vcpu_id == vcpu->vcpu_id;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nbool kvm_vcpu_is_reset_bsp(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->kvm->arch.bsp_vcpu_id == vcpu->vcpu_id;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_x86_ops->get_enable_apicv",
          "args": [],
          "line": 7635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "vcpu->kvm == NULL"
          ],
          "line": 7632
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define KVM_MAX_MCE_BANKS 32\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\nstatic unsigned long max_tsc_khz;\n\nint kvm_arch_vcpu_init(struct kvm_vcpu *vcpu)\n{\n\tstruct page *page;\n\tstruct kvm *kvm;\n\tint r;\n\n\tBUG_ON(vcpu->kvm == NULL);\n\tkvm = vcpu->kvm;\n\n\tvcpu->arch.apicv_active = kvm_x86_ops->get_enable_apicv();\n\tvcpu->arch.pv.pv_unhalted = false;\n\tvcpu->arch.emulate_ctxt.ops = &emulate_ops;\n\tif (!irqchip_in_kernel(kvm) || kvm_vcpu_is_reset_bsp(vcpu))\n\t\tvcpu->arch.mp_state = KVM_MP_STATE_RUNNABLE;\n\telse\n\t\tvcpu->arch.mp_state = KVM_MP_STATE_UNINITIALIZED;\n\n\tpage = alloc_page(GFP_KERNEL | __GFP_ZERO);\n\tif (!page) {\n\t\tr = -ENOMEM;\n\t\tgoto fail;\n\t}\n\tvcpu->arch.pio_data = page_address(page);\n\n\tkvm_set_tsc_khz(vcpu, max_tsc_khz);\n\n\tr = kvm_mmu_create(vcpu);\n\tif (r < 0)\n\t\tgoto fail_free_pio_data;\n\n\tif (irqchip_in_kernel(kvm)) {\n\t\tr = kvm_create_lapic(vcpu);\n\t\tif (r < 0)\n\t\t\tgoto fail_mmu_destroy;\n\t} else\n\t\tstatic_key_slow_inc(&kvm_no_apic_vcpu);\n\n\tvcpu->arch.mce_banks = kzalloc(KVM_MAX_MCE_BANKS * sizeof(u64) * 4,\n\t\t\t\t       GFP_KERNEL);\n\tif (!vcpu->arch.mce_banks) {\n\t\tr = -ENOMEM;\n\t\tgoto fail_free_lapic;\n\t}\n\tvcpu->arch.mcg_cap = KVM_MAX_MCE_BANKS;\n\n\tif (!zalloc_cpumask_var(&vcpu->arch.wbinvd_dirty_mask, GFP_KERNEL)) {\n\t\tr = -ENOMEM;\n\t\tgoto fail_free_mce_banks;\n\t}\n\n\tfx_init(vcpu);\n\n\tvcpu->arch.ia32_tsc_adjust_msr = 0x0;\n\tvcpu->arch.pv_time_enabled = false;\n\n\tvcpu->arch.guest_supported_xcr0 = 0;\n\tvcpu->arch.guest_xstate_size = XSAVE_HDR_SIZE + XSAVE_HDR_OFFSET;\n\n\tvcpu->arch.maxphyaddr = cpuid_query_maxphyaddr(vcpu);\n\n\tvcpu->arch.pat = MSR_IA32_CR_PAT_DEFAULT;\n\n\tkvm_async_pf_hash_reset(vcpu);\n\tkvm_pmu_init(vcpu);\n\n\tvcpu->arch.pending_external_vector = -1;\n\n\tkvm_hv_vcpu_init(vcpu);\n\n\treturn 0;\n\nfail_free_mce_banks:\n\tkfree(vcpu->arch.mce_banks);\nfail_free_lapic:\n\tkvm_free_lapic(vcpu);\nfail_mmu_destroy:\n\tkvm_mmu_destroy(vcpu);\nfail_free_pio_data:\n\tfree_page((unsigned long)vcpu->arch.pio_data);\nfail:\n\treturn r;\n}"
  },
  {
    "function_name": "kvm_vcpu_compatible",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "7618-7621",
    "snippet": "bool kvm_vcpu_compatible(struct kvm_vcpu *vcpu)\n{\n\treturn irqchip_in_kernel(vcpu->kvm) == lapic_in_kernel(vcpu);\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lapic_in_kernel",
          "args": [
            "vcpu"
          ],
          "line": 7620
        },
        "resolved": true,
        "details": {
          "function_name": "lapic_in_kernel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.h",
          "lines": "141-146",
          "snippet": "static inline bool lapic_in_kernel(struct kvm_vcpu *vcpu)\n{\n\tif (static_key_false(&kvm_no_apic_vcpu))\n\t\treturn vcpu->arch.apic;\n\treturn true;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline bool lapic_in_kernel(struct kvm_vcpu *vcpu)\n{\n\tif (static_key_false(&kvm_no_apic_vcpu))\n\t\treturn vcpu->arch.apic;\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irqchip_in_kernel",
          "args": [
            "vcpu->kvm"
          ],
          "line": 7620
        },
        "resolved": true,
        "details": {
          "function_name": "irqchip_in_kernel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/irq.h",
          "lines": "99-110",
          "snippet": "static inline int irqchip_in_kernel(struct kvm *kvm)\n{\n\tstruct kvm_pic *vpic = pic_irqchip(kvm);\n\tbool ret;\n\n\tret = (vpic != NULL);\n\tret |= irqchip_split(kvm);\n\n\t/* Read vpic before kvm->irq_routing.  */\n\tsmp_rmb();\n\treturn ret;\n}",
          "includes": [
            "#include \"lapic.h\"",
            "#include \"ioapic.h\"",
            "#include <kvm/iodev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/mm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <kvm/iodev.h>\n#include <linux/spinlock.h>\n#include <linux/kvm_host.h>\n#include <linux/hrtimer.h>\n#include <linux/mm_types.h>\n\nstatic inline int irqchip_in_kernel(struct kvm *kvm)\n{\n\tstruct kvm_pic *vpic = pic_irqchip(kvm);\n\tbool ret;\n\n\tret = (vpic != NULL);\n\tret |= irqchip_split(kvm);\n\n\t/* Read vpic before kvm->irq_routing.  */\n\tsmp_rmb();\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nbool kvm_vcpu_compatible(struct kvm_vcpu *vcpu)\n{\n\treturn irqchip_in_kernel(vcpu->kvm) == lapic_in_kernel(vcpu);\n}"
  },
  {
    "function_name": "kvm_vcpu_is_bsp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "7613-7616",
    "snippet": "bool kvm_vcpu_is_bsp(struct kvm_vcpu *vcpu)\n{\n\treturn (vcpu->arch.apic_base & MSR_IA32_APICBASE_BSP) != 0;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nbool kvm_vcpu_is_bsp(struct kvm_vcpu *vcpu)\n{\n\treturn (vcpu->arch.apic_base & MSR_IA32_APICBASE_BSP) != 0;\n}"
  },
  {
    "function_name": "kvm_vcpu_is_reset_bsp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "7607-7610",
    "snippet": "bool kvm_vcpu_is_reset_bsp(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->kvm->arch.bsp_vcpu_id == vcpu->vcpu_id;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nbool kvm_vcpu_is_reset_bsp(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->kvm->arch.bsp_vcpu_id == vcpu->vcpu_id;\n}"
  },
  {
    "function_name": "kvm_arch_check_processor_compat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "7602-7605",
    "snippet": "void kvm_arch_check_processor_compat(void *rtn)\n{\n\tkvm_x86_ops->check_processor_compatibility(rtn);\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct kvm_x86_ops *kvm_x86_ops"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_x86_ops->check_processor_compatibility",
          "args": [
            "rtn"
          ],
          "line": 7604
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstruct kvm_x86_ops *kvm_x86_ops;\n\nvoid kvm_arch_check_processor_compat(void *rtn)\n{\n\tkvm_x86_ops->check_processor_compatibility(rtn);\n}"
  },
  {
    "function_name": "kvm_arch_hardware_unsetup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "7597-7600",
    "snippet": "void kvm_arch_hardware_unsetup(void)\n{\n\tkvm_x86_ops->hardware_unsetup();\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct kvm_x86_ops *kvm_x86_ops"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_x86_ops->hardware_unsetup",
          "args": [],
          "line": 7599
        },
        "resolved": true,
        "details": {
          "function_name": "hardware_unsetup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/vmx.c",
          "lines": "6403-6417",
          "snippet": "static __exit void hardware_unsetup(void)\n{\n\tfree_page((unsigned long)vmx_msr_bitmap_legacy_x2apic);\n\tfree_page((unsigned long)vmx_msr_bitmap_longmode_x2apic);\n\tfree_page((unsigned long)vmx_msr_bitmap_legacy);\n\tfree_page((unsigned long)vmx_msr_bitmap_longmode);\n\tfree_page((unsigned long)vmx_io_bitmap_b);\n\tfree_page((unsigned long)vmx_io_bitmap_a);\n\tfree_page((unsigned long)vmx_vmwrite_bitmap);\n\tfree_page((unsigned long)vmx_vmread_bitmap);\n\tif (nested)\n\t\tfree_page((unsigned long)vmx_msr_bitmap_nested);\n\n\tfree_kvm_area();\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"trace.h\"",
            "#include <asm/irq_remapping.h>",
            "#include <asm/apic.h>",
            "#include <asm/kexec.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/mce.h>",
            "#include <asm/virtext.h>",
            "#include <asm/vmx.h>",
            "#include <asm/desc.h>",
            "#include <asm/io.h>",
            "#include <asm/cpu.h>",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/hrtimer.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include \"lapic.h\"",
            "#include \"cpuid.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool __read_mostly nested = 0;",
            "static unsigned long *vmx_io_bitmap_a;",
            "static unsigned long *vmx_io_bitmap_b;",
            "static unsigned long *vmx_msr_bitmap_legacy;",
            "static unsigned long *vmx_msr_bitmap_longmode;",
            "static unsigned long *vmx_msr_bitmap_legacy_x2apic;",
            "static unsigned long *vmx_msr_bitmap_longmode_x2apic;",
            "static unsigned long *vmx_msr_bitmap_nested;",
            "static unsigned long *vmx_vmread_bitmap;",
            "static unsigned long *vmx_vmwrite_bitmap;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"trace.h\"\n#include <asm/irq_remapping.h>\n#include <asm/apic.h>\n#include <asm/kexec.h>\n#include <asm/debugreg.h>\n#include <asm/perf_event.h>\n#include <asm/fpu/internal.h>\n#include <asm/mce.h>\n#include <asm/virtext.h>\n#include <asm/vmx.h>\n#include <asm/desc.h>\n#include <asm/io.h>\n#include <asm/cpu.h>\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/hrtimer.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic bool __read_mostly nested = 0;\nstatic unsigned long *vmx_io_bitmap_a;\nstatic unsigned long *vmx_io_bitmap_b;\nstatic unsigned long *vmx_msr_bitmap_legacy;\nstatic unsigned long *vmx_msr_bitmap_longmode;\nstatic unsigned long *vmx_msr_bitmap_legacy_x2apic;\nstatic unsigned long *vmx_msr_bitmap_longmode_x2apic;\nstatic unsigned long *vmx_msr_bitmap_nested;\nstatic unsigned long *vmx_vmread_bitmap;\nstatic unsigned long *vmx_vmwrite_bitmap;\n\nstatic __exit void hardware_unsetup(void)\n{\n\tfree_page((unsigned long)vmx_msr_bitmap_legacy_x2apic);\n\tfree_page((unsigned long)vmx_msr_bitmap_longmode_x2apic);\n\tfree_page((unsigned long)vmx_msr_bitmap_legacy);\n\tfree_page((unsigned long)vmx_msr_bitmap_longmode);\n\tfree_page((unsigned long)vmx_io_bitmap_b);\n\tfree_page((unsigned long)vmx_io_bitmap_a);\n\tfree_page((unsigned long)vmx_vmwrite_bitmap);\n\tfree_page((unsigned long)vmx_vmread_bitmap);\n\tif (nested)\n\t\tfree_page((unsigned long)vmx_msr_bitmap_nested);\n\n\tfree_kvm_area();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstruct kvm_x86_ops *kvm_x86_ops;\n\nvoid kvm_arch_hardware_unsetup(void)\n{\n\tkvm_x86_ops->hardware_unsetup();\n}"
  },
  {
    "function_name": "kvm_arch_hardware_setup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "7571-7595",
    "snippet": "int kvm_arch_hardware_setup(void)\n{\n\tint r;\n\n\tr = kvm_x86_ops->hardware_setup();\n\tif (r != 0)\n\t\treturn r;\n\n\tif (kvm_has_tsc_control) {\n\t\t/*\n\t\t * Make sure the user can only configure tsc_khz values that\n\t\t * fit into a signed integer.\n\t\t * A min value is not calculated needed because it will always\n\t\t * be 1 on all machines.\n\t\t */\n\t\tu64 max = min(0x7fffffffULL,\n\t\t\t      __scale_tsc(kvm_max_tsc_scaling_ratio, tsc_khz));\n\t\tkvm_max_guest_tsc_khz = max;\n\n\t\tkvm_default_tsc_scaling_ratio = 1ULL << kvm_tsc_scaling_ratio_frac_bits;\n\t}\n\n\tkvm_init_msr_list();\n\treturn 0;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct kvm_x86_ops *kvm_x86_ops"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_init_msr_list",
          "args": [],
          "line": 7593
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_init_msr_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "4059-4106",
          "snippet": "static void kvm_init_msr_list(void)\n{\n\tu32 dummy[2];\n\tunsigned i, j;\n\n\tfor (i = j = 0; i < ARRAY_SIZE(msrs_to_save); i++) {\n\t\tif (rdmsr_safe(msrs_to_save[i], &dummy[0], &dummy[1]) < 0)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Even MSRs that are valid in the host may not be exposed\n\t\t * to the guests in some cases.\n\t\t */\n\t\tswitch (msrs_to_save[i]) {\n\t\tcase MSR_IA32_BNDCFGS:\n\t\t\tif (!kvm_x86_ops->mpx_supported())\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\tcase MSR_TSC_AUX:\n\t\t\tif (!kvm_x86_ops->rdtscp_supported())\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tif (j < i)\n\t\t\tmsrs_to_save[j] = msrs_to_save[i];\n\t\tj++;\n\t}\n\tnum_msrs_to_save = j;\n\n\tfor (i = j = 0; i < ARRAY_SIZE(emulated_msrs); i++) {\n\t\tswitch (emulated_msrs[i]) {\n\t\tcase MSR_IA32_SMBASE:\n\t\t\tif (!kvm_x86_ops->cpu_has_high_real_mode_segbase())\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tif (j < i)\n\t\t\temulated_msrs[j] = emulated_msrs[i];\n\t\tj++;\n\t}\n\tnum_emulated_msrs = j;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct kvm_x86_ops *kvm_x86_ops",
            "static u32 msrs_to_save[] = {\n\tMSR_IA32_SYSENTER_CS, MSR_IA32_SYSENTER_ESP, MSR_IA32_SYSENTER_EIP,\n\tMSR_STAR,\n#ifdef CONFIG_X86_64\n\tMSR_CSTAR, MSR_KERNEL_GS_BASE, MSR_SYSCALL_MASK, MSR_LSTAR,\n#endif\n\tMSR_IA32_TSC, MSR_IA32_CR_PAT, MSR_VM_HSAVE_PA,\n\tMSR_IA32_FEATURE_CONTROL, MSR_IA32_BNDCFGS, MSR_TSC_AUX,\n};",
            "static unsigned num_msrs_to_save;",
            "static u32 emulated_msrs[] = {\n\tMSR_KVM_SYSTEM_TIME, MSR_KVM_WALL_CLOCK,\n\tMSR_KVM_SYSTEM_TIME_NEW, MSR_KVM_WALL_CLOCK_NEW,\n\tHV_X64_MSR_GUEST_OS_ID, HV_X64_MSR_HYPERCALL,\n\tHV_X64_MSR_TIME_REF_COUNT, HV_X64_MSR_REFERENCE_TSC,\n\tHV_X64_MSR_CRASH_P0, HV_X64_MSR_CRASH_P1, HV_X64_MSR_CRASH_P2,\n\tHV_X64_MSR_CRASH_P3, HV_X64_MSR_CRASH_P4, HV_X64_MSR_CRASH_CTL,\n\tHV_X64_MSR_RESET,\n\tHV_X64_MSR_VP_INDEX,\n\tHV_X64_MSR_VP_RUNTIME,\n\tHV_X64_MSR_SCONTROL,\n\tHV_X64_MSR_STIMER0_CONFIG,\n\tHV_X64_MSR_APIC_ASSIST_PAGE, MSR_KVM_ASYNC_PF_EN, MSR_KVM_STEAL_TIME,\n\tMSR_KVM_PV_EOI_EN,\n\n\tMSR_IA32_TSC_ADJUST,\n\tMSR_IA32_TSCDEADLINE,\n\tMSR_IA32_MISC_ENABLE,\n\tMSR_IA32_MCG_STATUS,\n\tMSR_IA32_MCG_CTL,\n\tMSR_IA32_SMBASE,\n};",
            "static unsigned num_emulated_msrs;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstruct kvm_x86_ops *kvm_x86_ops;\nstatic u32 msrs_to_save[] = {\n\tMSR_IA32_SYSENTER_CS, MSR_IA32_SYSENTER_ESP, MSR_IA32_SYSENTER_EIP,\n\tMSR_STAR,\n#ifdef CONFIG_X86_64\n\tMSR_CSTAR, MSR_KERNEL_GS_BASE, MSR_SYSCALL_MASK, MSR_LSTAR,\n#endif\n\tMSR_IA32_TSC, MSR_IA32_CR_PAT, MSR_VM_HSAVE_PA,\n\tMSR_IA32_FEATURE_CONTROL, MSR_IA32_BNDCFGS, MSR_TSC_AUX,\n};\nstatic unsigned num_msrs_to_save;\nstatic u32 emulated_msrs[] = {\n\tMSR_KVM_SYSTEM_TIME, MSR_KVM_WALL_CLOCK,\n\tMSR_KVM_SYSTEM_TIME_NEW, MSR_KVM_WALL_CLOCK_NEW,\n\tHV_X64_MSR_GUEST_OS_ID, HV_X64_MSR_HYPERCALL,\n\tHV_X64_MSR_TIME_REF_COUNT, HV_X64_MSR_REFERENCE_TSC,\n\tHV_X64_MSR_CRASH_P0, HV_X64_MSR_CRASH_P1, HV_X64_MSR_CRASH_P2,\n\tHV_X64_MSR_CRASH_P3, HV_X64_MSR_CRASH_P4, HV_X64_MSR_CRASH_CTL,\n\tHV_X64_MSR_RESET,\n\tHV_X64_MSR_VP_INDEX,\n\tHV_X64_MSR_VP_RUNTIME,\n\tHV_X64_MSR_SCONTROL,\n\tHV_X64_MSR_STIMER0_CONFIG,\n\tHV_X64_MSR_APIC_ASSIST_PAGE, MSR_KVM_ASYNC_PF_EN, MSR_KVM_STEAL_TIME,\n\tMSR_KVM_PV_EOI_EN,\n\n\tMSR_IA32_TSC_ADJUST,\n\tMSR_IA32_TSCDEADLINE,\n\tMSR_IA32_MISC_ENABLE,\n\tMSR_IA32_MCG_STATUS,\n\tMSR_IA32_MCG_CTL,\n\tMSR_IA32_SMBASE,\n};\nstatic unsigned num_emulated_msrs;\n\nstatic void kvm_init_msr_list(void)\n{\n\tu32 dummy[2];\n\tunsigned i, j;\n\n\tfor (i = j = 0; i < ARRAY_SIZE(msrs_to_save); i++) {\n\t\tif (rdmsr_safe(msrs_to_save[i], &dummy[0], &dummy[1]) < 0)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Even MSRs that are valid in the host may not be exposed\n\t\t * to the guests in some cases.\n\t\t */\n\t\tswitch (msrs_to_save[i]) {\n\t\tcase MSR_IA32_BNDCFGS:\n\t\t\tif (!kvm_x86_ops->mpx_supported())\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\tcase MSR_TSC_AUX:\n\t\t\tif (!kvm_x86_ops->rdtscp_supported())\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tif (j < i)\n\t\t\tmsrs_to_save[j] = msrs_to_save[i];\n\t\tj++;\n\t}\n\tnum_msrs_to_save = j;\n\n\tfor (i = j = 0; i < ARRAY_SIZE(emulated_msrs); i++) {\n\t\tswitch (emulated_msrs[i]) {\n\t\tcase MSR_IA32_SMBASE:\n\t\t\tif (!kvm_x86_ops->cpu_has_high_real_mode_segbase())\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tif (j < i)\n\t\t\temulated_msrs[j] = emulated_msrs[i];\n\t\tj++;\n\t}\n\tnum_emulated_msrs = j;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "0x7fffffffULL",
            "__scale_tsc(kvm_max_tsc_scaling_ratio, tsc_khz)"
          ],
          "line": 7586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__scale_tsc",
          "args": [
            "kvm_max_tsc_scaling_ratio",
            "tsc_khz"
          ],
          "line": 7587
        },
        "resolved": true,
        "details": {
          "function_name": "__scale_tsc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "1382-1385",
          "snippet": "static inline u64 __scale_tsc(u64 ratio, u64 tsc)\n{\n\treturn mul_u64_u64_shr(tsc, ratio, kvm_tsc_scaling_ratio_frac_bits);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic inline u64 __scale_tsc(u64 ratio, u64 tsc)\n{\n\treturn mul_u64_u64_shr(tsc, ratio, kvm_tsc_scaling_ratio_frac_bits);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_x86_ops->hardware_setup",
          "args": [],
          "line": 7575
        },
        "resolved": true,
        "details": {
          "function_name": "hardware_setup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/vmx.c",
          "lines": "6193-6401",
          "snippet": "static __init int hardware_setup(void)\n{\n\tint r = -ENOMEM, i, msr;\n\n\trdmsrl_safe(MSR_EFER, &host_efer);\n\n\tfor (i = 0; i < ARRAY_SIZE(vmx_msr_index); ++i)\n\t\tkvm_define_shared_msr(i, vmx_msr_index[i]);\n\n\tvmx_io_bitmap_a = (unsigned long *)__get_free_page(GFP_KERNEL);\n\tif (!vmx_io_bitmap_a)\n\t\treturn r;\n\n\tvmx_io_bitmap_b = (unsigned long *)__get_free_page(GFP_KERNEL);\n\tif (!vmx_io_bitmap_b)\n\t\tgoto out;\n\n\tvmx_msr_bitmap_legacy = (unsigned long *)__get_free_page(GFP_KERNEL);\n\tif (!vmx_msr_bitmap_legacy)\n\t\tgoto out1;\n\n\tvmx_msr_bitmap_legacy_x2apic =\n\t\t\t\t(unsigned long *)__get_free_page(GFP_KERNEL);\n\tif (!vmx_msr_bitmap_legacy_x2apic)\n\t\tgoto out2;\n\n\tvmx_msr_bitmap_longmode = (unsigned long *)__get_free_page(GFP_KERNEL);\n\tif (!vmx_msr_bitmap_longmode)\n\t\tgoto out3;\n\n\tvmx_msr_bitmap_longmode_x2apic =\n\t\t\t\t(unsigned long *)__get_free_page(GFP_KERNEL);\n\tif (!vmx_msr_bitmap_longmode_x2apic)\n\t\tgoto out4;\n\n\tif (nested) {\n\t\tvmx_msr_bitmap_nested =\n\t\t\t(unsigned long *)__get_free_page(GFP_KERNEL);\n\t\tif (!vmx_msr_bitmap_nested)\n\t\t\tgoto out5;\n\t}\n\n\tvmx_vmread_bitmap = (unsigned long *)__get_free_page(GFP_KERNEL);\n\tif (!vmx_vmread_bitmap)\n\t\tgoto out6;\n\n\tvmx_vmwrite_bitmap = (unsigned long *)__get_free_page(GFP_KERNEL);\n\tif (!vmx_vmwrite_bitmap)\n\t\tgoto out7;\n\n\tmemset(vmx_vmread_bitmap, 0xff, PAGE_SIZE);\n\tmemset(vmx_vmwrite_bitmap, 0xff, PAGE_SIZE);\n\n\t/*\n\t * Allow direct access to the PC debug port (it is often used for I/O\n\t * delays, but the vmexits simply slow things down).\n\t */\n\tmemset(vmx_io_bitmap_a, 0xff, PAGE_SIZE);\n\tclear_bit(0x80, vmx_io_bitmap_a);\n\n\tmemset(vmx_io_bitmap_b, 0xff, PAGE_SIZE);\n\n\tmemset(vmx_msr_bitmap_legacy, 0xff, PAGE_SIZE);\n\tmemset(vmx_msr_bitmap_longmode, 0xff, PAGE_SIZE);\n\tif (nested)\n\t\tmemset(vmx_msr_bitmap_nested, 0xff, PAGE_SIZE);\n\n\tif (setup_vmcs_config(&vmcs_config) < 0) {\n\t\tr = -EIO;\n\t\tgoto out8;\n\t}\n\n\tif (boot_cpu_has(X86_FEATURE_NX))\n\t\tkvm_enable_efer_bits(EFER_NX);\n\n\tif (!cpu_has_vmx_vpid())\n\t\tenable_vpid = 0;\n\tif (!cpu_has_vmx_shadow_vmcs())\n\t\tenable_shadow_vmcs = 0;\n\tif (enable_shadow_vmcs)\n\t\tinit_vmcs_shadow_fields();\n\n\tif (!cpu_has_vmx_ept() ||\n\t    !cpu_has_vmx_ept_4levels()) {\n\t\tenable_ept = 0;\n\t\tenable_unrestricted_guest = 0;\n\t\tenable_ept_ad_bits = 0;\n\t}\n\n\tif (!cpu_has_vmx_ept_ad_bits())\n\t\tenable_ept_ad_bits = 0;\n\n\tif (!cpu_has_vmx_unrestricted_guest())\n\t\tenable_unrestricted_guest = 0;\n\n\tif (!cpu_has_vmx_flexpriority())\n\t\tflexpriority_enabled = 0;\n\n\t/*\n\t * set_apic_access_page_addr() is used to reload apic access\n\t * page upon invalidation.  No need to do anything if not\n\t * using the APIC_ACCESS_ADDR VMCS field.\n\t */\n\tif (!flexpriority_enabled)\n\t\tkvm_x86_ops->set_apic_access_page_addr = NULL;\n\n\tif (!cpu_has_vmx_tpr_shadow())\n\t\tkvm_x86_ops->update_cr8_intercept = NULL;\n\n\tif (enable_ept && !cpu_has_vmx_ept_2m_page())\n\t\tkvm_disable_largepages();\n\n\tif (!cpu_has_vmx_ple())\n\t\tple_gap = 0;\n\n\tif (!cpu_has_vmx_apicv())\n\t\tenable_apicv = 0;\n\n\tif (cpu_has_vmx_tsc_scaling()) {\n\t\tkvm_has_tsc_control = true;\n\t\tkvm_max_tsc_scaling_ratio = KVM_VMX_TSC_MULTIPLIER_MAX;\n\t\tkvm_tsc_scaling_ratio_frac_bits = 48;\n\t}\n\n\tvmx_disable_intercept_for_msr(MSR_FS_BASE, false);\n\tvmx_disable_intercept_for_msr(MSR_GS_BASE, false);\n\tvmx_disable_intercept_for_msr(MSR_KERNEL_GS_BASE, true);\n\tvmx_disable_intercept_for_msr(MSR_IA32_SYSENTER_CS, false);\n\tvmx_disable_intercept_for_msr(MSR_IA32_SYSENTER_ESP, false);\n\tvmx_disable_intercept_for_msr(MSR_IA32_SYSENTER_EIP, false);\n\tvmx_disable_intercept_for_msr(MSR_IA32_BNDCFGS, true);\n\n\tmemcpy(vmx_msr_bitmap_legacy_x2apic,\n\t\t\tvmx_msr_bitmap_legacy, PAGE_SIZE);\n\tmemcpy(vmx_msr_bitmap_longmode_x2apic,\n\t\t\tvmx_msr_bitmap_longmode, PAGE_SIZE);\n\n\tset_bit(0, vmx_vpid_bitmap); /* 0 is reserved for host */\n\n\tif (enable_apicv) {\n\t\tfor (msr = 0x800; msr <= 0x8ff; msr++)\n\t\t\tvmx_disable_intercept_msr_read_x2apic(msr);\n\n\t\t/* According SDM, in x2apic mode, the whole id reg is used.\n\t\t * But in KVM, it only use the highest eight bits. Need to\n\t\t * intercept it */\n\t\tvmx_enable_intercept_msr_read_x2apic(0x802);\n\t\t/* TMCCT */\n\t\tvmx_enable_intercept_msr_read_x2apic(0x839);\n\t\t/* TPR */\n\t\tvmx_disable_intercept_msr_write_x2apic(0x808);\n\t\t/* EOI */\n\t\tvmx_disable_intercept_msr_write_x2apic(0x80b);\n\t\t/* SELF-IPI */\n\t\tvmx_disable_intercept_msr_write_x2apic(0x83f);\n\t}\n\n\tif (enable_ept) {\n\t\tkvm_mmu_set_mask_ptes(0ull,\n\t\t\t(enable_ept_ad_bits) ? VMX_EPT_ACCESS_BIT : 0ull,\n\t\t\t(enable_ept_ad_bits) ? VMX_EPT_DIRTY_BIT : 0ull,\n\t\t\t0ull, VMX_EPT_EXECUTABLE_MASK);\n\t\tept_set_mmio_spte_mask();\n\t\tkvm_enable_tdp();\n\t} else\n\t\tkvm_disable_tdp();\n\n\tupdate_ple_window_actual_max();\n\n\t/*\n\t * Only enable PML when hardware supports PML feature, and both EPT\n\t * and EPT A/D bit features are enabled -- PML depends on them to work.\n\t */\n\tif (!enable_ept || !enable_ept_ad_bits || !cpu_has_vmx_pml())\n\t\tenable_pml = 0;\n\n\tif (!enable_pml) {\n\t\tkvm_x86_ops->slot_enable_log_dirty = NULL;\n\t\tkvm_x86_ops->slot_disable_log_dirty = NULL;\n\t\tkvm_x86_ops->flush_log_dirty = NULL;\n\t\tkvm_x86_ops->enable_log_dirty_pt_masked = NULL;\n\t}\n\n\tkvm_set_posted_intr_wakeup_handler(wakeup_handler);\n\n\treturn alloc_kvm_area();\n\nout8:\n\tfree_page((unsigned long)vmx_vmwrite_bitmap);\nout7:\n\tfree_page((unsigned long)vmx_vmread_bitmap);\nout6:\n\tif (nested)\n\t\tfree_page((unsigned long)vmx_msr_bitmap_nested);\nout5:\n\tfree_page((unsigned long)vmx_msr_bitmap_longmode_x2apic);\nout4:\n\tfree_page((unsigned long)vmx_msr_bitmap_longmode);\nout3:\n\tfree_page((unsigned long)vmx_msr_bitmap_legacy_x2apic);\nout2:\n\tfree_page((unsigned long)vmx_msr_bitmap_legacy);\nout1:\n\tfree_page((unsigned long)vmx_io_bitmap_b);\nout:\n\tfree_page((unsigned long)vmx_io_bitmap_a);\n\n    return r;\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"trace.h\"",
            "#include <asm/irq_remapping.h>",
            "#include <asm/apic.h>",
            "#include <asm/kexec.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/mce.h>",
            "#include <asm/virtext.h>",
            "#include <asm/vmx.h>",
            "#include <asm/desc.h>",
            "#include <asm/io.h>",
            "#include <asm/cpu.h>",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/hrtimer.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include \"lapic.h\"",
            "#include \"cpuid.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define KVM_VMX_TSC_MULTIPLIER_MAX     0xffffffffffffffffULL"
          ],
          "globals_used": [
            "static bool __read_mostly nested = 0;",
            "static int ple_gap = KVM_VMX_DEFAULT_PLE_GAP;",
            "static unsigned long *vmx_io_bitmap_a;",
            "static unsigned long *vmx_io_bitmap_b;",
            "static unsigned long *vmx_msr_bitmap_legacy;",
            "static unsigned long *vmx_msr_bitmap_longmode;",
            "static unsigned long *vmx_msr_bitmap_legacy_x2apic;",
            "static unsigned long *vmx_msr_bitmap_longmode_x2apic;",
            "static unsigned long *vmx_msr_bitmap_nested;",
            "static unsigned long *vmx_vmread_bitmap;",
            "static unsigned long *vmx_vmwrite_bitmap;",
            "static struct vmcs_config {\n\tint size;\n\tint order;\n\tu32 revision_id;\n\tu32 pin_based_exec_ctrl;\n\tu32 cpu_based_exec_ctrl;\n\tu32 cpu_based_2nd_exec_ctrl;\n\tu32 vmexit_ctrl;\n\tu32 vmentry_ctrl;\n} vmcs_config;",
            "static u64 host_efer;",
            "static const u32 vmx_msr_index[] = {\n#ifdef CONFIG_X86_64\n\tMSR_SYSCALL_MASK, MSR_LSTAR, MSR_CSTAR,\n#endif\n\tMSR_EFER, MSR_TSC_AUX, MSR_STAR,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"trace.h\"\n#include <asm/irq_remapping.h>\n#include <asm/apic.h>\n#include <asm/kexec.h>\n#include <asm/debugreg.h>\n#include <asm/perf_event.h>\n#include <asm/fpu/internal.h>\n#include <asm/mce.h>\n#include <asm/virtext.h>\n#include <asm/vmx.h>\n#include <asm/desc.h>\n#include <asm/io.h>\n#include <asm/cpu.h>\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/hrtimer.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define KVM_VMX_TSC_MULTIPLIER_MAX     0xffffffffffffffffULL\n\nstatic bool __read_mostly nested = 0;\nstatic int ple_gap = KVM_VMX_DEFAULT_PLE_GAP;\nstatic unsigned long *vmx_io_bitmap_a;\nstatic unsigned long *vmx_io_bitmap_b;\nstatic unsigned long *vmx_msr_bitmap_legacy;\nstatic unsigned long *vmx_msr_bitmap_longmode;\nstatic unsigned long *vmx_msr_bitmap_legacy_x2apic;\nstatic unsigned long *vmx_msr_bitmap_longmode_x2apic;\nstatic unsigned long *vmx_msr_bitmap_nested;\nstatic unsigned long *vmx_vmread_bitmap;\nstatic unsigned long *vmx_vmwrite_bitmap;\nstatic struct vmcs_config {\n\tint size;\n\tint order;\n\tu32 revision_id;\n\tu32 pin_based_exec_ctrl;\n\tu32 cpu_based_exec_ctrl;\n\tu32 cpu_based_2nd_exec_ctrl;\n\tu32 vmexit_ctrl;\n\tu32 vmentry_ctrl;\n} vmcs_config;\nstatic u64 host_efer;\nstatic const u32 vmx_msr_index[] = {\n#ifdef CONFIG_X86_64\n\tMSR_SYSCALL_MASK, MSR_LSTAR, MSR_CSTAR,\n#endif\n\tMSR_EFER, MSR_TSC_AUX, MSR_STAR,\n};\n\nstatic __init int hardware_setup(void)\n{\n\tint r = -ENOMEM, i, msr;\n\n\trdmsrl_safe(MSR_EFER, &host_efer);\n\n\tfor (i = 0; i < ARRAY_SIZE(vmx_msr_index); ++i)\n\t\tkvm_define_shared_msr(i, vmx_msr_index[i]);\n\n\tvmx_io_bitmap_a = (unsigned long *)__get_free_page(GFP_KERNEL);\n\tif (!vmx_io_bitmap_a)\n\t\treturn r;\n\n\tvmx_io_bitmap_b = (unsigned long *)__get_free_page(GFP_KERNEL);\n\tif (!vmx_io_bitmap_b)\n\t\tgoto out;\n\n\tvmx_msr_bitmap_legacy = (unsigned long *)__get_free_page(GFP_KERNEL);\n\tif (!vmx_msr_bitmap_legacy)\n\t\tgoto out1;\n\n\tvmx_msr_bitmap_legacy_x2apic =\n\t\t\t\t(unsigned long *)__get_free_page(GFP_KERNEL);\n\tif (!vmx_msr_bitmap_legacy_x2apic)\n\t\tgoto out2;\n\n\tvmx_msr_bitmap_longmode = (unsigned long *)__get_free_page(GFP_KERNEL);\n\tif (!vmx_msr_bitmap_longmode)\n\t\tgoto out3;\n\n\tvmx_msr_bitmap_longmode_x2apic =\n\t\t\t\t(unsigned long *)__get_free_page(GFP_KERNEL);\n\tif (!vmx_msr_bitmap_longmode_x2apic)\n\t\tgoto out4;\n\n\tif (nested) {\n\t\tvmx_msr_bitmap_nested =\n\t\t\t(unsigned long *)__get_free_page(GFP_KERNEL);\n\t\tif (!vmx_msr_bitmap_nested)\n\t\t\tgoto out5;\n\t}\n\n\tvmx_vmread_bitmap = (unsigned long *)__get_free_page(GFP_KERNEL);\n\tif (!vmx_vmread_bitmap)\n\t\tgoto out6;\n\n\tvmx_vmwrite_bitmap = (unsigned long *)__get_free_page(GFP_KERNEL);\n\tif (!vmx_vmwrite_bitmap)\n\t\tgoto out7;\n\n\tmemset(vmx_vmread_bitmap, 0xff, PAGE_SIZE);\n\tmemset(vmx_vmwrite_bitmap, 0xff, PAGE_SIZE);\n\n\t/*\n\t * Allow direct access to the PC debug port (it is often used for I/O\n\t * delays, but the vmexits simply slow things down).\n\t */\n\tmemset(vmx_io_bitmap_a, 0xff, PAGE_SIZE);\n\tclear_bit(0x80, vmx_io_bitmap_a);\n\n\tmemset(vmx_io_bitmap_b, 0xff, PAGE_SIZE);\n\n\tmemset(vmx_msr_bitmap_legacy, 0xff, PAGE_SIZE);\n\tmemset(vmx_msr_bitmap_longmode, 0xff, PAGE_SIZE);\n\tif (nested)\n\t\tmemset(vmx_msr_bitmap_nested, 0xff, PAGE_SIZE);\n\n\tif (setup_vmcs_config(&vmcs_config) < 0) {\n\t\tr = -EIO;\n\t\tgoto out8;\n\t}\n\n\tif (boot_cpu_has(X86_FEATURE_NX))\n\t\tkvm_enable_efer_bits(EFER_NX);\n\n\tif (!cpu_has_vmx_vpid())\n\t\tenable_vpid = 0;\n\tif (!cpu_has_vmx_shadow_vmcs())\n\t\tenable_shadow_vmcs = 0;\n\tif (enable_shadow_vmcs)\n\t\tinit_vmcs_shadow_fields();\n\n\tif (!cpu_has_vmx_ept() ||\n\t    !cpu_has_vmx_ept_4levels()) {\n\t\tenable_ept = 0;\n\t\tenable_unrestricted_guest = 0;\n\t\tenable_ept_ad_bits = 0;\n\t}\n\n\tif (!cpu_has_vmx_ept_ad_bits())\n\t\tenable_ept_ad_bits = 0;\n\n\tif (!cpu_has_vmx_unrestricted_guest())\n\t\tenable_unrestricted_guest = 0;\n\n\tif (!cpu_has_vmx_flexpriority())\n\t\tflexpriority_enabled = 0;\n\n\t/*\n\t * set_apic_access_page_addr() is used to reload apic access\n\t * page upon invalidation.  No need to do anything if not\n\t * using the APIC_ACCESS_ADDR VMCS field.\n\t */\n\tif (!flexpriority_enabled)\n\t\tkvm_x86_ops->set_apic_access_page_addr = NULL;\n\n\tif (!cpu_has_vmx_tpr_shadow())\n\t\tkvm_x86_ops->update_cr8_intercept = NULL;\n\n\tif (enable_ept && !cpu_has_vmx_ept_2m_page())\n\t\tkvm_disable_largepages();\n\n\tif (!cpu_has_vmx_ple())\n\t\tple_gap = 0;\n\n\tif (!cpu_has_vmx_apicv())\n\t\tenable_apicv = 0;\n\n\tif (cpu_has_vmx_tsc_scaling()) {\n\t\tkvm_has_tsc_control = true;\n\t\tkvm_max_tsc_scaling_ratio = KVM_VMX_TSC_MULTIPLIER_MAX;\n\t\tkvm_tsc_scaling_ratio_frac_bits = 48;\n\t}\n\n\tvmx_disable_intercept_for_msr(MSR_FS_BASE, false);\n\tvmx_disable_intercept_for_msr(MSR_GS_BASE, false);\n\tvmx_disable_intercept_for_msr(MSR_KERNEL_GS_BASE, true);\n\tvmx_disable_intercept_for_msr(MSR_IA32_SYSENTER_CS, false);\n\tvmx_disable_intercept_for_msr(MSR_IA32_SYSENTER_ESP, false);\n\tvmx_disable_intercept_for_msr(MSR_IA32_SYSENTER_EIP, false);\n\tvmx_disable_intercept_for_msr(MSR_IA32_BNDCFGS, true);\n\n\tmemcpy(vmx_msr_bitmap_legacy_x2apic,\n\t\t\tvmx_msr_bitmap_legacy, PAGE_SIZE);\n\tmemcpy(vmx_msr_bitmap_longmode_x2apic,\n\t\t\tvmx_msr_bitmap_longmode, PAGE_SIZE);\n\n\tset_bit(0, vmx_vpid_bitmap); /* 0 is reserved for host */\n\n\tif (enable_apicv) {\n\t\tfor (msr = 0x800; msr <= 0x8ff; msr++)\n\t\t\tvmx_disable_intercept_msr_read_x2apic(msr);\n\n\t\t/* According SDM, in x2apic mode, the whole id reg is used.\n\t\t * But in KVM, it only use the highest eight bits. Need to\n\t\t * intercept it */\n\t\tvmx_enable_intercept_msr_read_x2apic(0x802);\n\t\t/* TMCCT */\n\t\tvmx_enable_intercept_msr_read_x2apic(0x839);\n\t\t/* TPR */\n\t\tvmx_disable_intercept_msr_write_x2apic(0x808);\n\t\t/* EOI */\n\t\tvmx_disable_intercept_msr_write_x2apic(0x80b);\n\t\t/* SELF-IPI */\n\t\tvmx_disable_intercept_msr_write_x2apic(0x83f);\n\t}\n\n\tif (enable_ept) {\n\t\tkvm_mmu_set_mask_ptes(0ull,\n\t\t\t(enable_ept_ad_bits) ? VMX_EPT_ACCESS_BIT : 0ull,\n\t\t\t(enable_ept_ad_bits) ? VMX_EPT_DIRTY_BIT : 0ull,\n\t\t\t0ull, VMX_EPT_EXECUTABLE_MASK);\n\t\tept_set_mmio_spte_mask();\n\t\tkvm_enable_tdp();\n\t} else\n\t\tkvm_disable_tdp();\n\n\tupdate_ple_window_actual_max();\n\n\t/*\n\t * Only enable PML when hardware supports PML feature, and both EPT\n\t * and EPT A/D bit features are enabled -- PML depends on them to work.\n\t */\n\tif (!enable_ept || !enable_ept_ad_bits || !cpu_has_vmx_pml())\n\t\tenable_pml = 0;\n\n\tif (!enable_pml) {\n\t\tkvm_x86_ops->slot_enable_log_dirty = NULL;\n\t\tkvm_x86_ops->slot_disable_log_dirty = NULL;\n\t\tkvm_x86_ops->flush_log_dirty = NULL;\n\t\tkvm_x86_ops->enable_log_dirty_pt_masked = NULL;\n\t}\n\n\tkvm_set_posted_intr_wakeup_handler(wakeup_handler);\n\n\treturn alloc_kvm_area();\n\nout8:\n\tfree_page((unsigned long)vmx_vmwrite_bitmap);\nout7:\n\tfree_page((unsigned long)vmx_vmread_bitmap);\nout6:\n\tif (nested)\n\t\tfree_page((unsigned long)vmx_msr_bitmap_nested);\nout5:\n\tfree_page((unsigned long)vmx_msr_bitmap_longmode_x2apic);\nout4:\n\tfree_page((unsigned long)vmx_msr_bitmap_longmode);\nout3:\n\tfree_page((unsigned long)vmx_msr_bitmap_legacy_x2apic);\nout2:\n\tfree_page((unsigned long)vmx_msr_bitmap_legacy);\nout1:\n\tfree_page((unsigned long)vmx_io_bitmap_b);\nout:\n\tfree_page((unsigned long)vmx_io_bitmap_a);\n\n    return r;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstruct kvm_x86_ops *kvm_x86_ops;\n\nint kvm_arch_hardware_setup(void)\n{\n\tint r;\n\n\tr = kvm_x86_ops->hardware_setup();\n\tif (r != 0)\n\t\treturn r;\n\n\tif (kvm_has_tsc_control) {\n\t\t/*\n\t\t * Make sure the user can only configure tsc_khz values that\n\t\t * fit into a signed integer.\n\t\t * A min value is not calculated needed because it will always\n\t\t * be 1 on all machines.\n\t\t */\n\t\tu64 max = min(0x7fffffffULL,\n\t\t\t      __scale_tsc(kvm_max_tsc_scaling_ratio, tsc_khz));\n\t\tkvm_max_guest_tsc_khz = max;\n\n\t\tkvm_default_tsc_scaling_ratio = 1ULL << kvm_tsc_scaling_ratio_frac_bits;\n\t}\n\n\tkvm_init_msr_list();\n\treturn 0;\n}"
  },
  {
    "function_name": "kvm_arch_hardware_disable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "7565-7569",
    "snippet": "void kvm_arch_hardware_disable(void)\n{\n\tkvm_x86_ops->hardware_disable();\n\tdrop_user_return_notifiers();\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct kvm_x86_ops *kvm_x86_ops"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "drop_user_return_notifiers",
          "args": [],
          "line": 7568
        },
        "resolved": true,
        "details": {
          "function_name": "drop_user_return_notifiers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "274-281",
          "snippet": "static void drop_user_return_notifiers(void)\n{\n\tunsigned int cpu = smp_processor_id();\n\tstruct kvm_shared_msrs *smsr = per_cpu_ptr(shared_msrs, cpu);\n\n\tif (smsr->registered)\n\t\tkvm_on_user_return(&smsr->urn);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kvm_shared_msrs __percpu *shared_msrs;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic struct kvm_shared_msrs __percpu *shared_msrs;\n\nstatic void drop_user_return_notifiers(void)\n{\n\tunsigned int cpu = smp_processor_id();\n\tstruct kvm_shared_msrs *smsr = per_cpu_ptr(shared_msrs, cpu);\n\n\tif (smsr->registered)\n\t\tkvm_on_user_return(&smsr->urn);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_x86_ops->hardware_disable",
          "args": [],
          "line": 7567
        },
        "resolved": true,
        "details": {
          "function_name": "hardware_disable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/vmx.c",
          "lines": "3177-3184",
          "snippet": "static void hardware_disable(void)\n{\n\tif (vmm_exclusive) {\n\t\tvmclear_local_loaded_vmcss();\n\t\tkvm_cpu_vmxoff();\n\t}\n\tcr4_clear_bits(X86_CR4_VMXE);\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"trace.h\"",
            "#include <asm/irq_remapping.h>",
            "#include <asm/apic.h>",
            "#include <asm/kexec.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/mce.h>",
            "#include <asm/virtext.h>",
            "#include <asm/vmx.h>",
            "#include <asm/desc.h>",
            "#include <asm/io.h>",
            "#include <asm/cpu.h>",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/hrtimer.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include \"lapic.h\"",
            "#include \"cpuid.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void kvm_cpu_vmxoff(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"trace.h\"\n#include <asm/irq_remapping.h>\n#include <asm/apic.h>\n#include <asm/kexec.h>\n#include <asm/debugreg.h>\n#include <asm/perf_event.h>\n#include <asm/fpu/internal.h>\n#include <asm/mce.h>\n#include <asm/virtext.h>\n#include <asm/vmx.h>\n#include <asm/desc.h>\n#include <asm/io.h>\n#include <asm/cpu.h>\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/hrtimer.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void kvm_cpu_vmxoff(void);\n\nstatic void hardware_disable(void)\n{\n\tif (vmm_exclusive) {\n\t\tvmclear_local_loaded_vmcss();\n\t\tkvm_cpu_vmxoff();\n\t}\n\tcr4_clear_bits(X86_CR4_VMXE);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstruct kvm_x86_ops *kvm_x86_ops;\n\nvoid kvm_arch_hardware_disable(void)\n{\n\tkvm_x86_ops->hardware_disable();\n\tdrop_user_return_notifiers();\n}"
  },
  {
    "function_name": "kvm_arch_hardware_enable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "7474-7563",
    "snippet": "int kvm_arch_hardware_enable(void)\n{\n\tstruct kvm *kvm;\n\tstruct kvm_vcpu *vcpu;\n\tint i;\n\tint ret;\n\tu64 local_tsc;\n\tu64 max_tsc = 0;\n\tbool stable, backwards_tsc = false;\n\n\tkvm_shared_msr_cpu_online();\n\tret = kvm_x86_ops->hardware_enable();\n\tif (ret != 0)\n\t\treturn ret;\n\n\tlocal_tsc = rdtsc();\n\tstable = !check_tsc_unstable();\n\tlist_for_each_entry(kvm, &vm_list, vm_list) {\n\t\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\t\tif (!stable && vcpu->cpu == smp_processor_id())\n\t\t\t\tkvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);\n\t\t\tif (stable && vcpu->arch.last_host_tsc > local_tsc) {\n\t\t\t\tbackwards_tsc = true;\n\t\t\t\tif (vcpu->arch.last_host_tsc > max_tsc)\n\t\t\t\t\tmax_tsc = vcpu->arch.last_host_tsc;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Sometimes, even reliable TSCs go backwards.  This happens on\n\t * platforms that reset TSC during suspend or hibernate actions, but\n\t * maintain synchronization.  We must compensate.  Fortunately, we can\n\t * detect that condition here, which happens early in CPU bringup,\n\t * before any KVM threads can be running.  Unfortunately, we can't\n\t * bring the TSCs fully up to date with real time, as we aren't yet far\n\t * enough into CPU bringup that we know how much real time has actually\n\t * elapsed; our helper function, get_kernel_ns() will be using boot\n\t * variables that haven't been updated yet.\n\t *\n\t * So we simply find the maximum observed TSC above, then record the\n\t * adjustment to TSC in each VCPU.  When the VCPU later gets loaded,\n\t * the adjustment will be applied.  Note that we accumulate\n\t * adjustments, in case multiple suspend cycles happen before some VCPU\n\t * gets a chance to run again.  In the event that no KVM threads get a\n\t * chance to run, we will miss the entire elapsed period, as we'll have\n\t * reset last_host_tsc, so VCPUs will not have the TSC adjusted and may\n\t * loose cycle time.  This isn't too big a deal, since the loss will be\n\t * uniform across all VCPUs (not to mention the scenario is extremely\n\t * unlikely). It is possible that a second hibernate recovery happens\n\t * much faster than a first, causing the observed TSC here to be\n\t * smaller; this would require additional padding adjustment, which is\n\t * why we set last_host_tsc to the local tsc observed here.\n\t *\n\t * N.B. - this code below runs only on platforms with reliable TSC,\n\t * as that is the only way backwards_tsc is set above.  Also note\n\t * that this runs for ALL vcpus, which is not a bug; all VCPUs should\n\t * have the same delta_cyc adjustment applied if backwards_tsc\n\t * is detected.  Note further, this adjustment is only done once,\n\t * as we reset last_host_tsc on all VCPUs to stop this from being\n\t * called multiple times (one for each physical CPU bringup).\n\t *\n\t * Platforms with unreliable TSCs don't have to deal with this, they\n\t * will be compensated by the logic in vcpu_load, which sets the TSC to\n\t * catchup mode.  This will catchup all VCPUs to real time, but cannot\n\t * guarantee that they stay in perfect synchronization.\n\t */\n\tif (backwards_tsc) {\n\t\tu64 delta_cyc = max_tsc - local_tsc;\n\t\tbackwards_tsc_observed = true;\n\t\tlist_for_each_entry(kvm, &vm_list, vm_list) {\n\t\t\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\t\t\tvcpu->arch.tsc_offset_adjustment += delta_cyc;\n\t\t\t\tvcpu->arch.last_host_tsc = local_tsc;\n\t\t\t\tkvm_make_request(KVM_REQ_MASTERCLOCK_UPDATE, vcpu);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * We have to disable TSC offset matching.. if you were\n\t\t\t * booting a VM while issuing an S4 host suspend....\n\t\t\t * you may have some problem.  Solving this issue is\n\t\t\t * left as an exercise to the reader.\n\t\t\t */\n\t\t\tkvm->arch.last_tsc_nsec = 0;\n\t\t\tkvm->arch.last_tsc_write = 0;\n\t\t}\n\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);",
      "struct kvm_x86_ops *kvm_x86_ops"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_make_request",
          "args": [
            "KVM_REQ_MASTERCLOCK_UPDATE",
            "vcpu"
          ],
          "line": 7548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_for_each_vcpu",
          "args": [
            "i",
            "vcpu",
            "kvm"
          ],
          "line": 7545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "kvm",
            "&vm_list",
            "vm_list"
          ],
          "line": 7544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_make_request",
          "args": [
            "KVM_REQ_CLOCK_UPDATE",
            "vcpu"
          ],
          "line": 7494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 7493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_for_each_vcpu",
          "args": [
            "i",
            "vcpu",
            "kvm"
          ],
          "line": 7492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "kvm",
            "&vm_list",
            "vm_list"
          ],
          "line": 7491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_tsc_unstable",
          "args": [],
          "line": 7490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rdtsc",
          "args": [],
          "line": 7489
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_rdtscp_supported",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/vmx.c",
          "lines": "2393-2396",
          "snippet": "static bool vmx_rdtscp_supported(void)\n{\n\treturn cpu_has_vmx_rdtscp();\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"trace.h\"",
            "#include <asm/irq_remapping.h>",
            "#include <asm/apic.h>",
            "#include <asm/kexec.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/mce.h>",
            "#include <asm/virtext.h>",
            "#include <asm/vmx.h>",
            "#include <asm/desc.h>",
            "#include <asm/io.h>",
            "#include <asm/cpu.h>",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/hrtimer.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include \"lapic.h\"",
            "#include \"cpuid.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"trace.h\"\n#include <asm/irq_remapping.h>\n#include <asm/apic.h>\n#include <asm/kexec.h>\n#include <asm/debugreg.h>\n#include <asm/perf_event.h>\n#include <asm/fpu/internal.h>\n#include <asm/mce.h>\n#include <asm/virtext.h>\n#include <asm/vmx.h>\n#include <asm/desc.h>\n#include <asm/io.h>\n#include <asm/cpu.h>\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/hrtimer.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic bool vmx_rdtscp_supported(void)\n{\n\treturn cpu_has_vmx_rdtscp();\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_x86_ops->hardware_enable",
          "args": [],
          "line": 7485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_shared_msr_cpu_online",
          "args": [],
          "line": 7484
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_shared_msr_cpu_online",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "244-250",
          "snippet": "static void kvm_shared_msr_cpu_online(void)\n{\n\tunsigned i;\n\n\tfor (i = 0; i < shared_msrs_global.nr; ++i)\n\t\tshared_msr_update(i, shared_msrs_global.msrs[i]);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void kvm_shared_msr_cpu_online(void)\n{\n\tunsigned i;\n\n\tfor (i = 0; i < shared_msrs_global.nr; ++i)\n\t\tshared_msr_update(i, shared_msrs_global.msrs[i]);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nint kvm_arch_hardware_enable(void)\n{\n\tstruct kvm *kvm;\n\tstruct kvm_vcpu *vcpu;\n\tint i;\n\tint ret;\n\tu64 local_tsc;\n\tu64 max_tsc = 0;\n\tbool stable, backwards_tsc = false;\n\n\tkvm_shared_msr_cpu_online();\n\tret = kvm_x86_ops->hardware_enable();\n\tif (ret != 0)\n\t\treturn ret;\n\n\tlocal_tsc = rdtsc();\n\tstable = !check_tsc_unstable();\n\tlist_for_each_entry(kvm, &vm_list, vm_list) {\n\t\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\t\tif (!stable && vcpu->cpu == smp_processor_id())\n\t\t\t\tkvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);\n\t\t\tif (stable && vcpu->arch.last_host_tsc > local_tsc) {\n\t\t\t\tbackwards_tsc = true;\n\t\t\t\tif (vcpu->arch.last_host_tsc > max_tsc)\n\t\t\t\t\tmax_tsc = vcpu->arch.last_host_tsc;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Sometimes, even reliable TSCs go backwards.  This happens on\n\t * platforms that reset TSC during suspend or hibernate actions, but\n\t * maintain synchronization.  We must compensate.  Fortunately, we can\n\t * detect that condition here, which happens early in CPU bringup,\n\t * before any KVM threads can be running.  Unfortunately, we can't\n\t * bring the TSCs fully up to date with real time, as we aren't yet far\n\t * enough into CPU bringup that we know how much real time has actually\n\t * elapsed; our helper function, get_kernel_ns() will be using boot\n\t * variables that haven't been updated yet.\n\t *\n\t * So we simply find the maximum observed TSC above, then record the\n\t * adjustment to TSC in each VCPU.  When the VCPU later gets loaded,\n\t * the adjustment will be applied.  Note that we accumulate\n\t * adjustments, in case multiple suspend cycles happen before some VCPU\n\t * gets a chance to run again.  In the event that no KVM threads get a\n\t * chance to run, we will miss the entire elapsed period, as we'll have\n\t * reset last_host_tsc, so VCPUs will not have the TSC adjusted and may\n\t * loose cycle time.  This isn't too big a deal, since the loss will be\n\t * uniform across all VCPUs (not to mention the scenario is extremely\n\t * unlikely). It is possible that a second hibernate recovery happens\n\t * much faster than a first, causing the observed TSC here to be\n\t * smaller; this would require additional padding adjustment, which is\n\t * why we set last_host_tsc to the local tsc observed here.\n\t *\n\t * N.B. - this code below runs only on platforms with reliable TSC,\n\t * as that is the only way backwards_tsc is set above.  Also note\n\t * that this runs for ALL vcpus, which is not a bug; all VCPUs should\n\t * have the same delta_cyc adjustment applied if backwards_tsc\n\t * is detected.  Note further, this adjustment is only done once,\n\t * as we reset last_host_tsc on all VCPUs to stop this from being\n\t * called multiple times (one for each physical CPU bringup).\n\t *\n\t * Platforms with unreliable TSCs don't have to deal with this, they\n\t * will be compensated by the logic in vcpu_load, which sets the TSC to\n\t * catchup mode.  This will catchup all VCPUs to real time, but cannot\n\t * guarantee that they stay in perfect synchronization.\n\t */\n\tif (backwards_tsc) {\n\t\tu64 delta_cyc = max_tsc - local_tsc;\n\t\tbackwards_tsc_observed = true;\n\t\tlist_for_each_entry(kvm, &vm_list, vm_list) {\n\t\t\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\t\t\tvcpu->arch.tsc_offset_adjustment += delta_cyc;\n\t\t\t\tvcpu->arch.last_host_tsc = local_tsc;\n\t\t\t\tkvm_make_request(KVM_REQ_MASTERCLOCK_UPDATE, vcpu);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * We have to disable TSC offset matching.. if you were\n\t\t\t * booting a VM while issuing an S4 host suspend....\n\t\t\t * you may have some problem.  Solving this issue is\n\t\t\t * left as an exercise to the reader.\n\t\t\t */\n\t\t\tkvm->arch.last_tsc_nsec = 0;\n\t\t\tkvm->arch.last_tsc_write = 0;\n\t\t}\n\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "kvm_vcpu_deliver_sipi_vector",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "7463-7472",
    "snippet": "void kvm_vcpu_deliver_sipi_vector(struct kvm_vcpu *vcpu, u8 vector)\n{\n\tstruct kvm_segment cs;\n\n\tkvm_get_segment(vcpu, &cs, VCPU_SREG_CS);\n\tcs.selector = vector << 8;\n\tcs.base = vector << 12;\n\tkvm_set_segment(vcpu, &cs, VCPU_SREG_CS);\n\tkvm_rip_write(vcpu, 0);\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_rip_write",
          "args": [
            "vcpu",
            "0"
          ],
          "line": 7471
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_rip_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "32-35",
          "snippet": "static inline void kvm_rip_write(struct kvm_vcpu *vcpu, unsigned long val)\n{\n\tkvm_register_write(vcpu, VCPU_REGS_RIP, val);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void kvm_rip_write(struct kvm_vcpu *vcpu, unsigned long val)\n{\n\tkvm_register_write(vcpu, VCPU_REGS_RIP, val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_set_segment",
          "args": [
            "vcpu",
            "&cs",
            "VCPU_SREG_CS"
          ],
          "line": 7470
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_set_segment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "4151-4155",
          "snippet": "static void kvm_set_segment(struct kvm_vcpu *vcpu,\n\t\t\tstruct kvm_segment *var, int seg)\n{\n\tkvm_x86_ops->set_segment(vcpu, var, seg);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "struct kvm_x86_ops *kvm_x86_ops"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nstatic void kvm_set_segment(struct kvm_vcpu *vcpu,\n\t\t\tstruct kvm_segment *var, int seg)\n{\n\tkvm_x86_ops->set_segment(vcpu, var, seg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_get_segment",
          "args": [
            "vcpu",
            "&cs",
            "VCPU_SREG_CS"
          ],
          "line": 7467
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_get_segment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "4157-4161",
          "snippet": "void kvm_get_segment(struct kvm_vcpu *vcpu,\n\t\t     struct kvm_segment *var, int seg)\n{\n\tkvm_x86_ops->get_segment(vcpu, var, seg);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "struct kvm_x86_ops *kvm_x86_ops"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nvoid kvm_get_segment(struct kvm_vcpu *vcpu,\n\t\t     struct kvm_segment *var, int seg)\n{\n\tkvm_x86_ops->get_segment(vcpu, var, seg);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nvoid kvm_vcpu_deliver_sipi_vector(struct kvm_vcpu *vcpu, u8 vector)\n{\n\tstruct kvm_segment cs;\n\n\tkvm_get_segment(vcpu, &cs, VCPU_SREG_CS);\n\tcs.selector = vector << 8;\n\tcs.base = vector << 12;\n\tkvm_set_segment(vcpu, &cs, VCPU_SREG_CS);\n\tkvm_rip_write(vcpu, 0);\n}"
  },
  {
    "function_name": "kvm_vcpu_reset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "7422-7461",
    "snippet": "void kvm_vcpu_reset(struct kvm_vcpu *vcpu, bool init_event)\n{\n\tvcpu->arch.hflags = 0;\n\n\tatomic_set(&vcpu->arch.nmi_queued, 0);\n\tvcpu->arch.nmi_pending = 0;\n\tvcpu->arch.nmi_injected = false;\n\tkvm_clear_interrupt_queue(vcpu);\n\tkvm_clear_exception_queue(vcpu);\n\n\tmemset(vcpu->arch.db, 0, sizeof(vcpu->arch.db));\n\tkvm_update_dr0123(vcpu);\n\tvcpu->arch.dr6 = DR6_INIT;\n\tkvm_update_dr6(vcpu);\n\tvcpu->arch.dr7 = DR7_FIXED_1;\n\tkvm_update_dr7(vcpu);\n\n\tvcpu->arch.cr2 = 0;\n\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\tvcpu->arch.apf.msr_val = 0;\n\tvcpu->arch.st.msr_val = 0;\n\n\tkvmclock_reset(vcpu);\n\n\tkvm_clear_async_pf_completion_queue(vcpu);\n\tkvm_async_pf_hash_reset(vcpu);\n\tvcpu->arch.apf.halted = false;\n\n\tif (!init_event) {\n\t\tkvm_pmu_reset(vcpu);\n\t\tvcpu->arch.smbase = 0x30000;\n\t}\n\n\tmemset(vcpu->arch.regs, 0, sizeof(vcpu->arch.regs));\n\tvcpu->arch.regs_avail = ~0;\n\tvcpu->arch.regs_dirty = ~0;\n\n\tkvm_x86_ops->vcpu_reset(vcpu, init_event);\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);",
      "struct kvm_x86_ops *kvm_x86_ops"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_x86_ops->vcpu_reset",
          "args": [
            "vcpu",
            "init_event"
          ],
          "line": 7460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "vcpu->arch.regs",
            "0",
            "sizeof(vcpu->arch.regs)"
          ],
          "line": 7456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_pmu_reset",
          "args": [
            "vcpu"
          ],
          "line": 7452
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_pmu_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/pmu.c",
          "lines": "288-294",
          "snippet": "void kvm_pmu_reset(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_pmu *pmu = vcpu_to_pmu(vcpu);\n\n\tirq_work_sync(&pmu->irq_work);\n\tkvm_x86_ops->pmu_ops->reset(vcpu);\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"lapic.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include <asm/perf_event.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include <asm/perf_event.h>\n#include <linux/perf_event.h>\n#include <linux/kvm_host.h>\n#include <linux/types.h>\n\nvoid kvm_pmu_reset(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_pmu *pmu = vcpu_to_pmu(vcpu);\n\n\tirq_work_sync(&pmu->irq_work);\n\tkvm_x86_ops->pmu_ops->reset(vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_async_pf_hash_reset",
          "args": [
            "vcpu"
          ],
          "line": 7448
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_async_pf_hash_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "193-198",
          "snippet": "static inline void kvm_async_pf_hash_reset(struct kvm_vcpu *vcpu)\n{\n\tint i;\n\tfor (i = 0; i < roundup_pow_of_two(ASYNC_PF_PER_VCPU); i++)\n\t\tvcpu->arch.apf.gfns[i] = ~0;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic inline void kvm_async_pf_hash_reset(struct kvm_vcpu *vcpu)\n{\n\tint i;\n\tfor (i = 0; i < roundup_pow_of_two(ASYNC_PF_PER_VCPU); i++)\n\t\tvcpu->arch.apf.gfns[i] = ~0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_clear_async_pf_completion_queue",
          "args": [
            "vcpu"
          ],
          "line": 7447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvmclock_reset",
          "args": [
            "vcpu"
          ],
          "line": 7445
        },
        "resolved": true,
        "details": {
          "function_name": "kvmclock_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "2001-2004",
          "snippet": "static void kvmclock_reset(struct kvm_vcpu *vcpu)\n{\n\tvcpu->arch.pv_time_enabled = false;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic void kvmclock_reset(struct kvm_vcpu *vcpu)\n{\n\tvcpu->arch.pv_time_enabled = false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_make_request",
          "args": [
            "KVM_REQ_EVENT",
            "vcpu"
          ],
          "line": 7441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_update_dr7",
          "args": [
            "vcpu"
          ],
          "line": 7437
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_update_dr7",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "842-854",
          "snippet": "static void kvm_update_dr7(struct kvm_vcpu *vcpu)\n{\n\tunsigned long dr7;\n\n\tif (vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP)\n\t\tdr7 = vcpu->arch.guest_debug_dr7;\n\telse\n\t\tdr7 = vcpu->arch.dr7;\n\tkvm_x86_ops->set_dr7(vcpu, dr7);\n\tvcpu->arch.switch_db_regs &= ~KVM_DEBUGREG_BP_ENABLED;\n\tif (dr7 & DR7_BP_EN_MASK)\n\t\tvcpu->arch.switch_db_regs |= KVM_DEBUGREG_BP_ENABLED;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "struct kvm_x86_ops *kvm_x86_ops"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nstatic void kvm_update_dr7(struct kvm_vcpu *vcpu)\n{\n\tunsigned long dr7;\n\n\tif (vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP)\n\t\tdr7 = vcpu->arch.guest_debug_dr7;\n\telse\n\t\tdr7 = vcpu->arch.dr7;\n\tkvm_x86_ops->set_dr7(vcpu, dr7);\n\tvcpu->arch.switch_db_regs &= ~KVM_DEBUGREG_BP_ENABLED;\n\tif (dr7 & DR7_BP_EN_MASK)\n\t\tvcpu->arch.switch_db_regs |= KVM_DEBUGREG_BP_ENABLED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_update_dr6",
          "args": [
            "vcpu"
          ],
          "line": 7435
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_update_dr6",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "836-840",
          "snippet": "static void kvm_update_dr6(struct kvm_vcpu *vcpu)\n{\n\tif (!(vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP))\n\t\tkvm_x86_ops->set_dr6(vcpu, vcpu->arch.dr6);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "struct kvm_x86_ops *kvm_x86_ops"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nstatic void kvm_update_dr6(struct kvm_vcpu *vcpu)\n{\n\tif (!(vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP))\n\t\tkvm_x86_ops->set_dr6(vcpu, vcpu->arch.dr6);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_update_dr0123",
          "args": [
            "vcpu"
          ],
          "line": 7433
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_update_dr0123",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "825-834",
          "snippet": "static void kvm_update_dr0123(struct kvm_vcpu *vcpu)\n{\n\tint i;\n\n\tif (!(vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP)) {\n\t\tfor (i = 0; i < KVM_NR_DB_REGS; i++)\n\t\t\tvcpu->arch.eff_db[i] = vcpu->arch.db[i];\n\t\tvcpu->arch.switch_db_regs |= KVM_DEBUGREG_RELOAD;\n\t}\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic void kvm_update_dr0123(struct kvm_vcpu *vcpu)\n{\n\tint i;\n\n\tif (!(vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP)) {\n\t\tfor (i = 0; i < KVM_NR_DB_REGS; i++)\n\t\t\tvcpu->arch.eff_db[i] = vcpu->arch.db[i];\n\t\tvcpu->arch.switch_db_regs |= KVM_DEBUGREG_RELOAD;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "vcpu->arch.db",
            "0",
            "sizeof(vcpu->arch.db)"
          ],
          "line": 7432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_clear_exception_queue",
          "args": [
            "vcpu"
          ],
          "line": 7430
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_clear_exception_queue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.h",
          "lines": "9-12",
          "snippet": "static inline void kvm_clear_exception_queue(struct kvm_vcpu *vcpu)\n{\n\tvcpu->arch.exception.pending = false;\n}",
          "includes": [
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline void kvm_clear_exception_queue(struct kvm_vcpu *vcpu)\n{\n\tvcpu->arch.exception.pending = false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_clear_interrupt_queue",
          "args": [
            "vcpu"
          ],
          "line": 7429
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_clear_interrupt_queue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.h",
          "lines": "22-25",
          "snippet": "static inline void kvm_clear_interrupt_queue(struct kvm_vcpu *vcpu)\n{\n\tvcpu->arch.interrupt.pending = false;\n}",
          "includes": [
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline void kvm_clear_interrupt_queue(struct kvm_vcpu *vcpu)\n{\n\tvcpu->arch.interrupt.pending = false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&vcpu->arch.nmi_queued",
            "0"
          ],
          "line": 7426
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nvoid kvm_vcpu_reset(struct kvm_vcpu *vcpu, bool init_event)\n{\n\tvcpu->arch.hflags = 0;\n\n\tatomic_set(&vcpu->arch.nmi_queued, 0);\n\tvcpu->arch.nmi_pending = 0;\n\tvcpu->arch.nmi_injected = false;\n\tkvm_clear_interrupt_queue(vcpu);\n\tkvm_clear_exception_queue(vcpu);\n\n\tmemset(vcpu->arch.db, 0, sizeof(vcpu->arch.db));\n\tkvm_update_dr0123(vcpu);\n\tvcpu->arch.dr6 = DR6_INIT;\n\tkvm_update_dr6(vcpu);\n\tvcpu->arch.dr7 = DR7_FIXED_1;\n\tkvm_update_dr7(vcpu);\n\n\tvcpu->arch.cr2 = 0;\n\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\tvcpu->arch.apf.msr_val = 0;\n\tvcpu->arch.st.msr_val = 0;\n\n\tkvmclock_reset(vcpu);\n\n\tkvm_clear_async_pf_completion_queue(vcpu);\n\tkvm_async_pf_hash_reset(vcpu);\n\tvcpu->arch.apf.halted = false;\n\n\tif (!init_event) {\n\t\tkvm_pmu_reset(vcpu);\n\t\tvcpu->arch.smbase = 0x30000;\n\t}\n\n\tmemset(vcpu->arch.regs, 0, sizeof(vcpu->arch.regs));\n\tvcpu->arch.regs_avail = ~0;\n\tvcpu->arch.regs_dirty = ~0;\n\n\tkvm_x86_ops->vcpu_reset(vcpu, init_event);\n}"
  },
  {
    "function_name": "kvm_arch_vcpu_destroy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "7409-7420",
    "snippet": "void kvm_arch_vcpu_destroy(struct kvm_vcpu *vcpu)\n{\n\tint r;\n\tvcpu->arch.apf.msr_val = 0;\n\n\tr = vcpu_load(vcpu);\n\tBUG_ON(r);\n\tkvm_mmu_unload(vcpu);\n\tvcpu_put(vcpu);\n\n\tkvm_x86_ops->vcpu_free(vcpu);\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);",
      "struct kvm_x86_ops *kvm_x86_ops"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_x86_ops->vcpu_free",
          "args": [
            "vcpu"
          ],
          "line": 7419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vcpu_put",
          "args": [
            "vcpu"
          ],
          "line": 7417
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_arch_vcpu_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "2761-2766",
          "snippet": "void kvm_arch_vcpu_put(struct kvm_vcpu *vcpu)\n{\n\tkvm_x86_ops->vcpu_put(vcpu);\n\tkvm_put_guest_fpu(vcpu);\n\tvcpu->arch.last_host_tsc = rdtsc();\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "struct kvm_x86_ops *kvm_x86_ops"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nvoid kvm_arch_vcpu_put(struct kvm_vcpu *vcpu)\n{\n\tkvm_x86_ops->vcpu_put(vcpu);\n\tkvm_put_guest_fpu(vcpu);\n\tvcpu->arch.last_host_tsc = rdtsc();\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_mmu_unload",
          "args": [
            "vcpu"
          ],
          "line": 7416
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_unload",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "4255-4259",
          "snippet": "void kvm_mmu_unload(struct kvm_vcpu *vcpu)\n{\n\tmmu_free_roots(vcpu);\n\tWARN_ON(VALID_PAGE(vcpu->arch.mmu.root_hpa));\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nvoid kvm_mmu_unload(struct kvm_vcpu *vcpu)\n{\n\tmmu_free_roots(vcpu);\n\tWARN_ON(VALID_PAGE(vcpu->arch.mmu.root_hpa));\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "r"
          ],
          "line": 7415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vcpu_load",
          "args": [
            "vcpu"
          ],
          "line": 7414
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nvoid kvm_arch_vcpu_destroy(struct kvm_vcpu *vcpu)\n{\n\tint r;\n\tvcpu->arch.apf.msr_val = 0;\n\n\tr = vcpu_load(vcpu);\n\tBUG_ON(r);\n\tkvm_mmu_unload(vcpu);\n\tvcpu_put(vcpu);\n\n\tkvm_x86_ops->vcpu_free(vcpu);\n}"
  },
  {
    "function_name": "kvm_arch_vcpu_postcreate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "7389-7407",
    "snippet": "void kvm_arch_vcpu_postcreate(struct kvm_vcpu *vcpu)\n{\n\tstruct msr_data msr;\n\tstruct kvm *kvm = vcpu->kvm;\n\n\tif (vcpu_load(vcpu))\n\t\treturn;\n\tmsr.data = 0x0;\n\tmsr.index = MSR_IA32_TSC;\n\tmsr.host_initiated = true;\n\tkvm_write_tsc(vcpu, &msr);\n\tvcpu_put(vcpu);\n\n\tif (!kvmclock_periodic_sync)\n\t\treturn;\n\n\tschedule_delayed_work(&kvm->arch.kvmclock_sync_work,\n\t\t\t\t\tKVMCLOCK_SYNC_PERIOD);\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define KVMCLOCK_SYNC_PERIOD (300 * HZ)"
    ],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "schedule_delayed_work",
          "args": [
            "&kvm->arch.kvmclock_sync_work",
            "KVMCLOCK_SYNC_PERIOD"
          ],
          "line": 7405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vcpu_put",
          "args": [
            "vcpu"
          ],
          "line": 7400
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_arch_vcpu_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "2761-2766",
          "snippet": "void kvm_arch_vcpu_put(struct kvm_vcpu *vcpu)\n{\n\tkvm_x86_ops->vcpu_put(vcpu);\n\tkvm_put_guest_fpu(vcpu);\n\tvcpu->arch.last_host_tsc = rdtsc();\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "struct kvm_x86_ops *kvm_x86_ops"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nvoid kvm_arch_vcpu_put(struct kvm_vcpu *vcpu)\n{\n\tkvm_x86_ops->vcpu_put(vcpu);\n\tkvm_put_guest_fpu(vcpu);\n\tvcpu->arch.last_host_tsc = rdtsc();\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_write_tsc",
          "args": [
            "vcpu",
            "&msr"
          ],
          "line": 7399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vcpu_load",
          "args": [
            "vcpu"
          ],
          "line": 7394
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define KVMCLOCK_SYNC_PERIOD (300 * HZ)\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nvoid kvm_arch_vcpu_postcreate(struct kvm_vcpu *vcpu)\n{\n\tstruct msr_data msr;\n\tstruct kvm *kvm = vcpu->kvm;\n\n\tif (vcpu_load(vcpu))\n\t\treturn;\n\tmsr.data = 0x0;\n\tmsr.index = MSR_IA32_TSC;\n\tmsr.host_initiated = true;\n\tkvm_write_tsc(vcpu, &msr);\n\tvcpu_put(vcpu);\n\n\tif (!kvmclock_periodic_sync)\n\t\treturn;\n\n\tschedule_delayed_work(&kvm->arch.kvmclock_sync_work,\n\t\t\t\t\tKVMCLOCK_SYNC_PERIOD);\n}"
  },
  {
    "function_name": "kvm_arch_vcpu_setup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "7375-7387",
    "snippet": "int kvm_arch_vcpu_setup(struct kvm_vcpu *vcpu)\n{\n\tint r;\n\n\tkvm_vcpu_mtrr_init(vcpu);\n\tr = vcpu_load(vcpu);\n\tif (r)\n\t\treturn r;\n\tkvm_vcpu_reset(vcpu, false);\n\tkvm_mmu_setup(vcpu);\n\tvcpu_put(vcpu);\n\treturn r;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vcpu_put",
          "args": [
            "vcpu"
          ],
          "line": 7385
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_arch_vcpu_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "2761-2766",
          "snippet": "void kvm_arch_vcpu_put(struct kvm_vcpu *vcpu)\n{\n\tkvm_x86_ops->vcpu_put(vcpu);\n\tkvm_put_guest_fpu(vcpu);\n\tvcpu->arch.last_host_tsc = rdtsc();\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "struct kvm_x86_ops *kvm_x86_ops"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nvoid kvm_arch_vcpu_put(struct kvm_vcpu *vcpu)\n{\n\tkvm_x86_ops->vcpu_put(vcpu);\n\tkvm_put_guest_fpu(vcpu);\n\tvcpu->arch.last_host_tsc = rdtsc();\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_mmu_setup",
          "args": [
            "vcpu"
          ],
          "line": 7384
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_setup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "4606-4611",
          "snippet": "void kvm_mmu_setup(struct kvm_vcpu *vcpu)\n{\n\tMMU_WARN_ON(VALID_PAGE(vcpu->arch.mmu.root_hpa));\n\n\tinit_kvm_mmu(vcpu);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nvoid kvm_mmu_setup(struct kvm_vcpu *vcpu)\n{\n\tMMU_WARN_ON(VALID_PAGE(vcpu->arch.mmu.root_hpa));\n\n\tinit_kvm_mmu(vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_reset",
          "args": [
            "vcpu",
            "false"
          ],
          "line": 7383
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_vcpu_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "7422-7461",
          "snippet": "void kvm_vcpu_reset(struct kvm_vcpu *vcpu, bool init_event)\n{\n\tvcpu->arch.hflags = 0;\n\n\tatomic_set(&vcpu->arch.nmi_queued, 0);\n\tvcpu->arch.nmi_pending = 0;\n\tvcpu->arch.nmi_injected = false;\n\tkvm_clear_interrupt_queue(vcpu);\n\tkvm_clear_exception_queue(vcpu);\n\n\tmemset(vcpu->arch.db, 0, sizeof(vcpu->arch.db));\n\tkvm_update_dr0123(vcpu);\n\tvcpu->arch.dr6 = DR6_INIT;\n\tkvm_update_dr6(vcpu);\n\tvcpu->arch.dr7 = DR7_FIXED_1;\n\tkvm_update_dr7(vcpu);\n\n\tvcpu->arch.cr2 = 0;\n\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\tvcpu->arch.apf.msr_val = 0;\n\tvcpu->arch.st.msr_val = 0;\n\n\tkvmclock_reset(vcpu);\n\n\tkvm_clear_async_pf_completion_queue(vcpu);\n\tkvm_async_pf_hash_reset(vcpu);\n\tvcpu->arch.apf.halted = false;\n\n\tif (!init_event) {\n\t\tkvm_pmu_reset(vcpu);\n\t\tvcpu->arch.smbase = 0x30000;\n\t}\n\n\tmemset(vcpu->arch.regs, 0, sizeof(vcpu->arch.regs));\n\tvcpu->arch.regs_avail = ~0;\n\tvcpu->arch.regs_dirty = ~0;\n\n\tkvm_x86_ops->vcpu_reset(vcpu, init_event);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "struct kvm_x86_ops *kvm_x86_ops"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nvoid kvm_vcpu_reset(struct kvm_vcpu *vcpu, bool init_event)\n{\n\tvcpu->arch.hflags = 0;\n\n\tatomic_set(&vcpu->arch.nmi_queued, 0);\n\tvcpu->arch.nmi_pending = 0;\n\tvcpu->arch.nmi_injected = false;\n\tkvm_clear_interrupt_queue(vcpu);\n\tkvm_clear_exception_queue(vcpu);\n\n\tmemset(vcpu->arch.db, 0, sizeof(vcpu->arch.db));\n\tkvm_update_dr0123(vcpu);\n\tvcpu->arch.dr6 = DR6_INIT;\n\tkvm_update_dr6(vcpu);\n\tvcpu->arch.dr7 = DR7_FIXED_1;\n\tkvm_update_dr7(vcpu);\n\n\tvcpu->arch.cr2 = 0;\n\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\tvcpu->arch.apf.msr_val = 0;\n\tvcpu->arch.st.msr_val = 0;\n\n\tkvmclock_reset(vcpu);\n\n\tkvm_clear_async_pf_completion_queue(vcpu);\n\tkvm_async_pf_hash_reset(vcpu);\n\tvcpu->arch.apf.halted = false;\n\n\tif (!init_event) {\n\t\tkvm_pmu_reset(vcpu);\n\t\tvcpu->arch.smbase = 0x30000;\n\t}\n\n\tmemset(vcpu->arch.regs, 0, sizeof(vcpu->arch.regs));\n\tvcpu->arch.regs_avail = ~0;\n\tvcpu->arch.regs_dirty = ~0;\n\n\tkvm_x86_ops->vcpu_reset(vcpu, init_event);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vcpu_load",
          "args": [
            "vcpu"
          ],
          "line": 7380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_mtrr_init",
          "args": [
            "vcpu"
          ],
          "line": 7379
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_vcpu_mtrr_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mtrr.c",
          "lines": "447-450",
          "snippet": "void kvm_vcpu_mtrr_init(struct kvm_vcpu *vcpu)\n{\n\tINIT_LIST_HEAD(&vcpu->arch.mtrr_state.head);\n}",
          "includes": [
            "#include \"mmu.h\"",
            "#include \"cpuid.h\"",
            "#include <asm/mtrr.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mmu.h\"\n#include \"cpuid.h\"\n#include <asm/mtrr.h>\n#include <linux/kvm_host.h>\n\nvoid kvm_vcpu_mtrr_init(struct kvm_vcpu *vcpu)\n{\n\tINIT_LIST_HEAD(&vcpu->arch.mtrr_state.head);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nint kvm_arch_vcpu_setup(struct kvm_vcpu *vcpu)\n{\n\tint r;\n\n\tkvm_vcpu_mtrr_init(vcpu);\n\tr = vcpu_load(vcpu);\n\tif (r)\n\t\treturn r;\n\tkvm_vcpu_reset(vcpu, false);\n\tkvm_mmu_setup(vcpu);\n\tvcpu_put(vcpu);\n\treturn r;\n}"
  },
  {
    "function_name": "kvm_arch_vcpu_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "7360-7373",
    "snippet": "struct kvm_vcpu *kvm_arch_vcpu_create(struct kvm *kvm,\n\t\t\t\t\t\tunsigned int id)\n{\n\tstruct kvm_vcpu *vcpu;\n\n\tif (check_tsc_unstable() && atomic_read(&kvm->online_vcpus) != 0)\n\t\tprintk_once(KERN_WARNING\n\t\t\"kvm: SMP vm created on host with unstable TSC; \"\n\t\t\"guest TSC will not be reliable\\n\");\n\n\tvcpu = kvm_x86_ops->vcpu_create(kvm, id);\n\n\treturn vcpu;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);",
      "struct kvm_x86_ops *kvm_x86_ops"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_x86_ops->vcpu_create",
          "args": [
            "kvm",
            "id"
          ],
          "line": 7370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk_once",
          "args": [
            "KERN_WARNING\n\t\t\"kvm: SMP vm created on host with unstable TSC; \"\n\t\t\"guest TSC will not be reliable\\n\""
          ],
          "line": 7366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&kvm->online_vcpus"
          ],
          "line": 7365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_tsc_unstable",
          "args": [],
          "line": 7365
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nstruct kvm_vcpu *kvm_arch_vcpu_create(struct kvm *kvm,\n\t\t\t\t\t\tunsigned int id)\n{\n\tstruct kvm_vcpu *vcpu;\n\n\tif (check_tsc_unstable() && atomic_read(&kvm->online_vcpus) != 0)\n\t\tprintk_once(KERN_WARNING\n\t\t\"kvm: SMP vm created on host with unstable TSC; \"\n\t\t\"guest TSC will not be reliable\\n\");\n\n\tvcpu = kvm_x86_ops->vcpu_create(kvm, id);\n\n\treturn vcpu;\n}"
  },
  {
    "function_name": "kvm_arch_vcpu_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "7352-7358",
    "snippet": "void kvm_arch_vcpu_free(struct kvm_vcpu *vcpu)\n{\n\tkvmclock_reset(vcpu);\n\n\tfree_cpumask_var(vcpu->arch.wbinvd_dirty_mask);\n\tkvm_x86_ops->vcpu_free(vcpu);\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);",
      "struct kvm_x86_ops *kvm_x86_ops"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_x86_ops->vcpu_free",
          "args": [
            "vcpu"
          ],
          "line": 7357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_cpumask_var",
          "args": [
            "vcpu->arch.wbinvd_dirty_mask"
          ],
          "line": 7356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvmclock_reset",
          "args": [
            "vcpu"
          ],
          "line": 7354
        },
        "resolved": true,
        "details": {
          "function_name": "kvmclock_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "2001-2004",
          "snippet": "static void kvmclock_reset(struct kvm_vcpu *vcpu)\n{\n\tvcpu->arch.pv_time_enabled = false;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic void kvmclock_reset(struct kvm_vcpu *vcpu)\n{\n\tvcpu->arch.pv_time_enabled = false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nvoid kvm_arch_vcpu_free(struct kvm_vcpu *vcpu)\n{\n\tkvmclock_reset(vcpu);\n\n\tfree_cpumask_var(vcpu->arch.wbinvd_dirty_mask);\n\tkvm_x86_ops->vcpu_free(vcpu);\n}"
  },
  {
    "function_name": "kvm_put_guest_fpu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "7328-7350",
    "snippet": "void kvm_put_guest_fpu(struct kvm_vcpu *vcpu)\n{\n\tif (!vcpu->guest_fpu_loaded) {\n\t\tvcpu->fpu_counter = 0;\n\t\treturn;\n\t}\n\n\tvcpu->guest_fpu_loaded = 0;\n\tcopy_fpregs_to_fpstate(&vcpu->arch.guest_fpu);\n\t__kernel_fpu_end();\n\t++vcpu->stat.fpu_reload;\n\t/*\n\t * If using eager FPU mode, or if the guest is a frequent user\n\t * of the FPU, just leave the FPU active for next time.\n\t * Every 255 times fpu_counter rolls over to 0; a guest that uses\n\t * the FPU in bursts will revert to loading it on demand.\n\t */\n\tif (!use_eager_fpu()) {\n\t\tif (++vcpu->fpu_counter < 5)\n\t\t\tkvm_make_request(KVM_REQ_DEACTIVATE_FPU, vcpu);\n\t}\n\ttrace_kvm_fpu(0);\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_kvm_fpu",
          "args": [
            "0"
          ],
          "line": 7349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_make_request",
          "args": [
            "KVM_REQ_DEACTIVATE_FPU",
            "vcpu"
          ],
          "line": 7347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "use_eager_fpu",
          "args": [],
          "line": 7345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__kernel_fpu_end",
          "args": [],
          "line": 7337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_fpregs_to_fpstate",
          "args": [
            "&vcpu->arch.guest_fpu"
          ],
          "line": 7336
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nvoid kvm_put_guest_fpu(struct kvm_vcpu *vcpu)\n{\n\tif (!vcpu->guest_fpu_loaded) {\n\t\tvcpu->fpu_counter = 0;\n\t\treturn;\n\t}\n\n\tvcpu->guest_fpu_loaded = 0;\n\tcopy_fpregs_to_fpstate(&vcpu->arch.guest_fpu);\n\t__kernel_fpu_end();\n\t++vcpu->stat.fpu_reload;\n\t/*\n\t * If using eager FPU mode, or if the guest is a frequent user\n\t * of the FPU, just leave the FPU active for next time.\n\t * Every 255 times fpu_counter rolls over to 0; a guest that uses\n\t * the FPU in bursts will revert to loading it on demand.\n\t */\n\tif (!use_eager_fpu()) {\n\t\tif (++vcpu->fpu_counter < 5)\n\t\t\tkvm_make_request(KVM_REQ_DEACTIVATE_FPU, vcpu);\n\t}\n\ttrace_kvm_fpu(0);\n}"
  },
  {
    "function_name": "kvm_load_guest_fpu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "7312-7326",
    "snippet": "void kvm_load_guest_fpu(struct kvm_vcpu *vcpu)\n{\n\tif (vcpu->guest_fpu_loaded)\n\t\treturn;\n\n\t/*\n\t * Restore all possible states in the guest,\n\t * and assume host would use all available bits.\n\t * Guest xcr0 would be loaded later.\n\t */\n\tvcpu->guest_fpu_loaded = 1;\n\t__kernel_fpu_begin();\n\t__copy_kernel_to_fpregs(&vcpu->arch.guest_fpu.state);\n\ttrace_kvm_fpu(1);\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_kvm_fpu",
          "args": [
            "1"
          ],
          "line": 7325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__copy_kernel_to_fpregs",
          "args": [
            "&vcpu->arch.guest_fpu.state"
          ],
          "line": 7324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__kernel_fpu_begin",
          "args": [],
          "line": 7323
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nvoid kvm_load_guest_fpu(struct kvm_vcpu *vcpu)\n{\n\tif (vcpu->guest_fpu_loaded)\n\t\treturn;\n\n\t/*\n\t * Restore all possible states in the guest,\n\t * and assume host would use all available bits.\n\t * Guest xcr0 would be loaded later.\n\t */\n\tvcpu->guest_fpu_loaded = 1;\n\t__kernel_fpu_begin();\n\t__copy_kernel_to_fpregs(&vcpu->arch.guest_fpu.state);\n\ttrace_kvm_fpu(1);\n}"
  },
  {
    "function_name": "fx_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "7297-7310",
    "snippet": "static void fx_init(struct kvm_vcpu *vcpu)\n{\n\tfpstate_init(&vcpu->arch.guest_fpu.state);\n\tif (cpu_has_xsaves)\n\t\tvcpu->arch.guest_fpu.state.xsave.header.xcomp_bv =\n\t\t\thost_xcr0 | XSTATE_COMPACTION_ENABLED;\n\n\t/*\n\t * Ensure guest xcr0 is valid for loading\n\t */\n\tvcpu->arch.xcr0 = XFEATURE_MASK_FP;\n\n\tvcpu->arch.cr0 |= X86_CR0_ET;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define XSTATE_COMPACTION_ENABLED (1ULL << 63)"
    ],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);",
      "u64 __read_mostly host_xcr0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fpstate_init",
          "args": [
            "&vcpu->arch.guest_fpu.state"
          ],
          "line": 7299
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define XSTATE_COMPACTION_ENABLED (1ULL << 63)\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nu64 __read_mostly host_xcr0;\n\nstatic void fx_init(struct kvm_vcpu *vcpu)\n{\n\tfpstate_init(&vcpu->arch.guest_fpu.state);\n\tif (cpu_has_xsaves)\n\t\tvcpu->arch.guest_fpu.state.xsave.header.xcomp_bv =\n\t\t\thost_xcr0 | XSTATE_COMPACTION_ENABLED;\n\n\t/*\n\t * Ensure guest xcr0 is valid for loading\n\t */\n\tvcpu->arch.xcr0 = XFEATURE_MASK_FP;\n\n\tvcpu->arch.cr0 |= X86_CR0_ET;\n}"
  },
  {
    "function_name": "kvm_arch_vcpu_ioctl_set_fpu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "7280-7295",
    "snippet": "int kvm_arch_vcpu_ioctl_set_fpu(struct kvm_vcpu *vcpu, struct kvm_fpu *fpu)\n{\n\tstruct fxregs_state *fxsave =\n\t\t\t&vcpu->arch.guest_fpu.state.fxsave;\n\n\tmemcpy(fxsave->st_space, fpu->fpr, 128);\n\tfxsave->cwd = fpu->fcw;\n\tfxsave->swd = fpu->fsw;\n\tfxsave->twd = fpu->ftwx;\n\tfxsave->fop = fpu->last_opcode;\n\tfxsave->rip = fpu->last_ip;\n\tfxsave->rdp = fpu->last_dp;\n\tmemcpy(fxsave->xmm_space, fpu->xmm, sizeof fxsave->xmm_space);\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "fxsave->xmm_space",
            "fpu->xmm",
            "sizeof fxsave->xmm_space"
          ],
          "line": 7292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "fxsave->st_space",
            "fpu->fpr",
            "128"
          ],
          "line": 7285
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nint kvm_arch_vcpu_ioctl_set_fpu(struct kvm_vcpu *vcpu, struct kvm_fpu *fpu)\n{\n\tstruct fxregs_state *fxsave =\n\t\t\t&vcpu->arch.guest_fpu.state.fxsave;\n\n\tmemcpy(fxsave->st_space, fpu->fpr, 128);\n\tfxsave->cwd = fpu->fcw;\n\tfxsave->swd = fpu->fsw;\n\tfxsave->twd = fpu->ftwx;\n\tfxsave->fop = fpu->last_opcode;\n\tfxsave->rip = fpu->last_ip;\n\tfxsave->rdp = fpu->last_dp;\n\tmemcpy(fxsave->xmm_space, fpu->xmm, sizeof fxsave->xmm_space);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "kvm_arch_vcpu_ioctl_get_fpu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "7263-7278",
    "snippet": "int kvm_arch_vcpu_ioctl_get_fpu(struct kvm_vcpu *vcpu, struct kvm_fpu *fpu)\n{\n\tstruct fxregs_state *fxsave =\n\t\t\t&vcpu->arch.guest_fpu.state.fxsave;\n\n\tmemcpy(fpu->fpr, fxsave->st_space, 128);\n\tfpu->fcw = fxsave->cwd;\n\tfpu->fsw = fxsave->swd;\n\tfpu->ftwx = fxsave->twd;\n\tfpu->last_opcode = fxsave->fop;\n\tfpu->last_ip = fxsave->rip;\n\tfpu->last_dp = fxsave->rdp;\n\tmemcpy(fpu->xmm, fxsave->xmm_space, sizeof fxsave->xmm_space);\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "fpu->xmm",
            "fxsave->xmm_space",
            "sizeof fxsave->xmm_space"
          ],
          "line": 7275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "fpu->fpr",
            "fxsave->st_space",
            "128"
          ],
          "line": 7268
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nint kvm_arch_vcpu_ioctl_get_fpu(struct kvm_vcpu *vcpu, struct kvm_fpu *fpu)\n{\n\tstruct fxregs_state *fxsave =\n\t\t\t&vcpu->arch.guest_fpu.state.fxsave;\n\n\tmemcpy(fpu->fpr, fxsave->st_space, 128);\n\tfpu->fcw = fxsave->cwd;\n\tfpu->fsw = fxsave->swd;\n\tfpu->ftwx = fxsave->twd;\n\tfpu->last_opcode = fxsave->fop;\n\tfpu->last_ip = fxsave->rip;\n\tfpu->last_dp = fxsave->rdp;\n\tmemcpy(fpu->xmm, fxsave->xmm_space, sizeof fxsave->xmm_space);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "kvm_arch_vcpu_ioctl_translate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "7245-7261",
    "snippet": "int kvm_arch_vcpu_ioctl_translate(struct kvm_vcpu *vcpu,\n\t\t\t\t    struct kvm_translation *tr)\n{\n\tunsigned long vaddr = tr->linear_address;\n\tgpa_t gpa;\n\tint idx;\n\n\tidx = srcu_read_lock(&vcpu->kvm->srcu);\n\tgpa = kvm_mmu_gva_to_gpa_system(vcpu, vaddr, NULL);\n\tsrcu_read_unlock(&vcpu->kvm->srcu, idx);\n\ttr->physical_address = gpa;\n\ttr->valid = gpa != UNMAPPED_GVA;\n\ttr->writeable = 1;\n\ttr->usermode = 0;\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "srcu_read_unlock",
          "args": [
            "&vcpu->kvm->srcu",
            "idx"
          ],
          "line": 7254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_mmu_gva_to_gpa_system",
          "args": [
            "vcpu",
            "vaddr",
            "NULL"
          ],
          "line": 7253
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_gva_to_gpa_system",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "4201-4205",
          "snippet": "gpa_t kvm_mmu_gva_to_gpa_system(struct kvm_vcpu *vcpu, gva_t gva,\n\t\t\t\tstruct x86_exception *exception)\n{\n\treturn vcpu->arch.walk_mmu->gva_to_gpa(vcpu, gva, 0, exception);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\ngpa_t kvm_mmu_gva_to_gpa_system(struct kvm_vcpu *vcpu, gva_t gva,\n\t\t\t\tstruct x86_exception *exception)\n{\n\treturn vcpu->arch.walk_mmu->gva_to_gpa(vcpu, gva, 0, exception);\n}"
        }
      },
      {
        "call_info": {
          "callee": "srcu_read_lock",
          "args": [
            "&vcpu->kvm->srcu"
          ],
          "line": 7252
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nint kvm_arch_vcpu_ioctl_translate(struct kvm_vcpu *vcpu,\n\t\t\t\t    struct kvm_translation *tr)\n{\n\tunsigned long vaddr = tr->linear_address;\n\tgpa_t gpa;\n\tint idx;\n\n\tidx = srcu_read_lock(&vcpu->kvm->srcu);\n\tgpa = kvm_mmu_gva_to_gpa_system(vcpu, vaddr, NULL);\n\tsrcu_read_unlock(&vcpu->kvm->srcu, idx);\n\ttr->physical_address = gpa;\n\ttr->valid = gpa != UNMAPPED_GVA;\n\ttr->writeable = 1;\n\ttr->usermode = 0;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "kvm_arch_vcpu_ioctl_set_guest_debug",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "7187-7240",
    "snippet": "int kvm_arch_vcpu_ioctl_set_guest_debug(struct kvm_vcpu *vcpu,\n\t\t\t\t\tstruct kvm_guest_debug *dbg)\n{\n\tunsigned long rflags;\n\tint i, r;\n\n\tif (dbg->control & (KVM_GUESTDBG_INJECT_DB | KVM_GUESTDBG_INJECT_BP)) {\n\t\tr = -EBUSY;\n\t\tif (vcpu->arch.exception.pending)\n\t\t\tgoto out;\n\t\tif (dbg->control & KVM_GUESTDBG_INJECT_DB)\n\t\t\tkvm_queue_exception(vcpu, DB_VECTOR);\n\t\telse\n\t\t\tkvm_queue_exception(vcpu, BP_VECTOR);\n\t}\n\n\t/*\n\t * Read rflags as long as potentially injected trace flags are still\n\t * filtered out.\n\t */\n\trflags = kvm_get_rflags(vcpu);\n\n\tvcpu->guest_debug = dbg->control;\n\tif (!(vcpu->guest_debug & KVM_GUESTDBG_ENABLE))\n\t\tvcpu->guest_debug = 0;\n\n\tif (vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP) {\n\t\tfor (i = 0; i < KVM_NR_DB_REGS; ++i)\n\t\t\tvcpu->arch.eff_db[i] = dbg->arch.debugreg[i];\n\t\tvcpu->arch.guest_debug_dr7 = dbg->arch.debugreg[7];\n\t} else {\n\t\tfor (i = 0; i < KVM_NR_DB_REGS; i++)\n\t\t\tvcpu->arch.eff_db[i] = vcpu->arch.db[i];\n\t}\n\tkvm_update_dr7(vcpu);\n\n\tif (vcpu->guest_debug & KVM_GUESTDBG_SINGLESTEP)\n\t\tvcpu->arch.singlestep_rip = kvm_rip_read(vcpu) +\n\t\t\tget_segment_base(vcpu, VCPU_SREG_CS);\n\n\t/*\n\t * Trigger an rflags update that will inject or remove the trace\n\t * flags.\n\t */\n\tkvm_set_rflags(vcpu, rflags);\n\n\tkvm_x86_ops->update_bp_intercept(vcpu);\n\n\tr = 0;\n\nout:\n\n\treturn r;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);",
      "static void __kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags);",
      "struct kvm_x86_ops *kvm_x86_ops"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_x86_ops->update_bp_intercept",
          "args": [
            "vcpu"
          ],
          "line": 7233
        },
        "resolved": true,
        "details": {
          "function_name": "update_bp_intercept",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "1867-1878",
          "snippet": "static void update_bp_intercept(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tclr_exception_intercept(svm, BP_VECTOR);\n\n\tif (vcpu->guest_debug & KVM_GUESTDBG_ENABLE) {\n\t\tif (vcpu->guest_debug & KVM_GUESTDBG_USE_SW_BP)\n\t\t\tset_exception_intercept(svm, BP_VECTOR);\n\t} else\n\t\tvcpu->guest_debug = 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\n\nstatic void update_bp_intercept(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tclr_exception_intercept(svm, BP_VECTOR);\n\n\tif (vcpu->guest_debug & KVM_GUESTDBG_ENABLE) {\n\t\tif (vcpu->guest_debug & KVM_GUESTDBG_USE_SW_BP)\n\t\t\tset_exception_intercept(svm, BP_VECTOR);\n\t} else\n\t\tvcpu->guest_debug = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_set_rflags",
          "args": [
            "vcpu",
            "rflags"
          ],
          "line": 7231
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_set_rflags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "8182-8186",
          "snippet": "void kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags)\n{\n\t__kvm_set_rflags(vcpu, rflags);\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void __kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void __kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags);\n\nvoid kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags)\n{\n\t__kvm_set_rflags(vcpu, rflags);\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_segment_base",
          "args": [
            "vcpu",
            "VCPU_SREG_CS"
          ],
          "line": 7225
        },
        "resolved": true,
        "details": {
          "function_name": "get_segment_base",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "4714-4717",
          "snippet": "static unsigned long get_segment_base(struct kvm_vcpu *vcpu, int seg)\n{\n\treturn kvm_x86_ops->get_segment_base(vcpu, seg);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "struct kvm_x86_ops *kvm_x86_ops"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nstatic unsigned long get_segment_base(struct kvm_vcpu *vcpu, int seg)\n{\n\treturn kvm_x86_ops->get_segment_base(vcpu, seg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_rip_read",
          "args": [
            "vcpu"
          ],
          "line": 7224
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_rip_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "27-30",
          "snippet": "static inline unsigned long kvm_rip_read(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_register_read(vcpu, VCPU_REGS_RIP);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline unsigned long kvm_rip_read(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_register_read(vcpu, VCPU_REGS_RIP);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_update_dr7",
          "args": [
            "vcpu"
          ],
          "line": 7221
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_update_dr7",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "842-854",
          "snippet": "static void kvm_update_dr7(struct kvm_vcpu *vcpu)\n{\n\tunsigned long dr7;\n\n\tif (vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP)\n\t\tdr7 = vcpu->arch.guest_debug_dr7;\n\telse\n\t\tdr7 = vcpu->arch.dr7;\n\tkvm_x86_ops->set_dr7(vcpu, dr7);\n\tvcpu->arch.switch_db_regs &= ~KVM_DEBUGREG_BP_ENABLED;\n\tif (dr7 & DR7_BP_EN_MASK)\n\t\tvcpu->arch.switch_db_regs |= KVM_DEBUGREG_BP_ENABLED;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "struct kvm_x86_ops *kvm_x86_ops"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nstatic void kvm_update_dr7(struct kvm_vcpu *vcpu)\n{\n\tunsigned long dr7;\n\n\tif (vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP)\n\t\tdr7 = vcpu->arch.guest_debug_dr7;\n\telse\n\t\tdr7 = vcpu->arch.dr7;\n\tkvm_x86_ops->set_dr7(vcpu, dr7);\n\tvcpu->arch.switch_db_regs &= ~KVM_DEBUGREG_BP_ENABLED;\n\tif (dr7 & DR7_BP_EN_MASK)\n\t\tvcpu->arch.switch_db_regs |= KVM_DEBUGREG_BP_ENABLED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_get_rflags",
          "args": [
            "vcpu"
          ],
          "line": 7207
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_get_rflags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "8163-8171",
          "snippet": "unsigned long kvm_get_rflags(struct kvm_vcpu *vcpu)\n{\n\tunsigned long rflags;\n\n\trflags = kvm_x86_ops->get_rflags(vcpu);\n\tif (vcpu->guest_debug & KVM_GUESTDBG_SINGLESTEP)\n\t\trflags &= ~X86_EFLAGS_TF;\n\treturn rflags;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void __kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags);",
            "struct kvm_x86_ops *kvm_x86_ops"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void __kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nunsigned long kvm_get_rflags(struct kvm_vcpu *vcpu)\n{\n\tunsigned long rflags;\n\n\trflags = kvm_x86_ops->get_rflags(vcpu);\n\tif (vcpu->guest_debug & KVM_GUESTDBG_SINGLESTEP)\n\t\trflags &= ~X86_EFLAGS_TF;\n\treturn rflags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_queue_exception",
          "args": [
            "vcpu",
            "BP_VECTOR"
          ],
          "line": 7200
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_queue_exception",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "409-412",
          "snippet": "void kvm_queue_exception(struct kvm_vcpu *vcpu, unsigned nr)\n{\n\tkvm_multiple_exception(vcpu, nr, false, 0, false);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nvoid kvm_queue_exception(struct kvm_vcpu *vcpu, unsigned nr)\n{\n\tkvm_multiple_exception(vcpu, nr, false, 0, false);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void __kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nint kvm_arch_vcpu_ioctl_set_guest_debug(struct kvm_vcpu *vcpu,\n\t\t\t\t\tstruct kvm_guest_debug *dbg)\n{\n\tunsigned long rflags;\n\tint i, r;\n\n\tif (dbg->control & (KVM_GUESTDBG_INJECT_DB | KVM_GUESTDBG_INJECT_BP)) {\n\t\tr = -EBUSY;\n\t\tif (vcpu->arch.exception.pending)\n\t\t\tgoto out;\n\t\tif (dbg->control & KVM_GUESTDBG_INJECT_DB)\n\t\t\tkvm_queue_exception(vcpu, DB_VECTOR);\n\t\telse\n\t\t\tkvm_queue_exception(vcpu, BP_VECTOR);\n\t}\n\n\t/*\n\t * Read rflags as long as potentially injected trace flags are still\n\t * filtered out.\n\t */\n\trflags = kvm_get_rflags(vcpu);\n\n\tvcpu->guest_debug = dbg->control;\n\tif (!(vcpu->guest_debug & KVM_GUESTDBG_ENABLE))\n\t\tvcpu->guest_debug = 0;\n\n\tif (vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP) {\n\t\tfor (i = 0; i < KVM_NR_DB_REGS; ++i)\n\t\t\tvcpu->arch.eff_db[i] = dbg->arch.debugreg[i];\n\t\tvcpu->arch.guest_debug_dr7 = dbg->arch.debugreg[7];\n\t} else {\n\t\tfor (i = 0; i < KVM_NR_DB_REGS; i++)\n\t\t\tvcpu->arch.eff_db[i] = vcpu->arch.db[i];\n\t}\n\tkvm_update_dr7(vcpu);\n\n\tif (vcpu->guest_debug & KVM_GUESTDBG_SINGLESTEP)\n\t\tvcpu->arch.singlestep_rip = kvm_rip_read(vcpu) +\n\t\t\tget_segment_base(vcpu, VCPU_SREG_CS);\n\n\t/*\n\t * Trigger an rflags update that will inject or remove the trace\n\t * flags.\n\t */\n\tkvm_set_rflags(vcpu, rflags);\n\n\tkvm_x86_ops->update_bp_intercept(vcpu);\n\n\tr = 0;\n\nout:\n\n\treturn r;\n}"
  },
  {
    "function_name": "kvm_arch_vcpu_ioctl_set_sregs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "7106-7185",
    "snippet": "int kvm_arch_vcpu_ioctl_set_sregs(struct kvm_vcpu *vcpu,\n\t\t\t\t  struct kvm_sregs *sregs)\n{\n\tstruct msr_data apic_base_msr;\n\tint mmu_reset_needed = 0;\n\tint pending_vec, max_bits, idx;\n\tstruct desc_ptr dt;\n\n\tif (!guest_cpuid_has_xsave(vcpu) && (sregs->cr4 & X86_CR4_OSXSAVE))\n\t\treturn -EINVAL;\n\n\tdt.size = sregs->idt.limit;\n\tdt.address = sregs->idt.base;\n\tkvm_x86_ops->set_idt(vcpu, &dt);\n\tdt.size = sregs->gdt.limit;\n\tdt.address = sregs->gdt.base;\n\tkvm_x86_ops->set_gdt(vcpu, &dt);\n\n\tvcpu->arch.cr2 = sregs->cr2;\n\tmmu_reset_needed |= kvm_read_cr3(vcpu) != sregs->cr3;\n\tvcpu->arch.cr3 = sregs->cr3;\n\t__set_bit(VCPU_EXREG_CR3, (ulong *)&vcpu->arch.regs_avail);\n\n\tkvm_set_cr8(vcpu, sregs->cr8);\n\n\tmmu_reset_needed |= vcpu->arch.efer != sregs->efer;\n\tkvm_x86_ops->set_efer(vcpu, sregs->efer);\n\tapic_base_msr.data = sregs->apic_base;\n\tapic_base_msr.host_initiated = true;\n\tkvm_set_apic_base(vcpu, &apic_base_msr);\n\n\tmmu_reset_needed |= kvm_read_cr0(vcpu) != sregs->cr0;\n\tkvm_x86_ops->set_cr0(vcpu, sregs->cr0);\n\tvcpu->arch.cr0 = sregs->cr0;\n\n\tmmu_reset_needed |= kvm_read_cr4(vcpu) != sregs->cr4;\n\tkvm_x86_ops->set_cr4(vcpu, sregs->cr4);\n\tif (sregs->cr4 & (X86_CR4_OSXSAVE | X86_CR4_PKE))\n\t\tkvm_update_cpuid(vcpu);\n\n\tidx = srcu_read_lock(&vcpu->kvm->srcu);\n\tif (!is_long_mode(vcpu) && is_pae(vcpu)) {\n\t\tload_pdptrs(vcpu, vcpu->arch.walk_mmu, kvm_read_cr3(vcpu));\n\t\tmmu_reset_needed = 1;\n\t}\n\tsrcu_read_unlock(&vcpu->kvm->srcu, idx);\n\n\tif (mmu_reset_needed)\n\t\tkvm_mmu_reset_context(vcpu);\n\n\tmax_bits = KVM_NR_INTERRUPTS;\n\tpending_vec = find_first_bit(\n\t\t(const unsigned long *)sregs->interrupt_bitmap, max_bits);\n\tif (pending_vec < max_bits) {\n\t\tkvm_queue_interrupt(vcpu, pending_vec, false);\n\t\tpr_debug(\"Set back pending irq %d\\n\", pending_vec);\n\t}\n\n\tkvm_set_segment(vcpu, &sregs->cs, VCPU_SREG_CS);\n\tkvm_set_segment(vcpu, &sregs->ds, VCPU_SREG_DS);\n\tkvm_set_segment(vcpu, &sregs->es, VCPU_SREG_ES);\n\tkvm_set_segment(vcpu, &sregs->fs, VCPU_SREG_FS);\n\tkvm_set_segment(vcpu, &sregs->gs, VCPU_SREG_GS);\n\tkvm_set_segment(vcpu, &sregs->ss, VCPU_SREG_SS);\n\n\tkvm_set_segment(vcpu, &sregs->tr, VCPU_SREG_TR);\n\tkvm_set_segment(vcpu, &sregs->ldt, VCPU_SREG_LDTR);\n\n\tupdate_cr8_intercept(vcpu);\n\n\t/* Older userspace won't unhalt the vcpu on reset. */\n\tif (kvm_vcpu_is_bsp(vcpu) && kvm_rip_read(vcpu) == 0xfff0 &&\n\t    sregs->cs.selector == 0xf000 && sregs->cs.base == 0xffff0000 &&\n\t    !is_protmode(vcpu))\n\t\tvcpu->arch.mp_state = KVM_MP_STATE_RUNNABLE;\n\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);",
      "struct kvm_x86_ops *kvm_x86_ops"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_make_request",
          "args": [
            "KVM_REQ_EVENT",
            "vcpu"
          ],
          "line": 7182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_protmode",
          "args": [
            "vcpu"
          ],
          "line": 7179
        },
        "resolved": true,
        "details": {
          "function_name": "is_protmode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.h",
          "lines": "38-41",
          "snippet": "static inline bool is_protmode(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_read_cr0_bits(vcpu, X86_CR0_PE);\n}",
          "includes": [
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline bool is_protmode(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_read_cr0_bits(vcpu, X86_CR0_PE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_rip_read",
          "args": [
            "vcpu"
          ],
          "line": 7177
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_rip_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "27-30",
          "snippet": "static inline unsigned long kvm_rip_read(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_register_read(vcpu, VCPU_REGS_RIP);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline unsigned long kvm_rip_read(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_register_read(vcpu, VCPU_REGS_RIP);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_is_bsp",
          "args": [
            "vcpu"
          ],
          "line": 7177
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_vcpu_is_bsp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "7613-7616",
          "snippet": "bool kvm_vcpu_is_bsp(struct kvm_vcpu *vcpu)\n{\n\treturn (vcpu->arch.apic_base & MSR_IA32_APICBASE_BSP) != 0;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nbool kvm_vcpu_is_bsp(struct kvm_vcpu *vcpu)\n{\n\treturn (vcpu->arch.apic_base & MSR_IA32_APICBASE_BSP) != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_cr8_intercept",
          "args": [
            "vcpu"
          ],
          "line": 7174
        },
        "resolved": true,
        "details": {
          "function_name": "update_cr8_intercept",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "6031-6055",
          "snippet": "static void update_cr8_intercept(struct kvm_vcpu *vcpu)\n{\n\tint max_irr, tpr;\n\n\tif (!kvm_x86_ops->update_cr8_intercept)\n\t\treturn;\n\n\tif (!lapic_in_kernel(vcpu))\n\t\treturn;\n\n\tif (vcpu->arch.apicv_active)\n\t\treturn;\n\n\tif (!vcpu->arch.apic->vapic_addr)\n\t\tmax_irr = kvm_lapic_find_highest_irr(vcpu);\n\telse\n\t\tmax_irr = -1;\n\n\tif (max_irr != -1)\n\t\tmax_irr >>= 4;\n\n\ttpr = kvm_lapic_get_cr8(vcpu);\n\n\tkvm_x86_ops->update_cr8_intercept(vcpu, tpr, max_irr);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "struct kvm_x86_ops *kvm_x86_ops"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu)\n{\n\tint max_irr, tpr;\n\n\tif (!kvm_x86_ops->update_cr8_intercept)\n\t\treturn;\n\n\tif (!lapic_in_kernel(vcpu))\n\t\treturn;\n\n\tif (vcpu->arch.apicv_active)\n\t\treturn;\n\n\tif (!vcpu->arch.apic->vapic_addr)\n\t\tmax_irr = kvm_lapic_find_highest_irr(vcpu);\n\telse\n\t\tmax_irr = -1;\n\n\tif (max_irr != -1)\n\t\tmax_irr >>= 4;\n\n\ttpr = kvm_lapic_get_cr8(vcpu);\n\n\tkvm_x86_ops->update_cr8_intercept(vcpu, tpr, max_irr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_set_segment",
          "args": [
            "vcpu",
            "&sregs->ldt",
            "VCPU_SREG_LDTR"
          ],
          "line": 7172
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_set_segment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "4151-4155",
          "snippet": "static void kvm_set_segment(struct kvm_vcpu *vcpu,\n\t\t\tstruct kvm_segment *var, int seg)\n{\n\tkvm_x86_ops->set_segment(vcpu, var, seg);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "struct kvm_x86_ops *kvm_x86_ops"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nstatic void kvm_set_segment(struct kvm_vcpu *vcpu,\n\t\t\tstruct kvm_segment *var, int seg)\n{\n\tkvm_x86_ops->set_segment(vcpu, var, seg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"Set back pending irq %d\\n\"",
            "pending_vec"
          ],
          "line": 7161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_queue_interrupt",
          "args": [
            "vcpu",
            "pending_vec",
            "false"
          ],
          "line": 7160
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_queue_interrupt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.h",
          "lines": "14-20",
          "snippet": "static inline void kvm_queue_interrupt(struct kvm_vcpu *vcpu, u8 vector,\n\tbool soft)\n{\n\tvcpu->arch.interrupt.pending = true;\n\tvcpu->arch.interrupt.soft = soft;\n\tvcpu->arch.interrupt.nr = vector;\n}",
          "includes": [
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline void kvm_queue_interrupt(struct kvm_vcpu *vcpu, u8 vector,\n\tbool soft)\n{\n\tvcpu->arch.interrupt.pending = true;\n\tvcpu->arch.interrupt.soft = soft;\n\tvcpu->arch.interrupt.nr = vector;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_first_bit",
          "args": [
            "(const unsigned long *)sregs->interrupt_bitmap",
            "max_bits"
          ],
          "line": 7157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_mmu_reset_context",
          "args": [
            "vcpu"
          ],
          "line": 7154
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_reset_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "4230-4234",
          "snippet": "void kvm_mmu_reset_context(struct kvm_vcpu *vcpu)\n{\n\tkvm_mmu_unload(vcpu);\n\tinit_kvm_mmu(vcpu);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nvoid kvm_mmu_reset_context(struct kvm_vcpu *vcpu)\n{\n\tkvm_mmu_unload(vcpu);\n\tinit_kvm_mmu(vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "srcu_read_unlock",
          "args": [
            "&vcpu->kvm->srcu",
            "idx"
          ],
          "line": 7151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "load_pdptrs",
          "args": [
            "vcpu",
            "vcpu->arch.walk_mmu",
            "kvm_read_cr3(vcpu)"
          ],
          "line": 7148
        },
        "resolved": true,
        "details": {
          "function_name": "load_pdptrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "524-557",
          "snippet": "int load_pdptrs(struct kvm_vcpu *vcpu, struct kvm_mmu *mmu, unsigned long cr3)\n{\n\tgfn_t pdpt_gfn = cr3 >> PAGE_SHIFT;\n\tunsigned offset = ((cr3 & (PAGE_SIZE-1)) >> 5) << 2;\n\tint i;\n\tint ret;\n\tu64 pdpte[ARRAY_SIZE(mmu->pdptrs)];\n\n\tret = kvm_read_guest_page_mmu(vcpu, mmu, pdpt_gfn, pdpte,\n\t\t\t\t      offset * sizeof(u64), sizeof(pdpte),\n\t\t\t\t      PFERR_USER_MASK|PFERR_WRITE_MASK);\n\tif (ret < 0) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\tfor (i = 0; i < ARRAY_SIZE(pdpte); ++i) {\n\t\tif (is_present_gpte(pdpte[i]) &&\n\t\t    (pdpte[i] &\n\t\t     vcpu->arch.mmu.guest_rsvd_check.rsvd_bits_mask[0][2])) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tret = 1;\n\n\tmemcpy(mmu->pdptrs, pdpte, sizeof(mmu->pdptrs));\n\t__set_bit(VCPU_EXREG_PDPTR,\n\t\t  (unsigned long *)&vcpu->arch.regs_avail);\n\t__set_bit(VCPU_EXREG_PDPTR,\n\t\t  (unsigned long *)&vcpu->arch.regs_dirty);\nout:\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nint load_pdptrs(struct kvm_vcpu *vcpu, struct kvm_mmu *mmu, unsigned long cr3)\n{\n\tgfn_t pdpt_gfn = cr3 >> PAGE_SHIFT;\n\tunsigned offset = ((cr3 & (PAGE_SIZE-1)) >> 5) << 2;\n\tint i;\n\tint ret;\n\tu64 pdpte[ARRAY_SIZE(mmu->pdptrs)];\n\n\tret = kvm_read_guest_page_mmu(vcpu, mmu, pdpt_gfn, pdpte,\n\t\t\t\t      offset * sizeof(u64), sizeof(pdpte),\n\t\t\t\t      PFERR_USER_MASK|PFERR_WRITE_MASK);\n\tif (ret < 0) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\tfor (i = 0; i < ARRAY_SIZE(pdpte); ++i) {\n\t\tif (is_present_gpte(pdpte[i]) &&\n\t\t    (pdpte[i] &\n\t\t     vcpu->arch.mmu.guest_rsvd_check.rsvd_bits_mask[0][2])) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tret = 1;\n\n\tmemcpy(mmu->pdptrs, pdpte, sizeof(mmu->pdptrs));\n\t__set_bit(VCPU_EXREG_PDPTR,\n\t\t  (unsigned long *)&vcpu->arch.regs_avail);\n\t__set_bit(VCPU_EXREG_PDPTR,\n\t\t  (unsigned long *)&vcpu->arch.regs_dirty);\nout:\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_read_cr3",
          "args": [
            "vcpu"
          ],
          "line": 7148
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_read_cr3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "69-74",
          "snippet": "static inline ulong kvm_read_cr3(struct kvm_vcpu *vcpu)\n{\n\tif (!test_bit(VCPU_EXREG_CR3, (ulong *)&vcpu->arch.regs_avail))\n\t\tkvm_x86_ops->decache_cr3(vcpu);\n\treturn vcpu->arch.cr3;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline ulong kvm_read_cr3(struct kvm_vcpu *vcpu)\n{\n\tif (!test_bit(VCPU_EXREG_CR3, (ulong *)&vcpu->arch.regs_avail))\n\t\tkvm_x86_ops->decache_cr3(vcpu);\n\treturn vcpu->arch.cr3;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_pae",
          "args": [
            "vcpu"
          ],
          "line": 7147
        },
        "resolved": true,
        "details": {
          "function_name": "is_pae",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.h",
          "lines": "67-70",
          "snippet": "static inline int is_pae(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_read_cr4_bits(vcpu, X86_CR4_PAE);\n}",
          "includes": [
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline int is_pae(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_read_cr4_bits(vcpu, X86_CR4_PAE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_long_mode",
          "args": [
            "vcpu"
          ],
          "line": 7147
        },
        "resolved": true,
        "details": {
          "function_name": "is_long_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.h",
          "lines": "43-50",
          "snippet": "static inline int is_long_mode(struct kvm_vcpu *vcpu)\n{\n#ifdef CONFIG_X86_64\n\treturn vcpu->arch.efer & EFER_LMA;\n#else\n\treturn 0;\n#endif\n}",
          "includes": [
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline int is_long_mode(struct kvm_vcpu *vcpu)\n{\n#ifdef CONFIG_X86_64\n\treturn vcpu->arch.efer & EFER_LMA;\n#else\n\treturn 0;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "srcu_read_lock",
          "args": [
            "&vcpu->kvm->srcu"
          ],
          "line": 7146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_update_cpuid",
          "args": [
            "vcpu"
          ],
          "line": 7144
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_update_cpuid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/cpuid.c",
          "lines": "68-134",
          "snippet": "int kvm_update_cpuid(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_cpuid_entry2 *best;\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tbest = kvm_find_cpuid_entry(vcpu, 1, 0);\n\tif (!best)\n\t\treturn 0;\n\n\t/* Update OSXSAVE bit */\n\tif (cpu_has_xsave && best->function == 0x1) {\n\t\tbest->ecx &= ~F(OSXSAVE);\n\t\tif (kvm_read_cr4_bits(vcpu, X86_CR4_OSXSAVE))\n\t\t\tbest->ecx |= F(OSXSAVE);\n\t}\n\n\tif (apic) {\n\t\tif (best->ecx & F(TSC_DEADLINE_TIMER))\n\t\t\tapic->lapic_timer.timer_mode_mask = 3 << 17;\n\t\telse\n\t\t\tapic->lapic_timer.timer_mode_mask = 1 << 17;\n\t}\n\n\tbest = kvm_find_cpuid_entry(vcpu, 7, 0);\n\tif (best) {\n\t\t/* Update OSPKE bit */\n\t\tif (boot_cpu_has(X86_FEATURE_PKU) && best->function == 0x7) {\n\t\t\tbest->ecx &= ~F(OSPKE);\n\t\t\tif (kvm_read_cr4_bits(vcpu, X86_CR4_PKE))\n\t\t\t\tbest->ecx |= F(OSPKE);\n\t\t}\n\t}\n\n\tbest = kvm_find_cpuid_entry(vcpu, 0xD, 0);\n\tif (!best) {\n\t\tvcpu->arch.guest_supported_xcr0 = 0;\n\t\tvcpu->arch.guest_xstate_size = XSAVE_HDR_SIZE + XSAVE_HDR_OFFSET;\n\t} else {\n\t\tvcpu->arch.guest_supported_xcr0 =\n\t\t\t(best->eax | ((u64)best->edx << 32)) &\n\t\t\tkvm_supported_xcr0();\n\t\tvcpu->arch.guest_xstate_size = best->ebx =\n\t\t\txstate_required_size(vcpu->arch.xcr0, false);\n\t}\n\n\tbest = kvm_find_cpuid_entry(vcpu, 0xD, 1);\n\tif (best && (best->eax & (F(XSAVES) | F(XSAVEC))))\n\t\tbest->ebx = xstate_required_size(vcpu->arch.xcr0, true);\n\n\tif (use_eager_fpu())\n\t\tkvm_x86_ops->fpu_activate(vcpu);\n\n\t/*\n\t * The existing code assumes virtual address is 48-bit in the canonical\n\t * address checks; exit if it is ever changed.\n\t */\n\tbest = kvm_find_cpuid_entry(vcpu, 0x80000008, 0);\n\tif (best && ((best->eax & 0xff00) >> 8) != 48 &&\n\t\t((best->eax & 0xff00) >> 8) != 0)\n\t\treturn -EINVAL;\n\n\t/* Update physical-address width */\n\tvcpu->arch.maxphyaddr = cpuid_query_maxphyaddr(vcpu);\n\n\tkvm_pmu_refresh(vcpu);\n\treturn 0;\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"trace.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"cpuid.h\"",
            "#include <asm/fpu/xstate.h>",
            "#include <asm/user.h>",
            "#include <asm/fpu/internal.h> /* For use_eager_fpu.  Ugh! */",
            "#include <linux/uaccess.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"trace.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include <asm/fpu/xstate.h>\n#include <asm/user.h>\n#include <asm/fpu/internal.h> /* For use_eager_fpu.  Ugh! */\n#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n\nint kvm_update_cpuid(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_cpuid_entry2 *best;\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tbest = kvm_find_cpuid_entry(vcpu, 1, 0);\n\tif (!best)\n\t\treturn 0;\n\n\t/* Update OSXSAVE bit */\n\tif (cpu_has_xsave && best->function == 0x1) {\n\t\tbest->ecx &= ~F(OSXSAVE);\n\t\tif (kvm_read_cr4_bits(vcpu, X86_CR4_OSXSAVE))\n\t\t\tbest->ecx |= F(OSXSAVE);\n\t}\n\n\tif (apic) {\n\t\tif (best->ecx & F(TSC_DEADLINE_TIMER))\n\t\t\tapic->lapic_timer.timer_mode_mask = 3 << 17;\n\t\telse\n\t\t\tapic->lapic_timer.timer_mode_mask = 1 << 17;\n\t}\n\n\tbest = kvm_find_cpuid_entry(vcpu, 7, 0);\n\tif (best) {\n\t\t/* Update OSPKE bit */\n\t\tif (boot_cpu_has(X86_FEATURE_PKU) && best->function == 0x7) {\n\t\t\tbest->ecx &= ~F(OSPKE);\n\t\t\tif (kvm_read_cr4_bits(vcpu, X86_CR4_PKE))\n\t\t\t\tbest->ecx |= F(OSPKE);\n\t\t}\n\t}\n\n\tbest = kvm_find_cpuid_entry(vcpu, 0xD, 0);\n\tif (!best) {\n\t\tvcpu->arch.guest_supported_xcr0 = 0;\n\t\tvcpu->arch.guest_xstate_size = XSAVE_HDR_SIZE + XSAVE_HDR_OFFSET;\n\t} else {\n\t\tvcpu->arch.guest_supported_xcr0 =\n\t\t\t(best->eax | ((u64)best->edx << 32)) &\n\t\t\tkvm_supported_xcr0();\n\t\tvcpu->arch.guest_xstate_size = best->ebx =\n\t\t\txstate_required_size(vcpu->arch.xcr0, false);\n\t}\n\n\tbest = kvm_find_cpuid_entry(vcpu, 0xD, 1);\n\tif (best && (best->eax & (F(XSAVES) | F(XSAVEC))))\n\t\tbest->ebx = xstate_required_size(vcpu->arch.xcr0, true);\n\n\tif (use_eager_fpu())\n\t\tkvm_x86_ops->fpu_activate(vcpu);\n\n\t/*\n\t * The existing code assumes virtual address is 48-bit in the canonical\n\t * address checks; exit if it is ever changed.\n\t */\n\tbest = kvm_find_cpuid_entry(vcpu, 0x80000008, 0);\n\tif (best && ((best->eax & 0xff00) >> 8) != 48 &&\n\t\t((best->eax & 0xff00) >> 8) != 0)\n\t\treturn -EINVAL;\n\n\t/* Update physical-address width */\n\tvcpu->arch.maxphyaddr = cpuid_query_maxphyaddr(vcpu);\n\n\tkvm_pmu_refresh(vcpu);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_x86_ops->set_cr4",
          "args": [
            "vcpu",
            "sregs->cr4"
          ],
          "line": 7142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_read_cr4",
          "args": [
            "vcpu"
          ],
          "line": 7141
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_read_cr4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "76-79",
          "snippet": "static inline ulong kvm_read_cr4(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_read_cr4_bits(vcpu, ~0UL);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline ulong kvm_read_cr4(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_read_cr4_bits(vcpu, ~0UL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_x86_ops->set_cr0",
          "args": [
            "vcpu",
            "sregs->cr0"
          ],
          "line": 7138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_read_cr0",
          "args": [
            "vcpu"
          ],
          "line": 7137
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_read_cr0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "56-59",
          "snippet": "static inline ulong kvm_read_cr0(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_read_cr0_bits(vcpu, ~0UL);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline ulong kvm_read_cr0(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_read_cr0_bits(vcpu, ~0UL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_set_apic_base",
          "args": [
            "vcpu",
            "&apic_base_msr"
          ],
          "line": 7135
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_set_apic_base",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "289-309",
          "snippet": "int kvm_set_apic_base(struct kvm_vcpu *vcpu, struct msr_data *msr_info)\n{\n\tu64 old_state = vcpu->arch.apic_base &\n\t\t(MSR_IA32_APICBASE_ENABLE | X2APIC_ENABLE);\n\tu64 new_state = msr_info->data &\n\t\t(MSR_IA32_APICBASE_ENABLE | X2APIC_ENABLE);\n\tu64 reserved_bits = ((~0ULL) << cpuid_maxphyaddr(vcpu)) |\n\t\t0x2ff | (guest_cpuid_has_x2apic(vcpu) ? 0 : X2APIC_ENABLE);\n\n\tif (!msr_info->host_initiated &&\n\t    ((msr_info->data & reserved_bits) != 0 ||\n\t     new_state == X2APIC_ENABLE ||\n\t     (new_state == MSR_IA32_APICBASE_ENABLE &&\n\t      old_state == (MSR_IA32_APICBASE_ENABLE | X2APIC_ENABLE)) ||\n\t     (new_state == (MSR_IA32_APICBASE_ENABLE | X2APIC_ENABLE) &&\n\t      old_state == 0)))\n\t\treturn 1;\n\n\tkvm_lapic_set_base(vcpu, msr_info->data);\n\treturn 0;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nint kvm_set_apic_base(struct kvm_vcpu *vcpu, struct msr_data *msr_info)\n{\n\tu64 old_state = vcpu->arch.apic_base &\n\t\t(MSR_IA32_APICBASE_ENABLE | X2APIC_ENABLE);\n\tu64 new_state = msr_info->data &\n\t\t(MSR_IA32_APICBASE_ENABLE | X2APIC_ENABLE);\n\tu64 reserved_bits = ((~0ULL) << cpuid_maxphyaddr(vcpu)) |\n\t\t0x2ff | (guest_cpuid_has_x2apic(vcpu) ? 0 : X2APIC_ENABLE);\n\n\tif (!msr_info->host_initiated &&\n\t    ((msr_info->data & reserved_bits) != 0 ||\n\t     new_state == X2APIC_ENABLE ||\n\t     (new_state == MSR_IA32_APICBASE_ENABLE &&\n\t      old_state == (MSR_IA32_APICBASE_ENABLE | X2APIC_ENABLE)) ||\n\t     (new_state == (MSR_IA32_APICBASE_ENABLE | X2APIC_ENABLE) &&\n\t      old_state == 0)))\n\t\treturn 1;\n\n\tkvm_lapic_set_base(vcpu, msr_info->data);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_x86_ops->set_efer",
          "args": [
            "vcpu",
            "sregs->efer"
          ],
          "line": 7132
        },
        "resolved": true,
        "details": {
          "function_name": "set_efer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "1015-1036",
          "snippet": "static int set_efer(struct kvm_vcpu *vcpu, u64 efer)\n{\n\tu64 old_efer = vcpu->arch.efer;\n\n\tif (!kvm_valid_efer(vcpu, efer))\n\t\treturn 1;\n\n\tif (is_paging(vcpu)\n\t    && (vcpu->arch.efer & EFER_LME) != (efer & EFER_LME))\n\t\treturn 1;\n\n\tefer &= ~EFER_LMA;\n\tefer |= vcpu->arch.efer & EFER_LMA;\n\n\tkvm_x86_ops->set_efer(vcpu, efer);\n\n\t/* Update reserved bits */\n\tif ((efer ^ old_efer) & EFER_NX)\n\t\tkvm_mmu_reset_context(vcpu);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "struct kvm_x86_ops *kvm_x86_ops"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nstatic int set_efer(struct kvm_vcpu *vcpu, u64 efer)\n{\n\tu64 old_efer = vcpu->arch.efer;\n\n\tif (!kvm_valid_efer(vcpu, efer))\n\t\treturn 1;\n\n\tif (is_paging(vcpu)\n\t    && (vcpu->arch.efer & EFER_LME) != (efer & EFER_LME))\n\t\treturn 1;\n\n\tefer &= ~EFER_LMA;\n\tefer |= vcpu->arch.efer & EFER_LMA;\n\n\tkvm_x86_ops->set_efer(vcpu, efer);\n\n\t/* Update reserved bits */\n\tif ((efer ^ old_efer) & EFER_NX)\n\t\tkvm_mmu_reset_context(vcpu);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_set_cr8",
          "args": [
            "vcpu",
            "sregs->cr8"
          ],
          "line": 7129
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_set_cr8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "804-813",
          "snippet": "int kvm_set_cr8(struct kvm_vcpu *vcpu, unsigned long cr8)\n{\n\tif (cr8 & CR8_RESERVED_BITS)\n\t\treturn 1;\n\tif (lapic_in_kernel(vcpu))\n\t\tkvm_lapic_set_tpr(vcpu, cr8);\n\telse\n\t\tvcpu->arch.cr8 = cr8;\n\treturn 0;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nint kvm_set_cr8(struct kvm_vcpu *vcpu, unsigned long cr8)\n{\n\tif (cr8 & CR8_RESERVED_BITS)\n\t\treturn 1;\n\tif (lapic_in_kernel(vcpu))\n\t\tkvm_lapic_set_tpr(vcpu, cr8);\n\telse\n\t\tvcpu->arch.cr8 = cr8;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__set_bit",
          "args": [
            "VCPU_EXREG_CR3",
            "(ulong *)&vcpu->arch.regs_avail"
          ],
          "line": 7127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_x86_ops->set_gdt",
          "args": [
            "vcpu",
            "&dt"
          ],
          "line": 7122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_x86_ops->set_idt",
          "args": [
            "vcpu",
            "&dt"
          ],
          "line": 7119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "guest_cpuid_has_xsave",
          "args": [
            "vcpu"
          ],
          "line": 7114
        },
        "resolved": true,
        "details": {
          "function_name": "guest_cpuid_has_xsave",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/cpuid.h",
          "lines": "32-41",
          "snippet": "static inline bool guest_cpuid_has_xsave(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_cpuid_entry2 *best;\n\n\tif (!static_cpu_has(X86_FEATURE_XSAVE))\n\t\treturn false;\n\n\tbest = kvm_find_cpuid_entry(vcpu, 1, 0);\n\treturn best && (best->ecx & bit(X86_FEATURE_XSAVE));\n}",
          "includes": [
            "#include <asm/cpu.h>",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpu.h>\n#include \"x86.h\"\n\nstatic inline bool guest_cpuid_has_xsave(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_cpuid_entry2 *best;\n\n\tif (!static_cpu_has(X86_FEATURE_XSAVE))\n\t\treturn false;\n\n\tbest = kvm_find_cpuid_entry(vcpu, 1, 0);\n\treturn best && (best->ecx & bit(X86_FEATURE_XSAVE));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nint kvm_arch_vcpu_ioctl_set_sregs(struct kvm_vcpu *vcpu,\n\t\t\t\t  struct kvm_sregs *sregs)\n{\n\tstruct msr_data apic_base_msr;\n\tint mmu_reset_needed = 0;\n\tint pending_vec, max_bits, idx;\n\tstruct desc_ptr dt;\n\n\tif (!guest_cpuid_has_xsave(vcpu) && (sregs->cr4 & X86_CR4_OSXSAVE))\n\t\treturn -EINVAL;\n\n\tdt.size = sregs->idt.limit;\n\tdt.address = sregs->idt.base;\n\tkvm_x86_ops->set_idt(vcpu, &dt);\n\tdt.size = sregs->gdt.limit;\n\tdt.address = sregs->gdt.base;\n\tkvm_x86_ops->set_gdt(vcpu, &dt);\n\n\tvcpu->arch.cr2 = sregs->cr2;\n\tmmu_reset_needed |= kvm_read_cr3(vcpu) != sregs->cr3;\n\tvcpu->arch.cr3 = sregs->cr3;\n\t__set_bit(VCPU_EXREG_CR3, (ulong *)&vcpu->arch.regs_avail);\n\n\tkvm_set_cr8(vcpu, sregs->cr8);\n\n\tmmu_reset_needed |= vcpu->arch.efer != sregs->efer;\n\tkvm_x86_ops->set_efer(vcpu, sregs->efer);\n\tapic_base_msr.data = sregs->apic_base;\n\tapic_base_msr.host_initiated = true;\n\tkvm_set_apic_base(vcpu, &apic_base_msr);\n\n\tmmu_reset_needed |= kvm_read_cr0(vcpu) != sregs->cr0;\n\tkvm_x86_ops->set_cr0(vcpu, sregs->cr0);\n\tvcpu->arch.cr0 = sregs->cr0;\n\n\tmmu_reset_needed |= kvm_read_cr4(vcpu) != sregs->cr4;\n\tkvm_x86_ops->set_cr4(vcpu, sregs->cr4);\n\tif (sregs->cr4 & (X86_CR4_OSXSAVE | X86_CR4_PKE))\n\t\tkvm_update_cpuid(vcpu);\n\n\tidx = srcu_read_lock(&vcpu->kvm->srcu);\n\tif (!is_long_mode(vcpu) && is_pae(vcpu)) {\n\t\tload_pdptrs(vcpu, vcpu->arch.walk_mmu, kvm_read_cr3(vcpu));\n\t\tmmu_reset_needed = 1;\n\t}\n\tsrcu_read_unlock(&vcpu->kvm->srcu, idx);\n\n\tif (mmu_reset_needed)\n\t\tkvm_mmu_reset_context(vcpu);\n\n\tmax_bits = KVM_NR_INTERRUPTS;\n\tpending_vec = find_first_bit(\n\t\t(const unsigned long *)sregs->interrupt_bitmap, max_bits);\n\tif (pending_vec < max_bits) {\n\t\tkvm_queue_interrupt(vcpu, pending_vec, false);\n\t\tpr_debug(\"Set back pending irq %d\\n\", pending_vec);\n\t}\n\n\tkvm_set_segment(vcpu, &sregs->cs, VCPU_SREG_CS);\n\tkvm_set_segment(vcpu, &sregs->ds, VCPU_SREG_DS);\n\tkvm_set_segment(vcpu, &sregs->es, VCPU_SREG_ES);\n\tkvm_set_segment(vcpu, &sregs->fs, VCPU_SREG_FS);\n\tkvm_set_segment(vcpu, &sregs->gs, VCPU_SREG_GS);\n\tkvm_set_segment(vcpu, &sregs->ss, VCPU_SREG_SS);\n\n\tkvm_set_segment(vcpu, &sregs->tr, VCPU_SREG_TR);\n\tkvm_set_segment(vcpu, &sregs->ldt, VCPU_SREG_LDTR);\n\n\tupdate_cr8_intercept(vcpu);\n\n\t/* Older userspace won't unhalt the vcpu on reset. */\n\tif (kvm_vcpu_is_bsp(vcpu) && kvm_rip_read(vcpu) == 0xfff0 &&\n\t    sregs->cs.selector == 0xf000 && sregs->cs.base == 0xffff0000 &&\n\t    !is_protmode(vcpu))\n\t\tvcpu->arch.mp_state = KVM_MP_STATE_RUNNABLE;\n\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "kvm_task_switch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "7085-7103",
    "snippet": "int kvm_task_switch(struct kvm_vcpu *vcpu, u16 tss_selector, int idt_index,\n\t\t    int reason, bool has_error_code, u32 error_code)\n{\n\tstruct x86_emulate_ctxt *ctxt = &vcpu->arch.emulate_ctxt;\n\tint ret;\n\n\tinit_emulate_ctxt(vcpu);\n\n\tret = emulator_task_switch(ctxt, tss_selector, idt_index, reason,\n\t\t\t\t   has_error_code, error_code);\n\n\tif (ret)\n\t\treturn EMULATE_FAIL;\n\n\tkvm_rip_write(vcpu, ctxt->eip);\n\tkvm_set_rflags(vcpu, ctxt->eflags);\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\treturn EMULATE_DONE;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);",
      "static int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_make_request",
          "args": [
            "KVM_REQ_EVENT",
            "vcpu"
          ],
          "line": 7101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_set_rflags",
          "args": [
            "vcpu",
            "ctxt->eflags"
          ],
          "line": 7100
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_set_rflags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "8182-8186",
          "snippet": "void kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags)\n{\n\t__kvm_set_rflags(vcpu, rflags);\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void __kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void __kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags);\n\nvoid kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags)\n{\n\t__kvm_set_rflags(vcpu, rflags);\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_rip_write",
          "args": [
            "vcpu",
            "ctxt->eip"
          ],
          "line": 7099
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_rip_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "32-35",
          "snippet": "static inline void kvm_rip_write(struct kvm_vcpu *vcpu, unsigned long val)\n{\n\tkvm_register_write(vcpu, VCPU_REGS_RIP, val);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void kvm_rip_write(struct kvm_vcpu *vcpu, unsigned long val)\n{\n\tkvm_register_write(vcpu, VCPU_REGS_RIP, val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "emulator_task_switch",
          "args": [
            "ctxt",
            "tss_selector",
            "idt_index",
            "reason",
            "has_error_code",
            "error_code"
          ],
          "line": 7093
        },
        "resolved": true,
        "details": {
          "function_name": "emulator_task_switch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "3254-3273",
          "snippet": "int emulator_task_switch(struct x86_emulate_ctxt *ctxt,\n\t\t\t u16 tss_selector, int idt_index, int reason,\n\t\t\t bool has_error_code, u32 error_code)\n{\n\tint rc;\n\n\tinvalidate_registers(ctxt);\n\tctxt->_eip = ctxt->eip;\n\tctxt->dst.type = OP_NONE;\n\n\trc = emulator_do_task_switch(ctxt, tss_selector, idt_index, reason,\n\t\t\t\t     has_error_code, error_code);\n\n\tif (rc == X86EMUL_CONTINUE) {\n\t\tctxt->eip = ctxt->_eip;\n\t\twriteback_registers(ctxt);\n\t}\n\n\treturn (rc == X86EMUL_UNHANDLEABLE) ? EMULATION_FAILED : EMULATION_OK;\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nint emulator_task_switch(struct x86_emulate_ctxt *ctxt,\n\t\t\t u16 tss_selector, int idt_index, int reason,\n\t\t\t bool has_error_code, u32 error_code)\n{\n\tint rc;\n\n\tinvalidate_registers(ctxt);\n\tctxt->_eip = ctxt->eip;\n\tctxt->dst.type = OP_NONE;\n\n\trc = emulator_do_task_switch(ctxt, tss_selector, idt_index, reason,\n\t\t\t\t     has_error_code, error_code);\n\n\tif (rc == X86EMUL_CONTINUE) {\n\t\tctxt->eip = ctxt->_eip;\n\t\twriteback_registers(ctxt);\n\t}\n\n\treturn (rc == X86EMUL_UNHANDLEABLE) ? EMULATION_FAILED : EMULATION_OK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_emulate_ctxt",
          "args": [
            "vcpu"
          ],
          "line": 7091
        },
        "resolved": true,
        "details": {
          "function_name": "init_emulate_ctxt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "5103-5124",
          "snippet": "static void init_emulate_ctxt(struct kvm_vcpu *vcpu)\n{\n\tstruct x86_emulate_ctxt *ctxt = &vcpu->arch.emulate_ctxt;\n\tint cs_db, cs_l;\n\n\tkvm_x86_ops->get_cs_db_l_bits(vcpu, &cs_db, &cs_l);\n\n\tctxt->eflags = kvm_get_rflags(vcpu);\n\tctxt->eip = kvm_rip_read(vcpu);\n\tctxt->mode = (!is_protmode(vcpu))\t\t? X86EMUL_MODE_REAL :\n\t\t     (ctxt->eflags & X86_EFLAGS_VM)\t? X86EMUL_MODE_VM86 :\n\t\t     (cs_l && is_long_mode(vcpu))\t? X86EMUL_MODE_PROT64 :\n\t\t     cs_db\t\t\t\t? X86EMUL_MODE_PROT32 :\n\t\t\t\t\t\t\t  X86EMUL_MODE_PROT16;\n\tBUILD_BUG_ON(HF_GUEST_MASK != X86EMUL_GUEST_MASK);\n\tBUILD_BUG_ON(HF_SMM_MASK != X86EMUL_SMM_MASK);\n\tBUILD_BUG_ON(HF_SMM_INSIDE_NMI_MASK != X86EMUL_SMM_INSIDE_NMI_MASK);\n\tctxt->emul_flags = vcpu->arch.hflags;\n\n\tinit_decode_cache(ctxt);\n\tvcpu->arch.emulate_regs_need_sync_from_vcpu = false;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "struct kvm_x86_ops *kvm_x86_ops",
            "static int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\nstatic int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);\n\nstatic void init_emulate_ctxt(struct kvm_vcpu *vcpu)\n{\n\tstruct x86_emulate_ctxt *ctxt = &vcpu->arch.emulate_ctxt;\n\tint cs_db, cs_l;\n\n\tkvm_x86_ops->get_cs_db_l_bits(vcpu, &cs_db, &cs_l);\n\n\tctxt->eflags = kvm_get_rflags(vcpu);\n\tctxt->eip = kvm_rip_read(vcpu);\n\tctxt->mode = (!is_protmode(vcpu))\t\t? X86EMUL_MODE_REAL :\n\t\t     (ctxt->eflags & X86_EFLAGS_VM)\t? X86EMUL_MODE_VM86 :\n\t\t     (cs_l && is_long_mode(vcpu))\t? X86EMUL_MODE_PROT64 :\n\t\t     cs_db\t\t\t\t? X86EMUL_MODE_PROT32 :\n\t\t\t\t\t\t\t  X86EMUL_MODE_PROT16;\n\tBUILD_BUG_ON(HF_GUEST_MASK != X86EMUL_GUEST_MASK);\n\tBUILD_BUG_ON(HF_SMM_MASK != X86EMUL_SMM_MASK);\n\tBUILD_BUG_ON(HF_SMM_INSIDE_NMI_MASK != X86EMUL_SMM_INSIDE_NMI_MASK);\n\tctxt->emul_flags = vcpu->arch.hflags;\n\n\tinit_decode_cache(ctxt);\n\tvcpu->arch.emulate_regs_need_sync_from_vcpu = false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);\n\nint kvm_task_switch(struct kvm_vcpu *vcpu, u16 tss_selector, int idt_index,\n\t\t    int reason, bool has_error_code, u32 error_code)\n{\n\tstruct x86_emulate_ctxt *ctxt = &vcpu->arch.emulate_ctxt;\n\tint ret;\n\n\tinit_emulate_ctxt(vcpu);\n\n\tret = emulator_task_switch(ctxt, tss_selector, idt_index, reason,\n\t\t\t\t   has_error_code, error_code);\n\n\tif (ret)\n\t\treturn EMULATE_FAIL;\n\n\tkvm_rip_write(vcpu, ctxt->eip);\n\tkvm_set_rflags(vcpu, ctxt->eflags);\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\treturn EMULATE_DONE;\n}"
  },
  {
    "function_name": "kvm_arch_vcpu_ioctl_set_mpstate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "7069-7083",
    "snippet": "int kvm_arch_vcpu_ioctl_set_mpstate(struct kvm_vcpu *vcpu,\n\t\t\t\t    struct kvm_mp_state *mp_state)\n{\n\tif (!lapic_in_kernel(vcpu) &&\n\t    mp_state->mp_state != KVM_MP_STATE_RUNNABLE)\n\t\treturn -EINVAL;\n\n\tif (mp_state->mp_state == KVM_MP_STATE_SIPI_RECEIVED) {\n\t\tvcpu->arch.mp_state = KVM_MP_STATE_INIT_RECEIVED;\n\t\tset_bit(KVM_APIC_SIPI, &vcpu->arch.apic->pending_events);\n\t} else\n\t\tvcpu->arch.mp_state = mp_state->mp_state;\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\treturn 0;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_make_request",
          "args": [
            "KVM_REQ_EVENT",
            "vcpu"
          ],
          "line": 7081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "KVM_APIC_SIPI",
            "&vcpu->arch.apic->pending_events"
          ],
          "line": 7078
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_set_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/vmx.c",
          "lines": "1599-1604",
          "snippet": "static __always_inline void vmcs_set_bits(unsigned long field, u32 mask)\n{\n        BUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x2000,\n\t\t\t \"vmcs_set_bits does not support 64-bit fields\");\n\t__vmcs_writel(field, __vmcs_readl(field) | mask);\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"trace.h\"",
            "#include <asm/irq_remapping.h>",
            "#include <asm/apic.h>",
            "#include <asm/kexec.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/mce.h>",
            "#include <asm/virtext.h>",
            "#include <asm/vmx.h>",
            "#include <asm/desc.h>",
            "#include <asm/io.h>",
            "#include <asm/cpu.h>",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/hrtimer.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include \"lapic.h\"",
            "#include \"cpuid.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"trace.h\"\n#include <asm/irq_remapping.h>\n#include <asm/apic.h>\n#include <asm/kexec.h>\n#include <asm/debugreg.h>\n#include <asm/perf_event.h>\n#include <asm/fpu/internal.h>\n#include <asm/mce.h>\n#include <asm/virtext.h>\n#include <asm/vmx.h>\n#include <asm/desc.h>\n#include <asm/io.h>\n#include <asm/cpu.h>\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/hrtimer.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic __always_inline void vmcs_set_bits(unsigned long field, u32 mask)\n{\n        BUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x2000,\n\t\t\t \"vmcs_set_bits does not support 64-bit fields\");\n\t__vmcs_writel(field, __vmcs_readl(field) | mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lapic_in_kernel",
          "args": [
            "vcpu"
          ],
          "line": 7072
        },
        "resolved": true,
        "details": {
          "function_name": "lapic_in_kernel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.h",
          "lines": "141-146",
          "snippet": "static inline bool lapic_in_kernel(struct kvm_vcpu *vcpu)\n{\n\tif (static_key_false(&kvm_no_apic_vcpu))\n\t\treturn vcpu->arch.apic;\n\treturn true;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline bool lapic_in_kernel(struct kvm_vcpu *vcpu)\n{\n\tif (static_key_false(&kvm_no_apic_vcpu))\n\t\treturn vcpu->arch.apic;\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nint kvm_arch_vcpu_ioctl_set_mpstate(struct kvm_vcpu *vcpu,\n\t\t\t\t    struct kvm_mp_state *mp_state)\n{\n\tif (!lapic_in_kernel(vcpu) &&\n\t    mp_state->mp_state != KVM_MP_STATE_RUNNABLE)\n\t\treturn -EINVAL;\n\n\tif (mp_state->mp_state == KVM_MP_STATE_SIPI_RECEIVED) {\n\t\tvcpu->arch.mp_state = KVM_MP_STATE_INIT_RECEIVED;\n\t\tset_bit(KVM_APIC_SIPI, &vcpu->arch.apic->pending_events);\n\t} else\n\t\tvcpu->arch.mp_state = mp_state->mp_state;\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\treturn 0;\n}"
  },
  {
    "function_name": "kvm_arch_vcpu_ioctl_get_mpstate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "7056-7067",
    "snippet": "int kvm_arch_vcpu_ioctl_get_mpstate(struct kvm_vcpu *vcpu,\n\t\t\t\t    struct kvm_mp_state *mp_state)\n{\n\tkvm_apic_accept_events(vcpu);\n\tif (vcpu->arch.mp_state == KVM_MP_STATE_HALTED &&\n\t\t\t\t\tvcpu->arch.pv.pv_unhalted)\n\t\tmp_state->mp_state = KVM_MP_STATE_RUNNABLE;\n\telse\n\t\tmp_state->mp_state = vcpu->arch.mp_state;\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_apic_accept_events",
          "args": [
            "vcpu"
          ],
          "line": 7059
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_accept_events",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "2195-2235",
          "snippet": "void kvm_apic_accept_events(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tu8 sipi_vector;\n\tunsigned long pe;\n\n\tif (!lapic_in_kernel(vcpu) || !apic->pending_events)\n\t\treturn;\n\n\t/*\n\t * INITs are latched while in SMM.  Because an SMM CPU cannot\n\t * be in KVM_MP_STATE_INIT_RECEIVED state, just eat SIPIs\n\t * and delay processing of INIT until the next RSM.\n\t */\n\tif (is_smm(vcpu)) {\n\t\tWARN_ON_ONCE(vcpu->arch.mp_state == KVM_MP_STATE_INIT_RECEIVED);\n\t\tif (test_bit(KVM_APIC_SIPI, &apic->pending_events))\n\t\t\tclear_bit(KVM_APIC_SIPI, &apic->pending_events);\n\t\treturn;\n\t}\n\n\tpe = xchg(&apic->pending_events, 0);\n\tif (test_bit(KVM_APIC_INIT, &pe)) {\n\t\tkvm_lapic_reset(vcpu, true);\n\t\tkvm_vcpu_reset(vcpu, true);\n\t\tif (kvm_vcpu_is_bsp(apic->vcpu))\n\t\t\tvcpu->arch.mp_state = KVM_MP_STATE_RUNNABLE;\n\t\telse\n\t\t\tvcpu->arch.mp_state = KVM_MP_STATE_INIT_RECEIVED;\n\t}\n\tif (test_bit(KVM_APIC_SIPI, &pe) &&\n\t    vcpu->arch.mp_state == KVM_MP_STATE_INIT_RECEIVED) {\n\t\t/* evaluate pending_events before reading the vector */\n\t\tsmp_rmb();\n\t\tsipi_vector = apic->sipi_vector;\n\t\tapic_debug(\"vcpu %d received sipi with vector # %x\\n\",\n\t\t\t vcpu->vcpu_id, sipi_vector);\n\t\tkvm_vcpu_deliver_sipi_vector(vcpu, sipi_vector);\n\t\tvcpu->arch.mp_state = KVM_MP_STATE_RUNNABLE;\n\t}\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nvoid kvm_apic_accept_events(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tu8 sipi_vector;\n\tunsigned long pe;\n\n\tif (!lapic_in_kernel(vcpu) || !apic->pending_events)\n\t\treturn;\n\n\t/*\n\t * INITs are latched while in SMM.  Because an SMM CPU cannot\n\t * be in KVM_MP_STATE_INIT_RECEIVED state, just eat SIPIs\n\t * and delay processing of INIT until the next RSM.\n\t */\n\tif (is_smm(vcpu)) {\n\t\tWARN_ON_ONCE(vcpu->arch.mp_state == KVM_MP_STATE_INIT_RECEIVED);\n\t\tif (test_bit(KVM_APIC_SIPI, &apic->pending_events))\n\t\t\tclear_bit(KVM_APIC_SIPI, &apic->pending_events);\n\t\treturn;\n\t}\n\n\tpe = xchg(&apic->pending_events, 0);\n\tif (test_bit(KVM_APIC_INIT, &pe)) {\n\t\tkvm_lapic_reset(vcpu, true);\n\t\tkvm_vcpu_reset(vcpu, true);\n\t\tif (kvm_vcpu_is_bsp(apic->vcpu))\n\t\t\tvcpu->arch.mp_state = KVM_MP_STATE_RUNNABLE;\n\t\telse\n\t\t\tvcpu->arch.mp_state = KVM_MP_STATE_INIT_RECEIVED;\n\t}\n\tif (test_bit(KVM_APIC_SIPI, &pe) &&\n\t    vcpu->arch.mp_state == KVM_MP_STATE_INIT_RECEIVED) {\n\t\t/* evaluate pending_events before reading the vector */\n\t\tsmp_rmb();\n\t\tsipi_vector = apic->sipi_vector;\n\t\tapic_debug(\"vcpu %d received sipi with vector # %x\\n\",\n\t\t\t vcpu->vcpu_id, sipi_vector);\n\t\tkvm_vcpu_deliver_sipi_vector(vcpu, sipi_vector);\n\t\tvcpu->arch.mp_state = KVM_MP_STATE_RUNNABLE;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nint kvm_arch_vcpu_ioctl_get_mpstate(struct kvm_vcpu *vcpu,\n\t\t\t\t    struct kvm_mp_state *mp_state)\n{\n\tkvm_apic_accept_events(vcpu);\n\tif (vcpu->arch.mp_state == KVM_MP_STATE_HALTED &&\n\t\t\t\t\tvcpu->arch.pv.pv_unhalted)\n\t\tmp_state->mp_state = KVM_MP_STATE_RUNNABLE;\n\telse\n\t\tmp_state->mp_state = vcpu->arch.mp_state;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "kvm_arch_vcpu_ioctl_get_sregs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "7017-7054",
    "snippet": "int kvm_arch_vcpu_ioctl_get_sregs(struct kvm_vcpu *vcpu,\n\t\t\t\t  struct kvm_sregs *sregs)\n{\n\tstruct desc_ptr dt;\n\n\tkvm_get_segment(vcpu, &sregs->cs, VCPU_SREG_CS);\n\tkvm_get_segment(vcpu, &sregs->ds, VCPU_SREG_DS);\n\tkvm_get_segment(vcpu, &sregs->es, VCPU_SREG_ES);\n\tkvm_get_segment(vcpu, &sregs->fs, VCPU_SREG_FS);\n\tkvm_get_segment(vcpu, &sregs->gs, VCPU_SREG_GS);\n\tkvm_get_segment(vcpu, &sregs->ss, VCPU_SREG_SS);\n\n\tkvm_get_segment(vcpu, &sregs->tr, VCPU_SREG_TR);\n\tkvm_get_segment(vcpu, &sregs->ldt, VCPU_SREG_LDTR);\n\n\tkvm_x86_ops->get_idt(vcpu, &dt);\n\tsregs->idt.limit = dt.size;\n\tsregs->idt.base = dt.address;\n\tkvm_x86_ops->get_gdt(vcpu, &dt);\n\tsregs->gdt.limit = dt.size;\n\tsregs->gdt.base = dt.address;\n\n\tsregs->cr0 = kvm_read_cr0(vcpu);\n\tsregs->cr2 = vcpu->arch.cr2;\n\tsregs->cr3 = kvm_read_cr3(vcpu);\n\tsregs->cr4 = kvm_read_cr4(vcpu);\n\tsregs->cr8 = kvm_get_cr8(vcpu);\n\tsregs->efer = vcpu->arch.efer;\n\tsregs->apic_base = kvm_get_apic_base(vcpu);\n\n\tmemset(sregs->interrupt_bitmap, 0, sizeof sregs->interrupt_bitmap);\n\n\tif (vcpu->arch.interrupt.pending && !vcpu->arch.interrupt.soft)\n\t\tset_bit(vcpu->arch.interrupt.nr,\n\t\t\t(unsigned long *)sregs->interrupt_bitmap);\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);",
      "struct kvm_x86_ops *kvm_x86_ops"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "vcpu->arch.interrupt.nr",
            "(unsigned long *)sregs->interrupt_bitmap"
          ],
          "line": 7050
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_set_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/vmx.c",
          "lines": "1599-1604",
          "snippet": "static __always_inline void vmcs_set_bits(unsigned long field, u32 mask)\n{\n        BUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x2000,\n\t\t\t \"vmcs_set_bits does not support 64-bit fields\");\n\t__vmcs_writel(field, __vmcs_readl(field) | mask);\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"trace.h\"",
            "#include <asm/irq_remapping.h>",
            "#include <asm/apic.h>",
            "#include <asm/kexec.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/mce.h>",
            "#include <asm/virtext.h>",
            "#include <asm/vmx.h>",
            "#include <asm/desc.h>",
            "#include <asm/io.h>",
            "#include <asm/cpu.h>",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/hrtimer.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include \"lapic.h\"",
            "#include \"cpuid.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"trace.h\"\n#include <asm/irq_remapping.h>\n#include <asm/apic.h>\n#include <asm/kexec.h>\n#include <asm/debugreg.h>\n#include <asm/perf_event.h>\n#include <asm/fpu/internal.h>\n#include <asm/mce.h>\n#include <asm/virtext.h>\n#include <asm/vmx.h>\n#include <asm/desc.h>\n#include <asm/io.h>\n#include <asm/cpu.h>\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/hrtimer.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic __always_inline void vmcs_set_bits(unsigned long field, u32 mask)\n{\n        BUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x2000,\n\t\t\t \"vmcs_set_bits does not support 64-bit fields\");\n\t__vmcs_writel(field, __vmcs_readl(field) | mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "sregs->interrupt_bitmap",
            "0",
            "sizeof sregs->interrupt_bitmap"
          ],
          "line": 7047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_get_apic_base",
          "args": [
            "vcpu"
          ],
          "line": 7045
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_get_apic_base",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "283-286",
          "snippet": "u64 kvm_get_apic_base(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.apic_base;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nu64 kvm_get_apic_base(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.apic_base;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_get_cr8",
          "args": [
            "vcpu"
          ],
          "line": 7043
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_get_cr8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "816-822",
          "snippet": "unsigned long kvm_get_cr8(struct kvm_vcpu *vcpu)\n{\n\tif (lapic_in_kernel(vcpu))\n\t\treturn kvm_lapic_get_cr8(vcpu);\n\telse\n\t\treturn vcpu->arch.cr8;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nunsigned long kvm_get_cr8(struct kvm_vcpu *vcpu)\n{\n\tif (lapic_in_kernel(vcpu))\n\t\treturn kvm_lapic_get_cr8(vcpu);\n\telse\n\t\treturn vcpu->arch.cr8;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_read_cr4",
          "args": [
            "vcpu"
          ],
          "line": 7042
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_read_cr4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "76-79",
          "snippet": "static inline ulong kvm_read_cr4(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_read_cr4_bits(vcpu, ~0UL);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline ulong kvm_read_cr4(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_read_cr4_bits(vcpu, ~0UL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_read_cr3",
          "args": [
            "vcpu"
          ],
          "line": 7041
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_read_cr3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "69-74",
          "snippet": "static inline ulong kvm_read_cr3(struct kvm_vcpu *vcpu)\n{\n\tif (!test_bit(VCPU_EXREG_CR3, (ulong *)&vcpu->arch.regs_avail))\n\t\tkvm_x86_ops->decache_cr3(vcpu);\n\treturn vcpu->arch.cr3;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline ulong kvm_read_cr3(struct kvm_vcpu *vcpu)\n{\n\tif (!test_bit(VCPU_EXREG_CR3, (ulong *)&vcpu->arch.regs_avail))\n\t\tkvm_x86_ops->decache_cr3(vcpu);\n\treturn vcpu->arch.cr3;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_read_cr0",
          "args": [
            "vcpu"
          ],
          "line": 7039
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_read_cr0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "56-59",
          "snippet": "static inline ulong kvm_read_cr0(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_read_cr0_bits(vcpu, ~0UL);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline ulong kvm_read_cr0(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_read_cr0_bits(vcpu, ~0UL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_x86_ops->get_gdt",
          "args": [
            "vcpu",
            "&dt"
          ],
          "line": 7035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_x86_ops->get_idt",
          "args": [
            "vcpu",
            "&dt"
          ],
          "line": 7032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_get_segment",
          "args": [
            "vcpu",
            "&sregs->ldt",
            "VCPU_SREG_LDTR"
          ],
          "line": 7030
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_get_segment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "4157-4161",
          "snippet": "void kvm_get_segment(struct kvm_vcpu *vcpu,\n\t\t     struct kvm_segment *var, int seg)\n{\n\tkvm_x86_ops->get_segment(vcpu, var, seg);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "struct kvm_x86_ops *kvm_x86_ops"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nvoid kvm_get_segment(struct kvm_vcpu *vcpu,\n\t\t     struct kvm_segment *var, int seg)\n{\n\tkvm_x86_ops->get_segment(vcpu, var, seg);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nint kvm_arch_vcpu_ioctl_get_sregs(struct kvm_vcpu *vcpu,\n\t\t\t\t  struct kvm_sregs *sregs)\n{\n\tstruct desc_ptr dt;\n\n\tkvm_get_segment(vcpu, &sregs->cs, VCPU_SREG_CS);\n\tkvm_get_segment(vcpu, &sregs->ds, VCPU_SREG_DS);\n\tkvm_get_segment(vcpu, &sregs->es, VCPU_SREG_ES);\n\tkvm_get_segment(vcpu, &sregs->fs, VCPU_SREG_FS);\n\tkvm_get_segment(vcpu, &sregs->gs, VCPU_SREG_GS);\n\tkvm_get_segment(vcpu, &sregs->ss, VCPU_SREG_SS);\n\n\tkvm_get_segment(vcpu, &sregs->tr, VCPU_SREG_TR);\n\tkvm_get_segment(vcpu, &sregs->ldt, VCPU_SREG_LDTR);\n\n\tkvm_x86_ops->get_idt(vcpu, &dt);\n\tsregs->idt.limit = dt.size;\n\tsregs->idt.base = dt.address;\n\tkvm_x86_ops->get_gdt(vcpu, &dt);\n\tsregs->gdt.limit = dt.size;\n\tsregs->gdt.base = dt.address;\n\n\tsregs->cr0 = kvm_read_cr0(vcpu);\n\tsregs->cr2 = vcpu->arch.cr2;\n\tsregs->cr3 = kvm_read_cr3(vcpu);\n\tsregs->cr4 = kvm_read_cr4(vcpu);\n\tsregs->cr8 = kvm_get_cr8(vcpu);\n\tsregs->efer = vcpu->arch.efer;\n\tsregs->apic_base = kvm_get_apic_base(vcpu);\n\n\tmemset(sregs->interrupt_bitmap, 0, sizeof sregs->interrupt_bitmap);\n\n\tif (vcpu->arch.interrupt.pending && !vcpu->arch.interrupt.soft)\n\t\tset_bit(vcpu->arch.interrupt.nr,\n\t\t\t(unsigned long *)sregs->interrupt_bitmap);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "kvm_get_cs_db_l_bits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "7007-7014",
    "snippet": "void kvm_get_cs_db_l_bits(struct kvm_vcpu *vcpu, int *db, int *l)\n{\n\tstruct kvm_segment cs;\n\n\tkvm_get_segment(vcpu, &cs, VCPU_SREG_CS);\n\t*db = cs.db;\n\t*l = cs.l;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_get_segment",
          "args": [
            "vcpu",
            "&cs",
            "VCPU_SREG_CS"
          ],
          "line": 7011
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_get_segment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "4157-4161",
          "snippet": "void kvm_get_segment(struct kvm_vcpu *vcpu,\n\t\t     struct kvm_segment *var, int seg)\n{\n\tkvm_x86_ops->get_segment(vcpu, var, seg);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "struct kvm_x86_ops *kvm_x86_ops"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nvoid kvm_get_segment(struct kvm_vcpu *vcpu,\n\t\t     struct kvm_segment *var, int seg)\n{\n\tkvm_x86_ops->get_segment(vcpu, var, seg);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nvoid kvm_get_cs_db_l_bits(struct kvm_vcpu *vcpu, int *db, int *l)\n{\n\tstruct kvm_segment cs;\n\n\tkvm_get_segment(vcpu, &cs, VCPU_SREG_CS);\n\t*db = cs.db;\n\t*l = cs.l;\n}"
  },
  {
    "function_name": "kvm_arch_vcpu_ioctl_set_regs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "6973-7005",
    "snippet": "int kvm_arch_vcpu_ioctl_set_regs(struct kvm_vcpu *vcpu, struct kvm_regs *regs)\n{\n\tvcpu->arch.emulate_regs_need_sync_from_vcpu = true;\n\tvcpu->arch.emulate_regs_need_sync_to_vcpu = false;\n\n\tkvm_register_write(vcpu, VCPU_REGS_RAX, regs->rax);\n\tkvm_register_write(vcpu, VCPU_REGS_RBX, regs->rbx);\n\tkvm_register_write(vcpu, VCPU_REGS_RCX, regs->rcx);\n\tkvm_register_write(vcpu, VCPU_REGS_RDX, regs->rdx);\n\tkvm_register_write(vcpu, VCPU_REGS_RSI, regs->rsi);\n\tkvm_register_write(vcpu, VCPU_REGS_RDI, regs->rdi);\n\tkvm_register_write(vcpu, VCPU_REGS_RSP, regs->rsp);\n\tkvm_register_write(vcpu, VCPU_REGS_RBP, regs->rbp);\n#ifdef CONFIG_X86_64\n\tkvm_register_write(vcpu, VCPU_REGS_R8, regs->r8);\n\tkvm_register_write(vcpu, VCPU_REGS_R9, regs->r9);\n\tkvm_register_write(vcpu, VCPU_REGS_R10, regs->r10);\n\tkvm_register_write(vcpu, VCPU_REGS_R11, regs->r11);\n\tkvm_register_write(vcpu, VCPU_REGS_R12, regs->r12);\n\tkvm_register_write(vcpu, VCPU_REGS_R13, regs->r13);\n\tkvm_register_write(vcpu, VCPU_REGS_R14, regs->r14);\n\tkvm_register_write(vcpu, VCPU_REGS_R15, regs->r15);\n#endif\n\n\tkvm_rip_write(vcpu, regs->rip);\n\tkvm_set_rflags(vcpu, regs->rflags);\n\n\tvcpu->arch.exception.pending = false;\n\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);",
      "static void __kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_make_request",
          "args": [
            "KVM_REQ_EVENT",
            "vcpu"
          ],
          "line": 7002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_set_rflags",
          "args": [
            "vcpu",
            "regs->rflags"
          ],
          "line": 6998
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_set_rflags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "8182-8186",
          "snippet": "void kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags)\n{\n\t__kvm_set_rflags(vcpu, rflags);\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void __kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void __kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags);\n\nvoid kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags)\n{\n\t__kvm_set_rflags(vcpu, rflags);\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_rip_write",
          "args": [
            "vcpu",
            "regs->rip"
          ],
          "line": 6997
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_rip_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "32-35",
          "snippet": "static inline void kvm_rip_write(struct kvm_vcpu *vcpu, unsigned long val)\n{\n\tkvm_register_write(vcpu, VCPU_REGS_RIP, val);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void kvm_rip_write(struct kvm_vcpu *vcpu, unsigned long val)\n{\n\tkvm_register_write(vcpu, VCPU_REGS_RIP, val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_register_write",
          "args": [
            "vcpu",
            "VCPU_REGS_R15",
            "regs->r15"
          ],
          "line": 6994
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_register_writel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.h",
          "lines": "141-148",
          "snippet": "static inline void kvm_register_writel(struct kvm_vcpu *vcpu,\n\t\t\t\t       enum kvm_reg reg,\n\t\t\t\t       unsigned long val)\n{\n\tif (!is_64_bit_mode(vcpu))\n\t\tval = (u32)val;\n\treturn kvm_register_write(vcpu, reg, val);\n}",
          "includes": [
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline void kvm_register_writel(struct kvm_vcpu *vcpu,\n\t\t\t\t       enum kvm_reg reg,\n\t\t\t\t       unsigned long val)\n{\n\tif (!is_64_bit_mode(vcpu))\n\t\tval = (u32)val;\n\treturn kvm_register_write(vcpu, reg, val);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void __kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags);\n\nint kvm_arch_vcpu_ioctl_set_regs(struct kvm_vcpu *vcpu, struct kvm_regs *regs)\n{\n\tvcpu->arch.emulate_regs_need_sync_from_vcpu = true;\n\tvcpu->arch.emulate_regs_need_sync_to_vcpu = false;\n\n\tkvm_register_write(vcpu, VCPU_REGS_RAX, regs->rax);\n\tkvm_register_write(vcpu, VCPU_REGS_RBX, regs->rbx);\n\tkvm_register_write(vcpu, VCPU_REGS_RCX, regs->rcx);\n\tkvm_register_write(vcpu, VCPU_REGS_RDX, regs->rdx);\n\tkvm_register_write(vcpu, VCPU_REGS_RSI, regs->rsi);\n\tkvm_register_write(vcpu, VCPU_REGS_RDI, regs->rdi);\n\tkvm_register_write(vcpu, VCPU_REGS_RSP, regs->rsp);\n\tkvm_register_write(vcpu, VCPU_REGS_RBP, regs->rbp);\n#ifdef CONFIG_X86_64\n\tkvm_register_write(vcpu, VCPU_REGS_R8, regs->r8);\n\tkvm_register_write(vcpu, VCPU_REGS_R9, regs->r9);\n\tkvm_register_write(vcpu, VCPU_REGS_R10, regs->r10);\n\tkvm_register_write(vcpu, VCPU_REGS_R11, regs->r11);\n\tkvm_register_write(vcpu, VCPU_REGS_R12, regs->r12);\n\tkvm_register_write(vcpu, VCPU_REGS_R13, regs->r13);\n\tkvm_register_write(vcpu, VCPU_REGS_R14, regs->r14);\n\tkvm_register_write(vcpu, VCPU_REGS_R15, regs->r15);\n#endif\n\n\tkvm_rip_write(vcpu, regs->rip);\n\tkvm_set_rflags(vcpu, regs->rflags);\n\n\tvcpu->arch.exception.pending = false;\n\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "kvm_arch_vcpu_ioctl_get_regs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "6935-6971",
    "snippet": "int kvm_arch_vcpu_ioctl_get_regs(struct kvm_vcpu *vcpu, struct kvm_regs *regs)\n{\n\tif (vcpu->arch.emulate_regs_need_sync_to_vcpu) {\n\t\t/*\n\t\t * We are here if userspace calls get_regs() in the middle of\n\t\t * instruction emulation. Registers state needs to be copied\n\t\t * back from emulation context to vcpu. Userspace shouldn't do\n\t\t * that usually, but some bad designed PV devices (vmware\n\t\t * backdoor interface) need this to work\n\t\t */\n\t\temulator_writeback_register_cache(&vcpu->arch.emulate_ctxt);\n\t\tvcpu->arch.emulate_regs_need_sync_to_vcpu = false;\n\t}\n\tregs->rax = kvm_register_read(vcpu, VCPU_REGS_RAX);\n\tregs->rbx = kvm_register_read(vcpu, VCPU_REGS_RBX);\n\tregs->rcx = kvm_register_read(vcpu, VCPU_REGS_RCX);\n\tregs->rdx = kvm_register_read(vcpu, VCPU_REGS_RDX);\n\tregs->rsi = kvm_register_read(vcpu, VCPU_REGS_RSI);\n\tregs->rdi = kvm_register_read(vcpu, VCPU_REGS_RDI);\n\tregs->rsp = kvm_register_read(vcpu, VCPU_REGS_RSP);\n\tregs->rbp = kvm_register_read(vcpu, VCPU_REGS_RBP);\n#ifdef CONFIG_X86_64\n\tregs->r8 = kvm_register_read(vcpu, VCPU_REGS_R8);\n\tregs->r9 = kvm_register_read(vcpu, VCPU_REGS_R9);\n\tregs->r10 = kvm_register_read(vcpu, VCPU_REGS_R10);\n\tregs->r11 = kvm_register_read(vcpu, VCPU_REGS_R11);\n\tregs->r12 = kvm_register_read(vcpu, VCPU_REGS_R12);\n\tregs->r13 = kvm_register_read(vcpu, VCPU_REGS_R13);\n\tregs->r14 = kvm_register_read(vcpu, VCPU_REGS_R14);\n\tregs->r15 = kvm_register_read(vcpu, VCPU_REGS_R15);\n#endif\n\n\tregs->rip = kvm_rip_read(vcpu);\n\tregs->rflags = kvm_get_rflags(vcpu);\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);",
      "static void __kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_get_rflags",
          "args": [
            "vcpu"
          ],
          "line": 6968
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_get_rflags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "8163-8171",
          "snippet": "unsigned long kvm_get_rflags(struct kvm_vcpu *vcpu)\n{\n\tunsigned long rflags;\n\n\trflags = kvm_x86_ops->get_rflags(vcpu);\n\tif (vcpu->guest_debug & KVM_GUESTDBG_SINGLESTEP)\n\t\trflags &= ~X86_EFLAGS_TF;\n\treturn rflags;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void __kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags);",
            "struct kvm_x86_ops *kvm_x86_ops"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void __kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nunsigned long kvm_get_rflags(struct kvm_vcpu *vcpu)\n{\n\tunsigned long rflags;\n\n\trflags = kvm_x86_ops->get_rflags(vcpu);\n\tif (vcpu->guest_debug & KVM_GUESTDBG_SINGLESTEP)\n\t\trflags &= ~X86_EFLAGS_TF;\n\treturn rflags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_rip_read",
          "args": [
            "vcpu"
          ],
          "line": 6967
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_rip_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "27-30",
          "snippet": "static inline unsigned long kvm_rip_read(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_register_read(vcpu, VCPU_REGS_RIP);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline unsigned long kvm_rip_read(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_register_read(vcpu, VCPU_REGS_RIP);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_register_read",
          "args": [
            "vcpu",
            "VCPU_REGS_R15"
          ],
          "line": 6964
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_register_readl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.h",
          "lines": "133-139",
          "snippet": "static inline unsigned long kvm_register_readl(struct kvm_vcpu *vcpu,\n\t\t\t\t\t       enum kvm_reg reg)\n{\n\tunsigned long val = kvm_register_read(vcpu, reg);\n\n\treturn is_64_bit_mode(vcpu) ? val : (u32)val;\n}",
          "includes": [
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline unsigned long kvm_register_readl(struct kvm_vcpu *vcpu,\n\t\t\t\t\t       enum kvm_reg reg)\n{\n\tunsigned long val = kvm_register_read(vcpu, reg);\n\n\treturn is_64_bit_mode(vcpu) ? val : (u32)val;\n}"
        }
      },
      {
        "call_info": {
          "callee": "emulator_writeback_register_cache",
          "args": [
            "&vcpu->arch.emulate_ctxt"
          ],
          "line": 6945
        },
        "resolved": true,
        "details": {
          "function_name": "emulator_writeback_register_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "5493-5496",
          "snippet": "void emulator_writeback_register_cache(struct x86_emulate_ctxt *ctxt)\n{\n\twriteback_registers(ctxt);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nvoid emulator_writeback_register_cache(struct x86_emulate_ctxt *ctxt)\n{\n\twriteback_registers(ctxt);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void __kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags);\n\nint kvm_arch_vcpu_ioctl_get_regs(struct kvm_vcpu *vcpu, struct kvm_regs *regs)\n{\n\tif (vcpu->arch.emulate_regs_need_sync_to_vcpu) {\n\t\t/*\n\t\t * We are here if userspace calls get_regs() in the middle of\n\t\t * instruction emulation. Registers state needs to be copied\n\t\t * back from emulation context to vcpu. Userspace shouldn't do\n\t\t * that usually, but some bad designed PV devices (vmware\n\t\t * backdoor interface) need this to work\n\t\t */\n\t\temulator_writeback_register_cache(&vcpu->arch.emulate_ctxt);\n\t\tvcpu->arch.emulate_regs_need_sync_to_vcpu = false;\n\t}\n\tregs->rax = kvm_register_read(vcpu, VCPU_REGS_RAX);\n\tregs->rbx = kvm_register_read(vcpu, VCPU_REGS_RBX);\n\tregs->rcx = kvm_register_read(vcpu, VCPU_REGS_RCX);\n\tregs->rdx = kvm_register_read(vcpu, VCPU_REGS_RDX);\n\tregs->rsi = kvm_register_read(vcpu, VCPU_REGS_RSI);\n\tregs->rdi = kvm_register_read(vcpu, VCPU_REGS_RDI);\n\tregs->rsp = kvm_register_read(vcpu, VCPU_REGS_RSP);\n\tregs->rbp = kvm_register_read(vcpu, VCPU_REGS_RBP);\n#ifdef CONFIG_X86_64\n\tregs->r8 = kvm_register_read(vcpu, VCPU_REGS_R8);\n\tregs->r9 = kvm_register_read(vcpu, VCPU_REGS_R9);\n\tregs->r10 = kvm_register_read(vcpu, VCPU_REGS_R10);\n\tregs->r11 = kvm_register_read(vcpu, VCPU_REGS_R11);\n\tregs->r12 = kvm_register_read(vcpu, VCPU_REGS_R12);\n\tregs->r13 = kvm_register_read(vcpu, VCPU_REGS_R13);\n\tregs->r14 = kvm_register_read(vcpu, VCPU_REGS_R14);\n\tregs->r15 = kvm_register_read(vcpu, VCPU_REGS_R15);\n#endif\n\n\tregs->rip = kvm_rip_read(vcpu);\n\tregs->rflags = kvm_get_rflags(vcpu);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "kvm_arch_vcpu_ioctl_run",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "6889-6933",
    "snippet": "int kvm_arch_vcpu_ioctl_run(struct kvm_vcpu *vcpu, struct kvm_run *kvm_run)\n{\n\tstruct fpu *fpu = &current->thread.fpu;\n\tint r;\n\tsigset_t sigsaved;\n\n\tfpu__activate_curr(fpu);\n\n\tif (vcpu->sigset_active)\n\t\tsigprocmask(SIG_SETMASK, &vcpu->sigset, &sigsaved);\n\n\tif (unlikely(vcpu->arch.mp_state == KVM_MP_STATE_UNINITIALIZED)) {\n\t\tkvm_vcpu_block(vcpu);\n\t\tkvm_apic_accept_events(vcpu);\n\t\tclear_bit(KVM_REQ_UNHALT, &vcpu->requests);\n\t\tr = -EAGAIN;\n\t\tgoto out;\n\t}\n\n\t/* re-sync apic's tpr */\n\tif (!lapic_in_kernel(vcpu)) {\n\t\tif (kvm_set_cr8(vcpu, kvm_run->cr8) != 0) {\n\t\t\tr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (unlikely(vcpu->arch.complete_userspace_io)) {\n\t\tint (*cui)(struct kvm_vcpu *) = vcpu->arch.complete_userspace_io;\n\t\tvcpu->arch.complete_userspace_io = NULL;\n\t\tr = cui(vcpu);\n\t\tif (r <= 0)\n\t\t\tgoto out;\n\t} else\n\t\tWARN_ON(vcpu->arch.pio.count || vcpu->mmio_needed);\n\n\tr = vcpu_run(vcpu);\n\nout:\n\tpost_kvm_run_save(vcpu);\n\tif (vcpu->sigset_active)\n\t\tsigprocmask(SIG_SETMASK, &sigsaved, NULL);\n\n\treturn r;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sigprocmask",
          "args": [
            "SIG_SETMASK",
            "&sigsaved",
            "NULL"
          ],
          "line": 6930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "post_kvm_run_save",
          "args": [
            "vcpu"
          ],
          "line": 6928
        },
        "resolved": true,
        "details": {
          "function_name": "post_kvm_run_save",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "6018-6029",
          "snippet": "static void post_kvm_run_save(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_run *kvm_run = vcpu->run;\n\n\tkvm_run->if_flag = (kvm_get_rflags(vcpu) & X86_EFLAGS_IF) != 0;\n\tkvm_run->flags = is_smm(vcpu) ? KVM_RUN_X86_SMM : 0;\n\tkvm_run->cr8 = kvm_get_cr8(vcpu);\n\tkvm_run->apic_base = kvm_get_apic_base(vcpu);\n\tkvm_run->ready_for_interrupt_injection =\n\t\tpic_in_kernel(vcpu->kvm) ||\n\t\tkvm_vcpu_ready_for_interrupt_injection(vcpu);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic void post_kvm_run_save(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_run *kvm_run = vcpu->run;\n\n\tkvm_run->if_flag = (kvm_get_rflags(vcpu) & X86_EFLAGS_IF) != 0;\n\tkvm_run->flags = is_smm(vcpu) ? KVM_RUN_X86_SMM : 0;\n\tkvm_run->cr8 = kvm_get_cr8(vcpu);\n\tkvm_run->apic_base = kvm_get_apic_base(vcpu);\n\tkvm_run->ready_for_interrupt_injection =\n\t\tpic_in_kernel(vcpu->kvm) ||\n\t\tkvm_vcpu_ready_for_interrupt_injection(vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vcpu_run",
          "args": [
            "vcpu"
          ],
          "line": 6925
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_arch_vcpu_runnable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "8130-8136",
          "snippet": "int kvm_arch_vcpu_runnable(struct kvm_vcpu *vcpu)\n{\n\tif (is_guest_mode(vcpu) && kvm_x86_ops->check_nested_events)\n\t\tkvm_x86_ops->check_nested_events(vcpu, false);\n\n\treturn kvm_vcpu_running(vcpu) || kvm_vcpu_has_events(vcpu);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "struct kvm_x86_ops *kvm_x86_ops"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nint kvm_arch_vcpu_runnable(struct kvm_vcpu *vcpu)\n{\n\tif (is_guest_mode(vcpu) && kvm_x86_ops->check_nested_events)\n\t\tkvm_x86_ops->check_nested_events(vcpu, false);\n\n\treturn kvm_vcpu_running(vcpu) || kvm_vcpu_has_events(vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "vcpu->arch.pio.count || vcpu->mmio_needed"
          ],
          "line": 6923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cui",
          "args": [
            "vcpu"
          ],
          "line": 6919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "vcpu->arch.complete_userspace_io"
          ],
          "line": 6916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_set_cr8",
          "args": [
            "vcpu",
            "kvm_run->cr8"
          ],
          "line": 6910
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_set_cr8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "804-813",
          "snippet": "int kvm_set_cr8(struct kvm_vcpu *vcpu, unsigned long cr8)\n{\n\tif (cr8 & CR8_RESERVED_BITS)\n\t\treturn 1;\n\tif (lapic_in_kernel(vcpu))\n\t\tkvm_lapic_set_tpr(vcpu, cr8);\n\telse\n\t\tvcpu->arch.cr8 = cr8;\n\treturn 0;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nint kvm_set_cr8(struct kvm_vcpu *vcpu, unsigned long cr8)\n{\n\tif (cr8 & CR8_RESERVED_BITS)\n\t\treturn 1;\n\tif (lapic_in_kernel(vcpu))\n\t\tkvm_lapic_set_tpr(vcpu, cr8);\n\telse\n\t\tvcpu->arch.cr8 = cr8;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lapic_in_kernel",
          "args": [
            "vcpu"
          ],
          "line": 6909
        },
        "resolved": true,
        "details": {
          "function_name": "lapic_in_kernel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.h",
          "lines": "141-146",
          "snippet": "static inline bool lapic_in_kernel(struct kvm_vcpu *vcpu)\n{\n\tif (static_key_false(&kvm_no_apic_vcpu))\n\t\treturn vcpu->arch.apic;\n\treturn true;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline bool lapic_in_kernel(struct kvm_vcpu *vcpu)\n{\n\tif (static_key_false(&kvm_no_apic_vcpu))\n\t\treturn vcpu->arch.apic;\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "KVM_REQ_UNHALT",
            "&vcpu->requests"
          ],
          "line": 6903
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_clear_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/vmx.c",
          "lines": "1592-1597",
          "snippet": "static __always_inline void vmcs_clear_bits(unsigned long field, u32 mask)\n{\n        BUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x2000,\n\t\t\t \"vmcs_clear_bits does not support 64-bit fields\");\n\t__vmcs_writel(field, __vmcs_readl(field) & ~mask);\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"trace.h\"",
            "#include <asm/irq_remapping.h>",
            "#include <asm/apic.h>",
            "#include <asm/kexec.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/mce.h>",
            "#include <asm/virtext.h>",
            "#include <asm/vmx.h>",
            "#include <asm/desc.h>",
            "#include <asm/io.h>",
            "#include <asm/cpu.h>",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/hrtimer.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include \"lapic.h\"",
            "#include \"cpuid.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"trace.h\"\n#include <asm/irq_remapping.h>\n#include <asm/apic.h>\n#include <asm/kexec.h>\n#include <asm/debugreg.h>\n#include <asm/perf_event.h>\n#include <asm/fpu/internal.h>\n#include <asm/mce.h>\n#include <asm/virtext.h>\n#include <asm/vmx.h>\n#include <asm/desc.h>\n#include <asm/io.h>\n#include <asm/cpu.h>\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/hrtimer.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic __always_inline void vmcs_clear_bits(unsigned long field, u32 mask)\n{\n        BUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x2000,\n\t\t\t \"vmcs_clear_bits does not support 64-bit fields\");\n\t__vmcs_writel(field, __vmcs_readl(field) & ~mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_apic_accept_events",
          "args": [
            "vcpu"
          ],
          "line": 6902
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_accept_events",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "2195-2235",
          "snippet": "void kvm_apic_accept_events(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tu8 sipi_vector;\n\tunsigned long pe;\n\n\tif (!lapic_in_kernel(vcpu) || !apic->pending_events)\n\t\treturn;\n\n\t/*\n\t * INITs are latched while in SMM.  Because an SMM CPU cannot\n\t * be in KVM_MP_STATE_INIT_RECEIVED state, just eat SIPIs\n\t * and delay processing of INIT until the next RSM.\n\t */\n\tif (is_smm(vcpu)) {\n\t\tWARN_ON_ONCE(vcpu->arch.mp_state == KVM_MP_STATE_INIT_RECEIVED);\n\t\tif (test_bit(KVM_APIC_SIPI, &apic->pending_events))\n\t\t\tclear_bit(KVM_APIC_SIPI, &apic->pending_events);\n\t\treturn;\n\t}\n\n\tpe = xchg(&apic->pending_events, 0);\n\tif (test_bit(KVM_APIC_INIT, &pe)) {\n\t\tkvm_lapic_reset(vcpu, true);\n\t\tkvm_vcpu_reset(vcpu, true);\n\t\tif (kvm_vcpu_is_bsp(apic->vcpu))\n\t\t\tvcpu->arch.mp_state = KVM_MP_STATE_RUNNABLE;\n\t\telse\n\t\t\tvcpu->arch.mp_state = KVM_MP_STATE_INIT_RECEIVED;\n\t}\n\tif (test_bit(KVM_APIC_SIPI, &pe) &&\n\t    vcpu->arch.mp_state == KVM_MP_STATE_INIT_RECEIVED) {\n\t\t/* evaluate pending_events before reading the vector */\n\t\tsmp_rmb();\n\t\tsipi_vector = apic->sipi_vector;\n\t\tapic_debug(\"vcpu %d received sipi with vector # %x\\n\",\n\t\t\t vcpu->vcpu_id, sipi_vector);\n\t\tkvm_vcpu_deliver_sipi_vector(vcpu, sipi_vector);\n\t\tvcpu->arch.mp_state = KVM_MP_STATE_RUNNABLE;\n\t}\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nvoid kvm_apic_accept_events(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tu8 sipi_vector;\n\tunsigned long pe;\n\n\tif (!lapic_in_kernel(vcpu) || !apic->pending_events)\n\t\treturn;\n\n\t/*\n\t * INITs are latched while in SMM.  Because an SMM CPU cannot\n\t * be in KVM_MP_STATE_INIT_RECEIVED state, just eat SIPIs\n\t * and delay processing of INIT until the next RSM.\n\t */\n\tif (is_smm(vcpu)) {\n\t\tWARN_ON_ONCE(vcpu->arch.mp_state == KVM_MP_STATE_INIT_RECEIVED);\n\t\tif (test_bit(KVM_APIC_SIPI, &apic->pending_events))\n\t\t\tclear_bit(KVM_APIC_SIPI, &apic->pending_events);\n\t\treturn;\n\t}\n\n\tpe = xchg(&apic->pending_events, 0);\n\tif (test_bit(KVM_APIC_INIT, &pe)) {\n\t\tkvm_lapic_reset(vcpu, true);\n\t\tkvm_vcpu_reset(vcpu, true);\n\t\tif (kvm_vcpu_is_bsp(apic->vcpu))\n\t\t\tvcpu->arch.mp_state = KVM_MP_STATE_RUNNABLE;\n\t\telse\n\t\t\tvcpu->arch.mp_state = KVM_MP_STATE_INIT_RECEIVED;\n\t}\n\tif (test_bit(KVM_APIC_SIPI, &pe) &&\n\t    vcpu->arch.mp_state == KVM_MP_STATE_INIT_RECEIVED) {\n\t\t/* evaluate pending_events before reading the vector */\n\t\tsmp_rmb();\n\t\tsipi_vector = apic->sipi_vector;\n\t\tapic_debug(\"vcpu %d received sipi with vector # %x\\n\",\n\t\t\t vcpu->vcpu_id, sipi_vector);\n\t\tkvm_vcpu_deliver_sipi_vector(vcpu, sipi_vector);\n\t\tvcpu->arch.mp_state = KVM_MP_STATE_RUNNABLE;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_block",
          "args": [
            "vcpu"
          ],
          "line": 6901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "vcpu->arch.mp_state == KVM_MP_STATE_UNINITIALIZED"
          ],
          "line": 6900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigprocmask",
          "args": [
            "SIG_SETMASK",
            "&vcpu->sigset",
            "&sigsaved"
          ],
          "line": 6898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fpu__activate_curr",
          "args": [
            "fpu"
          ],
          "line": 6895
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nint kvm_arch_vcpu_ioctl_run(struct kvm_vcpu *vcpu, struct kvm_run *kvm_run)\n{\n\tstruct fpu *fpu = &current->thread.fpu;\n\tint r;\n\tsigset_t sigsaved;\n\n\tfpu__activate_curr(fpu);\n\n\tif (vcpu->sigset_active)\n\t\tsigprocmask(SIG_SETMASK, &vcpu->sigset, &sigsaved);\n\n\tif (unlikely(vcpu->arch.mp_state == KVM_MP_STATE_UNINITIALIZED)) {\n\t\tkvm_vcpu_block(vcpu);\n\t\tkvm_apic_accept_events(vcpu);\n\t\tclear_bit(KVM_REQ_UNHALT, &vcpu->requests);\n\t\tr = -EAGAIN;\n\t\tgoto out;\n\t}\n\n\t/* re-sync apic's tpr */\n\tif (!lapic_in_kernel(vcpu)) {\n\t\tif (kvm_set_cr8(vcpu, kvm_run->cr8) != 0) {\n\t\t\tr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (unlikely(vcpu->arch.complete_userspace_io)) {\n\t\tint (*cui)(struct kvm_vcpu *) = vcpu->arch.complete_userspace_io;\n\t\tvcpu->arch.complete_userspace_io = NULL;\n\t\tr = cui(vcpu);\n\t\tif (r <= 0)\n\t\t\tgoto out;\n\t} else\n\t\tWARN_ON(vcpu->arch.pio.count || vcpu->mmio_needed);\n\n\tr = vcpu_run(vcpu);\n\nout:\n\tpost_kvm_run_save(vcpu);\n\tif (vcpu->sigset_active)\n\t\tsigprocmask(SIG_SETMASK, &sigsaved, NULL);\n\n\treturn r;\n}"
  },
  {
    "function_name": "complete_emulated_mmio",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "6843-6886",
    "snippet": "static int complete_emulated_mmio(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_run *run = vcpu->run;\n\tstruct kvm_mmio_fragment *frag;\n\tunsigned len;\n\n\tBUG_ON(!vcpu->mmio_needed);\n\n\t/* Complete previous fragment */\n\tfrag = &vcpu->mmio_fragments[vcpu->mmio_cur_fragment];\n\tlen = min(8u, frag->len);\n\tif (!vcpu->mmio_is_write)\n\t\tmemcpy(frag->data, run->mmio.data, len);\n\n\tif (frag->len <= 8) {\n\t\t/* Switch to the next fragment. */\n\t\tfrag++;\n\t\tvcpu->mmio_cur_fragment++;\n\t} else {\n\t\t/* Go forward to the next mmio piece. */\n\t\tfrag->data += len;\n\t\tfrag->gpa += len;\n\t\tfrag->len -= len;\n\t}\n\n\tif (vcpu->mmio_cur_fragment >= vcpu->mmio_nr_fragments) {\n\t\tvcpu->mmio_needed = 0;\n\n\t\t/* FIXME: return into emulator if single-stepping.  */\n\t\tif (vcpu->mmio_is_write)\n\t\t\treturn 1;\n\t\tvcpu->mmio_read_completed = 1;\n\t\treturn complete_emulated_io(vcpu);\n\t}\n\n\trun->exit_reason = KVM_EXIT_MMIO;\n\trun->mmio.phys_addr = frag->gpa;\n\tif (vcpu->mmio_is_write)\n\t\tmemcpy(run->mmio.data, frag->data, min(8u, frag->len));\n\trun->mmio.len = min(8u, frag->len);\n\trun->mmio.is_write = vcpu->mmio_is_write;\n\tvcpu->arch.complete_userspace_io = complete_emulated_mmio;\n\treturn 0;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "min",
          "args": [
            "8u",
            "frag->len"
          ],
          "line": 6882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "run->mmio.data",
            "frag->data",
            "min(8u, frag->len)"
          ],
          "line": 6881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "8u",
            "frag->len"
          ],
          "line": 6881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "complete_emulated_io",
          "args": [
            "vcpu"
          ],
          "line": 6875
        },
        "resolved": true,
        "details": {
          "function_name": "complete_emulated_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "6807-6816",
          "snippet": "static inline int complete_emulated_io(struct kvm_vcpu *vcpu)\n{\n\tint r;\n\tvcpu->srcu_idx = srcu_read_lock(&vcpu->kvm->srcu);\n\tr = emulate_instruction(vcpu, EMULTYPE_NO_DECODE);\n\tsrcu_read_unlock(&vcpu->kvm->srcu, vcpu->srcu_idx);\n\tif (r != EMULATE_DONE)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic inline int complete_emulated_io(struct kvm_vcpu *vcpu)\n{\n\tint r;\n\tvcpu->srcu_idx = srcu_read_lock(&vcpu->kvm->srcu);\n\tr = emulate_instruction(vcpu, EMULTYPE_NO_DECODE);\n\tsrcu_read_unlock(&vcpu->kvm->srcu, vcpu->srcu_idx);\n\tif (r != EMULATE_DONE)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "frag->data",
            "run->mmio.data",
            "len"
          ],
          "line": 6855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "8u",
            "frag->len"
          ],
          "line": 6853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!vcpu->mmio_needed"
          ],
          "line": 6849
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_run *run = vcpu->run;\n\tstruct kvm_mmio_fragment *frag;\n\tunsigned len;\n\n\tBUG_ON(!vcpu->mmio_needed);\n\n\t/* Complete previous fragment */\n\tfrag = &vcpu->mmio_fragments[vcpu->mmio_cur_fragment];\n\tlen = min(8u, frag->len);\n\tif (!vcpu->mmio_is_write)\n\t\tmemcpy(frag->data, run->mmio.data, len);\n\n\tif (frag->len <= 8) {\n\t\t/* Switch to the next fragment. */\n\t\tfrag++;\n\t\tvcpu->mmio_cur_fragment++;\n\t} else {\n\t\t/* Go forward to the next mmio piece. */\n\t\tfrag->data += len;\n\t\tfrag->gpa += len;\n\t\tfrag->len -= len;\n\t}\n\n\tif (vcpu->mmio_cur_fragment >= vcpu->mmio_nr_fragments) {\n\t\tvcpu->mmio_needed = 0;\n\n\t\t/* FIXME: return into emulator if single-stepping.  */\n\t\tif (vcpu->mmio_is_write)\n\t\t\treturn 1;\n\t\tvcpu->mmio_read_completed = 1;\n\t\treturn complete_emulated_io(vcpu);\n\t}\n\n\trun->exit_reason = KVM_EXIT_MMIO;\n\trun->mmio.phys_addr = frag->gpa;\n\tif (vcpu->mmio_is_write)\n\t\tmemcpy(run->mmio.data, frag->data, min(8u, frag->len));\n\trun->mmio.len = min(8u, frag->len);\n\trun->mmio.is_write = vcpu->mmio_is_write;\n\tvcpu->arch.complete_userspace_io = complete_emulated_mmio;\n\treturn 0;\n}"
  },
  {
    "function_name": "complete_emulated_pio",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "6818-6823",
    "snippet": "static int complete_emulated_pio(struct kvm_vcpu *vcpu)\n{\n\tBUG_ON(!vcpu->arch.pio.count);\n\n\treturn complete_emulated_io(vcpu);\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "complete_emulated_io",
          "args": [
            "vcpu"
          ],
          "line": 6822
        },
        "resolved": true,
        "details": {
          "function_name": "complete_emulated_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "6807-6816",
          "snippet": "static inline int complete_emulated_io(struct kvm_vcpu *vcpu)\n{\n\tint r;\n\tvcpu->srcu_idx = srcu_read_lock(&vcpu->kvm->srcu);\n\tr = emulate_instruction(vcpu, EMULTYPE_NO_DECODE);\n\tsrcu_read_unlock(&vcpu->kvm->srcu, vcpu->srcu_idx);\n\tif (r != EMULATE_DONE)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic inline int complete_emulated_io(struct kvm_vcpu *vcpu)\n{\n\tint r;\n\tvcpu->srcu_idx = srcu_read_lock(&vcpu->kvm->srcu);\n\tr = emulate_instruction(vcpu, EMULTYPE_NO_DECODE);\n\tsrcu_read_unlock(&vcpu->kvm->srcu, vcpu->srcu_idx);\n\tif (r != EMULATE_DONE)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!vcpu->arch.pio.count"
          ],
          "line": 6820
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu)\n{\n\tBUG_ON(!vcpu->arch.pio.count);\n\n\treturn complete_emulated_io(vcpu);\n}"
  },
  {
    "function_name": "complete_emulated_io",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "6807-6816",
    "snippet": "static inline int complete_emulated_io(struct kvm_vcpu *vcpu)\n{\n\tint r;\n\tvcpu->srcu_idx = srcu_read_lock(&vcpu->kvm->srcu);\n\tr = emulate_instruction(vcpu, EMULTYPE_NO_DECODE);\n\tsrcu_read_unlock(&vcpu->kvm->srcu, vcpu->srcu_idx);\n\tif (r != EMULATE_DONE)\n\t\treturn 0;\n\treturn 1;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "srcu_read_unlock",
          "args": [
            "&vcpu->kvm->srcu",
            "vcpu->srcu_idx"
          ],
          "line": 6812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "emulate_instruction",
          "args": [
            "vcpu",
            "EMULTYPE_NO_DECODE"
          ],
          "line": 6811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "srcu_read_lock",
          "args": [
            "&vcpu->kvm->srcu"
          ],
          "line": 6810
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic inline int complete_emulated_io(struct kvm_vcpu *vcpu)\n{\n\tint r;\n\tvcpu->srcu_idx = srcu_read_lock(&vcpu->kvm->srcu);\n\tr = emulate_instruction(vcpu, EMULTYPE_NO_DECODE);\n\tsrcu_read_unlock(&vcpu->kvm->srcu, vcpu->srcu_idx);\n\tif (r != EMULATE_DONE)\n\t\treturn 0;\n\treturn 1;\n}"
  },
  {
    "function_name": "vcpu_run",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "6758-6805",
    "snippet": "static int vcpu_run(struct kvm_vcpu *vcpu)\n{\n\tint r;\n\tstruct kvm *kvm = vcpu->kvm;\n\n\tvcpu->srcu_idx = srcu_read_lock(&kvm->srcu);\n\n\tfor (;;) {\n\t\tif (kvm_vcpu_running(vcpu)) {\n\t\t\tr = vcpu_enter_guest(vcpu);\n\t\t} else {\n\t\t\tr = vcpu_block(kvm, vcpu);\n\t\t}\n\n\t\tif (r <= 0)\n\t\t\tbreak;\n\n\t\tclear_bit(KVM_REQ_PENDING_TIMER, &vcpu->requests);\n\t\tif (kvm_cpu_has_pending_timer(vcpu))\n\t\t\tkvm_inject_pending_timer_irqs(vcpu);\n\n\t\tif (dm_request_for_irq_injection(vcpu) &&\n\t\t\tkvm_vcpu_ready_for_interrupt_injection(vcpu)) {\n\t\t\tr = 0;\n\t\t\tvcpu->run->exit_reason = KVM_EXIT_IRQ_WINDOW_OPEN;\n\t\t\t++vcpu->stat.request_irq_exits;\n\t\t\tbreak;\n\t\t}\n\n\t\tkvm_check_async_pf_completion(vcpu);\n\n\t\tif (signal_pending(current)) {\n\t\t\tr = -EINTR;\n\t\t\tvcpu->run->exit_reason = KVM_EXIT_INTR;\n\t\t\t++vcpu->stat.signal_exits;\n\t\t\tbreak;\n\t\t}\n\t\tif (need_resched()) {\n\t\t\tsrcu_read_unlock(&kvm->srcu, vcpu->srcu_idx);\n\t\t\tcond_resched();\n\t\t\tvcpu->srcu_idx = srcu_read_lock(&kvm->srcu);\n\t\t}\n\t}\n\n\tsrcu_read_unlock(&kvm->srcu, vcpu->srcu_idx);\n\n\treturn r;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "srcu_read_unlock",
          "args": [
            "&kvm->srcu",
            "vcpu->srcu_idx"
          ],
          "line": 6802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "srcu_read_lock",
          "args": [
            "&kvm->srcu"
          ],
          "line": 6798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 6797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "srcu_read_unlock",
          "args": [
            "&kvm->srcu",
            "vcpu->srcu_idx"
          ],
          "line": 6796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "need_resched",
          "args": [],
          "line": 6795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal_pending",
          "args": [
            "current"
          ],
          "line": 6789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_check_async_pf_completion",
          "args": [
            "vcpu"
          ],
          "line": 6787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_ready_for_interrupt_injection",
          "args": [
            "vcpu"
          ],
          "line": 6780
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_vcpu_ready_for_interrupt_injection",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "2800-2806",
          "snippet": "static int kvm_vcpu_ready_for_interrupt_injection(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_arch_interrupt_allowed(vcpu) &&\n\t\t!kvm_cpu_has_interrupt(vcpu) &&\n\t\t!kvm_event_needs_reinjection(vcpu) &&\n\t\tkvm_cpu_accept_dm_intr(vcpu);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic int kvm_vcpu_ready_for_interrupt_injection(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_arch_interrupt_allowed(vcpu) &&\n\t\t!kvm_cpu_has_interrupt(vcpu) &&\n\t\t!kvm_event_needs_reinjection(vcpu) &&\n\t\tkvm_cpu_accept_dm_intr(vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dm_request_for_irq_injection",
          "args": [
            "vcpu"
          ],
          "line": 6779
        },
        "resolved": true,
        "details": {
          "function_name": "dm_request_for_irq_injection",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "6012-6016",
          "snippet": "static int dm_request_for_irq_injection(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->run->request_interrupt_window &&\n\t\tlikely(!pic_in_kernel(vcpu->kvm));\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic int dm_request_for_irq_injection(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->run->request_interrupt_window &&\n\t\tlikely(!pic_in_kernel(vcpu->kvm));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_inject_pending_timer_irqs",
          "args": [
            "vcpu"
          ],
          "line": 6777
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_inject_pending_timer_irqs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/irq.c",
          "lines": "141-145",
          "snippet": "void kvm_inject_pending_timer_irqs(struct kvm_vcpu *vcpu)\n{\n\tif (lapic_in_kernel(vcpu))\n\t\tkvm_inject_apic_timer_irqs(vcpu);\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"i8254.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"i8254.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n#include <linux/module.h>\n\nvoid kvm_inject_pending_timer_irqs(struct kvm_vcpu *vcpu)\n{\n\tif (lapic_in_kernel(vcpu))\n\t\tkvm_inject_apic_timer_irqs(vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_cpu_has_pending_timer",
          "args": [
            "vcpu"
          ],
          "line": 6776
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_cpu_has_pending_timer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/irq.c",
          "lines": "34-40",
          "snippet": "int kvm_cpu_has_pending_timer(struct kvm_vcpu *vcpu)\n{\n\tif (lapic_in_kernel(vcpu))\n\t\treturn apic_has_pending_timer(vcpu);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"i8254.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"i8254.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n#include <linux/module.h>\n\nint kvm_cpu_has_pending_timer(struct kvm_vcpu *vcpu)\n{\n\tif (lapic_in_kernel(vcpu))\n\t\treturn apic_has_pending_timer(vcpu);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "KVM_REQ_PENDING_TIMER",
            "&vcpu->requests"
          ],
          "line": 6775
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_clear_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/vmx.c",
          "lines": "1592-1597",
          "snippet": "static __always_inline void vmcs_clear_bits(unsigned long field, u32 mask)\n{\n        BUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x2000,\n\t\t\t \"vmcs_clear_bits does not support 64-bit fields\");\n\t__vmcs_writel(field, __vmcs_readl(field) & ~mask);\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"trace.h\"",
            "#include <asm/irq_remapping.h>",
            "#include <asm/apic.h>",
            "#include <asm/kexec.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/mce.h>",
            "#include <asm/virtext.h>",
            "#include <asm/vmx.h>",
            "#include <asm/desc.h>",
            "#include <asm/io.h>",
            "#include <asm/cpu.h>",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/hrtimer.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include \"lapic.h\"",
            "#include \"cpuid.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"trace.h\"\n#include <asm/irq_remapping.h>\n#include <asm/apic.h>\n#include <asm/kexec.h>\n#include <asm/debugreg.h>\n#include <asm/perf_event.h>\n#include <asm/fpu/internal.h>\n#include <asm/mce.h>\n#include <asm/virtext.h>\n#include <asm/vmx.h>\n#include <asm/desc.h>\n#include <asm/io.h>\n#include <asm/cpu.h>\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/hrtimer.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic __always_inline void vmcs_clear_bits(unsigned long field, u32 mask)\n{\n        BUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x2000,\n\t\t\t \"vmcs_clear_bits does not support 64-bit fields\");\n\t__vmcs_writel(field, __vmcs_readl(field) & ~mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vcpu_block",
          "args": [
            "kvm",
            "vcpu"
          ],
          "line": 6769
        },
        "resolved": true,
        "details": {
          "function_name": "vcpu_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "6719-6750",
          "snippet": "static inline int vcpu_block(struct kvm *kvm, struct kvm_vcpu *vcpu)\n{\n\tif (!kvm_arch_vcpu_runnable(vcpu) &&\n\t    (!kvm_x86_ops->pre_block || kvm_x86_ops->pre_block(vcpu) == 0)) {\n\t\tsrcu_read_unlock(&kvm->srcu, vcpu->srcu_idx);\n\t\tkvm_vcpu_block(vcpu);\n\t\tvcpu->srcu_idx = srcu_read_lock(&kvm->srcu);\n\n\t\tif (kvm_x86_ops->post_block)\n\t\t\tkvm_x86_ops->post_block(vcpu);\n\n\t\tif (!kvm_check_request(KVM_REQ_UNHALT, vcpu))\n\t\t\treturn 1;\n\t}\n\n\tkvm_apic_accept_events(vcpu);\n\tswitch(vcpu->arch.mp_state) {\n\tcase KVM_MP_STATE_HALTED:\n\t\tvcpu->arch.pv.pv_unhalted = false;\n\t\tvcpu->arch.mp_state =\n\t\t\tKVM_MP_STATE_RUNNABLE;\n\tcase KVM_MP_STATE_RUNNABLE:\n\t\tvcpu->arch.apf.halted = false;\n\t\tbreak;\n\tcase KVM_MP_STATE_INIT_RECEIVED:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINTR;\n\t\tbreak;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "struct kvm_x86_ops *kvm_x86_ops"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nstatic inline int vcpu_block(struct kvm *kvm, struct kvm_vcpu *vcpu)\n{\n\tif (!kvm_arch_vcpu_runnable(vcpu) &&\n\t    (!kvm_x86_ops->pre_block || kvm_x86_ops->pre_block(vcpu) == 0)) {\n\t\tsrcu_read_unlock(&kvm->srcu, vcpu->srcu_idx);\n\t\tkvm_vcpu_block(vcpu);\n\t\tvcpu->srcu_idx = srcu_read_lock(&kvm->srcu);\n\n\t\tif (kvm_x86_ops->post_block)\n\t\t\tkvm_x86_ops->post_block(vcpu);\n\n\t\tif (!kvm_check_request(KVM_REQ_UNHALT, vcpu))\n\t\t\treturn 1;\n\t}\n\n\tkvm_apic_accept_events(vcpu);\n\tswitch(vcpu->arch.mp_state) {\n\tcase KVM_MP_STATE_HALTED:\n\t\tvcpu->arch.pv.pv_unhalted = false;\n\t\tvcpu->arch.mp_state =\n\t\t\tKVM_MP_STATE_RUNNABLE;\n\tcase KVM_MP_STATE_RUNNABLE:\n\t\tvcpu->arch.apf.halted = false;\n\t\tbreak;\n\tcase KVM_MP_STATE_INIT_RECEIVED:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINTR;\n\t\tbreak;\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vcpu_enter_guest",
          "args": [
            "vcpu"
          ],
          "line": 6767
        },
        "resolved": true,
        "details": {
          "function_name": "vcpu_enter_guest",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "6449-6717",
          "snippet": "static int vcpu_enter_guest(struct kvm_vcpu *vcpu)\n{\n\tint r;\n\tbool req_int_win =\n\t\tdm_request_for_irq_injection(vcpu) &&\n\t\tkvm_cpu_accept_dm_intr(vcpu);\n\n\tbool req_immediate_exit = false;\n\n\tif (vcpu->requests) {\n\t\tif (kvm_check_request(KVM_REQ_MMU_RELOAD, vcpu))\n\t\t\tkvm_mmu_unload(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_MIGRATE_TIMER, vcpu))\n\t\t\t__kvm_migrate_timers(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_MASTERCLOCK_UPDATE, vcpu))\n\t\t\tkvm_gen_update_masterclock(vcpu->kvm);\n\t\tif (kvm_check_request(KVM_REQ_GLOBAL_CLOCK_UPDATE, vcpu))\n\t\t\tkvm_gen_kvmclock_update(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_CLOCK_UPDATE, vcpu)) {\n\t\t\tr = kvm_guest_time_update(vcpu);\n\t\t\tif (unlikely(r))\n\t\t\t\tgoto out;\n\t\t}\n\t\tif (kvm_check_request(KVM_REQ_MMU_SYNC, vcpu))\n\t\t\tkvm_mmu_sync_roots(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_TLB_FLUSH, vcpu))\n\t\t\tkvm_vcpu_flush_tlb(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_REPORT_TPR_ACCESS, vcpu)) {\n\t\t\tvcpu->run->exit_reason = KVM_EXIT_TPR_ACCESS;\n\t\t\tr = 0;\n\t\t\tgoto out;\n\t\t}\n\t\tif (kvm_check_request(KVM_REQ_TRIPLE_FAULT, vcpu)) {\n\t\t\tvcpu->run->exit_reason = KVM_EXIT_SHUTDOWN;\n\t\t\tr = 0;\n\t\t\tgoto out;\n\t\t}\n\t\tif (kvm_check_request(KVM_REQ_DEACTIVATE_FPU, vcpu)) {\n\t\t\tvcpu->fpu_active = 0;\n\t\t\tkvm_x86_ops->fpu_deactivate(vcpu);\n\t\t}\n\t\tif (kvm_check_request(KVM_REQ_APF_HALT, vcpu)) {\n\t\t\t/* Page is swapped out. Do synthetic halt */\n\t\t\tvcpu->arch.apf.halted = true;\n\t\t\tr = 1;\n\t\t\tgoto out;\n\t\t}\n\t\tif (kvm_check_request(KVM_REQ_STEAL_UPDATE, vcpu))\n\t\t\trecord_steal_time(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_SMI, vcpu))\n\t\t\tprocess_smi(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_NMI, vcpu))\n\t\t\tprocess_nmi(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_PMU, vcpu))\n\t\t\tkvm_pmu_handle_event(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_PMI, vcpu))\n\t\t\tkvm_pmu_deliver_pmi(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_IOAPIC_EOI_EXIT, vcpu)) {\n\t\t\tBUG_ON(vcpu->arch.pending_ioapic_eoi > 255);\n\t\t\tif (test_bit(vcpu->arch.pending_ioapic_eoi,\n\t\t\t\t     vcpu->arch.ioapic_handled_vectors)) {\n\t\t\t\tvcpu->run->exit_reason = KVM_EXIT_IOAPIC_EOI;\n\t\t\t\tvcpu->run->eoi.vector =\n\t\t\t\t\t\tvcpu->arch.pending_ioapic_eoi;\n\t\t\t\tr = 0;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tif (kvm_check_request(KVM_REQ_SCAN_IOAPIC, vcpu))\n\t\t\tvcpu_scan_ioapic(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_APIC_PAGE_RELOAD, vcpu))\n\t\t\tkvm_vcpu_reload_apic_access_page(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_HV_CRASH, vcpu)) {\n\t\t\tvcpu->run->exit_reason = KVM_EXIT_SYSTEM_EVENT;\n\t\t\tvcpu->run->system_event.type = KVM_SYSTEM_EVENT_CRASH;\n\t\t\tr = 0;\n\t\t\tgoto out;\n\t\t}\n\t\tif (kvm_check_request(KVM_REQ_HV_RESET, vcpu)) {\n\t\t\tvcpu->run->exit_reason = KVM_EXIT_SYSTEM_EVENT;\n\t\t\tvcpu->run->system_event.type = KVM_SYSTEM_EVENT_RESET;\n\t\t\tr = 0;\n\t\t\tgoto out;\n\t\t}\n\t\tif (kvm_check_request(KVM_REQ_HV_EXIT, vcpu)) {\n\t\t\tvcpu->run->exit_reason = KVM_EXIT_HYPERV;\n\t\t\tvcpu->run->hyperv = vcpu->arch.hyperv.exit;\n\t\t\tr = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * KVM_REQ_HV_STIMER has to be processed after\n\t\t * KVM_REQ_CLOCK_UPDATE, because Hyper-V SynIC timers\n\t\t * depend on the guest clock being up-to-date\n\t\t */\n\t\tif (kvm_check_request(KVM_REQ_HV_STIMER, vcpu))\n\t\t\tkvm_hv_process_stimers(vcpu);\n\t}\n\n\t/*\n\t * KVM_REQ_EVENT is not set when posted interrupts are set by\n\t * VT-d hardware, so we have to update RVI unconditionally.\n\t */\n\tif (kvm_lapic_enabled(vcpu)) {\n\t\t/*\n\t\t * Update architecture specific hints for APIC\n\t\t * virtual interrupt delivery.\n\t\t */\n\t\tif (vcpu->arch.apicv_active)\n\t\t\tkvm_x86_ops->hwapic_irr_update(vcpu,\n\t\t\t\tkvm_lapic_find_highest_irr(vcpu));\n\t}\n\n\tif (kvm_check_request(KVM_REQ_EVENT, vcpu) || req_int_win) {\n\t\tkvm_apic_accept_events(vcpu);\n\t\tif (vcpu->arch.mp_state == KVM_MP_STATE_INIT_RECEIVED) {\n\t\t\tr = 1;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (inject_pending_event(vcpu, req_int_win) != 0)\n\t\t\treq_immediate_exit = true;\n\t\t/* enable NMI/IRQ window open exits if needed */\n\t\telse {\n\t\t\tif (vcpu->arch.nmi_pending)\n\t\t\t\tkvm_x86_ops->enable_nmi_window(vcpu);\n\t\t\tif (kvm_cpu_has_injectable_intr(vcpu) || req_int_win)\n\t\t\t\tkvm_x86_ops->enable_irq_window(vcpu);\n\t\t}\n\n\t\tif (kvm_lapic_enabled(vcpu)) {\n\t\t\tupdate_cr8_intercept(vcpu);\n\t\t\tkvm_lapic_sync_to_vapic(vcpu);\n\t\t}\n\t}\n\n\tr = kvm_mmu_reload(vcpu);\n\tif (unlikely(r)) {\n\t\tgoto cancel_injection;\n\t}\n\n\tpreempt_disable();\n\n\tkvm_x86_ops->prepare_guest_switch(vcpu);\n\tif (vcpu->fpu_active)\n\t\tkvm_load_guest_fpu(vcpu);\n\tvcpu->mode = IN_GUEST_MODE;\n\n\tsrcu_read_unlock(&vcpu->kvm->srcu, vcpu->srcu_idx);\n\n\t/*\n\t * We should set ->mode before check ->requests,\n\t * Please see the comment in kvm_make_all_cpus_request.\n\t * This also orders the write to mode from any reads\n\t * to the page tables done while the VCPU is running.\n\t * Please see the comment in kvm_flush_remote_tlbs.\n\t */\n\tsmp_mb__after_srcu_read_unlock();\n\n\tlocal_irq_disable();\n\n\tif (vcpu->mode == EXITING_GUEST_MODE || vcpu->requests\n\t    || need_resched() || signal_pending(current)) {\n\t\tvcpu->mode = OUTSIDE_GUEST_MODE;\n\t\tsmp_wmb();\n\t\tlocal_irq_enable();\n\t\tpreempt_enable();\n\t\tvcpu->srcu_idx = srcu_read_lock(&vcpu->kvm->srcu);\n\t\tr = 1;\n\t\tgoto cancel_injection;\n\t}\n\n\tkvm_load_guest_xcr0(vcpu);\n\n\tif (req_immediate_exit)\n\t\tsmp_send_reschedule(vcpu->cpu);\n\n\ttrace_kvm_entry(vcpu->vcpu_id);\n\twait_lapic_expire(vcpu);\n\t__kvm_guest_enter();\n\n\tif (unlikely(vcpu->arch.switch_db_regs)) {\n\t\tset_debugreg(0, 7);\n\t\tset_debugreg(vcpu->arch.eff_db[0], 0);\n\t\tset_debugreg(vcpu->arch.eff_db[1], 1);\n\t\tset_debugreg(vcpu->arch.eff_db[2], 2);\n\t\tset_debugreg(vcpu->arch.eff_db[3], 3);\n\t\tset_debugreg(vcpu->arch.dr6, 6);\n\t\tvcpu->arch.switch_db_regs &= ~KVM_DEBUGREG_RELOAD;\n\t}\n\n\tkvm_x86_ops->run(vcpu);\n\n\t/*\n\t * Do this here before restoring debug registers on the host.  And\n\t * since we do this before handling the vmexit, a DR access vmexit\n\t * can (a) read the correct value of the debug registers, (b) set\n\t * KVM_DEBUGREG_WONT_EXIT again.\n\t */\n\tif (unlikely(vcpu->arch.switch_db_regs & KVM_DEBUGREG_WONT_EXIT)) {\n\t\tWARN_ON(vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP);\n\t\tkvm_x86_ops->sync_dirty_debug_regs(vcpu);\n\t\tkvm_update_dr0123(vcpu);\n\t\tkvm_update_dr6(vcpu);\n\t\tkvm_update_dr7(vcpu);\n\t\tvcpu->arch.switch_db_regs &= ~KVM_DEBUGREG_RELOAD;\n\t}\n\n\t/*\n\t * If the guest has used debug registers, at least dr7\n\t * will be disabled while returning to the host.\n\t * If we don't have active breakpoints in the host, we don't\n\t * care about the messed up debug address registers. But if\n\t * we have some of them active, restore the old state.\n\t */\n\tif (hw_breakpoint_active())\n\t\thw_breakpoint_restore();\n\n\tvcpu->arch.last_guest_tsc = kvm_read_l1_tsc(vcpu, rdtsc());\n\n\tvcpu->mode = OUTSIDE_GUEST_MODE;\n\tsmp_wmb();\n\n\tkvm_put_guest_xcr0(vcpu);\n\n\t/* Interrupt is enabled by handle_external_intr() */\n\tkvm_x86_ops->handle_external_intr(vcpu);\n\n\t++vcpu->stat.exits;\n\n\t/*\n\t * We must have an instruction between local_irq_enable() and\n\t * kvm_guest_exit(), so the timer interrupt isn't delayed by\n\t * the interrupt shadow.  The stat.exits increment will do nicely.\n\t * But we need to prevent reordering, hence this barrier():\n\t */\n\tbarrier();\n\n\tkvm_guest_exit();\n\n\tpreempt_enable();\n\n\tvcpu->srcu_idx = srcu_read_lock(&vcpu->kvm->srcu);\n\n\t/*\n\t * Profile KVM exit RIPs:\n\t */\n\tif (unlikely(prof_on == KVM_PROFILING)) {\n\t\tunsigned long rip = kvm_rip_read(vcpu);\n\t\tprofile_hit(KVM_PROFILING, (void *)rip);\n\t}\n\n\tif (unlikely(vcpu->arch.tsc_always_catchup))\n\t\tkvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);\n\n\tif (vcpu->arch.apic_attention)\n\t\tkvm_lapic_sync_from_vapic(vcpu);\n\n\tr = kvm_x86_ops->handle_exit(vcpu);\n\treturn r;\n\ncancel_injection:\n\tkvm_x86_ops->cancel_injection(vcpu);\n\tif (unlikely(vcpu->arch.apic_attention))\n\t\tkvm_lapic_sync_from_vapic(vcpu);\nout:\n\treturn r;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "struct kvm_x86_ops *kvm_x86_ops"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nstatic int vcpu_enter_guest(struct kvm_vcpu *vcpu)\n{\n\tint r;\n\tbool req_int_win =\n\t\tdm_request_for_irq_injection(vcpu) &&\n\t\tkvm_cpu_accept_dm_intr(vcpu);\n\n\tbool req_immediate_exit = false;\n\n\tif (vcpu->requests) {\n\t\tif (kvm_check_request(KVM_REQ_MMU_RELOAD, vcpu))\n\t\t\tkvm_mmu_unload(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_MIGRATE_TIMER, vcpu))\n\t\t\t__kvm_migrate_timers(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_MASTERCLOCK_UPDATE, vcpu))\n\t\t\tkvm_gen_update_masterclock(vcpu->kvm);\n\t\tif (kvm_check_request(KVM_REQ_GLOBAL_CLOCK_UPDATE, vcpu))\n\t\t\tkvm_gen_kvmclock_update(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_CLOCK_UPDATE, vcpu)) {\n\t\t\tr = kvm_guest_time_update(vcpu);\n\t\t\tif (unlikely(r))\n\t\t\t\tgoto out;\n\t\t}\n\t\tif (kvm_check_request(KVM_REQ_MMU_SYNC, vcpu))\n\t\t\tkvm_mmu_sync_roots(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_TLB_FLUSH, vcpu))\n\t\t\tkvm_vcpu_flush_tlb(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_REPORT_TPR_ACCESS, vcpu)) {\n\t\t\tvcpu->run->exit_reason = KVM_EXIT_TPR_ACCESS;\n\t\t\tr = 0;\n\t\t\tgoto out;\n\t\t}\n\t\tif (kvm_check_request(KVM_REQ_TRIPLE_FAULT, vcpu)) {\n\t\t\tvcpu->run->exit_reason = KVM_EXIT_SHUTDOWN;\n\t\t\tr = 0;\n\t\t\tgoto out;\n\t\t}\n\t\tif (kvm_check_request(KVM_REQ_DEACTIVATE_FPU, vcpu)) {\n\t\t\tvcpu->fpu_active = 0;\n\t\t\tkvm_x86_ops->fpu_deactivate(vcpu);\n\t\t}\n\t\tif (kvm_check_request(KVM_REQ_APF_HALT, vcpu)) {\n\t\t\t/* Page is swapped out. Do synthetic halt */\n\t\t\tvcpu->arch.apf.halted = true;\n\t\t\tr = 1;\n\t\t\tgoto out;\n\t\t}\n\t\tif (kvm_check_request(KVM_REQ_STEAL_UPDATE, vcpu))\n\t\t\trecord_steal_time(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_SMI, vcpu))\n\t\t\tprocess_smi(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_NMI, vcpu))\n\t\t\tprocess_nmi(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_PMU, vcpu))\n\t\t\tkvm_pmu_handle_event(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_PMI, vcpu))\n\t\t\tkvm_pmu_deliver_pmi(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_IOAPIC_EOI_EXIT, vcpu)) {\n\t\t\tBUG_ON(vcpu->arch.pending_ioapic_eoi > 255);\n\t\t\tif (test_bit(vcpu->arch.pending_ioapic_eoi,\n\t\t\t\t     vcpu->arch.ioapic_handled_vectors)) {\n\t\t\t\tvcpu->run->exit_reason = KVM_EXIT_IOAPIC_EOI;\n\t\t\t\tvcpu->run->eoi.vector =\n\t\t\t\t\t\tvcpu->arch.pending_ioapic_eoi;\n\t\t\t\tr = 0;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tif (kvm_check_request(KVM_REQ_SCAN_IOAPIC, vcpu))\n\t\t\tvcpu_scan_ioapic(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_APIC_PAGE_RELOAD, vcpu))\n\t\t\tkvm_vcpu_reload_apic_access_page(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_HV_CRASH, vcpu)) {\n\t\t\tvcpu->run->exit_reason = KVM_EXIT_SYSTEM_EVENT;\n\t\t\tvcpu->run->system_event.type = KVM_SYSTEM_EVENT_CRASH;\n\t\t\tr = 0;\n\t\t\tgoto out;\n\t\t}\n\t\tif (kvm_check_request(KVM_REQ_HV_RESET, vcpu)) {\n\t\t\tvcpu->run->exit_reason = KVM_EXIT_SYSTEM_EVENT;\n\t\t\tvcpu->run->system_event.type = KVM_SYSTEM_EVENT_RESET;\n\t\t\tr = 0;\n\t\t\tgoto out;\n\t\t}\n\t\tif (kvm_check_request(KVM_REQ_HV_EXIT, vcpu)) {\n\t\t\tvcpu->run->exit_reason = KVM_EXIT_HYPERV;\n\t\t\tvcpu->run->hyperv = vcpu->arch.hyperv.exit;\n\t\t\tr = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * KVM_REQ_HV_STIMER has to be processed after\n\t\t * KVM_REQ_CLOCK_UPDATE, because Hyper-V SynIC timers\n\t\t * depend on the guest clock being up-to-date\n\t\t */\n\t\tif (kvm_check_request(KVM_REQ_HV_STIMER, vcpu))\n\t\t\tkvm_hv_process_stimers(vcpu);\n\t}\n\n\t/*\n\t * KVM_REQ_EVENT is not set when posted interrupts are set by\n\t * VT-d hardware, so we have to update RVI unconditionally.\n\t */\n\tif (kvm_lapic_enabled(vcpu)) {\n\t\t/*\n\t\t * Update architecture specific hints for APIC\n\t\t * virtual interrupt delivery.\n\t\t */\n\t\tif (vcpu->arch.apicv_active)\n\t\t\tkvm_x86_ops->hwapic_irr_update(vcpu,\n\t\t\t\tkvm_lapic_find_highest_irr(vcpu));\n\t}\n\n\tif (kvm_check_request(KVM_REQ_EVENT, vcpu) || req_int_win) {\n\t\tkvm_apic_accept_events(vcpu);\n\t\tif (vcpu->arch.mp_state == KVM_MP_STATE_INIT_RECEIVED) {\n\t\t\tr = 1;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (inject_pending_event(vcpu, req_int_win) != 0)\n\t\t\treq_immediate_exit = true;\n\t\t/* enable NMI/IRQ window open exits if needed */\n\t\telse {\n\t\t\tif (vcpu->arch.nmi_pending)\n\t\t\t\tkvm_x86_ops->enable_nmi_window(vcpu);\n\t\t\tif (kvm_cpu_has_injectable_intr(vcpu) || req_int_win)\n\t\t\t\tkvm_x86_ops->enable_irq_window(vcpu);\n\t\t}\n\n\t\tif (kvm_lapic_enabled(vcpu)) {\n\t\t\tupdate_cr8_intercept(vcpu);\n\t\t\tkvm_lapic_sync_to_vapic(vcpu);\n\t\t}\n\t}\n\n\tr = kvm_mmu_reload(vcpu);\n\tif (unlikely(r)) {\n\t\tgoto cancel_injection;\n\t}\n\n\tpreempt_disable();\n\n\tkvm_x86_ops->prepare_guest_switch(vcpu);\n\tif (vcpu->fpu_active)\n\t\tkvm_load_guest_fpu(vcpu);\n\tvcpu->mode = IN_GUEST_MODE;\n\n\tsrcu_read_unlock(&vcpu->kvm->srcu, vcpu->srcu_idx);\n\n\t/*\n\t * We should set ->mode before check ->requests,\n\t * Please see the comment in kvm_make_all_cpus_request.\n\t * This also orders the write to mode from any reads\n\t * to the page tables done while the VCPU is running.\n\t * Please see the comment in kvm_flush_remote_tlbs.\n\t */\n\tsmp_mb__after_srcu_read_unlock();\n\n\tlocal_irq_disable();\n\n\tif (vcpu->mode == EXITING_GUEST_MODE || vcpu->requests\n\t    || need_resched() || signal_pending(current)) {\n\t\tvcpu->mode = OUTSIDE_GUEST_MODE;\n\t\tsmp_wmb();\n\t\tlocal_irq_enable();\n\t\tpreempt_enable();\n\t\tvcpu->srcu_idx = srcu_read_lock(&vcpu->kvm->srcu);\n\t\tr = 1;\n\t\tgoto cancel_injection;\n\t}\n\n\tkvm_load_guest_xcr0(vcpu);\n\n\tif (req_immediate_exit)\n\t\tsmp_send_reschedule(vcpu->cpu);\n\n\ttrace_kvm_entry(vcpu->vcpu_id);\n\twait_lapic_expire(vcpu);\n\t__kvm_guest_enter();\n\n\tif (unlikely(vcpu->arch.switch_db_regs)) {\n\t\tset_debugreg(0, 7);\n\t\tset_debugreg(vcpu->arch.eff_db[0], 0);\n\t\tset_debugreg(vcpu->arch.eff_db[1], 1);\n\t\tset_debugreg(vcpu->arch.eff_db[2], 2);\n\t\tset_debugreg(vcpu->arch.eff_db[3], 3);\n\t\tset_debugreg(vcpu->arch.dr6, 6);\n\t\tvcpu->arch.switch_db_regs &= ~KVM_DEBUGREG_RELOAD;\n\t}\n\n\tkvm_x86_ops->run(vcpu);\n\n\t/*\n\t * Do this here before restoring debug registers on the host.  And\n\t * since we do this before handling the vmexit, a DR access vmexit\n\t * can (a) read the correct value of the debug registers, (b) set\n\t * KVM_DEBUGREG_WONT_EXIT again.\n\t */\n\tif (unlikely(vcpu->arch.switch_db_regs & KVM_DEBUGREG_WONT_EXIT)) {\n\t\tWARN_ON(vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP);\n\t\tkvm_x86_ops->sync_dirty_debug_regs(vcpu);\n\t\tkvm_update_dr0123(vcpu);\n\t\tkvm_update_dr6(vcpu);\n\t\tkvm_update_dr7(vcpu);\n\t\tvcpu->arch.switch_db_regs &= ~KVM_DEBUGREG_RELOAD;\n\t}\n\n\t/*\n\t * If the guest has used debug registers, at least dr7\n\t * will be disabled while returning to the host.\n\t * If we don't have active breakpoints in the host, we don't\n\t * care about the messed up debug address registers. But if\n\t * we have some of them active, restore the old state.\n\t */\n\tif (hw_breakpoint_active())\n\t\thw_breakpoint_restore();\n\n\tvcpu->arch.last_guest_tsc = kvm_read_l1_tsc(vcpu, rdtsc());\n\n\tvcpu->mode = OUTSIDE_GUEST_MODE;\n\tsmp_wmb();\n\n\tkvm_put_guest_xcr0(vcpu);\n\n\t/* Interrupt is enabled by handle_external_intr() */\n\tkvm_x86_ops->handle_external_intr(vcpu);\n\n\t++vcpu->stat.exits;\n\n\t/*\n\t * We must have an instruction between local_irq_enable() and\n\t * kvm_guest_exit(), so the timer interrupt isn't delayed by\n\t * the interrupt shadow.  The stat.exits increment will do nicely.\n\t * But we need to prevent reordering, hence this barrier():\n\t */\n\tbarrier();\n\n\tkvm_guest_exit();\n\n\tpreempt_enable();\n\n\tvcpu->srcu_idx = srcu_read_lock(&vcpu->kvm->srcu);\n\n\t/*\n\t * Profile KVM exit RIPs:\n\t */\n\tif (unlikely(prof_on == KVM_PROFILING)) {\n\t\tunsigned long rip = kvm_rip_read(vcpu);\n\t\tprofile_hit(KVM_PROFILING, (void *)rip);\n\t}\n\n\tif (unlikely(vcpu->arch.tsc_always_catchup))\n\t\tkvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);\n\n\tif (vcpu->arch.apic_attention)\n\t\tkvm_lapic_sync_from_vapic(vcpu);\n\n\tr = kvm_x86_ops->handle_exit(vcpu);\n\treturn r;\n\ncancel_injection:\n\tkvm_x86_ops->cancel_injection(vcpu);\n\tif (unlikely(vcpu->arch.apic_attention))\n\t\tkvm_lapic_sync_from_vapic(vcpu);\nout:\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_running",
          "args": [
            "vcpu"
          ],
          "line": 6766
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_vcpu_running",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "6752-6756",
          "snippet": "static inline bool kvm_vcpu_running(struct kvm_vcpu *vcpu)\n{\n\treturn (vcpu->arch.mp_state == KVM_MP_STATE_RUNNABLE &&\n\t\t!vcpu->arch.apf.halted);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic inline bool kvm_vcpu_running(struct kvm_vcpu *vcpu)\n{\n\treturn (vcpu->arch.mp_state == KVM_MP_STATE_RUNNABLE &&\n\t\t!vcpu->arch.apf.halted);\n}"
        }
      },
      {
        "call_info": {
          "callee": "srcu_read_lock",
          "args": [
            "&kvm->srcu"
          ],
          "line": 6763
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic int vcpu_run(struct kvm_vcpu *vcpu)\n{\n\tint r;\n\tstruct kvm *kvm = vcpu->kvm;\n\n\tvcpu->srcu_idx = srcu_read_lock(&kvm->srcu);\n\n\tfor (;;) {\n\t\tif (kvm_vcpu_running(vcpu)) {\n\t\t\tr = vcpu_enter_guest(vcpu);\n\t\t} else {\n\t\t\tr = vcpu_block(kvm, vcpu);\n\t\t}\n\n\t\tif (r <= 0)\n\t\t\tbreak;\n\n\t\tclear_bit(KVM_REQ_PENDING_TIMER, &vcpu->requests);\n\t\tif (kvm_cpu_has_pending_timer(vcpu))\n\t\t\tkvm_inject_pending_timer_irqs(vcpu);\n\n\t\tif (dm_request_for_irq_injection(vcpu) &&\n\t\t\tkvm_vcpu_ready_for_interrupt_injection(vcpu)) {\n\t\t\tr = 0;\n\t\t\tvcpu->run->exit_reason = KVM_EXIT_IRQ_WINDOW_OPEN;\n\t\t\t++vcpu->stat.request_irq_exits;\n\t\t\tbreak;\n\t\t}\n\n\t\tkvm_check_async_pf_completion(vcpu);\n\n\t\tif (signal_pending(current)) {\n\t\t\tr = -EINTR;\n\t\t\tvcpu->run->exit_reason = KVM_EXIT_INTR;\n\t\t\t++vcpu->stat.signal_exits;\n\t\t\tbreak;\n\t\t}\n\t\tif (need_resched()) {\n\t\t\tsrcu_read_unlock(&kvm->srcu, vcpu->srcu_idx);\n\t\t\tcond_resched();\n\t\t\tvcpu->srcu_idx = srcu_read_lock(&kvm->srcu);\n\t\t}\n\t}\n\n\tsrcu_read_unlock(&kvm->srcu, vcpu->srcu_idx);\n\n\treturn r;\n}"
  },
  {
    "function_name": "kvm_vcpu_running",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "6752-6756",
    "snippet": "static inline bool kvm_vcpu_running(struct kvm_vcpu *vcpu)\n{\n\treturn (vcpu->arch.mp_state == KVM_MP_STATE_RUNNABLE &&\n\t\t!vcpu->arch.apf.halted);\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic inline bool kvm_vcpu_running(struct kvm_vcpu *vcpu)\n{\n\treturn (vcpu->arch.mp_state == KVM_MP_STATE_RUNNABLE &&\n\t\t!vcpu->arch.apf.halted);\n}"
  },
  {
    "function_name": "vcpu_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "6719-6750",
    "snippet": "static inline int vcpu_block(struct kvm *kvm, struct kvm_vcpu *vcpu)\n{\n\tif (!kvm_arch_vcpu_runnable(vcpu) &&\n\t    (!kvm_x86_ops->pre_block || kvm_x86_ops->pre_block(vcpu) == 0)) {\n\t\tsrcu_read_unlock(&kvm->srcu, vcpu->srcu_idx);\n\t\tkvm_vcpu_block(vcpu);\n\t\tvcpu->srcu_idx = srcu_read_lock(&kvm->srcu);\n\n\t\tif (kvm_x86_ops->post_block)\n\t\t\tkvm_x86_ops->post_block(vcpu);\n\n\t\tif (!kvm_check_request(KVM_REQ_UNHALT, vcpu))\n\t\t\treturn 1;\n\t}\n\n\tkvm_apic_accept_events(vcpu);\n\tswitch(vcpu->arch.mp_state) {\n\tcase KVM_MP_STATE_HALTED:\n\t\tvcpu->arch.pv.pv_unhalted = false;\n\t\tvcpu->arch.mp_state =\n\t\t\tKVM_MP_STATE_RUNNABLE;\n\tcase KVM_MP_STATE_RUNNABLE:\n\t\tvcpu->arch.apf.halted = false;\n\t\tbreak;\n\tcase KVM_MP_STATE_INIT_RECEIVED:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINTR;\n\t\tbreak;\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);",
      "struct kvm_x86_ops *kvm_x86_ops"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_apic_accept_events",
          "args": [
            "vcpu"
          ],
          "line": 6734
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_accept_events",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "2195-2235",
          "snippet": "void kvm_apic_accept_events(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tu8 sipi_vector;\n\tunsigned long pe;\n\n\tif (!lapic_in_kernel(vcpu) || !apic->pending_events)\n\t\treturn;\n\n\t/*\n\t * INITs are latched while in SMM.  Because an SMM CPU cannot\n\t * be in KVM_MP_STATE_INIT_RECEIVED state, just eat SIPIs\n\t * and delay processing of INIT until the next RSM.\n\t */\n\tif (is_smm(vcpu)) {\n\t\tWARN_ON_ONCE(vcpu->arch.mp_state == KVM_MP_STATE_INIT_RECEIVED);\n\t\tif (test_bit(KVM_APIC_SIPI, &apic->pending_events))\n\t\t\tclear_bit(KVM_APIC_SIPI, &apic->pending_events);\n\t\treturn;\n\t}\n\n\tpe = xchg(&apic->pending_events, 0);\n\tif (test_bit(KVM_APIC_INIT, &pe)) {\n\t\tkvm_lapic_reset(vcpu, true);\n\t\tkvm_vcpu_reset(vcpu, true);\n\t\tif (kvm_vcpu_is_bsp(apic->vcpu))\n\t\t\tvcpu->arch.mp_state = KVM_MP_STATE_RUNNABLE;\n\t\telse\n\t\t\tvcpu->arch.mp_state = KVM_MP_STATE_INIT_RECEIVED;\n\t}\n\tif (test_bit(KVM_APIC_SIPI, &pe) &&\n\t    vcpu->arch.mp_state == KVM_MP_STATE_INIT_RECEIVED) {\n\t\t/* evaluate pending_events before reading the vector */\n\t\tsmp_rmb();\n\t\tsipi_vector = apic->sipi_vector;\n\t\tapic_debug(\"vcpu %d received sipi with vector # %x\\n\",\n\t\t\t vcpu->vcpu_id, sipi_vector);\n\t\tkvm_vcpu_deliver_sipi_vector(vcpu, sipi_vector);\n\t\tvcpu->arch.mp_state = KVM_MP_STATE_RUNNABLE;\n\t}\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nvoid kvm_apic_accept_events(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tu8 sipi_vector;\n\tunsigned long pe;\n\n\tif (!lapic_in_kernel(vcpu) || !apic->pending_events)\n\t\treturn;\n\n\t/*\n\t * INITs are latched while in SMM.  Because an SMM CPU cannot\n\t * be in KVM_MP_STATE_INIT_RECEIVED state, just eat SIPIs\n\t * and delay processing of INIT until the next RSM.\n\t */\n\tif (is_smm(vcpu)) {\n\t\tWARN_ON_ONCE(vcpu->arch.mp_state == KVM_MP_STATE_INIT_RECEIVED);\n\t\tif (test_bit(KVM_APIC_SIPI, &apic->pending_events))\n\t\t\tclear_bit(KVM_APIC_SIPI, &apic->pending_events);\n\t\treturn;\n\t}\n\n\tpe = xchg(&apic->pending_events, 0);\n\tif (test_bit(KVM_APIC_INIT, &pe)) {\n\t\tkvm_lapic_reset(vcpu, true);\n\t\tkvm_vcpu_reset(vcpu, true);\n\t\tif (kvm_vcpu_is_bsp(apic->vcpu))\n\t\t\tvcpu->arch.mp_state = KVM_MP_STATE_RUNNABLE;\n\t\telse\n\t\t\tvcpu->arch.mp_state = KVM_MP_STATE_INIT_RECEIVED;\n\t}\n\tif (test_bit(KVM_APIC_SIPI, &pe) &&\n\t    vcpu->arch.mp_state == KVM_MP_STATE_INIT_RECEIVED) {\n\t\t/* evaluate pending_events before reading the vector */\n\t\tsmp_rmb();\n\t\tsipi_vector = apic->sipi_vector;\n\t\tapic_debug(\"vcpu %d received sipi with vector # %x\\n\",\n\t\t\t vcpu->vcpu_id, sipi_vector);\n\t\tkvm_vcpu_deliver_sipi_vector(vcpu, sipi_vector);\n\t\tvcpu->arch.mp_state = KVM_MP_STATE_RUNNABLE;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_check_request",
          "args": [
            "KVM_REQ_UNHALT",
            "vcpu"
          ],
          "line": 6730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_x86_ops->post_block",
          "args": [
            "vcpu"
          ],
          "line": 6728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "srcu_read_lock",
          "args": [
            "&kvm->srcu"
          ],
          "line": 6725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_block",
          "args": [
            "vcpu"
          ],
          "line": 6724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "srcu_read_unlock",
          "args": [
            "&kvm->srcu",
            "vcpu->srcu_idx"
          ],
          "line": 6723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_x86_ops->pre_block",
          "args": [
            "vcpu"
          ],
          "line": 6722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_arch_vcpu_runnable",
          "args": [
            "vcpu"
          ],
          "line": 6721
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_arch_vcpu_runnable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "8130-8136",
          "snippet": "int kvm_arch_vcpu_runnable(struct kvm_vcpu *vcpu)\n{\n\tif (is_guest_mode(vcpu) && kvm_x86_ops->check_nested_events)\n\t\tkvm_x86_ops->check_nested_events(vcpu, false);\n\n\treturn kvm_vcpu_running(vcpu) || kvm_vcpu_has_events(vcpu);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "struct kvm_x86_ops *kvm_x86_ops"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nint kvm_arch_vcpu_runnable(struct kvm_vcpu *vcpu)\n{\n\tif (is_guest_mode(vcpu) && kvm_x86_ops->check_nested_events)\n\t\tkvm_x86_ops->check_nested_events(vcpu, false);\n\n\treturn kvm_vcpu_running(vcpu) || kvm_vcpu_has_events(vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nstatic inline int vcpu_block(struct kvm *kvm, struct kvm_vcpu *vcpu)\n{\n\tif (!kvm_arch_vcpu_runnable(vcpu) &&\n\t    (!kvm_x86_ops->pre_block || kvm_x86_ops->pre_block(vcpu) == 0)) {\n\t\tsrcu_read_unlock(&kvm->srcu, vcpu->srcu_idx);\n\t\tkvm_vcpu_block(vcpu);\n\t\tvcpu->srcu_idx = srcu_read_lock(&kvm->srcu);\n\n\t\tif (kvm_x86_ops->post_block)\n\t\t\tkvm_x86_ops->post_block(vcpu);\n\n\t\tif (!kvm_check_request(KVM_REQ_UNHALT, vcpu))\n\t\t\treturn 1;\n\t}\n\n\tkvm_apic_accept_events(vcpu);\n\tswitch(vcpu->arch.mp_state) {\n\tcase KVM_MP_STATE_HALTED:\n\t\tvcpu->arch.pv.pv_unhalted = false;\n\t\tvcpu->arch.mp_state =\n\t\t\tKVM_MP_STATE_RUNNABLE;\n\tcase KVM_MP_STATE_RUNNABLE:\n\t\tvcpu->arch.apf.halted = false;\n\t\tbreak;\n\tcase KVM_MP_STATE_INIT_RECEIVED:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINTR;\n\t\tbreak;\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "vcpu_enter_guest",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "6449-6717",
    "snippet": "static int vcpu_enter_guest(struct kvm_vcpu *vcpu)\n{\n\tint r;\n\tbool req_int_win =\n\t\tdm_request_for_irq_injection(vcpu) &&\n\t\tkvm_cpu_accept_dm_intr(vcpu);\n\n\tbool req_immediate_exit = false;\n\n\tif (vcpu->requests) {\n\t\tif (kvm_check_request(KVM_REQ_MMU_RELOAD, vcpu))\n\t\t\tkvm_mmu_unload(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_MIGRATE_TIMER, vcpu))\n\t\t\t__kvm_migrate_timers(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_MASTERCLOCK_UPDATE, vcpu))\n\t\t\tkvm_gen_update_masterclock(vcpu->kvm);\n\t\tif (kvm_check_request(KVM_REQ_GLOBAL_CLOCK_UPDATE, vcpu))\n\t\t\tkvm_gen_kvmclock_update(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_CLOCK_UPDATE, vcpu)) {\n\t\t\tr = kvm_guest_time_update(vcpu);\n\t\t\tif (unlikely(r))\n\t\t\t\tgoto out;\n\t\t}\n\t\tif (kvm_check_request(KVM_REQ_MMU_SYNC, vcpu))\n\t\t\tkvm_mmu_sync_roots(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_TLB_FLUSH, vcpu))\n\t\t\tkvm_vcpu_flush_tlb(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_REPORT_TPR_ACCESS, vcpu)) {\n\t\t\tvcpu->run->exit_reason = KVM_EXIT_TPR_ACCESS;\n\t\t\tr = 0;\n\t\t\tgoto out;\n\t\t}\n\t\tif (kvm_check_request(KVM_REQ_TRIPLE_FAULT, vcpu)) {\n\t\t\tvcpu->run->exit_reason = KVM_EXIT_SHUTDOWN;\n\t\t\tr = 0;\n\t\t\tgoto out;\n\t\t}\n\t\tif (kvm_check_request(KVM_REQ_DEACTIVATE_FPU, vcpu)) {\n\t\t\tvcpu->fpu_active = 0;\n\t\t\tkvm_x86_ops->fpu_deactivate(vcpu);\n\t\t}\n\t\tif (kvm_check_request(KVM_REQ_APF_HALT, vcpu)) {\n\t\t\t/* Page is swapped out. Do synthetic halt */\n\t\t\tvcpu->arch.apf.halted = true;\n\t\t\tr = 1;\n\t\t\tgoto out;\n\t\t}\n\t\tif (kvm_check_request(KVM_REQ_STEAL_UPDATE, vcpu))\n\t\t\trecord_steal_time(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_SMI, vcpu))\n\t\t\tprocess_smi(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_NMI, vcpu))\n\t\t\tprocess_nmi(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_PMU, vcpu))\n\t\t\tkvm_pmu_handle_event(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_PMI, vcpu))\n\t\t\tkvm_pmu_deliver_pmi(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_IOAPIC_EOI_EXIT, vcpu)) {\n\t\t\tBUG_ON(vcpu->arch.pending_ioapic_eoi > 255);\n\t\t\tif (test_bit(vcpu->arch.pending_ioapic_eoi,\n\t\t\t\t     vcpu->arch.ioapic_handled_vectors)) {\n\t\t\t\tvcpu->run->exit_reason = KVM_EXIT_IOAPIC_EOI;\n\t\t\t\tvcpu->run->eoi.vector =\n\t\t\t\t\t\tvcpu->arch.pending_ioapic_eoi;\n\t\t\t\tr = 0;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tif (kvm_check_request(KVM_REQ_SCAN_IOAPIC, vcpu))\n\t\t\tvcpu_scan_ioapic(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_APIC_PAGE_RELOAD, vcpu))\n\t\t\tkvm_vcpu_reload_apic_access_page(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_HV_CRASH, vcpu)) {\n\t\t\tvcpu->run->exit_reason = KVM_EXIT_SYSTEM_EVENT;\n\t\t\tvcpu->run->system_event.type = KVM_SYSTEM_EVENT_CRASH;\n\t\t\tr = 0;\n\t\t\tgoto out;\n\t\t}\n\t\tif (kvm_check_request(KVM_REQ_HV_RESET, vcpu)) {\n\t\t\tvcpu->run->exit_reason = KVM_EXIT_SYSTEM_EVENT;\n\t\t\tvcpu->run->system_event.type = KVM_SYSTEM_EVENT_RESET;\n\t\t\tr = 0;\n\t\t\tgoto out;\n\t\t}\n\t\tif (kvm_check_request(KVM_REQ_HV_EXIT, vcpu)) {\n\t\t\tvcpu->run->exit_reason = KVM_EXIT_HYPERV;\n\t\t\tvcpu->run->hyperv = vcpu->arch.hyperv.exit;\n\t\t\tr = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * KVM_REQ_HV_STIMER has to be processed after\n\t\t * KVM_REQ_CLOCK_UPDATE, because Hyper-V SynIC timers\n\t\t * depend on the guest clock being up-to-date\n\t\t */\n\t\tif (kvm_check_request(KVM_REQ_HV_STIMER, vcpu))\n\t\t\tkvm_hv_process_stimers(vcpu);\n\t}\n\n\t/*\n\t * KVM_REQ_EVENT is not set when posted interrupts are set by\n\t * VT-d hardware, so we have to update RVI unconditionally.\n\t */\n\tif (kvm_lapic_enabled(vcpu)) {\n\t\t/*\n\t\t * Update architecture specific hints for APIC\n\t\t * virtual interrupt delivery.\n\t\t */\n\t\tif (vcpu->arch.apicv_active)\n\t\t\tkvm_x86_ops->hwapic_irr_update(vcpu,\n\t\t\t\tkvm_lapic_find_highest_irr(vcpu));\n\t}\n\n\tif (kvm_check_request(KVM_REQ_EVENT, vcpu) || req_int_win) {\n\t\tkvm_apic_accept_events(vcpu);\n\t\tif (vcpu->arch.mp_state == KVM_MP_STATE_INIT_RECEIVED) {\n\t\t\tr = 1;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (inject_pending_event(vcpu, req_int_win) != 0)\n\t\t\treq_immediate_exit = true;\n\t\t/* enable NMI/IRQ window open exits if needed */\n\t\telse {\n\t\t\tif (vcpu->arch.nmi_pending)\n\t\t\t\tkvm_x86_ops->enable_nmi_window(vcpu);\n\t\t\tif (kvm_cpu_has_injectable_intr(vcpu) || req_int_win)\n\t\t\t\tkvm_x86_ops->enable_irq_window(vcpu);\n\t\t}\n\n\t\tif (kvm_lapic_enabled(vcpu)) {\n\t\t\tupdate_cr8_intercept(vcpu);\n\t\t\tkvm_lapic_sync_to_vapic(vcpu);\n\t\t}\n\t}\n\n\tr = kvm_mmu_reload(vcpu);\n\tif (unlikely(r)) {\n\t\tgoto cancel_injection;\n\t}\n\n\tpreempt_disable();\n\n\tkvm_x86_ops->prepare_guest_switch(vcpu);\n\tif (vcpu->fpu_active)\n\t\tkvm_load_guest_fpu(vcpu);\n\tvcpu->mode = IN_GUEST_MODE;\n\n\tsrcu_read_unlock(&vcpu->kvm->srcu, vcpu->srcu_idx);\n\n\t/*\n\t * We should set ->mode before check ->requests,\n\t * Please see the comment in kvm_make_all_cpus_request.\n\t * This also orders the write to mode from any reads\n\t * to the page tables done while the VCPU is running.\n\t * Please see the comment in kvm_flush_remote_tlbs.\n\t */\n\tsmp_mb__after_srcu_read_unlock();\n\n\tlocal_irq_disable();\n\n\tif (vcpu->mode == EXITING_GUEST_MODE || vcpu->requests\n\t    || need_resched() || signal_pending(current)) {\n\t\tvcpu->mode = OUTSIDE_GUEST_MODE;\n\t\tsmp_wmb();\n\t\tlocal_irq_enable();\n\t\tpreempt_enable();\n\t\tvcpu->srcu_idx = srcu_read_lock(&vcpu->kvm->srcu);\n\t\tr = 1;\n\t\tgoto cancel_injection;\n\t}\n\n\tkvm_load_guest_xcr0(vcpu);\n\n\tif (req_immediate_exit)\n\t\tsmp_send_reschedule(vcpu->cpu);\n\n\ttrace_kvm_entry(vcpu->vcpu_id);\n\twait_lapic_expire(vcpu);\n\t__kvm_guest_enter();\n\n\tif (unlikely(vcpu->arch.switch_db_regs)) {\n\t\tset_debugreg(0, 7);\n\t\tset_debugreg(vcpu->arch.eff_db[0], 0);\n\t\tset_debugreg(vcpu->arch.eff_db[1], 1);\n\t\tset_debugreg(vcpu->arch.eff_db[2], 2);\n\t\tset_debugreg(vcpu->arch.eff_db[3], 3);\n\t\tset_debugreg(vcpu->arch.dr6, 6);\n\t\tvcpu->arch.switch_db_regs &= ~KVM_DEBUGREG_RELOAD;\n\t}\n\n\tkvm_x86_ops->run(vcpu);\n\n\t/*\n\t * Do this here before restoring debug registers on the host.  And\n\t * since we do this before handling the vmexit, a DR access vmexit\n\t * can (a) read the correct value of the debug registers, (b) set\n\t * KVM_DEBUGREG_WONT_EXIT again.\n\t */\n\tif (unlikely(vcpu->arch.switch_db_regs & KVM_DEBUGREG_WONT_EXIT)) {\n\t\tWARN_ON(vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP);\n\t\tkvm_x86_ops->sync_dirty_debug_regs(vcpu);\n\t\tkvm_update_dr0123(vcpu);\n\t\tkvm_update_dr6(vcpu);\n\t\tkvm_update_dr7(vcpu);\n\t\tvcpu->arch.switch_db_regs &= ~KVM_DEBUGREG_RELOAD;\n\t}\n\n\t/*\n\t * If the guest has used debug registers, at least dr7\n\t * will be disabled while returning to the host.\n\t * If we don't have active breakpoints in the host, we don't\n\t * care about the messed up debug address registers. But if\n\t * we have some of them active, restore the old state.\n\t */\n\tif (hw_breakpoint_active())\n\t\thw_breakpoint_restore();\n\n\tvcpu->arch.last_guest_tsc = kvm_read_l1_tsc(vcpu, rdtsc());\n\n\tvcpu->mode = OUTSIDE_GUEST_MODE;\n\tsmp_wmb();\n\n\tkvm_put_guest_xcr0(vcpu);\n\n\t/* Interrupt is enabled by handle_external_intr() */\n\tkvm_x86_ops->handle_external_intr(vcpu);\n\n\t++vcpu->stat.exits;\n\n\t/*\n\t * We must have an instruction between local_irq_enable() and\n\t * kvm_guest_exit(), so the timer interrupt isn't delayed by\n\t * the interrupt shadow.  The stat.exits increment will do nicely.\n\t * But we need to prevent reordering, hence this barrier():\n\t */\n\tbarrier();\n\n\tkvm_guest_exit();\n\n\tpreempt_enable();\n\n\tvcpu->srcu_idx = srcu_read_lock(&vcpu->kvm->srcu);\n\n\t/*\n\t * Profile KVM exit RIPs:\n\t */\n\tif (unlikely(prof_on == KVM_PROFILING)) {\n\t\tunsigned long rip = kvm_rip_read(vcpu);\n\t\tprofile_hit(KVM_PROFILING, (void *)rip);\n\t}\n\n\tif (unlikely(vcpu->arch.tsc_always_catchup))\n\t\tkvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);\n\n\tif (vcpu->arch.apic_attention)\n\t\tkvm_lapic_sync_from_vapic(vcpu);\n\n\tr = kvm_x86_ops->handle_exit(vcpu);\n\treturn r;\n\ncancel_injection:\n\tkvm_x86_ops->cancel_injection(vcpu);\n\tif (unlikely(vcpu->arch.apic_attention))\n\t\tkvm_lapic_sync_from_vapic(vcpu);\nout:\n\treturn r;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);",
      "struct kvm_x86_ops *kvm_x86_ops"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_lapic_sync_from_vapic",
          "args": [
            "vcpu"
          ],
          "line": 6714
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_sync_from_vapic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "2027-2042",
          "snippet": "void kvm_lapic_sync_from_vapic(struct kvm_vcpu *vcpu)\n{\n\tu32 data;\n\n\tif (test_bit(KVM_APIC_PV_EOI_PENDING, &vcpu->arch.apic_attention))\n\t\tapic_sync_pv_eoi_from_guest(vcpu, vcpu->arch.apic);\n\n\tif (!test_bit(KVM_APIC_CHECK_VAPIC, &vcpu->arch.apic_attention))\n\t\treturn;\n\n\tif (kvm_read_guest_cached(vcpu->kvm, &vcpu->arch.apic->vapic_cache, &data,\n\t\t\t\t  sizeof(u32)))\n\t\treturn;\n\n\tapic_set_tpr(vcpu->arch.apic, data & 0xff);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nvoid kvm_lapic_sync_from_vapic(struct kvm_vcpu *vcpu)\n{\n\tu32 data;\n\n\tif (test_bit(KVM_APIC_PV_EOI_PENDING, &vcpu->arch.apic_attention))\n\t\tapic_sync_pv_eoi_from_guest(vcpu, vcpu->arch.apic);\n\n\tif (!test_bit(KVM_APIC_CHECK_VAPIC, &vcpu->arch.apic_attention))\n\t\treturn;\n\n\tif (kvm_read_guest_cached(vcpu->kvm, &vcpu->arch.apic->vapic_cache, &data,\n\t\t\t\t  sizeof(u32)))\n\t\treturn;\n\n\tapic_set_tpr(vcpu->arch.apic, data & 0xff);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "vcpu->arch.apic_attention"
          ],
          "line": 6713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_x86_ops->cancel_injection",
          "args": [
            "vcpu"
          ],
          "line": 6712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_x86_ops->handle_exit",
          "args": [
            "vcpu"
          ],
          "line": 6708
        },
        "resolved": true,
        "details": {
          "function_name": "handle_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/svm.c",
          "lines": "4044-4111",
          "snippet": "static int handle_exit(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tstruct kvm_run *kvm_run = vcpu->run;\n\tu32 exit_code = svm->vmcb->control.exit_code;\n\n\ttrace_kvm_exit(exit_code, vcpu, KVM_ISA_SVM);\n\n\tif (!is_cr_intercept(svm, INTERCEPT_CR0_WRITE))\n\t\tvcpu->arch.cr0 = svm->vmcb->save.cr0;\n\tif (npt_enabled)\n\t\tvcpu->arch.cr3 = svm->vmcb->save.cr3;\n\n\tif (unlikely(svm->nested.exit_required)) {\n\t\tnested_svm_vmexit(svm);\n\t\tsvm->nested.exit_required = false;\n\n\t\treturn 1;\n\t}\n\n\tif (is_guest_mode(vcpu)) {\n\t\tint vmexit;\n\n\t\ttrace_kvm_nested_vmexit(svm->vmcb->save.rip, exit_code,\n\t\t\t\t\tsvm->vmcb->control.exit_info_1,\n\t\t\t\t\tsvm->vmcb->control.exit_info_2,\n\t\t\t\t\tsvm->vmcb->control.exit_int_info,\n\t\t\t\t\tsvm->vmcb->control.exit_int_info_err,\n\t\t\t\t\tKVM_ISA_SVM);\n\n\t\tvmexit = nested_svm_exit_special(svm);\n\n\t\tif (vmexit == NESTED_EXIT_CONTINUE)\n\t\t\tvmexit = nested_svm_exit_handled(svm);\n\n\t\tif (vmexit == NESTED_EXIT_DONE)\n\t\t\treturn 1;\n\t}\n\n\tsvm_complete_interrupts(svm);\n\n\tif (svm->vmcb->control.exit_code == SVM_EXIT_ERR) {\n\t\tkvm_run->exit_reason = KVM_EXIT_FAIL_ENTRY;\n\t\tkvm_run->fail_entry.hardware_entry_failure_reason\n\t\t\t= svm->vmcb->control.exit_code;\n\t\tpr_err(\"KVM: FAILED VMRUN WITH VMCB:\\n\");\n\t\tdump_vmcb(vcpu);\n\t\treturn 0;\n\t}\n\n\tif (is_external_interrupt(svm->vmcb->control.exit_int_info) &&\n\t    exit_code != SVM_EXIT_EXCP_BASE + PF_VECTOR &&\n\t    exit_code != SVM_EXIT_NPF && exit_code != SVM_EXIT_TASK_SWITCH &&\n\t    exit_code != SVM_EXIT_INTR && exit_code != SVM_EXIT_NMI)\n\t\tprintk(KERN_ERR \"%s: unexpected exit_int_info 0x%x \"\n\t\t       \"exit_code 0x%x\\n\",\n\t\t       __func__, svm->vmcb->control.exit_int_info,\n\t\t       exit_code);\n\n\tif (exit_code >= ARRAY_SIZE(svm_exit_handlers)\n\t    || !svm_exit_handlers[exit_code]) {\n\t\tWARN_ONCE(1, \"svm: unexpected exit reason 0x%x\\n\", exit_code);\n\t\tkvm_queue_exception(vcpu, UD_VECTOR);\n\t\treturn 1;\n\t}\n\n\treturn svm_exit_handlers[exit_code](svm);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define NESTED_EXIT_CONTINUE\t2\t/* Further checks needed      */",
            "#define NESTED_EXIT_DONE\t1\t/* Exit caused nested vmexit  */"
          ],
          "globals_used": [
            "static int nested = true;",
            "static void svm_set_cr0(struct kvm_vcpu *vcpu, unsigned long cr0);",
            "static void svm_flush_tlb(struct kvm_vcpu *vcpu);",
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static int nested_svm_exit_handled(struct vcpu_svm *svm);",
            "static int nested_svm_intercept(struct vcpu_svm *svm);",
            "static int nested_svm_vmexit(struct vcpu_svm *svm);",
            "static int (*const svm_exit_handlers[])(struct vcpu_svm *svm) = {\n\t[SVM_EXIT_READ_CR0]\t\t\t= cr_interception,\n\t[SVM_EXIT_READ_CR3]\t\t\t= cr_interception,\n\t[SVM_EXIT_READ_CR4]\t\t\t= cr_interception,\n\t[SVM_EXIT_READ_CR8]\t\t\t= cr_interception,\n\t[SVM_EXIT_CR0_SEL_WRITE]\t\t= cr_interception,\n\t[SVM_EXIT_WRITE_CR0]\t\t\t= cr_interception,\n\t[SVM_EXIT_WRITE_CR3]\t\t\t= cr_interception,\n\t[SVM_EXIT_WRITE_CR4]\t\t\t= cr_interception,\n\t[SVM_EXIT_WRITE_CR8]\t\t\t= cr8_write_interception,\n\t[SVM_EXIT_READ_DR0]\t\t\t= dr_interception,\n\t[SVM_EXIT_READ_DR1]\t\t\t= dr_interception,\n\t[SVM_EXIT_READ_DR2]\t\t\t= dr_interception,\n\t[SVM_EXIT_READ_DR3]\t\t\t= dr_interception,\n\t[SVM_EXIT_READ_DR4]\t\t\t= dr_interception,\n\t[SVM_EXIT_READ_DR5]\t\t\t= dr_interception,\n\t[SVM_EXIT_READ_DR6]\t\t\t= dr_interception,\n\t[SVM_EXIT_READ_DR7]\t\t\t= dr_interception,\n\t[SVM_EXIT_WRITE_DR0]\t\t\t= dr_interception,\n\t[SVM_EXIT_WRITE_DR1]\t\t\t= dr_interception,\n\t[SVM_EXIT_WRITE_DR2]\t\t\t= dr_interception,\n\t[SVM_EXIT_WRITE_DR3]\t\t\t= dr_interception,\n\t[SVM_EXIT_WRITE_DR4]\t\t\t= dr_interception,\n\t[SVM_EXIT_WRITE_DR5]\t\t\t= dr_interception,\n\t[SVM_EXIT_WRITE_DR6]\t\t\t= dr_interception,\n\t[SVM_EXIT_WRITE_DR7]\t\t\t= dr_interception,\n\t[SVM_EXIT_EXCP_BASE + DB_VECTOR]\t= db_interception,\n\t[SVM_EXIT_EXCP_BASE + BP_VECTOR]\t= bp_interception,\n\t[SVM_EXIT_EXCP_BASE + UD_VECTOR]\t= ud_interception,\n\t[SVM_EXIT_EXCP_BASE + PF_VECTOR]\t= pf_interception,\n\t[SVM_EXIT_EXCP_BASE + NM_VECTOR]\t= nm_interception,\n\t[SVM_EXIT_EXCP_BASE + MC_VECTOR]\t= mc_interception,\n\t[SVM_EXIT_EXCP_BASE + AC_VECTOR]\t= ac_interception,\n\t[SVM_EXIT_INTR]\t\t\t\t= intr_interception,\n\t[SVM_EXIT_NMI]\t\t\t\t= nmi_interception,\n\t[SVM_EXIT_SMI]\t\t\t\t= nop_on_interception,\n\t[SVM_EXIT_INIT]\t\t\t\t= nop_on_interception,\n\t[SVM_EXIT_VINTR]\t\t\t= interrupt_window_interception,\n\t[SVM_EXIT_RDPMC]\t\t\t= rdpmc_interception,\n\t[SVM_EXIT_CPUID]\t\t\t= cpuid_interception,\n\t[SVM_EXIT_IRET]                         = iret_interception,\n\t[SVM_EXIT_INVD]                         = emulate_on_interception,\n\t[SVM_EXIT_PAUSE]\t\t\t= pause_interception,\n\t[SVM_EXIT_HLT]\t\t\t\t= halt_interception,\n\t[SVM_EXIT_INVLPG]\t\t\t= invlpg_interception,\n\t[SVM_EXIT_INVLPGA]\t\t\t= invlpga_interception,\n\t[SVM_EXIT_IOIO]\t\t\t\t= io_interception,\n\t[SVM_EXIT_MSR]\t\t\t\t= msr_interception,\n\t[SVM_EXIT_TASK_SWITCH]\t\t\t= task_switch_interception,\n\t[SVM_EXIT_SHUTDOWN]\t\t\t= shutdown_interception,\n\t[SVM_EXIT_VMRUN]\t\t\t= vmrun_interception,\n\t[SVM_EXIT_VMMCALL]\t\t\t= vmmcall_interception,\n\t[SVM_EXIT_VMLOAD]\t\t\t= vmload_interception,\n\t[SVM_EXIT_VMSAVE]\t\t\t= vmsave_interception,\n\t[SVM_EXIT_STGI]\t\t\t\t= stgi_interception,\n\t[SVM_EXIT_CLGI]\t\t\t\t= clgi_interception,\n\t[SVM_EXIT_SKINIT]\t\t\t= skinit_interception,\n\t[SVM_EXIT_WBINVD]                       = wbinvd_interception,\n\t[SVM_EXIT_MONITOR]\t\t\t= monitor_interception,\n\t[SVM_EXIT_MWAIT]\t\t\t= mwait_interception,\n\t[SVM_EXIT_XSETBV]\t\t\t= xsetbv_interception,\n\t[SVM_EXIT_NPF]\t\t\t\t= pf_interception,\n\t[SVM_EXIT_RSM]                          = emulate_on_interception,\n\t[SVM_EXIT_AVIC_INCOMPLETE_IPI]\t\t= avic_incomplete_ipi_interception,\n\t[SVM_EXIT_AVIC_UNACCELERATED_ACCESS]\t= avic_unaccelerated_access_interception,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define NESTED_EXIT_CONTINUE\t2\t/* Further checks needed      */\n#define NESTED_EXIT_DONE\t1\t/* Exit caused nested vmexit  */\n\nstatic int nested = true;\nstatic void svm_set_cr0(struct kvm_vcpu *vcpu, unsigned long cr0);\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\nstatic int (*const svm_exit_handlers[])(struct vcpu_svm *svm) = {\n\t[SVM_EXIT_READ_CR0]\t\t\t= cr_interception,\n\t[SVM_EXIT_READ_CR3]\t\t\t= cr_interception,\n\t[SVM_EXIT_READ_CR4]\t\t\t= cr_interception,\n\t[SVM_EXIT_READ_CR8]\t\t\t= cr_interception,\n\t[SVM_EXIT_CR0_SEL_WRITE]\t\t= cr_interception,\n\t[SVM_EXIT_WRITE_CR0]\t\t\t= cr_interception,\n\t[SVM_EXIT_WRITE_CR3]\t\t\t= cr_interception,\n\t[SVM_EXIT_WRITE_CR4]\t\t\t= cr_interception,\n\t[SVM_EXIT_WRITE_CR8]\t\t\t= cr8_write_interception,\n\t[SVM_EXIT_READ_DR0]\t\t\t= dr_interception,\n\t[SVM_EXIT_READ_DR1]\t\t\t= dr_interception,\n\t[SVM_EXIT_READ_DR2]\t\t\t= dr_interception,\n\t[SVM_EXIT_READ_DR3]\t\t\t= dr_interception,\n\t[SVM_EXIT_READ_DR4]\t\t\t= dr_interception,\n\t[SVM_EXIT_READ_DR5]\t\t\t= dr_interception,\n\t[SVM_EXIT_READ_DR6]\t\t\t= dr_interception,\n\t[SVM_EXIT_READ_DR7]\t\t\t= dr_interception,\n\t[SVM_EXIT_WRITE_DR0]\t\t\t= dr_interception,\n\t[SVM_EXIT_WRITE_DR1]\t\t\t= dr_interception,\n\t[SVM_EXIT_WRITE_DR2]\t\t\t= dr_interception,\n\t[SVM_EXIT_WRITE_DR3]\t\t\t= dr_interception,\n\t[SVM_EXIT_WRITE_DR4]\t\t\t= dr_interception,\n\t[SVM_EXIT_WRITE_DR5]\t\t\t= dr_interception,\n\t[SVM_EXIT_WRITE_DR6]\t\t\t= dr_interception,\n\t[SVM_EXIT_WRITE_DR7]\t\t\t= dr_interception,\n\t[SVM_EXIT_EXCP_BASE + DB_VECTOR]\t= db_interception,\n\t[SVM_EXIT_EXCP_BASE + BP_VECTOR]\t= bp_interception,\n\t[SVM_EXIT_EXCP_BASE + UD_VECTOR]\t= ud_interception,\n\t[SVM_EXIT_EXCP_BASE + PF_VECTOR]\t= pf_interception,\n\t[SVM_EXIT_EXCP_BASE + NM_VECTOR]\t= nm_interception,\n\t[SVM_EXIT_EXCP_BASE + MC_VECTOR]\t= mc_interception,\n\t[SVM_EXIT_EXCP_BASE + AC_VECTOR]\t= ac_interception,\n\t[SVM_EXIT_INTR]\t\t\t\t= intr_interception,\n\t[SVM_EXIT_NMI]\t\t\t\t= nmi_interception,\n\t[SVM_EXIT_SMI]\t\t\t\t= nop_on_interception,\n\t[SVM_EXIT_INIT]\t\t\t\t= nop_on_interception,\n\t[SVM_EXIT_VINTR]\t\t\t= interrupt_window_interception,\n\t[SVM_EXIT_RDPMC]\t\t\t= rdpmc_interception,\n\t[SVM_EXIT_CPUID]\t\t\t= cpuid_interception,\n\t[SVM_EXIT_IRET]                         = iret_interception,\n\t[SVM_EXIT_INVD]                         = emulate_on_interception,\n\t[SVM_EXIT_PAUSE]\t\t\t= pause_interception,\n\t[SVM_EXIT_HLT]\t\t\t\t= halt_interception,\n\t[SVM_EXIT_INVLPG]\t\t\t= invlpg_interception,\n\t[SVM_EXIT_INVLPGA]\t\t\t= invlpga_interception,\n\t[SVM_EXIT_IOIO]\t\t\t\t= io_interception,\n\t[SVM_EXIT_MSR]\t\t\t\t= msr_interception,\n\t[SVM_EXIT_TASK_SWITCH]\t\t\t= task_switch_interception,\n\t[SVM_EXIT_SHUTDOWN]\t\t\t= shutdown_interception,\n\t[SVM_EXIT_VMRUN]\t\t\t= vmrun_interception,\n\t[SVM_EXIT_VMMCALL]\t\t\t= vmmcall_interception,\n\t[SVM_EXIT_VMLOAD]\t\t\t= vmload_interception,\n\t[SVM_EXIT_VMSAVE]\t\t\t= vmsave_interception,\n\t[SVM_EXIT_STGI]\t\t\t\t= stgi_interception,\n\t[SVM_EXIT_CLGI]\t\t\t\t= clgi_interception,\n\t[SVM_EXIT_SKINIT]\t\t\t= skinit_interception,\n\t[SVM_EXIT_WBINVD]                       = wbinvd_interception,\n\t[SVM_EXIT_MONITOR]\t\t\t= monitor_interception,\n\t[SVM_EXIT_MWAIT]\t\t\t= mwait_interception,\n\t[SVM_EXIT_XSETBV]\t\t\t= xsetbv_interception,\n\t[SVM_EXIT_NPF]\t\t\t\t= pf_interception,\n\t[SVM_EXIT_RSM]                          = emulate_on_interception,\n\t[SVM_EXIT_AVIC_INCOMPLETE_IPI]\t\t= avic_incomplete_ipi_interception,\n\t[SVM_EXIT_AVIC_UNACCELERATED_ACCESS]\t= avic_unaccelerated_access_interception,\n};\n\nstatic int handle_exit(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tstruct kvm_run *kvm_run = vcpu->run;\n\tu32 exit_code = svm->vmcb->control.exit_code;\n\n\ttrace_kvm_exit(exit_code, vcpu, KVM_ISA_SVM);\n\n\tif (!is_cr_intercept(svm, INTERCEPT_CR0_WRITE))\n\t\tvcpu->arch.cr0 = svm->vmcb->save.cr0;\n\tif (npt_enabled)\n\t\tvcpu->arch.cr3 = svm->vmcb->save.cr3;\n\n\tif (unlikely(svm->nested.exit_required)) {\n\t\tnested_svm_vmexit(svm);\n\t\tsvm->nested.exit_required = false;\n\n\t\treturn 1;\n\t}\n\n\tif (is_guest_mode(vcpu)) {\n\t\tint vmexit;\n\n\t\ttrace_kvm_nested_vmexit(svm->vmcb->save.rip, exit_code,\n\t\t\t\t\tsvm->vmcb->control.exit_info_1,\n\t\t\t\t\tsvm->vmcb->control.exit_info_2,\n\t\t\t\t\tsvm->vmcb->control.exit_int_info,\n\t\t\t\t\tsvm->vmcb->control.exit_int_info_err,\n\t\t\t\t\tKVM_ISA_SVM);\n\n\t\tvmexit = nested_svm_exit_special(svm);\n\n\t\tif (vmexit == NESTED_EXIT_CONTINUE)\n\t\t\tvmexit = nested_svm_exit_handled(svm);\n\n\t\tif (vmexit == NESTED_EXIT_DONE)\n\t\t\treturn 1;\n\t}\n\n\tsvm_complete_interrupts(svm);\n\n\tif (svm->vmcb->control.exit_code == SVM_EXIT_ERR) {\n\t\tkvm_run->exit_reason = KVM_EXIT_FAIL_ENTRY;\n\t\tkvm_run->fail_entry.hardware_entry_failure_reason\n\t\t\t= svm->vmcb->control.exit_code;\n\t\tpr_err(\"KVM: FAILED VMRUN WITH VMCB:\\n\");\n\t\tdump_vmcb(vcpu);\n\t\treturn 0;\n\t}\n\n\tif (is_external_interrupt(svm->vmcb->control.exit_int_info) &&\n\t    exit_code != SVM_EXIT_EXCP_BASE + PF_VECTOR &&\n\t    exit_code != SVM_EXIT_NPF && exit_code != SVM_EXIT_TASK_SWITCH &&\n\t    exit_code != SVM_EXIT_INTR && exit_code != SVM_EXIT_NMI)\n\t\tprintk(KERN_ERR \"%s: unexpected exit_int_info 0x%x \"\n\t\t       \"exit_code 0x%x\\n\",\n\t\t       __func__, svm->vmcb->control.exit_int_info,\n\t\t       exit_code);\n\n\tif (exit_code >= ARRAY_SIZE(svm_exit_handlers)\n\t    || !svm_exit_handlers[exit_code]) {\n\t\tWARN_ONCE(1, \"svm: unexpected exit reason 0x%x\\n\", exit_code);\n\t\tkvm_queue_exception(vcpu, UD_VECTOR);\n\t\treturn 1;\n\t}\n\n\treturn svm_exit_handlers[exit_code](svm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_make_request",
          "args": [
            "KVM_REQ_CLOCK_UPDATE",
            "vcpu"
          ],
          "line": 6703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "vcpu->arch.tsc_always_catchup"
          ],
          "line": 6702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "profile_hit",
          "args": [
            "KVM_PROFILING",
            "(void *)rip"
          ],
          "line": 6699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_rip_read",
          "args": [
            "vcpu"
          ],
          "line": 6698
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_rip_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "27-30",
          "snippet": "static inline unsigned long kvm_rip_read(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_register_read(vcpu, VCPU_REGS_RIP);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline unsigned long kvm_rip_read(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_register_read(vcpu, VCPU_REGS_RIP);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "prof_on == KVM_PROFILING"
          ],
          "line": 6697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "srcu_read_lock",
          "args": [
            "&vcpu->kvm->srcu"
          ],
          "line": 6692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 6690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_guest_exit",
          "args": [],
          "line": 6688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "barrier",
          "args": [],
          "line": 6686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_x86_ops->handle_external_intr",
          "args": [
            "vcpu"
          ],
          "line": 6676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_put_guest_xcr0",
          "args": [
            "vcpu"
          ],
          "line": 6673
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_put_guest_xcr0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "662-669",
          "snippet": "static void kvm_put_guest_xcr0(struct kvm_vcpu *vcpu)\n{\n\tif (vcpu->guest_xcr0_loaded) {\n\t\tif (vcpu->arch.xcr0 != host_xcr0)\n\t\t\txsetbv(XCR_XFEATURE_ENABLED_MASK, host_xcr0);\n\t\tvcpu->guest_xcr0_loaded = 0;\n\t}\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "u64 __read_mostly host_xcr0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nu64 __read_mostly host_xcr0;\n\nstatic void kvm_put_guest_xcr0(struct kvm_vcpu *vcpu)\n{\n\tif (vcpu->guest_xcr0_loaded) {\n\t\tif (vcpu->arch.xcr0 != host_xcr0)\n\t\t\txsetbv(XCR_XFEATURE_ENABLED_MASK, host_xcr0);\n\t\tvcpu->guest_xcr0_loaded = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_wmb",
          "args": [],
          "line": 6671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_read_l1_tsc",
          "args": [
            "vcpu",
            "rdtsc()"
          ],
          "line": 6668
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_read_l1_tsc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "1408-1411",
          "snippet": "u64 kvm_read_l1_tsc(struct kvm_vcpu *vcpu, u64 host_tsc)\n{\n\treturn kvm_x86_ops->read_l1_tsc(vcpu, kvm_scale_tsc(vcpu, host_tsc));\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "struct kvm_x86_ops *kvm_x86_ops"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nu64 kvm_read_l1_tsc(struct kvm_vcpu *vcpu, u64 host_tsc)\n{\n\treturn kvm_x86_ops->read_l1_tsc(vcpu, kvm_scale_tsc(vcpu, host_tsc));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rdtsc",
          "args": [],
          "line": 6668
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_rdtscp_supported",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/vmx.c",
          "lines": "2393-2396",
          "snippet": "static bool vmx_rdtscp_supported(void)\n{\n\treturn cpu_has_vmx_rdtscp();\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"trace.h\"",
            "#include <asm/irq_remapping.h>",
            "#include <asm/apic.h>",
            "#include <asm/kexec.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/mce.h>",
            "#include <asm/virtext.h>",
            "#include <asm/vmx.h>",
            "#include <asm/desc.h>",
            "#include <asm/io.h>",
            "#include <asm/cpu.h>",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/hrtimer.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include \"lapic.h\"",
            "#include \"cpuid.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"trace.h\"\n#include <asm/irq_remapping.h>\n#include <asm/apic.h>\n#include <asm/kexec.h>\n#include <asm/debugreg.h>\n#include <asm/perf_event.h>\n#include <asm/fpu/internal.h>\n#include <asm/mce.h>\n#include <asm/virtext.h>\n#include <asm/vmx.h>\n#include <asm/desc.h>\n#include <asm/io.h>\n#include <asm/cpu.h>\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/hrtimer.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic bool vmx_rdtscp_supported(void)\n{\n\treturn cpu_has_vmx_rdtscp();\n}"
        }
      },
      {
        "call_info": {
          "callee": "hw_breakpoint_restore",
          "args": [],
          "line": 6666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hw_breakpoint_active",
          "args": [],
          "line": 6665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_update_dr7",
          "args": [
            "vcpu"
          ],
          "line": 6654
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_update_dr7",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "842-854",
          "snippet": "static void kvm_update_dr7(struct kvm_vcpu *vcpu)\n{\n\tunsigned long dr7;\n\n\tif (vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP)\n\t\tdr7 = vcpu->arch.guest_debug_dr7;\n\telse\n\t\tdr7 = vcpu->arch.dr7;\n\tkvm_x86_ops->set_dr7(vcpu, dr7);\n\tvcpu->arch.switch_db_regs &= ~KVM_DEBUGREG_BP_ENABLED;\n\tif (dr7 & DR7_BP_EN_MASK)\n\t\tvcpu->arch.switch_db_regs |= KVM_DEBUGREG_BP_ENABLED;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "struct kvm_x86_ops *kvm_x86_ops"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nstatic void kvm_update_dr7(struct kvm_vcpu *vcpu)\n{\n\tunsigned long dr7;\n\n\tif (vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP)\n\t\tdr7 = vcpu->arch.guest_debug_dr7;\n\telse\n\t\tdr7 = vcpu->arch.dr7;\n\tkvm_x86_ops->set_dr7(vcpu, dr7);\n\tvcpu->arch.switch_db_regs &= ~KVM_DEBUGREG_BP_ENABLED;\n\tif (dr7 & DR7_BP_EN_MASK)\n\t\tvcpu->arch.switch_db_regs |= KVM_DEBUGREG_BP_ENABLED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_update_dr6",
          "args": [
            "vcpu"
          ],
          "line": 6653
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_update_dr6",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "836-840",
          "snippet": "static void kvm_update_dr6(struct kvm_vcpu *vcpu)\n{\n\tif (!(vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP))\n\t\tkvm_x86_ops->set_dr6(vcpu, vcpu->arch.dr6);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "struct kvm_x86_ops *kvm_x86_ops"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nstatic void kvm_update_dr6(struct kvm_vcpu *vcpu)\n{\n\tif (!(vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP))\n\t\tkvm_x86_ops->set_dr6(vcpu, vcpu->arch.dr6);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_update_dr0123",
          "args": [
            "vcpu"
          ],
          "line": 6652
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_update_dr0123",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "825-834",
          "snippet": "static void kvm_update_dr0123(struct kvm_vcpu *vcpu)\n{\n\tint i;\n\n\tif (!(vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP)) {\n\t\tfor (i = 0; i < KVM_NR_DB_REGS; i++)\n\t\t\tvcpu->arch.eff_db[i] = vcpu->arch.db[i];\n\t\tvcpu->arch.switch_db_regs |= KVM_DEBUGREG_RELOAD;\n\t}\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic void kvm_update_dr0123(struct kvm_vcpu *vcpu)\n{\n\tint i;\n\n\tif (!(vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP)) {\n\t\tfor (i = 0; i < KVM_NR_DB_REGS; i++)\n\t\t\tvcpu->arch.eff_db[i] = vcpu->arch.db[i];\n\t\tvcpu->arch.switch_db_regs |= KVM_DEBUGREG_RELOAD;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_x86_ops->sync_dirty_debug_regs",
          "args": [
            "vcpu"
          ],
          "line": 6651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP"
          ],
          "line": 6650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "vcpu->arch.switch_db_regs & KVM_DEBUGREG_WONT_EXIT"
          ],
          "line": 6649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_x86_ops->run",
          "args": [
            "vcpu"
          ],
          "line": 6641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_debugreg",
          "args": [
            "vcpu->arch.dr6",
            "6"
          ],
          "line": 6637
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_vcpu_ioctl_x86_set_debugregs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "3033-3047",
          "snippet": "static int kvm_vcpu_ioctl_x86_set_debugregs(struct kvm_vcpu *vcpu,\n\t\t\t\t\t    struct kvm_debugregs *dbgregs)\n{\n\tif (dbgregs->flags)\n\t\treturn -EINVAL;\n\n\tmemcpy(vcpu->arch.db, dbgregs->db, sizeof(vcpu->arch.db));\n\tkvm_update_dr0123(vcpu);\n\tvcpu->arch.dr6 = dbgregs->dr6;\n\tkvm_update_dr6(vcpu);\n\tvcpu->arch.dr7 = dbgregs->dr7;\n\tkvm_update_dr7(vcpu);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic int kvm_vcpu_ioctl_x86_set_debugregs(struct kvm_vcpu *vcpu,\n\t\t\t\t\t    struct kvm_debugregs *dbgregs)\n{\n\tif (dbgregs->flags)\n\t\treturn -EINVAL;\n\n\tmemcpy(vcpu->arch.db, dbgregs->db, sizeof(vcpu->arch.db));\n\tkvm_update_dr0123(vcpu);\n\tvcpu->arch.dr6 = dbgregs->dr6;\n\tkvm_update_dr6(vcpu);\n\tvcpu->arch.dr7 = dbgregs->dr7;\n\tkvm_update_dr7(vcpu);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "vcpu->arch.switch_db_regs"
          ],
          "line": 6631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__kvm_guest_enter",
          "args": [],
          "line": 6629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_lapic_expire",
          "args": [
            "vcpu"
          ],
          "line": 6628
        },
        "resolved": true,
        "details": {
          "function_name": "wait_lapic_expire",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "1292-1314",
          "snippet": "void wait_lapic_expire(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tu64 guest_tsc, tsc_deadline;\n\n\tif (!lapic_in_kernel(vcpu))\n\t\treturn;\n\n\tif (apic->lapic_timer.expired_tscdeadline == 0)\n\t\treturn;\n\n\tif (!lapic_timer_int_injected(vcpu))\n\t\treturn;\n\n\ttsc_deadline = apic->lapic_timer.expired_tscdeadline;\n\tapic->lapic_timer.expired_tscdeadline = 0;\n\tguest_tsc = kvm_read_l1_tsc(vcpu, rdtsc());\n\ttrace_kvm_wait_lapic_expire(vcpu->vcpu_id, guest_tsc - tsc_deadline);\n\n\t/* __delay is delay_tsc whenever the hardware has TSC, thus always.  */\n\tif (guest_tsc < tsc_deadline)\n\t\t__delay(tsc_deadline - guest_tsc);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nvoid wait_lapic_expire(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tu64 guest_tsc, tsc_deadline;\n\n\tif (!lapic_in_kernel(vcpu))\n\t\treturn;\n\n\tif (apic->lapic_timer.expired_tscdeadline == 0)\n\t\treturn;\n\n\tif (!lapic_timer_int_injected(vcpu))\n\t\treturn;\n\n\ttsc_deadline = apic->lapic_timer.expired_tscdeadline;\n\tapic->lapic_timer.expired_tscdeadline = 0;\n\tguest_tsc = kvm_read_l1_tsc(vcpu, rdtsc());\n\ttrace_kvm_wait_lapic_expire(vcpu->vcpu_id, guest_tsc - tsc_deadline);\n\n\t/* __delay is delay_tsc whenever the hardware has TSC, thus always.  */\n\tif (guest_tsc < tsc_deadline)\n\t\t__delay(tsc_deadline - guest_tsc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_kvm_entry",
          "args": [
            "vcpu->vcpu_id"
          ],
          "line": 6627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_send_reschedule",
          "args": [
            "vcpu->cpu"
          ],
          "line": 6625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_load_guest_xcr0",
          "args": [
            "vcpu"
          ],
          "line": 6622
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_load_guest_xcr0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "652-660",
          "snippet": "static void kvm_load_guest_xcr0(struct kvm_vcpu *vcpu)\n{\n\tif (kvm_read_cr4_bits(vcpu, X86_CR4_OSXSAVE) &&\n\t\t\t!vcpu->guest_xcr0_loaded) {\n\t\t/* kvm_set_xcr() also depends on this */\n\t\txsetbv(XCR_XFEATURE_ENABLED_MASK, vcpu->arch.xcr0);\n\t\tvcpu->guest_xcr0_loaded = 1;\n\t}\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic void kvm_load_guest_xcr0(struct kvm_vcpu *vcpu)\n{\n\tif (kvm_read_cr4_bits(vcpu, X86_CR4_OSXSAVE) &&\n\t\t\t!vcpu->guest_xcr0_loaded) {\n\t\t/* kvm_set_xcr() also depends on this */\n\t\txsetbv(XCR_XFEATURE_ENABLED_MASK, vcpu->arch.xcr0);\n\t\tvcpu->guest_xcr0_loaded = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "srcu_read_lock",
          "args": [
            "&vcpu->kvm->srcu"
          ],
          "line": 6617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 6616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_enable",
          "args": [],
          "line": 6615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_wmb",
          "args": [],
          "line": 6614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal_pending",
          "args": [
            "current"
          ],
          "line": 6612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "need_resched",
          "args": [],
          "line": 6612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_disable",
          "args": [],
          "line": 6609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb__after_srcu_read_unlock",
          "args": [],
          "line": 6607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "srcu_read_unlock",
          "args": [
            "&vcpu->kvm->srcu",
            "vcpu->srcu_idx"
          ],
          "line": 6598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_load_guest_fpu",
          "args": [
            "vcpu"
          ],
          "line": 6595
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_load_guest_fpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "7312-7326",
          "snippet": "void kvm_load_guest_fpu(struct kvm_vcpu *vcpu)\n{\n\tif (vcpu->guest_fpu_loaded)\n\t\treturn;\n\n\t/*\n\t * Restore all possible states in the guest,\n\t * and assume host would use all available bits.\n\t * Guest xcr0 would be loaded later.\n\t */\n\tvcpu->guest_fpu_loaded = 1;\n\t__kernel_fpu_begin();\n\t__copy_kernel_to_fpregs(&vcpu->arch.guest_fpu.state);\n\ttrace_kvm_fpu(1);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nvoid kvm_load_guest_fpu(struct kvm_vcpu *vcpu)\n{\n\tif (vcpu->guest_fpu_loaded)\n\t\treturn;\n\n\t/*\n\t * Restore all possible states in the guest,\n\t * and assume host would use all available bits.\n\t * Guest xcr0 would be loaded later.\n\t */\n\tvcpu->guest_fpu_loaded = 1;\n\t__kernel_fpu_begin();\n\t__copy_kernel_to_fpregs(&vcpu->arch.guest_fpu.state);\n\ttrace_kvm_fpu(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_x86_ops->prepare_guest_switch",
          "args": [
            "vcpu"
          ],
          "line": 6593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 6591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "r"
          ],
          "line": 6587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_mmu_reload",
          "args": [
            "vcpu"
          ],
          "line": 6586
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_reload",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.h",
          "lines": "88-94",
          "snippet": "static inline int kvm_mmu_reload(struct kvm_vcpu *vcpu)\n{\n\tif (likely(vcpu->arch.mmu.root_hpa != INVALID_PAGE))\n\t\treturn 0;\n\n\treturn kvm_mmu_load(vcpu);\n}",
          "includes": [
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline int kvm_mmu_reload(struct kvm_vcpu *vcpu)\n{\n\tif (likely(vcpu->arch.mmu.root_hpa != INVALID_PAGE))\n\t\treturn 0;\n\n\treturn kvm_mmu_load(vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_lapic_sync_to_vapic",
          "args": [
            "vcpu"
          ],
          "line": 6582
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_sync_to_vapic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "2070-2092",
          "snippet": "void kvm_lapic_sync_to_vapic(struct kvm_vcpu *vcpu)\n{\n\tu32 data, tpr;\n\tint max_irr, max_isr;\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tapic_sync_pv_eoi_to_guest(vcpu, apic);\n\n\tif (!test_bit(KVM_APIC_CHECK_VAPIC, &vcpu->arch.apic_attention))\n\t\treturn;\n\n\ttpr = kvm_lapic_get_reg(apic, APIC_TASKPRI) & 0xff;\n\tmax_irr = apic_find_highest_irr(apic);\n\tif (max_irr < 0)\n\t\tmax_irr = 0;\n\tmax_isr = apic_find_highest_isr(apic);\n\tif (max_isr < 0)\n\t\tmax_isr = 0;\n\tdata = (tpr & 0xff) | ((max_isr & 0xf0) << 8) | (max_irr << 24);\n\n\tkvm_write_guest_cached(vcpu->kvm, &vcpu->arch.apic->vapic_cache, &data,\n\t\t\t\tsizeof(u32));\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nvoid kvm_lapic_sync_to_vapic(struct kvm_vcpu *vcpu)\n{\n\tu32 data, tpr;\n\tint max_irr, max_isr;\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tapic_sync_pv_eoi_to_guest(vcpu, apic);\n\n\tif (!test_bit(KVM_APIC_CHECK_VAPIC, &vcpu->arch.apic_attention))\n\t\treturn;\n\n\ttpr = kvm_lapic_get_reg(apic, APIC_TASKPRI) & 0xff;\n\tmax_irr = apic_find_highest_irr(apic);\n\tif (max_irr < 0)\n\t\tmax_irr = 0;\n\tmax_isr = apic_find_highest_isr(apic);\n\tif (max_isr < 0)\n\t\tmax_isr = 0;\n\tdata = (tpr & 0xff) | ((max_isr & 0xf0) << 8) | (max_irr << 24);\n\n\tkvm_write_guest_cached(vcpu->kvm, &vcpu->arch.apic->vapic_cache, &data,\n\t\t\t\tsizeof(u32));\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_cr8_intercept",
          "args": [
            "vcpu"
          ],
          "line": 6581
        },
        "resolved": true,
        "details": {
          "function_name": "update_cr8_intercept",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "6031-6055",
          "snippet": "static void update_cr8_intercept(struct kvm_vcpu *vcpu)\n{\n\tint max_irr, tpr;\n\n\tif (!kvm_x86_ops->update_cr8_intercept)\n\t\treturn;\n\n\tif (!lapic_in_kernel(vcpu))\n\t\treturn;\n\n\tif (vcpu->arch.apicv_active)\n\t\treturn;\n\n\tif (!vcpu->arch.apic->vapic_addr)\n\t\tmax_irr = kvm_lapic_find_highest_irr(vcpu);\n\telse\n\t\tmax_irr = -1;\n\n\tif (max_irr != -1)\n\t\tmax_irr >>= 4;\n\n\ttpr = kvm_lapic_get_cr8(vcpu);\n\n\tkvm_x86_ops->update_cr8_intercept(vcpu, tpr, max_irr);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "struct kvm_x86_ops *kvm_x86_ops"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu)\n{\n\tint max_irr, tpr;\n\n\tif (!kvm_x86_ops->update_cr8_intercept)\n\t\treturn;\n\n\tif (!lapic_in_kernel(vcpu))\n\t\treturn;\n\n\tif (vcpu->arch.apicv_active)\n\t\treturn;\n\n\tif (!vcpu->arch.apic->vapic_addr)\n\t\tmax_irr = kvm_lapic_find_highest_irr(vcpu);\n\telse\n\t\tmax_irr = -1;\n\n\tif (max_irr != -1)\n\t\tmax_irr >>= 4;\n\n\ttpr = kvm_lapic_get_cr8(vcpu);\n\n\tkvm_x86_ops->update_cr8_intercept(vcpu, tpr, max_irr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_lapic_enabled",
          "args": [
            "vcpu"
          ],
          "line": 6580
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_enabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.h",
          "lines": "171-174",
          "snippet": "static inline int kvm_lapic_enabled(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_apic_present(vcpu) && kvm_apic_sw_enabled(vcpu->arch.apic);\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline int kvm_lapic_enabled(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_apic_present(vcpu) && kvm_apic_sw_enabled(vcpu->arch.apic);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_x86_ops->enable_irq_window",
          "args": [
            "vcpu"
          ],
          "line": 6577
        },
        "resolved": true,
        "details": {
          "function_name": "enable_irq_window",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/vmx.c",
          "lines": "5085-5092",
          "snippet": "static void enable_irq_window(struct kvm_vcpu *vcpu)\n{\n\tu32 cpu_based_vm_exec_control;\n\n\tcpu_based_vm_exec_control = vmcs_read32(CPU_BASED_VM_EXEC_CONTROL);\n\tcpu_based_vm_exec_control |= CPU_BASED_VIRTUAL_INTR_PENDING;\n\tvmcs_write32(CPU_BASED_VM_EXEC_CONTROL, cpu_based_vm_exec_control);\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"trace.h\"",
            "#include <asm/irq_remapping.h>",
            "#include <asm/apic.h>",
            "#include <asm/kexec.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/mce.h>",
            "#include <asm/virtext.h>",
            "#include <asm/vmx.h>",
            "#include <asm/desc.h>",
            "#include <asm/io.h>",
            "#include <asm/cpu.h>",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/hrtimer.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include \"lapic.h\"",
            "#include \"cpuid.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long nested_ept_get_cr3(struct kvm_vcpu *vcpu);",
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);",
            "static void ept_save_pdptrs(struct kvm_vcpu *vcpu);",
            "static void vmx_decache_cr0_guest_bits(struct kvm_vcpu *vcpu);",
            "static void vmx_leave_nested(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"trace.h\"\n#include <asm/irq_remapping.h>\n#include <asm/apic.h>\n#include <asm/kexec.h>\n#include <asm/debugreg.h>\n#include <asm/perf_event.h>\n#include <asm/fpu/internal.h>\n#include <asm/mce.h>\n#include <asm/virtext.h>\n#include <asm/vmx.h>\n#include <asm/desc.h>\n#include <asm/io.h>\n#include <asm/cpu.h>\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/hrtimer.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic unsigned long nested_ept_get_cr3(struct kvm_vcpu *vcpu);\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\nstatic void ept_save_pdptrs(struct kvm_vcpu *vcpu);\nstatic void vmx_decache_cr0_guest_bits(struct kvm_vcpu *vcpu);\nstatic void vmx_leave_nested(struct kvm_vcpu *vcpu);\n\nstatic void enable_irq_window(struct kvm_vcpu *vcpu)\n{\n\tu32 cpu_based_vm_exec_control;\n\n\tcpu_based_vm_exec_control = vmcs_read32(CPU_BASED_VM_EXEC_CONTROL);\n\tcpu_based_vm_exec_control |= CPU_BASED_VIRTUAL_INTR_PENDING;\n\tvmcs_write32(CPU_BASED_VM_EXEC_CONTROL, cpu_based_vm_exec_control);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_cpu_has_injectable_intr",
          "args": [
            "vcpu"
          ],
          "line": 6576
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_cpu_has_injectable_intr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/irq.c",
          "lines": "74-86",
          "snippet": "int kvm_cpu_has_injectable_intr(struct kvm_vcpu *v)\n{\n\tif (!lapic_in_kernel(v))\n\t\treturn v->arch.interrupt.pending;\n\n\tif (kvm_cpu_has_extint(v))\n\t\treturn 1;\n\n\tif (kvm_vcpu_apicv_active(v))\n\t\treturn 0;\n\n\treturn kvm_apic_has_interrupt(v) != -1; /* LAPIC */\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"i8254.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"i8254.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n#include <linux/module.h>\n\nint kvm_cpu_has_injectable_intr(struct kvm_vcpu *v)\n{\n\tif (!lapic_in_kernel(v))\n\t\treturn v->arch.interrupt.pending;\n\n\tif (kvm_cpu_has_extint(v))\n\t\treturn 1;\n\n\tif (kvm_vcpu_apicv_active(v))\n\t\treturn 0;\n\n\treturn kvm_apic_has_interrupt(v) != -1; /* LAPIC */\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_x86_ops->enable_nmi_window",
          "args": [
            "vcpu"
          ],
          "line": 6575
        },
        "resolved": true,
        "details": {
          "function_name": "enable_nmi_window",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/vmx.c",
          "lines": "5094-5107",
          "snippet": "static void enable_nmi_window(struct kvm_vcpu *vcpu)\n{\n\tu32 cpu_based_vm_exec_control;\n\n\tif (!cpu_has_virtual_nmis() ||\n\t    vmcs_read32(GUEST_INTERRUPTIBILITY_INFO) & GUEST_INTR_STATE_STI) {\n\t\tenable_irq_window(vcpu);\n\t\treturn;\n\t}\n\n\tcpu_based_vm_exec_control = vmcs_read32(CPU_BASED_VM_EXEC_CONTROL);\n\tcpu_based_vm_exec_control |= CPU_BASED_VIRTUAL_NMI_PENDING;\n\tvmcs_write32(CPU_BASED_VM_EXEC_CONTROL, cpu_based_vm_exec_control);\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"trace.h\"",
            "#include <asm/irq_remapping.h>",
            "#include <asm/apic.h>",
            "#include <asm/kexec.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/mce.h>",
            "#include <asm/virtext.h>",
            "#include <asm/vmx.h>",
            "#include <asm/desc.h>",
            "#include <asm/io.h>",
            "#include <asm/cpu.h>",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/hrtimer.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include \"lapic.h\"",
            "#include \"cpuid.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long nested_ept_get_cr3(struct kvm_vcpu *vcpu);",
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);",
            "static void ept_save_pdptrs(struct kvm_vcpu *vcpu);",
            "static void vmx_decache_cr0_guest_bits(struct kvm_vcpu *vcpu);",
            "static void vmx_leave_nested(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"trace.h\"\n#include <asm/irq_remapping.h>\n#include <asm/apic.h>\n#include <asm/kexec.h>\n#include <asm/debugreg.h>\n#include <asm/perf_event.h>\n#include <asm/fpu/internal.h>\n#include <asm/mce.h>\n#include <asm/virtext.h>\n#include <asm/vmx.h>\n#include <asm/desc.h>\n#include <asm/io.h>\n#include <asm/cpu.h>\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/hrtimer.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic unsigned long nested_ept_get_cr3(struct kvm_vcpu *vcpu);\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\nstatic void ept_save_pdptrs(struct kvm_vcpu *vcpu);\nstatic void vmx_decache_cr0_guest_bits(struct kvm_vcpu *vcpu);\nstatic void vmx_leave_nested(struct kvm_vcpu *vcpu);\n\nstatic void enable_nmi_window(struct kvm_vcpu *vcpu)\n{\n\tu32 cpu_based_vm_exec_control;\n\n\tif (!cpu_has_virtual_nmis() ||\n\t    vmcs_read32(GUEST_INTERRUPTIBILITY_INFO) & GUEST_INTR_STATE_STI) {\n\t\tenable_irq_window(vcpu);\n\t\treturn;\n\t}\n\n\tcpu_based_vm_exec_control = vmcs_read32(CPU_BASED_VM_EXEC_CONTROL);\n\tcpu_based_vm_exec_control |= CPU_BASED_VIRTUAL_NMI_PENDING;\n\tvmcs_write32(CPU_BASED_VM_EXEC_CONTROL, cpu_based_vm_exec_control);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inject_pending_event",
          "args": [
            "vcpu",
            "req_int_win"
          ],
          "line": 6570
        },
        "resolved": true,
        "details": {
          "function_name": "inject_pending_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "6057-6125",
          "snippet": "static int inject_pending_event(struct kvm_vcpu *vcpu, bool req_int_win)\n{\n\tint r;\n\n\t/* try to reinject previous events if any */\n\tif (vcpu->arch.exception.pending) {\n\t\ttrace_kvm_inj_exception(vcpu->arch.exception.nr,\n\t\t\t\t\tvcpu->arch.exception.has_error_code,\n\t\t\t\t\tvcpu->arch.exception.error_code);\n\n\t\tif (exception_type(vcpu->arch.exception.nr) == EXCPT_FAULT)\n\t\t\t__kvm_set_rflags(vcpu, kvm_get_rflags(vcpu) |\n\t\t\t\t\t     X86_EFLAGS_RF);\n\n\t\tif (vcpu->arch.exception.nr == DB_VECTOR &&\n\t\t    (vcpu->arch.dr7 & DR7_GD)) {\n\t\t\tvcpu->arch.dr7 &= ~DR7_GD;\n\t\t\tkvm_update_dr7(vcpu);\n\t\t}\n\n\t\tkvm_x86_ops->queue_exception(vcpu, vcpu->arch.exception.nr,\n\t\t\t\t\t  vcpu->arch.exception.has_error_code,\n\t\t\t\t\t  vcpu->arch.exception.error_code,\n\t\t\t\t\t  vcpu->arch.exception.reinject);\n\t\treturn 0;\n\t}\n\n\tif (vcpu->arch.nmi_injected) {\n\t\tkvm_x86_ops->set_nmi(vcpu);\n\t\treturn 0;\n\t}\n\n\tif (vcpu->arch.interrupt.pending) {\n\t\tkvm_x86_ops->set_irq(vcpu);\n\t\treturn 0;\n\t}\n\n\tif (is_guest_mode(vcpu) && kvm_x86_ops->check_nested_events) {\n\t\tr = kvm_x86_ops->check_nested_events(vcpu, req_int_win);\n\t\tif (r != 0)\n\t\t\treturn r;\n\t}\n\n\t/* try to inject new event if pending */\n\tif (vcpu->arch.nmi_pending && kvm_x86_ops->nmi_allowed(vcpu)) {\n\t\t--vcpu->arch.nmi_pending;\n\t\tvcpu->arch.nmi_injected = true;\n\t\tkvm_x86_ops->set_nmi(vcpu);\n\t} else if (kvm_cpu_has_injectable_intr(vcpu)) {\n\t\t/*\n\t\t * Because interrupts can be injected asynchronously, we are\n\t\t * calling check_nested_events again here to avoid a race condition.\n\t\t * See https://lkml.org/lkml/2014/7/2/60 for discussion about this\n\t\t * proposal and current concerns.  Perhaps we should be setting\n\t\t * KVM_REQ_EVENT only on certain events and not unconditionally?\n\t\t */\n\t\tif (is_guest_mode(vcpu) && kvm_x86_ops->check_nested_events) {\n\t\t\tr = kvm_x86_ops->check_nested_events(vcpu, req_int_win);\n\t\t\tif (r != 0)\n\t\t\t\treturn r;\n\t\t}\n\t\tif (kvm_x86_ops->interrupt_allowed(vcpu)) {\n\t\t\tkvm_queue_interrupt(vcpu, kvm_cpu_get_interrupt(vcpu),\n\t\t\t\t\t    false);\n\t\t\tkvm_x86_ops->set_irq(vcpu);\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define EXCPT_FAULT\t\t0"
          ],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "struct kvm_x86_ops *kvm_x86_ops"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define EXCPT_FAULT\t\t0\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nstatic int inject_pending_event(struct kvm_vcpu *vcpu, bool req_int_win)\n{\n\tint r;\n\n\t/* try to reinject previous events if any */\n\tif (vcpu->arch.exception.pending) {\n\t\ttrace_kvm_inj_exception(vcpu->arch.exception.nr,\n\t\t\t\t\tvcpu->arch.exception.has_error_code,\n\t\t\t\t\tvcpu->arch.exception.error_code);\n\n\t\tif (exception_type(vcpu->arch.exception.nr) == EXCPT_FAULT)\n\t\t\t__kvm_set_rflags(vcpu, kvm_get_rflags(vcpu) |\n\t\t\t\t\t     X86_EFLAGS_RF);\n\n\t\tif (vcpu->arch.exception.nr == DB_VECTOR &&\n\t\t    (vcpu->arch.dr7 & DR7_GD)) {\n\t\t\tvcpu->arch.dr7 &= ~DR7_GD;\n\t\t\tkvm_update_dr7(vcpu);\n\t\t}\n\n\t\tkvm_x86_ops->queue_exception(vcpu, vcpu->arch.exception.nr,\n\t\t\t\t\t  vcpu->arch.exception.has_error_code,\n\t\t\t\t\t  vcpu->arch.exception.error_code,\n\t\t\t\t\t  vcpu->arch.exception.reinject);\n\t\treturn 0;\n\t}\n\n\tif (vcpu->arch.nmi_injected) {\n\t\tkvm_x86_ops->set_nmi(vcpu);\n\t\treturn 0;\n\t}\n\n\tif (vcpu->arch.interrupt.pending) {\n\t\tkvm_x86_ops->set_irq(vcpu);\n\t\treturn 0;\n\t}\n\n\tif (is_guest_mode(vcpu) && kvm_x86_ops->check_nested_events) {\n\t\tr = kvm_x86_ops->check_nested_events(vcpu, req_int_win);\n\t\tif (r != 0)\n\t\t\treturn r;\n\t}\n\n\t/* try to inject new event if pending */\n\tif (vcpu->arch.nmi_pending && kvm_x86_ops->nmi_allowed(vcpu)) {\n\t\t--vcpu->arch.nmi_pending;\n\t\tvcpu->arch.nmi_injected = true;\n\t\tkvm_x86_ops->set_nmi(vcpu);\n\t} else if (kvm_cpu_has_injectable_intr(vcpu)) {\n\t\t/*\n\t\t * Because interrupts can be injected asynchronously, we are\n\t\t * calling check_nested_events again here to avoid a race condition.\n\t\t * See https://lkml.org/lkml/2014/7/2/60 for discussion about this\n\t\t * proposal and current concerns.  Perhaps we should be setting\n\t\t * KVM_REQ_EVENT only on certain events and not unconditionally?\n\t\t */\n\t\tif (is_guest_mode(vcpu) && kvm_x86_ops->check_nested_events) {\n\t\t\tr = kvm_x86_ops->check_nested_events(vcpu, req_int_win);\n\t\t\tif (r != 0)\n\t\t\t\treturn r;\n\t\t}\n\t\tif (kvm_x86_ops->interrupt_allowed(vcpu)) {\n\t\t\tkvm_queue_interrupt(vcpu, kvm_cpu_get_interrupt(vcpu),\n\t\t\t\t\t    false);\n\t\t\tkvm_x86_ops->set_irq(vcpu);\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_apic_accept_events",
          "args": [
            "vcpu"
          ],
          "line": 6564
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_accept_events",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "2195-2235",
          "snippet": "void kvm_apic_accept_events(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tu8 sipi_vector;\n\tunsigned long pe;\n\n\tif (!lapic_in_kernel(vcpu) || !apic->pending_events)\n\t\treturn;\n\n\t/*\n\t * INITs are latched while in SMM.  Because an SMM CPU cannot\n\t * be in KVM_MP_STATE_INIT_RECEIVED state, just eat SIPIs\n\t * and delay processing of INIT until the next RSM.\n\t */\n\tif (is_smm(vcpu)) {\n\t\tWARN_ON_ONCE(vcpu->arch.mp_state == KVM_MP_STATE_INIT_RECEIVED);\n\t\tif (test_bit(KVM_APIC_SIPI, &apic->pending_events))\n\t\t\tclear_bit(KVM_APIC_SIPI, &apic->pending_events);\n\t\treturn;\n\t}\n\n\tpe = xchg(&apic->pending_events, 0);\n\tif (test_bit(KVM_APIC_INIT, &pe)) {\n\t\tkvm_lapic_reset(vcpu, true);\n\t\tkvm_vcpu_reset(vcpu, true);\n\t\tif (kvm_vcpu_is_bsp(apic->vcpu))\n\t\t\tvcpu->arch.mp_state = KVM_MP_STATE_RUNNABLE;\n\t\telse\n\t\t\tvcpu->arch.mp_state = KVM_MP_STATE_INIT_RECEIVED;\n\t}\n\tif (test_bit(KVM_APIC_SIPI, &pe) &&\n\t    vcpu->arch.mp_state == KVM_MP_STATE_INIT_RECEIVED) {\n\t\t/* evaluate pending_events before reading the vector */\n\t\tsmp_rmb();\n\t\tsipi_vector = apic->sipi_vector;\n\t\tapic_debug(\"vcpu %d received sipi with vector # %x\\n\",\n\t\t\t vcpu->vcpu_id, sipi_vector);\n\t\tkvm_vcpu_deliver_sipi_vector(vcpu, sipi_vector);\n\t\tvcpu->arch.mp_state = KVM_MP_STATE_RUNNABLE;\n\t}\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nvoid kvm_apic_accept_events(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tu8 sipi_vector;\n\tunsigned long pe;\n\n\tif (!lapic_in_kernel(vcpu) || !apic->pending_events)\n\t\treturn;\n\n\t/*\n\t * INITs are latched while in SMM.  Because an SMM CPU cannot\n\t * be in KVM_MP_STATE_INIT_RECEIVED state, just eat SIPIs\n\t * and delay processing of INIT until the next RSM.\n\t */\n\tif (is_smm(vcpu)) {\n\t\tWARN_ON_ONCE(vcpu->arch.mp_state == KVM_MP_STATE_INIT_RECEIVED);\n\t\tif (test_bit(KVM_APIC_SIPI, &apic->pending_events))\n\t\t\tclear_bit(KVM_APIC_SIPI, &apic->pending_events);\n\t\treturn;\n\t}\n\n\tpe = xchg(&apic->pending_events, 0);\n\tif (test_bit(KVM_APIC_INIT, &pe)) {\n\t\tkvm_lapic_reset(vcpu, true);\n\t\tkvm_vcpu_reset(vcpu, true);\n\t\tif (kvm_vcpu_is_bsp(apic->vcpu))\n\t\t\tvcpu->arch.mp_state = KVM_MP_STATE_RUNNABLE;\n\t\telse\n\t\t\tvcpu->arch.mp_state = KVM_MP_STATE_INIT_RECEIVED;\n\t}\n\tif (test_bit(KVM_APIC_SIPI, &pe) &&\n\t    vcpu->arch.mp_state == KVM_MP_STATE_INIT_RECEIVED) {\n\t\t/* evaluate pending_events before reading the vector */\n\t\tsmp_rmb();\n\t\tsipi_vector = apic->sipi_vector;\n\t\tapic_debug(\"vcpu %d received sipi with vector # %x\\n\",\n\t\t\t vcpu->vcpu_id, sipi_vector);\n\t\tkvm_vcpu_deliver_sipi_vector(vcpu, sipi_vector);\n\t\tvcpu->arch.mp_state = KVM_MP_STATE_RUNNABLE;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_check_request",
          "args": [
            "KVM_REQ_EVENT",
            "vcpu"
          ],
          "line": 6563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_x86_ops->hwapic_irr_update",
          "args": [
            "vcpu",
            "kvm_lapic_find_highest_irr(vcpu)"
          ],
          "line": 6559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_lapic_find_highest_irr",
          "args": [
            "vcpu"
          ],
          "line": 6560
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_find_highest_irr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "452-460",
          "snippet": "int kvm_lapic_find_highest_irr(struct kvm_vcpu *vcpu)\n{\n\t/* This may race with setting of irr in __apic_accept_irq() and\n\t * value returned may be wrong, but kvm_vcpu_kick() in __apic_accept_irq\n\t * will cause vmexit immediately and the value will be recalculated\n\t * on the next vmentry.\n\t */\n\treturn apic_find_highest_irr(vcpu->arch.apic);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nint kvm_lapic_find_highest_irr(struct kvm_vcpu *vcpu)\n{\n\t/* This may race with setting of irr in __apic_accept_irq() and\n\t * value returned may be wrong, but kvm_vcpu_kick() in __apic_accept_irq\n\t * will cause vmexit immediately and the value will be recalculated\n\t * on the next vmentry.\n\t */\n\treturn apic_find_highest_irr(vcpu->arch.apic);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_hv_process_stimers",
          "args": [
            "vcpu"
          ],
          "line": 6546
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_hv_process_stimers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.c",
          "lines": "600-627",
          "snippet": "void kvm_hv_process_stimers(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_vcpu_hv *hv_vcpu = vcpu_to_hv_vcpu(vcpu);\n\tstruct kvm_vcpu_hv_stimer *stimer;\n\tu64 time_now, exp_time;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(hv_vcpu->stimer); i++)\n\t\tif (test_and_clear_bit(i, hv_vcpu->stimer_pending_bitmap)) {\n\t\t\tstimer = &hv_vcpu->stimer[i];\n\t\t\tif (stimer->config & HV_STIMER_ENABLE) {\n\t\t\t\texp_time = stimer->exp_time;\n\n\t\t\t\tif (exp_time) {\n\t\t\t\t\ttime_now =\n\t\t\t\t\t\tget_time_ref_counter(vcpu->kvm);\n\t\t\t\t\tif (time_now >= exp_time)\n\t\t\t\t\t\tstimer_expiration(stimer);\n\t\t\t\t}\n\n\t\t\t\tif ((stimer->config & HV_STIMER_ENABLE) &&\n\t\t\t\t    stimer->count)\n\t\t\t\t\tstimer_start(stimer);\n\t\t\t\telse\n\t\t\t\t\tstimer_cleanup(stimer);\n\t\t\t}\n\t\t}\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nvoid kvm_hv_process_stimers(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_vcpu_hv *hv_vcpu = vcpu_to_hv_vcpu(vcpu);\n\tstruct kvm_vcpu_hv_stimer *stimer;\n\tu64 time_now, exp_time;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(hv_vcpu->stimer); i++)\n\t\tif (test_and_clear_bit(i, hv_vcpu->stimer_pending_bitmap)) {\n\t\t\tstimer = &hv_vcpu->stimer[i];\n\t\t\tif (stimer->config & HV_STIMER_ENABLE) {\n\t\t\t\texp_time = stimer->exp_time;\n\n\t\t\t\tif (exp_time) {\n\t\t\t\t\ttime_now =\n\t\t\t\t\t\tget_time_ref_counter(vcpu->kvm);\n\t\t\t\t\tif (time_now >= exp_time)\n\t\t\t\t\t\tstimer_expiration(stimer);\n\t\t\t\t}\n\n\t\t\t\tif ((stimer->config & HV_STIMER_ENABLE) &&\n\t\t\t\t    stimer->count)\n\t\t\t\t\tstimer_start(stimer);\n\t\t\t\telse\n\t\t\t\t\tstimer_cleanup(stimer);\n\t\t\t}\n\t\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_check_request",
          "args": [
            "KVM_REQ_HV_STIMER",
            "vcpu"
          ],
          "line": 6545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_check_request",
          "args": [
            "KVM_REQ_HV_EXIT",
            "vcpu"
          ],
          "line": 6533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_check_request",
          "args": [
            "KVM_REQ_HV_RESET",
            "vcpu"
          ],
          "line": 6527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_check_request",
          "args": [
            "KVM_REQ_HV_CRASH",
            "vcpu"
          ],
          "line": 6521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_reload_apic_access_page",
          "args": [
            "vcpu"
          ],
          "line": 6520
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_vcpu_reload_apic_access_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "6410-6430",
          "snippet": "void kvm_vcpu_reload_apic_access_page(struct kvm_vcpu *vcpu)\n{\n\tstruct page *page = NULL;\n\n\tif (!lapic_in_kernel(vcpu))\n\t\treturn;\n\n\tif (!kvm_x86_ops->set_apic_access_page_addr)\n\t\treturn;\n\n\tpage = gfn_to_page(vcpu->kvm, APIC_DEFAULT_PHYS_BASE >> PAGE_SHIFT);\n\tif (is_error_page(page))\n\t\treturn;\n\tkvm_x86_ops->set_apic_access_page_addr(vcpu, page_to_phys(page));\n\n\t/*\n\t * Do not pin apic access page in memory, the MMU notifier\n\t * will call us again if it is migrated or swapped out.\n\t */\n\tput_page(page);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "struct kvm_x86_ops *kvm_x86_ops"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nvoid kvm_vcpu_reload_apic_access_page(struct kvm_vcpu *vcpu)\n{\n\tstruct page *page = NULL;\n\n\tif (!lapic_in_kernel(vcpu))\n\t\treturn;\n\n\tif (!kvm_x86_ops->set_apic_access_page_addr)\n\t\treturn;\n\n\tpage = gfn_to_page(vcpu->kvm, APIC_DEFAULT_PHYS_BASE >> PAGE_SHIFT);\n\tif (is_error_page(page))\n\t\treturn;\n\tkvm_x86_ops->set_apic_access_page_addr(vcpu, page_to_phys(page));\n\n\t/*\n\t * Do not pin apic access page in memory, the MMU notifier\n\t * will call us again if it is migrated or swapped out.\n\t */\n\tput_page(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_check_request",
          "args": [
            "KVM_REQ_APIC_PAGE_RELOAD",
            "vcpu"
          ],
          "line": 6519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vcpu_scan_ioapic",
          "args": [
            "vcpu"
          ],
          "line": 6518
        },
        "resolved": true,
        "details": {
          "function_name": "vcpu_scan_ioapic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "6383-6402",
          "snippet": "static void vcpu_scan_ioapic(struct kvm_vcpu *vcpu)\n{\n\tu64 eoi_exit_bitmap[4];\n\n\tif (!kvm_apic_hw_enabled(vcpu->arch.apic))\n\t\treturn;\n\n\tbitmap_zero(vcpu->arch.ioapic_handled_vectors, 256);\n\n\tif (irqchip_split(vcpu->kvm))\n\t\tkvm_scan_ioapic_routes(vcpu, vcpu->arch.ioapic_handled_vectors);\n\telse {\n\t\tif (vcpu->arch.apicv_active)\n\t\t\tkvm_x86_ops->sync_pir_to_irr(vcpu);\n\t\tkvm_ioapic_scan_entry(vcpu, vcpu->arch.ioapic_handled_vectors);\n\t}\n\tbitmap_or((ulong *)eoi_exit_bitmap, vcpu->arch.ioapic_handled_vectors,\n\t\t  vcpu_to_synic(vcpu)->vec_bitmap, 256);\n\tkvm_x86_ops->load_eoi_exitmap(vcpu, eoi_exit_bitmap);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "struct kvm_x86_ops *kvm_x86_ops"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nstatic void vcpu_scan_ioapic(struct kvm_vcpu *vcpu)\n{\n\tu64 eoi_exit_bitmap[4];\n\n\tif (!kvm_apic_hw_enabled(vcpu->arch.apic))\n\t\treturn;\n\n\tbitmap_zero(vcpu->arch.ioapic_handled_vectors, 256);\n\n\tif (irqchip_split(vcpu->kvm))\n\t\tkvm_scan_ioapic_routes(vcpu, vcpu->arch.ioapic_handled_vectors);\n\telse {\n\t\tif (vcpu->arch.apicv_active)\n\t\t\tkvm_x86_ops->sync_pir_to_irr(vcpu);\n\t\tkvm_ioapic_scan_entry(vcpu, vcpu->arch.ioapic_handled_vectors);\n\t}\n\tbitmap_or((ulong *)eoi_exit_bitmap, vcpu->arch.ioapic_handled_vectors,\n\t\t  vcpu_to_synic(vcpu)->vec_bitmap, 256);\n\tkvm_x86_ops->load_eoi_exitmap(vcpu, eoi_exit_bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_check_request",
          "args": [
            "KVM_REQ_SCAN_IOAPIC",
            "vcpu"
          ],
          "line": 6517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "vcpu->arch.pending_ioapic_eoi",
            "vcpu->arch.ioapic_handled_vectors"
          ],
          "line": 6508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "vcpu->arch.pending_ioapic_eoi > 255"
          ],
          "line": 6507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_check_request",
          "args": [
            "KVM_REQ_IOAPIC_EOI_EXIT",
            "vcpu"
          ],
          "line": 6506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_pmu_deliver_pmi",
          "args": [
            "vcpu"
          ],
          "line": 6505
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_pmu_deliver_pmi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/pmu.c",
          "lines": "258-262",
          "snippet": "void kvm_pmu_deliver_pmi(struct kvm_vcpu *vcpu)\n{\n\tif (lapic_in_kernel(vcpu))\n\t\tkvm_apic_local_deliver(vcpu->arch.apic, APIC_LVTPC);\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"lapic.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include <asm/perf_event.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include <asm/perf_event.h>\n#include <linux/perf_event.h>\n#include <linux/kvm_host.h>\n#include <linux/types.h>\n\nvoid kvm_pmu_deliver_pmi(struct kvm_vcpu *vcpu)\n{\n\tif (lapic_in_kernel(vcpu))\n\t\tkvm_apic_local_deliver(vcpu->arch.apic, APIC_LVTPC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_check_request",
          "args": [
            "KVM_REQ_PMI",
            "vcpu"
          ],
          "line": 6504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_pmu_handle_event",
          "args": [
            "vcpu"
          ],
          "line": 6503
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_pmu_handle_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/pmu.c",
          "lines": "214-232",
          "snippet": "void kvm_pmu_handle_event(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_pmu *pmu = vcpu_to_pmu(vcpu);\n\tu64 bitmask;\n\tint bit;\n\n\tbitmask = pmu->reprogram_pmi;\n\n\tfor_each_set_bit(bit, (unsigned long *)&bitmask, X86_PMC_IDX_MAX) {\n\t\tstruct kvm_pmc *pmc = kvm_x86_ops->pmu_ops->pmc_idx_to_pmc(pmu, bit);\n\n\t\tif (unlikely(!pmc || !pmc->perf_event)) {\n\t\t\tclear_bit(bit, (unsigned long *)&pmu->reprogram_pmi);\n\t\t\tcontinue;\n\t\t}\n\n\t\treprogram_counter(pmu, bit);\n\t}\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"lapic.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include <asm/perf_event.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include <asm/perf_event.h>\n#include <linux/perf_event.h>\n#include <linux/kvm_host.h>\n#include <linux/types.h>\n\nvoid kvm_pmu_handle_event(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_pmu *pmu = vcpu_to_pmu(vcpu);\n\tu64 bitmask;\n\tint bit;\n\n\tbitmask = pmu->reprogram_pmi;\n\n\tfor_each_set_bit(bit, (unsigned long *)&bitmask, X86_PMC_IDX_MAX) {\n\t\tstruct kvm_pmc *pmc = kvm_x86_ops->pmu_ops->pmc_idx_to_pmc(pmu, bit);\n\n\t\tif (unlikely(!pmc || !pmc->perf_event)) {\n\t\t\tclear_bit(bit, (unsigned long *)&pmu->reprogram_pmi);\n\t\t\tcontinue;\n\t\t}\n\n\t\treprogram_counter(pmu, bit);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_check_request",
          "args": [
            "KVM_REQ_PMU",
            "vcpu"
          ],
          "line": 6502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "process_nmi",
          "args": [
            "vcpu"
          ],
          "line": 6501
        },
        "resolved": true,
        "details": {
          "function_name": "process_nmi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "6127-6142",
          "snippet": "static void process_nmi(struct kvm_vcpu *vcpu)\n{\n\tunsigned limit = 2;\n\n\t/*\n\t * x86 is limited to one NMI running, and one NMI pending after it.\n\t * If an NMI is already in progress, limit further NMIs to just one.\n\t * Otherwise, allow two (and we'll inject the first one immediately).\n\t */\n\tif (kvm_x86_ops->get_nmi_mask(vcpu) || vcpu->arch.nmi_injected)\n\t\tlimit = 1;\n\n\tvcpu->arch.nmi_pending += atomic_xchg(&vcpu->arch.nmi_queued, 0);\n\tvcpu->arch.nmi_pending = min(vcpu->arch.nmi_pending, limit);\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "struct kvm_x86_ops *kvm_x86_ops"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nstatic void process_nmi(struct kvm_vcpu *vcpu)\n{\n\tunsigned limit = 2;\n\n\t/*\n\t * x86 is limited to one NMI running, and one NMI pending after it.\n\t * If an NMI is already in progress, limit further NMIs to just one.\n\t * Otherwise, allow two (and we'll inject the first one immediately).\n\t */\n\tif (kvm_x86_ops->get_nmi_mask(vcpu) || vcpu->arch.nmi_injected)\n\t\tlimit = 1;\n\n\tvcpu->arch.nmi_pending += atomic_xchg(&vcpu->arch.nmi_queued, 0);\n\tvcpu->arch.nmi_pending = min(vcpu->arch.nmi_pending, limit);\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_check_request",
          "args": [
            "KVM_REQ_NMI",
            "vcpu"
          ],
          "line": 6500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "process_smi",
          "args": [
            "vcpu"
          ],
          "line": 6499
        },
        "resolved": true,
        "details": {
          "function_name": "process_smi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "6304-6376",
          "snippet": "static void process_smi(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_segment cs, ds;\n\tstruct desc_ptr dt;\n\tchar buf[512];\n\tu32 cr0;\n\n\tif (is_smm(vcpu)) {\n\t\tvcpu->arch.smi_pending = true;\n\t\treturn;\n\t}\n\n\ttrace_kvm_enter_smm(vcpu->vcpu_id, vcpu->arch.smbase, true);\n\tvcpu->arch.hflags |= HF_SMM_MASK;\n\tmemset(buf, 0, 512);\n\tif (guest_cpuid_has_longmode(vcpu))\n\t\tprocess_smi_save_state_64(vcpu, buf);\n\telse\n\t\tprocess_smi_save_state_32(vcpu, buf);\n\n\tkvm_vcpu_write_guest(vcpu, vcpu->arch.smbase + 0xfe00, buf, sizeof(buf));\n\n\tif (kvm_x86_ops->get_nmi_mask(vcpu))\n\t\tvcpu->arch.hflags |= HF_SMM_INSIDE_NMI_MASK;\n\telse\n\t\tkvm_x86_ops->set_nmi_mask(vcpu, true);\n\n\tkvm_set_rflags(vcpu, X86_EFLAGS_FIXED);\n\tkvm_rip_write(vcpu, 0x8000);\n\n\tcr0 = vcpu->arch.cr0 & ~(X86_CR0_PE | X86_CR0_EM | X86_CR0_TS | X86_CR0_PG);\n\tkvm_x86_ops->set_cr0(vcpu, cr0);\n\tvcpu->arch.cr0 = cr0;\n\n\tkvm_x86_ops->set_cr4(vcpu, 0);\n\n\t/* Undocumented: IDT limit is set to zero on entry to SMM.  */\n\tdt.address = dt.size = 0;\n\tkvm_x86_ops->set_idt(vcpu, &dt);\n\n\t__kvm_set_dr(vcpu, 7, DR7_FIXED_1);\n\n\tcs.selector = (vcpu->arch.smbase >> 4) & 0xffff;\n\tcs.base = vcpu->arch.smbase;\n\n\tds.selector = 0;\n\tds.base = 0;\n\n\tcs.limit    = ds.limit = 0xffffffff;\n\tcs.type     = ds.type = 0x3;\n\tcs.dpl      = ds.dpl = 0;\n\tcs.db       = ds.db = 0;\n\tcs.s        = ds.s = 1;\n\tcs.l        = ds.l = 0;\n\tcs.g        = ds.g = 1;\n\tcs.avl      = ds.avl = 0;\n\tcs.present  = ds.present = 1;\n\tcs.unusable = ds.unusable = 0;\n\tcs.padding  = ds.padding = 0;\n\n\tkvm_set_segment(vcpu, &cs, VCPU_SREG_CS);\n\tkvm_set_segment(vcpu, &ds, VCPU_SREG_DS);\n\tkvm_set_segment(vcpu, &ds, VCPU_SREG_ES);\n\tkvm_set_segment(vcpu, &ds, VCPU_SREG_FS);\n\tkvm_set_segment(vcpu, &ds, VCPU_SREG_GS);\n\tkvm_set_segment(vcpu, &ds, VCPU_SREG_SS);\n\n\tif (guest_cpuid_has_longmode(vcpu))\n\t\tkvm_x86_ops->set_efer(vcpu, 0);\n\n\tkvm_update_cpuid(vcpu);\n\tkvm_mmu_reset_context(vcpu);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "struct kvm_x86_ops *kvm_x86_ops"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nstatic void process_smi(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_segment cs, ds;\n\tstruct desc_ptr dt;\n\tchar buf[512];\n\tu32 cr0;\n\n\tif (is_smm(vcpu)) {\n\t\tvcpu->arch.smi_pending = true;\n\t\treturn;\n\t}\n\n\ttrace_kvm_enter_smm(vcpu->vcpu_id, vcpu->arch.smbase, true);\n\tvcpu->arch.hflags |= HF_SMM_MASK;\n\tmemset(buf, 0, 512);\n\tif (guest_cpuid_has_longmode(vcpu))\n\t\tprocess_smi_save_state_64(vcpu, buf);\n\telse\n\t\tprocess_smi_save_state_32(vcpu, buf);\n\n\tkvm_vcpu_write_guest(vcpu, vcpu->arch.smbase + 0xfe00, buf, sizeof(buf));\n\n\tif (kvm_x86_ops->get_nmi_mask(vcpu))\n\t\tvcpu->arch.hflags |= HF_SMM_INSIDE_NMI_MASK;\n\telse\n\t\tkvm_x86_ops->set_nmi_mask(vcpu, true);\n\n\tkvm_set_rflags(vcpu, X86_EFLAGS_FIXED);\n\tkvm_rip_write(vcpu, 0x8000);\n\n\tcr0 = vcpu->arch.cr0 & ~(X86_CR0_PE | X86_CR0_EM | X86_CR0_TS | X86_CR0_PG);\n\tkvm_x86_ops->set_cr0(vcpu, cr0);\n\tvcpu->arch.cr0 = cr0;\n\n\tkvm_x86_ops->set_cr4(vcpu, 0);\n\n\t/* Undocumented: IDT limit is set to zero on entry to SMM.  */\n\tdt.address = dt.size = 0;\n\tkvm_x86_ops->set_idt(vcpu, &dt);\n\n\t__kvm_set_dr(vcpu, 7, DR7_FIXED_1);\n\n\tcs.selector = (vcpu->arch.smbase >> 4) & 0xffff;\n\tcs.base = vcpu->arch.smbase;\n\n\tds.selector = 0;\n\tds.base = 0;\n\n\tcs.limit    = ds.limit = 0xffffffff;\n\tcs.type     = ds.type = 0x3;\n\tcs.dpl      = ds.dpl = 0;\n\tcs.db       = ds.db = 0;\n\tcs.s        = ds.s = 1;\n\tcs.l        = ds.l = 0;\n\tcs.g        = ds.g = 1;\n\tcs.avl      = ds.avl = 0;\n\tcs.present  = ds.present = 1;\n\tcs.unusable = ds.unusable = 0;\n\tcs.padding  = ds.padding = 0;\n\n\tkvm_set_segment(vcpu, &cs, VCPU_SREG_CS);\n\tkvm_set_segment(vcpu, &ds, VCPU_SREG_DS);\n\tkvm_set_segment(vcpu, &ds, VCPU_SREG_ES);\n\tkvm_set_segment(vcpu, &ds, VCPU_SREG_FS);\n\tkvm_set_segment(vcpu, &ds, VCPU_SREG_GS);\n\tkvm_set_segment(vcpu, &ds, VCPU_SREG_SS);\n\n\tif (guest_cpuid_has_longmode(vcpu))\n\t\tkvm_x86_ops->set_efer(vcpu, 0);\n\n\tkvm_update_cpuid(vcpu);\n\tkvm_mmu_reset_context(vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_check_request",
          "args": [
            "KVM_REQ_SMI",
            "vcpu"
          ],
          "line": 6498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "record_steal_time",
          "args": [
            "vcpu"
          ],
          "line": 6497
        },
        "resolved": true,
        "details": {
          "function_name": "record_steal_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "2006-2038",
          "snippet": "static void record_steal_time(struct kvm_vcpu *vcpu)\n{\n\tif (!(vcpu->arch.st.msr_val & KVM_MSR_ENABLED))\n\t\treturn;\n\n\tif (unlikely(kvm_read_guest_cached(vcpu->kvm, &vcpu->arch.st.stime,\n\t\t&vcpu->arch.st.steal, sizeof(struct kvm_steal_time))))\n\t\treturn;\n\n\tif (vcpu->arch.st.steal.version & 1)\n\t\tvcpu->arch.st.steal.version += 1;  /* first time write, random junk */\n\n\tvcpu->arch.st.steal.version += 1;\n\n\tkvm_write_guest_cached(vcpu->kvm, &vcpu->arch.st.stime,\n\t\t&vcpu->arch.st.steal, sizeof(struct kvm_steal_time));\n\n\tsmp_wmb();\n\n\tvcpu->arch.st.steal.steal += current->sched_info.run_delay -\n\t\tvcpu->arch.st.last_steal;\n\tvcpu->arch.st.last_steal = current->sched_info.run_delay;\n\n\tkvm_write_guest_cached(vcpu->kvm, &vcpu->arch.st.stime,\n\t\t&vcpu->arch.st.steal, sizeof(struct kvm_steal_time));\n\n\tsmp_wmb();\n\n\tvcpu->arch.st.steal.version += 1;\n\n\tkvm_write_guest_cached(vcpu->kvm, &vcpu->arch.st.stime,\n\t\t&vcpu->arch.st.steal, sizeof(struct kvm_steal_time));\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic void record_steal_time(struct kvm_vcpu *vcpu)\n{\n\tif (!(vcpu->arch.st.msr_val & KVM_MSR_ENABLED))\n\t\treturn;\n\n\tif (unlikely(kvm_read_guest_cached(vcpu->kvm, &vcpu->arch.st.stime,\n\t\t&vcpu->arch.st.steal, sizeof(struct kvm_steal_time))))\n\t\treturn;\n\n\tif (vcpu->arch.st.steal.version & 1)\n\t\tvcpu->arch.st.steal.version += 1;  /* first time write, random junk */\n\n\tvcpu->arch.st.steal.version += 1;\n\n\tkvm_write_guest_cached(vcpu->kvm, &vcpu->arch.st.stime,\n\t\t&vcpu->arch.st.steal, sizeof(struct kvm_steal_time));\n\n\tsmp_wmb();\n\n\tvcpu->arch.st.steal.steal += current->sched_info.run_delay -\n\t\tvcpu->arch.st.last_steal;\n\tvcpu->arch.st.last_steal = current->sched_info.run_delay;\n\n\tkvm_write_guest_cached(vcpu->kvm, &vcpu->arch.st.stime,\n\t\t&vcpu->arch.st.steal, sizeof(struct kvm_steal_time));\n\n\tsmp_wmb();\n\n\tvcpu->arch.st.steal.version += 1;\n\n\tkvm_write_guest_cached(vcpu->kvm, &vcpu->arch.st.stime,\n\t\t&vcpu->arch.st.steal, sizeof(struct kvm_steal_time));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_check_request",
          "args": [
            "KVM_REQ_STEAL_UPDATE",
            "vcpu"
          ],
          "line": 6496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_check_request",
          "args": [
            "KVM_REQ_APF_HALT",
            "vcpu"
          ],
          "line": 6490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_x86_ops->fpu_deactivate",
          "args": [
            "vcpu"
          ],
          "line": 6488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_check_request",
          "args": [
            "KVM_REQ_DEACTIVATE_FPU",
            "vcpu"
          ],
          "line": 6486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_check_request",
          "args": [
            "KVM_REQ_TRIPLE_FAULT",
            "vcpu"
          ],
          "line": 6481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_check_request",
          "args": [
            "KVM_REQ_REPORT_TPR_ACCESS",
            "vcpu"
          ],
          "line": 6476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_flush_tlb",
          "args": [
            "vcpu"
          ],
          "line": 6475
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_vcpu_flush_tlb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "6404-6408",
          "snippet": "static void kvm_vcpu_flush_tlb(struct kvm_vcpu *vcpu)\n{\n\t++vcpu->stat.tlb_flush;\n\tkvm_x86_ops->tlb_flush(vcpu);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "struct kvm_x86_ops *kvm_x86_ops"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nstatic void kvm_vcpu_flush_tlb(struct kvm_vcpu *vcpu)\n{\n\t++vcpu->stat.tlb_flush;\n\tkvm_x86_ops->tlb_flush(vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_check_request",
          "args": [
            "KVM_REQ_TLB_FLUSH",
            "vcpu"
          ],
          "line": 6474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_mmu_sync_roots",
          "args": [
            "vcpu"
          ],
          "line": 6473
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_sync_roots",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "3280-3285",
          "snippet": "void kvm_mmu_sync_roots(struct kvm_vcpu *vcpu)\n{\n\tspin_lock(&vcpu->kvm->mmu_lock);\n\tmmu_sync_roots(vcpu);\n\tspin_unlock(&vcpu->kvm->mmu_lock);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nvoid kvm_mmu_sync_roots(struct kvm_vcpu *vcpu)\n{\n\tspin_lock(&vcpu->kvm->mmu_lock);\n\tmmu_sync_roots(vcpu);\n\tspin_unlock(&vcpu->kvm->mmu_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_check_request",
          "args": [
            "KVM_REQ_MMU_SYNC",
            "vcpu"
          ],
          "line": 6472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "r"
          ],
          "line": 6469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_guest_time_update",
          "args": [
            "vcpu"
          ],
          "line": 6468
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_guest_time_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "1717-1850",
          "snippet": "static int kvm_guest_time_update(struct kvm_vcpu *v)\n{\n\tunsigned long flags, tgt_tsc_khz;\n\tstruct kvm_vcpu_arch *vcpu = &v->arch;\n\tstruct kvm_arch *ka = &v->kvm->arch;\n\ts64 kernel_ns;\n\tu64 tsc_timestamp, host_tsc;\n\tstruct pvclock_vcpu_time_info guest_hv_clock;\n\tu8 pvclock_flags;\n\tbool use_master_clock;\n\n\tkernel_ns = 0;\n\thost_tsc = 0;\n\n\t/*\n\t * If the host uses TSC clock, then passthrough TSC as stable\n\t * to the guest.\n\t */\n\tspin_lock(&ka->pvclock_gtod_sync_lock);\n\tuse_master_clock = ka->use_master_clock;\n\tif (use_master_clock) {\n\t\thost_tsc = ka->master_cycle_now;\n\t\tkernel_ns = ka->master_kernel_ns;\n\t}\n\tspin_unlock(&ka->pvclock_gtod_sync_lock);\n\n\t/* Keep irq disabled to prevent changes to the clock */\n\tlocal_irq_save(flags);\n\ttgt_tsc_khz = __this_cpu_read(cpu_tsc_khz);\n\tif (unlikely(tgt_tsc_khz == 0)) {\n\t\tlocal_irq_restore(flags);\n\t\tkvm_make_request(KVM_REQ_CLOCK_UPDATE, v);\n\t\treturn 1;\n\t}\n\tif (!use_master_clock) {\n\t\thost_tsc = rdtsc();\n\t\tkernel_ns = get_kernel_ns();\n\t}\n\n\ttsc_timestamp = kvm_read_l1_tsc(v, host_tsc);\n\n\t/*\n\t * We may have to catch up the TSC to match elapsed wall clock\n\t * time for two reasons, even if kvmclock is used.\n\t *   1) CPU could have been running below the maximum TSC rate\n\t *   2) Broken TSC compensation resets the base at each VCPU\n\t *      entry to avoid unknown leaps of TSC even when running\n\t *      again on the same CPU.  This may cause apparent elapsed\n\t *      time to disappear, and the guest to stand still or run\n\t *\tvery slowly.\n\t */\n\tif (vcpu->tsc_catchup) {\n\t\tu64 tsc = compute_guest_tsc(v, kernel_ns);\n\t\tif (tsc > tsc_timestamp) {\n\t\t\tadjust_tsc_offset_guest(v, tsc - tsc_timestamp);\n\t\t\ttsc_timestamp = tsc;\n\t\t}\n\t}\n\n\tlocal_irq_restore(flags);\n\n\tif (!vcpu->pv_time_enabled)\n\t\treturn 0;\n\n\tif (kvm_has_tsc_control)\n\t\ttgt_tsc_khz = kvm_scale_tsc(v, tgt_tsc_khz);\n\n\tif (unlikely(vcpu->hw_tsc_khz != tgt_tsc_khz)) {\n\t\tkvm_get_time_scale(NSEC_PER_SEC, tgt_tsc_khz * 1000LL,\n\t\t\t\t   &vcpu->hv_clock.tsc_shift,\n\t\t\t\t   &vcpu->hv_clock.tsc_to_system_mul);\n\t\tvcpu->hw_tsc_khz = tgt_tsc_khz;\n\t}\n\n\t/* With all the info we got, fill in the values */\n\tvcpu->hv_clock.tsc_timestamp = tsc_timestamp;\n\tvcpu->hv_clock.system_time = kernel_ns + v->kvm->arch.kvmclock_offset;\n\tvcpu->last_guest_tsc = tsc_timestamp;\n\n\tif (unlikely(kvm_read_guest_cached(v->kvm, &vcpu->pv_time,\n\t\t&guest_hv_clock, sizeof(guest_hv_clock))))\n\t\treturn 0;\n\n\t/* This VCPU is paused, but it's legal for a guest to read another\n\t * VCPU's kvmclock, so we really have to follow the specification where\n\t * it says that version is odd if data is being modified, and even after\n\t * it is consistent.\n\t *\n\t * Version field updates must be kept separate.  This is because\n\t * kvm_write_guest_cached might use a \"rep movs\" instruction, and\n\t * writes within a string instruction are weakly ordered.  So there\n\t * are three writes overall.\n\t *\n\t * As a small optimization, only write the version field in the first\n\t * and third write.  The vcpu->pv_time cache is still valid, because the\n\t * version field is the first in the struct.\n\t */\n\tBUILD_BUG_ON(offsetof(struct pvclock_vcpu_time_info, version) != 0);\n\n\tvcpu->hv_clock.version = guest_hv_clock.version + 1;\n\tkvm_write_guest_cached(v->kvm, &vcpu->pv_time,\n\t\t\t\t&vcpu->hv_clock,\n\t\t\t\tsizeof(vcpu->hv_clock.version));\n\n\tsmp_wmb();\n\n\t/* retain PVCLOCK_GUEST_STOPPED if set in guest copy */\n\tpvclock_flags = (guest_hv_clock.flags & PVCLOCK_GUEST_STOPPED);\n\n\tif (vcpu->pvclock_set_guest_stopped_request) {\n\t\tpvclock_flags |= PVCLOCK_GUEST_STOPPED;\n\t\tvcpu->pvclock_set_guest_stopped_request = false;\n\t}\n\n\t/* If the host uses TSC clocksource, then it is stable */\n\tif (use_master_clock)\n\t\tpvclock_flags |= PVCLOCK_TSC_STABLE_BIT;\n\n\tvcpu->hv_clock.flags = pvclock_flags;\n\n\ttrace_kvm_pvclock_update(v->vcpu_id, &vcpu->hv_clock);\n\n\tkvm_write_guest_cached(v->kvm, &vcpu->pv_time,\n\t\t\t\t&vcpu->hv_clock,\n\t\t\t\tsizeof(vcpu->hv_clock));\n\n\tsmp_wmb();\n\n\tvcpu->hv_clock.version++;\n\tkvm_write_guest_cached(v->kvm, &vcpu->pv_time,\n\t\t\t\t&vcpu->hv_clock,\n\t\t\t\tsizeof(vcpu->hv_clock.version));\n\treturn 0;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static DEFINE_PER_CPU(unsigned long, cpu_tsc_khz);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic DEFINE_PER_CPU(unsigned long, cpu_tsc_khz);\n\nstatic int kvm_guest_time_update(struct kvm_vcpu *v)\n{\n\tunsigned long flags, tgt_tsc_khz;\n\tstruct kvm_vcpu_arch *vcpu = &v->arch;\n\tstruct kvm_arch *ka = &v->kvm->arch;\n\ts64 kernel_ns;\n\tu64 tsc_timestamp, host_tsc;\n\tstruct pvclock_vcpu_time_info guest_hv_clock;\n\tu8 pvclock_flags;\n\tbool use_master_clock;\n\n\tkernel_ns = 0;\n\thost_tsc = 0;\n\n\t/*\n\t * If the host uses TSC clock, then passthrough TSC as stable\n\t * to the guest.\n\t */\n\tspin_lock(&ka->pvclock_gtod_sync_lock);\n\tuse_master_clock = ka->use_master_clock;\n\tif (use_master_clock) {\n\t\thost_tsc = ka->master_cycle_now;\n\t\tkernel_ns = ka->master_kernel_ns;\n\t}\n\tspin_unlock(&ka->pvclock_gtod_sync_lock);\n\n\t/* Keep irq disabled to prevent changes to the clock */\n\tlocal_irq_save(flags);\n\ttgt_tsc_khz = __this_cpu_read(cpu_tsc_khz);\n\tif (unlikely(tgt_tsc_khz == 0)) {\n\t\tlocal_irq_restore(flags);\n\t\tkvm_make_request(KVM_REQ_CLOCK_UPDATE, v);\n\t\treturn 1;\n\t}\n\tif (!use_master_clock) {\n\t\thost_tsc = rdtsc();\n\t\tkernel_ns = get_kernel_ns();\n\t}\n\n\ttsc_timestamp = kvm_read_l1_tsc(v, host_tsc);\n\n\t/*\n\t * We may have to catch up the TSC to match elapsed wall clock\n\t * time for two reasons, even if kvmclock is used.\n\t *   1) CPU could have been running below the maximum TSC rate\n\t *   2) Broken TSC compensation resets the base at each VCPU\n\t *      entry to avoid unknown leaps of TSC even when running\n\t *      again on the same CPU.  This may cause apparent elapsed\n\t *      time to disappear, and the guest to stand still or run\n\t *\tvery slowly.\n\t */\n\tif (vcpu->tsc_catchup) {\n\t\tu64 tsc = compute_guest_tsc(v, kernel_ns);\n\t\tif (tsc > tsc_timestamp) {\n\t\t\tadjust_tsc_offset_guest(v, tsc - tsc_timestamp);\n\t\t\ttsc_timestamp = tsc;\n\t\t}\n\t}\n\n\tlocal_irq_restore(flags);\n\n\tif (!vcpu->pv_time_enabled)\n\t\treturn 0;\n\n\tif (kvm_has_tsc_control)\n\t\ttgt_tsc_khz = kvm_scale_tsc(v, tgt_tsc_khz);\n\n\tif (unlikely(vcpu->hw_tsc_khz != tgt_tsc_khz)) {\n\t\tkvm_get_time_scale(NSEC_PER_SEC, tgt_tsc_khz * 1000LL,\n\t\t\t\t   &vcpu->hv_clock.tsc_shift,\n\t\t\t\t   &vcpu->hv_clock.tsc_to_system_mul);\n\t\tvcpu->hw_tsc_khz = tgt_tsc_khz;\n\t}\n\n\t/* With all the info we got, fill in the values */\n\tvcpu->hv_clock.tsc_timestamp = tsc_timestamp;\n\tvcpu->hv_clock.system_time = kernel_ns + v->kvm->arch.kvmclock_offset;\n\tvcpu->last_guest_tsc = tsc_timestamp;\n\n\tif (unlikely(kvm_read_guest_cached(v->kvm, &vcpu->pv_time,\n\t\t&guest_hv_clock, sizeof(guest_hv_clock))))\n\t\treturn 0;\n\n\t/* This VCPU is paused, but it's legal for a guest to read another\n\t * VCPU's kvmclock, so we really have to follow the specification where\n\t * it says that version is odd if data is being modified, and even after\n\t * it is consistent.\n\t *\n\t * Version field updates must be kept separate.  This is because\n\t * kvm_write_guest_cached might use a \"rep movs\" instruction, and\n\t * writes within a string instruction are weakly ordered.  So there\n\t * are three writes overall.\n\t *\n\t * As a small optimization, only write the version field in the first\n\t * and third write.  The vcpu->pv_time cache is still valid, because the\n\t * version field is the first in the struct.\n\t */\n\tBUILD_BUG_ON(offsetof(struct pvclock_vcpu_time_info, version) != 0);\n\n\tvcpu->hv_clock.version = guest_hv_clock.version + 1;\n\tkvm_write_guest_cached(v->kvm, &vcpu->pv_time,\n\t\t\t\t&vcpu->hv_clock,\n\t\t\t\tsizeof(vcpu->hv_clock.version));\n\n\tsmp_wmb();\n\n\t/* retain PVCLOCK_GUEST_STOPPED if set in guest copy */\n\tpvclock_flags = (guest_hv_clock.flags & PVCLOCK_GUEST_STOPPED);\n\n\tif (vcpu->pvclock_set_guest_stopped_request) {\n\t\tpvclock_flags |= PVCLOCK_GUEST_STOPPED;\n\t\tvcpu->pvclock_set_guest_stopped_request = false;\n\t}\n\n\t/* If the host uses TSC clocksource, then it is stable */\n\tif (use_master_clock)\n\t\tpvclock_flags |= PVCLOCK_TSC_STABLE_BIT;\n\n\tvcpu->hv_clock.flags = pvclock_flags;\n\n\ttrace_kvm_pvclock_update(v->vcpu_id, &vcpu->hv_clock);\n\n\tkvm_write_guest_cached(v->kvm, &vcpu->pv_time,\n\t\t\t\t&vcpu->hv_clock,\n\t\t\t\tsizeof(vcpu->hv_clock));\n\n\tsmp_wmb();\n\n\tvcpu->hv_clock.version++;\n\tkvm_write_guest_cached(v->kvm, &vcpu->pv_time,\n\t\t\t\t&vcpu->hv_clock,\n\t\t\t\tsizeof(vcpu->hv_clock.version));\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_check_request",
          "args": [
            "KVM_REQ_CLOCK_UPDATE",
            "vcpu"
          ],
          "line": 6467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_gen_kvmclock_update",
          "args": [
            "vcpu"
          ],
          "line": 6466
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_gen_kvmclock_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "1883-1890",
          "snippet": "static void kvm_gen_kvmclock_update(struct kvm_vcpu *v)\n{\n\tstruct kvm *kvm = v->kvm;\n\n\tkvm_make_request(KVM_REQ_CLOCK_UPDATE, v);\n\tschedule_delayed_work(&kvm->arch.kvmclock_update_work,\n\t\t\t\t\tKVMCLOCK_UPDATE_DELAY);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define KVMCLOCK_UPDATE_DELAY msecs_to_jiffies(100)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define KVMCLOCK_UPDATE_DELAY msecs_to_jiffies(100)\n\nstatic void kvm_gen_kvmclock_update(struct kvm_vcpu *v)\n{\n\tstruct kvm *kvm = v->kvm;\n\n\tkvm_make_request(KVM_REQ_CLOCK_UPDATE, v);\n\tschedule_delayed_work(&kvm->arch.kvmclock_update_work,\n\t\t\t\t\tKVMCLOCK_UPDATE_DELAY);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_check_request",
          "args": [
            "KVM_REQ_GLOBAL_CLOCK_UPDATE",
            "vcpu"
          ],
          "line": 6465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_gen_update_masterclock",
          "args": [
            "vcpu->kvm"
          ],
          "line": 6464
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_gen_update_masterclock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "1694-1715",
          "snippet": "static void kvm_gen_update_masterclock(struct kvm *kvm)\n{\n#ifdef CONFIG_X86_64\n\tint i;\n\tstruct kvm_vcpu *vcpu;\n\tstruct kvm_arch *ka = &kvm->arch;\n\n\tspin_lock(&ka->pvclock_gtod_sync_lock);\n\tkvm_make_mclock_inprogress_request(kvm);\n\t/* no guest entries from this point */\n\tpvclock_update_vm_gtod_copy(kvm);\n\n\tkvm_for_each_vcpu(i, vcpu, kvm)\n\t\tkvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);\n\n\t/* guest entries allowed */\n\tkvm_for_each_vcpu(i, vcpu, kvm)\n\t\tclear_bit(KVM_REQ_MCLOCK_INPROGRESS, &vcpu->requests);\n\n\tspin_unlock(&ka->pvclock_gtod_sync_lock);\n#endif\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic void kvm_gen_update_masterclock(struct kvm *kvm)\n{\n#ifdef CONFIG_X86_64\n\tint i;\n\tstruct kvm_vcpu *vcpu;\n\tstruct kvm_arch *ka = &kvm->arch;\n\n\tspin_lock(&ka->pvclock_gtod_sync_lock);\n\tkvm_make_mclock_inprogress_request(kvm);\n\t/* no guest entries from this point */\n\tpvclock_update_vm_gtod_copy(kvm);\n\n\tkvm_for_each_vcpu(i, vcpu, kvm)\n\t\tkvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);\n\n\t/* guest entries allowed */\n\tkvm_for_each_vcpu(i, vcpu, kvm)\n\t\tclear_bit(KVM_REQ_MCLOCK_INPROGRESS, &vcpu->requests);\n\n\tspin_unlock(&ka->pvclock_gtod_sync_lock);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_check_request",
          "args": [
            "KVM_REQ_MASTERCLOCK_UPDATE",
            "vcpu"
          ],
          "line": 6463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__kvm_migrate_timers",
          "args": [
            "vcpu"
          ],
          "line": 6462
        },
        "resolved": true,
        "details": {
          "function_name": "__kvm_migrate_timers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/irq.c",
          "lines": "148-152",
          "snippet": "void __kvm_migrate_timers(struct kvm_vcpu *vcpu)\n{\n\t__kvm_migrate_apic_timer(vcpu);\n\t__kvm_migrate_pit_timer(vcpu);\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"i8254.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"i8254.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n#include <linux/module.h>\n\nvoid __kvm_migrate_timers(struct kvm_vcpu *vcpu)\n{\n\t__kvm_migrate_apic_timer(vcpu);\n\t__kvm_migrate_pit_timer(vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_check_request",
          "args": [
            "KVM_REQ_MIGRATE_TIMER",
            "vcpu"
          ],
          "line": 6461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_mmu_unload",
          "args": [
            "vcpu"
          ],
          "line": 6460
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_unload",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "4255-4259",
          "snippet": "void kvm_mmu_unload(struct kvm_vcpu *vcpu)\n{\n\tmmu_free_roots(vcpu);\n\tWARN_ON(VALID_PAGE(vcpu->arch.mmu.root_hpa));\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nvoid kvm_mmu_unload(struct kvm_vcpu *vcpu)\n{\n\tmmu_free_roots(vcpu);\n\tWARN_ON(VALID_PAGE(vcpu->arch.mmu.root_hpa));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_check_request",
          "args": [
            "KVM_REQ_MMU_RELOAD",
            "vcpu"
          ],
          "line": 6459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_cpu_accept_dm_intr",
          "args": [
            "vcpu"
          ],
          "line": 6454
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_cpu_accept_dm_intr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "2788-2792",
          "snippet": "static int kvm_cpu_accept_dm_intr(struct kvm_vcpu *vcpu)\n{\n\treturn (!lapic_in_kernel(vcpu) ||\n\t\tkvm_apic_accept_pic_intr(vcpu));\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic int kvm_cpu_accept_dm_intr(struct kvm_vcpu *vcpu)\n{\n\treturn (!lapic_in_kernel(vcpu) ||\n\t\tkvm_apic_accept_pic_intr(vcpu));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dm_request_for_irq_injection",
          "args": [
            "vcpu"
          ],
          "line": 6453
        },
        "resolved": true,
        "details": {
          "function_name": "dm_request_for_irq_injection",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "6012-6016",
          "snippet": "static int dm_request_for_irq_injection(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->run->request_interrupt_window &&\n\t\tlikely(!pic_in_kernel(vcpu->kvm));\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic int dm_request_for_irq_injection(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->run->request_interrupt_window &&\n\t\tlikely(!pic_in_kernel(vcpu->kvm));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nstatic int vcpu_enter_guest(struct kvm_vcpu *vcpu)\n{\n\tint r;\n\tbool req_int_win =\n\t\tdm_request_for_irq_injection(vcpu) &&\n\t\tkvm_cpu_accept_dm_intr(vcpu);\n\n\tbool req_immediate_exit = false;\n\n\tif (vcpu->requests) {\n\t\tif (kvm_check_request(KVM_REQ_MMU_RELOAD, vcpu))\n\t\t\tkvm_mmu_unload(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_MIGRATE_TIMER, vcpu))\n\t\t\t__kvm_migrate_timers(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_MASTERCLOCK_UPDATE, vcpu))\n\t\t\tkvm_gen_update_masterclock(vcpu->kvm);\n\t\tif (kvm_check_request(KVM_REQ_GLOBAL_CLOCK_UPDATE, vcpu))\n\t\t\tkvm_gen_kvmclock_update(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_CLOCK_UPDATE, vcpu)) {\n\t\t\tr = kvm_guest_time_update(vcpu);\n\t\t\tif (unlikely(r))\n\t\t\t\tgoto out;\n\t\t}\n\t\tif (kvm_check_request(KVM_REQ_MMU_SYNC, vcpu))\n\t\t\tkvm_mmu_sync_roots(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_TLB_FLUSH, vcpu))\n\t\t\tkvm_vcpu_flush_tlb(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_REPORT_TPR_ACCESS, vcpu)) {\n\t\t\tvcpu->run->exit_reason = KVM_EXIT_TPR_ACCESS;\n\t\t\tr = 0;\n\t\t\tgoto out;\n\t\t}\n\t\tif (kvm_check_request(KVM_REQ_TRIPLE_FAULT, vcpu)) {\n\t\t\tvcpu->run->exit_reason = KVM_EXIT_SHUTDOWN;\n\t\t\tr = 0;\n\t\t\tgoto out;\n\t\t}\n\t\tif (kvm_check_request(KVM_REQ_DEACTIVATE_FPU, vcpu)) {\n\t\t\tvcpu->fpu_active = 0;\n\t\t\tkvm_x86_ops->fpu_deactivate(vcpu);\n\t\t}\n\t\tif (kvm_check_request(KVM_REQ_APF_HALT, vcpu)) {\n\t\t\t/* Page is swapped out. Do synthetic halt */\n\t\t\tvcpu->arch.apf.halted = true;\n\t\t\tr = 1;\n\t\t\tgoto out;\n\t\t}\n\t\tif (kvm_check_request(KVM_REQ_STEAL_UPDATE, vcpu))\n\t\t\trecord_steal_time(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_SMI, vcpu))\n\t\t\tprocess_smi(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_NMI, vcpu))\n\t\t\tprocess_nmi(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_PMU, vcpu))\n\t\t\tkvm_pmu_handle_event(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_PMI, vcpu))\n\t\t\tkvm_pmu_deliver_pmi(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_IOAPIC_EOI_EXIT, vcpu)) {\n\t\t\tBUG_ON(vcpu->arch.pending_ioapic_eoi > 255);\n\t\t\tif (test_bit(vcpu->arch.pending_ioapic_eoi,\n\t\t\t\t     vcpu->arch.ioapic_handled_vectors)) {\n\t\t\t\tvcpu->run->exit_reason = KVM_EXIT_IOAPIC_EOI;\n\t\t\t\tvcpu->run->eoi.vector =\n\t\t\t\t\t\tvcpu->arch.pending_ioapic_eoi;\n\t\t\t\tr = 0;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tif (kvm_check_request(KVM_REQ_SCAN_IOAPIC, vcpu))\n\t\t\tvcpu_scan_ioapic(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_APIC_PAGE_RELOAD, vcpu))\n\t\t\tkvm_vcpu_reload_apic_access_page(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_HV_CRASH, vcpu)) {\n\t\t\tvcpu->run->exit_reason = KVM_EXIT_SYSTEM_EVENT;\n\t\t\tvcpu->run->system_event.type = KVM_SYSTEM_EVENT_CRASH;\n\t\t\tr = 0;\n\t\t\tgoto out;\n\t\t}\n\t\tif (kvm_check_request(KVM_REQ_HV_RESET, vcpu)) {\n\t\t\tvcpu->run->exit_reason = KVM_EXIT_SYSTEM_EVENT;\n\t\t\tvcpu->run->system_event.type = KVM_SYSTEM_EVENT_RESET;\n\t\t\tr = 0;\n\t\t\tgoto out;\n\t\t}\n\t\tif (kvm_check_request(KVM_REQ_HV_EXIT, vcpu)) {\n\t\t\tvcpu->run->exit_reason = KVM_EXIT_HYPERV;\n\t\t\tvcpu->run->hyperv = vcpu->arch.hyperv.exit;\n\t\t\tr = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * KVM_REQ_HV_STIMER has to be processed after\n\t\t * KVM_REQ_CLOCK_UPDATE, because Hyper-V SynIC timers\n\t\t * depend on the guest clock being up-to-date\n\t\t */\n\t\tif (kvm_check_request(KVM_REQ_HV_STIMER, vcpu))\n\t\t\tkvm_hv_process_stimers(vcpu);\n\t}\n\n\t/*\n\t * KVM_REQ_EVENT is not set when posted interrupts are set by\n\t * VT-d hardware, so we have to update RVI unconditionally.\n\t */\n\tif (kvm_lapic_enabled(vcpu)) {\n\t\t/*\n\t\t * Update architecture specific hints for APIC\n\t\t * virtual interrupt delivery.\n\t\t */\n\t\tif (vcpu->arch.apicv_active)\n\t\t\tkvm_x86_ops->hwapic_irr_update(vcpu,\n\t\t\t\tkvm_lapic_find_highest_irr(vcpu));\n\t}\n\n\tif (kvm_check_request(KVM_REQ_EVENT, vcpu) || req_int_win) {\n\t\tkvm_apic_accept_events(vcpu);\n\t\tif (vcpu->arch.mp_state == KVM_MP_STATE_INIT_RECEIVED) {\n\t\t\tr = 1;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (inject_pending_event(vcpu, req_int_win) != 0)\n\t\t\treq_immediate_exit = true;\n\t\t/* enable NMI/IRQ window open exits if needed */\n\t\telse {\n\t\t\tif (vcpu->arch.nmi_pending)\n\t\t\t\tkvm_x86_ops->enable_nmi_window(vcpu);\n\t\t\tif (kvm_cpu_has_injectable_intr(vcpu) || req_int_win)\n\t\t\t\tkvm_x86_ops->enable_irq_window(vcpu);\n\t\t}\n\n\t\tif (kvm_lapic_enabled(vcpu)) {\n\t\t\tupdate_cr8_intercept(vcpu);\n\t\t\tkvm_lapic_sync_to_vapic(vcpu);\n\t\t}\n\t}\n\n\tr = kvm_mmu_reload(vcpu);\n\tif (unlikely(r)) {\n\t\tgoto cancel_injection;\n\t}\n\n\tpreempt_disable();\n\n\tkvm_x86_ops->prepare_guest_switch(vcpu);\n\tif (vcpu->fpu_active)\n\t\tkvm_load_guest_fpu(vcpu);\n\tvcpu->mode = IN_GUEST_MODE;\n\n\tsrcu_read_unlock(&vcpu->kvm->srcu, vcpu->srcu_idx);\n\n\t/*\n\t * We should set ->mode before check ->requests,\n\t * Please see the comment in kvm_make_all_cpus_request.\n\t * This also orders the write to mode from any reads\n\t * to the page tables done while the VCPU is running.\n\t * Please see the comment in kvm_flush_remote_tlbs.\n\t */\n\tsmp_mb__after_srcu_read_unlock();\n\n\tlocal_irq_disable();\n\n\tif (vcpu->mode == EXITING_GUEST_MODE || vcpu->requests\n\t    || need_resched() || signal_pending(current)) {\n\t\tvcpu->mode = OUTSIDE_GUEST_MODE;\n\t\tsmp_wmb();\n\t\tlocal_irq_enable();\n\t\tpreempt_enable();\n\t\tvcpu->srcu_idx = srcu_read_lock(&vcpu->kvm->srcu);\n\t\tr = 1;\n\t\tgoto cancel_injection;\n\t}\n\n\tkvm_load_guest_xcr0(vcpu);\n\n\tif (req_immediate_exit)\n\t\tsmp_send_reschedule(vcpu->cpu);\n\n\ttrace_kvm_entry(vcpu->vcpu_id);\n\twait_lapic_expire(vcpu);\n\t__kvm_guest_enter();\n\n\tif (unlikely(vcpu->arch.switch_db_regs)) {\n\t\tset_debugreg(0, 7);\n\t\tset_debugreg(vcpu->arch.eff_db[0], 0);\n\t\tset_debugreg(vcpu->arch.eff_db[1], 1);\n\t\tset_debugreg(vcpu->arch.eff_db[2], 2);\n\t\tset_debugreg(vcpu->arch.eff_db[3], 3);\n\t\tset_debugreg(vcpu->arch.dr6, 6);\n\t\tvcpu->arch.switch_db_regs &= ~KVM_DEBUGREG_RELOAD;\n\t}\n\n\tkvm_x86_ops->run(vcpu);\n\n\t/*\n\t * Do this here before restoring debug registers on the host.  And\n\t * since we do this before handling the vmexit, a DR access vmexit\n\t * can (a) read the correct value of the debug registers, (b) set\n\t * KVM_DEBUGREG_WONT_EXIT again.\n\t */\n\tif (unlikely(vcpu->arch.switch_db_regs & KVM_DEBUGREG_WONT_EXIT)) {\n\t\tWARN_ON(vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP);\n\t\tkvm_x86_ops->sync_dirty_debug_regs(vcpu);\n\t\tkvm_update_dr0123(vcpu);\n\t\tkvm_update_dr6(vcpu);\n\t\tkvm_update_dr7(vcpu);\n\t\tvcpu->arch.switch_db_regs &= ~KVM_DEBUGREG_RELOAD;\n\t}\n\n\t/*\n\t * If the guest has used debug registers, at least dr7\n\t * will be disabled while returning to the host.\n\t * If we don't have active breakpoints in the host, we don't\n\t * care about the messed up debug address registers. But if\n\t * we have some of them active, restore the old state.\n\t */\n\tif (hw_breakpoint_active())\n\t\thw_breakpoint_restore();\n\n\tvcpu->arch.last_guest_tsc = kvm_read_l1_tsc(vcpu, rdtsc());\n\n\tvcpu->mode = OUTSIDE_GUEST_MODE;\n\tsmp_wmb();\n\n\tkvm_put_guest_xcr0(vcpu);\n\n\t/* Interrupt is enabled by handle_external_intr() */\n\tkvm_x86_ops->handle_external_intr(vcpu);\n\n\t++vcpu->stat.exits;\n\n\t/*\n\t * We must have an instruction between local_irq_enable() and\n\t * kvm_guest_exit(), so the timer interrupt isn't delayed by\n\t * the interrupt shadow.  The stat.exits increment will do nicely.\n\t * But we need to prevent reordering, hence this barrier():\n\t */\n\tbarrier();\n\n\tkvm_guest_exit();\n\n\tpreempt_enable();\n\n\tvcpu->srcu_idx = srcu_read_lock(&vcpu->kvm->srcu);\n\n\t/*\n\t * Profile KVM exit RIPs:\n\t */\n\tif (unlikely(prof_on == KVM_PROFILING)) {\n\t\tunsigned long rip = kvm_rip_read(vcpu);\n\t\tprofile_hit(KVM_PROFILING, (void *)rip);\n\t}\n\n\tif (unlikely(vcpu->arch.tsc_always_catchup))\n\t\tkvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);\n\n\tif (vcpu->arch.apic_attention)\n\t\tkvm_lapic_sync_from_vapic(vcpu);\n\n\tr = kvm_x86_ops->handle_exit(vcpu);\n\treturn r;\n\ncancel_injection:\n\tkvm_x86_ops->cancel_injection(vcpu);\n\tif (unlikely(vcpu->arch.apic_attention))\n\t\tkvm_lapic_sync_from_vapic(vcpu);\nout:\n\treturn r;\n}"
  },
  {
    "function_name": "kvm_arch_mmu_notifier_invalidate_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "6433-6442",
    "snippet": "void kvm_arch_mmu_notifier_invalidate_page(struct kvm *kvm,\n\t\t\t\t\t   unsigned long address)\n{\n\t/*\n\t * The physical address of apic access page is stored in the VMCS.\n\t * Update it when it becomes invalid.\n\t */\n\tif (address == gfn_to_hva(kvm, APIC_DEFAULT_PHYS_BASE >> PAGE_SHIFT))\n\t\tkvm_make_all_cpus_request(kvm, KVM_REQ_APIC_PAGE_RELOAD);\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_make_all_cpus_request",
          "args": [
            "kvm",
            "KVM_REQ_APIC_PAGE_RELOAD"
          ],
          "line": 6441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfn_to_hva",
          "args": [
            "kvm",
            "APIC_DEFAULT_PHYS_BASE >> PAGE_SHIFT"
          ],
          "line": 6440
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nvoid kvm_arch_mmu_notifier_invalidate_page(struct kvm *kvm,\n\t\t\t\t\t   unsigned long address)\n{\n\t/*\n\t * The physical address of apic access page is stored in the VMCS.\n\t * Update it when it becomes invalid.\n\t */\n\tif (address == gfn_to_hva(kvm, APIC_DEFAULT_PHYS_BASE >> PAGE_SHIFT))\n\t\tkvm_make_all_cpus_request(kvm, KVM_REQ_APIC_PAGE_RELOAD);\n}"
  },
  {
    "function_name": "kvm_vcpu_reload_apic_access_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "6410-6430",
    "snippet": "void kvm_vcpu_reload_apic_access_page(struct kvm_vcpu *vcpu)\n{\n\tstruct page *page = NULL;\n\n\tif (!lapic_in_kernel(vcpu))\n\t\treturn;\n\n\tif (!kvm_x86_ops->set_apic_access_page_addr)\n\t\treturn;\n\n\tpage = gfn_to_page(vcpu->kvm, APIC_DEFAULT_PHYS_BASE >> PAGE_SHIFT);\n\tif (is_error_page(page))\n\t\treturn;\n\tkvm_x86_ops->set_apic_access_page_addr(vcpu, page_to_phys(page));\n\n\t/*\n\t * Do not pin apic access page in memory, the MMU notifier\n\t * will call us again if it is migrated or swapped out.\n\t */\n\tput_page(page);\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);",
      "struct kvm_x86_ops *kvm_x86_ops"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "page"
          ],
          "line": 6429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_x86_ops->set_apic_access_page_addr",
          "args": [
            "vcpu",
            "page_to_phys(page)"
          ],
          "line": 6423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_to_phys",
          "args": [
            "page"
          ],
          "line": 6423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_error_page",
          "args": [
            "page"
          ],
          "line": 6421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfn_to_page",
          "args": [
            "vcpu->kvm",
            "APIC_DEFAULT_PHYS_BASE >> PAGE_SHIFT"
          ],
          "line": 6420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lapic_in_kernel",
          "args": [
            "vcpu"
          ],
          "line": 6414
        },
        "resolved": true,
        "details": {
          "function_name": "lapic_in_kernel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.h",
          "lines": "141-146",
          "snippet": "static inline bool lapic_in_kernel(struct kvm_vcpu *vcpu)\n{\n\tif (static_key_false(&kvm_no_apic_vcpu))\n\t\treturn vcpu->arch.apic;\n\treturn true;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline bool lapic_in_kernel(struct kvm_vcpu *vcpu)\n{\n\tif (static_key_false(&kvm_no_apic_vcpu))\n\t\treturn vcpu->arch.apic;\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nvoid kvm_vcpu_reload_apic_access_page(struct kvm_vcpu *vcpu)\n{\n\tstruct page *page = NULL;\n\n\tif (!lapic_in_kernel(vcpu))\n\t\treturn;\n\n\tif (!kvm_x86_ops->set_apic_access_page_addr)\n\t\treturn;\n\n\tpage = gfn_to_page(vcpu->kvm, APIC_DEFAULT_PHYS_BASE >> PAGE_SHIFT);\n\tif (is_error_page(page))\n\t\treturn;\n\tkvm_x86_ops->set_apic_access_page_addr(vcpu, page_to_phys(page));\n\n\t/*\n\t * Do not pin apic access page in memory, the MMU notifier\n\t * will call us again if it is migrated or swapped out.\n\t */\n\tput_page(page);\n}"
  },
  {
    "function_name": "kvm_vcpu_flush_tlb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "6404-6408",
    "snippet": "static void kvm_vcpu_flush_tlb(struct kvm_vcpu *vcpu)\n{\n\t++vcpu->stat.tlb_flush;\n\tkvm_x86_ops->tlb_flush(vcpu);\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);",
      "struct kvm_x86_ops *kvm_x86_ops"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_x86_ops->tlb_flush",
          "args": [
            "vcpu"
          ],
          "line": 6407
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nstatic void kvm_vcpu_flush_tlb(struct kvm_vcpu *vcpu)\n{\n\t++vcpu->stat.tlb_flush;\n\tkvm_x86_ops->tlb_flush(vcpu);\n}"
  },
  {
    "function_name": "vcpu_scan_ioapic",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "6383-6402",
    "snippet": "static void vcpu_scan_ioapic(struct kvm_vcpu *vcpu)\n{\n\tu64 eoi_exit_bitmap[4];\n\n\tif (!kvm_apic_hw_enabled(vcpu->arch.apic))\n\t\treturn;\n\n\tbitmap_zero(vcpu->arch.ioapic_handled_vectors, 256);\n\n\tif (irqchip_split(vcpu->kvm))\n\t\tkvm_scan_ioapic_routes(vcpu, vcpu->arch.ioapic_handled_vectors);\n\telse {\n\t\tif (vcpu->arch.apicv_active)\n\t\t\tkvm_x86_ops->sync_pir_to_irr(vcpu);\n\t\tkvm_ioapic_scan_entry(vcpu, vcpu->arch.ioapic_handled_vectors);\n\t}\n\tbitmap_or((ulong *)eoi_exit_bitmap, vcpu->arch.ioapic_handled_vectors,\n\t\t  vcpu_to_synic(vcpu)->vec_bitmap, 256);\n\tkvm_x86_ops->load_eoi_exitmap(vcpu, eoi_exit_bitmap);\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);",
      "struct kvm_x86_ops *kvm_x86_ops"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_x86_ops->load_eoi_exitmap",
          "args": [
            "vcpu",
            "eoi_exit_bitmap"
          ],
          "line": 6401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bitmap_or",
          "args": [
            "(ulong *)eoi_exit_bitmap",
            "vcpu->arch.ioapic_handled_vectors",
            "vcpu_to_synic(vcpu)->vec_bitmap",
            "256"
          ],
          "line": 6399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vcpu_to_synic",
          "args": [
            "vcpu"
          ],
          "line": 6400
        },
        "resolved": true,
        "details": {
          "function_name": "vcpu_to_synic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.h",
          "lines": "40-43",
          "snippet": "static inline struct kvm_vcpu_hv_synic *vcpu_to_synic(struct kvm_vcpu *vcpu)\n{\n\treturn &vcpu->arch.hyperv.synic;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct kvm_vcpu_hv_synic *vcpu_to_synic(struct kvm_vcpu *vcpu)\n{\n\treturn &vcpu->arch.hyperv.synic;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_ioapic_scan_entry",
          "args": [
            "vcpu",
            "vcpu->arch.ioapic_handled_vectors"
          ],
          "line": 6397
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_ioapic_scan_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/ioapic.c",
          "lines": "237-265",
          "snippet": "void kvm_ioapic_scan_entry(struct kvm_vcpu *vcpu, ulong *ioapic_handled_vectors)\n{\n\tstruct kvm_ioapic *ioapic = vcpu->kvm->arch.vioapic;\n\tstruct dest_map *dest_map = &ioapic->rtc_status.dest_map;\n\tunion kvm_ioapic_redirect_entry *e;\n\tint index;\n\n\tspin_lock(&ioapic->lock);\n\n\t/* Make sure we see any missing RTC EOI */\n\tif (test_bit(vcpu->vcpu_id, dest_map->map))\n\t\t__set_bit(dest_map->vectors[vcpu->vcpu_id],\n\t\t\t  ioapic_handled_vectors);\n\n\tfor (index = 0; index < IOAPIC_NUM_PINS; index++) {\n\t\te = &ioapic->redirtbl[index];\n\t\tif (e->fields.trig_mode == IOAPIC_LEVEL_TRIG ||\n\t\t    kvm_irq_has_notifier(ioapic->kvm, KVM_IRQCHIP_IOAPIC, index) ||\n\t\t    index == RTC_GSI) {\n\t\t\tif (kvm_apic_match_dest(vcpu, NULL, 0,\n\t\t\t             e->fields.dest_id, e->fields.dest_mode) ||\n\t\t\t    (e->fields.trig_mode == IOAPIC_EDGE_TRIG &&\n\t\t\t     kvm_apic_pending_eoi(vcpu, e->fields.vector)))\n\t\t\t\t__set_bit(e->fields.vector,\n\t\t\t\t\t  ioapic_handled_vectors);\n\t\t}\n\t}\n\tspin_unlock(&ioapic->lock);\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"lapic.h\"",
            "#include \"ioapic.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/processor.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <trace/events/kvm.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/processor.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);\n\nvoid kvm_ioapic_scan_entry(struct kvm_vcpu *vcpu, ulong *ioapic_handled_vectors)\n{\n\tstruct kvm_ioapic *ioapic = vcpu->kvm->arch.vioapic;\n\tstruct dest_map *dest_map = &ioapic->rtc_status.dest_map;\n\tunion kvm_ioapic_redirect_entry *e;\n\tint index;\n\n\tspin_lock(&ioapic->lock);\n\n\t/* Make sure we see any missing RTC EOI */\n\tif (test_bit(vcpu->vcpu_id, dest_map->map))\n\t\t__set_bit(dest_map->vectors[vcpu->vcpu_id],\n\t\t\t  ioapic_handled_vectors);\n\n\tfor (index = 0; index < IOAPIC_NUM_PINS; index++) {\n\t\te = &ioapic->redirtbl[index];\n\t\tif (e->fields.trig_mode == IOAPIC_LEVEL_TRIG ||\n\t\t    kvm_irq_has_notifier(ioapic->kvm, KVM_IRQCHIP_IOAPIC, index) ||\n\t\t    index == RTC_GSI) {\n\t\t\tif (kvm_apic_match_dest(vcpu, NULL, 0,\n\t\t\t             e->fields.dest_id, e->fields.dest_mode) ||\n\t\t\t    (e->fields.trig_mode == IOAPIC_EDGE_TRIG &&\n\t\t\t     kvm_apic_pending_eoi(vcpu, e->fields.vector)))\n\t\t\t\t__set_bit(e->fields.vector,\n\t\t\t\t\t  ioapic_handled_vectors);\n\t\t}\n\t}\n\tspin_unlock(&ioapic->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_x86_ops->sync_pir_to_irr",
          "args": [
            "vcpu"
          ],
          "line": 6396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_scan_ioapic_routes",
          "args": [
            "vcpu",
            "vcpu->arch.ioapic_handled_vectors"
          ],
          "line": 6393
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_scan_ioapic_routes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/irq_comm.c",
          "lines": "376-409",
          "snippet": "void kvm_scan_ioapic_routes(struct kvm_vcpu *vcpu,\n\t\t\t    ulong *ioapic_handled_vectors)\n{\n\tstruct kvm *kvm = vcpu->kvm;\n\tstruct kvm_kernel_irq_routing_entry *entry;\n\tstruct kvm_irq_routing_table *table;\n\tu32 i, nr_ioapic_pins;\n\tint idx;\n\n\tidx = srcu_read_lock(&kvm->irq_srcu);\n\ttable = srcu_dereference(kvm->irq_routing, &kvm->irq_srcu);\n\tnr_ioapic_pins = min_t(u32, table->nr_rt_entries,\n\t\t\t       kvm->arch.nr_reserved_ioapic_pins);\n\tfor (i = 0; i < nr_ioapic_pins; ++i) {\n\t\thlist_for_each_entry(entry, &table->map[i], link) {\n\t\t\tu32 dest_id, dest_mode;\n\t\t\tbool level;\n\n\t\t\tif (entry->type != KVM_IRQ_ROUTING_MSI)\n\t\t\t\tcontinue;\n\t\t\tdest_id = (entry->msi.address_lo >> 12) & 0xff;\n\t\t\tdest_mode = (entry->msi.address_lo >> 2) & 0x1;\n\t\t\tlevel = entry->msi.data & MSI_DATA_TRIGGER_LEVEL;\n\t\t\tif (level && kvm_apic_match_dest(vcpu, NULL, 0,\n\t\t\t\t\t\tdest_id, dest_mode)) {\n\t\t\t\tu32 vector = entry->msi.data & 0xff;\n\n\t\t\t\t__set_bit(vector,\n\t\t\t\t\t  ioapic_handled_vectors);\n\t\t\t}\n\t\t}\n\t}\n\tsrcu_read_unlock(&kvm->irq_srcu, idx);\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"hyperv.h\"",
            "#include \"lapic.h\"",
            "#include \"ioapic.h\"",
            "#include \"irq.h\"",
            "#include <asm/msidef.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"hyperv.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include \"irq.h\"\n#include <asm/msidef.h>\n#include <trace/events/kvm.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nvoid kvm_scan_ioapic_routes(struct kvm_vcpu *vcpu,\n\t\t\t    ulong *ioapic_handled_vectors)\n{\n\tstruct kvm *kvm = vcpu->kvm;\n\tstruct kvm_kernel_irq_routing_entry *entry;\n\tstruct kvm_irq_routing_table *table;\n\tu32 i, nr_ioapic_pins;\n\tint idx;\n\n\tidx = srcu_read_lock(&kvm->irq_srcu);\n\ttable = srcu_dereference(kvm->irq_routing, &kvm->irq_srcu);\n\tnr_ioapic_pins = min_t(u32, table->nr_rt_entries,\n\t\t\t       kvm->arch.nr_reserved_ioapic_pins);\n\tfor (i = 0; i < nr_ioapic_pins; ++i) {\n\t\thlist_for_each_entry(entry, &table->map[i], link) {\n\t\t\tu32 dest_id, dest_mode;\n\t\t\tbool level;\n\n\t\t\tif (entry->type != KVM_IRQ_ROUTING_MSI)\n\t\t\t\tcontinue;\n\t\t\tdest_id = (entry->msi.address_lo >> 12) & 0xff;\n\t\t\tdest_mode = (entry->msi.address_lo >> 2) & 0x1;\n\t\t\tlevel = entry->msi.data & MSI_DATA_TRIGGER_LEVEL;\n\t\t\tif (level && kvm_apic_match_dest(vcpu, NULL, 0,\n\t\t\t\t\t\tdest_id, dest_mode)) {\n\t\t\t\tu32 vector = entry->msi.data & 0xff;\n\n\t\t\t\t__set_bit(vector,\n\t\t\t\t\t  ioapic_handled_vectors);\n\t\t\t}\n\t\t}\n\t}\n\tsrcu_read_unlock(&kvm->irq_srcu, idx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irqchip_split",
          "args": [
            "vcpu->kvm"
          ],
          "line": 6392
        },
        "resolved": true,
        "details": {
          "function_name": "irqchip_split",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/irq.h",
          "lines": "94-97",
          "snippet": "static inline int irqchip_split(struct kvm *kvm)\n{\n\treturn kvm->arch.irqchip_split;\n}",
          "includes": [
            "#include \"lapic.h\"",
            "#include \"ioapic.h\"",
            "#include <kvm/iodev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/mm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <kvm/iodev.h>\n#include <linux/spinlock.h>\n#include <linux/kvm_host.h>\n#include <linux/hrtimer.h>\n#include <linux/mm_types.h>\n\nstatic inline int irqchip_split(struct kvm *kvm)\n{\n\treturn kvm->arch.irqchip_split;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bitmap_zero",
          "args": [
            "vcpu->arch.ioapic_handled_vectors",
            "256"
          ],
          "line": 6390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_apic_hw_enabled",
          "args": [
            "vcpu->arch.apic"
          ],
          "line": 6387
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_hw_enabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.h",
          "lines": "150-155",
          "snippet": "static inline int kvm_apic_hw_enabled(struct kvm_lapic *apic)\n{\n\tif (static_key_false(&apic_hw_disabled.key))\n\t\treturn apic->vcpu->arch.apic_base & MSR_IA32_APICBASE_ENABLE;\n\treturn MSR_IA32_APICBASE_ENABLE;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline int kvm_apic_hw_enabled(struct kvm_lapic *apic)\n{\n\tif (static_key_false(&apic_hw_disabled.key))\n\t\treturn apic->vcpu->arch.apic_base & MSR_IA32_APICBASE_ENABLE;\n\treturn MSR_IA32_APICBASE_ENABLE;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nstatic void vcpu_scan_ioapic(struct kvm_vcpu *vcpu)\n{\n\tu64 eoi_exit_bitmap[4];\n\n\tif (!kvm_apic_hw_enabled(vcpu->arch.apic))\n\t\treturn;\n\n\tbitmap_zero(vcpu->arch.ioapic_handled_vectors, 256);\n\n\tif (irqchip_split(vcpu->kvm))\n\t\tkvm_scan_ioapic_routes(vcpu, vcpu->arch.ioapic_handled_vectors);\n\telse {\n\t\tif (vcpu->arch.apicv_active)\n\t\t\tkvm_x86_ops->sync_pir_to_irr(vcpu);\n\t\tkvm_ioapic_scan_entry(vcpu, vcpu->arch.ioapic_handled_vectors);\n\t}\n\tbitmap_or((ulong *)eoi_exit_bitmap, vcpu->arch.ioapic_handled_vectors,\n\t\t  vcpu_to_synic(vcpu)->vec_bitmap, 256);\n\tkvm_x86_ops->load_eoi_exitmap(vcpu, eoi_exit_bitmap);\n}"
  },
  {
    "function_name": "kvm_make_scan_ioapic_request",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "6378-6381",
    "snippet": "void kvm_make_scan_ioapic_request(struct kvm *kvm)\n{\n\tkvm_make_all_cpus_request(kvm, KVM_REQ_SCAN_IOAPIC);\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_make_all_cpus_request",
          "args": [
            "kvm",
            "KVM_REQ_SCAN_IOAPIC"
          ],
          "line": 6380
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nvoid kvm_make_scan_ioapic_request(struct kvm *kvm)\n{\n\tkvm_make_all_cpus_request(kvm, KVM_REQ_SCAN_IOAPIC);\n}"
  },
  {
    "function_name": "process_smi",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "6304-6376",
    "snippet": "static void process_smi(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_segment cs, ds;\n\tstruct desc_ptr dt;\n\tchar buf[512];\n\tu32 cr0;\n\n\tif (is_smm(vcpu)) {\n\t\tvcpu->arch.smi_pending = true;\n\t\treturn;\n\t}\n\n\ttrace_kvm_enter_smm(vcpu->vcpu_id, vcpu->arch.smbase, true);\n\tvcpu->arch.hflags |= HF_SMM_MASK;\n\tmemset(buf, 0, 512);\n\tif (guest_cpuid_has_longmode(vcpu))\n\t\tprocess_smi_save_state_64(vcpu, buf);\n\telse\n\t\tprocess_smi_save_state_32(vcpu, buf);\n\n\tkvm_vcpu_write_guest(vcpu, vcpu->arch.smbase + 0xfe00, buf, sizeof(buf));\n\n\tif (kvm_x86_ops->get_nmi_mask(vcpu))\n\t\tvcpu->arch.hflags |= HF_SMM_INSIDE_NMI_MASK;\n\telse\n\t\tkvm_x86_ops->set_nmi_mask(vcpu, true);\n\n\tkvm_set_rflags(vcpu, X86_EFLAGS_FIXED);\n\tkvm_rip_write(vcpu, 0x8000);\n\n\tcr0 = vcpu->arch.cr0 & ~(X86_CR0_PE | X86_CR0_EM | X86_CR0_TS | X86_CR0_PG);\n\tkvm_x86_ops->set_cr0(vcpu, cr0);\n\tvcpu->arch.cr0 = cr0;\n\n\tkvm_x86_ops->set_cr4(vcpu, 0);\n\n\t/* Undocumented: IDT limit is set to zero on entry to SMM.  */\n\tdt.address = dt.size = 0;\n\tkvm_x86_ops->set_idt(vcpu, &dt);\n\n\t__kvm_set_dr(vcpu, 7, DR7_FIXED_1);\n\n\tcs.selector = (vcpu->arch.smbase >> 4) & 0xffff;\n\tcs.base = vcpu->arch.smbase;\n\n\tds.selector = 0;\n\tds.base = 0;\n\n\tcs.limit    = ds.limit = 0xffffffff;\n\tcs.type     = ds.type = 0x3;\n\tcs.dpl      = ds.dpl = 0;\n\tcs.db       = ds.db = 0;\n\tcs.s        = ds.s = 1;\n\tcs.l        = ds.l = 0;\n\tcs.g        = ds.g = 1;\n\tcs.avl      = ds.avl = 0;\n\tcs.present  = ds.present = 1;\n\tcs.unusable = ds.unusable = 0;\n\tcs.padding  = ds.padding = 0;\n\n\tkvm_set_segment(vcpu, &cs, VCPU_SREG_CS);\n\tkvm_set_segment(vcpu, &ds, VCPU_SREG_DS);\n\tkvm_set_segment(vcpu, &ds, VCPU_SREG_ES);\n\tkvm_set_segment(vcpu, &ds, VCPU_SREG_FS);\n\tkvm_set_segment(vcpu, &ds, VCPU_SREG_GS);\n\tkvm_set_segment(vcpu, &ds, VCPU_SREG_SS);\n\n\tif (guest_cpuid_has_longmode(vcpu))\n\t\tkvm_x86_ops->set_efer(vcpu, 0);\n\n\tkvm_update_cpuid(vcpu);\n\tkvm_mmu_reset_context(vcpu);\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);",
      "struct kvm_x86_ops *kvm_x86_ops"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_mmu_reset_context",
          "args": [
            "vcpu"
          ],
          "line": 6375
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_reset_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "4230-4234",
          "snippet": "void kvm_mmu_reset_context(struct kvm_vcpu *vcpu)\n{\n\tkvm_mmu_unload(vcpu);\n\tinit_kvm_mmu(vcpu);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nvoid kvm_mmu_reset_context(struct kvm_vcpu *vcpu)\n{\n\tkvm_mmu_unload(vcpu);\n\tinit_kvm_mmu(vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_update_cpuid",
          "args": [
            "vcpu"
          ],
          "line": 6374
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_update_cpuid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/cpuid.c",
          "lines": "68-134",
          "snippet": "int kvm_update_cpuid(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_cpuid_entry2 *best;\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tbest = kvm_find_cpuid_entry(vcpu, 1, 0);\n\tif (!best)\n\t\treturn 0;\n\n\t/* Update OSXSAVE bit */\n\tif (cpu_has_xsave && best->function == 0x1) {\n\t\tbest->ecx &= ~F(OSXSAVE);\n\t\tif (kvm_read_cr4_bits(vcpu, X86_CR4_OSXSAVE))\n\t\t\tbest->ecx |= F(OSXSAVE);\n\t}\n\n\tif (apic) {\n\t\tif (best->ecx & F(TSC_DEADLINE_TIMER))\n\t\t\tapic->lapic_timer.timer_mode_mask = 3 << 17;\n\t\telse\n\t\t\tapic->lapic_timer.timer_mode_mask = 1 << 17;\n\t}\n\n\tbest = kvm_find_cpuid_entry(vcpu, 7, 0);\n\tif (best) {\n\t\t/* Update OSPKE bit */\n\t\tif (boot_cpu_has(X86_FEATURE_PKU) && best->function == 0x7) {\n\t\t\tbest->ecx &= ~F(OSPKE);\n\t\t\tif (kvm_read_cr4_bits(vcpu, X86_CR4_PKE))\n\t\t\t\tbest->ecx |= F(OSPKE);\n\t\t}\n\t}\n\n\tbest = kvm_find_cpuid_entry(vcpu, 0xD, 0);\n\tif (!best) {\n\t\tvcpu->arch.guest_supported_xcr0 = 0;\n\t\tvcpu->arch.guest_xstate_size = XSAVE_HDR_SIZE + XSAVE_HDR_OFFSET;\n\t} else {\n\t\tvcpu->arch.guest_supported_xcr0 =\n\t\t\t(best->eax | ((u64)best->edx << 32)) &\n\t\t\tkvm_supported_xcr0();\n\t\tvcpu->arch.guest_xstate_size = best->ebx =\n\t\t\txstate_required_size(vcpu->arch.xcr0, false);\n\t}\n\n\tbest = kvm_find_cpuid_entry(vcpu, 0xD, 1);\n\tif (best && (best->eax & (F(XSAVES) | F(XSAVEC))))\n\t\tbest->ebx = xstate_required_size(vcpu->arch.xcr0, true);\n\n\tif (use_eager_fpu())\n\t\tkvm_x86_ops->fpu_activate(vcpu);\n\n\t/*\n\t * The existing code assumes virtual address is 48-bit in the canonical\n\t * address checks; exit if it is ever changed.\n\t */\n\tbest = kvm_find_cpuid_entry(vcpu, 0x80000008, 0);\n\tif (best && ((best->eax & 0xff00) >> 8) != 48 &&\n\t\t((best->eax & 0xff00) >> 8) != 0)\n\t\treturn -EINVAL;\n\n\t/* Update physical-address width */\n\tvcpu->arch.maxphyaddr = cpuid_query_maxphyaddr(vcpu);\n\n\tkvm_pmu_refresh(vcpu);\n\treturn 0;\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"trace.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"cpuid.h\"",
            "#include <asm/fpu/xstate.h>",
            "#include <asm/user.h>",
            "#include <asm/fpu/internal.h> /* For use_eager_fpu.  Ugh! */",
            "#include <linux/uaccess.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"trace.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include <asm/fpu/xstate.h>\n#include <asm/user.h>\n#include <asm/fpu/internal.h> /* For use_eager_fpu.  Ugh! */\n#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n\nint kvm_update_cpuid(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_cpuid_entry2 *best;\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tbest = kvm_find_cpuid_entry(vcpu, 1, 0);\n\tif (!best)\n\t\treturn 0;\n\n\t/* Update OSXSAVE bit */\n\tif (cpu_has_xsave && best->function == 0x1) {\n\t\tbest->ecx &= ~F(OSXSAVE);\n\t\tif (kvm_read_cr4_bits(vcpu, X86_CR4_OSXSAVE))\n\t\t\tbest->ecx |= F(OSXSAVE);\n\t}\n\n\tif (apic) {\n\t\tif (best->ecx & F(TSC_DEADLINE_TIMER))\n\t\t\tapic->lapic_timer.timer_mode_mask = 3 << 17;\n\t\telse\n\t\t\tapic->lapic_timer.timer_mode_mask = 1 << 17;\n\t}\n\n\tbest = kvm_find_cpuid_entry(vcpu, 7, 0);\n\tif (best) {\n\t\t/* Update OSPKE bit */\n\t\tif (boot_cpu_has(X86_FEATURE_PKU) && best->function == 0x7) {\n\t\t\tbest->ecx &= ~F(OSPKE);\n\t\t\tif (kvm_read_cr4_bits(vcpu, X86_CR4_PKE))\n\t\t\t\tbest->ecx |= F(OSPKE);\n\t\t}\n\t}\n\n\tbest = kvm_find_cpuid_entry(vcpu, 0xD, 0);\n\tif (!best) {\n\t\tvcpu->arch.guest_supported_xcr0 = 0;\n\t\tvcpu->arch.guest_xstate_size = XSAVE_HDR_SIZE + XSAVE_HDR_OFFSET;\n\t} else {\n\t\tvcpu->arch.guest_supported_xcr0 =\n\t\t\t(best->eax | ((u64)best->edx << 32)) &\n\t\t\tkvm_supported_xcr0();\n\t\tvcpu->arch.guest_xstate_size = best->ebx =\n\t\t\txstate_required_size(vcpu->arch.xcr0, false);\n\t}\n\n\tbest = kvm_find_cpuid_entry(vcpu, 0xD, 1);\n\tif (best && (best->eax & (F(XSAVES) | F(XSAVEC))))\n\t\tbest->ebx = xstate_required_size(vcpu->arch.xcr0, true);\n\n\tif (use_eager_fpu())\n\t\tkvm_x86_ops->fpu_activate(vcpu);\n\n\t/*\n\t * The existing code assumes virtual address is 48-bit in the canonical\n\t * address checks; exit if it is ever changed.\n\t */\n\tbest = kvm_find_cpuid_entry(vcpu, 0x80000008, 0);\n\tif (best && ((best->eax & 0xff00) >> 8) != 48 &&\n\t\t((best->eax & 0xff00) >> 8) != 0)\n\t\treturn -EINVAL;\n\n\t/* Update physical-address width */\n\tvcpu->arch.maxphyaddr = cpuid_query_maxphyaddr(vcpu);\n\n\tkvm_pmu_refresh(vcpu);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_x86_ops->set_efer",
          "args": [
            "vcpu",
            "0"
          ],
          "line": 6372
        },
        "resolved": true,
        "details": {
          "function_name": "set_efer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "1015-1036",
          "snippet": "static int set_efer(struct kvm_vcpu *vcpu, u64 efer)\n{\n\tu64 old_efer = vcpu->arch.efer;\n\n\tif (!kvm_valid_efer(vcpu, efer))\n\t\treturn 1;\n\n\tif (is_paging(vcpu)\n\t    && (vcpu->arch.efer & EFER_LME) != (efer & EFER_LME))\n\t\treturn 1;\n\n\tefer &= ~EFER_LMA;\n\tefer |= vcpu->arch.efer & EFER_LMA;\n\n\tkvm_x86_ops->set_efer(vcpu, efer);\n\n\t/* Update reserved bits */\n\tif ((efer ^ old_efer) & EFER_NX)\n\t\tkvm_mmu_reset_context(vcpu);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "struct kvm_x86_ops *kvm_x86_ops"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nstatic int set_efer(struct kvm_vcpu *vcpu, u64 efer)\n{\n\tu64 old_efer = vcpu->arch.efer;\n\n\tif (!kvm_valid_efer(vcpu, efer))\n\t\treturn 1;\n\n\tif (is_paging(vcpu)\n\t    && (vcpu->arch.efer & EFER_LME) != (efer & EFER_LME))\n\t\treturn 1;\n\n\tefer &= ~EFER_LMA;\n\tefer |= vcpu->arch.efer & EFER_LMA;\n\n\tkvm_x86_ops->set_efer(vcpu, efer);\n\n\t/* Update reserved bits */\n\tif ((efer ^ old_efer) & EFER_NX)\n\t\tkvm_mmu_reset_context(vcpu);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "guest_cpuid_has_longmode",
          "args": [
            "vcpu"
          ],
          "line": 6371
        },
        "resolved": true,
        "details": {
          "function_name": "guest_cpuid_has_longmode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/cpuid.h",
          "lines": "91-97",
          "snippet": "static inline bool guest_cpuid_has_longmode(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_cpuid_entry2 *best;\n\n\tbest = kvm_find_cpuid_entry(vcpu, 0x80000001, 0);\n\treturn best && (best->edx & bit(X86_FEATURE_LM));\n}",
          "includes": [
            "#include <asm/cpu.h>",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpu.h>\n#include \"x86.h\"\n\nstatic inline bool guest_cpuid_has_longmode(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_cpuid_entry2 *best;\n\n\tbest = kvm_find_cpuid_entry(vcpu, 0x80000001, 0);\n\treturn best && (best->edx & bit(X86_FEATURE_LM));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_set_segment",
          "args": [
            "vcpu",
            "&ds",
            "VCPU_SREG_SS"
          ],
          "line": 6369
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_set_segment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "4151-4155",
          "snippet": "static void kvm_set_segment(struct kvm_vcpu *vcpu,\n\t\t\tstruct kvm_segment *var, int seg)\n{\n\tkvm_x86_ops->set_segment(vcpu, var, seg);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "struct kvm_x86_ops *kvm_x86_ops"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nstatic void kvm_set_segment(struct kvm_vcpu *vcpu,\n\t\t\tstruct kvm_segment *var, int seg)\n{\n\tkvm_x86_ops->set_segment(vcpu, var, seg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__kvm_set_dr",
          "args": [
            "vcpu",
            "7",
            "DR7_FIXED_1"
          ],
          "line": 6344
        },
        "resolved": true,
        "details": {
          "function_name": "__kvm_set_dr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "865-892",
          "snippet": "static int __kvm_set_dr(struct kvm_vcpu *vcpu, int dr, unsigned long val)\n{\n\tswitch (dr) {\n\tcase 0 ... 3:\n\t\tvcpu->arch.db[dr] = val;\n\t\tif (!(vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP))\n\t\t\tvcpu->arch.eff_db[dr] = val;\n\t\tbreak;\n\tcase 4:\n\t\t/* fall through */\n\tcase 6:\n\t\tif (val & 0xffffffff00000000ULL)\n\t\t\treturn -1; /* #GP */\n\t\tvcpu->arch.dr6 = (val & DR6_VOLATILE) | kvm_dr6_fixed(vcpu);\n\t\tkvm_update_dr6(vcpu);\n\t\tbreak;\n\tcase 5:\n\t\t/* fall through */\n\tdefault: /* 7 */\n\t\tif (val & 0xffffffff00000000ULL)\n\t\t\treturn -1; /* #GP */\n\t\tvcpu->arch.dr7 = (val & DR7_VOLATILE) | DR7_FIXED_1;\n\t\tkvm_update_dr7(vcpu);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic int __kvm_set_dr(struct kvm_vcpu *vcpu, int dr, unsigned long val)\n{\n\tswitch (dr) {\n\tcase 0 ... 3:\n\t\tvcpu->arch.db[dr] = val;\n\t\tif (!(vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP))\n\t\t\tvcpu->arch.eff_db[dr] = val;\n\t\tbreak;\n\tcase 4:\n\t\t/* fall through */\n\tcase 6:\n\t\tif (val & 0xffffffff00000000ULL)\n\t\t\treturn -1; /* #GP */\n\t\tvcpu->arch.dr6 = (val & DR6_VOLATILE) | kvm_dr6_fixed(vcpu);\n\t\tkvm_update_dr6(vcpu);\n\t\tbreak;\n\tcase 5:\n\t\t/* fall through */\n\tdefault: /* 7 */\n\t\tif (val & 0xffffffff00000000ULL)\n\t\t\treturn -1; /* #GP */\n\t\tvcpu->arch.dr7 = (val & DR7_VOLATILE) | DR7_FIXED_1;\n\t\tkvm_update_dr7(vcpu);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_x86_ops->set_idt",
          "args": [
            "vcpu",
            "&dt"
          ],
          "line": 6342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_x86_ops->set_cr4",
          "args": [
            "vcpu",
            "0"
          ],
          "line": 6338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_x86_ops->set_cr0",
          "args": [
            "vcpu",
            "cr0"
          ],
          "line": 6335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_rip_write",
          "args": [
            "vcpu",
            "0x8000"
          ],
          "line": 6332
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_rip_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "32-35",
          "snippet": "static inline void kvm_rip_write(struct kvm_vcpu *vcpu, unsigned long val)\n{\n\tkvm_register_write(vcpu, VCPU_REGS_RIP, val);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void kvm_rip_write(struct kvm_vcpu *vcpu, unsigned long val)\n{\n\tkvm_register_write(vcpu, VCPU_REGS_RIP, val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_set_rflags",
          "args": [
            "vcpu",
            "X86_EFLAGS_FIXED"
          ],
          "line": 6331
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_set_rflags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "8182-8186",
          "snippet": "void kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags)\n{\n\t__kvm_set_rflags(vcpu, rflags);\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void __kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void __kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags);\n\nvoid kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags)\n{\n\t__kvm_set_rflags(vcpu, rflags);\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_x86_ops->set_nmi_mask",
          "args": [
            "vcpu",
            "true"
          ],
          "line": 6329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_x86_ops->get_nmi_mask",
          "args": [
            "vcpu"
          ],
          "line": 6326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_write_guest",
          "args": [
            "vcpu",
            "vcpu->arch.smbase + 0xfe00",
            "buf",
            "sizeof(buf)"
          ],
          "line": 6324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "process_smi_save_state_32",
          "args": [
            "vcpu",
            "buf"
          ],
          "line": 6322
        },
        "resolved": true,
        "details": {
          "function_name": "process_smi_save_state_32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "6197-6245",
          "snippet": "static void process_smi_save_state_32(struct kvm_vcpu *vcpu, char *buf)\n{\n\tstruct desc_ptr dt;\n\tstruct kvm_segment seg;\n\tunsigned long val;\n\tint i;\n\n\tput_smstate(u32, buf, 0x7ffc, kvm_read_cr0(vcpu));\n\tput_smstate(u32, buf, 0x7ff8, kvm_read_cr3(vcpu));\n\tput_smstate(u32, buf, 0x7ff4, kvm_get_rflags(vcpu));\n\tput_smstate(u32, buf, 0x7ff0, kvm_rip_read(vcpu));\n\n\tfor (i = 0; i < 8; i++)\n\t\tput_smstate(u32, buf, 0x7fd0 + i * 4, kvm_register_read(vcpu, i));\n\n\tkvm_get_dr(vcpu, 6, &val);\n\tput_smstate(u32, buf, 0x7fcc, (u32)val);\n\tkvm_get_dr(vcpu, 7, &val);\n\tput_smstate(u32, buf, 0x7fc8, (u32)val);\n\n\tkvm_get_segment(vcpu, &seg, VCPU_SREG_TR);\n\tput_smstate(u32, buf, 0x7fc4, seg.selector);\n\tput_smstate(u32, buf, 0x7f64, seg.base);\n\tput_smstate(u32, buf, 0x7f60, seg.limit);\n\tput_smstate(u32, buf, 0x7f5c, process_smi_get_segment_flags(&seg));\n\n\tkvm_get_segment(vcpu, &seg, VCPU_SREG_LDTR);\n\tput_smstate(u32, buf, 0x7fc0, seg.selector);\n\tput_smstate(u32, buf, 0x7f80, seg.base);\n\tput_smstate(u32, buf, 0x7f7c, seg.limit);\n\tput_smstate(u32, buf, 0x7f78, process_smi_get_segment_flags(&seg));\n\n\tkvm_x86_ops->get_gdt(vcpu, &dt);\n\tput_smstate(u32, buf, 0x7f74, dt.address);\n\tput_smstate(u32, buf, 0x7f70, dt.size);\n\n\tkvm_x86_ops->get_idt(vcpu, &dt);\n\tput_smstate(u32, buf, 0x7f58, dt.address);\n\tput_smstate(u32, buf, 0x7f54, dt.size);\n\n\tfor (i = 0; i < 6; i++)\n\t\tprocess_smi_save_seg_32(vcpu, buf, i);\n\n\tput_smstate(u32, buf, 0x7f14, kvm_read_cr4(vcpu));\n\n\t/* revision id */\n\tput_smstate(u32, buf, 0x7efc, 0x00020000);\n\tput_smstate(u32, buf, 0x7ef8, vcpu->arch.smbase);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "struct kvm_x86_ops *kvm_x86_ops"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nstatic void process_smi_save_state_32(struct kvm_vcpu *vcpu, char *buf)\n{\n\tstruct desc_ptr dt;\n\tstruct kvm_segment seg;\n\tunsigned long val;\n\tint i;\n\n\tput_smstate(u32, buf, 0x7ffc, kvm_read_cr0(vcpu));\n\tput_smstate(u32, buf, 0x7ff8, kvm_read_cr3(vcpu));\n\tput_smstate(u32, buf, 0x7ff4, kvm_get_rflags(vcpu));\n\tput_smstate(u32, buf, 0x7ff0, kvm_rip_read(vcpu));\n\n\tfor (i = 0; i < 8; i++)\n\t\tput_smstate(u32, buf, 0x7fd0 + i * 4, kvm_register_read(vcpu, i));\n\n\tkvm_get_dr(vcpu, 6, &val);\n\tput_smstate(u32, buf, 0x7fcc, (u32)val);\n\tkvm_get_dr(vcpu, 7, &val);\n\tput_smstate(u32, buf, 0x7fc8, (u32)val);\n\n\tkvm_get_segment(vcpu, &seg, VCPU_SREG_TR);\n\tput_smstate(u32, buf, 0x7fc4, seg.selector);\n\tput_smstate(u32, buf, 0x7f64, seg.base);\n\tput_smstate(u32, buf, 0x7f60, seg.limit);\n\tput_smstate(u32, buf, 0x7f5c, process_smi_get_segment_flags(&seg));\n\n\tkvm_get_segment(vcpu, &seg, VCPU_SREG_LDTR);\n\tput_smstate(u32, buf, 0x7fc0, seg.selector);\n\tput_smstate(u32, buf, 0x7f80, seg.base);\n\tput_smstate(u32, buf, 0x7f7c, seg.limit);\n\tput_smstate(u32, buf, 0x7f78, process_smi_get_segment_flags(&seg));\n\n\tkvm_x86_ops->get_gdt(vcpu, &dt);\n\tput_smstate(u32, buf, 0x7f74, dt.address);\n\tput_smstate(u32, buf, 0x7f70, dt.size);\n\n\tkvm_x86_ops->get_idt(vcpu, &dt);\n\tput_smstate(u32, buf, 0x7f58, dt.address);\n\tput_smstate(u32, buf, 0x7f54, dt.size);\n\n\tfor (i = 0; i < 6; i++)\n\t\tprocess_smi_save_seg_32(vcpu, buf, i);\n\n\tput_smstate(u32, buf, 0x7f14, kvm_read_cr4(vcpu));\n\n\t/* revision id */\n\tput_smstate(u32, buf, 0x7efc, 0x00020000);\n\tput_smstate(u32, buf, 0x7ef8, vcpu->arch.smbase);\n}"
        }
      },
      {
        "call_info": {
          "callee": "process_smi_save_state_64",
          "args": [
            "vcpu",
            "buf"
          ],
          "line": 6320
        },
        "resolved": true,
        "details": {
          "function_name": "process_smi_save_state_64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "6247-6302",
          "snippet": "static void process_smi_save_state_64(struct kvm_vcpu *vcpu, char *buf)\n{\n#ifdef CONFIG_X86_64\n\tstruct desc_ptr dt;\n\tstruct kvm_segment seg;\n\tunsigned long val;\n\tint i;\n\n\tfor (i = 0; i < 16; i++)\n\t\tput_smstate(u64, buf, 0x7ff8 - i * 8, kvm_register_read(vcpu, i));\n\n\tput_smstate(u64, buf, 0x7f78, kvm_rip_read(vcpu));\n\tput_smstate(u32, buf, 0x7f70, kvm_get_rflags(vcpu));\n\n\tkvm_get_dr(vcpu, 6, &val);\n\tput_smstate(u64, buf, 0x7f68, val);\n\tkvm_get_dr(vcpu, 7, &val);\n\tput_smstate(u64, buf, 0x7f60, val);\n\n\tput_smstate(u64, buf, 0x7f58, kvm_read_cr0(vcpu));\n\tput_smstate(u64, buf, 0x7f50, kvm_read_cr3(vcpu));\n\tput_smstate(u64, buf, 0x7f48, kvm_read_cr4(vcpu));\n\n\tput_smstate(u32, buf, 0x7f00, vcpu->arch.smbase);\n\n\t/* revision id */\n\tput_smstate(u32, buf, 0x7efc, 0x00020064);\n\n\tput_smstate(u64, buf, 0x7ed0, vcpu->arch.efer);\n\n\tkvm_get_segment(vcpu, &seg, VCPU_SREG_TR);\n\tput_smstate(u16, buf, 0x7e90, seg.selector);\n\tput_smstate(u16, buf, 0x7e92, process_smi_get_segment_flags(&seg) >> 8);\n\tput_smstate(u32, buf, 0x7e94, seg.limit);\n\tput_smstate(u64, buf, 0x7e98, seg.base);\n\n\tkvm_x86_ops->get_idt(vcpu, &dt);\n\tput_smstate(u32, buf, 0x7e84, dt.size);\n\tput_smstate(u64, buf, 0x7e88, dt.address);\n\n\tkvm_get_segment(vcpu, &seg, VCPU_SREG_LDTR);\n\tput_smstate(u16, buf, 0x7e70, seg.selector);\n\tput_smstate(u16, buf, 0x7e72, process_smi_get_segment_flags(&seg) >> 8);\n\tput_smstate(u32, buf, 0x7e74, seg.limit);\n\tput_smstate(u64, buf, 0x7e78, seg.base);\n\n\tkvm_x86_ops->get_gdt(vcpu, &dt);\n\tput_smstate(u32, buf, 0x7e64, dt.size);\n\tput_smstate(u64, buf, 0x7e68, dt.address);\n\n\tfor (i = 0; i < 6; i++)\n\t\tprocess_smi_save_seg_64(vcpu, buf, i);\n#else\n\tWARN_ON_ONCE(1);\n#endif\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "struct kvm_x86_ops *kvm_x86_ops"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nstatic void process_smi_save_state_64(struct kvm_vcpu *vcpu, char *buf)\n{\n#ifdef CONFIG_X86_64\n\tstruct desc_ptr dt;\n\tstruct kvm_segment seg;\n\tunsigned long val;\n\tint i;\n\n\tfor (i = 0; i < 16; i++)\n\t\tput_smstate(u64, buf, 0x7ff8 - i * 8, kvm_register_read(vcpu, i));\n\n\tput_smstate(u64, buf, 0x7f78, kvm_rip_read(vcpu));\n\tput_smstate(u32, buf, 0x7f70, kvm_get_rflags(vcpu));\n\n\tkvm_get_dr(vcpu, 6, &val);\n\tput_smstate(u64, buf, 0x7f68, val);\n\tkvm_get_dr(vcpu, 7, &val);\n\tput_smstate(u64, buf, 0x7f60, val);\n\n\tput_smstate(u64, buf, 0x7f58, kvm_read_cr0(vcpu));\n\tput_smstate(u64, buf, 0x7f50, kvm_read_cr3(vcpu));\n\tput_smstate(u64, buf, 0x7f48, kvm_read_cr4(vcpu));\n\n\tput_smstate(u32, buf, 0x7f00, vcpu->arch.smbase);\n\n\t/* revision id */\n\tput_smstate(u32, buf, 0x7efc, 0x00020064);\n\n\tput_smstate(u64, buf, 0x7ed0, vcpu->arch.efer);\n\n\tkvm_get_segment(vcpu, &seg, VCPU_SREG_TR);\n\tput_smstate(u16, buf, 0x7e90, seg.selector);\n\tput_smstate(u16, buf, 0x7e92, process_smi_get_segment_flags(&seg) >> 8);\n\tput_smstate(u32, buf, 0x7e94, seg.limit);\n\tput_smstate(u64, buf, 0x7e98, seg.base);\n\n\tkvm_x86_ops->get_idt(vcpu, &dt);\n\tput_smstate(u32, buf, 0x7e84, dt.size);\n\tput_smstate(u64, buf, 0x7e88, dt.address);\n\n\tkvm_get_segment(vcpu, &seg, VCPU_SREG_LDTR);\n\tput_smstate(u16, buf, 0x7e70, seg.selector);\n\tput_smstate(u16, buf, 0x7e72, process_smi_get_segment_flags(&seg) >> 8);\n\tput_smstate(u32, buf, 0x7e74, seg.limit);\n\tput_smstate(u64, buf, 0x7e78, seg.base);\n\n\tkvm_x86_ops->get_gdt(vcpu, &dt);\n\tput_smstate(u32, buf, 0x7e64, dt.size);\n\tput_smstate(u64, buf, 0x7e68, dt.address);\n\n\tfor (i = 0; i < 6; i++)\n\t\tprocess_smi_save_seg_64(vcpu, buf, i);\n#else\n\tWARN_ON_ONCE(1);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "buf",
            "0",
            "512"
          ],
          "line": 6318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_kvm_enter_smm",
          "args": [
            "vcpu->vcpu_id",
            "vcpu->arch.smbase",
            "true"
          ],
          "line": 6316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_smm",
          "args": [
            "vcpu"
          ],
          "line": 6311
        },
        "resolved": true,
        "details": {
          "function_name": "is_smm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "107-110",
          "snippet": "static inline bool is_smm(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.hflags & HF_SMM_MASK;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline bool is_smm(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.hflags & HF_SMM_MASK;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nstatic void process_smi(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_segment cs, ds;\n\tstruct desc_ptr dt;\n\tchar buf[512];\n\tu32 cr0;\n\n\tif (is_smm(vcpu)) {\n\t\tvcpu->arch.smi_pending = true;\n\t\treturn;\n\t}\n\n\ttrace_kvm_enter_smm(vcpu->vcpu_id, vcpu->arch.smbase, true);\n\tvcpu->arch.hflags |= HF_SMM_MASK;\n\tmemset(buf, 0, 512);\n\tif (guest_cpuid_has_longmode(vcpu))\n\t\tprocess_smi_save_state_64(vcpu, buf);\n\telse\n\t\tprocess_smi_save_state_32(vcpu, buf);\n\n\tkvm_vcpu_write_guest(vcpu, vcpu->arch.smbase + 0xfe00, buf, sizeof(buf));\n\n\tif (kvm_x86_ops->get_nmi_mask(vcpu))\n\t\tvcpu->arch.hflags |= HF_SMM_INSIDE_NMI_MASK;\n\telse\n\t\tkvm_x86_ops->set_nmi_mask(vcpu, true);\n\n\tkvm_set_rflags(vcpu, X86_EFLAGS_FIXED);\n\tkvm_rip_write(vcpu, 0x8000);\n\n\tcr0 = vcpu->arch.cr0 & ~(X86_CR0_PE | X86_CR0_EM | X86_CR0_TS | X86_CR0_PG);\n\tkvm_x86_ops->set_cr0(vcpu, cr0);\n\tvcpu->arch.cr0 = cr0;\n\n\tkvm_x86_ops->set_cr4(vcpu, 0);\n\n\t/* Undocumented: IDT limit is set to zero on entry to SMM.  */\n\tdt.address = dt.size = 0;\n\tkvm_x86_ops->set_idt(vcpu, &dt);\n\n\t__kvm_set_dr(vcpu, 7, DR7_FIXED_1);\n\n\tcs.selector = (vcpu->arch.smbase >> 4) & 0xffff;\n\tcs.base = vcpu->arch.smbase;\n\n\tds.selector = 0;\n\tds.base = 0;\n\n\tcs.limit    = ds.limit = 0xffffffff;\n\tcs.type     = ds.type = 0x3;\n\tcs.dpl      = ds.dpl = 0;\n\tcs.db       = ds.db = 0;\n\tcs.s        = ds.s = 1;\n\tcs.l        = ds.l = 0;\n\tcs.g        = ds.g = 1;\n\tcs.avl      = ds.avl = 0;\n\tcs.present  = ds.present = 1;\n\tcs.unusable = ds.unusable = 0;\n\tcs.padding  = ds.padding = 0;\n\n\tkvm_set_segment(vcpu, &cs, VCPU_SREG_CS);\n\tkvm_set_segment(vcpu, &ds, VCPU_SREG_DS);\n\tkvm_set_segment(vcpu, &ds, VCPU_SREG_ES);\n\tkvm_set_segment(vcpu, &ds, VCPU_SREG_FS);\n\tkvm_set_segment(vcpu, &ds, VCPU_SREG_GS);\n\tkvm_set_segment(vcpu, &ds, VCPU_SREG_SS);\n\n\tif (guest_cpuid_has_longmode(vcpu))\n\t\tkvm_x86_ops->set_efer(vcpu, 0);\n\n\tkvm_update_cpuid(vcpu);\n\tkvm_mmu_reset_context(vcpu);\n}"
  },
  {
    "function_name": "process_smi_save_state_64",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "6247-6302",
    "snippet": "static void process_smi_save_state_64(struct kvm_vcpu *vcpu, char *buf)\n{\n#ifdef CONFIG_X86_64\n\tstruct desc_ptr dt;\n\tstruct kvm_segment seg;\n\tunsigned long val;\n\tint i;\n\n\tfor (i = 0; i < 16; i++)\n\t\tput_smstate(u64, buf, 0x7ff8 - i * 8, kvm_register_read(vcpu, i));\n\n\tput_smstate(u64, buf, 0x7f78, kvm_rip_read(vcpu));\n\tput_smstate(u32, buf, 0x7f70, kvm_get_rflags(vcpu));\n\n\tkvm_get_dr(vcpu, 6, &val);\n\tput_smstate(u64, buf, 0x7f68, val);\n\tkvm_get_dr(vcpu, 7, &val);\n\tput_smstate(u64, buf, 0x7f60, val);\n\n\tput_smstate(u64, buf, 0x7f58, kvm_read_cr0(vcpu));\n\tput_smstate(u64, buf, 0x7f50, kvm_read_cr3(vcpu));\n\tput_smstate(u64, buf, 0x7f48, kvm_read_cr4(vcpu));\n\n\tput_smstate(u32, buf, 0x7f00, vcpu->arch.smbase);\n\n\t/* revision id */\n\tput_smstate(u32, buf, 0x7efc, 0x00020064);\n\n\tput_smstate(u64, buf, 0x7ed0, vcpu->arch.efer);\n\n\tkvm_get_segment(vcpu, &seg, VCPU_SREG_TR);\n\tput_smstate(u16, buf, 0x7e90, seg.selector);\n\tput_smstate(u16, buf, 0x7e92, process_smi_get_segment_flags(&seg) >> 8);\n\tput_smstate(u32, buf, 0x7e94, seg.limit);\n\tput_smstate(u64, buf, 0x7e98, seg.base);\n\n\tkvm_x86_ops->get_idt(vcpu, &dt);\n\tput_smstate(u32, buf, 0x7e84, dt.size);\n\tput_smstate(u64, buf, 0x7e88, dt.address);\n\n\tkvm_get_segment(vcpu, &seg, VCPU_SREG_LDTR);\n\tput_smstate(u16, buf, 0x7e70, seg.selector);\n\tput_smstate(u16, buf, 0x7e72, process_smi_get_segment_flags(&seg) >> 8);\n\tput_smstate(u32, buf, 0x7e74, seg.limit);\n\tput_smstate(u64, buf, 0x7e78, seg.base);\n\n\tkvm_x86_ops->get_gdt(vcpu, &dt);\n\tput_smstate(u32, buf, 0x7e64, dt.size);\n\tput_smstate(u64, buf, 0x7e68, dt.address);\n\n\tfor (i = 0; i < 6; i++)\n\t\tprocess_smi_save_seg_64(vcpu, buf, i);\n#else\n\tWARN_ON_ONCE(1);\n#endif\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);",
      "struct kvm_x86_ops *kvm_x86_ops"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "1"
          ],
          "line": 6300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "process_smi_save_seg_64",
          "args": [
            "vcpu",
            "buf",
            "i"
          ],
          "line": 6298
        },
        "resolved": true,
        "details": {
          "function_name": "process_smi_save_seg_64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "6180-6194",
          "snippet": "static void process_smi_save_seg_64(struct kvm_vcpu *vcpu, char *buf, int n)\n{\n\tstruct kvm_segment seg;\n\tint offset;\n\tu16 flags;\n\n\tkvm_get_segment(vcpu, &seg, n);\n\toffset = 0x7e00 + n * 16;\n\n\tflags = process_smi_get_segment_flags(&seg) >> 8;\n\tput_smstate(u16, buf, offset, seg.selector);\n\tput_smstate(u16, buf, offset + 2, flags);\n\tput_smstate(u32, buf, offset + 4, seg.limit);\n\tput_smstate(u64, buf, offset + 8, seg.base);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic void process_smi_save_seg_64(struct kvm_vcpu *vcpu, char *buf, int n)\n{\n\tstruct kvm_segment seg;\n\tint offset;\n\tu16 flags;\n\n\tkvm_get_segment(vcpu, &seg, n);\n\toffset = 0x7e00 + n * 16;\n\n\tflags = process_smi_get_segment_flags(&seg) >> 8;\n\tput_smstate(u16, buf, offset, seg.selector);\n\tput_smstate(u16, buf, offset + 2, flags);\n\tput_smstate(u32, buf, offset + 4, seg.limit);\n\tput_smstate(u64, buf, offset + 8, seg.base);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_smstate",
          "args": [
            "u64",
            "buf",
            "0x7e68",
            "dt.address"
          ],
          "line": 6295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_smstate",
          "args": [
            "u32",
            "buf",
            "0x7e64",
            "dt.size"
          ],
          "line": 6294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_x86_ops->get_gdt",
          "args": [
            "vcpu",
            "&dt"
          ],
          "line": 6293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_smstate",
          "args": [
            "u64",
            "buf",
            "0x7e78",
            "seg.base"
          ],
          "line": 6291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_smstate",
          "args": [
            "u32",
            "buf",
            "0x7e74",
            "seg.limit"
          ],
          "line": 6290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_smstate",
          "args": [
            "u16",
            "buf",
            "0x7e72",
            "process_smi_get_segment_flags(&seg) >> 8"
          ],
          "line": 6289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "process_smi_get_segment_flags",
          "args": [
            "&seg"
          ],
          "line": 6289
        },
        "resolved": true,
        "details": {
          "function_name": "process_smi_get_segment_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "6147-6159",
          "snippet": "static u32 process_smi_get_segment_flags(struct kvm_segment *seg)\n{\n\tu32 flags = 0;\n\tflags |= seg->g       << 23;\n\tflags |= seg->db      << 22;\n\tflags |= seg->l       << 21;\n\tflags |= seg->avl     << 20;\n\tflags |= seg->present << 15;\n\tflags |= seg->dpl     << 13;\n\tflags |= seg->s       << 12;\n\tflags |= seg->type    << 8;\n\treturn flags;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic u32 process_smi_get_segment_flags(struct kvm_segment *seg)\n{\n\tu32 flags = 0;\n\tflags |= seg->g       << 23;\n\tflags |= seg->db      << 22;\n\tflags |= seg->l       << 21;\n\tflags |= seg->avl     << 20;\n\tflags |= seg->present << 15;\n\tflags |= seg->dpl     << 13;\n\tflags |= seg->s       << 12;\n\tflags |= seg->type    << 8;\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_smstate",
          "args": [
            "u16",
            "buf",
            "0x7e70",
            "seg.selector"
          ],
          "line": 6288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_get_segment",
          "args": [
            "vcpu",
            "&seg",
            "VCPU_SREG_LDTR"
          ],
          "line": 6287
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_get_segment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "4157-4161",
          "snippet": "void kvm_get_segment(struct kvm_vcpu *vcpu,\n\t\t     struct kvm_segment *var, int seg)\n{\n\tkvm_x86_ops->get_segment(vcpu, var, seg);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "struct kvm_x86_ops *kvm_x86_ops"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nvoid kvm_get_segment(struct kvm_vcpu *vcpu,\n\t\t     struct kvm_segment *var, int seg)\n{\n\tkvm_x86_ops->get_segment(vcpu, var, seg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_smstate",
          "args": [
            "u64",
            "buf",
            "0x7e88",
            "dt.address"
          ],
          "line": 6285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_smstate",
          "args": [
            "u32",
            "buf",
            "0x7e84",
            "dt.size"
          ],
          "line": 6284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_x86_ops->get_idt",
          "args": [
            "vcpu",
            "&dt"
          ],
          "line": 6283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_smstate",
          "args": [
            "u64",
            "buf",
            "0x7e98",
            "seg.base"
          ],
          "line": 6281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_smstate",
          "args": [
            "u32",
            "buf",
            "0x7e94",
            "seg.limit"
          ],
          "line": 6280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_smstate",
          "args": [
            "u16",
            "buf",
            "0x7e92",
            "process_smi_get_segment_flags(&seg) >> 8"
          ],
          "line": 6279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_smstate",
          "args": [
            "u16",
            "buf",
            "0x7e90",
            "seg.selector"
          ],
          "line": 6278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_smstate",
          "args": [
            "u64",
            "buf",
            "0x7ed0",
            "vcpu->arch.efer"
          ],
          "line": 6275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_smstate",
          "args": [
            "u32",
            "buf",
            "0x7efc",
            "0x00020064"
          ],
          "line": 6273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_smstate",
          "args": [
            "u32",
            "buf",
            "0x7f00",
            "vcpu->arch.smbase"
          ],
          "line": 6270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_smstate",
          "args": [
            "u64",
            "buf",
            "0x7f48",
            "kvm_read_cr4(vcpu)"
          ],
          "line": 6268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_read_cr4",
          "args": [
            "vcpu"
          ],
          "line": 6268
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_read_cr4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "76-79",
          "snippet": "static inline ulong kvm_read_cr4(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_read_cr4_bits(vcpu, ~0UL);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline ulong kvm_read_cr4(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_read_cr4_bits(vcpu, ~0UL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_smstate",
          "args": [
            "u64",
            "buf",
            "0x7f50",
            "kvm_read_cr3(vcpu)"
          ],
          "line": 6267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_read_cr3",
          "args": [
            "vcpu"
          ],
          "line": 6267
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_read_cr3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "69-74",
          "snippet": "static inline ulong kvm_read_cr3(struct kvm_vcpu *vcpu)\n{\n\tif (!test_bit(VCPU_EXREG_CR3, (ulong *)&vcpu->arch.regs_avail))\n\t\tkvm_x86_ops->decache_cr3(vcpu);\n\treturn vcpu->arch.cr3;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline ulong kvm_read_cr3(struct kvm_vcpu *vcpu)\n{\n\tif (!test_bit(VCPU_EXREG_CR3, (ulong *)&vcpu->arch.regs_avail))\n\t\tkvm_x86_ops->decache_cr3(vcpu);\n\treturn vcpu->arch.cr3;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_smstate",
          "args": [
            "u64",
            "buf",
            "0x7f58",
            "kvm_read_cr0(vcpu)"
          ],
          "line": 6266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_read_cr0",
          "args": [
            "vcpu"
          ],
          "line": 6266
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_read_cr0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "56-59",
          "snippet": "static inline ulong kvm_read_cr0(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_read_cr0_bits(vcpu, ~0UL);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline ulong kvm_read_cr0(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_read_cr0_bits(vcpu, ~0UL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_smstate",
          "args": [
            "u64",
            "buf",
            "0x7f60",
            "val"
          ],
          "line": 6264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_get_dr",
          "args": [
            "vcpu",
            "7",
            "&val"
          ],
          "line": 6263
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_get_dr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "904-925",
          "snippet": "int kvm_get_dr(struct kvm_vcpu *vcpu, int dr, unsigned long *val)\n{\n\tswitch (dr) {\n\tcase 0 ... 3:\n\t\t*val = vcpu->arch.db[dr];\n\t\tbreak;\n\tcase 4:\n\t\t/* fall through */\n\tcase 6:\n\t\tif (vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP)\n\t\t\t*val = vcpu->arch.dr6;\n\t\telse\n\t\t\t*val = kvm_x86_ops->get_dr6(vcpu);\n\t\tbreak;\n\tcase 5:\n\t\t/* fall through */\n\tdefault: /* 7 */\n\t\t*val = vcpu->arch.dr7;\n\t\tbreak;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "struct kvm_x86_ops *kvm_x86_ops"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nint kvm_get_dr(struct kvm_vcpu *vcpu, int dr, unsigned long *val)\n{\n\tswitch (dr) {\n\tcase 0 ... 3:\n\t\t*val = vcpu->arch.db[dr];\n\t\tbreak;\n\tcase 4:\n\t\t/* fall through */\n\tcase 6:\n\t\tif (vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP)\n\t\t\t*val = vcpu->arch.dr6;\n\t\telse\n\t\t\t*val = kvm_x86_ops->get_dr6(vcpu);\n\t\tbreak;\n\tcase 5:\n\t\t/* fall through */\n\tdefault: /* 7 */\n\t\t*val = vcpu->arch.dr7;\n\t\tbreak;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_smstate",
          "args": [
            "u64",
            "buf",
            "0x7f68",
            "val"
          ],
          "line": 6262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_smstate",
          "args": [
            "u32",
            "buf",
            "0x7f70",
            "kvm_get_rflags(vcpu)"
          ],
          "line": 6259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_get_rflags",
          "args": [
            "vcpu"
          ],
          "line": 6259
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_get_rflags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "8163-8171",
          "snippet": "unsigned long kvm_get_rflags(struct kvm_vcpu *vcpu)\n{\n\tunsigned long rflags;\n\n\trflags = kvm_x86_ops->get_rflags(vcpu);\n\tif (vcpu->guest_debug & KVM_GUESTDBG_SINGLESTEP)\n\t\trflags &= ~X86_EFLAGS_TF;\n\treturn rflags;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void __kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags);",
            "struct kvm_x86_ops *kvm_x86_ops"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void __kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nunsigned long kvm_get_rflags(struct kvm_vcpu *vcpu)\n{\n\tunsigned long rflags;\n\n\trflags = kvm_x86_ops->get_rflags(vcpu);\n\tif (vcpu->guest_debug & KVM_GUESTDBG_SINGLESTEP)\n\t\trflags &= ~X86_EFLAGS_TF;\n\treturn rflags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_smstate",
          "args": [
            "u64",
            "buf",
            "0x7f78",
            "kvm_rip_read(vcpu)"
          ],
          "line": 6258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_rip_read",
          "args": [
            "vcpu"
          ],
          "line": 6258
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_rip_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "27-30",
          "snippet": "static inline unsigned long kvm_rip_read(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_register_read(vcpu, VCPU_REGS_RIP);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline unsigned long kvm_rip_read(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_register_read(vcpu, VCPU_REGS_RIP);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_smstate",
          "args": [
            "u64",
            "buf",
            "0x7ff8 - i * 8",
            "kvm_register_read(vcpu, i)"
          ],
          "line": 6256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_register_read",
          "args": [
            "vcpu",
            "i"
          ],
          "line": 6256
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_register_readl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.h",
          "lines": "133-139",
          "snippet": "static inline unsigned long kvm_register_readl(struct kvm_vcpu *vcpu,\n\t\t\t\t\t       enum kvm_reg reg)\n{\n\tunsigned long val = kvm_register_read(vcpu, reg);\n\n\treturn is_64_bit_mode(vcpu) ? val : (u32)val;\n}",
          "includes": [
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline unsigned long kvm_register_readl(struct kvm_vcpu *vcpu,\n\t\t\t\t\t       enum kvm_reg reg)\n{\n\tunsigned long val = kvm_register_read(vcpu, reg);\n\n\treturn is_64_bit_mode(vcpu) ? val : (u32)val;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nstatic void process_smi_save_state_64(struct kvm_vcpu *vcpu, char *buf)\n{\n#ifdef CONFIG_X86_64\n\tstruct desc_ptr dt;\n\tstruct kvm_segment seg;\n\tunsigned long val;\n\tint i;\n\n\tfor (i = 0; i < 16; i++)\n\t\tput_smstate(u64, buf, 0x7ff8 - i * 8, kvm_register_read(vcpu, i));\n\n\tput_smstate(u64, buf, 0x7f78, kvm_rip_read(vcpu));\n\tput_smstate(u32, buf, 0x7f70, kvm_get_rflags(vcpu));\n\n\tkvm_get_dr(vcpu, 6, &val);\n\tput_smstate(u64, buf, 0x7f68, val);\n\tkvm_get_dr(vcpu, 7, &val);\n\tput_smstate(u64, buf, 0x7f60, val);\n\n\tput_smstate(u64, buf, 0x7f58, kvm_read_cr0(vcpu));\n\tput_smstate(u64, buf, 0x7f50, kvm_read_cr3(vcpu));\n\tput_smstate(u64, buf, 0x7f48, kvm_read_cr4(vcpu));\n\n\tput_smstate(u32, buf, 0x7f00, vcpu->arch.smbase);\n\n\t/* revision id */\n\tput_smstate(u32, buf, 0x7efc, 0x00020064);\n\n\tput_smstate(u64, buf, 0x7ed0, vcpu->arch.efer);\n\n\tkvm_get_segment(vcpu, &seg, VCPU_SREG_TR);\n\tput_smstate(u16, buf, 0x7e90, seg.selector);\n\tput_smstate(u16, buf, 0x7e92, process_smi_get_segment_flags(&seg) >> 8);\n\tput_smstate(u32, buf, 0x7e94, seg.limit);\n\tput_smstate(u64, buf, 0x7e98, seg.base);\n\n\tkvm_x86_ops->get_idt(vcpu, &dt);\n\tput_smstate(u32, buf, 0x7e84, dt.size);\n\tput_smstate(u64, buf, 0x7e88, dt.address);\n\n\tkvm_get_segment(vcpu, &seg, VCPU_SREG_LDTR);\n\tput_smstate(u16, buf, 0x7e70, seg.selector);\n\tput_smstate(u16, buf, 0x7e72, process_smi_get_segment_flags(&seg) >> 8);\n\tput_smstate(u32, buf, 0x7e74, seg.limit);\n\tput_smstate(u64, buf, 0x7e78, seg.base);\n\n\tkvm_x86_ops->get_gdt(vcpu, &dt);\n\tput_smstate(u32, buf, 0x7e64, dt.size);\n\tput_smstate(u64, buf, 0x7e68, dt.address);\n\n\tfor (i = 0; i < 6; i++)\n\t\tprocess_smi_save_seg_64(vcpu, buf, i);\n#else\n\tWARN_ON_ONCE(1);\n#endif\n}"
  },
  {
    "function_name": "process_smi_save_state_32",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "6197-6245",
    "snippet": "static void process_smi_save_state_32(struct kvm_vcpu *vcpu, char *buf)\n{\n\tstruct desc_ptr dt;\n\tstruct kvm_segment seg;\n\tunsigned long val;\n\tint i;\n\n\tput_smstate(u32, buf, 0x7ffc, kvm_read_cr0(vcpu));\n\tput_smstate(u32, buf, 0x7ff8, kvm_read_cr3(vcpu));\n\tput_smstate(u32, buf, 0x7ff4, kvm_get_rflags(vcpu));\n\tput_smstate(u32, buf, 0x7ff0, kvm_rip_read(vcpu));\n\n\tfor (i = 0; i < 8; i++)\n\t\tput_smstate(u32, buf, 0x7fd0 + i * 4, kvm_register_read(vcpu, i));\n\n\tkvm_get_dr(vcpu, 6, &val);\n\tput_smstate(u32, buf, 0x7fcc, (u32)val);\n\tkvm_get_dr(vcpu, 7, &val);\n\tput_smstate(u32, buf, 0x7fc8, (u32)val);\n\n\tkvm_get_segment(vcpu, &seg, VCPU_SREG_TR);\n\tput_smstate(u32, buf, 0x7fc4, seg.selector);\n\tput_smstate(u32, buf, 0x7f64, seg.base);\n\tput_smstate(u32, buf, 0x7f60, seg.limit);\n\tput_smstate(u32, buf, 0x7f5c, process_smi_get_segment_flags(&seg));\n\n\tkvm_get_segment(vcpu, &seg, VCPU_SREG_LDTR);\n\tput_smstate(u32, buf, 0x7fc0, seg.selector);\n\tput_smstate(u32, buf, 0x7f80, seg.base);\n\tput_smstate(u32, buf, 0x7f7c, seg.limit);\n\tput_smstate(u32, buf, 0x7f78, process_smi_get_segment_flags(&seg));\n\n\tkvm_x86_ops->get_gdt(vcpu, &dt);\n\tput_smstate(u32, buf, 0x7f74, dt.address);\n\tput_smstate(u32, buf, 0x7f70, dt.size);\n\n\tkvm_x86_ops->get_idt(vcpu, &dt);\n\tput_smstate(u32, buf, 0x7f58, dt.address);\n\tput_smstate(u32, buf, 0x7f54, dt.size);\n\n\tfor (i = 0; i < 6; i++)\n\t\tprocess_smi_save_seg_32(vcpu, buf, i);\n\n\tput_smstate(u32, buf, 0x7f14, kvm_read_cr4(vcpu));\n\n\t/* revision id */\n\tput_smstate(u32, buf, 0x7efc, 0x00020000);\n\tput_smstate(u32, buf, 0x7ef8, vcpu->arch.smbase);\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);",
      "struct kvm_x86_ops *kvm_x86_ops"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_smstate",
          "args": [
            "u32",
            "buf",
            "0x7ef8",
            "vcpu->arch.smbase"
          ],
          "line": 6244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_smstate",
          "args": [
            "u32",
            "buf",
            "0x7efc",
            "0x00020000"
          ],
          "line": 6243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_smstate",
          "args": [
            "u32",
            "buf",
            "0x7f14",
            "kvm_read_cr4(vcpu)"
          ],
          "line": 6240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_read_cr4",
          "args": [
            "vcpu"
          ],
          "line": 6240
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_read_cr4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "76-79",
          "snippet": "static inline ulong kvm_read_cr4(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_read_cr4_bits(vcpu, ~0UL);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline ulong kvm_read_cr4(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_read_cr4_bits(vcpu, ~0UL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "process_smi_save_seg_32",
          "args": [
            "vcpu",
            "buf",
            "i"
          ],
          "line": 6238
        },
        "resolved": true,
        "details": {
          "function_name": "process_smi_save_seg_32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "6161-6177",
          "snippet": "static void process_smi_save_seg_32(struct kvm_vcpu *vcpu, char *buf, int n)\n{\n\tstruct kvm_segment seg;\n\tint offset;\n\n\tkvm_get_segment(vcpu, &seg, n);\n\tput_smstate(u32, buf, 0x7fa8 + n * 4, seg.selector);\n\n\tif (n < 3)\n\t\toffset = 0x7f84 + n * 12;\n\telse\n\t\toffset = 0x7f2c + (n - 3) * 12;\n\n\tput_smstate(u32, buf, offset + 8, seg.base);\n\tput_smstate(u32, buf, offset + 4, seg.limit);\n\tput_smstate(u32, buf, offset, process_smi_get_segment_flags(&seg));\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic void process_smi_save_seg_32(struct kvm_vcpu *vcpu, char *buf, int n)\n{\n\tstruct kvm_segment seg;\n\tint offset;\n\n\tkvm_get_segment(vcpu, &seg, n);\n\tput_smstate(u32, buf, 0x7fa8 + n * 4, seg.selector);\n\n\tif (n < 3)\n\t\toffset = 0x7f84 + n * 12;\n\telse\n\t\toffset = 0x7f2c + (n - 3) * 12;\n\n\tput_smstate(u32, buf, offset + 8, seg.base);\n\tput_smstate(u32, buf, offset + 4, seg.limit);\n\tput_smstate(u32, buf, offset, process_smi_get_segment_flags(&seg));\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_smstate",
          "args": [
            "u32",
            "buf",
            "0x7f54",
            "dt.size"
          ],
          "line": 6235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_smstate",
          "args": [
            "u32",
            "buf",
            "0x7f58",
            "dt.address"
          ],
          "line": 6234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_x86_ops->get_idt",
          "args": [
            "vcpu",
            "&dt"
          ],
          "line": 6233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_smstate",
          "args": [
            "u32",
            "buf",
            "0x7f70",
            "dt.size"
          ],
          "line": 6231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_smstate",
          "args": [
            "u32",
            "buf",
            "0x7f74",
            "dt.address"
          ],
          "line": 6230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_x86_ops->get_gdt",
          "args": [
            "vcpu",
            "&dt"
          ],
          "line": 6229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_smstate",
          "args": [
            "u32",
            "buf",
            "0x7f78",
            "process_smi_get_segment_flags(&seg)"
          ],
          "line": 6227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "process_smi_get_segment_flags",
          "args": [
            "&seg"
          ],
          "line": 6227
        },
        "resolved": true,
        "details": {
          "function_name": "process_smi_get_segment_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "6147-6159",
          "snippet": "static u32 process_smi_get_segment_flags(struct kvm_segment *seg)\n{\n\tu32 flags = 0;\n\tflags |= seg->g       << 23;\n\tflags |= seg->db      << 22;\n\tflags |= seg->l       << 21;\n\tflags |= seg->avl     << 20;\n\tflags |= seg->present << 15;\n\tflags |= seg->dpl     << 13;\n\tflags |= seg->s       << 12;\n\tflags |= seg->type    << 8;\n\treturn flags;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic u32 process_smi_get_segment_flags(struct kvm_segment *seg)\n{\n\tu32 flags = 0;\n\tflags |= seg->g       << 23;\n\tflags |= seg->db      << 22;\n\tflags |= seg->l       << 21;\n\tflags |= seg->avl     << 20;\n\tflags |= seg->present << 15;\n\tflags |= seg->dpl     << 13;\n\tflags |= seg->s       << 12;\n\tflags |= seg->type    << 8;\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_smstate",
          "args": [
            "u32",
            "buf",
            "0x7f7c",
            "seg.limit"
          ],
          "line": 6226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_smstate",
          "args": [
            "u32",
            "buf",
            "0x7f80",
            "seg.base"
          ],
          "line": 6225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_smstate",
          "args": [
            "u32",
            "buf",
            "0x7fc0",
            "seg.selector"
          ],
          "line": 6224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_get_segment",
          "args": [
            "vcpu",
            "&seg",
            "VCPU_SREG_LDTR"
          ],
          "line": 6223
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_get_segment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "4157-4161",
          "snippet": "void kvm_get_segment(struct kvm_vcpu *vcpu,\n\t\t     struct kvm_segment *var, int seg)\n{\n\tkvm_x86_ops->get_segment(vcpu, var, seg);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "struct kvm_x86_ops *kvm_x86_ops"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nvoid kvm_get_segment(struct kvm_vcpu *vcpu,\n\t\t     struct kvm_segment *var, int seg)\n{\n\tkvm_x86_ops->get_segment(vcpu, var, seg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_smstate",
          "args": [
            "u32",
            "buf",
            "0x7f5c",
            "process_smi_get_segment_flags(&seg)"
          ],
          "line": 6221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_smstate",
          "args": [
            "u32",
            "buf",
            "0x7f60",
            "seg.limit"
          ],
          "line": 6220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_smstate",
          "args": [
            "u32",
            "buf",
            "0x7f64",
            "seg.base"
          ],
          "line": 6219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_smstate",
          "args": [
            "u32",
            "buf",
            "0x7fc4",
            "seg.selector"
          ],
          "line": 6218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_smstate",
          "args": [
            "u32",
            "buf",
            "0x7fc8",
            "(u32)val"
          ],
          "line": 6215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_get_dr",
          "args": [
            "vcpu",
            "7",
            "&val"
          ],
          "line": 6214
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_get_dr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "904-925",
          "snippet": "int kvm_get_dr(struct kvm_vcpu *vcpu, int dr, unsigned long *val)\n{\n\tswitch (dr) {\n\tcase 0 ... 3:\n\t\t*val = vcpu->arch.db[dr];\n\t\tbreak;\n\tcase 4:\n\t\t/* fall through */\n\tcase 6:\n\t\tif (vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP)\n\t\t\t*val = vcpu->arch.dr6;\n\t\telse\n\t\t\t*val = kvm_x86_ops->get_dr6(vcpu);\n\t\tbreak;\n\tcase 5:\n\t\t/* fall through */\n\tdefault: /* 7 */\n\t\t*val = vcpu->arch.dr7;\n\t\tbreak;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "struct kvm_x86_ops *kvm_x86_ops"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nint kvm_get_dr(struct kvm_vcpu *vcpu, int dr, unsigned long *val)\n{\n\tswitch (dr) {\n\tcase 0 ... 3:\n\t\t*val = vcpu->arch.db[dr];\n\t\tbreak;\n\tcase 4:\n\t\t/* fall through */\n\tcase 6:\n\t\tif (vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP)\n\t\t\t*val = vcpu->arch.dr6;\n\t\telse\n\t\t\t*val = kvm_x86_ops->get_dr6(vcpu);\n\t\tbreak;\n\tcase 5:\n\t\t/* fall through */\n\tdefault: /* 7 */\n\t\t*val = vcpu->arch.dr7;\n\t\tbreak;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_smstate",
          "args": [
            "u32",
            "buf",
            "0x7fcc",
            "(u32)val"
          ],
          "line": 6213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_smstate",
          "args": [
            "u32",
            "buf",
            "0x7fd0 + i * 4",
            "kvm_register_read(vcpu, i)"
          ],
          "line": 6210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_register_read",
          "args": [
            "vcpu",
            "i"
          ],
          "line": 6210
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_register_readl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.h",
          "lines": "133-139",
          "snippet": "static inline unsigned long kvm_register_readl(struct kvm_vcpu *vcpu,\n\t\t\t\t\t       enum kvm_reg reg)\n{\n\tunsigned long val = kvm_register_read(vcpu, reg);\n\n\treturn is_64_bit_mode(vcpu) ? val : (u32)val;\n}",
          "includes": [
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline unsigned long kvm_register_readl(struct kvm_vcpu *vcpu,\n\t\t\t\t\t       enum kvm_reg reg)\n{\n\tunsigned long val = kvm_register_read(vcpu, reg);\n\n\treturn is_64_bit_mode(vcpu) ? val : (u32)val;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_smstate",
          "args": [
            "u32",
            "buf",
            "0x7ff0",
            "kvm_rip_read(vcpu)"
          ],
          "line": 6207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_rip_read",
          "args": [
            "vcpu"
          ],
          "line": 6207
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_rip_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "27-30",
          "snippet": "static inline unsigned long kvm_rip_read(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_register_read(vcpu, VCPU_REGS_RIP);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline unsigned long kvm_rip_read(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_register_read(vcpu, VCPU_REGS_RIP);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_smstate",
          "args": [
            "u32",
            "buf",
            "0x7ff4",
            "kvm_get_rflags(vcpu)"
          ],
          "line": 6206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_get_rflags",
          "args": [
            "vcpu"
          ],
          "line": 6206
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_get_rflags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "8163-8171",
          "snippet": "unsigned long kvm_get_rflags(struct kvm_vcpu *vcpu)\n{\n\tunsigned long rflags;\n\n\trflags = kvm_x86_ops->get_rflags(vcpu);\n\tif (vcpu->guest_debug & KVM_GUESTDBG_SINGLESTEP)\n\t\trflags &= ~X86_EFLAGS_TF;\n\treturn rflags;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void __kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags);",
            "struct kvm_x86_ops *kvm_x86_ops"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void __kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nunsigned long kvm_get_rflags(struct kvm_vcpu *vcpu)\n{\n\tunsigned long rflags;\n\n\trflags = kvm_x86_ops->get_rflags(vcpu);\n\tif (vcpu->guest_debug & KVM_GUESTDBG_SINGLESTEP)\n\t\trflags &= ~X86_EFLAGS_TF;\n\treturn rflags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_smstate",
          "args": [
            "u32",
            "buf",
            "0x7ff8",
            "kvm_read_cr3(vcpu)"
          ],
          "line": 6205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_read_cr3",
          "args": [
            "vcpu"
          ],
          "line": 6205
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_read_cr3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "69-74",
          "snippet": "static inline ulong kvm_read_cr3(struct kvm_vcpu *vcpu)\n{\n\tif (!test_bit(VCPU_EXREG_CR3, (ulong *)&vcpu->arch.regs_avail))\n\t\tkvm_x86_ops->decache_cr3(vcpu);\n\treturn vcpu->arch.cr3;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline ulong kvm_read_cr3(struct kvm_vcpu *vcpu)\n{\n\tif (!test_bit(VCPU_EXREG_CR3, (ulong *)&vcpu->arch.regs_avail))\n\t\tkvm_x86_ops->decache_cr3(vcpu);\n\treturn vcpu->arch.cr3;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_smstate",
          "args": [
            "u32",
            "buf",
            "0x7ffc",
            "kvm_read_cr0(vcpu)"
          ],
          "line": 6204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_read_cr0",
          "args": [
            "vcpu"
          ],
          "line": 6204
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_read_cr0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "56-59",
          "snippet": "static inline ulong kvm_read_cr0(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_read_cr0_bits(vcpu, ~0UL);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline ulong kvm_read_cr0(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_read_cr0_bits(vcpu, ~0UL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nstatic void process_smi_save_state_32(struct kvm_vcpu *vcpu, char *buf)\n{\n\tstruct desc_ptr dt;\n\tstruct kvm_segment seg;\n\tunsigned long val;\n\tint i;\n\n\tput_smstate(u32, buf, 0x7ffc, kvm_read_cr0(vcpu));\n\tput_smstate(u32, buf, 0x7ff8, kvm_read_cr3(vcpu));\n\tput_smstate(u32, buf, 0x7ff4, kvm_get_rflags(vcpu));\n\tput_smstate(u32, buf, 0x7ff0, kvm_rip_read(vcpu));\n\n\tfor (i = 0; i < 8; i++)\n\t\tput_smstate(u32, buf, 0x7fd0 + i * 4, kvm_register_read(vcpu, i));\n\n\tkvm_get_dr(vcpu, 6, &val);\n\tput_smstate(u32, buf, 0x7fcc, (u32)val);\n\tkvm_get_dr(vcpu, 7, &val);\n\tput_smstate(u32, buf, 0x7fc8, (u32)val);\n\n\tkvm_get_segment(vcpu, &seg, VCPU_SREG_TR);\n\tput_smstate(u32, buf, 0x7fc4, seg.selector);\n\tput_smstate(u32, buf, 0x7f64, seg.base);\n\tput_smstate(u32, buf, 0x7f60, seg.limit);\n\tput_smstate(u32, buf, 0x7f5c, process_smi_get_segment_flags(&seg));\n\n\tkvm_get_segment(vcpu, &seg, VCPU_SREG_LDTR);\n\tput_smstate(u32, buf, 0x7fc0, seg.selector);\n\tput_smstate(u32, buf, 0x7f80, seg.base);\n\tput_smstate(u32, buf, 0x7f7c, seg.limit);\n\tput_smstate(u32, buf, 0x7f78, process_smi_get_segment_flags(&seg));\n\n\tkvm_x86_ops->get_gdt(vcpu, &dt);\n\tput_smstate(u32, buf, 0x7f74, dt.address);\n\tput_smstate(u32, buf, 0x7f70, dt.size);\n\n\tkvm_x86_ops->get_idt(vcpu, &dt);\n\tput_smstate(u32, buf, 0x7f58, dt.address);\n\tput_smstate(u32, buf, 0x7f54, dt.size);\n\n\tfor (i = 0; i < 6; i++)\n\t\tprocess_smi_save_seg_32(vcpu, buf, i);\n\n\tput_smstate(u32, buf, 0x7f14, kvm_read_cr4(vcpu));\n\n\t/* revision id */\n\tput_smstate(u32, buf, 0x7efc, 0x00020000);\n\tput_smstate(u32, buf, 0x7ef8, vcpu->arch.smbase);\n}"
  },
  {
    "function_name": "process_smi_save_seg_64",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "6180-6194",
    "snippet": "static void process_smi_save_seg_64(struct kvm_vcpu *vcpu, char *buf, int n)\n{\n\tstruct kvm_segment seg;\n\tint offset;\n\tu16 flags;\n\n\tkvm_get_segment(vcpu, &seg, n);\n\toffset = 0x7e00 + n * 16;\n\n\tflags = process_smi_get_segment_flags(&seg) >> 8;\n\tput_smstate(u16, buf, offset, seg.selector);\n\tput_smstate(u16, buf, offset + 2, flags);\n\tput_smstate(u32, buf, offset + 4, seg.limit);\n\tput_smstate(u64, buf, offset + 8, seg.base);\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_smstate",
          "args": [
            "u64",
            "buf",
            "offset + 8",
            "seg.base"
          ],
          "line": 6193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_smstate",
          "args": [
            "u32",
            "buf",
            "offset + 4",
            "seg.limit"
          ],
          "line": 6192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_smstate",
          "args": [
            "u16",
            "buf",
            "offset + 2",
            "flags"
          ],
          "line": 6191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_smstate",
          "args": [
            "u16",
            "buf",
            "offset",
            "seg.selector"
          ],
          "line": 6190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "process_smi_get_segment_flags",
          "args": [
            "&seg"
          ],
          "line": 6189
        },
        "resolved": true,
        "details": {
          "function_name": "process_smi_get_segment_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "6147-6159",
          "snippet": "static u32 process_smi_get_segment_flags(struct kvm_segment *seg)\n{\n\tu32 flags = 0;\n\tflags |= seg->g       << 23;\n\tflags |= seg->db      << 22;\n\tflags |= seg->l       << 21;\n\tflags |= seg->avl     << 20;\n\tflags |= seg->present << 15;\n\tflags |= seg->dpl     << 13;\n\tflags |= seg->s       << 12;\n\tflags |= seg->type    << 8;\n\treturn flags;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic u32 process_smi_get_segment_flags(struct kvm_segment *seg)\n{\n\tu32 flags = 0;\n\tflags |= seg->g       << 23;\n\tflags |= seg->db      << 22;\n\tflags |= seg->l       << 21;\n\tflags |= seg->avl     << 20;\n\tflags |= seg->present << 15;\n\tflags |= seg->dpl     << 13;\n\tflags |= seg->s       << 12;\n\tflags |= seg->type    << 8;\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_get_segment",
          "args": [
            "vcpu",
            "&seg",
            "n"
          ],
          "line": 6186
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_get_segment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "4157-4161",
          "snippet": "void kvm_get_segment(struct kvm_vcpu *vcpu,\n\t\t     struct kvm_segment *var, int seg)\n{\n\tkvm_x86_ops->get_segment(vcpu, var, seg);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "struct kvm_x86_ops *kvm_x86_ops"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nvoid kvm_get_segment(struct kvm_vcpu *vcpu,\n\t\t     struct kvm_segment *var, int seg)\n{\n\tkvm_x86_ops->get_segment(vcpu, var, seg);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic void process_smi_save_seg_64(struct kvm_vcpu *vcpu, char *buf, int n)\n{\n\tstruct kvm_segment seg;\n\tint offset;\n\tu16 flags;\n\n\tkvm_get_segment(vcpu, &seg, n);\n\toffset = 0x7e00 + n * 16;\n\n\tflags = process_smi_get_segment_flags(&seg) >> 8;\n\tput_smstate(u16, buf, offset, seg.selector);\n\tput_smstate(u16, buf, offset + 2, flags);\n\tput_smstate(u32, buf, offset + 4, seg.limit);\n\tput_smstate(u64, buf, offset + 8, seg.base);\n}"
  },
  {
    "function_name": "process_smi_save_seg_32",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "6161-6177",
    "snippet": "static void process_smi_save_seg_32(struct kvm_vcpu *vcpu, char *buf, int n)\n{\n\tstruct kvm_segment seg;\n\tint offset;\n\n\tkvm_get_segment(vcpu, &seg, n);\n\tput_smstate(u32, buf, 0x7fa8 + n * 4, seg.selector);\n\n\tif (n < 3)\n\t\toffset = 0x7f84 + n * 12;\n\telse\n\t\toffset = 0x7f2c + (n - 3) * 12;\n\n\tput_smstate(u32, buf, offset + 8, seg.base);\n\tput_smstate(u32, buf, offset + 4, seg.limit);\n\tput_smstate(u32, buf, offset, process_smi_get_segment_flags(&seg));\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_smstate",
          "args": [
            "u32",
            "buf",
            "offset",
            "process_smi_get_segment_flags(&seg)"
          ],
          "line": 6176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "process_smi_get_segment_flags",
          "args": [
            "&seg"
          ],
          "line": 6176
        },
        "resolved": true,
        "details": {
          "function_name": "process_smi_get_segment_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "6147-6159",
          "snippet": "static u32 process_smi_get_segment_flags(struct kvm_segment *seg)\n{\n\tu32 flags = 0;\n\tflags |= seg->g       << 23;\n\tflags |= seg->db      << 22;\n\tflags |= seg->l       << 21;\n\tflags |= seg->avl     << 20;\n\tflags |= seg->present << 15;\n\tflags |= seg->dpl     << 13;\n\tflags |= seg->s       << 12;\n\tflags |= seg->type    << 8;\n\treturn flags;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic u32 process_smi_get_segment_flags(struct kvm_segment *seg)\n{\n\tu32 flags = 0;\n\tflags |= seg->g       << 23;\n\tflags |= seg->db      << 22;\n\tflags |= seg->l       << 21;\n\tflags |= seg->avl     << 20;\n\tflags |= seg->present << 15;\n\tflags |= seg->dpl     << 13;\n\tflags |= seg->s       << 12;\n\tflags |= seg->type    << 8;\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_smstate",
          "args": [
            "u32",
            "buf",
            "offset + 4",
            "seg.limit"
          ],
          "line": 6175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_smstate",
          "args": [
            "u32",
            "buf",
            "offset + 8",
            "seg.base"
          ],
          "line": 6174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_smstate",
          "args": [
            "u32",
            "buf",
            "0x7fa8 + n * 4",
            "seg.selector"
          ],
          "line": 6167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_get_segment",
          "args": [
            "vcpu",
            "&seg",
            "n"
          ],
          "line": 6166
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_get_segment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "4157-4161",
          "snippet": "void kvm_get_segment(struct kvm_vcpu *vcpu,\n\t\t     struct kvm_segment *var, int seg)\n{\n\tkvm_x86_ops->get_segment(vcpu, var, seg);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "struct kvm_x86_ops *kvm_x86_ops"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nvoid kvm_get_segment(struct kvm_vcpu *vcpu,\n\t\t     struct kvm_segment *var, int seg)\n{\n\tkvm_x86_ops->get_segment(vcpu, var, seg);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic void process_smi_save_seg_32(struct kvm_vcpu *vcpu, char *buf, int n)\n{\n\tstruct kvm_segment seg;\n\tint offset;\n\n\tkvm_get_segment(vcpu, &seg, n);\n\tput_smstate(u32, buf, 0x7fa8 + n * 4, seg.selector);\n\n\tif (n < 3)\n\t\toffset = 0x7f84 + n * 12;\n\telse\n\t\toffset = 0x7f2c + (n - 3) * 12;\n\n\tput_smstate(u32, buf, offset + 8, seg.base);\n\tput_smstate(u32, buf, offset + 4, seg.limit);\n\tput_smstate(u32, buf, offset, process_smi_get_segment_flags(&seg));\n}"
  },
  {
    "function_name": "process_smi_get_segment_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "6147-6159",
    "snippet": "static u32 process_smi_get_segment_flags(struct kvm_segment *seg)\n{\n\tu32 flags = 0;\n\tflags |= seg->g       << 23;\n\tflags |= seg->db      << 22;\n\tflags |= seg->l       << 21;\n\tflags |= seg->avl     << 20;\n\tflags |= seg->present << 15;\n\tflags |= seg->dpl     << 13;\n\tflags |= seg->s       << 12;\n\tflags |= seg->type    << 8;\n\treturn flags;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic u32 process_smi_get_segment_flags(struct kvm_segment *seg)\n{\n\tu32 flags = 0;\n\tflags |= seg->g       << 23;\n\tflags |= seg->db      << 22;\n\tflags |= seg->l       << 21;\n\tflags |= seg->avl     << 20;\n\tflags |= seg->present << 15;\n\tflags |= seg->dpl     << 13;\n\tflags |= seg->s       << 12;\n\tflags |= seg->type    << 8;\n\treturn flags;\n}"
  },
  {
    "function_name": "process_nmi",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "6127-6142",
    "snippet": "static void process_nmi(struct kvm_vcpu *vcpu)\n{\n\tunsigned limit = 2;\n\n\t/*\n\t * x86 is limited to one NMI running, and one NMI pending after it.\n\t * If an NMI is already in progress, limit further NMIs to just one.\n\t * Otherwise, allow two (and we'll inject the first one immediately).\n\t */\n\tif (kvm_x86_ops->get_nmi_mask(vcpu) || vcpu->arch.nmi_injected)\n\t\tlimit = 1;\n\n\tvcpu->arch.nmi_pending += atomic_xchg(&vcpu->arch.nmi_queued, 0);\n\tvcpu->arch.nmi_pending = min(vcpu->arch.nmi_pending, limit);\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);",
      "struct kvm_x86_ops *kvm_x86_ops"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_make_request",
          "args": [
            "KVM_REQ_EVENT",
            "vcpu"
          ],
          "line": 6141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "vcpu->arch.nmi_pending",
            "limit"
          ],
          "line": 6140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_xchg",
          "args": [
            "&vcpu->arch.nmi_queued",
            "0"
          ],
          "line": 6139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_x86_ops->get_nmi_mask",
          "args": [
            "vcpu"
          ],
          "line": 6136
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nstatic void process_nmi(struct kvm_vcpu *vcpu)\n{\n\tunsigned limit = 2;\n\n\t/*\n\t * x86 is limited to one NMI running, and one NMI pending after it.\n\t * If an NMI is already in progress, limit further NMIs to just one.\n\t * Otherwise, allow two (and we'll inject the first one immediately).\n\t */\n\tif (kvm_x86_ops->get_nmi_mask(vcpu) || vcpu->arch.nmi_injected)\n\t\tlimit = 1;\n\n\tvcpu->arch.nmi_pending += atomic_xchg(&vcpu->arch.nmi_queued, 0);\n\tvcpu->arch.nmi_pending = min(vcpu->arch.nmi_pending, limit);\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n}"
  },
  {
    "function_name": "inject_pending_event",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "6057-6125",
    "snippet": "static int inject_pending_event(struct kvm_vcpu *vcpu, bool req_int_win)\n{\n\tint r;\n\n\t/* try to reinject previous events if any */\n\tif (vcpu->arch.exception.pending) {\n\t\ttrace_kvm_inj_exception(vcpu->arch.exception.nr,\n\t\t\t\t\tvcpu->arch.exception.has_error_code,\n\t\t\t\t\tvcpu->arch.exception.error_code);\n\n\t\tif (exception_type(vcpu->arch.exception.nr) == EXCPT_FAULT)\n\t\t\t__kvm_set_rflags(vcpu, kvm_get_rflags(vcpu) |\n\t\t\t\t\t     X86_EFLAGS_RF);\n\n\t\tif (vcpu->arch.exception.nr == DB_VECTOR &&\n\t\t    (vcpu->arch.dr7 & DR7_GD)) {\n\t\t\tvcpu->arch.dr7 &= ~DR7_GD;\n\t\t\tkvm_update_dr7(vcpu);\n\t\t}\n\n\t\tkvm_x86_ops->queue_exception(vcpu, vcpu->arch.exception.nr,\n\t\t\t\t\t  vcpu->arch.exception.has_error_code,\n\t\t\t\t\t  vcpu->arch.exception.error_code,\n\t\t\t\t\t  vcpu->arch.exception.reinject);\n\t\treturn 0;\n\t}\n\n\tif (vcpu->arch.nmi_injected) {\n\t\tkvm_x86_ops->set_nmi(vcpu);\n\t\treturn 0;\n\t}\n\n\tif (vcpu->arch.interrupt.pending) {\n\t\tkvm_x86_ops->set_irq(vcpu);\n\t\treturn 0;\n\t}\n\n\tif (is_guest_mode(vcpu) && kvm_x86_ops->check_nested_events) {\n\t\tr = kvm_x86_ops->check_nested_events(vcpu, req_int_win);\n\t\tif (r != 0)\n\t\t\treturn r;\n\t}\n\n\t/* try to inject new event if pending */\n\tif (vcpu->arch.nmi_pending && kvm_x86_ops->nmi_allowed(vcpu)) {\n\t\t--vcpu->arch.nmi_pending;\n\t\tvcpu->arch.nmi_injected = true;\n\t\tkvm_x86_ops->set_nmi(vcpu);\n\t} else if (kvm_cpu_has_injectable_intr(vcpu)) {\n\t\t/*\n\t\t * Because interrupts can be injected asynchronously, we are\n\t\t * calling check_nested_events again here to avoid a race condition.\n\t\t * See https://lkml.org/lkml/2014/7/2/60 for discussion about this\n\t\t * proposal and current concerns.  Perhaps we should be setting\n\t\t * KVM_REQ_EVENT only on certain events and not unconditionally?\n\t\t */\n\t\tif (is_guest_mode(vcpu) && kvm_x86_ops->check_nested_events) {\n\t\t\tr = kvm_x86_ops->check_nested_events(vcpu, req_int_win);\n\t\t\tif (r != 0)\n\t\t\t\treturn r;\n\t\t}\n\t\tif (kvm_x86_ops->interrupt_allowed(vcpu)) {\n\t\t\tkvm_queue_interrupt(vcpu, kvm_cpu_get_interrupt(vcpu),\n\t\t\t\t\t    false);\n\t\t\tkvm_x86_ops->set_irq(vcpu);\n\t\t}\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define EXCPT_FAULT\t\t0"
    ],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);",
      "struct kvm_x86_ops *kvm_x86_ops"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_x86_ops->set_irq",
          "args": [
            "vcpu"
          ],
          "line": 6121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_queue_interrupt",
          "args": [
            "vcpu",
            "kvm_cpu_get_interrupt(vcpu)",
            "false"
          ],
          "line": 6119
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_queue_interrupt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.h",
          "lines": "14-20",
          "snippet": "static inline void kvm_queue_interrupt(struct kvm_vcpu *vcpu, u8 vector,\n\tbool soft)\n{\n\tvcpu->arch.interrupt.pending = true;\n\tvcpu->arch.interrupt.soft = soft;\n\tvcpu->arch.interrupt.nr = vector;\n}",
          "includes": [
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline void kvm_queue_interrupt(struct kvm_vcpu *vcpu, u8 vector,\n\tbool soft)\n{\n\tvcpu->arch.interrupt.pending = true;\n\tvcpu->arch.interrupt.soft = soft;\n\tvcpu->arch.interrupt.nr = vector;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_cpu_get_interrupt",
          "args": [
            "vcpu"
          ],
          "line": 6119
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_cpu_get_interrupt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/irq.c",
          "lines": "125-138",
          "snippet": "int kvm_cpu_get_interrupt(struct kvm_vcpu *v)\n{\n\tint vector;\n\n\tif (!lapic_in_kernel(v))\n\t\treturn v->arch.interrupt.nr;\n\n\tvector = kvm_cpu_get_extint(v);\n\n\tif (vector != -1)\n\t\treturn vector;\t\t\t/* PIC */\n\n\treturn kvm_get_apic_interrupt(v);\t/* APIC */\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"i8254.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"i8254.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n#include <linux/module.h>\n\nint kvm_cpu_get_interrupt(struct kvm_vcpu *v)\n{\n\tint vector;\n\n\tif (!lapic_in_kernel(v))\n\t\treturn v->arch.interrupt.nr;\n\n\tvector = kvm_cpu_get_extint(v);\n\n\tif (vector != -1)\n\t\treturn vector;\t\t\t/* PIC */\n\n\treturn kvm_get_apic_interrupt(v);\t/* APIC */\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_x86_ops->interrupt_allowed",
          "args": [
            "vcpu"
          ],
          "line": 6118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_x86_ops->check_nested_events",
          "args": [
            "vcpu",
            "req_int_win"
          ],
          "line": 6114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_guest_mode",
          "args": [
            "vcpu"
          ],
          "line": 6113
        },
        "resolved": true,
        "details": {
          "function_name": "is_guest_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "102-105",
          "snippet": "static inline bool is_guest_mode(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.hflags & HF_GUEST_MASK;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline bool is_guest_mode(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.hflags & HF_GUEST_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_cpu_has_injectable_intr",
          "args": [
            "vcpu"
          ],
          "line": 6105
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_cpu_has_injectable_intr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/irq.c",
          "lines": "74-86",
          "snippet": "int kvm_cpu_has_injectable_intr(struct kvm_vcpu *v)\n{\n\tif (!lapic_in_kernel(v))\n\t\treturn v->arch.interrupt.pending;\n\n\tif (kvm_cpu_has_extint(v))\n\t\treturn 1;\n\n\tif (kvm_vcpu_apicv_active(v))\n\t\treturn 0;\n\n\treturn kvm_apic_has_interrupt(v) != -1; /* LAPIC */\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"i8254.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"i8254.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n#include <linux/module.h>\n\nint kvm_cpu_has_injectable_intr(struct kvm_vcpu *v)\n{\n\tif (!lapic_in_kernel(v))\n\t\treturn v->arch.interrupt.pending;\n\n\tif (kvm_cpu_has_extint(v))\n\t\treturn 1;\n\n\tif (kvm_vcpu_apicv_active(v))\n\t\treturn 0;\n\n\treturn kvm_apic_has_interrupt(v) != -1; /* LAPIC */\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_x86_ops->set_nmi",
          "args": [
            "vcpu"
          ],
          "line": 6104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_x86_ops->nmi_allowed",
          "args": [
            "vcpu"
          ],
          "line": 6101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_x86_ops->check_nested_events",
          "args": [
            "vcpu",
            "req_int_win"
          ],
          "line": 6095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_x86_ops->set_irq",
          "args": [
            "vcpu"
          ],
          "line": 6090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_x86_ops->set_nmi",
          "args": [
            "vcpu"
          ],
          "line": 6085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_x86_ops->queue_exception",
          "args": [
            "vcpu",
            "vcpu->arch.exception.nr",
            "vcpu->arch.exception.has_error_code",
            "vcpu->arch.exception.error_code",
            "vcpu->arch.exception.reinject"
          ],
          "line": 6077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_update_dr7",
          "args": [
            "vcpu"
          ],
          "line": 6074
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_update_dr7",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "842-854",
          "snippet": "static void kvm_update_dr7(struct kvm_vcpu *vcpu)\n{\n\tunsigned long dr7;\n\n\tif (vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP)\n\t\tdr7 = vcpu->arch.guest_debug_dr7;\n\telse\n\t\tdr7 = vcpu->arch.dr7;\n\tkvm_x86_ops->set_dr7(vcpu, dr7);\n\tvcpu->arch.switch_db_regs &= ~KVM_DEBUGREG_BP_ENABLED;\n\tif (dr7 & DR7_BP_EN_MASK)\n\t\tvcpu->arch.switch_db_regs |= KVM_DEBUGREG_BP_ENABLED;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "struct kvm_x86_ops *kvm_x86_ops"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nstatic void kvm_update_dr7(struct kvm_vcpu *vcpu)\n{\n\tunsigned long dr7;\n\n\tif (vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP)\n\t\tdr7 = vcpu->arch.guest_debug_dr7;\n\telse\n\t\tdr7 = vcpu->arch.dr7;\n\tkvm_x86_ops->set_dr7(vcpu, dr7);\n\tvcpu->arch.switch_db_regs &= ~KVM_DEBUGREG_BP_ENABLED;\n\tif (dr7 & DR7_BP_EN_MASK)\n\t\tvcpu->arch.switch_db_regs |= KVM_DEBUGREG_BP_ENABLED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__kvm_set_rflags",
          "args": [
            "vcpu",
            "kvm_get_rflags(vcpu) |\n\t\t\t\t\t     X86_EFLAGS_RF"
          ],
          "line": 6068
        },
        "resolved": true,
        "details": {
          "function_name": "__kvm_set_rflags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "8174-8180",
          "snippet": "static void __kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags)\n{\n\tif (vcpu->guest_debug & KVM_GUESTDBG_SINGLESTEP &&\n\t    kvm_is_linear_rip(vcpu, vcpu->arch.singlestep_rip))\n\t\trflags |= X86_EFLAGS_TF;\n\tkvm_x86_ops->set_rflags(vcpu, rflags);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void __kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags);",
            "struct kvm_x86_ops *kvm_x86_ops"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void __kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nstatic void __kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags)\n{\n\tif (vcpu->guest_debug & KVM_GUESTDBG_SINGLESTEP &&\n\t    kvm_is_linear_rip(vcpu, vcpu->arch.singlestep_rip))\n\t\trflags |= X86_EFLAGS_TF;\n\tkvm_x86_ops->set_rflags(vcpu, rflags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_get_rflags",
          "args": [
            "vcpu"
          ],
          "line": 6068
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_get_rflags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "8163-8171",
          "snippet": "unsigned long kvm_get_rflags(struct kvm_vcpu *vcpu)\n{\n\tunsigned long rflags;\n\n\trflags = kvm_x86_ops->get_rflags(vcpu);\n\tif (vcpu->guest_debug & KVM_GUESTDBG_SINGLESTEP)\n\t\trflags &= ~X86_EFLAGS_TF;\n\treturn rflags;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void __kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags);",
            "struct kvm_x86_ops *kvm_x86_ops"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void __kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nunsigned long kvm_get_rflags(struct kvm_vcpu *vcpu)\n{\n\tunsigned long rflags;\n\n\trflags = kvm_x86_ops->get_rflags(vcpu);\n\tif (vcpu->guest_debug & KVM_GUESTDBG_SINGLESTEP)\n\t\trflags &= ~X86_EFLAGS_TF;\n\treturn rflags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exception_type",
          "args": [
            "vcpu->arch.exception.nr"
          ],
          "line": 6067
        },
        "resolved": true,
        "details": {
          "function_name": "exception_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "345-363",
          "snippet": "static int exception_type(int vector)\n{\n\tunsigned int mask;\n\n\tif (WARN_ON(vector > 31 || vector == NMI_VECTOR))\n\t\treturn EXCPT_INTERRUPT;\n\n\tmask = 1 << vector;\n\n\t/* #DB is trap, as instruction watchpoints are handled elsewhere */\n\tif (mask & ((1 << DB_VECTOR) | (1 << BP_VECTOR) | (1 << OF_VECTOR)))\n\t\treturn EXCPT_TRAP;\n\n\tif (mask & ((1 << DF_VECTOR) | (1 << MC_VECTOR)))\n\t\treturn EXCPT_ABORT;\n\n\t/* Reserved exceptions will result in fault */\n\treturn EXCPT_FAULT;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define EXCPT_INTERRUPT\t\t3",
            "#define EXCPT_ABORT\t\t2",
            "#define EXCPT_TRAP\t\t1",
            "#define EXCPT_FAULT\t\t0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define EXCPT_INTERRUPT\t\t3\n#define EXCPT_ABORT\t\t2\n#define EXCPT_TRAP\t\t1\n#define EXCPT_FAULT\t\t0\n\nstatic int exception_type(int vector)\n{\n\tunsigned int mask;\n\n\tif (WARN_ON(vector > 31 || vector == NMI_VECTOR))\n\t\treturn EXCPT_INTERRUPT;\n\n\tmask = 1 << vector;\n\n\t/* #DB is trap, as instruction watchpoints are handled elsewhere */\n\tif (mask & ((1 << DB_VECTOR) | (1 << BP_VECTOR) | (1 << OF_VECTOR)))\n\t\treturn EXCPT_TRAP;\n\n\tif (mask & ((1 << DF_VECTOR) | (1 << MC_VECTOR)))\n\t\treturn EXCPT_ABORT;\n\n\t/* Reserved exceptions will result in fault */\n\treturn EXCPT_FAULT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_kvm_inj_exception",
          "args": [
            "vcpu->arch.exception.nr",
            "vcpu->arch.exception.has_error_code",
            "vcpu->arch.exception.error_code"
          ],
          "line": 6063
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define EXCPT_FAULT\t\t0\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nstatic int inject_pending_event(struct kvm_vcpu *vcpu, bool req_int_win)\n{\n\tint r;\n\n\t/* try to reinject previous events if any */\n\tif (vcpu->arch.exception.pending) {\n\t\ttrace_kvm_inj_exception(vcpu->arch.exception.nr,\n\t\t\t\t\tvcpu->arch.exception.has_error_code,\n\t\t\t\t\tvcpu->arch.exception.error_code);\n\n\t\tif (exception_type(vcpu->arch.exception.nr) == EXCPT_FAULT)\n\t\t\t__kvm_set_rflags(vcpu, kvm_get_rflags(vcpu) |\n\t\t\t\t\t     X86_EFLAGS_RF);\n\n\t\tif (vcpu->arch.exception.nr == DB_VECTOR &&\n\t\t    (vcpu->arch.dr7 & DR7_GD)) {\n\t\t\tvcpu->arch.dr7 &= ~DR7_GD;\n\t\t\tkvm_update_dr7(vcpu);\n\t\t}\n\n\t\tkvm_x86_ops->queue_exception(vcpu, vcpu->arch.exception.nr,\n\t\t\t\t\t  vcpu->arch.exception.has_error_code,\n\t\t\t\t\t  vcpu->arch.exception.error_code,\n\t\t\t\t\t  vcpu->arch.exception.reinject);\n\t\treturn 0;\n\t}\n\n\tif (vcpu->arch.nmi_injected) {\n\t\tkvm_x86_ops->set_nmi(vcpu);\n\t\treturn 0;\n\t}\n\n\tif (vcpu->arch.interrupt.pending) {\n\t\tkvm_x86_ops->set_irq(vcpu);\n\t\treturn 0;\n\t}\n\n\tif (is_guest_mode(vcpu) && kvm_x86_ops->check_nested_events) {\n\t\tr = kvm_x86_ops->check_nested_events(vcpu, req_int_win);\n\t\tif (r != 0)\n\t\t\treturn r;\n\t}\n\n\t/* try to inject new event if pending */\n\tif (vcpu->arch.nmi_pending && kvm_x86_ops->nmi_allowed(vcpu)) {\n\t\t--vcpu->arch.nmi_pending;\n\t\tvcpu->arch.nmi_injected = true;\n\t\tkvm_x86_ops->set_nmi(vcpu);\n\t} else if (kvm_cpu_has_injectable_intr(vcpu)) {\n\t\t/*\n\t\t * Because interrupts can be injected asynchronously, we are\n\t\t * calling check_nested_events again here to avoid a race condition.\n\t\t * See https://lkml.org/lkml/2014/7/2/60 for discussion about this\n\t\t * proposal and current concerns.  Perhaps we should be setting\n\t\t * KVM_REQ_EVENT only on certain events and not unconditionally?\n\t\t */\n\t\tif (is_guest_mode(vcpu) && kvm_x86_ops->check_nested_events) {\n\t\t\tr = kvm_x86_ops->check_nested_events(vcpu, req_int_win);\n\t\t\tif (r != 0)\n\t\t\t\treturn r;\n\t\t}\n\t\tif (kvm_x86_ops->interrupt_allowed(vcpu)) {\n\t\t\tkvm_queue_interrupt(vcpu, kvm_cpu_get_interrupt(vcpu),\n\t\t\t\t\t    false);\n\t\t\tkvm_x86_ops->set_irq(vcpu);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "update_cr8_intercept",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "6031-6055",
    "snippet": "static void update_cr8_intercept(struct kvm_vcpu *vcpu)\n{\n\tint max_irr, tpr;\n\n\tif (!kvm_x86_ops->update_cr8_intercept)\n\t\treturn;\n\n\tif (!lapic_in_kernel(vcpu))\n\t\treturn;\n\n\tif (vcpu->arch.apicv_active)\n\t\treturn;\n\n\tif (!vcpu->arch.apic->vapic_addr)\n\t\tmax_irr = kvm_lapic_find_highest_irr(vcpu);\n\telse\n\t\tmax_irr = -1;\n\n\tif (max_irr != -1)\n\t\tmax_irr >>= 4;\n\n\ttpr = kvm_lapic_get_cr8(vcpu);\n\n\tkvm_x86_ops->update_cr8_intercept(vcpu, tpr, max_irr);\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);",
      "struct kvm_x86_ops *kvm_x86_ops"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_x86_ops->update_cr8_intercept",
          "args": [
            "vcpu",
            "tpr",
            "max_irr"
          ],
          "line": 6054
        },
        "resolved": true,
        "details": {
          "function_name": "update_cr8_intercept",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/vmx.c",
          "lines": "8249-8263",
          "snippet": "static void update_cr8_intercept(struct kvm_vcpu *vcpu, int tpr, int irr)\n{\n\tstruct vmcs12 *vmcs12 = get_vmcs12(vcpu);\n\n\tif (is_guest_mode(vcpu) &&\n\t\tnested_cpu_has(vmcs12, CPU_BASED_TPR_SHADOW))\n\t\treturn;\n\n\tif (irr == -1 || tpr < irr) {\n\t\tvmcs_write32(TPR_THRESHOLD, 0);\n\t\treturn;\n\t}\n\n\tvmcs_write32(TPR_THRESHOLD, irr);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "kvm_lapic_get_cr8",
          "args": [
            "vcpu"
          ],
          "line": 6052
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_get_cr8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "1652-1659",
          "snippet": "u64 kvm_lapic_get_cr8(struct kvm_vcpu *vcpu)\n{\n\tu64 tpr;\n\n\ttpr = (u64) kvm_lapic_get_reg(vcpu->arch.apic, APIC_TASKPRI);\n\n\treturn (tpr & 0xf0) >> 4;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nu64 kvm_lapic_get_cr8(struct kvm_vcpu *vcpu)\n{\n\tu64 tpr;\n\n\ttpr = (u64) kvm_lapic_get_reg(vcpu->arch.apic, APIC_TASKPRI);\n\n\treturn (tpr & 0xf0) >> 4;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_lapic_find_highest_irr",
          "args": [
            "vcpu"
          ],
          "line": 6045
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_find_highest_irr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "452-460",
          "snippet": "int kvm_lapic_find_highest_irr(struct kvm_vcpu *vcpu)\n{\n\t/* This may race with setting of irr in __apic_accept_irq() and\n\t * value returned may be wrong, but kvm_vcpu_kick() in __apic_accept_irq\n\t * will cause vmexit immediately and the value will be recalculated\n\t * on the next vmentry.\n\t */\n\treturn apic_find_highest_irr(vcpu->arch.apic);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nint kvm_lapic_find_highest_irr(struct kvm_vcpu *vcpu)\n{\n\t/* This may race with setting of irr in __apic_accept_irq() and\n\t * value returned may be wrong, but kvm_vcpu_kick() in __apic_accept_irq\n\t * will cause vmexit immediately and the value will be recalculated\n\t * on the next vmentry.\n\t */\n\treturn apic_find_highest_irr(vcpu->arch.apic);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lapic_in_kernel",
          "args": [
            "vcpu"
          ],
          "line": 6038
        },
        "resolved": true,
        "details": {
          "function_name": "lapic_in_kernel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.h",
          "lines": "141-146",
          "snippet": "static inline bool lapic_in_kernel(struct kvm_vcpu *vcpu)\n{\n\tif (static_key_false(&kvm_no_apic_vcpu))\n\t\treturn vcpu->arch.apic;\n\treturn true;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline bool lapic_in_kernel(struct kvm_vcpu *vcpu)\n{\n\tif (static_key_false(&kvm_no_apic_vcpu))\n\t\treturn vcpu->arch.apic;\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu)\n{\n\tint max_irr, tpr;\n\n\tif (!kvm_x86_ops->update_cr8_intercept)\n\t\treturn;\n\n\tif (!lapic_in_kernel(vcpu))\n\t\treturn;\n\n\tif (vcpu->arch.apicv_active)\n\t\treturn;\n\n\tif (!vcpu->arch.apic->vapic_addr)\n\t\tmax_irr = kvm_lapic_find_highest_irr(vcpu);\n\telse\n\t\tmax_irr = -1;\n\n\tif (max_irr != -1)\n\t\tmax_irr >>= 4;\n\n\ttpr = kvm_lapic_get_cr8(vcpu);\n\n\tkvm_x86_ops->update_cr8_intercept(vcpu, tpr, max_irr);\n}"
  },
  {
    "function_name": "post_kvm_run_save",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "6018-6029",
    "snippet": "static void post_kvm_run_save(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_run *kvm_run = vcpu->run;\n\n\tkvm_run->if_flag = (kvm_get_rflags(vcpu) & X86_EFLAGS_IF) != 0;\n\tkvm_run->flags = is_smm(vcpu) ? KVM_RUN_X86_SMM : 0;\n\tkvm_run->cr8 = kvm_get_cr8(vcpu);\n\tkvm_run->apic_base = kvm_get_apic_base(vcpu);\n\tkvm_run->ready_for_interrupt_injection =\n\t\tpic_in_kernel(vcpu->kvm) ||\n\t\tkvm_vcpu_ready_for_interrupt_injection(vcpu);\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_vcpu_ready_for_interrupt_injection",
          "args": [
            "vcpu"
          ],
          "line": 6028
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_vcpu_ready_for_interrupt_injection",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "2800-2806",
          "snippet": "static int kvm_vcpu_ready_for_interrupt_injection(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_arch_interrupt_allowed(vcpu) &&\n\t\t!kvm_cpu_has_interrupt(vcpu) &&\n\t\t!kvm_event_needs_reinjection(vcpu) &&\n\t\tkvm_cpu_accept_dm_intr(vcpu);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic int kvm_vcpu_ready_for_interrupt_injection(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_arch_interrupt_allowed(vcpu) &&\n\t\t!kvm_cpu_has_interrupt(vcpu) &&\n\t\t!kvm_event_needs_reinjection(vcpu) &&\n\t\tkvm_cpu_accept_dm_intr(vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pic_in_kernel",
          "args": [
            "vcpu->kvm"
          ],
          "line": 6027
        },
        "resolved": true,
        "details": {
          "function_name": "ioapic_in_kernel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/ioapic.h",
          "lines": "113-119",
          "snippet": "static inline int ioapic_in_kernel(struct kvm *kvm)\n{\n\tint ret;\n\n\tret = (ioapic_irqchip(kvm) != NULL);\n\treturn ret;\n}",
          "includes": [
            "#include <kvm/iodev.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kvm/iodev.h>\n#include <linux/kvm_host.h>\n\nstatic inline int ioapic_in_kernel(struct kvm *kvm)\n{\n\tint ret;\n\n\tret = (ioapic_irqchip(kvm) != NULL);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_get_apic_base",
          "args": [
            "vcpu"
          ],
          "line": 6025
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_get_apic_base",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "283-286",
          "snippet": "u64 kvm_get_apic_base(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.apic_base;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nu64 kvm_get_apic_base(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.apic_base;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_get_cr8",
          "args": [
            "vcpu"
          ],
          "line": 6024
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_get_cr8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "816-822",
          "snippet": "unsigned long kvm_get_cr8(struct kvm_vcpu *vcpu)\n{\n\tif (lapic_in_kernel(vcpu))\n\t\treturn kvm_lapic_get_cr8(vcpu);\n\telse\n\t\treturn vcpu->arch.cr8;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nunsigned long kvm_get_cr8(struct kvm_vcpu *vcpu)\n{\n\tif (lapic_in_kernel(vcpu))\n\t\treturn kvm_lapic_get_cr8(vcpu);\n\telse\n\t\treturn vcpu->arch.cr8;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_smm",
          "args": [
            "vcpu"
          ],
          "line": 6023
        },
        "resolved": true,
        "details": {
          "function_name": "is_smm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "107-110",
          "snippet": "static inline bool is_smm(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.hflags & HF_SMM_MASK;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline bool is_smm(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.hflags & HF_SMM_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_get_rflags",
          "args": [
            "vcpu"
          ],
          "line": 6022
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_get_rflags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "8163-8171",
          "snippet": "unsigned long kvm_get_rflags(struct kvm_vcpu *vcpu)\n{\n\tunsigned long rflags;\n\n\trflags = kvm_x86_ops->get_rflags(vcpu);\n\tif (vcpu->guest_debug & KVM_GUESTDBG_SINGLESTEP)\n\t\trflags &= ~X86_EFLAGS_TF;\n\treturn rflags;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void __kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags);",
            "struct kvm_x86_ops *kvm_x86_ops"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void __kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nunsigned long kvm_get_rflags(struct kvm_vcpu *vcpu)\n{\n\tunsigned long rflags;\n\n\trflags = kvm_x86_ops->get_rflags(vcpu);\n\tif (vcpu->guest_debug & KVM_GUESTDBG_SINGLESTEP)\n\t\trflags &= ~X86_EFLAGS_TF;\n\treturn rflags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic void post_kvm_run_save(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_run *kvm_run = vcpu->run;\n\n\tkvm_run->if_flag = (kvm_get_rflags(vcpu) & X86_EFLAGS_IF) != 0;\n\tkvm_run->flags = is_smm(vcpu) ? KVM_RUN_X86_SMM : 0;\n\tkvm_run->cr8 = kvm_get_cr8(vcpu);\n\tkvm_run->apic_base = kvm_get_apic_base(vcpu);\n\tkvm_run->ready_for_interrupt_injection =\n\t\tpic_in_kernel(vcpu->kvm) ||\n\t\tkvm_vcpu_ready_for_interrupt_injection(vcpu);\n}"
  },
  {
    "function_name": "dm_request_for_irq_injection",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "6012-6016",
    "snippet": "static int dm_request_for_irq_injection(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->run->request_interrupt_window &&\n\t\tlikely(!pic_in_kernel(vcpu->kvm));\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!pic_in_kernel(vcpu->kvm)"
          ],
          "line": 6015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pic_in_kernel",
          "args": [
            "vcpu->kvm"
          ],
          "line": 6015
        },
        "resolved": true,
        "details": {
          "function_name": "ioapic_in_kernel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/ioapic.h",
          "lines": "113-119",
          "snippet": "static inline int ioapic_in_kernel(struct kvm *kvm)\n{\n\tint ret;\n\n\tret = (ioapic_irqchip(kvm) != NULL);\n\treturn ret;\n}",
          "includes": [
            "#include <kvm/iodev.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kvm/iodev.h>\n#include <linux/kvm_host.h>\n\nstatic inline int ioapic_in_kernel(struct kvm *kvm)\n{\n\tint ret;\n\n\tret = (ioapic_irqchip(kvm) != NULL);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic int dm_request_for_irq_injection(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->run->request_interrupt_window &&\n\t\tlikely(!pic_in_kernel(vcpu->kvm));\n}"
  },
  {
    "function_name": "emulator_fix_hypercall",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "6001-6010",
    "snippet": "static int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt)\n{\n\tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n\tchar instruction[3];\n\tunsigned long rip = kvm_rip_read(vcpu);\n\n\tkvm_x86_ops->patch_hypercall(vcpu, instruction);\n\n\treturn emulator_write_emulated(ctxt, rip, instruction, 3, NULL);\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);",
      "struct kvm_x86_ops *kvm_x86_ops",
      "static int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "emulator_write_emulated",
          "args": [
            "ctxt",
            "rip",
            "instruction",
            "3",
            "NULL"
          ],
          "line": 6009
        },
        "resolved": true,
        "details": {
          "function_name": "emulator_write_emulated",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "4557-4565",
          "snippet": "static int emulator_write_emulated(struct x86_emulate_ctxt *ctxt,\n\t\t\t    unsigned long addr,\n\t\t\t    const void *val,\n\t\t\t    unsigned int bytes,\n\t\t\t    struct x86_exception *exception)\n{\n\treturn emulator_read_write(ctxt, addr, (void *)val, bytes,\n\t\t\t\t   exception, &write_emultor);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);\n\nstatic int emulator_write_emulated(struct x86_emulate_ctxt *ctxt,\n\t\t\t    unsigned long addr,\n\t\t\t    const void *val,\n\t\t\t    unsigned int bytes,\n\t\t\t    struct x86_exception *exception)\n{\n\treturn emulator_read_write(ctxt, addr, (void *)val, bytes,\n\t\t\t\t   exception, &write_emultor);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_x86_ops->patch_hypercall",
          "args": [
            "vcpu",
            "instruction"
          ],
          "line": 6007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_rip_read",
          "args": [
            "vcpu"
          ],
          "line": 6005
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_rip_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "27-30",
          "snippet": "static inline unsigned long kvm_rip_read(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_register_read(vcpu, VCPU_REGS_RIP);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline unsigned long kvm_rip_read(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_register_read(vcpu, VCPU_REGS_RIP);\n}"
        }
      },
      {
        "call_info": {
          "callee": "emul_to_vcpu",
          "args": [
            "ctxt"
          ],
          "line": 6003
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\nstatic int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);\n\nstatic int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt)\n{\n\tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n\tchar instruction[3];\n\tunsigned long rip = kvm_rip_read(vcpu);\n\n\tkvm_x86_ops->patch_hypercall(vcpu, instruction);\n\n\treturn emulator_write_emulated(ctxt, rip, instruction, 3, NULL);\n}"
  },
  {
    "function_name": "kvm_emulate_hypercall",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "5948-5998",
    "snippet": "int kvm_emulate_hypercall(struct kvm_vcpu *vcpu)\n{\n\tunsigned long nr, a0, a1, a2, a3, ret;\n\tint op_64_bit, r = 1;\n\n\tkvm_x86_ops->skip_emulated_instruction(vcpu);\n\n\tif (kvm_hv_hypercall_enabled(vcpu->kvm))\n\t\treturn kvm_hv_hypercall(vcpu);\n\n\tnr = kvm_register_read(vcpu, VCPU_REGS_RAX);\n\ta0 = kvm_register_read(vcpu, VCPU_REGS_RBX);\n\ta1 = kvm_register_read(vcpu, VCPU_REGS_RCX);\n\ta2 = kvm_register_read(vcpu, VCPU_REGS_RDX);\n\ta3 = kvm_register_read(vcpu, VCPU_REGS_RSI);\n\n\ttrace_kvm_hypercall(nr, a0, a1, a2, a3);\n\n\top_64_bit = is_64_bit_mode(vcpu);\n\tif (!op_64_bit) {\n\t\tnr &= 0xFFFFFFFF;\n\t\ta0 &= 0xFFFFFFFF;\n\t\ta1 &= 0xFFFFFFFF;\n\t\ta2 &= 0xFFFFFFFF;\n\t\ta3 &= 0xFFFFFFFF;\n\t}\n\n\tif (kvm_x86_ops->get_cpl(vcpu) != 0) {\n\t\tret = -KVM_EPERM;\n\t\tgoto out;\n\t}\n\n\tswitch (nr) {\n\tcase KVM_HC_VAPIC_POLL_IRQ:\n\t\tret = 0;\n\t\tbreak;\n\tcase KVM_HC_KICK_CPU:\n\t\tkvm_pv_kick_cpu_op(vcpu->kvm, a0, a1);\n\t\tret = 0;\n\t\tbreak;\n\tdefault:\n\t\tret = -KVM_ENOSYS;\n\t\tbreak;\n\t}\nout:\n\tif (!op_64_bit)\n\t\tret = (u32)ret;\n\tkvm_register_write(vcpu, VCPU_REGS_RAX, ret);\n\t++vcpu->stat.hypercalls;\n\treturn r;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);",
      "struct kvm_x86_ops *kvm_x86_ops"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_register_write",
          "args": [
            "vcpu",
            "VCPU_REGS_RAX",
            "ret"
          ],
          "line": 5995
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_register_writel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.h",
          "lines": "141-148",
          "snippet": "static inline void kvm_register_writel(struct kvm_vcpu *vcpu,\n\t\t\t\t       enum kvm_reg reg,\n\t\t\t\t       unsigned long val)\n{\n\tif (!is_64_bit_mode(vcpu))\n\t\tval = (u32)val;\n\treturn kvm_register_write(vcpu, reg, val);\n}",
          "includes": [
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline void kvm_register_writel(struct kvm_vcpu *vcpu,\n\t\t\t\t       enum kvm_reg reg,\n\t\t\t\t       unsigned long val)\n{\n\tif (!is_64_bit_mode(vcpu))\n\t\tval = (u32)val;\n\treturn kvm_register_write(vcpu, reg, val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_pv_kick_cpu_op",
          "args": [
            "vcpu->kvm",
            "a0",
            "a1"
          ],
          "line": 5985
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_pv_kick_cpu_op",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "5929-5940",
          "snippet": "static void kvm_pv_kick_cpu_op(struct kvm *kvm, unsigned long flags, int apicid)\n{\n\tstruct kvm_lapic_irq lapic_irq;\n\n\tlapic_irq.shorthand = 0;\n\tlapic_irq.dest_mode = 0;\n\tlapic_irq.dest_id = apicid;\n\tlapic_irq.msi_redir_hint = false;\n\n\tlapic_irq.delivery_mode = APIC_DM_REMRD;\n\tkvm_irq_delivery_to_apic(kvm, NULL, &lapic_irq, NULL);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void kvm_pv_kick_cpu_op(struct kvm *kvm, unsigned long flags, int apicid)\n{\n\tstruct kvm_lapic_irq lapic_irq;\n\n\tlapic_irq.shorthand = 0;\n\tlapic_irq.dest_mode = 0;\n\tlapic_irq.dest_id = apicid;\n\tlapic_irq.msi_redir_hint = false;\n\n\tlapic_irq.delivery_mode = APIC_DM_REMRD;\n\tkvm_irq_delivery_to_apic(kvm, NULL, &lapic_irq, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_x86_ops->get_cpl",
          "args": [
            "vcpu"
          ],
          "line": 5975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_64_bit_mode",
          "args": [
            "vcpu"
          ],
          "line": 5966
        },
        "resolved": true,
        "details": {
          "function_name": "is_64_bit_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.h",
          "lines": "52-60",
          "snippet": "static inline bool is_64_bit_mode(struct kvm_vcpu *vcpu)\n{\n\tint cs_db, cs_l;\n\n\tif (!is_long_mode(vcpu))\n\t\treturn false;\n\tkvm_x86_ops->get_cs_db_l_bits(vcpu, &cs_db, &cs_l);\n\treturn cs_l;\n}",
          "includes": [
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline bool is_64_bit_mode(struct kvm_vcpu *vcpu)\n{\n\tint cs_db, cs_l;\n\n\tif (!is_long_mode(vcpu))\n\t\treturn false;\n\tkvm_x86_ops->get_cs_db_l_bits(vcpu, &cs_db, &cs_l);\n\treturn cs_l;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_kvm_hypercall",
          "args": [
            "nr",
            "a0",
            "a1",
            "a2",
            "a3"
          ],
          "line": 5964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_register_read",
          "args": [
            "vcpu",
            "VCPU_REGS_RSI"
          ],
          "line": 5962
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_register_readl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.h",
          "lines": "133-139",
          "snippet": "static inline unsigned long kvm_register_readl(struct kvm_vcpu *vcpu,\n\t\t\t\t\t       enum kvm_reg reg)\n{\n\tunsigned long val = kvm_register_read(vcpu, reg);\n\n\treturn is_64_bit_mode(vcpu) ? val : (u32)val;\n}",
          "includes": [
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline unsigned long kvm_register_readl(struct kvm_vcpu *vcpu,\n\t\t\t\t\t       enum kvm_reg reg)\n{\n\tunsigned long val = kvm_register_read(vcpu, reg);\n\n\treturn is_64_bit_mode(vcpu) ? val : (u32)val;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_hv_hypercall",
          "args": [
            "vcpu"
          ],
          "line": 5956
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_hv_hypercall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.c",
          "lines": "1067-1141",
          "snippet": "int kvm_hv_hypercall(struct kvm_vcpu *vcpu)\n{\n\tu64 param, ingpa, outgpa, ret;\n\tuint16_t code, rep_idx, rep_cnt, res = HV_STATUS_SUCCESS, rep_done = 0;\n\tbool fast, longmode;\n\n\t/*\n\t * hypercall generates UD from non zero cpl and real mode\n\t * per HYPER-V spec\n\t */\n\tif (kvm_x86_ops->get_cpl(vcpu) != 0 || !is_protmode(vcpu)) {\n\t\tkvm_queue_exception(vcpu, UD_VECTOR);\n\t\treturn 1;\n\t}\n\n\tlongmode = is_64_bit_mode(vcpu);\n\n\tif (!longmode) {\n\t\tparam = ((u64)kvm_register_read(vcpu, VCPU_REGS_RDX) << 32) |\n\t\t\t(kvm_register_read(vcpu, VCPU_REGS_RAX) & 0xffffffff);\n\t\tingpa = ((u64)kvm_register_read(vcpu, VCPU_REGS_RBX) << 32) |\n\t\t\t(kvm_register_read(vcpu, VCPU_REGS_RCX) & 0xffffffff);\n\t\toutgpa = ((u64)kvm_register_read(vcpu, VCPU_REGS_RDI) << 32) |\n\t\t\t(kvm_register_read(vcpu, VCPU_REGS_RSI) & 0xffffffff);\n\t}\n#ifdef CONFIG_X86_64\n\telse {\n\t\tparam = kvm_register_read(vcpu, VCPU_REGS_RCX);\n\t\tingpa = kvm_register_read(vcpu, VCPU_REGS_RDX);\n\t\toutgpa = kvm_register_read(vcpu, VCPU_REGS_R8);\n\t}\n#endif\n\n\tcode = param & 0xffff;\n\tfast = (param >> 16) & 0x1;\n\trep_cnt = (param >> 32) & 0xfff;\n\trep_idx = (param >> 48) & 0xfff;\n\n\ttrace_kvm_hv_hypercall(code, fast, rep_cnt, rep_idx, ingpa, outgpa);\n\n\t/* Hypercall continuation is not supported yet */\n\tif (rep_cnt || rep_idx) {\n\t\tres = HV_STATUS_INVALID_HYPERCALL_CODE;\n\t\tgoto set_result;\n\t}\n\n\tswitch (code) {\n\tcase HVCALL_NOTIFY_LONG_SPIN_WAIT:\n\t\tkvm_vcpu_on_spin(vcpu);\n\t\tbreak;\n\tcase HVCALL_POST_MESSAGE:\n\tcase HVCALL_SIGNAL_EVENT:\n\t\t/* don't bother userspace if it has no way to handle it */\n\t\tif (!vcpu_to_synic(vcpu)->active) {\n\t\t\tres = HV_STATUS_INVALID_HYPERCALL_CODE;\n\t\t\tbreak;\n\t\t}\n\t\tvcpu->run->exit_reason = KVM_EXIT_HYPERV;\n\t\tvcpu->run->hyperv.type = KVM_EXIT_HYPERV_HCALL;\n\t\tvcpu->run->hyperv.u.hcall.input = param;\n\t\tvcpu->run->hyperv.u.hcall.params[0] = ingpa;\n\t\tvcpu->run->hyperv.u.hcall.params[1] = outgpa;\n\t\tvcpu->arch.complete_userspace_io =\n\t\t\t\tkvm_hv_hypercall_complete_userspace;\n\t\treturn 0;\n\tdefault:\n\t\tres = HV_STATUS_INVALID_HYPERCALL_CODE;\n\t\tbreak;\n\t}\n\nset_result:\n\tret = res | (((u64)rep_done & 0xfff) << 32);\n\tkvm_hv_hypercall_set_result(vcpu, ret);\n\treturn 1;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nint kvm_hv_hypercall(struct kvm_vcpu *vcpu)\n{\n\tu64 param, ingpa, outgpa, ret;\n\tuint16_t code, rep_idx, rep_cnt, res = HV_STATUS_SUCCESS, rep_done = 0;\n\tbool fast, longmode;\n\n\t/*\n\t * hypercall generates UD from non zero cpl and real mode\n\t * per HYPER-V spec\n\t */\n\tif (kvm_x86_ops->get_cpl(vcpu) != 0 || !is_protmode(vcpu)) {\n\t\tkvm_queue_exception(vcpu, UD_VECTOR);\n\t\treturn 1;\n\t}\n\n\tlongmode = is_64_bit_mode(vcpu);\n\n\tif (!longmode) {\n\t\tparam = ((u64)kvm_register_read(vcpu, VCPU_REGS_RDX) << 32) |\n\t\t\t(kvm_register_read(vcpu, VCPU_REGS_RAX) & 0xffffffff);\n\t\tingpa = ((u64)kvm_register_read(vcpu, VCPU_REGS_RBX) << 32) |\n\t\t\t(kvm_register_read(vcpu, VCPU_REGS_RCX) & 0xffffffff);\n\t\toutgpa = ((u64)kvm_register_read(vcpu, VCPU_REGS_RDI) << 32) |\n\t\t\t(kvm_register_read(vcpu, VCPU_REGS_RSI) & 0xffffffff);\n\t}\n#ifdef CONFIG_X86_64\n\telse {\n\t\tparam = kvm_register_read(vcpu, VCPU_REGS_RCX);\n\t\tingpa = kvm_register_read(vcpu, VCPU_REGS_RDX);\n\t\toutgpa = kvm_register_read(vcpu, VCPU_REGS_R8);\n\t}\n#endif\n\n\tcode = param & 0xffff;\n\tfast = (param >> 16) & 0x1;\n\trep_cnt = (param >> 32) & 0xfff;\n\trep_idx = (param >> 48) & 0xfff;\n\n\ttrace_kvm_hv_hypercall(code, fast, rep_cnt, rep_idx, ingpa, outgpa);\n\n\t/* Hypercall continuation is not supported yet */\n\tif (rep_cnt || rep_idx) {\n\t\tres = HV_STATUS_INVALID_HYPERCALL_CODE;\n\t\tgoto set_result;\n\t}\n\n\tswitch (code) {\n\tcase HVCALL_NOTIFY_LONG_SPIN_WAIT:\n\t\tkvm_vcpu_on_spin(vcpu);\n\t\tbreak;\n\tcase HVCALL_POST_MESSAGE:\n\tcase HVCALL_SIGNAL_EVENT:\n\t\t/* don't bother userspace if it has no way to handle it */\n\t\tif (!vcpu_to_synic(vcpu)->active) {\n\t\t\tres = HV_STATUS_INVALID_HYPERCALL_CODE;\n\t\t\tbreak;\n\t\t}\n\t\tvcpu->run->exit_reason = KVM_EXIT_HYPERV;\n\t\tvcpu->run->hyperv.type = KVM_EXIT_HYPERV_HCALL;\n\t\tvcpu->run->hyperv.u.hcall.input = param;\n\t\tvcpu->run->hyperv.u.hcall.params[0] = ingpa;\n\t\tvcpu->run->hyperv.u.hcall.params[1] = outgpa;\n\t\tvcpu->arch.complete_userspace_io =\n\t\t\t\tkvm_hv_hypercall_complete_userspace;\n\t\treturn 0;\n\tdefault:\n\t\tres = HV_STATUS_INVALID_HYPERCALL_CODE;\n\t\tbreak;\n\t}\n\nset_result:\n\tret = res | (((u64)rep_done & 0xfff) << 32);\n\tkvm_hv_hypercall_set_result(vcpu, ret);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_hv_hypercall_enabled",
          "args": [
            "vcpu->kvm"
          ],
          "line": 5955
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_hv_hypercall_enabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.c",
          "lines": "1041-1044",
          "snippet": "bool kvm_hv_hypercall_enabled(struct kvm *kvm)\n{\n\treturn kvm->arch.hyperv.hv_hypercall & HV_X64_MSR_HYPERCALL_ENABLE;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nbool kvm_hv_hypercall_enabled(struct kvm *kvm)\n{\n\treturn kvm->arch.hyperv.hv_hypercall & HV_X64_MSR_HYPERCALL_ENABLE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_x86_ops->skip_emulated_instruction",
          "args": [
            "vcpu"
          ],
          "line": 5953
        },
        "resolved": true,
        "details": {
          "function_name": "skip_emulated_instruction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/vmx.c",
          "lines": "2329-2339",
          "snippet": "static void skip_emulated_instruction(struct kvm_vcpu *vcpu)\n{\n\tunsigned long rip;\n\n\trip = kvm_rip_read(vcpu);\n\trip += vmcs_read32(VM_EXIT_INSTRUCTION_LEN);\n\tkvm_rip_write(vcpu, rip);\n\n\t/* skipping an emulated instruction also counts */\n\tvmx_set_interrupt_shadow(vcpu, 0);\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"trace.h\"",
            "#include <asm/irq_remapping.h>",
            "#include <asm/apic.h>",
            "#include <asm/kexec.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/mce.h>",
            "#include <asm/virtext.h>",
            "#include <asm/vmx.h>",
            "#include <asm/desc.h>",
            "#include <asm/io.h>",
            "#include <asm/cpu.h>",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/hrtimer.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include \"lapic.h\"",
            "#include \"cpuid.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long nested_ept_get_cr3(struct kvm_vcpu *vcpu);",
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);",
            "static void ept_save_pdptrs(struct kvm_vcpu *vcpu);",
            "static void vmx_decache_cr0_guest_bits(struct kvm_vcpu *vcpu);",
            "static void vmx_leave_nested(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"trace.h\"\n#include <asm/irq_remapping.h>\n#include <asm/apic.h>\n#include <asm/kexec.h>\n#include <asm/debugreg.h>\n#include <asm/perf_event.h>\n#include <asm/fpu/internal.h>\n#include <asm/mce.h>\n#include <asm/virtext.h>\n#include <asm/vmx.h>\n#include <asm/desc.h>\n#include <asm/io.h>\n#include <asm/cpu.h>\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/hrtimer.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic unsigned long nested_ept_get_cr3(struct kvm_vcpu *vcpu);\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\nstatic void ept_save_pdptrs(struct kvm_vcpu *vcpu);\nstatic void vmx_decache_cr0_guest_bits(struct kvm_vcpu *vcpu);\nstatic void vmx_leave_nested(struct kvm_vcpu *vcpu);\n\nstatic void skip_emulated_instruction(struct kvm_vcpu *vcpu)\n{\n\tunsigned long rip;\n\n\trip = kvm_rip_read(vcpu);\n\trip += vmcs_read32(VM_EXIT_INSTRUCTION_LEN);\n\tkvm_rip_write(vcpu, rip);\n\n\t/* skipping an emulated instruction also counts */\n\tvmx_set_interrupt_shadow(vcpu, 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nint kvm_emulate_hypercall(struct kvm_vcpu *vcpu)\n{\n\tunsigned long nr, a0, a1, a2, a3, ret;\n\tint op_64_bit, r = 1;\n\n\tkvm_x86_ops->skip_emulated_instruction(vcpu);\n\n\tif (kvm_hv_hypercall_enabled(vcpu->kvm))\n\t\treturn kvm_hv_hypercall(vcpu);\n\n\tnr = kvm_register_read(vcpu, VCPU_REGS_RAX);\n\ta0 = kvm_register_read(vcpu, VCPU_REGS_RBX);\n\ta1 = kvm_register_read(vcpu, VCPU_REGS_RCX);\n\ta2 = kvm_register_read(vcpu, VCPU_REGS_RDX);\n\ta3 = kvm_register_read(vcpu, VCPU_REGS_RSI);\n\n\ttrace_kvm_hypercall(nr, a0, a1, a2, a3);\n\n\top_64_bit = is_64_bit_mode(vcpu);\n\tif (!op_64_bit) {\n\t\tnr &= 0xFFFFFFFF;\n\t\ta0 &= 0xFFFFFFFF;\n\t\ta1 &= 0xFFFFFFFF;\n\t\ta2 &= 0xFFFFFFFF;\n\t\ta3 &= 0xFFFFFFFF;\n\t}\n\n\tif (kvm_x86_ops->get_cpl(vcpu) != 0) {\n\t\tret = -KVM_EPERM;\n\t\tgoto out;\n\t}\n\n\tswitch (nr) {\n\tcase KVM_HC_VAPIC_POLL_IRQ:\n\t\tret = 0;\n\t\tbreak;\n\tcase KVM_HC_KICK_CPU:\n\t\tkvm_pv_kick_cpu_op(vcpu->kvm, a0, a1);\n\t\tret = 0;\n\t\tbreak;\n\tdefault:\n\t\tret = -KVM_ENOSYS;\n\t\tbreak;\n\t}\nout:\n\tif (!op_64_bit)\n\t\tret = (u32)ret;\n\tkvm_register_write(vcpu, VCPU_REGS_RAX, ret);\n\t++vcpu->stat.hypercalls;\n\treturn r;\n}"
  },
  {
    "function_name": "kvm_vcpu_deactivate_apicv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "5942-5946",
    "snippet": "void kvm_vcpu_deactivate_apicv(struct kvm_vcpu *vcpu)\n{\n\tvcpu->arch.apicv_active = false;\n\tkvm_x86_ops->refresh_apicv_exec_ctrl(vcpu);\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);",
      "struct kvm_x86_ops *kvm_x86_ops"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_x86_ops->refresh_apicv_exec_ctrl",
          "args": [
            "vcpu"
          ],
          "line": 5945
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nvoid kvm_vcpu_deactivate_apicv(struct kvm_vcpu *vcpu)\n{\n\tvcpu->arch.apicv_active = false;\n\tkvm_x86_ops->refresh_apicv_exec_ctrl(vcpu);\n}"
  },
  {
    "function_name": "kvm_pv_kick_cpu_op",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "5929-5940",
    "snippet": "static void kvm_pv_kick_cpu_op(struct kvm *kvm, unsigned long flags, int apicid)\n{\n\tstruct kvm_lapic_irq lapic_irq;\n\n\tlapic_irq.shorthand = 0;\n\tlapic_irq.dest_mode = 0;\n\tlapic_irq.dest_id = apicid;\n\tlapic_irq.msi_redir_hint = false;\n\n\tlapic_irq.delivery_mode = APIC_DM_REMRD;\n\tkvm_irq_delivery_to_apic(kvm, NULL, &lapic_irq, NULL);\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_irq_delivery_to_apic",
          "args": [
            "kvm",
            "NULL",
            "&lapic_irq",
            "NULL"
          ],
          "line": 5939
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_irq_delivery_to_apic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/irq_comm.c",
          "lines": "56-111",
          "snippet": "int kvm_irq_delivery_to_apic(struct kvm *kvm, struct kvm_lapic *src,\n\t\tstruct kvm_lapic_irq *irq, struct dest_map *dest_map)\n{\n\tint i, r = -1;\n\tstruct kvm_vcpu *vcpu, *lowest = NULL;\n\tunsigned long dest_vcpu_bitmap[BITS_TO_LONGS(KVM_MAX_VCPUS)];\n\tunsigned int dest_vcpus = 0;\n\n\tif (irq->dest_mode == 0 && irq->dest_id == 0xff &&\n\t\t\tkvm_lowest_prio_delivery(irq)) {\n\t\tprintk(KERN_INFO \"kvm: apic: phys broadcast and lowest prio\\n\");\n\t\tirq->delivery_mode = APIC_DM_FIXED;\n\t}\n\n\tif (kvm_irq_delivery_to_apic_fast(kvm, src, irq, &r, dest_map))\n\t\treturn r;\n\n\tmemset(dest_vcpu_bitmap, 0, sizeof(dest_vcpu_bitmap));\n\n\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\tif (!kvm_apic_present(vcpu))\n\t\t\tcontinue;\n\n\t\tif (!kvm_apic_match_dest(vcpu, src, irq->shorthand,\n\t\t\t\t\tirq->dest_id, irq->dest_mode))\n\t\t\tcontinue;\n\n\t\tif (!kvm_lowest_prio_delivery(irq)) {\n\t\t\tif (r < 0)\n\t\t\t\tr = 0;\n\t\t\tr += kvm_apic_set_irq(vcpu, irq, dest_map);\n\t\t} else if (kvm_lapic_enabled(vcpu)) {\n\t\t\tif (!kvm_vector_hashing_enabled()) {\n\t\t\t\tif (!lowest)\n\t\t\t\t\tlowest = vcpu;\n\t\t\t\telse if (kvm_apic_compare_prio(vcpu, lowest) < 0)\n\t\t\t\t\tlowest = vcpu;\n\t\t\t} else {\n\t\t\t\t__set_bit(i, dest_vcpu_bitmap);\n\t\t\t\tdest_vcpus++;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (dest_vcpus != 0) {\n\t\tint idx = kvm_vector_to_index(irq->vector, dest_vcpus,\n\t\t\t\t\tdest_vcpu_bitmap, KVM_MAX_VCPUS);\n\n\t\tlowest = kvm_get_vcpu(kvm, idx);\n\t}\n\n\tif (lowest)\n\t\tr = kvm_apic_set_irq(lowest, irq, dest_map);\n\n\treturn r;\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"hyperv.h\"",
            "#include \"lapic.h\"",
            "#include \"ioapic.h\"",
            "#include \"irq.h\"",
            "#include <asm/msidef.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"hyperv.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include \"irq.h\"\n#include <asm/msidef.h>\n#include <trace/events/kvm.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nint kvm_irq_delivery_to_apic(struct kvm *kvm, struct kvm_lapic *src,\n\t\tstruct kvm_lapic_irq *irq, struct dest_map *dest_map)\n{\n\tint i, r = -1;\n\tstruct kvm_vcpu *vcpu, *lowest = NULL;\n\tunsigned long dest_vcpu_bitmap[BITS_TO_LONGS(KVM_MAX_VCPUS)];\n\tunsigned int dest_vcpus = 0;\n\n\tif (irq->dest_mode == 0 && irq->dest_id == 0xff &&\n\t\t\tkvm_lowest_prio_delivery(irq)) {\n\t\tprintk(KERN_INFO \"kvm: apic: phys broadcast and lowest prio\\n\");\n\t\tirq->delivery_mode = APIC_DM_FIXED;\n\t}\n\n\tif (kvm_irq_delivery_to_apic_fast(kvm, src, irq, &r, dest_map))\n\t\treturn r;\n\n\tmemset(dest_vcpu_bitmap, 0, sizeof(dest_vcpu_bitmap));\n\n\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\tif (!kvm_apic_present(vcpu))\n\t\t\tcontinue;\n\n\t\tif (!kvm_apic_match_dest(vcpu, src, irq->shorthand,\n\t\t\t\t\tirq->dest_id, irq->dest_mode))\n\t\t\tcontinue;\n\n\t\tif (!kvm_lowest_prio_delivery(irq)) {\n\t\t\tif (r < 0)\n\t\t\t\tr = 0;\n\t\t\tr += kvm_apic_set_irq(vcpu, irq, dest_map);\n\t\t} else if (kvm_lapic_enabled(vcpu)) {\n\t\t\tif (!kvm_vector_hashing_enabled()) {\n\t\t\t\tif (!lowest)\n\t\t\t\t\tlowest = vcpu;\n\t\t\t\telse if (kvm_apic_compare_prio(vcpu, lowest) < 0)\n\t\t\t\t\tlowest = vcpu;\n\t\t\t} else {\n\t\t\t\t__set_bit(i, dest_vcpu_bitmap);\n\t\t\t\tdest_vcpus++;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (dest_vcpus != 0) {\n\t\tint idx = kvm_vector_to_index(irq->vector, dest_vcpus,\n\t\t\t\t\tdest_vcpu_bitmap, KVM_MAX_VCPUS);\n\n\t\tlowest = kvm_get_vcpu(kvm, idx);\n\t}\n\n\tif (lowest)\n\t\tr = kvm_apic_set_irq(lowest, irq, dest_map);\n\n\treturn r;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void kvm_pv_kick_cpu_op(struct kvm *kvm, unsigned long flags, int apicid)\n{\n\tstruct kvm_lapic_irq lapic_irq;\n\n\tlapic_irq.shorthand = 0;\n\tlapic_irq.dest_mode = 0;\n\tlapic_irq.dest_id = apicid;\n\tlapic_irq.msi_redir_hint = false;\n\n\tlapic_irq.delivery_mode = APIC_DM_REMRD;\n\tkvm_irq_delivery_to_apic(kvm, NULL, &lapic_irq, NULL);\n}"
  },
  {
    "function_name": "kvm_emulate_halt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "5917-5921",
    "snippet": "int kvm_emulate_halt(struct kvm_vcpu *vcpu)\n{\n\tkvm_x86_ops->skip_emulated_instruction(vcpu);\n\treturn kvm_vcpu_halt(vcpu);\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);",
      "struct kvm_x86_ops *kvm_x86_ops"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_vcpu_halt",
          "args": [
            "vcpu"
          ],
          "line": 5920
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_vcpu_halt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "5904-5914",
          "snippet": "int kvm_vcpu_halt(struct kvm_vcpu *vcpu)\n{\n\t++vcpu->stat.halt_exits;\n\tif (lapic_in_kernel(vcpu)) {\n\t\tvcpu->arch.mp_state = KVM_MP_STATE_HALTED;\n\t\treturn 1;\n\t} else {\n\t\tvcpu->run->exit_reason = KVM_EXIT_HLT;\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nint kvm_vcpu_halt(struct kvm_vcpu *vcpu)\n{\n\t++vcpu->stat.halt_exits;\n\tif (lapic_in_kernel(vcpu)) {\n\t\tvcpu->arch.mp_state = KVM_MP_STATE_HALTED;\n\t\treturn 1;\n\t} else {\n\t\tvcpu->run->exit_reason = KVM_EXIT_HLT;\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_x86_ops->skip_emulated_instruction",
          "args": [
            "vcpu"
          ],
          "line": 5919
        },
        "resolved": true,
        "details": {
          "function_name": "skip_emulated_instruction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/vmx.c",
          "lines": "2329-2339",
          "snippet": "static void skip_emulated_instruction(struct kvm_vcpu *vcpu)\n{\n\tunsigned long rip;\n\n\trip = kvm_rip_read(vcpu);\n\trip += vmcs_read32(VM_EXIT_INSTRUCTION_LEN);\n\tkvm_rip_write(vcpu, rip);\n\n\t/* skipping an emulated instruction also counts */\n\tvmx_set_interrupt_shadow(vcpu, 0);\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"trace.h\"",
            "#include <asm/irq_remapping.h>",
            "#include <asm/apic.h>",
            "#include <asm/kexec.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/mce.h>",
            "#include <asm/virtext.h>",
            "#include <asm/vmx.h>",
            "#include <asm/desc.h>",
            "#include <asm/io.h>",
            "#include <asm/cpu.h>",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/hrtimer.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include \"lapic.h\"",
            "#include \"cpuid.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long nested_ept_get_cr3(struct kvm_vcpu *vcpu);",
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);",
            "static void ept_save_pdptrs(struct kvm_vcpu *vcpu);",
            "static void vmx_decache_cr0_guest_bits(struct kvm_vcpu *vcpu);",
            "static void vmx_leave_nested(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"trace.h\"\n#include <asm/irq_remapping.h>\n#include <asm/apic.h>\n#include <asm/kexec.h>\n#include <asm/debugreg.h>\n#include <asm/perf_event.h>\n#include <asm/fpu/internal.h>\n#include <asm/mce.h>\n#include <asm/virtext.h>\n#include <asm/vmx.h>\n#include <asm/desc.h>\n#include <asm/io.h>\n#include <asm/cpu.h>\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/hrtimer.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic unsigned long nested_ept_get_cr3(struct kvm_vcpu *vcpu);\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\nstatic void ept_save_pdptrs(struct kvm_vcpu *vcpu);\nstatic void vmx_decache_cr0_guest_bits(struct kvm_vcpu *vcpu);\nstatic void vmx_leave_nested(struct kvm_vcpu *vcpu);\n\nstatic void skip_emulated_instruction(struct kvm_vcpu *vcpu)\n{\n\tunsigned long rip;\n\n\trip = kvm_rip_read(vcpu);\n\trip += vmcs_read32(VM_EXIT_INSTRUCTION_LEN);\n\tkvm_rip_write(vcpu, rip);\n\n\t/* skipping an emulated instruction also counts */\n\tvmx_set_interrupt_shadow(vcpu, 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nint kvm_emulate_halt(struct kvm_vcpu *vcpu)\n{\n\tkvm_x86_ops->skip_emulated_instruction(vcpu);\n\treturn kvm_vcpu_halt(vcpu);\n}"
  },
  {
    "function_name": "kvm_vcpu_halt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "5904-5914",
    "snippet": "int kvm_vcpu_halt(struct kvm_vcpu *vcpu)\n{\n\t++vcpu->stat.halt_exits;\n\tif (lapic_in_kernel(vcpu)) {\n\t\tvcpu->arch.mp_state = KVM_MP_STATE_HALTED;\n\t\treturn 1;\n\t} else {\n\t\tvcpu->run->exit_reason = KVM_EXIT_HLT;\n\t\treturn 0;\n\t}\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lapic_in_kernel",
          "args": [
            "vcpu"
          ],
          "line": 5907
        },
        "resolved": true,
        "details": {
          "function_name": "lapic_in_kernel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.h",
          "lines": "141-146",
          "snippet": "static inline bool lapic_in_kernel(struct kvm_vcpu *vcpu)\n{\n\tif (static_key_false(&kvm_no_apic_vcpu))\n\t\treturn vcpu->arch.apic;\n\treturn true;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline bool lapic_in_kernel(struct kvm_vcpu *vcpu)\n{\n\tif (static_key_false(&kvm_no_apic_vcpu))\n\t\treturn vcpu->arch.apic;\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nint kvm_vcpu_halt(struct kvm_vcpu *vcpu)\n{\n\t++vcpu->stat.halt_exits;\n\tif (lapic_in_kernel(vcpu)) {\n\t\tvcpu->arch.mp_state = KVM_MP_STATE_HALTED;\n\t\treturn 1;\n\t} else {\n\t\tvcpu->run->exit_reason = KVM_EXIT_HLT;\n\t\treturn 0;\n\t}\n}"
  },
  {
    "function_name": "kvm_arch_exit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "5888-5902",
    "snippet": "void kvm_arch_exit(void)\n{\n\tperf_unregister_guest_info_callbacks(&kvm_guest_cbs);\n\n\tif (!boot_cpu_has(X86_FEATURE_CONSTANT_TSC))\n\t\tcpufreq_unregister_notifier(&kvmclock_cpufreq_notifier_block,\n\t\t\t\t\t    CPUFREQ_TRANSITION_NOTIFIER);\n\tunregister_hotcpu_notifier(&kvmclock_cpu_notifier_block);\n#ifdef CONFIG_X86_64\n\tpvclock_gtod_unregister_notifier(&pvclock_gtod_notifier);\n#endif\n\tkvm_x86_ops = NULL;\n\tkvm_mmu_module_exit();\n\tfree_percpu(shared_msrs);\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct kvm_x86_ops *kvm_x86_ops",
      "static struct kvm_shared_msrs __percpu *shared_msrs;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_percpu",
          "args": [
            "shared_msrs"
          ],
          "line": 5901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_mmu_module_exit",
          "args": [],
          "line": 5900
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_module_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "5098-5104",
          "snippet": "void kvm_mmu_module_exit(void)\n{\n\tmmu_destroy_caches();\n\tpercpu_counter_destroy(&kvm_total_used_mmu_pages);\n\tunregister_shrinker(&mmu_shrinker);\n\tmmu_audit_disable();\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct percpu_counter kvm_total_used_mmu_pages;",
            "static struct shrinker mmu_shrinker = {\n\t.count_objects = mmu_shrink_count,\n\t.scan_objects = mmu_shrink_scan,\n\t.seeks = DEFAULT_SEEKS * 10,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic struct percpu_counter kvm_total_used_mmu_pages;\nstatic struct shrinker mmu_shrinker = {\n\t.count_objects = mmu_shrink_count,\n\t.scan_objects = mmu_shrink_scan,\n\t.seeks = DEFAULT_SEEKS * 10,\n};\n\nvoid kvm_mmu_module_exit(void)\n{\n\tmmu_destroy_caches();\n\tpercpu_counter_destroy(&kvm_total_used_mmu_pages);\n\tunregister_shrinker(&mmu_shrinker);\n\tmmu_audit_disable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "pvclock_gtod_unregister_notifier",
          "args": [
            "&pvclock_gtod_notifier"
          ],
          "line": 5897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unregister_hotcpu_notifier",
          "args": [
            "&kvmclock_cpu_notifier_block"
          ],
          "line": 5895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpufreq_unregister_notifier",
          "args": [
            "&kvmclock_cpufreq_notifier_block",
            "CPUFREQ_TRANSITION_NOTIFIER"
          ],
          "line": 5893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "boot_cpu_has",
          "args": [
            "X86_FEATURE_CONSTANT_TSC"
          ],
          "line": 5892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perf_unregister_guest_info_callbacks",
          "args": [
            "&kvm_guest_cbs"
          ],
          "line": 5890
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstruct kvm_x86_ops *kvm_x86_ops;\nstatic struct kvm_shared_msrs __percpu *shared_msrs;\n\nvoid kvm_arch_exit(void)\n{\n\tperf_unregister_guest_info_callbacks(&kvm_guest_cbs);\n\n\tif (!boot_cpu_has(X86_FEATURE_CONSTANT_TSC))\n\t\tcpufreq_unregister_notifier(&kvmclock_cpufreq_notifier_block,\n\t\t\t\t\t    CPUFREQ_TRANSITION_NOTIFIER);\n\tunregister_hotcpu_notifier(&kvmclock_cpu_notifier_block);\n#ifdef CONFIG_X86_64\n\tpvclock_gtod_unregister_notifier(&pvclock_gtod_notifier);\n#endif\n\tkvm_x86_ops = NULL;\n\tkvm_mmu_module_exit();\n\tfree_percpu(shared_msrs);\n}"
  },
  {
    "function_name": "kvm_arch_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "5828-5886",
    "snippet": "int kvm_arch_init(void *opaque)\n{\n\tint r;\n\tstruct kvm_x86_ops *ops = opaque;\n\n\tif (kvm_x86_ops) {\n\t\tprintk(KERN_ERR \"kvm: already loaded the other module\\n\");\n\t\tr = -EEXIST;\n\t\tgoto out;\n\t}\n\n\tif (!ops->cpu_has_kvm_support()) {\n\t\tprintk(KERN_ERR \"kvm: no hardware support\\n\");\n\t\tr = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\tif (ops->disabled_by_bios()) {\n\t\tprintk(KERN_ERR \"kvm: disabled by bios\\n\");\n\t\tr = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\tr = -ENOMEM;\n\tshared_msrs = alloc_percpu(struct kvm_shared_msrs);\n\tif (!shared_msrs) {\n\t\tprintk(KERN_ERR \"kvm: failed to allocate percpu kvm_shared_msrs\\n\");\n\t\tgoto out;\n\t}\n\n\tr = kvm_mmu_module_init();\n\tif (r)\n\t\tgoto out_free_percpu;\n\n\tkvm_set_mmio_spte_mask();\n\n\tkvm_x86_ops = ops;\n\n\tkvm_mmu_set_mask_ptes(PT_USER_MASK, PT_ACCESSED_MASK,\n\t\t\tPT_DIRTY_MASK, PT64_NX_MASK, 0);\n\n\tkvm_timer_init();\n\n\tperf_register_guest_info_callbacks(&kvm_guest_cbs);\n\n\tif (cpu_has_xsave)\n\t\thost_xcr0 = xgetbv(XCR_XFEATURE_ENABLED_MASK);\n\n\tkvm_lapic_init();\n#ifdef CONFIG_X86_64\n\tpvclock_gtod_register_notifier(&pvclock_gtod_notifier);\n#endif\n\n\treturn 0;\n\nout_free_percpu:\n\tfree_percpu(shared_msrs);\nout:\n\treturn r;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct kvm_x86_ops *kvm_x86_ops",
      "static struct kvm_shared_msrs __percpu *shared_msrs;",
      "u64 __read_mostly host_xcr0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_percpu",
          "args": [
            "shared_msrs"
          ],
          "line": 5883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pvclock_gtod_register_notifier",
          "args": [
            "&pvclock_gtod_notifier"
          ],
          "line": 5877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_lapic_init",
          "args": [],
          "line": 5875
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "2237-2242",
          "snippet": "void kvm_lapic_init(void)\n{\n\t/* do not patch jump label more than once per second */\n\tjump_label_rate_limit(&apic_hw_disabled, HZ);\n\tjump_label_rate_limit(&apic_sw_disabled, HZ);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct static_key_deferred apic_hw_disabled",
            "struct static_key_deferred apic_sw_disabled"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstruct static_key_deferred apic_hw_disabled;\nstruct static_key_deferred apic_sw_disabled;\n\nvoid kvm_lapic_init(void)\n{\n\t/* do not patch jump label more than once per second */\n\tjump_label_rate_limit(&apic_hw_disabled, HZ);\n\tjump_label_rate_limit(&apic_sw_disabled, HZ);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xgetbv",
          "args": [
            "XCR_XFEATURE_ENABLED_MASK"
          ],
          "line": 5873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perf_register_guest_info_callbacks",
          "args": [
            "&kvm_guest_cbs"
          ],
          "line": 5870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_timer_init",
          "args": [],
          "line": 5868
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_timer_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "5680-5707",
          "snippet": "static void kvm_timer_init(void)\n{\n\tint cpu;\n\n\tmax_tsc_khz = tsc_khz;\n\n\tcpu_notifier_register_begin();\n\tif (!boot_cpu_has(X86_FEATURE_CONSTANT_TSC)) {\n#ifdef CONFIG_CPU_FREQ\n\t\tstruct cpufreq_policy policy;\n\t\tmemset(&policy, 0, sizeof(policy));\n\t\tcpu = get_cpu();\n\t\tcpufreq_get_policy(&policy, cpu);\n\t\tif (policy.cpuinfo.max_freq)\n\t\t\tmax_tsc_khz = policy.cpuinfo.max_freq;\n\t\tput_cpu();\n#endif\n\t\tcpufreq_register_notifier(&kvmclock_cpufreq_notifier_block,\n\t\t\t\t\t  CPUFREQ_TRANSITION_NOTIFIER);\n\t}\n\tpr_debug(\"kvm: max_tsc_khz = %ld\\n\", max_tsc_khz);\n\tfor_each_online_cpu(cpu)\n\t\tsmp_call_function_single(cpu, tsc_khz_changed, NULL, 1);\n\n\t__register_hotcpu_notifier(&kvmclock_cpu_notifier_block);\n\tcpu_notifier_register_done();\n\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long max_tsc_khz;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic unsigned long max_tsc_khz;\n\nstatic void kvm_timer_init(void)\n{\n\tint cpu;\n\n\tmax_tsc_khz = tsc_khz;\n\n\tcpu_notifier_register_begin();\n\tif (!boot_cpu_has(X86_FEATURE_CONSTANT_TSC)) {\n#ifdef CONFIG_CPU_FREQ\n\t\tstruct cpufreq_policy policy;\n\t\tmemset(&policy, 0, sizeof(policy));\n\t\tcpu = get_cpu();\n\t\tcpufreq_get_policy(&policy, cpu);\n\t\tif (policy.cpuinfo.max_freq)\n\t\t\tmax_tsc_khz = policy.cpuinfo.max_freq;\n\t\tput_cpu();\n#endif\n\t\tcpufreq_register_notifier(&kvmclock_cpufreq_notifier_block,\n\t\t\t\t\t  CPUFREQ_TRANSITION_NOTIFIER);\n\t}\n\tpr_debug(\"kvm: max_tsc_khz = %ld\\n\", max_tsc_khz);\n\tfor_each_online_cpu(cpu)\n\t\tsmp_call_function_single(cpu, tsc_khz_changed, NULL, 1);\n\n\t__register_hotcpu_notifier(&kvmclock_cpu_notifier_block);\n\tcpu_notifier_register_done();\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_mmu_set_mask_ptes",
          "args": [
            "PT_USER_MASK",
            "PT_ACCESSED_MASK",
            "PT_DIRTY_MASK",
            "PT64_NX_MASK",
            "0"
          ],
          "line": 5865
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_set_mask_ptes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "284-292",
          "snippet": "void kvm_mmu_set_mask_ptes(u64 user_mask, u64 accessed_mask,\n\t\tu64 dirty_mask, u64 nx_mask, u64 x_mask)\n{\n\tshadow_user_mask = user_mask;\n\tshadow_accessed_mask = accessed_mask;\n\tshadow_dirty_mask = dirty_mask;\n\tshadow_nx_mask = nx_mask;\n\tshadow_x_mask = x_mask;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nvoid kvm_mmu_set_mask_ptes(u64 user_mask, u64 accessed_mask,\n\t\tu64 dirty_mask, u64 nx_mask, u64 x_mask)\n{\n\tshadow_user_mask = user_mask;\n\tshadow_accessed_mask = accessed_mask;\n\tshadow_dirty_mask = dirty_mask;\n\tshadow_nx_mask = nx_mask;\n\tshadow_x_mask = x_mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_set_mmio_spte_mask",
          "args": [],
          "line": 5861
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_set_mmio_spte_mask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "5754-5782",
          "snippet": "static void kvm_set_mmio_spte_mask(void)\n{\n\tu64 mask;\n\tint maxphyaddr = boot_cpu_data.x86_phys_bits;\n\n\t/*\n\t * Set the reserved bits and the present bit of an paging-structure\n\t * entry to generate page fault with PFER.RSV = 1.\n\t */\n\t /* Mask the reserved physical address bits. */\n\tmask = rsvd_bits(maxphyaddr, 51);\n\n\t/* Bit 62 is always reserved for 32bit host. */\n\tmask |= 0x3ull << 62;\n\n\t/* Set the present bit. */\n\tmask |= 1ull;\n\n#ifdef CONFIG_X86_64\n\t/*\n\t * If reserved bit is not supported, clear the present bit to disable\n\t * mmio page fault.\n\t */\n\tif (maxphyaddr == 52)\n\t\tmask &= ~1ull;\n#endif\n\n\tkvm_mmu_set_mmio_spte_mask(mask);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void kvm_set_mmio_spte_mask(void)\n{\n\tu64 mask;\n\tint maxphyaddr = boot_cpu_data.x86_phys_bits;\n\n\t/*\n\t * Set the reserved bits and the present bit of an paging-structure\n\t * entry to generate page fault with PFER.RSV = 1.\n\t */\n\t /* Mask the reserved physical address bits. */\n\tmask = rsvd_bits(maxphyaddr, 51);\n\n\t/* Bit 62 is always reserved for 32bit host. */\n\tmask |= 0x3ull << 62;\n\n\t/* Set the present bit. */\n\tmask |= 1ull;\n\n#ifdef CONFIG_X86_64\n\t/*\n\t * If reserved bit is not supported, clear the present bit to disable\n\t * mmio page fault.\n\t */\n\tif (maxphyaddr == 52)\n\t\tmask &= ~1ull;\n#endif\n\n\tkvm_mmu_set_mmio_spte_mask(mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_mmu_module_init",
          "args": [],
          "line": 5857
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_module_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "5040-5064",
          "snippet": "int kvm_mmu_module_init(void)\n{\n\tpte_list_desc_cache = kmem_cache_create(\"pte_list_desc\",\n\t\t\t\t\t    sizeof(struct pte_list_desc),\n\t\t\t\t\t    0, 0, NULL);\n\tif (!pte_list_desc_cache)\n\t\tgoto nomem;\n\n\tmmu_page_header_cache = kmem_cache_create(\"kvm_mmu_page_header\",\n\t\t\t\t\t\t  sizeof(struct kvm_mmu_page),\n\t\t\t\t\t\t  0, 0, NULL);\n\tif (!mmu_page_header_cache)\n\t\tgoto nomem;\n\n\tif (percpu_counter_init(&kvm_total_used_mmu_pages, 0, GFP_KERNEL))\n\t\tgoto nomem;\n\n\tregister_shrinker(&mmu_shrinker);\n\n\treturn 0;\n\nnomem:\n\tmmu_destroy_caches();\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *pte_list_desc_cache;",
            "static struct kmem_cache *mmu_page_header_cache;",
            "static struct percpu_counter kvm_total_used_mmu_pages;",
            "static struct shrinker mmu_shrinker = {\n\t.count_objects = mmu_shrink_count,\n\t.scan_objects = mmu_shrink_scan,\n\t.seeks = DEFAULT_SEEKS * 10,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic struct kmem_cache *pte_list_desc_cache;\nstatic struct kmem_cache *mmu_page_header_cache;\nstatic struct percpu_counter kvm_total_used_mmu_pages;\nstatic struct shrinker mmu_shrinker = {\n\t.count_objects = mmu_shrink_count,\n\t.scan_objects = mmu_shrink_scan,\n\t.seeks = DEFAULT_SEEKS * 10,\n};\n\nint kvm_mmu_module_init(void)\n{\n\tpte_list_desc_cache = kmem_cache_create(\"pte_list_desc\",\n\t\t\t\t\t    sizeof(struct pte_list_desc),\n\t\t\t\t\t    0, 0, NULL);\n\tif (!pte_list_desc_cache)\n\t\tgoto nomem;\n\n\tmmu_page_header_cache = kmem_cache_create(\"kvm_mmu_page_header\",\n\t\t\t\t\t\t  sizeof(struct kvm_mmu_page),\n\t\t\t\t\t\t  0, 0, NULL);\n\tif (!mmu_page_header_cache)\n\t\tgoto nomem;\n\n\tif (percpu_counter_init(&kvm_total_used_mmu_pages, 0, GFP_KERNEL))\n\t\tgoto nomem;\n\n\tregister_shrinker(&mmu_shrinker);\n\n\treturn 0;\n\nnomem:\n\tmmu_destroy_caches();\n\treturn -ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"kvm: failed to allocate percpu kvm_shared_msrs\\n\""
          ],
          "line": 5853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_percpu",
          "args": [
            "structkvm_shared_msrs"
          ],
          "line": 5851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"kvm: disabled by bios\\n\""
          ],
          "line": 5845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ops->disabled_by_bios",
          "args": [],
          "line": 5844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"kvm: no hardware support\\n\""
          ],
          "line": 5840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ops->cpu_has_kvm_support",
          "args": [],
          "line": 5839
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_has_kvm_support",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/vmx.c",
          "lines": "3072-3075",
          "snippet": "static __init int cpu_has_kvm_support(void)\n{\n\treturn cpu_has_vmx();\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"trace.h\"",
            "#include <asm/irq_remapping.h>",
            "#include <asm/apic.h>",
            "#include <asm/kexec.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/mce.h>",
            "#include <asm/virtext.h>",
            "#include <asm/vmx.h>",
            "#include <asm/desc.h>",
            "#include <asm/io.h>",
            "#include <asm/cpu.h>",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/hrtimer.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include \"lapic.h\"",
            "#include \"cpuid.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"trace.h\"\n#include <asm/irq_remapping.h>\n#include <asm/apic.h>\n#include <asm/kexec.h>\n#include <asm/debugreg.h>\n#include <asm/perf_event.h>\n#include <asm/fpu/internal.h>\n#include <asm/mce.h>\n#include <asm/virtext.h>\n#include <asm/vmx.h>\n#include <asm/desc.h>\n#include <asm/io.h>\n#include <asm/cpu.h>\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/hrtimer.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic __init int cpu_has_kvm_support(void)\n{\n\treturn cpu_has_vmx();\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"kvm: already loaded the other module\\n\""
          ],
          "line": 5834
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstruct kvm_x86_ops *kvm_x86_ops;\nstatic struct kvm_shared_msrs __percpu *shared_msrs;\nu64 __read_mostly host_xcr0;\n\nint kvm_arch_init(void *opaque)\n{\n\tint r;\n\tstruct kvm_x86_ops *ops = opaque;\n\n\tif (kvm_x86_ops) {\n\t\tprintk(KERN_ERR \"kvm: already loaded the other module\\n\");\n\t\tr = -EEXIST;\n\t\tgoto out;\n\t}\n\n\tif (!ops->cpu_has_kvm_support()) {\n\t\tprintk(KERN_ERR \"kvm: no hardware support\\n\");\n\t\tr = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\tif (ops->disabled_by_bios()) {\n\t\tprintk(KERN_ERR \"kvm: disabled by bios\\n\");\n\t\tr = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\tr = -ENOMEM;\n\tshared_msrs = alloc_percpu(struct kvm_shared_msrs);\n\tif (!shared_msrs) {\n\t\tprintk(KERN_ERR \"kvm: failed to allocate percpu kvm_shared_msrs\\n\");\n\t\tgoto out;\n\t}\n\n\tr = kvm_mmu_module_init();\n\tif (r)\n\t\tgoto out_free_percpu;\n\n\tkvm_set_mmio_spte_mask();\n\n\tkvm_x86_ops = ops;\n\n\tkvm_mmu_set_mask_ptes(PT_USER_MASK, PT_ACCESSED_MASK,\n\t\t\tPT_DIRTY_MASK, PT64_NX_MASK, 0);\n\n\tkvm_timer_init();\n\n\tperf_register_guest_info_callbacks(&kvm_guest_cbs);\n\n\tif (cpu_has_xsave)\n\t\thost_xcr0 = xgetbv(XCR_XFEATURE_ENABLED_MASK);\n\n\tkvm_lapic_init();\n#ifdef CONFIG_X86_64\n\tpvclock_gtod_register_notifier(&pvclock_gtod_notifier);\n#endif\n\n\treturn 0;\n\nout_free_percpu:\n\tfree_percpu(shared_msrs);\nout:\n\treturn r;\n}"
  },
  {
    "function_name": "pvclock_gtod_notify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "5805-5821",
    "snippet": "static int pvclock_gtod_notify(struct notifier_block *nb, unsigned long unused,\n\t\t\t       void *priv)\n{\n\tstruct pvclock_gtod_data *gtod = &pvclock_gtod_data;\n\tstruct timekeeper *tk = priv;\n\n\tupdate_pvclock_gtod(tk);\n\n\t/* disable master clock if host does not trust, or does not\n\t * use, TSC clocksource\n\t */\n\tif (gtod->clock.vclock_mode != VCLOCK_TSC &&\n\t    atomic_read(&kvm_guest_has_master_clock) != 0)\n\t\tqueue_work(system_long_wq, &pvclock_gtod_work);\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "queue_work",
          "args": [
            "system_long_wq",
            "&pvclock_gtod_work"
          ],
          "line": 5818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&kvm_guest_has_master_clock"
          ],
          "line": 5817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "update_pvclock_gtod",
          "args": [
            "tk"
          ],
          "line": 5811
        },
        "resolved": true,
        "details": {
          "function_name": "update_pvclock_gtod",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "1126-1146",
          "snippet": "static void update_pvclock_gtod(struct timekeeper *tk)\n{\n\tstruct pvclock_gtod_data *vdata = &pvclock_gtod_data;\n\tu64 boot_ns;\n\n\tboot_ns = ktime_to_ns(ktime_add(tk->tkr_mono.base, tk->offs_boot));\n\n\twrite_seqcount_begin(&vdata->seq);\n\n\t/* copy pvclock gtod data */\n\tvdata->clock.vclock_mode\t= tk->tkr_mono.clock->archdata.vclock_mode;\n\tvdata->clock.cycle_last\t\t= tk->tkr_mono.cycle_last;\n\tvdata->clock.mask\t\t= tk->tkr_mono.mask;\n\tvdata->clock.mult\t\t= tk->tkr_mono.mult;\n\tvdata->clock.shift\t\t= tk->tkr_mono.shift;\n\n\tvdata->boot_ns\t\t\t= boot_ns;\n\tvdata->nsec_base\t\t= tk->tkr_mono.xtime_nsec;\n\n\twrite_seqcount_end(&vdata->seq);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_pvclock_gtod(struct timekeeper *tk)\n{\n\tstruct pvclock_gtod_data *vdata = &pvclock_gtod_data;\n\tu64 boot_ns;\n\n\tboot_ns = ktime_to_ns(ktime_add(tk->tkr_mono.base, tk->offs_boot));\n\n\twrite_seqcount_begin(&vdata->seq);\n\n\t/* copy pvclock gtod data */\n\tvdata->clock.vclock_mode\t= tk->tkr_mono.clock->archdata.vclock_mode;\n\tvdata->clock.cycle_last\t\t= tk->tkr_mono.cycle_last;\n\tvdata->clock.mask\t\t= tk->tkr_mono.mask;\n\tvdata->clock.mult\t\t= tk->tkr_mono.mult;\n\tvdata->clock.shift\t\t= tk->tkr_mono.shift;\n\n\tvdata->boot_ns\t\t\t= boot_ns;\n\tvdata->nsec_base\t\t= tk->tkr_mono.xtime_nsec;\n\n\twrite_seqcount_end(&vdata->seq);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int pvclock_gtod_notify(struct notifier_block *nb, unsigned long unused,\n\t\t\t       void *priv)\n{\n\tstruct pvclock_gtod_data *gtod = &pvclock_gtod_data;\n\tstruct timekeeper *tk = priv;\n\n\tupdate_pvclock_gtod(tk);\n\n\t/* disable master clock if host does not trust, or does not\n\t * use, TSC clocksource\n\t */\n\tif (gtod->clock.vclock_mode != VCLOCK_TSC &&\n\t    atomic_read(&kvm_guest_has_master_clock) != 0)\n\t\tqueue_work(system_long_wq, &pvclock_gtod_work);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "pvclock_gtod_update_fn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "5785-5798",
    "snippet": "static void pvclock_gtod_update_fn(struct work_struct *work)\n{\n\tstruct kvm *kvm;\n\n\tstruct kvm_vcpu *vcpu;\n\tint i;\n\n\tspin_lock(&kvm_lock);\n\tlist_for_each_entry(kvm, &vm_list, vm_list)\n\t\tkvm_for_each_vcpu(i, vcpu, kvm)\n\t\t\tkvm_make_request(KVM_REQ_MASTERCLOCK_UPDATE, vcpu);\n\tatomic_set(&kvm_guest_has_master_clock, 0);\n\tspin_unlock(&kvm_lock);\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&kvm_lock"
          ],
          "line": 5797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&kvm_guest_has_master_clock",
            "0"
          ],
          "line": 5796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_make_request",
          "args": [
            "KVM_REQ_MASTERCLOCK_UPDATE",
            "vcpu"
          ],
          "line": 5795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_for_each_vcpu",
          "args": [
            "i",
            "vcpu",
            "kvm"
          ],
          "line": 5794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "kvm",
            "&vm_list",
            "vm_list"
          ],
          "line": 5793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&kvm_lock"
          ],
          "line": 5792
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic void pvclock_gtod_update_fn(struct work_struct *work)\n{\n\tstruct kvm *kvm;\n\n\tstruct kvm_vcpu *vcpu;\n\tint i;\n\n\tspin_lock(&kvm_lock);\n\tlist_for_each_entry(kvm, &vm_list, vm_list)\n\t\tkvm_for_each_vcpu(i, vcpu, kvm)\n\t\t\tkvm_make_request(KVM_REQ_MASTERCLOCK_UPDATE, vcpu);\n\tatomic_set(&kvm_guest_has_master_clock, 0);\n\tspin_unlock(&kvm_lock);\n}"
  },
  {
    "function_name": "kvm_set_mmio_spte_mask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "5754-5782",
    "snippet": "static void kvm_set_mmio_spte_mask(void)\n{\n\tu64 mask;\n\tint maxphyaddr = boot_cpu_data.x86_phys_bits;\n\n\t/*\n\t * Set the reserved bits and the present bit of an paging-structure\n\t * entry to generate page fault with PFER.RSV = 1.\n\t */\n\t /* Mask the reserved physical address bits. */\n\tmask = rsvd_bits(maxphyaddr, 51);\n\n\t/* Bit 62 is always reserved for 32bit host. */\n\tmask |= 0x3ull << 62;\n\n\t/* Set the present bit. */\n\tmask |= 1ull;\n\n#ifdef CONFIG_X86_64\n\t/*\n\t * If reserved bit is not supported, clear the present bit to disable\n\t * mmio page fault.\n\t */\n\tif (maxphyaddr == 52)\n\t\tmask &= ~1ull;\n#endif\n\n\tkvm_mmu_set_mmio_spte_mask(mask);\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_mmu_set_mmio_spte_mask",
          "args": [
            "mask"
          ],
          "line": 5781
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_set_mmio_spte_mask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "182-185",
          "snippet": "void kvm_mmu_set_mmio_spte_mask(u64 mmio_mask)\n{\n\tshadow_mmio_mask = mmio_mask;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nvoid kvm_mmu_set_mmio_spte_mask(u64 mmio_mask)\n{\n\tshadow_mmio_mask = mmio_mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rsvd_bits",
          "args": [
            "maxphyaddr",
            "51"
          ],
          "line": 5764
        },
        "resolved": true,
        "details": {
          "function_name": "rsvd_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.h",
          "lines": "49-52",
          "snippet": "static inline u64 rsvd_bits(int s, int e)\n{\n\treturn ((1ULL << (e - s + 1)) - 1) << s;\n}",
          "includes": [
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline u64 rsvd_bits(int s, int e)\n{\n\treturn ((1ULL << (e - s + 1)) - 1) << s;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void kvm_set_mmio_spte_mask(void)\n{\n\tu64 mask;\n\tint maxphyaddr = boot_cpu_data.x86_phys_bits;\n\n\t/*\n\t * Set the reserved bits and the present bit of an paging-structure\n\t * entry to generate page fault with PFER.RSV = 1.\n\t */\n\t /* Mask the reserved physical address bits. */\n\tmask = rsvd_bits(maxphyaddr, 51);\n\n\t/* Bit 62 is always reserved for 32bit host. */\n\tmask |= 0x3ull << 62;\n\n\t/* Set the present bit. */\n\tmask |= 1ull;\n\n#ifdef CONFIG_X86_64\n\t/*\n\t * If reserved bit is not supported, clear the present bit to disable\n\t * mmio page fault.\n\t */\n\tif (maxphyaddr == 52)\n\t\tmask &= ~1ull;\n#endif\n\n\tkvm_mmu_set_mmio_spte_mask(mask);\n}"
  },
  {
    "function_name": "kvm_after_handle_nmi",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "5748-5751",
    "snippet": "void kvm_after_handle_nmi(struct kvm_vcpu *vcpu)\n{\n\t__this_cpu_write(current_vcpu, NULL);\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__this_cpu_write",
          "args": [
            "current_vcpu",
            "NULL"
          ],
          "line": 5750
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nvoid kvm_after_handle_nmi(struct kvm_vcpu *vcpu)\n{\n\t__this_cpu_write(current_vcpu, NULL);\n}"
  },
  {
    "function_name": "kvm_before_handle_nmi",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "5742-5745",
    "snippet": "void kvm_before_handle_nmi(struct kvm_vcpu *vcpu)\n{\n\t__this_cpu_write(current_vcpu, vcpu);\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__this_cpu_write",
          "args": [
            "current_vcpu",
            "vcpu"
          ],
          "line": 5744
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nvoid kvm_before_handle_nmi(struct kvm_vcpu *vcpu)\n{\n\t__this_cpu_write(current_vcpu, vcpu);\n}"
  },
  {
    "function_name": "kvm_get_guest_ip",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "5726-5734",
    "snippet": "static unsigned long kvm_get_guest_ip(void)\n{\n\tunsigned long ip = 0;\n\n\tif (__this_cpu_read(current_vcpu))\n\t\tip = kvm_rip_read(__this_cpu_read(current_vcpu));\n\n\treturn ip;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_rip_read",
          "args": [
            "__this_cpu_read(current_vcpu)"
          ],
          "line": 5731
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_rip_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "27-30",
          "snippet": "static inline unsigned long kvm_rip_read(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_register_read(vcpu, VCPU_REGS_RIP);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline unsigned long kvm_rip_read(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_register_read(vcpu, VCPU_REGS_RIP);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__this_cpu_read",
          "args": [
            "current_vcpu"
          ],
          "line": 5731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_read",
          "args": [
            "current_vcpu"
          ],
          "line": 5730
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic unsigned long kvm_get_guest_ip(void)\n{\n\tunsigned long ip = 0;\n\n\tif (__this_cpu_read(current_vcpu))\n\t\tip = kvm_rip_read(__this_cpu_read(current_vcpu));\n\n\treturn ip;\n}"
  },
  {
    "function_name": "kvm_is_user_mode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "5716-5724",
    "snippet": "static int kvm_is_user_mode(void)\n{\n\tint user_mode = 3;\n\n\tif (__this_cpu_read(current_vcpu))\n\t\tuser_mode = kvm_x86_ops->get_cpl(__this_cpu_read(current_vcpu));\n\n\treturn user_mode != 0;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct kvm_x86_ops *kvm_x86_ops"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_x86_ops->get_cpl",
          "args": [
            "__this_cpu_read(current_vcpu)"
          ],
          "line": 5721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_read",
          "args": [
            "current_vcpu"
          ],
          "line": 5721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_read",
          "args": [
            "current_vcpu"
          ],
          "line": 5720
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstruct kvm_x86_ops *kvm_x86_ops;\n\nstatic int kvm_is_user_mode(void)\n{\n\tint user_mode = 3;\n\n\tif (__this_cpu_read(current_vcpu))\n\t\tuser_mode = kvm_x86_ops->get_cpl(__this_cpu_read(current_vcpu));\n\n\treturn user_mode != 0;\n}"
  },
  {
    "function_name": "kvm_is_in_guest",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "5711-5714",
    "snippet": "int kvm_is_in_guest(void)\n{\n\treturn __this_cpu_read(current_vcpu) != NULL;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__this_cpu_read",
          "args": [
            "current_vcpu"
          ],
          "line": 5713
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nint kvm_is_in_guest(void)\n{\n\treturn __this_cpu_read(current_vcpu) != NULL;\n}"
  },
  {
    "function_name": "kvm_timer_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "5680-5707",
    "snippet": "static void kvm_timer_init(void)\n{\n\tint cpu;\n\n\tmax_tsc_khz = tsc_khz;\n\n\tcpu_notifier_register_begin();\n\tif (!boot_cpu_has(X86_FEATURE_CONSTANT_TSC)) {\n#ifdef CONFIG_CPU_FREQ\n\t\tstruct cpufreq_policy policy;\n\t\tmemset(&policy, 0, sizeof(policy));\n\t\tcpu = get_cpu();\n\t\tcpufreq_get_policy(&policy, cpu);\n\t\tif (policy.cpuinfo.max_freq)\n\t\t\tmax_tsc_khz = policy.cpuinfo.max_freq;\n\t\tput_cpu();\n#endif\n\t\tcpufreq_register_notifier(&kvmclock_cpufreq_notifier_block,\n\t\t\t\t\t  CPUFREQ_TRANSITION_NOTIFIER);\n\t}\n\tpr_debug(\"kvm: max_tsc_khz = %ld\\n\", max_tsc_khz);\n\tfor_each_online_cpu(cpu)\n\t\tsmp_call_function_single(cpu, tsc_khz_changed, NULL, 1);\n\n\t__register_hotcpu_notifier(&kvmclock_cpu_notifier_block);\n\tcpu_notifier_register_done();\n\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned long max_tsc_khz;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_notifier_register_done",
          "args": [],
          "line": 5705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"kvm: max_tsc_khz = %ld\\n\"",
            "max_tsc_khz"
          ],
          "line": 5700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpufreq_register_notifier",
          "args": [
            "&kvmclock_cpufreq_notifier_block",
            "CPUFREQ_TRANSITION_NOTIFIER"
          ],
          "line": 5697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_cpu",
          "args": [],
          "line": 5695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpufreq_get_policy",
          "args": [
            "&policy",
            "cpu"
          ],
          "line": 5692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_cpu",
          "args": [],
          "line": 5691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&policy",
            "0",
            "sizeof(policy)"
          ],
          "line": 5690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "boot_cpu_has",
          "args": [
            "X86_FEATURE_CONSTANT_TSC"
          ],
          "line": 5687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_notifier_register_begin",
          "args": [],
          "line": 5686
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic unsigned long max_tsc_khz;\n\nstatic void kvm_timer_init(void)\n{\n\tint cpu;\n\n\tmax_tsc_khz = tsc_khz;\n\n\tcpu_notifier_register_begin();\n\tif (!boot_cpu_has(X86_FEATURE_CONSTANT_TSC)) {\n#ifdef CONFIG_CPU_FREQ\n\t\tstruct cpufreq_policy policy;\n\t\tmemset(&policy, 0, sizeof(policy));\n\t\tcpu = get_cpu();\n\t\tcpufreq_get_policy(&policy, cpu);\n\t\tif (policy.cpuinfo.max_freq)\n\t\t\tmax_tsc_khz = policy.cpuinfo.max_freq;\n\t\tput_cpu();\n#endif\n\t\tcpufreq_register_notifier(&kvmclock_cpufreq_notifier_block,\n\t\t\t\t\t  CPUFREQ_TRANSITION_NOTIFIER);\n\t}\n\tpr_debug(\"kvm: max_tsc_khz = %ld\\n\", max_tsc_khz);\n\tfor_each_online_cpu(cpu)\n\t\tsmp_call_function_single(cpu, tsc_khz_changed, NULL, 1);\n\n\t__register_hotcpu_notifier(&kvmclock_cpu_notifier_block);\n\tcpu_notifier_register_done();\n\n}"
  },
  {
    "function_name": "kvmclock_cpu_notifier",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "5658-5673",
    "snippet": "static int kvmclock_cpu_notifier(struct notifier_block *nfb,\n\t\t\t\t\tunsigned long action, void *hcpu)\n{\n\tunsigned int cpu = (unsigned long)hcpu;\n\n\tswitch (action) {\n\t\tcase CPU_ONLINE:\n\t\tcase CPU_DOWN_FAILED:\n\t\t\tsmp_call_function_single(cpu, tsc_khz_changed, NULL, 1);\n\t\t\tbreak;\n\t\tcase CPU_DOWN_PREPARE:\n\t\t\tsmp_call_function_single(cpu, tsc_bad, NULL, 1);\n\t\t\tbreak;\n\t}\n\treturn NOTIFY_OK;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smp_call_function_single",
          "args": [
            "cpu",
            "tsc_bad",
            "NULL",
            "1"
          ],
          "line": 5669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_call_function_single",
          "args": [
            "cpu",
            "tsc_khz_changed",
            "NULL",
            "1"
          ],
          "line": 5666
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int kvmclock_cpu_notifier(struct notifier_block *nfb,\n\t\t\t\t\tunsigned long action, void *hcpu)\n{\n\tunsigned int cpu = (unsigned long)hcpu;\n\n\tswitch (action) {\n\t\tcase CPU_ONLINE:\n\t\tcase CPU_DOWN_FAILED:\n\t\t\tsmp_call_function_single(cpu, tsc_khz_changed, NULL, 1);\n\t\t\tbreak;\n\t\tcase CPU_DOWN_PREPARE:\n\t\t\tsmp_call_function_single(cpu, tsc_bad, NULL, 1);\n\t\t\tbreak;\n\t}\n\treturn NOTIFY_OK;\n}"
  },
  {
    "function_name": "kvmclock_cpufreq_notifier",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "5570-5652",
    "snippet": "static int kvmclock_cpufreq_notifier(struct notifier_block *nb, unsigned long val,\n\t\t\t\t     void *data)\n{\n\tstruct cpufreq_freqs *freq = data;\n\tstruct kvm *kvm;\n\tstruct kvm_vcpu *vcpu;\n\tint i, send_ipi = 0;\n\n\t/*\n\t * We allow guests to temporarily run on slowing clocks,\n\t * provided we notify them after, or to run on accelerating\n\t * clocks, provided we notify them before.  Thus time never\n\t * goes backwards.\n\t *\n\t * However, we have a problem.  We can't atomically update\n\t * the frequency of a given CPU from this function; it is\n\t * merely a notifier, which can be called from any CPU.\n\t * Changing the TSC frequency at arbitrary points in time\n\t * requires a recomputation of local variables related to\n\t * the TSC for each VCPU.  We must flag these local variables\n\t * to be updated and be sure the update takes place with the\n\t * new frequency before any guests proceed.\n\t *\n\t * Unfortunately, the combination of hotplug CPU and frequency\n\t * change creates an intractable locking scenario; the order\n\t * of when these callouts happen is undefined with respect to\n\t * CPU hotplug, and they can race with each other.  As such,\n\t * merely setting per_cpu(cpu_tsc_khz) = X during a hotadd is\n\t * undefined; you can actually have a CPU frequency change take\n\t * place in between the computation of X and the setting of the\n\t * variable.  To protect against this problem, all updates of\n\t * the per_cpu tsc_khz variable are done in an interrupt\n\t * protected IPI, and all callers wishing to update the value\n\t * must wait for a synchronous IPI to complete (which is trivial\n\t * if the caller is on the CPU already).  This establishes the\n\t * necessary total order on variable updates.\n\t *\n\t * Note that because a guest time update may take place\n\t * anytime after the setting of the VCPU's request bit, the\n\t * correct TSC value must be set before the request.  However,\n\t * to ensure the update actually makes it to any guest which\n\t * starts running in hardware virtualization between the set\n\t * and the acquisition of the spinlock, we must also ping the\n\t * CPU after setting the request bit.\n\t *\n\t */\n\n\tif (val == CPUFREQ_PRECHANGE && freq->old > freq->new)\n\t\treturn 0;\n\tif (val == CPUFREQ_POSTCHANGE && freq->old < freq->new)\n\t\treturn 0;\n\n\tsmp_call_function_single(freq->cpu, tsc_khz_changed, freq, 1);\n\n\tspin_lock(&kvm_lock);\n\tlist_for_each_entry(kvm, &vm_list, vm_list) {\n\t\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\t\tif (vcpu->cpu != freq->cpu)\n\t\t\t\tcontinue;\n\t\t\tkvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);\n\t\t\tif (vcpu->cpu != smp_processor_id())\n\t\t\t\tsend_ipi = 1;\n\t\t}\n\t}\n\tspin_unlock(&kvm_lock);\n\n\tif (freq->old < freq->new && send_ipi) {\n\t\t/*\n\t\t * We upscale the frequency.  Must make the guest\n\t\t * doesn't see old kvmclock values while running with\n\t\t * the new frequency, otherwise we risk the guest sees\n\t\t * time go backwards.\n\t\t *\n\t\t * In case we update the frequency for another cpu\n\t\t * (which might be in guest context) send an interrupt\n\t\t * to kick the cpu out of guest context.  Next time\n\t\t * guest context is entered kvmclock will be updated,\n\t\t * so the guest will not see stale values.\n\t\t */\n\t\tsmp_call_function_single(freq->cpu, tsc_khz_changed, freq, 1);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);",
      "static DEFINE_PER_CPU(unsigned long, cpu_tsc_khz);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "smp_call_function_single",
          "args": [
            "freq->cpu",
            "tsc_khz_changed",
            "freq",
            "1"
          ],
          "line": 5649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&kvm_lock"
          ],
          "line": 5634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 5630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_make_request",
          "args": [
            "KVM_REQ_CLOCK_UPDATE",
            "vcpu"
          ],
          "line": 5629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_for_each_vcpu",
          "args": [
            "i",
            "vcpu",
            "kvm"
          ],
          "line": 5626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "kvm",
            "&vm_list",
            "vm_list"
          ],
          "line": 5625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&kvm_lock"
          ],
          "line": 5624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_call_function_single",
          "args": [
            "freq->cpu",
            "tsc_khz_changed",
            "freq",
            "1"
          ],
          "line": 5622
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic DEFINE_PER_CPU(unsigned long, cpu_tsc_khz);\n\nstatic int kvmclock_cpufreq_notifier(struct notifier_block *nb, unsigned long val,\n\t\t\t\t     void *data)\n{\n\tstruct cpufreq_freqs *freq = data;\n\tstruct kvm *kvm;\n\tstruct kvm_vcpu *vcpu;\n\tint i, send_ipi = 0;\n\n\t/*\n\t * We allow guests to temporarily run on slowing clocks,\n\t * provided we notify them after, or to run on accelerating\n\t * clocks, provided we notify them before.  Thus time never\n\t * goes backwards.\n\t *\n\t * However, we have a problem.  We can't atomically update\n\t * the frequency of a given CPU from this function; it is\n\t * merely a notifier, which can be called from any CPU.\n\t * Changing the TSC frequency at arbitrary points in time\n\t * requires a recomputation of local variables related to\n\t * the TSC for each VCPU.  We must flag these local variables\n\t * to be updated and be sure the update takes place with the\n\t * new frequency before any guests proceed.\n\t *\n\t * Unfortunately, the combination of hotplug CPU and frequency\n\t * change creates an intractable locking scenario; the order\n\t * of when these callouts happen is undefined with respect to\n\t * CPU hotplug, and they can race with each other.  As such,\n\t * merely setting per_cpu(cpu_tsc_khz) = X during a hotadd is\n\t * undefined; you can actually have a CPU frequency change take\n\t * place in between the computation of X and the setting of the\n\t * variable.  To protect against this problem, all updates of\n\t * the per_cpu tsc_khz variable are done in an interrupt\n\t * protected IPI, and all callers wishing to update the value\n\t * must wait for a synchronous IPI to complete (which is trivial\n\t * if the caller is on the CPU already).  This establishes the\n\t * necessary total order on variable updates.\n\t *\n\t * Note that because a guest time update may take place\n\t * anytime after the setting of the VCPU's request bit, the\n\t * correct TSC value must be set before the request.  However,\n\t * to ensure the update actually makes it to any guest which\n\t * starts running in hardware virtualization between the set\n\t * and the acquisition of the spinlock, we must also ping the\n\t * CPU after setting the request bit.\n\t *\n\t */\n\n\tif (val == CPUFREQ_PRECHANGE && freq->old > freq->new)\n\t\treturn 0;\n\tif (val == CPUFREQ_POSTCHANGE && freq->old < freq->new)\n\t\treturn 0;\n\n\tsmp_call_function_single(freq->cpu, tsc_khz_changed, freq, 1);\n\n\tspin_lock(&kvm_lock);\n\tlist_for_each_entry(kvm, &vm_list, vm_list) {\n\t\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\t\tif (vcpu->cpu != freq->cpu)\n\t\t\t\tcontinue;\n\t\t\tkvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);\n\t\t\tif (vcpu->cpu != smp_processor_id())\n\t\t\t\tsend_ipi = 1;\n\t\t}\n\t}\n\tspin_unlock(&kvm_lock);\n\n\tif (freq->old < freq->new && send_ipi) {\n\t\t/*\n\t\t * We upscale the frequency.  Must make the guest\n\t\t * doesn't see old kvmclock values while running with\n\t\t * the new frequency, otherwise we risk the guest sees\n\t\t * time go backwards.\n\t\t *\n\t\t * In case we update the frequency for another cpu\n\t\t * (which might be in guest context) send an interrupt\n\t\t * to kick the cpu out of guest context.  Next time\n\t\t * guest context is entered kvmclock will be updated,\n\t\t * so the guest will not see stale values.\n\t\t */\n\t\tsmp_call_function_single(freq->cpu, tsc_khz_changed, freq, 1);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "tsc_khz_changed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "5556-5568",
    "snippet": "static void tsc_khz_changed(void *data)\n{\n\tstruct cpufreq_freqs *freq = data;\n\tunsigned long khz = 0;\n\n\tif (data)\n\t\tkhz = freq->new;\n\telse if (!boot_cpu_has(X86_FEATURE_CONSTANT_TSC))\n\t\tkhz = cpufreq_quick_get(raw_smp_processor_id());\n\tif (!khz)\n\t\tkhz = tsc_khz;\n\t__this_cpu_write(cpu_tsc_khz, khz);\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(unsigned long, cpu_tsc_khz);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__this_cpu_write",
          "args": [
            "cpu_tsc_khz",
            "khz"
          ],
          "line": 5567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpufreq_quick_get",
          "args": [
            "raw_smp_processor_id()"
          ],
          "line": 5564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 5564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "boot_cpu_has",
          "args": [
            "X86_FEATURE_CONSTANT_TSC"
          ],
          "line": 5563
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic DEFINE_PER_CPU(unsigned long, cpu_tsc_khz);\n\nstatic void tsc_khz_changed(void *data)\n{\n\tstruct cpufreq_freqs *freq = data;\n\tunsigned long khz = 0;\n\n\tif (data)\n\t\tkhz = freq->new;\n\telse if (!boot_cpu_has(X86_FEATURE_CONSTANT_TSC))\n\t\tkhz = cpufreq_quick_get(raw_smp_processor_id());\n\tif (!khz)\n\t\tkhz = tsc_khz;\n\t__this_cpu_write(cpu_tsc_khz, khz);\n}"
  },
  {
    "function_name": "tsc_bad",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "5551-5554",
    "snippet": "static void tsc_bad(void *info)\n{\n\t__this_cpu_write(cpu_tsc_khz, 0);\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(unsigned long, cpu_tsc_khz);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__this_cpu_write",
          "args": [
            "cpu_tsc_khz",
            "0"
          ],
          "line": 5553
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic DEFINE_PER_CPU(unsigned long, cpu_tsc_khz);\n\nstatic void tsc_bad(void *info)\n{\n\t__this_cpu_write(cpu_tsc_khz, 0);\n}"
  },
  {
    "function_name": "kvm_fast_pio_out",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "5540-5548",
    "snippet": "int kvm_fast_pio_out(struct kvm_vcpu *vcpu, int size, unsigned short port)\n{\n\tunsigned long val = kvm_register_read(vcpu, VCPU_REGS_RAX);\n\tint ret = emulator_pio_out_emulated(&vcpu->arch.emulate_ctxt,\n\t\t\t\t\t    size, port, &val, 1);\n\t/* do not return to emulator after return from userspace */\n\tvcpu->arch.pio.count = 0;\n\treturn ret;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "emulator_pio_out_emulated",
          "args": [
            "&vcpu->arch.emulate_ctxt",
            "size",
            "port",
            "&val",
            "1"
          ],
          "line": 5543
        },
        "resolved": true,
        "details": {
          "function_name": "emulator_pio_out_emulated",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "4703-4712",
          "snippet": "static int emulator_pio_out_emulated(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t     int size, unsigned short port,\n\t\t\t\t     const void *val, unsigned int count)\n{\n\tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n\n\tmemcpy(vcpu->arch.pio_data, val, size * count);\n\ttrace_kvm_pio(KVM_PIO_OUT, port, size, count, vcpu->arch.pio_data);\n\treturn emulator_pio_in_out(vcpu, size, port, (void *)val, count, false);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);\n\nstatic int emulator_pio_out_emulated(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t     int size, unsigned short port,\n\t\t\t\t     const void *val, unsigned int count)\n{\n\tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n\n\tmemcpy(vcpu->arch.pio_data, val, size * count);\n\ttrace_kvm_pio(KVM_PIO_OUT, port, size, count, vcpu->arch.pio_data);\n\treturn emulator_pio_in_out(vcpu, size, port, (void *)val, count, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_register_read",
          "args": [
            "vcpu",
            "VCPU_REGS_RAX"
          ],
          "line": 5542
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_register_readl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.h",
          "lines": "133-139",
          "snippet": "static inline unsigned long kvm_register_readl(struct kvm_vcpu *vcpu,\n\t\t\t\t\t       enum kvm_reg reg)\n{\n\tunsigned long val = kvm_register_read(vcpu, reg);\n\n\treturn is_64_bit_mode(vcpu) ? val : (u32)val;\n}",
          "includes": [
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline unsigned long kvm_register_readl(struct kvm_vcpu *vcpu,\n\t\t\t\t\t       enum kvm_reg reg)\n{\n\tunsigned long val = kvm_register_read(vcpu, reg);\n\n\treturn is_64_bit_mode(vcpu) ? val : (u32)val;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nint kvm_fast_pio_out(struct kvm_vcpu *vcpu, int size, unsigned short port)\n{\n\tunsigned long val = kvm_register_read(vcpu, VCPU_REGS_RAX);\n\tint ret = emulator_pio_out_emulated(&vcpu->arch.emulate_ctxt,\n\t\t\t\t\t    size, port, &val, 1);\n\t/* do not return to emulator after return from userspace */\n\tvcpu->arch.pio.count = 0;\n\treturn ret;\n}"
  },
  {
    "function_name": "x86_emulate_instruction",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "5405-5537",
    "snippet": "int x86_emulate_instruction(struct kvm_vcpu *vcpu,\n\t\t\t    unsigned long cr2,\n\t\t\t    int emulation_type,\n\t\t\t    void *insn,\n\t\t\t    int insn_len)\n{\n\tint r;\n\tstruct x86_emulate_ctxt *ctxt = &vcpu->arch.emulate_ctxt;\n\tbool writeback = true;\n\tbool write_fault_to_spt = vcpu->arch.write_fault_to_shadow_pgtable;\n\n\t/*\n\t * Clear write_fault_to_shadow_pgtable here to ensure it is\n\t * never reused.\n\t */\n\tvcpu->arch.write_fault_to_shadow_pgtable = false;\n\tkvm_clear_exception_queue(vcpu);\n\n\tif (!(emulation_type & EMULTYPE_NO_DECODE)) {\n\t\tinit_emulate_ctxt(vcpu);\n\n\t\t/*\n\t\t * We will reenter on the same instruction since\n\t\t * we do not set complete_userspace_io.  This does not\n\t\t * handle watchpoints yet, those would be handled in\n\t\t * the emulate_ops.\n\t\t */\n\t\tif (kvm_vcpu_check_breakpoint(vcpu, &r))\n\t\t\treturn r;\n\n\t\tctxt->interruptibility = 0;\n\t\tctxt->have_exception = false;\n\t\tctxt->exception.vector = -1;\n\t\tctxt->perm_ok = false;\n\n\t\tctxt->ud = emulation_type & EMULTYPE_TRAP_UD;\n\n\t\tr = x86_decode_insn(ctxt, insn, insn_len);\n\n\t\ttrace_kvm_emulate_insn_start(vcpu);\n\t\t++vcpu->stat.insn_emulation;\n\t\tif (r != EMULATION_OK)  {\n\t\t\tif (emulation_type & EMULTYPE_TRAP_UD)\n\t\t\t\treturn EMULATE_FAIL;\n\t\t\tif (reexecute_instruction(vcpu, cr2, write_fault_to_spt,\n\t\t\t\t\t\temulation_type))\n\t\t\t\treturn EMULATE_DONE;\n\t\t\tif (emulation_type & EMULTYPE_SKIP)\n\t\t\t\treturn EMULATE_FAIL;\n\t\t\treturn handle_emulation_failure(vcpu);\n\t\t}\n\t}\n\n\tif (emulation_type & EMULTYPE_SKIP) {\n\t\tkvm_rip_write(vcpu, ctxt->_eip);\n\t\tif (ctxt->eflags & X86_EFLAGS_RF)\n\t\t\tkvm_set_rflags(vcpu, ctxt->eflags & ~X86_EFLAGS_RF);\n\t\treturn EMULATE_DONE;\n\t}\n\n\tif (retry_instruction(ctxt, cr2, emulation_type))\n\t\treturn EMULATE_DONE;\n\n\t/* this is needed for vmware backdoor interface to work since it\n\t   changes registers values  during IO operation */\n\tif (vcpu->arch.emulate_regs_need_sync_from_vcpu) {\n\t\tvcpu->arch.emulate_regs_need_sync_from_vcpu = false;\n\t\temulator_invalidate_register_cache(ctxt);\n\t}\n\nrestart:\n\tr = x86_emulate_insn(ctxt);\n\n\tif (r == EMULATION_INTERCEPTED)\n\t\treturn EMULATE_DONE;\n\n\tif (r == EMULATION_FAILED) {\n\t\tif (reexecute_instruction(vcpu, cr2, write_fault_to_spt,\n\t\t\t\t\temulation_type))\n\t\t\treturn EMULATE_DONE;\n\n\t\treturn handle_emulation_failure(vcpu);\n\t}\n\n\tif (ctxt->have_exception) {\n\t\tr = EMULATE_DONE;\n\t\tif (inject_emulated_exception(vcpu))\n\t\t\treturn r;\n\t} else if (vcpu->arch.pio.count) {\n\t\tif (!vcpu->arch.pio.in) {\n\t\t\t/* FIXME: return into emulator if single-stepping.  */\n\t\t\tvcpu->arch.pio.count = 0;\n\t\t} else {\n\t\t\twriteback = false;\n\t\t\tvcpu->arch.complete_userspace_io = complete_emulated_pio;\n\t\t}\n\t\tr = EMULATE_USER_EXIT;\n\t} else if (vcpu->mmio_needed) {\n\t\tif (!vcpu->mmio_is_write)\n\t\t\twriteback = false;\n\t\tr = EMULATE_USER_EXIT;\n\t\tvcpu->arch.complete_userspace_io = complete_emulated_mmio;\n\t} else if (r == EMULATION_RESTART)\n\t\tgoto restart;\n\telse\n\t\tr = EMULATE_DONE;\n\n\tif (writeback) {\n\t\tunsigned long rflags = kvm_x86_ops->get_rflags(vcpu);\n\t\ttoggle_interruptibility(vcpu, ctxt->interruptibility);\n\t\tvcpu->arch.emulate_regs_need_sync_to_vcpu = false;\n\t\tif (vcpu->arch.hflags != ctxt->emul_flags)\n\t\t\tkvm_set_hflags(vcpu, ctxt->emul_flags);\n\t\tkvm_rip_write(vcpu, ctxt->eip);\n\t\tif (r == EMULATE_DONE)\n\t\t\tkvm_vcpu_check_singlestep(vcpu, rflags, &r);\n\t\tif (!ctxt->have_exception ||\n\t\t    exception_type(ctxt->exception.vector) == EXCPT_TRAP)\n\t\t\t__kvm_set_rflags(vcpu, ctxt->eflags);\n\n\t\t/*\n\t\t * For STI, interrupts are shadowed; so KVM_REQ_EVENT will\n\t\t * do nothing, and it will be requested again as soon as\n\t\t * the shadow expires.  But we still need to check here,\n\t\t * because POPF has no interrupt shadow.\n\t\t */\n\t\tif (unlikely((ctxt->eflags & ~rflags) & X86_EFLAGS_IF))\n\t\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t} else\n\t\tvcpu->arch.emulate_regs_need_sync_to_vcpu = true;\n\n\treturn r;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define EXCPT_TRAP\t\t1"
    ],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);",
      "static void __kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags);",
      "struct kvm_x86_ops *kvm_x86_ops",
      "static int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_make_request",
          "args": [
            "KVM_REQ_EVENT",
            "vcpu"
          ],
          "line": 5532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "(ctxt->eflags & ~rflags) & X86_EFLAGS_IF"
          ],
          "line": 5531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__kvm_set_rflags",
          "args": [
            "vcpu",
            "ctxt->eflags"
          ],
          "line": 5523
        },
        "resolved": true,
        "details": {
          "function_name": "__kvm_set_rflags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "8174-8180",
          "snippet": "static void __kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags)\n{\n\tif (vcpu->guest_debug & KVM_GUESTDBG_SINGLESTEP &&\n\t    kvm_is_linear_rip(vcpu, vcpu->arch.singlestep_rip))\n\t\trflags |= X86_EFLAGS_TF;\n\tkvm_x86_ops->set_rflags(vcpu, rflags);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void __kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags);",
            "struct kvm_x86_ops *kvm_x86_ops"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void __kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nstatic void __kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags)\n{\n\tif (vcpu->guest_debug & KVM_GUESTDBG_SINGLESTEP &&\n\t    kvm_is_linear_rip(vcpu, vcpu->arch.singlestep_rip))\n\t\trflags |= X86_EFLAGS_TF;\n\tkvm_x86_ops->set_rflags(vcpu, rflags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "exception_type",
          "args": [
            "ctxt->exception.vector"
          ],
          "line": 5522
        },
        "resolved": true,
        "details": {
          "function_name": "exception_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "345-363",
          "snippet": "static int exception_type(int vector)\n{\n\tunsigned int mask;\n\n\tif (WARN_ON(vector > 31 || vector == NMI_VECTOR))\n\t\treturn EXCPT_INTERRUPT;\n\n\tmask = 1 << vector;\n\n\t/* #DB is trap, as instruction watchpoints are handled elsewhere */\n\tif (mask & ((1 << DB_VECTOR) | (1 << BP_VECTOR) | (1 << OF_VECTOR)))\n\t\treturn EXCPT_TRAP;\n\n\tif (mask & ((1 << DF_VECTOR) | (1 << MC_VECTOR)))\n\t\treturn EXCPT_ABORT;\n\n\t/* Reserved exceptions will result in fault */\n\treturn EXCPT_FAULT;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define EXCPT_INTERRUPT\t\t3",
            "#define EXCPT_ABORT\t\t2",
            "#define EXCPT_TRAP\t\t1",
            "#define EXCPT_FAULT\t\t0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define EXCPT_INTERRUPT\t\t3\n#define EXCPT_ABORT\t\t2\n#define EXCPT_TRAP\t\t1\n#define EXCPT_FAULT\t\t0\n\nstatic int exception_type(int vector)\n{\n\tunsigned int mask;\n\n\tif (WARN_ON(vector > 31 || vector == NMI_VECTOR))\n\t\treturn EXCPT_INTERRUPT;\n\n\tmask = 1 << vector;\n\n\t/* #DB is trap, as instruction watchpoints are handled elsewhere */\n\tif (mask & ((1 << DB_VECTOR) | (1 << BP_VECTOR) | (1 << OF_VECTOR)))\n\t\treturn EXCPT_TRAP;\n\n\tif (mask & ((1 << DF_VECTOR) | (1 << MC_VECTOR)))\n\t\treturn EXCPT_ABORT;\n\n\t/* Reserved exceptions will result in fault */\n\treturn EXCPT_FAULT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_check_singlestep",
          "args": [
            "vcpu",
            "rflags",
            "&r"
          ],
          "line": 5520
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_vcpu_check_singlestep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "5332-5364",
          "snippet": "static void kvm_vcpu_check_singlestep(struct kvm_vcpu *vcpu, unsigned long rflags, int *r)\n{\n\tstruct kvm_run *kvm_run = vcpu->run;\n\n\t/*\n\t * rflags is the old, \"raw\" value of the flags.  The new value has\n\t * not been saved yet.\n\t *\n\t * This is correct even for TF set by the guest, because \"the\n\t * processor will not generate this exception after the instruction\n\t * that sets the TF flag\".\n\t */\n\tif (unlikely(rflags & X86_EFLAGS_TF)) {\n\t\tif (vcpu->guest_debug & KVM_GUESTDBG_SINGLESTEP) {\n\t\t\tkvm_run->debug.arch.dr6 = DR6_BS | DR6_FIXED_1 |\n\t\t\t\t\t\t  DR6_RTM;\n\t\t\tkvm_run->debug.arch.pc = vcpu->arch.singlestep_rip;\n\t\t\tkvm_run->debug.arch.exception = DB_VECTOR;\n\t\t\tkvm_run->exit_reason = KVM_EXIT_DEBUG;\n\t\t\t*r = EMULATE_USER_EXIT;\n\t\t} else {\n\t\t\tvcpu->arch.emulate_ctxt.eflags &= ~X86_EFLAGS_TF;\n\t\t\t/*\n\t\t\t * \"Certain debug exceptions may clear bit 0-3.  The\n\t\t\t * remaining contents of the DR6 register are never\n\t\t\t * cleared by the processor\".\n\t\t\t */\n\t\t\tvcpu->arch.dr6 &= ~15;\n\t\t\tvcpu->arch.dr6 |= DR6_BS | DR6_RTM;\n\t\t\tkvm_queue_exception(vcpu, DB_VECTOR);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void __kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void __kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags);\n\nstatic void kvm_vcpu_check_singlestep(struct kvm_vcpu *vcpu, unsigned long rflags, int *r)\n{\n\tstruct kvm_run *kvm_run = vcpu->run;\n\n\t/*\n\t * rflags is the old, \"raw\" value of the flags.  The new value has\n\t * not been saved yet.\n\t *\n\t * This is correct even for TF set by the guest, because \"the\n\t * processor will not generate this exception after the instruction\n\t * that sets the TF flag\".\n\t */\n\tif (unlikely(rflags & X86_EFLAGS_TF)) {\n\t\tif (vcpu->guest_debug & KVM_GUESTDBG_SINGLESTEP) {\n\t\t\tkvm_run->debug.arch.dr6 = DR6_BS | DR6_FIXED_1 |\n\t\t\t\t\t\t  DR6_RTM;\n\t\t\tkvm_run->debug.arch.pc = vcpu->arch.singlestep_rip;\n\t\t\tkvm_run->debug.arch.exception = DB_VECTOR;\n\t\t\tkvm_run->exit_reason = KVM_EXIT_DEBUG;\n\t\t\t*r = EMULATE_USER_EXIT;\n\t\t} else {\n\t\t\tvcpu->arch.emulate_ctxt.eflags &= ~X86_EFLAGS_TF;\n\t\t\t/*\n\t\t\t * \"Certain debug exceptions may clear bit 0-3.  The\n\t\t\t * remaining contents of the DR6 register are never\n\t\t\t * cleared by the processor\".\n\t\t\t */\n\t\t\tvcpu->arch.dr6 &= ~15;\n\t\t\tvcpu->arch.dr6 |= DR6_BS | DR6_RTM;\n\t\t\tkvm_queue_exception(vcpu, DB_VECTOR);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_rip_write",
          "args": [
            "vcpu",
            "ctxt->eip"
          ],
          "line": 5518
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_rip_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "32-35",
          "snippet": "static inline void kvm_rip_write(struct kvm_vcpu *vcpu, unsigned long val)\n{\n\tkvm_register_write(vcpu, VCPU_REGS_RIP, val);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void kvm_rip_write(struct kvm_vcpu *vcpu, unsigned long val)\n{\n\tkvm_register_write(vcpu, VCPU_REGS_RIP, val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_set_hflags",
          "args": [
            "vcpu",
            "ctxt->emul_flags"
          ],
          "line": 5517
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_set_hflags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "5307-5315",
          "snippet": "static void kvm_set_hflags(struct kvm_vcpu *vcpu, unsigned emul_flags)\n{\n\tunsigned changed = vcpu->arch.hflags ^ emul_flags;\n\n\tvcpu->arch.hflags = emul_flags;\n\n\tif (changed & HF_SMM_MASK)\n\t\tkvm_smm_changed(vcpu);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic void kvm_set_hflags(struct kvm_vcpu *vcpu, unsigned emul_flags)\n{\n\tunsigned changed = vcpu->arch.hflags ^ emul_flags;\n\n\tvcpu->arch.hflags = emul_flags;\n\n\tif (changed & HF_SMM_MASK)\n\t\tkvm_smm_changed(vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "toggle_interruptibility",
          "args": [
            "vcpu",
            "ctxt->interruptibility"
          ],
          "line": 5514
        },
        "resolved": true,
        "details": {
          "function_name": "toggle_interruptibility",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "5070-5087",
          "snippet": "static void toggle_interruptibility(struct kvm_vcpu *vcpu, u32 mask)\n{\n\tu32 int_shadow = kvm_x86_ops->get_interrupt_shadow(vcpu);\n\t/*\n\t * an sti; sti; sequence only disable interrupts for the first\n\t * instruction. So, if the last instruction, be it emulated or\n\t * not, left the system with the INT_STI flag enabled, it\n\t * means that the last instruction is an sti. We should not\n\t * leave the flag on in this case. The same goes for mov ss\n\t */\n\tif (int_shadow & mask)\n\t\tmask = 0;\n\tif (unlikely(int_shadow || mask)) {\n\t\tkvm_x86_ops->set_interrupt_shadow(vcpu, mask);\n\t\tif (!mask)\n\t\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t}\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "struct kvm_x86_ops *kvm_x86_ops"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nstatic void toggle_interruptibility(struct kvm_vcpu *vcpu, u32 mask)\n{\n\tu32 int_shadow = kvm_x86_ops->get_interrupt_shadow(vcpu);\n\t/*\n\t * an sti; sti; sequence only disable interrupts for the first\n\t * instruction. So, if the last instruction, be it emulated or\n\t * not, left the system with the INT_STI flag enabled, it\n\t * means that the last instruction is an sti. We should not\n\t * leave the flag on in this case. The same goes for mov ss\n\t */\n\tif (int_shadow & mask)\n\t\tmask = 0;\n\tif (unlikely(int_shadow || mask)) {\n\t\tkvm_x86_ops->set_interrupt_shadow(vcpu, mask);\n\t\tif (!mask)\n\t\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_x86_ops->get_rflags",
          "args": [
            "vcpu"
          ],
          "line": 5513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inject_emulated_exception",
          "args": [
            "vcpu"
          ],
          "line": 5491
        },
        "resolved": true,
        "details": {
          "function_name": "inject_emulated_exception",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "5089-5101",
          "snippet": "static bool inject_emulated_exception(struct kvm_vcpu *vcpu)\n{\n\tstruct x86_emulate_ctxt *ctxt = &vcpu->arch.emulate_ctxt;\n\tif (ctxt->exception.vector == PF_VECTOR)\n\t\treturn kvm_propagate_fault(vcpu, &ctxt->exception);\n\n\tif (ctxt->exception.error_code_valid)\n\t\tkvm_queue_exception_e(vcpu, ctxt->exception.vector,\n\t\t\t\t      ctxt->exception.error_code);\n\telse\n\t\tkvm_queue_exception(vcpu, ctxt->exception.vector);\n\treturn false;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);\n\nstatic bool inject_emulated_exception(struct kvm_vcpu *vcpu)\n{\n\tstruct x86_emulate_ctxt *ctxt = &vcpu->arch.emulate_ctxt;\n\tif (ctxt->exception.vector == PF_VECTOR)\n\t\treturn kvm_propagate_fault(vcpu, &ctxt->exception);\n\n\tif (ctxt->exception.error_code_valid)\n\t\tkvm_queue_exception_e(vcpu, ctxt->exception.vector,\n\t\t\t\t      ctxt->exception.error_code);\n\telse\n\t\tkvm_queue_exception(vcpu, ctxt->exception.vector);\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "handle_emulation_failure",
          "args": [
            "vcpu"
          ],
          "line": 5486
        },
        "resolved": true,
        "details": {
          "function_name": "handle_emulation_failure",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "5154-5169",
          "snippet": "static int handle_emulation_failure(struct kvm_vcpu *vcpu)\n{\n\tint r = EMULATE_DONE;\n\n\t++vcpu->stat.insn_emulation_fail;\n\ttrace_kvm_emulate_insn_failed(vcpu);\n\tif (!is_guest_mode(vcpu) && kvm_x86_ops->get_cpl(vcpu) == 0) {\n\t\tvcpu->run->exit_reason = KVM_EXIT_INTERNAL_ERROR;\n\t\tvcpu->run->internal.suberror = KVM_INTERNAL_ERROR_EMULATION;\n\t\tvcpu->run->internal.ndata = 0;\n\t\tr = EMULATE_FAIL;\n\t}\n\tkvm_queue_exception(vcpu, UD_VECTOR);\n\n\treturn r;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "struct kvm_x86_ops *kvm_x86_ops"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nstatic int handle_emulation_failure(struct kvm_vcpu *vcpu)\n{\n\tint r = EMULATE_DONE;\n\n\t++vcpu->stat.insn_emulation_fail;\n\ttrace_kvm_emulate_insn_failed(vcpu);\n\tif (!is_guest_mode(vcpu) && kvm_x86_ops->get_cpl(vcpu) == 0) {\n\t\tvcpu->run->exit_reason = KVM_EXIT_INTERNAL_ERROR;\n\t\tvcpu->run->internal.suberror = KVM_INTERNAL_ERROR_EMULATION;\n\t\tvcpu->run->internal.ndata = 0;\n\t\tr = EMULATE_FAIL;\n\t}\n\tkvm_queue_exception(vcpu, UD_VECTOR);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reexecute_instruction",
          "args": [
            "vcpu",
            "cr2",
            "write_fault_to_spt",
            "emulation_type"
          ],
          "line": 5482
        },
        "resolved": true,
        "details": {
          "function_name": "reexecute_instruction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "5171-5240",
          "snippet": "static bool reexecute_instruction(struct kvm_vcpu *vcpu, gva_t cr2,\n\t\t\t\t  bool write_fault_to_shadow_pgtable,\n\t\t\t\t  int emulation_type)\n{\n\tgpa_t gpa = cr2;\n\tkvm_pfn_t pfn;\n\n\tif (emulation_type & EMULTYPE_NO_REEXECUTE)\n\t\treturn false;\n\n\tif (!vcpu->arch.mmu.direct_map) {\n\t\t/*\n\t\t * Write permission should be allowed since only\n\t\t * write access need to be emulated.\n\t\t */\n\t\tgpa = kvm_mmu_gva_to_gpa_write(vcpu, cr2, NULL);\n\n\t\t/*\n\t\t * If the mapping is invalid in guest, let cpu retry\n\t\t * it to generate fault.\n\t\t */\n\t\tif (gpa == UNMAPPED_GVA)\n\t\t\treturn true;\n\t}\n\n\t/*\n\t * Do not retry the unhandleable instruction if it faults on the\n\t * readonly host memory, otherwise it will goto a infinite loop:\n\t * retry instruction -> write #PF -> emulation fail -> retry\n\t * instruction -> ...\n\t */\n\tpfn = gfn_to_pfn(vcpu->kvm, gpa_to_gfn(gpa));\n\n\t/*\n\t * If the instruction failed on the error pfn, it can not be fixed,\n\t * report the error to userspace.\n\t */\n\tif (is_error_noslot_pfn(pfn))\n\t\treturn false;\n\n\tkvm_release_pfn_clean(pfn);\n\n\t/* The instructions are well-emulated on direct mmu. */\n\tif (vcpu->arch.mmu.direct_map) {\n\t\tunsigned int indirect_shadow_pages;\n\n\t\tspin_lock(&vcpu->kvm->mmu_lock);\n\t\tindirect_shadow_pages = vcpu->kvm->arch.indirect_shadow_pages;\n\t\tspin_unlock(&vcpu->kvm->mmu_lock);\n\n\t\tif (indirect_shadow_pages)\n\t\t\tkvm_mmu_unprotect_page(vcpu->kvm, gpa_to_gfn(gpa));\n\n\t\treturn true;\n\t}\n\n\t/*\n\t * if emulation was due to access to shadowed page table\n\t * and it failed try to unshadow page and re-enter the\n\t * guest to let CPU execute the instruction.\n\t */\n\tkvm_mmu_unprotect_page(vcpu->kvm, gpa_to_gfn(gpa));\n\n\t/*\n\t * If the access faults on its page table, it can not\n\t * be fixed by unprotecting shadow page and it should\n\t * be reported to userspace.\n\t */\n\treturn !write_fault_to_shadow_pgtable;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic bool reexecute_instruction(struct kvm_vcpu *vcpu, gva_t cr2,\n\t\t\t\t  bool write_fault_to_shadow_pgtable,\n\t\t\t\t  int emulation_type)\n{\n\tgpa_t gpa = cr2;\n\tkvm_pfn_t pfn;\n\n\tif (emulation_type & EMULTYPE_NO_REEXECUTE)\n\t\treturn false;\n\n\tif (!vcpu->arch.mmu.direct_map) {\n\t\t/*\n\t\t * Write permission should be allowed since only\n\t\t * write access need to be emulated.\n\t\t */\n\t\tgpa = kvm_mmu_gva_to_gpa_write(vcpu, cr2, NULL);\n\n\t\t/*\n\t\t * If the mapping is invalid in guest, let cpu retry\n\t\t * it to generate fault.\n\t\t */\n\t\tif (gpa == UNMAPPED_GVA)\n\t\t\treturn true;\n\t}\n\n\t/*\n\t * Do not retry the unhandleable instruction if it faults on the\n\t * readonly host memory, otherwise it will goto a infinite loop:\n\t * retry instruction -> write #PF -> emulation fail -> retry\n\t * instruction -> ...\n\t */\n\tpfn = gfn_to_pfn(vcpu->kvm, gpa_to_gfn(gpa));\n\n\t/*\n\t * If the instruction failed on the error pfn, it can not be fixed,\n\t * report the error to userspace.\n\t */\n\tif (is_error_noslot_pfn(pfn))\n\t\treturn false;\n\n\tkvm_release_pfn_clean(pfn);\n\n\t/* The instructions are well-emulated on direct mmu. */\n\tif (vcpu->arch.mmu.direct_map) {\n\t\tunsigned int indirect_shadow_pages;\n\n\t\tspin_lock(&vcpu->kvm->mmu_lock);\n\t\tindirect_shadow_pages = vcpu->kvm->arch.indirect_shadow_pages;\n\t\tspin_unlock(&vcpu->kvm->mmu_lock);\n\n\t\tif (indirect_shadow_pages)\n\t\t\tkvm_mmu_unprotect_page(vcpu->kvm, gpa_to_gfn(gpa));\n\n\t\treturn true;\n\t}\n\n\t/*\n\t * if emulation was due to access to shadowed page table\n\t * and it failed try to unshadow page and re-enter the\n\t * guest to let CPU execute the instruction.\n\t */\n\tkvm_mmu_unprotect_page(vcpu->kvm, gpa_to_gfn(gpa));\n\n\t/*\n\t * If the access faults on its page table, it can not\n\t * be fixed by unprotecting shadow page and it should\n\t * be reported to userspace.\n\t */\n\treturn !write_fault_to_shadow_pgtable;\n}"
        }
      },
      {
        "call_info": {
          "callee": "x86_emulate_insn",
          "args": [
            "ctxt"
          ],
          "line": 5476
        },
        "resolved": true,
        "details": {
          "function_name": "x86_emulate_insn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "5136-5486",
          "snippet": "int x86_emulate_insn(struct x86_emulate_ctxt *ctxt)\n{\n\tconst struct x86_emulate_ops *ops = ctxt->ops;\n\tint rc = X86EMUL_CONTINUE;\n\tint saved_dst_type = ctxt->dst.type;\n\n\tctxt->mem_read.pos = 0;\n\n\t/* LOCK prefix is allowed only with some instructions */\n\tif (ctxt->lock_prefix && (!(ctxt->d & Lock) || ctxt->dst.type != OP_MEM)) {\n\t\trc = emulate_ud(ctxt);\n\t\tgoto done;\n\t}\n\n\tif ((ctxt->d & SrcMask) == SrcMemFAddr && ctxt->src.type != OP_MEM) {\n\t\trc = emulate_ud(ctxt);\n\t\tgoto done;\n\t}\n\n\tif (unlikely(ctxt->d &\n\t\t     (No64|Undefined|Sse|Mmx|Intercept|CheckPerm|Priv|Prot|String))) {\n\t\tif ((ctxt->mode == X86EMUL_MODE_PROT64 && (ctxt->d & No64)) ||\n\t\t\t\t(ctxt->d & Undefined)) {\n\t\t\trc = emulate_ud(ctxt);\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (((ctxt->d & (Sse|Mmx)) && ((ops->get_cr(ctxt, 0) & X86_CR0_EM)))\n\t\t    || ((ctxt->d & Sse) && !(ops->get_cr(ctxt, 4) & X86_CR4_OSFXSR))) {\n\t\t\trc = emulate_ud(ctxt);\n\t\t\tgoto done;\n\t\t}\n\n\t\tif ((ctxt->d & (Sse|Mmx)) && (ops->get_cr(ctxt, 0) & X86_CR0_TS)) {\n\t\t\trc = emulate_nm(ctxt);\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (ctxt->d & Mmx) {\n\t\t\trc = flush_pending_x87_faults(ctxt);\n\t\t\tif (rc != X86EMUL_CONTINUE)\n\t\t\t\tgoto done;\n\t\t\t/*\n\t\t\t * Now that we know the fpu is exception safe, we can fetch\n\t\t\t * operands from it.\n\t\t\t */\n\t\t\tfetch_possible_mmx_operand(ctxt, &ctxt->src);\n\t\t\tfetch_possible_mmx_operand(ctxt, &ctxt->src2);\n\t\t\tif (!(ctxt->d & Mov))\n\t\t\t\tfetch_possible_mmx_operand(ctxt, &ctxt->dst);\n\t\t}\n\n\t\tif (unlikely(ctxt->emul_flags & X86EMUL_GUEST_MASK) && ctxt->intercept) {\n\t\t\trc = emulator_check_intercept(ctxt, ctxt->intercept,\n\t\t\t\t\t\t      X86_ICPT_PRE_EXCEPT);\n\t\t\tif (rc != X86EMUL_CONTINUE)\n\t\t\t\tgoto done;\n\t\t}\n\n\t\t/* Instruction can only be executed in protected mode */\n\t\tif ((ctxt->d & Prot) && ctxt->mode < X86EMUL_MODE_PROT16) {\n\t\t\trc = emulate_ud(ctxt);\n\t\t\tgoto done;\n\t\t}\n\n\t\t/* Privileged instruction can be executed only in CPL=0 */\n\t\tif ((ctxt->d & Priv) && ops->cpl(ctxt)) {\n\t\t\tif (ctxt->d & PrivUD)\n\t\t\t\trc = emulate_ud(ctxt);\n\t\t\telse\n\t\t\t\trc = emulate_gp(ctxt, 0);\n\t\t\tgoto done;\n\t\t}\n\n\t\t/* Do instruction specific permission checks */\n\t\tif (ctxt->d & CheckPerm) {\n\t\t\trc = ctxt->check_perm(ctxt);\n\t\t\tif (rc != X86EMUL_CONTINUE)\n\t\t\t\tgoto done;\n\t\t}\n\n\t\tif (unlikely(ctxt->emul_flags & X86EMUL_GUEST_MASK) && (ctxt->d & Intercept)) {\n\t\t\trc = emulator_check_intercept(ctxt, ctxt->intercept,\n\t\t\t\t\t\t      X86_ICPT_POST_EXCEPT);\n\t\t\tif (rc != X86EMUL_CONTINUE)\n\t\t\t\tgoto done;\n\t\t}\n\n\t\tif (ctxt->rep_prefix && (ctxt->d & String)) {\n\t\t\t/* All REP prefixes have the same first termination condition */\n\t\t\tif (address_mask(ctxt, reg_read(ctxt, VCPU_REGS_RCX)) == 0) {\n\t\t\t\tstring_registers_quirk(ctxt);\n\t\t\t\tctxt->eip = ctxt->_eip;\n\t\t\t\tctxt->eflags &= ~X86_EFLAGS_RF;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t}\n\n\tif ((ctxt->src.type == OP_MEM) && !(ctxt->d & NoAccess)) {\n\t\trc = segmented_read(ctxt, ctxt->src.addr.mem,\n\t\t\t\t    ctxt->src.valptr, ctxt->src.bytes);\n\t\tif (rc != X86EMUL_CONTINUE)\n\t\t\tgoto done;\n\t\tctxt->src.orig_val64 = ctxt->src.val64;\n\t}\n\n\tif (ctxt->src2.type == OP_MEM) {\n\t\trc = segmented_read(ctxt, ctxt->src2.addr.mem,\n\t\t\t\t    &ctxt->src2.val, ctxt->src2.bytes);\n\t\tif (rc != X86EMUL_CONTINUE)\n\t\t\tgoto done;\n\t}\n\n\tif ((ctxt->d & DstMask) == ImplicitOps)\n\t\tgoto special_insn;\n\n\n\tif ((ctxt->dst.type == OP_MEM) && !(ctxt->d & Mov)) {\n\t\t/* optimisation - avoid slow emulated read if Mov */\n\t\trc = segmented_read(ctxt, ctxt->dst.addr.mem,\n\t\t\t\t   &ctxt->dst.val, ctxt->dst.bytes);\n\t\tif (rc != X86EMUL_CONTINUE) {\n\t\t\tif (!(ctxt->d & NoWrite) &&\n\t\t\t    rc == X86EMUL_PROPAGATE_FAULT &&\n\t\t\t    ctxt->exception.vector == PF_VECTOR)\n\t\t\t\tctxt->exception.error_code |= PFERR_WRITE_MASK;\n\t\t\tgoto done;\n\t\t}\n\t}\n\t/* Copy full 64-bit value for CMPXCHG8B.  */\n\tctxt->dst.orig_val64 = ctxt->dst.val64;\n\nspecial_insn:\n\n\tif (unlikely(ctxt->emul_flags & X86EMUL_GUEST_MASK) && (ctxt->d & Intercept)) {\n\t\trc = emulator_check_intercept(ctxt, ctxt->intercept,\n\t\t\t\t\t      X86_ICPT_POST_MEMACCESS);\n\t\tif (rc != X86EMUL_CONTINUE)\n\t\t\tgoto done;\n\t}\n\n\tif (ctxt->rep_prefix && (ctxt->d & String))\n\t\tctxt->eflags |= X86_EFLAGS_RF;\n\telse\n\t\tctxt->eflags &= ~X86_EFLAGS_RF;\n\n\tif (ctxt->execute) {\n\t\tif (ctxt->d & Fastop) {\n\t\t\tvoid (*fop)(struct fastop *) = (void *)ctxt->execute;\n\t\t\trc = fastop(ctxt, fop);\n\t\t\tif (rc != X86EMUL_CONTINUE)\n\t\t\t\tgoto done;\n\t\t\tgoto writeback;\n\t\t}\n\t\trc = ctxt->execute(ctxt);\n\t\tif (rc != X86EMUL_CONTINUE)\n\t\t\tgoto done;\n\t\tgoto writeback;\n\t}\n\n\tif (ctxt->opcode_len == 2)\n\t\tgoto twobyte_insn;\n\telse if (ctxt->opcode_len == 3)\n\t\tgoto threebyte_insn;\n\n\tswitch (ctxt->b) {\n\tcase 0x70 ... 0x7f: /* jcc (short) */\n\t\tif (test_cc(ctxt->b, ctxt->eflags))\n\t\t\trc = jmp_rel(ctxt, ctxt->src.val);\n\t\tbreak;\n\tcase 0x8d: /* lea r16/r32, m */\n\t\tctxt->dst.val = ctxt->src.addr.mem.ea;\n\t\tbreak;\n\tcase 0x90 ... 0x97: /* nop / xchg reg, rax */\n\t\tif (ctxt->dst.addr.reg == reg_rmw(ctxt, VCPU_REGS_RAX))\n\t\t\tctxt->dst.type = OP_NONE;\n\t\telse\n\t\t\trc = em_xchg(ctxt);\n\t\tbreak;\n\tcase 0x98: /* cbw/cwde/cdqe */\n\t\tswitch (ctxt->op_bytes) {\n\t\tcase 2: ctxt->dst.val = (s8)ctxt->dst.val; break;\n\t\tcase 4: ctxt->dst.val = (s16)ctxt->dst.val; break;\n\t\tcase 8: ctxt->dst.val = (s32)ctxt->dst.val; break;\n\t\t}\n\t\tbreak;\n\tcase 0xcc:\t\t/* int3 */\n\t\trc = emulate_int(ctxt, 3);\n\t\tbreak;\n\tcase 0xcd:\t\t/* int n */\n\t\trc = emulate_int(ctxt, ctxt->src.val);\n\t\tbreak;\n\tcase 0xce:\t\t/* into */\n\t\tif (ctxt->eflags & X86_EFLAGS_OF)\n\t\t\trc = emulate_int(ctxt, 4);\n\t\tbreak;\n\tcase 0xe9: /* jmp rel */\n\tcase 0xeb: /* jmp rel short */\n\t\trc = jmp_rel(ctxt, ctxt->src.val);\n\t\tctxt->dst.type = OP_NONE; /* Disable writeback. */\n\t\tbreak;\n\tcase 0xf4:              /* hlt */\n\t\tctxt->ops->halt(ctxt);\n\t\tbreak;\n\tcase 0xf5:\t/* cmc */\n\t\t/* complement carry flag from eflags reg */\n\t\tctxt->eflags ^= X86_EFLAGS_CF;\n\t\tbreak;\n\tcase 0xf8: /* clc */\n\t\tctxt->eflags &= ~X86_EFLAGS_CF;\n\t\tbreak;\n\tcase 0xf9: /* stc */\n\t\tctxt->eflags |= X86_EFLAGS_CF;\n\t\tbreak;\n\tcase 0xfc: /* cld */\n\t\tctxt->eflags &= ~X86_EFLAGS_DF;\n\t\tbreak;\n\tcase 0xfd: /* std */\n\t\tctxt->eflags |= X86_EFLAGS_DF;\n\t\tbreak;\n\tdefault:\n\t\tgoto cannot_emulate;\n\t}\n\n\tif (rc != X86EMUL_CONTINUE)\n\t\tgoto done;\n\nwriteback:\n\tif (ctxt->d & SrcWrite) {\n\t\tBUG_ON(ctxt->src.type == OP_MEM || ctxt->src.type == OP_MEM_STR);\n\t\trc = writeback(ctxt, &ctxt->src);\n\t\tif (rc != X86EMUL_CONTINUE)\n\t\t\tgoto done;\n\t}\n\tif (!(ctxt->d & NoWrite)) {\n\t\trc = writeback(ctxt, &ctxt->dst);\n\t\tif (rc != X86EMUL_CONTINUE)\n\t\t\tgoto done;\n\t}\n\n\t/*\n\t * restore dst type in case the decoding will be reused\n\t * (happens for string instruction )\n\t */\n\tctxt->dst.type = saved_dst_type;\n\n\tif ((ctxt->d & SrcMask) == SrcSI)\n\t\tstring_addr_inc(ctxt, VCPU_REGS_RSI, &ctxt->src);\n\n\tif ((ctxt->d & DstMask) == DstDI)\n\t\tstring_addr_inc(ctxt, VCPU_REGS_RDI, &ctxt->dst);\n\n\tif (ctxt->rep_prefix && (ctxt->d & String)) {\n\t\tunsigned int count;\n\t\tstruct read_cache *r = &ctxt->io_read;\n\t\tif ((ctxt->d & SrcMask) == SrcSI)\n\t\t\tcount = ctxt->src.count;\n\t\telse\n\t\t\tcount = ctxt->dst.count;\n\t\tregister_address_increment(ctxt, VCPU_REGS_RCX, -count);\n\n\t\tif (!string_insn_completed(ctxt)) {\n\t\t\t/*\n\t\t\t * Re-enter guest when pio read ahead buffer is empty\n\t\t\t * or, if it is not used, after each 1024 iteration.\n\t\t\t */\n\t\t\tif ((r->end != 0 || reg_read(ctxt, VCPU_REGS_RCX) & 0x3ff) &&\n\t\t\t    (r->end == 0 || r->end != r->pos)) {\n\t\t\t\t/*\n\t\t\t\t * Reset read cache. Usually happens before\n\t\t\t\t * decode, but since instruction is restarted\n\t\t\t\t * we have to do it here.\n\t\t\t\t */\n\t\t\t\tctxt->mem_read.end = 0;\n\t\t\t\twriteback_registers(ctxt);\n\t\t\t\treturn EMULATION_RESTART;\n\t\t\t}\n\t\t\tgoto done; /* skip rip writeback */\n\t\t}\n\t\tctxt->eflags &= ~X86_EFLAGS_RF;\n\t}\n\n\tctxt->eip = ctxt->_eip;\n\ndone:\n\tif (rc == X86EMUL_PROPAGATE_FAULT) {\n\t\tWARN_ON(ctxt->exception.vector > 0x1f);\n\t\tctxt->have_exception = true;\n\t}\n\tif (rc == X86EMUL_INTERCEPTED)\n\t\treturn EMULATION_INTERCEPTED;\n\n\tif (rc == X86EMUL_CONTINUE)\n\t\twriteback_registers(ctxt);\n\n\treturn (rc == X86EMUL_UNHANDLEABLE) ? EMULATION_FAILED : EMULATION_OK;\n\ntwobyte_insn:\n\tswitch (ctxt->b) {\n\tcase 0x09:\t\t/* wbinvd */\n\t\t(ctxt->ops->wbinvd)(ctxt);\n\t\tbreak;\n\tcase 0x08:\t\t/* invd */\n\tcase 0x0d:\t\t/* GrpP (prefetch) */\n\tcase 0x18:\t\t/* Grp16 (prefetch/nop) */\n\tcase 0x1f:\t\t/* nop */\n\t\tbreak;\n\tcase 0x20: /* mov cr, reg */\n\t\tctxt->dst.val = ops->get_cr(ctxt, ctxt->modrm_reg);\n\t\tbreak;\n\tcase 0x21: /* mov from dr to reg */\n\t\tops->get_dr(ctxt, ctxt->modrm_reg, &ctxt->dst.val);\n\t\tbreak;\n\tcase 0x40 ... 0x4f:\t/* cmov */\n\t\tif (test_cc(ctxt->b, ctxt->eflags))\n\t\t\tctxt->dst.val = ctxt->src.val;\n\t\telse if (ctxt->op_bytes != 4)\n\t\t\tctxt->dst.type = OP_NONE; /* no writeback */\n\t\tbreak;\n\tcase 0x80 ... 0x8f: /* jnz rel, etc*/\n\t\tif (test_cc(ctxt->b, ctxt->eflags))\n\t\t\trc = jmp_rel(ctxt, ctxt->src.val);\n\t\tbreak;\n\tcase 0x90 ... 0x9f:     /* setcc r/m8 */\n\t\tctxt->dst.val = test_cc(ctxt->b, ctxt->eflags);\n\t\tbreak;\n\tcase 0xb6 ... 0xb7:\t/* movzx */\n\t\tctxt->dst.bytes = ctxt->op_bytes;\n\t\tctxt->dst.val = (ctxt->src.bytes == 1) ? (u8) ctxt->src.val\n\t\t\t\t\t\t       : (u16) ctxt->src.val;\n\t\tbreak;\n\tcase 0xbe ... 0xbf:\t/* movsx */\n\t\tctxt->dst.bytes = ctxt->op_bytes;\n\t\tctxt->dst.val = (ctxt->src.bytes == 1) ? (s8) ctxt->src.val :\n\t\t\t\t\t\t\t(s16) ctxt->src.val;\n\t\tbreak;\n\tdefault:\n\t\tgoto cannot_emulate;\n\t}\n\nthreebyte_insn:\n\n\tif (rc != X86EMUL_CONTINUE)\n\t\tgoto done;\n\n\tgoto writeback;\n\ncannot_emulate:\n\treturn EMULATION_FAILED;\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define PrivUD      ((u64)1 << 51)  /* #UD instead of #GP on CPL > 0 */",
            "#define CheckPerm   ((u64)1 << 49)  /* Has valid check_perm field */",
            "#define Intercept   ((u64)1 << 48)  /* Has valid intercept field */",
            "#define SrcWrite    ((u64)1 << 46)  /* Write back src operand */",
            "#define NoWrite     ((u64)1 << 45)  /* No writeback */",
            "#define Fastop      ((u64)1 << 44)  /* Use opcode::u.fastop */",
            "#define Mmx         ((u64)1 << 40)  /* MMX Vector instruction */",
            "#define No64\t    (1<<28)",
            "#define Priv        (1<<27) /* instruction generates #GP if current CPL != 0 */",
            "#define Lock        (1<<26) /* lock prefix is allowed for the instruction */",
            "#define Undefined   (1<<25) /* No Such Instruction */",
            "#define NoAccess    (1<<23) /* Don't access memory (lea/invlpg/verr etc) */",
            "#define Prot        (1<<21) /* instruction generates #UD if not in prot-mode */",
            "#define Mov         (1<<20)",
            "#define Sse         (1<<18)     /* SSE Vector instruction */",
            "#define String      (1<<13)     /* String instruction (rep capable) */",
            "#define SrcMask     (OpMask << SrcShift)",
            "#define SrcMemFAddr (OpMemFAddr << SrcShift)",
            "#define SrcSI       (OpSI << SrcShift)",
            "#define DstMask     (OpMask << DstShift)",
            "#define DstDI       (OpDI << DstShift)",
            "#define ImplicitOps (OpImplicit << DstShift)"
          ],
          "globals_used": [
            "static int fastop(struct x86_emulate_ctxt *ctxt, void (*fop)(struct fastop *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\n#define PrivUD      ((u64)1 << 51)  /* #UD instead of #GP on CPL > 0 */\n#define CheckPerm   ((u64)1 << 49)  /* Has valid check_perm field */\n#define Intercept   ((u64)1 << 48)  /* Has valid intercept field */\n#define SrcWrite    ((u64)1 << 46)  /* Write back src operand */\n#define NoWrite     ((u64)1 << 45)  /* No writeback */\n#define Fastop      ((u64)1 << 44)  /* Use opcode::u.fastop */\n#define Mmx         ((u64)1 << 40)  /* MMX Vector instruction */\n#define No64\t    (1<<28)\n#define Priv        (1<<27) /* instruction generates #GP if current CPL != 0 */\n#define Lock        (1<<26) /* lock prefix is allowed for the instruction */\n#define Undefined   (1<<25) /* No Such Instruction */\n#define NoAccess    (1<<23) /* Don't access memory (lea/invlpg/verr etc) */\n#define Prot        (1<<21) /* instruction generates #UD if not in prot-mode */\n#define Mov         (1<<20)\n#define Sse         (1<<18)     /* SSE Vector instruction */\n#define String      (1<<13)     /* String instruction (rep capable) */\n#define SrcMask     (OpMask << SrcShift)\n#define SrcMemFAddr (OpMemFAddr << SrcShift)\n#define SrcSI       (OpSI << SrcShift)\n#define DstMask     (OpMask << DstShift)\n#define DstDI       (OpDI << DstShift)\n#define ImplicitOps (OpImplicit << DstShift)\n\nstatic int fastop(struct x86_emulate_ctxt *ctxt, void (*fop)(struct fastop *));\n\nint x86_emulate_insn(struct x86_emulate_ctxt *ctxt)\n{\n\tconst struct x86_emulate_ops *ops = ctxt->ops;\n\tint rc = X86EMUL_CONTINUE;\n\tint saved_dst_type = ctxt->dst.type;\n\n\tctxt->mem_read.pos = 0;\n\n\t/* LOCK prefix is allowed only with some instructions */\n\tif (ctxt->lock_prefix && (!(ctxt->d & Lock) || ctxt->dst.type != OP_MEM)) {\n\t\trc = emulate_ud(ctxt);\n\t\tgoto done;\n\t}\n\n\tif ((ctxt->d & SrcMask) == SrcMemFAddr && ctxt->src.type != OP_MEM) {\n\t\trc = emulate_ud(ctxt);\n\t\tgoto done;\n\t}\n\n\tif (unlikely(ctxt->d &\n\t\t     (No64|Undefined|Sse|Mmx|Intercept|CheckPerm|Priv|Prot|String))) {\n\t\tif ((ctxt->mode == X86EMUL_MODE_PROT64 && (ctxt->d & No64)) ||\n\t\t\t\t(ctxt->d & Undefined)) {\n\t\t\trc = emulate_ud(ctxt);\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (((ctxt->d & (Sse|Mmx)) && ((ops->get_cr(ctxt, 0) & X86_CR0_EM)))\n\t\t    || ((ctxt->d & Sse) && !(ops->get_cr(ctxt, 4) & X86_CR4_OSFXSR))) {\n\t\t\trc = emulate_ud(ctxt);\n\t\t\tgoto done;\n\t\t}\n\n\t\tif ((ctxt->d & (Sse|Mmx)) && (ops->get_cr(ctxt, 0) & X86_CR0_TS)) {\n\t\t\trc = emulate_nm(ctxt);\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (ctxt->d & Mmx) {\n\t\t\trc = flush_pending_x87_faults(ctxt);\n\t\t\tif (rc != X86EMUL_CONTINUE)\n\t\t\t\tgoto done;\n\t\t\t/*\n\t\t\t * Now that we know the fpu is exception safe, we can fetch\n\t\t\t * operands from it.\n\t\t\t */\n\t\t\tfetch_possible_mmx_operand(ctxt, &ctxt->src);\n\t\t\tfetch_possible_mmx_operand(ctxt, &ctxt->src2);\n\t\t\tif (!(ctxt->d & Mov))\n\t\t\t\tfetch_possible_mmx_operand(ctxt, &ctxt->dst);\n\t\t}\n\n\t\tif (unlikely(ctxt->emul_flags & X86EMUL_GUEST_MASK) && ctxt->intercept) {\n\t\t\trc = emulator_check_intercept(ctxt, ctxt->intercept,\n\t\t\t\t\t\t      X86_ICPT_PRE_EXCEPT);\n\t\t\tif (rc != X86EMUL_CONTINUE)\n\t\t\t\tgoto done;\n\t\t}\n\n\t\t/* Instruction can only be executed in protected mode */\n\t\tif ((ctxt->d & Prot) && ctxt->mode < X86EMUL_MODE_PROT16) {\n\t\t\trc = emulate_ud(ctxt);\n\t\t\tgoto done;\n\t\t}\n\n\t\t/* Privileged instruction can be executed only in CPL=0 */\n\t\tif ((ctxt->d & Priv) && ops->cpl(ctxt)) {\n\t\t\tif (ctxt->d & PrivUD)\n\t\t\t\trc = emulate_ud(ctxt);\n\t\t\telse\n\t\t\t\trc = emulate_gp(ctxt, 0);\n\t\t\tgoto done;\n\t\t}\n\n\t\t/* Do instruction specific permission checks */\n\t\tif (ctxt->d & CheckPerm) {\n\t\t\trc = ctxt->check_perm(ctxt);\n\t\t\tif (rc != X86EMUL_CONTINUE)\n\t\t\t\tgoto done;\n\t\t}\n\n\t\tif (unlikely(ctxt->emul_flags & X86EMUL_GUEST_MASK) && (ctxt->d & Intercept)) {\n\t\t\trc = emulator_check_intercept(ctxt, ctxt->intercept,\n\t\t\t\t\t\t      X86_ICPT_POST_EXCEPT);\n\t\t\tif (rc != X86EMUL_CONTINUE)\n\t\t\t\tgoto done;\n\t\t}\n\n\t\tif (ctxt->rep_prefix && (ctxt->d & String)) {\n\t\t\t/* All REP prefixes have the same first termination condition */\n\t\t\tif (address_mask(ctxt, reg_read(ctxt, VCPU_REGS_RCX)) == 0) {\n\t\t\t\tstring_registers_quirk(ctxt);\n\t\t\t\tctxt->eip = ctxt->_eip;\n\t\t\t\tctxt->eflags &= ~X86_EFLAGS_RF;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t}\n\n\tif ((ctxt->src.type == OP_MEM) && !(ctxt->d & NoAccess)) {\n\t\trc = segmented_read(ctxt, ctxt->src.addr.mem,\n\t\t\t\t    ctxt->src.valptr, ctxt->src.bytes);\n\t\tif (rc != X86EMUL_CONTINUE)\n\t\t\tgoto done;\n\t\tctxt->src.orig_val64 = ctxt->src.val64;\n\t}\n\n\tif (ctxt->src2.type == OP_MEM) {\n\t\trc = segmented_read(ctxt, ctxt->src2.addr.mem,\n\t\t\t\t    &ctxt->src2.val, ctxt->src2.bytes);\n\t\tif (rc != X86EMUL_CONTINUE)\n\t\t\tgoto done;\n\t}\n\n\tif ((ctxt->d & DstMask) == ImplicitOps)\n\t\tgoto special_insn;\n\n\n\tif ((ctxt->dst.type == OP_MEM) && !(ctxt->d & Mov)) {\n\t\t/* optimisation - avoid slow emulated read if Mov */\n\t\trc = segmented_read(ctxt, ctxt->dst.addr.mem,\n\t\t\t\t   &ctxt->dst.val, ctxt->dst.bytes);\n\t\tif (rc != X86EMUL_CONTINUE) {\n\t\t\tif (!(ctxt->d & NoWrite) &&\n\t\t\t    rc == X86EMUL_PROPAGATE_FAULT &&\n\t\t\t    ctxt->exception.vector == PF_VECTOR)\n\t\t\t\tctxt->exception.error_code |= PFERR_WRITE_MASK;\n\t\t\tgoto done;\n\t\t}\n\t}\n\t/* Copy full 64-bit value for CMPXCHG8B.  */\n\tctxt->dst.orig_val64 = ctxt->dst.val64;\n\nspecial_insn:\n\n\tif (unlikely(ctxt->emul_flags & X86EMUL_GUEST_MASK) && (ctxt->d & Intercept)) {\n\t\trc = emulator_check_intercept(ctxt, ctxt->intercept,\n\t\t\t\t\t      X86_ICPT_POST_MEMACCESS);\n\t\tif (rc != X86EMUL_CONTINUE)\n\t\t\tgoto done;\n\t}\n\n\tif (ctxt->rep_prefix && (ctxt->d & String))\n\t\tctxt->eflags |= X86_EFLAGS_RF;\n\telse\n\t\tctxt->eflags &= ~X86_EFLAGS_RF;\n\n\tif (ctxt->execute) {\n\t\tif (ctxt->d & Fastop) {\n\t\t\tvoid (*fop)(struct fastop *) = (void *)ctxt->execute;\n\t\t\trc = fastop(ctxt, fop);\n\t\t\tif (rc != X86EMUL_CONTINUE)\n\t\t\t\tgoto done;\n\t\t\tgoto writeback;\n\t\t}\n\t\trc = ctxt->execute(ctxt);\n\t\tif (rc != X86EMUL_CONTINUE)\n\t\t\tgoto done;\n\t\tgoto writeback;\n\t}\n\n\tif (ctxt->opcode_len == 2)\n\t\tgoto twobyte_insn;\n\telse if (ctxt->opcode_len == 3)\n\t\tgoto threebyte_insn;\n\n\tswitch (ctxt->b) {\n\tcase 0x70 ... 0x7f: /* jcc (short) */\n\t\tif (test_cc(ctxt->b, ctxt->eflags))\n\t\t\trc = jmp_rel(ctxt, ctxt->src.val);\n\t\tbreak;\n\tcase 0x8d: /* lea r16/r32, m */\n\t\tctxt->dst.val = ctxt->src.addr.mem.ea;\n\t\tbreak;\n\tcase 0x90 ... 0x97: /* nop / xchg reg, rax */\n\t\tif (ctxt->dst.addr.reg == reg_rmw(ctxt, VCPU_REGS_RAX))\n\t\t\tctxt->dst.type = OP_NONE;\n\t\telse\n\t\t\trc = em_xchg(ctxt);\n\t\tbreak;\n\tcase 0x98: /* cbw/cwde/cdqe */\n\t\tswitch (ctxt->op_bytes) {\n\t\tcase 2: ctxt->dst.val = (s8)ctxt->dst.val; break;\n\t\tcase 4: ctxt->dst.val = (s16)ctxt->dst.val; break;\n\t\tcase 8: ctxt->dst.val = (s32)ctxt->dst.val; break;\n\t\t}\n\t\tbreak;\n\tcase 0xcc:\t\t/* int3 */\n\t\trc = emulate_int(ctxt, 3);\n\t\tbreak;\n\tcase 0xcd:\t\t/* int n */\n\t\trc = emulate_int(ctxt, ctxt->src.val);\n\t\tbreak;\n\tcase 0xce:\t\t/* into */\n\t\tif (ctxt->eflags & X86_EFLAGS_OF)\n\t\t\trc = emulate_int(ctxt, 4);\n\t\tbreak;\n\tcase 0xe9: /* jmp rel */\n\tcase 0xeb: /* jmp rel short */\n\t\trc = jmp_rel(ctxt, ctxt->src.val);\n\t\tctxt->dst.type = OP_NONE; /* Disable writeback. */\n\t\tbreak;\n\tcase 0xf4:              /* hlt */\n\t\tctxt->ops->halt(ctxt);\n\t\tbreak;\n\tcase 0xf5:\t/* cmc */\n\t\t/* complement carry flag from eflags reg */\n\t\tctxt->eflags ^= X86_EFLAGS_CF;\n\t\tbreak;\n\tcase 0xf8: /* clc */\n\t\tctxt->eflags &= ~X86_EFLAGS_CF;\n\t\tbreak;\n\tcase 0xf9: /* stc */\n\t\tctxt->eflags |= X86_EFLAGS_CF;\n\t\tbreak;\n\tcase 0xfc: /* cld */\n\t\tctxt->eflags &= ~X86_EFLAGS_DF;\n\t\tbreak;\n\tcase 0xfd: /* std */\n\t\tctxt->eflags |= X86_EFLAGS_DF;\n\t\tbreak;\n\tdefault:\n\t\tgoto cannot_emulate;\n\t}\n\n\tif (rc != X86EMUL_CONTINUE)\n\t\tgoto done;\n\nwriteback:\n\tif (ctxt->d & SrcWrite) {\n\t\tBUG_ON(ctxt->src.type == OP_MEM || ctxt->src.type == OP_MEM_STR);\n\t\trc = writeback(ctxt, &ctxt->src);\n\t\tif (rc != X86EMUL_CONTINUE)\n\t\t\tgoto done;\n\t}\n\tif (!(ctxt->d & NoWrite)) {\n\t\trc = writeback(ctxt, &ctxt->dst);\n\t\tif (rc != X86EMUL_CONTINUE)\n\t\t\tgoto done;\n\t}\n\n\t/*\n\t * restore dst type in case the decoding will be reused\n\t * (happens for string instruction )\n\t */\n\tctxt->dst.type = saved_dst_type;\n\n\tif ((ctxt->d & SrcMask) == SrcSI)\n\t\tstring_addr_inc(ctxt, VCPU_REGS_RSI, &ctxt->src);\n\n\tif ((ctxt->d & DstMask) == DstDI)\n\t\tstring_addr_inc(ctxt, VCPU_REGS_RDI, &ctxt->dst);\n\n\tif (ctxt->rep_prefix && (ctxt->d & String)) {\n\t\tunsigned int count;\n\t\tstruct read_cache *r = &ctxt->io_read;\n\t\tif ((ctxt->d & SrcMask) == SrcSI)\n\t\t\tcount = ctxt->src.count;\n\t\telse\n\t\t\tcount = ctxt->dst.count;\n\t\tregister_address_increment(ctxt, VCPU_REGS_RCX, -count);\n\n\t\tif (!string_insn_completed(ctxt)) {\n\t\t\t/*\n\t\t\t * Re-enter guest when pio read ahead buffer is empty\n\t\t\t * or, if it is not used, after each 1024 iteration.\n\t\t\t */\n\t\t\tif ((r->end != 0 || reg_read(ctxt, VCPU_REGS_RCX) & 0x3ff) &&\n\t\t\t    (r->end == 0 || r->end != r->pos)) {\n\t\t\t\t/*\n\t\t\t\t * Reset read cache. Usually happens before\n\t\t\t\t * decode, but since instruction is restarted\n\t\t\t\t * we have to do it here.\n\t\t\t\t */\n\t\t\t\tctxt->mem_read.end = 0;\n\t\t\t\twriteback_registers(ctxt);\n\t\t\t\treturn EMULATION_RESTART;\n\t\t\t}\n\t\t\tgoto done; /* skip rip writeback */\n\t\t}\n\t\tctxt->eflags &= ~X86_EFLAGS_RF;\n\t}\n\n\tctxt->eip = ctxt->_eip;\n\ndone:\n\tif (rc == X86EMUL_PROPAGATE_FAULT) {\n\t\tWARN_ON(ctxt->exception.vector > 0x1f);\n\t\tctxt->have_exception = true;\n\t}\n\tif (rc == X86EMUL_INTERCEPTED)\n\t\treturn EMULATION_INTERCEPTED;\n\n\tif (rc == X86EMUL_CONTINUE)\n\t\twriteback_registers(ctxt);\n\n\treturn (rc == X86EMUL_UNHANDLEABLE) ? EMULATION_FAILED : EMULATION_OK;\n\ntwobyte_insn:\n\tswitch (ctxt->b) {\n\tcase 0x09:\t\t/* wbinvd */\n\t\t(ctxt->ops->wbinvd)(ctxt);\n\t\tbreak;\n\tcase 0x08:\t\t/* invd */\n\tcase 0x0d:\t\t/* GrpP (prefetch) */\n\tcase 0x18:\t\t/* Grp16 (prefetch/nop) */\n\tcase 0x1f:\t\t/* nop */\n\t\tbreak;\n\tcase 0x20: /* mov cr, reg */\n\t\tctxt->dst.val = ops->get_cr(ctxt, ctxt->modrm_reg);\n\t\tbreak;\n\tcase 0x21: /* mov from dr to reg */\n\t\tops->get_dr(ctxt, ctxt->modrm_reg, &ctxt->dst.val);\n\t\tbreak;\n\tcase 0x40 ... 0x4f:\t/* cmov */\n\t\tif (test_cc(ctxt->b, ctxt->eflags))\n\t\t\tctxt->dst.val = ctxt->src.val;\n\t\telse if (ctxt->op_bytes != 4)\n\t\t\tctxt->dst.type = OP_NONE; /* no writeback */\n\t\tbreak;\n\tcase 0x80 ... 0x8f: /* jnz rel, etc*/\n\t\tif (test_cc(ctxt->b, ctxt->eflags))\n\t\t\trc = jmp_rel(ctxt, ctxt->src.val);\n\t\tbreak;\n\tcase 0x90 ... 0x9f:     /* setcc r/m8 */\n\t\tctxt->dst.val = test_cc(ctxt->b, ctxt->eflags);\n\t\tbreak;\n\tcase 0xb6 ... 0xb7:\t/* movzx */\n\t\tctxt->dst.bytes = ctxt->op_bytes;\n\t\tctxt->dst.val = (ctxt->src.bytes == 1) ? (u8) ctxt->src.val\n\t\t\t\t\t\t       : (u16) ctxt->src.val;\n\t\tbreak;\n\tcase 0xbe ... 0xbf:\t/* movsx */\n\t\tctxt->dst.bytes = ctxt->op_bytes;\n\t\tctxt->dst.val = (ctxt->src.bytes == 1) ? (s8) ctxt->src.val :\n\t\t\t\t\t\t\t(s16) ctxt->src.val;\n\t\tbreak;\n\tdefault:\n\t\tgoto cannot_emulate;\n\t}\n\nthreebyte_insn:\n\n\tif (rc != X86EMUL_CONTINUE)\n\t\tgoto done;\n\n\tgoto writeback;\n\ncannot_emulate:\n\treturn EMULATION_FAILED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "emulator_invalidate_register_cache",
          "args": [
            "ctxt"
          ],
          "line": 5472
        },
        "resolved": true,
        "details": {
          "function_name": "emulator_invalidate_register_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "5488-5491",
          "snippet": "void emulator_invalidate_register_cache(struct x86_emulate_ctxt *ctxt)\n{\n\tinvalidate_registers(ctxt);\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nvoid emulator_invalidate_register_cache(struct x86_emulate_ctxt *ctxt)\n{\n\tinvalidate_registers(ctxt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "retry_instruction",
          "args": [
            "ctxt",
            "cr2",
            "emulation_type"
          ],
          "line": 5465
        },
        "resolved": true,
        "details": {
          "function_name": "retry_instruction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "5242-5284",
          "snippet": "static bool retry_instruction(struct x86_emulate_ctxt *ctxt,\n\t\t\t      unsigned long cr2,  int emulation_type)\n{\n\tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n\tunsigned long last_retry_eip, last_retry_addr, gpa = cr2;\n\n\tlast_retry_eip = vcpu->arch.last_retry_eip;\n\tlast_retry_addr = vcpu->arch.last_retry_addr;\n\n\t/*\n\t * If the emulation is caused by #PF and it is non-page_table\n\t * writing instruction, it means the VM-EXIT is caused by shadow\n\t * page protected, we can zap the shadow page and retry this\n\t * instruction directly.\n\t *\n\t * Note: if the guest uses a non-page-table modifying instruction\n\t * on the PDE that points to the instruction, then we will unmap\n\t * the instruction and go to an infinite loop. So, we cache the\n\t * last retried eip and the last fault address, if we meet the eip\n\t * and the address again, we can break out of the potential infinite\n\t * loop.\n\t */\n\tvcpu->arch.last_retry_eip = vcpu->arch.last_retry_addr = 0;\n\n\tif (!(emulation_type & EMULTYPE_RETRY))\n\t\treturn false;\n\n\tif (x86_page_table_writing_insn(ctxt))\n\t\treturn false;\n\n\tif (ctxt->eip == last_retry_eip && last_retry_addr == cr2)\n\t\treturn false;\n\n\tvcpu->arch.last_retry_eip = ctxt->eip;\n\tvcpu->arch.last_retry_addr = cr2;\n\n\tif (!vcpu->arch.mmu.direct_map)\n\t\tgpa = kvm_mmu_gva_to_gpa_write(vcpu, cr2, NULL);\n\n\tkvm_mmu_unprotect_page(vcpu->kvm, gpa_to_gfn(gpa));\n\n\treturn true;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);\n\nstatic bool retry_instruction(struct x86_emulate_ctxt *ctxt,\n\t\t\t      unsigned long cr2,  int emulation_type)\n{\n\tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n\tunsigned long last_retry_eip, last_retry_addr, gpa = cr2;\n\n\tlast_retry_eip = vcpu->arch.last_retry_eip;\n\tlast_retry_addr = vcpu->arch.last_retry_addr;\n\n\t/*\n\t * If the emulation is caused by #PF and it is non-page_table\n\t * writing instruction, it means the VM-EXIT is caused by shadow\n\t * page protected, we can zap the shadow page and retry this\n\t * instruction directly.\n\t *\n\t * Note: if the guest uses a non-page-table modifying instruction\n\t * on the PDE that points to the instruction, then we will unmap\n\t * the instruction and go to an infinite loop. So, we cache the\n\t * last retried eip and the last fault address, if we meet the eip\n\t * and the address again, we can break out of the potential infinite\n\t * loop.\n\t */\n\tvcpu->arch.last_retry_eip = vcpu->arch.last_retry_addr = 0;\n\n\tif (!(emulation_type & EMULTYPE_RETRY))\n\t\treturn false;\n\n\tif (x86_page_table_writing_insn(ctxt))\n\t\treturn false;\n\n\tif (ctxt->eip == last_retry_eip && last_retry_addr == cr2)\n\t\treturn false;\n\n\tvcpu->arch.last_retry_eip = ctxt->eip;\n\tvcpu->arch.last_retry_addr = cr2;\n\n\tif (!vcpu->arch.mmu.direct_map)\n\t\tgpa = kvm_mmu_gva_to_gpa_write(vcpu, cr2, NULL);\n\n\tkvm_mmu_unprotect_page(vcpu->kvm, gpa_to_gfn(gpa));\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_set_rflags",
          "args": [
            "vcpu",
            "ctxt->eflags & ~X86_EFLAGS_RF"
          ],
          "line": 5461
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_set_rflags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "8182-8186",
          "snippet": "void kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags)\n{\n\t__kvm_set_rflags(vcpu, rflags);\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void __kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void __kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags);\n\nvoid kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags)\n{\n\t__kvm_set_rflags(vcpu, rflags);\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_kvm_emulate_insn_start",
          "args": [
            "vcpu"
          ],
          "line": 5444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x86_decode_insn",
          "args": [
            "ctxt",
            "insn",
            "insn_len"
          ],
          "line": 5442
        },
        "resolved": true,
        "details": {
          "function_name": "x86_decode_insn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "4788-5055",
          "snippet": "int x86_decode_insn(struct x86_emulate_ctxt *ctxt, void *insn, int insn_len)\n{\n\tint rc = X86EMUL_CONTINUE;\n\tint mode = ctxt->mode;\n\tint def_op_bytes, def_ad_bytes, goffset, simd_prefix;\n\tbool op_prefix = false;\n\tbool has_seg_override = false;\n\tstruct opcode opcode;\n\n\tctxt->memop.type = OP_NONE;\n\tctxt->memopp = NULL;\n\tctxt->_eip = ctxt->eip;\n\tctxt->fetch.ptr = ctxt->fetch.data;\n\tctxt->fetch.end = ctxt->fetch.data + insn_len;\n\tctxt->opcode_len = 1;\n\tif (insn_len > 0)\n\t\tmemcpy(ctxt->fetch.data, insn, insn_len);\n\telse {\n\t\trc = __do_insn_fetch_bytes(ctxt, 1);\n\t\tif (rc != X86EMUL_CONTINUE)\n\t\t\treturn rc;\n\t}\n\n\tswitch (mode) {\n\tcase X86EMUL_MODE_REAL:\n\tcase X86EMUL_MODE_VM86:\n\tcase X86EMUL_MODE_PROT16:\n\t\tdef_op_bytes = def_ad_bytes = 2;\n\t\tbreak;\n\tcase X86EMUL_MODE_PROT32:\n\t\tdef_op_bytes = def_ad_bytes = 4;\n\t\tbreak;\n#ifdef CONFIG_X86_64\n\tcase X86EMUL_MODE_PROT64:\n\t\tdef_op_bytes = 4;\n\t\tdef_ad_bytes = 8;\n\t\tbreak;\n#endif\n\tdefault:\n\t\treturn EMULATION_FAILED;\n\t}\n\n\tctxt->op_bytes = def_op_bytes;\n\tctxt->ad_bytes = def_ad_bytes;\n\n\t/* Legacy prefixes. */\n\tfor (;;) {\n\t\tswitch (ctxt->b = insn_fetch(u8, ctxt)) {\n\t\tcase 0x66:\t/* operand-size override */\n\t\t\top_prefix = true;\n\t\t\t/* switch between 2/4 bytes */\n\t\t\tctxt->op_bytes = def_op_bytes ^ 6;\n\t\t\tbreak;\n\t\tcase 0x67:\t/* address-size override */\n\t\t\tif (mode == X86EMUL_MODE_PROT64)\n\t\t\t\t/* switch between 4/8 bytes */\n\t\t\t\tctxt->ad_bytes = def_ad_bytes ^ 12;\n\t\t\telse\n\t\t\t\t/* switch between 2/4 bytes */\n\t\t\t\tctxt->ad_bytes = def_ad_bytes ^ 6;\n\t\t\tbreak;\n\t\tcase 0x26:\t/* ES override */\n\t\tcase 0x2e:\t/* CS override */\n\t\tcase 0x36:\t/* SS override */\n\t\tcase 0x3e:\t/* DS override */\n\t\t\thas_seg_override = true;\n\t\t\tctxt->seg_override = (ctxt->b >> 3) & 3;\n\t\t\tbreak;\n\t\tcase 0x64:\t/* FS override */\n\t\tcase 0x65:\t/* GS override */\n\t\t\thas_seg_override = true;\n\t\t\tctxt->seg_override = ctxt->b & 7;\n\t\t\tbreak;\n\t\tcase 0x40 ... 0x4f: /* REX */\n\t\t\tif (mode != X86EMUL_MODE_PROT64)\n\t\t\t\tgoto done_prefixes;\n\t\t\tctxt->rex_prefix = ctxt->b;\n\t\t\tcontinue;\n\t\tcase 0xf0:\t/* LOCK */\n\t\t\tctxt->lock_prefix = 1;\n\t\t\tbreak;\n\t\tcase 0xf2:\t/* REPNE/REPNZ */\n\t\tcase 0xf3:\t/* REP/REPE/REPZ */\n\t\t\tctxt->rep_prefix = ctxt->b;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto done_prefixes;\n\t\t}\n\n\t\t/* Any legacy prefix after a REX prefix nullifies its effect. */\n\n\t\tctxt->rex_prefix = 0;\n\t}\n\ndone_prefixes:\n\n\t/* REX prefix. */\n\tif (ctxt->rex_prefix & 8)\n\t\tctxt->op_bytes = 8;\t/* REX.W */\n\n\t/* Opcode byte(s). */\n\topcode = opcode_table[ctxt->b];\n\t/* Two-byte opcode? */\n\tif (ctxt->b == 0x0f) {\n\t\tctxt->opcode_len = 2;\n\t\tctxt->b = insn_fetch(u8, ctxt);\n\t\topcode = twobyte_table[ctxt->b];\n\n\t\t/* 0F_38 opcode map */\n\t\tif (ctxt->b == 0x38) {\n\t\t\tctxt->opcode_len = 3;\n\t\t\tctxt->b = insn_fetch(u8, ctxt);\n\t\t\topcode = opcode_map_0f_38[ctxt->b];\n\t\t}\n\t}\n\tctxt->d = opcode.flags;\n\n\tif (ctxt->d & ModRM)\n\t\tctxt->modrm = insn_fetch(u8, ctxt);\n\n\t/* vex-prefix instructions are not implemented */\n\tif (ctxt->opcode_len == 1 && (ctxt->b == 0xc5 || ctxt->b == 0xc4) &&\n\t    (mode == X86EMUL_MODE_PROT64 || (ctxt->modrm & 0xc0) == 0xc0)) {\n\t\tctxt->d = NotImpl;\n\t}\n\n\twhile (ctxt->d & GroupMask) {\n\t\tswitch (ctxt->d & GroupMask) {\n\t\tcase Group:\n\t\t\tgoffset = (ctxt->modrm >> 3) & 7;\n\t\t\topcode = opcode.u.group[goffset];\n\t\t\tbreak;\n\t\tcase GroupDual:\n\t\t\tgoffset = (ctxt->modrm >> 3) & 7;\n\t\t\tif ((ctxt->modrm >> 6) == 3)\n\t\t\t\topcode = opcode.u.gdual->mod3[goffset];\n\t\t\telse\n\t\t\t\topcode = opcode.u.gdual->mod012[goffset];\n\t\t\tbreak;\n\t\tcase RMExt:\n\t\t\tgoffset = ctxt->modrm & 7;\n\t\t\topcode = opcode.u.group[goffset];\n\t\t\tbreak;\n\t\tcase Prefix:\n\t\t\tif (ctxt->rep_prefix && op_prefix)\n\t\t\t\treturn EMULATION_FAILED;\n\t\t\tsimd_prefix = op_prefix ? 0x66 : ctxt->rep_prefix;\n\t\t\tswitch (simd_prefix) {\n\t\t\tcase 0x00: opcode = opcode.u.gprefix->pfx_no; break;\n\t\t\tcase 0x66: opcode = opcode.u.gprefix->pfx_66; break;\n\t\t\tcase 0xf2: opcode = opcode.u.gprefix->pfx_f2; break;\n\t\t\tcase 0xf3: opcode = opcode.u.gprefix->pfx_f3; break;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Escape:\n\t\t\tif (ctxt->modrm > 0xbf)\n\t\t\t\topcode = opcode.u.esc->high[ctxt->modrm - 0xc0];\n\t\t\telse\n\t\t\t\topcode = opcode.u.esc->op[(ctxt->modrm >> 3) & 7];\n\t\t\tbreak;\n\t\tcase InstrDual:\n\t\t\tif ((ctxt->modrm >> 6) == 3)\n\t\t\t\topcode = opcode.u.idual->mod3;\n\t\t\telse\n\t\t\t\topcode = opcode.u.idual->mod012;\n\t\t\tbreak;\n\t\tcase ModeDual:\n\t\t\tif (ctxt->mode == X86EMUL_MODE_PROT64)\n\t\t\t\topcode = opcode.u.mdual->mode64;\n\t\t\telse\n\t\t\t\topcode = opcode.u.mdual->mode32;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn EMULATION_FAILED;\n\t\t}\n\n\t\tctxt->d &= ~(u64)GroupMask;\n\t\tctxt->d |= opcode.flags;\n\t}\n\n\t/* Unrecognised? */\n\tif (ctxt->d == 0)\n\t\treturn EMULATION_FAILED;\n\n\tctxt->execute = opcode.u.execute;\n\n\tif (unlikely(ctxt->ud) && likely(!(ctxt->d & EmulateOnUD)))\n\t\treturn EMULATION_FAILED;\n\n\tif (unlikely(ctxt->d &\n\t    (NotImpl|Stack|Op3264|Sse|Mmx|Intercept|CheckPerm|NearBranch|\n\t     No16))) {\n\t\t/*\n\t\t * These are copied unconditionally here, and checked unconditionally\n\t\t * in x86_emulate_insn.\n\t\t */\n\t\tctxt->check_perm = opcode.check_perm;\n\t\tctxt->intercept = opcode.intercept;\n\n\t\tif (ctxt->d & NotImpl)\n\t\t\treturn EMULATION_FAILED;\n\n\t\tif (mode == X86EMUL_MODE_PROT64) {\n\t\t\tif (ctxt->op_bytes == 4 && (ctxt->d & Stack))\n\t\t\t\tctxt->op_bytes = 8;\n\t\t\telse if (ctxt->d & NearBranch)\n\t\t\t\tctxt->op_bytes = 8;\n\t\t}\n\n\t\tif (ctxt->d & Op3264) {\n\t\t\tif (mode == X86EMUL_MODE_PROT64)\n\t\t\t\tctxt->op_bytes = 8;\n\t\t\telse\n\t\t\t\tctxt->op_bytes = 4;\n\t\t}\n\n\t\tif ((ctxt->d & No16) && ctxt->op_bytes == 2)\n\t\t\tctxt->op_bytes = 4;\n\n\t\tif (ctxt->d & Sse)\n\t\t\tctxt->op_bytes = 16;\n\t\telse if (ctxt->d & Mmx)\n\t\t\tctxt->op_bytes = 8;\n\t}\n\n\t/* ModRM and SIB bytes. */\n\tif (ctxt->d & ModRM) {\n\t\trc = decode_modrm(ctxt, &ctxt->memop);\n\t\tif (!has_seg_override) {\n\t\t\thas_seg_override = true;\n\t\t\tctxt->seg_override = ctxt->modrm_seg;\n\t\t}\n\t} else if (ctxt->d & MemAbs)\n\t\trc = decode_abs(ctxt, &ctxt->memop);\n\tif (rc != X86EMUL_CONTINUE)\n\t\tgoto done;\n\n\tif (!has_seg_override)\n\t\tctxt->seg_override = VCPU_SREG_DS;\n\n\tctxt->memop.addr.mem.seg = ctxt->seg_override;\n\n\t/*\n\t * Decode and fetch the source operand: register, memory\n\t * or immediate.\n\t */\n\trc = decode_operand(ctxt, &ctxt->src, (ctxt->d >> SrcShift) & OpMask);\n\tif (rc != X86EMUL_CONTINUE)\n\t\tgoto done;\n\n\t/*\n\t * Decode and fetch the second source operand: register, memory\n\t * or immediate.\n\t */\n\trc = decode_operand(ctxt, &ctxt->src2, (ctxt->d >> Src2Shift) & OpMask);\n\tif (rc != X86EMUL_CONTINUE)\n\t\tgoto done;\n\n\t/* Decode and fetch the destination operand: register or memory. */\n\trc = decode_operand(ctxt, &ctxt->dst, (ctxt->d >> DstShift) & OpMask);\n\n\tif (ctxt->rip_relative)\n\t\tctxt->memopp->addr.mem.ea = address_mask(ctxt,\n\t\t\t\t\tctxt->memopp->addr.mem.ea + ctxt->_eip);\n\ndone:\n\treturn (rc != X86EMUL_CONTINUE) ? EMULATION_FAILED : EMULATION_OK;\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define No16\t    ((u64)1 << 53)  /* No 16 bit operand */",
            "#define NearBranch  ((u64)1 << 52)  /* Near branches */",
            "#define CheckPerm   ((u64)1 << 49)  /* Has valid check_perm field */",
            "#define Intercept   ((u64)1 << 48)  /* Has valid intercept field */",
            "#define Mmx         ((u64)1 << 40)  /* MMX Vector instruction */",
            "#define Src2Shift   (31)",
            "#define NotImpl     (1 << 30)   /* instruction is not implemented */",
            "#define Op3264      (1<<24) /* Operand is 64b in long mode, 32b otherwise */",
            "#define EmulateOnUD (1<<22) /* Emulate if unsupported by the host */",
            "#define ModRM       (1<<19)",
            "#define Sse         (1<<18)     /* SSE Vector instruction */",
            "#define ModeDual    (7<<15)     /* Different instruction for 32/64 bit */",
            "#define InstrDual   (6<<15)     /* Alternate instruction decoding of mod == 3 */",
            "#define Escape      (5<<15)     /* Escape to coprocessor instruction */",
            "#define RMExt       (4<<15)     /* Opcode extension in ModRM r/m if mod == 3 */",
            "#define Prefix      (3<<15)     /* Instruction varies with 66/f2/f3 prefix */",
            "#define GroupDual   (2<<15)     /* Alternate decoding of mod == 3 */",
            "#define Group       (1<<15)     /* Bits 3:5 of modrm byte extend opcode */",
            "#define GroupMask   (7<<15)     /* Opcode uses one of the group mechanisms */",
            "#define Stack       (1<<14)     /* Stack instruction (push/pop) */",
            "#define MemAbs      (1<<12)      /* Memory operand is absolute displacement */",
            "#define SrcShift    6",
            "#define DstShift    1",
            "#define OpMask             ((1ull << OpBits) - 1)"
          ],
          "globals_used": [
            "static const struct opcode opcode_table[256] = {\n\t/* 0x00 - 0x07 */\n\tF6ALU(Lock, em_add),\n\tI(ImplicitOps | Stack | No64 | Src2ES, em_push_sreg),\n\tI(ImplicitOps | Stack | No64 | Src2ES, em_pop_sreg),\n\t/* 0x08 - 0x0F */\n\tF6ALU(Lock | PageTable, em_or),\n\tI(ImplicitOps | Stack | No64 | Src2CS, em_push_sreg),\n\tN,\n\t/* 0x10 - 0x17 */\n\tF6ALU(Lock, em_adc),\n\tI(ImplicitOps | Stack | No64 | Src2SS, em_push_sreg),\n\tI(ImplicitOps | Stack | No64 | Src2SS, em_pop_sreg),\n\t/* 0x18 - 0x1F */\n\tF6ALU(Lock, em_sbb),\n\tI(ImplicitOps | Stack | No64 | Src2DS, em_push_sreg),\n\tI(ImplicitOps | Stack | No64 | Src2DS, em_pop_sreg),\n\t/* 0x20 - 0x27 */\n\tF6ALU(Lock | PageTable, em_and), N, N,\n\t/* 0x28 - 0x2F */\n\tF6ALU(Lock, em_sub), N, I(ByteOp | DstAcc | No64, em_das),\n\t/* 0x30 - 0x37 */\n\tF6ALU(Lock, em_xor), N, N,\n\t/* 0x38 - 0x3F */\n\tF6ALU(NoWrite, em_cmp), N, N,\n\t/* 0x40 - 0x4F */\n\tX8(F(DstReg, em_inc)), X8(F(DstReg, em_dec)),\n\t/* 0x50 - 0x57 */\n\tX8(I(SrcReg | Stack, em_push)),\n\t/* 0x58 - 0x5F */\n\tX8(I(DstReg | Stack, em_pop)),\n\t/* 0x60 - 0x67 */\n\tI(ImplicitOps | Stack | No64, em_pusha),\n\tI(ImplicitOps | Stack | No64, em_popa),\n\tN, MD(ModRM, &mode_dual_63),\n\tN, N, N, N,\n\t/* 0x68 - 0x6F */\n\tI(SrcImm | Mov | Stack, em_push),\n\tI(DstReg | SrcMem | ModRM | Src2Imm, em_imul_3op),\n\tI(SrcImmByte | Mov | Stack, em_push),\n\tI(DstReg | SrcMem | ModRM | Src2ImmByte, em_imul_3op),\n\tI2bvIP(DstDI | SrcDX | Mov | String | Unaligned, em_in, ins, check_perm_in), /* insb, insw/insd */\n\tI2bvIP(SrcSI | DstDX | String, em_out, outs, check_perm_out), /* outsb, outsw/outsd */\n\t/* 0x70 - 0x7F */\n\tX16(D(SrcImmByte | NearBranch)),\n\t/* 0x80 - 0x87 */\n\tG(ByteOp | DstMem | SrcImm, group1),\n\tG(DstMem | SrcImm, group1),\n\tG(ByteOp | DstMem | SrcImm | No64, group1),\n\tG(DstMem | SrcImmByte, group1),\n\tF2bv(DstMem | SrcReg | ModRM | NoWrite, em_test),\n\tI2bv(DstMem | SrcReg | ModRM | Lock | PageTable, em_xchg),\n\t/* 0x88 - 0x8F */\n\tI2bv(DstMem | SrcReg | ModRM | Mov | PageTable, em_mov),\n\tI2bv(DstReg | SrcMem | ModRM | Mov, em_mov),\n\tI(DstMem | SrcNone | ModRM | Mov | PageTable, em_mov_rm_sreg),\n\tD(ModRM | SrcMem | NoAccess | DstReg),\n\tI(ImplicitOps | SrcMem16 | ModRM, em_mov_sreg_rm),\n\tG(0, group1A),\n\t/* 0x90 - 0x97 */\n\tDI(SrcAcc | DstReg, pause), X7(D(SrcAcc | DstReg)),\n\t/* 0x98 - 0x9F */\n\tD(DstAcc | SrcNone), I(ImplicitOps | SrcAcc, em_cwd),\n\tI(SrcImmFAddr | No64, em_call_far), N,\n\tII(ImplicitOps | Stack, em_pushf, pushf),\n\tII(ImplicitOps | Stack, em_popf, popf),\n\tI(ImplicitOps, em_sahf), I(ImplicitOps, em_lahf),\n\t/* 0xA0 - 0xA7 */\n\tI2bv(DstAcc | SrcMem | Mov | MemAbs, em_mov),\n\tI2bv(DstMem | SrcAcc | Mov | MemAbs | PageTable, em_mov),\n\tI2bv(SrcSI | DstDI | Mov | String, em_mov),\n\tF2bv(SrcSI | DstDI | String | NoWrite, em_cmp_r),\n\t/* 0xA8 - 0xAF */\n\tF2bv(DstAcc | SrcImm | NoWrite, em_test),\n\tI2bv(SrcAcc | DstDI | Mov | String, em_mov),\n\tI2bv(SrcSI | DstAcc | Mov | String, em_mov),\n\tF2bv(SrcAcc | DstDI | String | NoWrite, em_cmp_r),\n\t/* 0xB0 - 0xB7 */\n\tX8(I(ByteOp | DstReg | SrcImm | Mov, em_mov)),\n\t/* 0xB8 - 0xBF */\n\tX8(I(DstReg | SrcImm64 | Mov, em_mov)),\n\t/* 0xC0 - 0xC7 */\n\tG(ByteOp | Src2ImmByte, group2), G(Src2ImmByte, group2),\n\tI(ImplicitOps | NearBranch | SrcImmU16, em_ret_near_imm),\n\tI(ImplicitOps | NearBranch, em_ret),\n\tI(DstReg | SrcMemFAddr | ModRM | No64 | Src2ES, em_lseg),\n\tI(DstReg | SrcMemFAddr | ModRM | No64 | Src2DS, em_lseg),\n\tG(ByteOp, group11), G(0, group11),\n\t/* 0xC8 - 0xCF */\n\tI(Stack | SrcImmU16 | Src2ImmByte, em_enter), I(Stack, em_leave),\n\tI(ImplicitOps | SrcImmU16, em_ret_far_imm),\n\tI(ImplicitOps, em_ret_far),\n\tD(ImplicitOps), DI(SrcImmByte, intn),\n\tD(ImplicitOps | No64), II(ImplicitOps, em_iret, iret),\n\t/* 0xD0 - 0xD7 */\n\tG(Src2One | ByteOp, group2), G(Src2One, group2),\n\tG(Src2CL | ByteOp, group2), G(Src2CL, group2),\n\tI(DstAcc | SrcImmUByte | No64, em_aam),\n\tI(DstAcc | SrcImmUByte | No64, em_aad),\n\tF(DstAcc | ByteOp | No64, em_salc),\n\tI(DstAcc | SrcXLat | ByteOp, em_mov),\n\t/* 0xD8 - 0xDF */\n\tN, E(0, &escape_d9), N, E(0, &escape_db), N, E(0, &escape_dd), N, N,\n\t/* 0xE0 - 0xE7 */\n\tX3(I(SrcImmByte | NearBranch, em_loop)),\n\tI(SrcImmByte | NearBranch, em_jcxz),\n\tI2bvIP(SrcImmUByte | DstAcc, em_in,  in,  check_perm_in),\n\tI2bvIP(SrcAcc | DstImmUByte, em_out, out, check_perm_out),\n\t/* 0xE8 - 0xEF */\n\tI(SrcImm | NearBranch, em_call), D(SrcImm | ImplicitOps | NearBranch),\n\tI(SrcImmFAddr | No64, em_jmp_far),\n\tD(SrcImmByte | ImplicitOps | NearBranch),\n\tI2bvIP(SrcDX | DstAcc, em_in,  in,  check_perm_in),\n\tI2bvIP(SrcAcc | DstDX, em_out, out, check_perm_out),\n\t/* 0xF0 - 0xF7 */\n\tN, DI(ImplicitOps, icebp), N, N,\n\tDI(ImplicitOps | Priv, hlt), D(ImplicitOps),\n\tG(ByteOp, group3), G(0, group3),\n\t/* 0xF8 - 0xFF */\n\tD(ImplicitOps), D(ImplicitOps),\n\tI(ImplicitOps, em_cli), I(ImplicitOps, em_sti),\n\tD(ImplicitOps), D(ImplicitOps), G(0, group4), G(0, group5),\n};",
            "static const struct opcode twobyte_table[256] = {\n\t/* 0x00 - 0x0F */\n\tG(0, group6), GD(0, &group7), N, N,\n\tN, I(ImplicitOps | EmulateOnUD, em_syscall),\n\tII(ImplicitOps | Priv, em_clts, clts), N,\n\tDI(ImplicitOps | Priv, invd), DI(ImplicitOps | Priv, wbinvd), N, N,\n\tN, D(ImplicitOps | ModRM | SrcMem | NoAccess), N, N,\n\t/* 0x10 - 0x1F */\n\tN, N, N, N, N, N, N, N,\n\tD(ImplicitOps | ModRM | SrcMem | NoAccess),\n\tN, N, N, N, N, N, D(ImplicitOps | ModRM | SrcMem | NoAccess),\n\t/* 0x20 - 0x2F */\n\tDIP(ModRM | DstMem | Priv | Op3264 | NoMod, cr_read, check_cr_read),\n\tDIP(ModRM | DstMem | Priv | Op3264 | NoMod, dr_read, check_dr_read),\n\tIIP(ModRM | SrcMem | Priv | Op3264 | NoMod, em_cr_write, cr_write,\n\t\t\t\t\t\tcheck_cr_write),\n\tIIP(ModRM | SrcMem | Priv | Op3264 | NoMod, em_dr_write, dr_write,\n\t\t\t\t\t\tcheck_dr_write),\n\tN, N, N, N,\n\tGP(ModRM | DstReg | SrcMem | Mov | Sse, &pfx_0f_28_0f_29),\n\tGP(ModRM | DstMem | SrcReg | Mov | Sse, &pfx_0f_28_0f_29),\n\tN, GP(ModRM | DstMem | SrcReg | Mov | Sse, &pfx_0f_2b),\n\tN, N, N, N,\n\t/* 0x30 - 0x3F */\n\tII(ImplicitOps | Priv, em_wrmsr, wrmsr),\n\tIIP(ImplicitOps, em_rdtsc, rdtsc, check_rdtsc),\n\tII(ImplicitOps | Priv, em_rdmsr, rdmsr),\n\tIIP(ImplicitOps, em_rdpmc, rdpmc, check_rdpmc),\n\tI(ImplicitOps | EmulateOnUD, em_sysenter),\n\tI(ImplicitOps | Priv | EmulateOnUD, em_sysexit),\n\tN, N,\n\tN, N, N, N, N, N, N, N,\n\t/* 0x40 - 0x4F */\n\tX16(D(DstReg | SrcMem | ModRM)),\n\t/* 0x50 - 0x5F */\n\tN, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N,\n\t/* 0x60 - 0x6F */\n\tN, N, N, N,\n\tN, N, N, N,\n\tN, N, N, N,\n\tN, N, N, GP(SrcMem | DstReg | ModRM | Mov, &pfx_0f_6f_0f_7f),\n\t/* 0x70 - 0x7F */\n\tN, N, N, N,\n\tN, N, N, N,\n\tN, N, N, N,\n\tN, N, N, GP(SrcReg | DstMem | ModRM | Mov, &pfx_0f_6f_0f_7f),\n\t/* 0x80 - 0x8F */\n\tX16(D(SrcImm | NearBranch)),\n\t/* 0x90 - 0x9F */\n\tX16(D(ByteOp | DstMem | SrcNone | ModRM| Mov)),\n\t/* 0xA0 - 0xA7 */\n\tI(Stack | Src2FS, em_push_sreg), I(Stack | Src2FS, em_pop_sreg),\n\tII(ImplicitOps, em_cpuid, cpuid),\n\tF(DstMem | SrcReg | ModRM | BitOp | NoWrite, em_bt),\n\tF(DstMem | SrcReg | Src2ImmByte | ModRM, em_shld),\n\tF(DstMem | SrcReg | Src2CL | ModRM, em_shld), N, N,\n\t/* 0xA8 - 0xAF */\n\tI(Stack | Src2GS, em_push_sreg), I(Stack | Src2GS, em_pop_sreg),\n\tII(EmulateOnUD | ImplicitOps, em_rsm, rsm),\n\tF(DstMem | SrcReg | ModRM | BitOp | Lock | PageTable, em_bts),\n\tF(DstMem | SrcReg | Src2ImmByte | ModRM, em_shrd),\n\tF(DstMem | SrcReg | Src2CL | ModRM, em_shrd),\n\tGD(0, &group15), F(DstReg | SrcMem | ModRM, em_imul),\n\t/* 0xB0 - 0xB7 */\n\tI2bv(DstMem | SrcReg | ModRM | Lock | PageTable | SrcWrite, em_cmpxchg),\n\tI(DstReg | SrcMemFAddr | ModRM | Src2SS, em_lseg),\n\tF(DstMem | SrcReg | ModRM | BitOp | Lock, em_btr),\n\tI(DstReg | SrcMemFAddr | ModRM | Src2FS, em_lseg),\n\tI(DstReg | SrcMemFAddr | ModRM | Src2GS, em_lseg),\n\tD(DstReg | SrcMem8 | ModRM | Mov), D(DstReg | SrcMem16 | ModRM | Mov),\n\t/* 0xB8 - 0xBF */\n\tN, N,\n\tG(BitOp, group8),\n\tF(DstMem | SrcReg | ModRM | BitOp | Lock | PageTable, em_btc),\n\tI(DstReg | SrcMem | ModRM, em_bsf_c),\n\tI(DstReg | SrcMem | ModRM, em_bsr_c),\n\tD(DstReg | SrcMem8 | ModRM | Mov), D(DstReg | SrcMem16 | ModRM | Mov),\n\t/* 0xC0 - 0xC7 */\n\tF2bv(DstMem | SrcReg | ModRM | SrcWrite | Lock, em_xadd),\n\tN, ID(0, &instr_dual_0f_c3),\n\tN, N, N, GD(0, &group9),\n\t/* 0xC8 - 0xCF */\n\tX8(I(DstReg, em_bswap)),\n\t/* 0xD0 - 0xDF */\n\tN, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N,\n\t/* 0xE0 - 0xEF */\n\tN, N, N, N, N, N, N, GP(SrcReg | DstMem | ModRM | Mov, &pfx_0f_e7),\n\tN, N, N, N, N, N, N, N,\n\t/* 0xF0 - 0xFF */\n\tN, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N\n};",
            "static const struct opcode opcode_map_0f_38[256] = {\n\t/* 0x00 - 0x7f */\n\tX16(N), X16(N), X16(N), X16(N), X16(N), X16(N), X16(N), X16(N),\n\t/* 0x80 - 0xef */\n\tX16(N), X16(N), X16(N), X16(N), X16(N), X16(N), X16(N),\n\t/* 0xf0 - 0xf1 */\n\tGP(EmulateOnUD | ModRM, &three_byte_0f_38_f0),\n\tGP(EmulateOnUD | ModRM, &three_byte_0f_38_f1),\n\t/* 0xf2 - 0xff */\n\tN, N, X4(N), X8(N)\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\n#define No16\t    ((u64)1 << 53)  /* No 16 bit operand */\n#define NearBranch  ((u64)1 << 52)  /* Near branches */\n#define CheckPerm   ((u64)1 << 49)  /* Has valid check_perm field */\n#define Intercept   ((u64)1 << 48)  /* Has valid intercept field */\n#define Mmx         ((u64)1 << 40)  /* MMX Vector instruction */\n#define Src2Shift   (31)\n#define NotImpl     (1 << 30)   /* instruction is not implemented */\n#define Op3264      (1<<24) /* Operand is 64b in long mode, 32b otherwise */\n#define EmulateOnUD (1<<22) /* Emulate if unsupported by the host */\n#define ModRM       (1<<19)\n#define Sse         (1<<18)     /* SSE Vector instruction */\n#define ModeDual    (7<<15)     /* Different instruction for 32/64 bit */\n#define InstrDual   (6<<15)     /* Alternate instruction decoding of mod == 3 */\n#define Escape      (5<<15)     /* Escape to coprocessor instruction */\n#define RMExt       (4<<15)     /* Opcode extension in ModRM r/m if mod == 3 */\n#define Prefix      (3<<15)     /* Instruction varies with 66/f2/f3 prefix */\n#define GroupDual   (2<<15)     /* Alternate decoding of mod == 3 */\n#define Group       (1<<15)     /* Bits 3:5 of modrm byte extend opcode */\n#define GroupMask   (7<<15)     /* Opcode uses one of the group mechanisms */\n#define Stack       (1<<14)     /* Stack instruction (push/pop) */\n#define MemAbs      (1<<12)      /* Memory operand is absolute displacement */\n#define SrcShift    6\n#define DstShift    1\n#define OpMask             ((1ull << OpBits) - 1)\n\nstatic const struct opcode opcode_table[256] = {\n\t/* 0x00 - 0x07 */\n\tF6ALU(Lock, em_add),\n\tI(ImplicitOps | Stack | No64 | Src2ES, em_push_sreg),\n\tI(ImplicitOps | Stack | No64 | Src2ES, em_pop_sreg),\n\t/* 0x08 - 0x0F */\n\tF6ALU(Lock | PageTable, em_or),\n\tI(ImplicitOps | Stack | No64 | Src2CS, em_push_sreg),\n\tN,\n\t/* 0x10 - 0x17 */\n\tF6ALU(Lock, em_adc),\n\tI(ImplicitOps | Stack | No64 | Src2SS, em_push_sreg),\n\tI(ImplicitOps | Stack | No64 | Src2SS, em_pop_sreg),\n\t/* 0x18 - 0x1F */\n\tF6ALU(Lock, em_sbb),\n\tI(ImplicitOps | Stack | No64 | Src2DS, em_push_sreg),\n\tI(ImplicitOps | Stack | No64 | Src2DS, em_pop_sreg),\n\t/* 0x20 - 0x27 */\n\tF6ALU(Lock | PageTable, em_and), N, N,\n\t/* 0x28 - 0x2F */\n\tF6ALU(Lock, em_sub), N, I(ByteOp | DstAcc | No64, em_das),\n\t/* 0x30 - 0x37 */\n\tF6ALU(Lock, em_xor), N, N,\n\t/* 0x38 - 0x3F */\n\tF6ALU(NoWrite, em_cmp), N, N,\n\t/* 0x40 - 0x4F */\n\tX8(F(DstReg, em_inc)), X8(F(DstReg, em_dec)),\n\t/* 0x50 - 0x57 */\n\tX8(I(SrcReg | Stack, em_push)),\n\t/* 0x58 - 0x5F */\n\tX8(I(DstReg | Stack, em_pop)),\n\t/* 0x60 - 0x67 */\n\tI(ImplicitOps | Stack | No64, em_pusha),\n\tI(ImplicitOps | Stack | No64, em_popa),\n\tN, MD(ModRM, &mode_dual_63),\n\tN, N, N, N,\n\t/* 0x68 - 0x6F */\n\tI(SrcImm | Mov | Stack, em_push),\n\tI(DstReg | SrcMem | ModRM | Src2Imm, em_imul_3op),\n\tI(SrcImmByte | Mov | Stack, em_push),\n\tI(DstReg | SrcMem | ModRM | Src2ImmByte, em_imul_3op),\n\tI2bvIP(DstDI | SrcDX | Mov | String | Unaligned, em_in, ins, check_perm_in), /* insb, insw/insd */\n\tI2bvIP(SrcSI | DstDX | String, em_out, outs, check_perm_out), /* outsb, outsw/outsd */\n\t/* 0x70 - 0x7F */\n\tX16(D(SrcImmByte | NearBranch)),\n\t/* 0x80 - 0x87 */\n\tG(ByteOp | DstMem | SrcImm, group1),\n\tG(DstMem | SrcImm, group1),\n\tG(ByteOp | DstMem | SrcImm | No64, group1),\n\tG(DstMem | SrcImmByte, group1),\n\tF2bv(DstMem | SrcReg | ModRM | NoWrite, em_test),\n\tI2bv(DstMem | SrcReg | ModRM | Lock | PageTable, em_xchg),\n\t/* 0x88 - 0x8F */\n\tI2bv(DstMem | SrcReg | ModRM | Mov | PageTable, em_mov),\n\tI2bv(DstReg | SrcMem | ModRM | Mov, em_mov),\n\tI(DstMem | SrcNone | ModRM | Mov | PageTable, em_mov_rm_sreg),\n\tD(ModRM | SrcMem | NoAccess | DstReg),\n\tI(ImplicitOps | SrcMem16 | ModRM, em_mov_sreg_rm),\n\tG(0, group1A),\n\t/* 0x90 - 0x97 */\n\tDI(SrcAcc | DstReg, pause), X7(D(SrcAcc | DstReg)),\n\t/* 0x98 - 0x9F */\n\tD(DstAcc | SrcNone), I(ImplicitOps | SrcAcc, em_cwd),\n\tI(SrcImmFAddr | No64, em_call_far), N,\n\tII(ImplicitOps | Stack, em_pushf, pushf),\n\tII(ImplicitOps | Stack, em_popf, popf),\n\tI(ImplicitOps, em_sahf), I(ImplicitOps, em_lahf),\n\t/* 0xA0 - 0xA7 */\n\tI2bv(DstAcc | SrcMem | Mov | MemAbs, em_mov),\n\tI2bv(DstMem | SrcAcc | Mov | MemAbs | PageTable, em_mov),\n\tI2bv(SrcSI | DstDI | Mov | String, em_mov),\n\tF2bv(SrcSI | DstDI | String | NoWrite, em_cmp_r),\n\t/* 0xA8 - 0xAF */\n\tF2bv(DstAcc | SrcImm | NoWrite, em_test),\n\tI2bv(SrcAcc | DstDI | Mov | String, em_mov),\n\tI2bv(SrcSI | DstAcc | Mov | String, em_mov),\n\tF2bv(SrcAcc | DstDI | String | NoWrite, em_cmp_r),\n\t/* 0xB0 - 0xB7 */\n\tX8(I(ByteOp | DstReg | SrcImm | Mov, em_mov)),\n\t/* 0xB8 - 0xBF */\n\tX8(I(DstReg | SrcImm64 | Mov, em_mov)),\n\t/* 0xC0 - 0xC7 */\n\tG(ByteOp | Src2ImmByte, group2), G(Src2ImmByte, group2),\n\tI(ImplicitOps | NearBranch | SrcImmU16, em_ret_near_imm),\n\tI(ImplicitOps | NearBranch, em_ret),\n\tI(DstReg | SrcMemFAddr | ModRM | No64 | Src2ES, em_lseg),\n\tI(DstReg | SrcMemFAddr | ModRM | No64 | Src2DS, em_lseg),\n\tG(ByteOp, group11), G(0, group11),\n\t/* 0xC8 - 0xCF */\n\tI(Stack | SrcImmU16 | Src2ImmByte, em_enter), I(Stack, em_leave),\n\tI(ImplicitOps | SrcImmU16, em_ret_far_imm),\n\tI(ImplicitOps, em_ret_far),\n\tD(ImplicitOps), DI(SrcImmByte, intn),\n\tD(ImplicitOps | No64), II(ImplicitOps, em_iret, iret),\n\t/* 0xD0 - 0xD7 */\n\tG(Src2One | ByteOp, group2), G(Src2One, group2),\n\tG(Src2CL | ByteOp, group2), G(Src2CL, group2),\n\tI(DstAcc | SrcImmUByte | No64, em_aam),\n\tI(DstAcc | SrcImmUByte | No64, em_aad),\n\tF(DstAcc | ByteOp | No64, em_salc),\n\tI(DstAcc | SrcXLat | ByteOp, em_mov),\n\t/* 0xD8 - 0xDF */\n\tN, E(0, &escape_d9), N, E(0, &escape_db), N, E(0, &escape_dd), N, N,\n\t/* 0xE0 - 0xE7 */\n\tX3(I(SrcImmByte | NearBranch, em_loop)),\n\tI(SrcImmByte | NearBranch, em_jcxz),\n\tI2bvIP(SrcImmUByte | DstAcc, em_in,  in,  check_perm_in),\n\tI2bvIP(SrcAcc | DstImmUByte, em_out, out, check_perm_out),\n\t/* 0xE8 - 0xEF */\n\tI(SrcImm | NearBranch, em_call), D(SrcImm | ImplicitOps | NearBranch),\n\tI(SrcImmFAddr | No64, em_jmp_far),\n\tD(SrcImmByte | ImplicitOps | NearBranch),\n\tI2bvIP(SrcDX | DstAcc, em_in,  in,  check_perm_in),\n\tI2bvIP(SrcAcc | DstDX, em_out, out, check_perm_out),\n\t/* 0xF0 - 0xF7 */\n\tN, DI(ImplicitOps, icebp), N, N,\n\tDI(ImplicitOps | Priv, hlt), D(ImplicitOps),\n\tG(ByteOp, group3), G(0, group3),\n\t/* 0xF8 - 0xFF */\n\tD(ImplicitOps), D(ImplicitOps),\n\tI(ImplicitOps, em_cli), I(ImplicitOps, em_sti),\n\tD(ImplicitOps), D(ImplicitOps), G(0, group4), G(0, group5),\n};\nstatic const struct opcode twobyte_table[256] = {\n\t/* 0x00 - 0x0F */\n\tG(0, group6), GD(0, &group7), N, N,\n\tN, I(ImplicitOps | EmulateOnUD, em_syscall),\n\tII(ImplicitOps | Priv, em_clts, clts), N,\n\tDI(ImplicitOps | Priv, invd), DI(ImplicitOps | Priv, wbinvd), N, N,\n\tN, D(ImplicitOps | ModRM | SrcMem | NoAccess), N, N,\n\t/* 0x10 - 0x1F */\n\tN, N, N, N, N, N, N, N,\n\tD(ImplicitOps | ModRM | SrcMem | NoAccess),\n\tN, N, N, N, N, N, D(ImplicitOps | ModRM | SrcMem | NoAccess),\n\t/* 0x20 - 0x2F */\n\tDIP(ModRM | DstMem | Priv | Op3264 | NoMod, cr_read, check_cr_read),\n\tDIP(ModRM | DstMem | Priv | Op3264 | NoMod, dr_read, check_dr_read),\n\tIIP(ModRM | SrcMem | Priv | Op3264 | NoMod, em_cr_write, cr_write,\n\t\t\t\t\t\tcheck_cr_write),\n\tIIP(ModRM | SrcMem | Priv | Op3264 | NoMod, em_dr_write, dr_write,\n\t\t\t\t\t\tcheck_dr_write),\n\tN, N, N, N,\n\tGP(ModRM | DstReg | SrcMem | Mov | Sse, &pfx_0f_28_0f_29),\n\tGP(ModRM | DstMem | SrcReg | Mov | Sse, &pfx_0f_28_0f_29),\n\tN, GP(ModRM | DstMem | SrcReg | Mov | Sse, &pfx_0f_2b),\n\tN, N, N, N,\n\t/* 0x30 - 0x3F */\n\tII(ImplicitOps | Priv, em_wrmsr, wrmsr),\n\tIIP(ImplicitOps, em_rdtsc, rdtsc, check_rdtsc),\n\tII(ImplicitOps | Priv, em_rdmsr, rdmsr),\n\tIIP(ImplicitOps, em_rdpmc, rdpmc, check_rdpmc),\n\tI(ImplicitOps | EmulateOnUD, em_sysenter),\n\tI(ImplicitOps | Priv | EmulateOnUD, em_sysexit),\n\tN, N,\n\tN, N, N, N, N, N, N, N,\n\t/* 0x40 - 0x4F */\n\tX16(D(DstReg | SrcMem | ModRM)),\n\t/* 0x50 - 0x5F */\n\tN, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N,\n\t/* 0x60 - 0x6F */\n\tN, N, N, N,\n\tN, N, N, N,\n\tN, N, N, N,\n\tN, N, N, GP(SrcMem | DstReg | ModRM | Mov, &pfx_0f_6f_0f_7f),\n\t/* 0x70 - 0x7F */\n\tN, N, N, N,\n\tN, N, N, N,\n\tN, N, N, N,\n\tN, N, N, GP(SrcReg | DstMem | ModRM | Mov, &pfx_0f_6f_0f_7f),\n\t/* 0x80 - 0x8F */\n\tX16(D(SrcImm | NearBranch)),\n\t/* 0x90 - 0x9F */\n\tX16(D(ByteOp | DstMem | SrcNone | ModRM| Mov)),\n\t/* 0xA0 - 0xA7 */\n\tI(Stack | Src2FS, em_push_sreg), I(Stack | Src2FS, em_pop_sreg),\n\tII(ImplicitOps, em_cpuid, cpuid),\n\tF(DstMem | SrcReg | ModRM | BitOp | NoWrite, em_bt),\n\tF(DstMem | SrcReg | Src2ImmByte | ModRM, em_shld),\n\tF(DstMem | SrcReg | Src2CL | ModRM, em_shld), N, N,\n\t/* 0xA8 - 0xAF */\n\tI(Stack | Src2GS, em_push_sreg), I(Stack | Src2GS, em_pop_sreg),\n\tII(EmulateOnUD | ImplicitOps, em_rsm, rsm),\n\tF(DstMem | SrcReg | ModRM | BitOp | Lock | PageTable, em_bts),\n\tF(DstMem | SrcReg | Src2ImmByte | ModRM, em_shrd),\n\tF(DstMem | SrcReg | Src2CL | ModRM, em_shrd),\n\tGD(0, &group15), F(DstReg | SrcMem | ModRM, em_imul),\n\t/* 0xB0 - 0xB7 */\n\tI2bv(DstMem | SrcReg | ModRM | Lock | PageTable | SrcWrite, em_cmpxchg),\n\tI(DstReg | SrcMemFAddr | ModRM | Src2SS, em_lseg),\n\tF(DstMem | SrcReg | ModRM | BitOp | Lock, em_btr),\n\tI(DstReg | SrcMemFAddr | ModRM | Src2FS, em_lseg),\n\tI(DstReg | SrcMemFAddr | ModRM | Src2GS, em_lseg),\n\tD(DstReg | SrcMem8 | ModRM | Mov), D(DstReg | SrcMem16 | ModRM | Mov),\n\t/* 0xB8 - 0xBF */\n\tN, N,\n\tG(BitOp, group8),\n\tF(DstMem | SrcReg | ModRM | BitOp | Lock | PageTable, em_btc),\n\tI(DstReg | SrcMem | ModRM, em_bsf_c),\n\tI(DstReg | SrcMem | ModRM, em_bsr_c),\n\tD(DstReg | SrcMem8 | ModRM | Mov), D(DstReg | SrcMem16 | ModRM | Mov),\n\t/* 0xC0 - 0xC7 */\n\tF2bv(DstMem | SrcReg | ModRM | SrcWrite | Lock, em_xadd),\n\tN, ID(0, &instr_dual_0f_c3),\n\tN, N, N, GD(0, &group9),\n\t/* 0xC8 - 0xCF */\n\tX8(I(DstReg, em_bswap)),\n\t/* 0xD0 - 0xDF */\n\tN, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N,\n\t/* 0xE0 - 0xEF */\n\tN, N, N, N, N, N, N, GP(SrcReg | DstMem | ModRM | Mov, &pfx_0f_e7),\n\tN, N, N, N, N, N, N, N,\n\t/* 0xF0 - 0xFF */\n\tN, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N\n};\nstatic const struct opcode opcode_map_0f_38[256] = {\n\t/* 0x00 - 0x7f */\n\tX16(N), X16(N), X16(N), X16(N), X16(N), X16(N), X16(N), X16(N),\n\t/* 0x80 - 0xef */\n\tX16(N), X16(N), X16(N), X16(N), X16(N), X16(N), X16(N),\n\t/* 0xf0 - 0xf1 */\n\tGP(EmulateOnUD | ModRM, &three_byte_0f_38_f0),\n\tGP(EmulateOnUD | ModRM, &three_byte_0f_38_f1),\n\t/* 0xf2 - 0xff */\n\tN, N, X4(N), X8(N)\n};\n\nint x86_decode_insn(struct x86_emulate_ctxt *ctxt, void *insn, int insn_len)\n{\n\tint rc = X86EMUL_CONTINUE;\n\tint mode = ctxt->mode;\n\tint def_op_bytes, def_ad_bytes, goffset, simd_prefix;\n\tbool op_prefix = false;\n\tbool has_seg_override = false;\n\tstruct opcode opcode;\n\n\tctxt->memop.type = OP_NONE;\n\tctxt->memopp = NULL;\n\tctxt->_eip = ctxt->eip;\n\tctxt->fetch.ptr = ctxt->fetch.data;\n\tctxt->fetch.end = ctxt->fetch.data + insn_len;\n\tctxt->opcode_len = 1;\n\tif (insn_len > 0)\n\t\tmemcpy(ctxt->fetch.data, insn, insn_len);\n\telse {\n\t\trc = __do_insn_fetch_bytes(ctxt, 1);\n\t\tif (rc != X86EMUL_CONTINUE)\n\t\t\treturn rc;\n\t}\n\n\tswitch (mode) {\n\tcase X86EMUL_MODE_REAL:\n\tcase X86EMUL_MODE_VM86:\n\tcase X86EMUL_MODE_PROT16:\n\t\tdef_op_bytes = def_ad_bytes = 2;\n\t\tbreak;\n\tcase X86EMUL_MODE_PROT32:\n\t\tdef_op_bytes = def_ad_bytes = 4;\n\t\tbreak;\n#ifdef CONFIG_X86_64\n\tcase X86EMUL_MODE_PROT64:\n\t\tdef_op_bytes = 4;\n\t\tdef_ad_bytes = 8;\n\t\tbreak;\n#endif\n\tdefault:\n\t\treturn EMULATION_FAILED;\n\t}\n\n\tctxt->op_bytes = def_op_bytes;\n\tctxt->ad_bytes = def_ad_bytes;\n\n\t/* Legacy prefixes. */\n\tfor (;;) {\n\t\tswitch (ctxt->b = insn_fetch(u8, ctxt)) {\n\t\tcase 0x66:\t/* operand-size override */\n\t\t\top_prefix = true;\n\t\t\t/* switch between 2/4 bytes */\n\t\t\tctxt->op_bytes = def_op_bytes ^ 6;\n\t\t\tbreak;\n\t\tcase 0x67:\t/* address-size override */\n\t\t\tif (mode == X86EMUL_MODE_PROT64)\n\t\t\t\t/* switch between 4/8 bytes */\n\t\t\t\tctxt->ad_bytes = def_ad_bytes ^ 12;\n\t\t\telse\n\t\t\t\t/* switch between 2/4 bytes */\n\t\t\t\tctxt->ad_bytes = def_ad_bytes ^ 6;\n\t\t\tbreak;\n\t\tcase 0x26:\t/* ES override */\n\t\tcase 0x2e:\t/* CS override */\n\t\tcase 0x36:\t/* SS override */\n\t\tcase 0x3e:\t/* DS override */\n\t\t\thas_seg_override = true;\n\t\t\tctxt->seg_override = (ctxt->b >> 3) & 3;\n\t\t\tbreak;\n\t\tcase 0x64:\t/* FS override */\n\t\tcase 0x65:\t/* GS override */\n\t\t\thas_seg_override = true;\n\t\t\tctxt->seg_override = ctxt->b & 7;\n\t\t\tbreak;\n\t\tcase 0x40 ... 0x4f: /* REX */\n\t\t\tif (mode != X86EMUL_MODE_PROT64)\n\t\t\t\tgoto done_prefixes;\n\t\t\tctxt->rex_prefix = ctxt->b;\n\t\t\tcontinue;\n\t\tcase 0xf0:\t/* LOCK */\n\t\t\tctxt->lock_prefix = 1;\n\t\t\tbreak;\n\t\tcase 0xf2:\t/* REPNE/REPNZ */\n\t\tcase 0xf3:\t/* REP/REPE/REPZ */\n\t\t\tctxt->rep_prefix = ctxt->b;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto done_prefixes;\n\t\t}\n\n\t\t/* Any legacy prefix after a REX prefix nullifies its effect. */\n\n\t\tctxt->rex_prefix = 0;\n\t}\n\ndone_prefixes:\n\n\t/* REX prefix. */\n\tif (ctxt->rex_prefix & 8)\n\t\tctxt->op_bytes = 8;\t/* REX.W */\n\n\t/* Opcode byte(s). */\n\topcode = opcode_table[ctxt->b];\n\t/* Two-byte opcode? */\n\tif (ctxt->b == 0x0f) {\n\t\tctxt->opcode_len = 2;\n\t\tctxt->b = insn_fetch(u8, ctxt);\n\t\topcode = twobyte_table[ctxt->b];\n\n\t\t/* 0F_38 opcode map */\n\t\tif (ctxt->b == 0x38) {\n\t\t\tctxt->opcode_len = 3;\n\t\t\tctxt->b = insn_fetch(u8, ctxt);\n\t\t\topcode = opcode_map_0f_38[ctxt->b];\n\t\t}\n\t}\n\tctxt->d = opcode.flags;\n\n\tif (ctxt->d & ModRM)\n\t\tctxt->modrm = insn_fetch(u8, ctxt);\n\n\t/* vex-prefix instructions are not implemented */\n\tif (ctxt->opcode_len == 1 && (ctxt->b == 0xc5 || ctxt->b == 0xc4) &&\n\t    (mode == X86EMUL_MODE_PROT64 || (ctxt->modrm & 0xc0) == 0xc0)) {\n\t\tctxt->d = NotImpl;\n\t}\n\n\twhile (ctxt->d & GroupMask) {\n\t\tswitch (ctxt->d & GroupMask) {\n\t\tcase Group:\n\t\t\tgoffset = (ctxt->modrm >> 3) & 7;\n\t\t\topcode = opcode.u.group[goffset];\n\t\t\tbreak;\n\t\tcase GroupDual:\n\t\t\tgoffset = (ctxt->modrm >> 3) & 7;\n\t\t\tif ((ctxt->modrm >> 6) == 3)\n\t\t\t\topcode = opcode.u.gdual->mod3[goffset];\n\t\t\telse\n\t\t\t\topcode = opcode.u.gdual->mod012[goffset];\n\t\t\tbreak;\n\t\tcase RMExt:\n\t\t\tgoffset = ctxt->modrm & 7;\n\t\t\topcode = opcode.u.group[goffset];\n\t\t\tbreak;\n\t\tcase Prefix:\n\t\t\tif (ctxt->rep_prefix && op_prefix)\n\t\t\t\treturn EMULATION_FAILED;\n\t\t\tsimd_prefix = op_prefix ? 0x66 : ctxt->rep_prefix;\n\t\t\tswitch (simd_prefix) {\n\t\t\tcase 0x00: opcode = opcode.u.gprefix->pfx_no; break;\n\t\t\tcase 0x66: opcode = opcode.u.gprefix->pfx_66; break;\n\t\t\tcase 0xf2: opcode = opcode.u.gprefix->pfx_f2; break;\n\t\t\tcase 0xf3: opcode = opcode.u.gprefix->pfx_f3; break;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Escape:\n\t\t\tif (ctxt->modrm > 0xbf)\n\t\t\t\topcode = opcode.u.esc->high[ctxt->modrm - 0xc0];\n\t\t\telse\n\t\t\t\topcode = opcode.u.esc->op[(ctxt->modrm >> 3) & 7];\n\t\t\tbreak;\n\t\tcase InstrDual:\n\t\t\tif ((ctxt->modrm >> 6) == 3)\n\t\t\t\topcode = opcode.u.idual->mod3;\n\t\t\telse\n\t\t\t\topcode = opcode.u.idual->mod012;\n\t\t\tbreak;\n\t\tcase ModeDual:\n\t\t\tif (ctxt->mode == X86EMUL_MODE_PROT64)\n\t\t\t\topcode = opcode.u.mdual->mode64;\n\t\t\telse\n\t\t\t\topcode = opcode.u.mdual->mode32;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn EMULATION_FAILED;\n\t\t}\n\n\t\tctxt->d &= ~(u64)GroupMask;\n\t\tctxt->d |= opcode.flags;\n\t}\n\n\t/* Unrecognised? */\n\tif (ctxt->d == 0)\n\t\treturn EMULATION_FAILED;\n\n\tctxt->execute = opcode.u.execute;\n\n\tif (unlikely(ctxt->ud) && likely(!(ctxt->d & EmulateOnUD)))\n\t\treturn EMULATION_FAILED;\n\n\tif (unlikely(ctxt->d &\n\t    (NotImpl|Stack|Op3264|Sse|Mmx|Intercept|CheckPerm|NearBranch|\n\t     No16))) {\n\t\t/*\n\t\t * These are copied unconditionally here, and checked unconditionally\n\t\t * in x86_emulate_insn.\n\t\t */\n\t\tctxt->check_perm = opcode.check_perm;\n\t\tctxt->intercept = opcode.intercept;\n\n\t\tif (ctxt->d & NotImpl)\n\t\t\treturn EMULATION_FAILED;\n\n\t\tif (mode == X86EMUL_MODE_PROT64) {\n\t\t\tif (ctxt->op_bytes == 4 && (ctxt->d & Stack))\n\t\t\t\tctxt->op_bytes = 8;\n\t\t\telse if (ctxt->d & NearBranch)\n\t\t\t\tctxt->op_bytes = 8;\n\t\t}\n\n\t\tif (ctxt->d & Op3264) {\n\t\t\tif (mode == X86EMUL_MODE_PROT64)\n\t\t\t\tctxt->op_bytes = 8;\n\t\t\telse\n\t\t\t\tctxt->op_bytes = 4;\n\t\t}\n\n\t\tif ((ctxt->d & No16) && ctxt->op_bytes == 2)\n\t\t\tctxt->op_bytes = 4;\n\n\t\tif (ctxt->d & Sse)\n\t\t\tctxt->op_bytes = 16;\n\t\telse if (ctxt->d & Mmx)\n\t\t\tctxt->op_bytes = 8;\n\t}\n\n\t/* ModRM and SIB bytes. */\n\tif (ctxt->d & ModRM) {\n\t\trc = decode_modrm(ctxt, &ctxt->memop);\n\t\tif (!has_seg_override) {\n\t\t\thas_seg_override = true;\n\t\t\tctxt->seg_override = ctxt->modrm_seg;\n\t\t}\n\t} else if (ctxt->d & MemAbs)\n\t\trc = decode_abs(ctxt, &ctxt->memop);\n\tif (rc != X86EMUL_CONTINUE)\n\t\tgoto done;\n\n\tif (!has_seg_override)\n\t\tctxt->seg_override = VCPU_SREG_DS;\n\n\tctxt->memop.addr.mem.seg = ctxt->seg_override;\n\n\t/*\n\t * Decode and fetch the source operand: register, memory\n\t * or immediate.\n\t */\n\trc = decode_operand(ctxt, &ctxt->src, (ctxt->d >> SrcShift) & OpMask);\n\tif (rc != X86EMUL_CONTINUE)\n\t\tgoto done;\n\n\t/*\n\t * Decode and fetch the second source operand: register, memory\n\t * or immediate.\n\t */\n\trc = decode_operand(ctxt, &ctxt->src2, (ctxt->d >> Src2Shift) & OpMask);\n\tif (rc != X86EMUL_CONTINUE)\n\t\tgoto done;\n\n\t/* Decode and fetch the destination operand: register or memory. */\n\trc = decode_operand(ctxt, &ctxt->dst, (ctxt->d >> DstShift) & OpMask);\n\n\tif (ctxt->rip_relative)\n\t\tctxt->memopp->addr.mem.ea = address_mask(ctxt,\n\t\t\t\t\tctxt->memopp->addr.mem.ea + ctxt->_eip);\n\ndone:\n\treturn (rc != X86EMUL_CONTINUE) ? EMULATION_FAILED : EMULATION_OK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_check_breakpoint",
          "args": [
            "vcpu",
            "&r"
          ],
          "line": 5432
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_vcpu_check_breakpoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "5366-5403",
          "snippet": "static bool kvm_vcpu_check_breakpoint(struct kvm_vcpu *vcpu, int *r)\n{\n\tif (unlikely(vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP) &&\n\t    (vcpu->arch.guest_debug_dr7 & DR7_BP_EN_MASK)) {\n\t\tstruct kvm_run *kvm_run = vcpu->run;\n\t\tunsigned long eip = kvm_get_linear_rip(vcpu);\n\t\tu32 dr6 = kvm_vcpu_check_hw_bp(eip, 0,\n\t\t\t\t\t   vcpu->arch.guest_debug_dr7,\n\t\t\t\t\t   vcpu->arch.eff_db);\n\n\t\tif (dr6 != 0) {\n\t\t\tkvm_run->debug.arch.dr6 = dr6 | DR6_FIXED_1 | DR6_RTM;\n\t\t\tkvm_run->debug.arch.pc = eip;\n\t\t\tkvm_run->debug.arch.exception = DB_VECTOR;\n\t\t\tkvm_run->exit_reason = KVM_EXIT_DEBUG;\n\t\t\t*r = EMULATE_USER_EXIT;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tif (unlikely(vcpu->arch.dr7 & DR7_BP_EN_MASK) &&\n\t    !(kvm_get_rflags(vcpu) & X86_EFLAGS_RF)) {\n\t\tunsigned long eip = kvm_get_linear_rip(vcpu);\n\t\tu32 dr6 = kvm_vcpu_check_hw_bp(eip, 0,\n\t\t\t\t\t   vcpu->arch.dr7,\n\t\t\t\t\t   vcpu->arch.db);\n\n\t\tif (dr6 != 0) {\n\t\t\tvcpu->arch.dr6 &= ~15;\n\t\t\tvcpu->arch.dr6 |= dr6 | DR6_RTM;\n\t\t\tkvm_queue_exception(vcpu, DB_VECTOR);\n\t\t\t*r = EMULATE_DONE;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic bool kvm_vcpu_check_breakpoint(struct kvm_vcpu *vcpu, int *r)\n{\n\tif (unlikely(vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP) &&\n\t    (vcpu->arch.guest_debug_dr7 & DR7_BP_EN_MASK)) {\n\t\tstruct kvm_run *kvm_run = vcpu->run;\n\t\tunsigned long eip = kvm_get_linear_rip(vcpu);\n\t\tu32 dr6 = kvm_vcpu_check_hw_bp(eip, 0,\n\t\t\t\t\t   vcpu->arch.guest_debug_dr7,\n\t\t\t\t\t   vcpu->arch.eff_db);\n\n\t\tif (dr6 != 0) {\n\t\t\tkvm_run->debug.arch.dr6 = dr6 | DR6_FIXED_1 | DR6_RTM;\n\t\t\tkvm_run->debug.arch.pc = eip;\n\t\t\tkvm_run->debug.arch.exception = DB_VECTOR;\n\t\t\tkvm_run->exit_reason = KVM_EXIT_DEBUG;\n\t\t\t*r = EMULATE_USER_EXIT;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tif (unlikely(vcpu->arch.dr7 & DR7_BP_EN_MASK) &&\n\t    !(kvm_get_rflags(vcpu) & X86_EFLAGS_RF)) {\n\t\tunsigned long eip = kvm_get_linear_rip(vcpu);\n\t\tu32 dr6 = kvm_vcpu_check_hw_bp(eip, 0,\n\t\t\t\t\t   vcpu->arch.dr7,\n\t\t\t\t\t   vcpu->arch.db);\n\n\t\tif (dr6 != 0) {\n\t\t\tvcpu->arch.dr6 &= ~15;\n\t\t\tvcpu->arch.dr6 |= dr6 | DR6_RTM;\n\t\t\tkvm_queue_exception(vcpu, DB_VECTOR);\n\t\t\t*r = EMULATE_DONE;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_emulate_ctxt",
          "args": [
            "vcpu"
          ],
          "line": 5424
        },
        "resolved": true,
        "details": {
          "function_name": "init_emulate_ctxt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "5103-5124",
          "snippet": "static void init_emulate_ctxt(struct kvm_vcpu *vcpu)\n{\n\tstruct x86_emulate_ctxt *ctxt = &vcpu->arch.emulate_ctxt;\n\tint cs_db, cs_l;\n\n\tkvm_x86_ops->get_cs_db_l_bits(vcpu, &cs_db, &cs_l);\n\n\tctxt->eflags = kvm_get_rflags(vcpu);\n\tctxt->eip = kvm_rip_read(vcpu);\n\tctxt->mode = (!is_protmode(vcpu))\t\t? X86EMUL_MODE_REAL :\n\t\t     (ctxt->eflags & X86_EFLAGS_VM)\t? X86EMUL_MODE_VM86 :\n\t\t     (cs_l && is_long_mode(vcpu))\t? X86EMUL_MODE_PROT64 :\n\t\t     cs_db\t\t\t\t? X86EMUL_MODE_PROT32 :\n\t\t\t\t\t\t\t  X86EMUL_MODE_PROT16;\n\tBUILD_BUG_ON(HF_GUEST_MASK != X86EMUL_GUEST_MASK);\n\tBUILD_BUG_ON(HF_SMM_MASK != X86EMUL_SMM_MASK);\n\tBUILD_BUG_ON(HF_SMM_INSIDE_NMI_MASK != X86EMUL_SMM_INSIDE_NMI_MASK);\n\tctxt->emul_flags = vcpu->arch.hflags;\n\n\tinit_decode_cache(ctxt);\n\tvcpu->arch.emulate_regs_need_sync_from_vcpu = false;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "struct kvm_x86_ops *kvm_x86_ops",
            "static int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\nstatic int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);\n\nstatic void init_emulate_ctxt(struct kvm_vcpu *vcpu)\n{\n\tstruct x86_emulate_ctxt *ctxt = &vcpu->arch.emulate_ctxt;\n\tint cs_db, cs_l;\n\n\tkvm_x86_ops->get_cs_db_l_bits(vcpu, &cs_db, &cs_l);\n\n\tctxt->eflags = kvm_get_rflags(vcpu);\n\tctxt->eip = kvm_rip_read(vcpu);\n\tctxt->mode = (!is_protmode(vcpu))\t\t? X86EMUL_MODE_REAL :\n\t\t     (ctxt->eflags & X86_EFLAGS_VM)\t? X86EMUL_MODE_VM86 :\n\t\t     (cs_l && is_long_mode(vcpu))\t? X86EMUL_MODE_PROT64 :\n\t\t     cs_db\t\t\t\t? X86EMUL_MODE_PROT32 :\n\t\t\t\t\t\t\t  X86EMUL_MODE_PROT16;\n\tBUILD_BUG_ON(HF_GUEST_MASK != X86EMUL_GUEST_MASK);\n\tBUILD_BUG_ON(HF_SMM_MASK != X86EMUL_SMM_MASK);\n\tBUILD_BUG_ON(HF_SMM_INSIDE_NMI_MASK != X86EMUL_SMM_INSIDE_NMI_MASK);\n\tctxt->emul_flags = vcpu->arch.hflags;\n\n\tinit_decode_cache(ctxt);\n\tvcpu->arch.emulate_regs_need_sync_from_vcpu = false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_clear_exception_queue",
          "args": [
            "vcpu"
          ],
          "line": 5421
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_clear_exception_queue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.h",
          "lines": "9-12",
          "snippet": "static inline void kvm_clear_exception_queue(struct kvm_vcpu *vcpu)\n{\n\tvcpu->arch.exception.pending = false;\n}",
          "includes": [
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline void kvm_clear_exception_queue(struct kvm_vcpu *vcpu)\n{\n\tvcpu->arch.exception.pending = false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define EXCPT_TRAP\t\t1\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void __kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags);\nstruct kvm_x86_ops *kvm_x86_ops;\nstatic int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);\n\nint x86_emulate_instruction(struct kvm_vcpu *vcpu,\n\t\t\t    unsigned long cr2,\n\t\t\t    int emulation_type,\n\t\t\t    void *insn,\n\t\t\t    int insn_len)\n{\n\tint r;\n\tstruct x86_emulate_ctxt *ctxt = &vcpu->arch.emulate_ctxt;\n\tbool writeback = true;\n\tbool write_fault_to_spt = vcpu->arch.write_fault_to_shadow_pgtable;\n\n\t/*\n\t * Clear write_fault_to_shadow_pgtable here to ensure it is\n\t * never reused.\n\t */\n\tvcpu->arch.write_fault_to_shadow_pgtable = false;\n\tkvm_clear_exception_queue(vcpu);\n\n\tif (!(emulation_type & EMULTYPE_NO_DECODE)) {\n\t\tinit_emulate_ctxt(vcpu);\n\n\t\t/*\n\t\t * We will reenter on the same instruction since\n\t\t * we do not set complete_userspace_io.  This does not\n\t\t * handle watchpoints yet, those would be handled in\n\t\t * the emulate_ops.\n\t\t */\n\t\tif (kvm_vcpu_check_breakpoint(vcpu, &r))\n\t\t\treturn r;\n\n\t\tctxt->interruptibility = 0;\n\t\tctxt->have_exception = false;\n\t\tctxt->exception.vector = -1;\n\t\tctxt->perm_ok = false;\n\n\t\tctxt->ud = emulation_type & EMULTYPE_TRAP_UD;\n\n\t\tr = x86_decode_insn(ctxt, insn, insn_len);\n\n\t\ttrace_kvm_emulate_insn_start(vcpu);\n\t\t++vcpu->stat.insn_emulation;\n\t\tif (r != EMULATION_OK)  {\n\t\t\tif (emulation_type & EMULTYPE_TRAP_UD)\n\t\t\t\treturn EMULATE_FAIL;\n\t\t\tif (reexecute_instruction(vcpu, cr2, write_fault_to_spt,\n\t\t\t\t\t\temulation_type))\n\t\t\t\treturn EMULATE_DONE;\n\t\t\tif (emulation_type & EMULTYPE_SKIP)\n\t\t\t\treturn EMULATE_FAIL;\n\t\t\treturn handle_emulation_failure(vcpu);\n\t\t}\n\t}\n\n\tif (emulation_type & EMULTYPE_SKIP) {\n\t\tkvm_rip_write(vcpu, ctxt->_eip);\n\t\tif (ctxt->eflags & X86_EFLAGS_RF)\n\t\t\tkvm_set_rflags(vcpu, ctxt->eflags & ~X86_EFLAGS_RF);\n\t\treturn EMULATE_DONE;\n\t}\n\n\tif (retry_instruction(ctxt, cr2, emulation_type))\n\t\treturn EMULATE_DONE;\n\n\t/* this is needed for vmware backdoor interface to work since it\n\t   changes registers values  during IO operation */\n\tif (vcpu->arch.emulate_regs_need_sync_from_vcpu) {\n\t\tvcpu->arch.emulate_regs_need_sync_from_vcpu = false;\n\t\temulator_invalidate_register_cache(ctxt);\n\t}\n\nrestart:\n\tr = x86_emulate_insn(ctxt);\n\n\tif (r == EMULATION_INTERCEPTED)\n\t\treturn EMULATE_DONE;\n\n\tif (r == EMULATION_FAILED) {\n\t\tif (reexecute_instruction(vcpu, cr2, write_fault_to_spt,\n\t\t\t\t\temulation_type))\n\t\t\treturn EMULATE_DONE;\n\n\t\treturn handle_emulation_failure(vcpu);\n\t}\n\n\tif (ctxt->have_exception) {\n\t\tr = EMULATE_DONE;\n\t\tif (inject_emulated_exception(vcpu))\n\t\t\treturn r;\n\t} else if (vcpu->arch.pio.count) {\n\t\tif (!vcpu->arch.pio.in) {\n\t\t\t/* FIXME: return into emulator if single-stepping.  */\n\t\t\tvcpu->arch.pio.count = 0;\n\t\t} else {\n\t\t\twriteback = false;\n\t\t\tvcpu->arch.complete_userspace_io = complete_emulated_pio;\n\t\t}\n\t\tr = EMULATE_USER_EXIT;\n\t} else if (vcpu->mmio_needed) {\n\t\tif (!vcpu->mmio_is_write)\n\t\t\twriteback = false;\n\t\tr = EMULATE_USER_EXIT;\n\t\tvcpu->arch.complete_userspace_io = complete_emulated_mmio;\n\t} else if (r == EMULATION_RESTART)\n\t\tgoto restart;\n\telse\n\t\tr = EMULATE_DONE;\n\n\tif (writeback) {\n\t\tunsigned long rflags = kvm_x86_ops->get_rflags(vcpu);\n\t\ttoggle_interruptibility(vcpu, ctxt->interruptibility);\n\t\tvcpu->arch.emulate_regs_need_sync_to_vcpu = false;\n\t\tif (vcpu->arch.hflags != ctxt->emul_flags)\n\t\t\tkvm_set_hflags(vcpu, ctxt->emul_flags);\n\t\tkvm_rip_write(vcpu, ctxt->eip);\n\t\tif (r == EMULATE_DONE)\n\t\t\tkvm_vcpu_check_singlestep(vcpu, rflags, &r);\n\t\tif (!ctxt->have_exception ||\n\t\t    exception_type(ctxt->exception.vector) == EXCPT_TRAP)\n\t\t\t__kvm_set_rflags(vcpu, ctxt->eflags);\n\n\t\t/*\n\t\t * For STI, interrupts are shadowed; so KVM_REQ_EVENT will\n\t\t * do nothing, and it will be requested again as soon as\n\t\t * the shadow expires.  But we still need to check here,\n\t\t * because POPF has no interrupt shadow.\n\t\t */\n\t\tif (unlikely((ctxt->eflags & ~rflags) & X86_EFLAGS_IF))\n\t\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t} else\n\t\tvcpu->arch.emulate_regs_need_sync_to_vcpu = true;\n\n\treturn r;\n}"
  },
  {
    "function_name": "kvm_vcpu_check_breakpoint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "5366-5403",
    "snippet": "static bool kvm_vcpu_check_breakpoint(struct kvm_vcpu *vcpu, int *r)\n{\n\tif (unlikely(vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP) &&\n\t    (vcpu->arch.guest_debug_dr7 & DR7_BP_EN_MASK)) {\n\t\tstruct kvm_run *kvm_run = vcpu->run;\n\t\tunsigned long eip = kvm_get_linear_rip(vcpu);\n\t\tu32 dr6 = kvm_vcpu_check_hw_bp(eip, 0,\n\t\t\t\t\t   vcpu->arch.guest_debug_dr7,\n\t\t\t\t\t   vcpu->arch.eff_db);\n\n\t\tif (dr6 != 0) {\n\t\t\tkvm_run->debug.arch.dr6 = dr6 | DR6_FIXED_1 | DR6_RTM;\n\t\t\tkvm_run->debug.arch.pc = eip;\n\t\t\tkvm_run->debug.arch.exception = DB_VECTOR;\n\t\t\tkvm_run->exit_reason = KVM_EXIT_DEBUG;\n\t\t\t*r = EMULATE_USER_EXIT;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tif (unlikely(vcpu->arch.dr7 & DR7_BP_EN_MASK) &&\n\t    !(kvm_get_rflags(vcpu) & X86_EFLAGS_RF)) {\n\t\tunsigned long eip = kvm_get_linear_rip(vcpu);\n\t\tu32 dr6 = kvm_vcpu_check_hw_bp(eip, 0,\n\t\t\t\t\t   vcpu->arch.dr7,\n\t\t\t\t\t   vcpu->arch.db);\n\n\t\tif (dr6 != 0) {\n\t\t\tvcpu->arch.dr6 &= ~15;\n\t\t\tvcpu->arch.dr6 |= dr6 | DR6_RTM;\n\t\t\tkvm_queue_exception(vcpu, DB_VECTOR);\n\t\t\t*r = EMULATE_DONE;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_queue_exception",
          "args": [
            "vcpu",
            "DB_VECTOR"
          ],
          "line": 5396
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_queue_exception",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "409-412",
          "snippet": "void kvm_queue_exception(struct kvm_vcpu *vcpu, unsigned nr)\n{\n\tkvm_multiple_exception(vcpu, nr, false, 0, false);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nvoid kvm_queue_exception(struct kvm_vcpu *vcpu, unsigned nr)\n{\n\tkvm_multiple_exception(vcpu, nr, false, 0, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_check_hw_bp",
          "args": [
            "eip",
            "0",
            "vcpu->arch.dr7",
            "vcpu->arch.db"
          ],
          "line": 5389
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_vcpu_check_hw_bp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "5317-5330",
          "snippet": "static int kvm_vcpu_check_hw_bp(unsigned long addr, u32 type, u32 dr7,\n\t\t\t\tunsigned long *db)\n{\n\tu32 dr6 = 0;\n\tint i;\n\tu32 enable, rwlen;\n\n\tenable = dr7;\n\trwlen = dr7 >> 16;\n\tfor (i = 0; i < 4; i++, enable >>= 2, rwlen >>= 4)\n\t\tif ((enable & 3) && (rwlen & 15) == type && db[i] == addr)\n\t\t\tdr6 |= (1 << i);\n\treturn dr6;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int kvm_vcpu_check_hw_bp(unsigned long addr, u32 type, u32 dr7,\n\t\t\t\tunsigned long *db)\n{\n\tu32 dr6 = 0;\n\tint i;\n\tu32 enable, rwlen;\n\n\tenable = dr7;\n\trwlen = dr7 >> 16;\n\tfor (i = 0; i < 4; i++, enable >>= 2, rwlen >>= 4)\n\t\tif ((enable & 3) && (rwlen & 15) == type && db[i] == addr)\n\t\t\tdr6 |= (1 << i);\n\treturn dr6;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_get_linear_rip",
          "args": [
            "vcpu"
          ],
          "line": 5388
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_get_linear_rip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "8148-8154",
          "snippet": "unsigned long kvm_get_linear_rip(struct kvm_vcpu *vcpu)\n{\n\tif (is_64_bit_mode(vcpu))\n\t\treturn kvm_rip_read(vcpu);\n\treturn (u32)(get_segment_base(vcpu, VCPU_SREG_CS) +\n\t\t     kvm_rip_read(vcpu));\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nunsigned long kvm_get_linear_rip(struct kvm_vcpu *vcpu)\n{\n\tif (is_64_bit_mode(vcpu))\n\t\treturn kvm_rip_read(vcpu);\n\treturn (u32)(get_segment_base(vcpu, VCPU_SREG_CS) +\n\t\t     kvm_rip_read(vcpu));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_get_rflags",
          "args": [
            "vcpu"
          ],
          "line": 5387
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_get_rflags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "8163-8171",
          "snippet": "unsigned long kvm_get_rflags(struct kvm_vcpu *vcpu)\n{\n\tunsigned long rflags;\n\n\trflags = kvm_x86_ops->get_rflags(vcpu);\n\tif (vcpu->guest_debug & KVM_GUESTDBG_SINGLESTEP)\n\t\trflags &= ~X86_EFLAGS_TF;\n\treturn rflags;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void __kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags);",
            "struct kvm_x86_ops *kvm_x86_ops"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void __kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nunsigned long kvm_get_rflags(struct kvm_vcpu *vcpu)\n{\n\tunsigned long rflags;\n\n\trflags = kvm_x86_ops->get_rflags(vcpu);\n\tif (vcpu->guest_debug & KVM_GUESTDBG_SINGLESTEP)\n\t\trflags &= ~X86_EFLAGS_TF;\n\treturn rflags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "vcpu->arch.dr7 & DR7_BP_EN_MASK"
          ],
          "line": 5386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP"
          ],
          "line": 5368
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic bool kvm_vcpu_check_breakpoint(struct kvm_vcpu *vcpu, int *r)\n{\n\tif (unlikely(vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP) &&\n\t    (vcpu->arch.guest_debug_dr7 & DR7_BP_EN_MASK)) {\n\t\tstruct kvm_run *kvm_run = vcpu->run;\n\t\tunsigned long eip = kvm_get_linear_rip(vcpu);\n\t\tu32 dr6 = kvm_vcpu_check_hw_bp(eip, 0,\n\t\t\t\t\t   vcpu->arch.guest_debug_dr7,\n\t\t\t\t\t   vcpu->arch.eff_db);\n\n\t\tif (dr6 != 0) {\n\t\t\tkvm_run->debug.arch.dr6 = dr6 | DR6_FIXED_1 | DR6_RTM;\n\t\t\tkvm_run->debug.arch.pc = eip;\n\t\t\tkvm_run->debug.arch.exception = DB_VECTOR;\n\t\t\tkvm_run->exit_reason = KVM_EXIT_DEBUG;\n\t\t\t*r = EMULATE_USER_EXIT;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tif (unlikely(vcpu->arch.dr7 & DR7_BP_EN_MASK) &&\n\t    !(kvm_get_rflags(vcpu) & X86_EFLAGS_RF)) {\n\t\tunsigned long eip = kvm_get_linear_rip(vcpu);\n\t\tu32 dr6 = kvm_vcpu_check_hw_bp(eip, 0,\n\t\t\t\t\t   vcpu->arch.dr7,\n\t\t\t\t\t   vcpu->arch.db);\n\n\t\tif (dr6 != 0) {\n\t\t\tvcpu->arch.dr6 &= ~15;\n\t\t\tvcpu->arch.dr6 |= dr6 | DR6_RTM;\n\t\t\tkvm_queue_exception(vcpu, DB_VECTOR);\n\t\t\t*r = EMULATE_DONE;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}"
  },
  {
    "function_name": "kvm_vcpu_check_singlestep",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "5332-5364",
    "snippet": "static void kvm_vcpu_check_singlestep(struct kvm_vcpu *vcpu, unsigned long rflags, int *r)\n{\n\tstruct kvm_run *kvm_run = vcpu->run;\n\n\t/*\n\t * rflags is the old, \"raw\" value of the flags.  The new value has\n\t * not been saved yet.\n\t *\n\t * This is correct even for TF set by the guest, because \"the\n\t * processor will not generate this exception after the instruction\n\t * that sets the TF flag\".\n\t */\n\tif (unlikely(rflags & X86_EFLAGS_TF)) {\n\t\tif (vcpu->guest_debug & KVM_GUESTDBG_SINGLESTEP) {\n\t\t\tkvm_run->debug.arch.dr6 = DR6_BS | DR6_FIXED_1 |\n\t\t\t\t\t\t  DR6_RTM;\n\t\t\tkvm_run->debug.arch.pc = vcpu->arch.singlestep_rip;\n\t\t\tkvm_run->debug.arch.exception = DB_VECTOR;\n\t\t\tkvm_run->exit_reason = KVM_EXIT_DEBUG;\n\t\t\t*r = EMULATE_USER_EXIT;\n\t\t} else {\n\t\t\tvcpu->arch.emulate_ctxt.eflags &= ~X86_EFLAGS_TF;\n\t\t\t/*\n\t\t\t * \"Certain debug exceptions may clear bit 0-3.  The\n\t\t\t * remaining contents of the DR6 register are never\n\t\t\t * cleared by the processor\".\n\t\t\t */\n\t\t\tvcpu->arch.dr6 &= ~15;\n\t\t\tvcpu->arch.dr6 |= DR6_BS | DR6_RTM;\n\t\t\tkvm_queue_exception(vcpu, DB_VECTOR);\n\t\t}\n\t}\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);",
      "static void __kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_queue_exception",
          "args": [
            "vcpu",
            "DB_VECTOR"
          ],
          "line": 5361
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_queue_exception",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "409-412",
          "snippet": "void kvm_queue_exception(struct kvm_vcpu *vcpu, unsigned nr)\n{\n\tkvm_multiple_exception(vcpu, nr, false, 0, false);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nvoid kvm_queue_exception(struct kvm_vcpu *vcpu, unsigned nr)\n{\n\tkvm_multiple_exception(vcpu, nr, false, 0, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "rflags & X86_EFLAGS_TF"
          ],
          "line": 5344
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void __kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags);\n\nstatic void kvm_vcpu_check_singlestep(struct kvm_vcpu *vcpu, unsigned long rflags, int *r)\n{\n\tstruct kvm_run *kvm_run = vcpu->run;\n\n\t/*\n\t * rflags is the old, \"raw\" value of the flags.  The new value has\n\t * not been saved yet.\n\t *\n\t * This is correct even for TF set by the guest, because \"the\n\t * processor will not generate this exception after the instruction\n\t * that sets the TF flag\".\n\t */\n\tif (unlikely(rflags & X86_EFLAGS_TF)) {\n\t\tif (vcpu->guest_debug & KVM_GUESTDBG_SINGLESTEP) {\n\t\t\tkvm_run->debug.arch.dr6 = DR6_BS | DR6_FIXED_1 |\n\t\t\t\t\t\t  DR6_RTM;\n\t\t\tkvm_run->debug.arch.pc = vcpu->arch.singlestep_rip;\n\t\t\tkvm_run->debug.arch.exception = DB_VECTOR;\n\t\t\tkvm_run->exit_reason = KVM_EXIT_DEBUG;\n\t\t\t*r = EMULATE_USER_EXIT;\n\t\t} else {\n\t\t\tvcpu->arch.emulate_ctxt.eflags &= ~X86_EFLAGS_TF;\n\t\t\t/*\n\t\t\t * \"Certain debug exceptions may clear bit 0-3.  The\n\t\t\t * remaining contents of the DR6 register are never\n\t\t\t * cleared by the processor\".\n\t\t\t */\n\t\t\tvcpu->arch.dr6 &= ~15;\n\t\t\tvcpu->arch.dr6 |= DR6_BS | DR6_RTM;\n\t\t\tkvm_queue_exception(vcpu, DB_VECTOR);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "kvm_vcpu_check_hw_bp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "5317-5330",
    "snippet": "static int kvm_vcpu_check_hw_bp(unsigned long addr, u32 type, u32 dr7,\n\t\t\t\tunsigned long *db)\n{\n\tu32 dr6 = 0;\n\tint i;\n\tu32 enable, rwlen;\n\n\tenable = dr7;\n\trwlen = dr7 >> 16;\n\tfor (i = 0; i < 4; i++, enable >>= 2, rwlen >>= 4)\n\t\tif ((enable & 3) && (rwlen & 15) == type && db[i] == addr)\n\t\t\tdr6 |= (1 << i);\n\treturn dr6;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int kvm_vcpu_check_hw_bp(unsigned long addr, u32 type, u32 dr7,\n\t\t\t\tunsigned long *db)\n{\n\tu32 dr6 = 0;\n\tint i;\n\tu32 enable, rwlen;\n\n\tenable = dr7;\n\trwlen = dr7 >> 16;\n\tfor (i = 0; i < 4; i++, enable >>= 2, rwlen >>= 4)\n\t\tif ((enable & 3) && (rwlen & 15) == type && db[i] == addr)\n\t\t\tdr6 |= (1 << i);\n\treturn dr6;\n}"
  },
  {
    "function_name": "kvm_set_hflags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "5307-5315",
    "snippet": "static void kvm_set_hflags(struct kvm_vcpu *vcpu, unsigned emul_flags)\n{\n\tunsigned changed = vcpu->arch.hflags ^ emul_flags;\n\n\tvcpu->arch.hflags = emul_flags;\n\n\tif (changed & HF_SMM_MASK)\n\t\tkvm_smm_changed(vcpu);\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_smm_changed",
          "args": [
            "vcpu"
          ],
          "line": 5314
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_smm_changed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "5289-5305",
          "snippet": "static void kvm_smm_changed(struct kvm_vcpu *vcpu)\n{\n\tif (!(vcpu->arch.hflags & HF_SMM_MASK)) {\n\t\t/* This is a good place to trace that we are exiting SMM.  */\n\t\ttrace_kvm_enter_smm(vcpu->vcpu_id, vcpu->arch.smbase, false);\n\n\t\tif (unlikely(vcpu->arch.smi_pending)) {\n\t\t\tkvm_make_request(KVM_REQ_SMI, vcpu);\n\t\t\tvcpu->arch.smi_pending = 0;\n\t\t} else {\n\t\t\t/* Process a latched INIT, if any.  */\n\t\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t\t}\n\t}\n\n\tkvm_mmu_reset_context(vcpu);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu)\n{\n\tif (!(vcpu->arch.hflags & HF_SMM_MASK)) {\n\t\t/* This is a good place to trace that we are exiting SMM.  */\n\t\ttrace_kvm_enter_smm(vcpu->vcpu_id, vcpu->arch.smbase, false);\n\n\t\tif (unlikely(vcpu->arch.smi_pending)) {\n\t\t\tkvm_make_request(KVM_REQ_SMI, vcpu);\n\t\t\tvcpu->arch.smi_pending = 0;\n\t\t} else {\n\t\t\t/* Process a latched INIT, if any.  */\n\t\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t\t}\n\t}\n\n\tkvm_mmu_reset_context(vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic void kvm_set_hflags(struct kvm_vcpu *vcpu, unsigned emul_flags)\n{\n\tunsigned changed = vcpu->arch.hflags ^ emul_flags;\n\n\tvcpu->arch.hflags = emul_flags;\n\n\tif (changed & HF_SMM_MASK)\n\t\tkvm_smm_changed(vcpu);\n}"
  },
  {
    "function_name": "kvm_smm_changed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "5289-5305",
    "snippet": "static void kvm_smm_changed(struct kvm_vcpu *vcpu)\n{\n\tif (!(vcpu->arch.hflags & HF_SMM_MASK)) {\n\t\t/* This is a good place to trace that we are exiting SMM.  */\n\t\ttrace_kvm_enter_smm(vcpu->vcpu_id, vcpu->arch.smbase, false);\n\n\t\tif (unlikely(vcpu->arch.smi_pending)) {\n\t\t\tkvm_make_request(KVM_REQ_SMI, vcpu);\n\t\t\tvcpu->arch.smi_pending = 0;\n\t\t} else {\n\t\t\t/* Process a latched INIT, if any.  */\n\t\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t\t}\n\t}\n\n\tkvm_mmu_reset_context(vcpu);\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_mmu_reset_context",
          "args": [
            "vcpu"
          ],
          "line": 5304
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_reset_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "4230-4234",
          "snippet": "void kvm_mmu_reset_context(struct kvm_vcpu *vcpu)\n{\n\tkvm_mmu_unload(vcpu);\n\tinit_kvm_mmu(vcpu);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nvoid kvm_mmu_reset_context(struct kvm_vcpu *vcpu)\n{\n\tkvm_mmu_unload(vcpu);\n\tinit_kvm_mmu(vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_make_request",
          "args": [
            "KVM_REQ_EVENT",
            "vcpu"
          ],
          "line": 5300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_make_request",
          "args": [
            "KVM_REQ_SMI",
            "vcpu"
          ],
          "line": 5296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "vcpu->arch.smi_pending"
          ],
          "line": 5295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_kvm_enter_smm",
          "args": [
            "vcpu->vcpu_id",
            "vcpu->arch.smbase",
            "false"
          ],
          "line": 5293
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu)\n{\n\tif (!(vcpu->arch.hflags & HF_SMM_MASK)) {\n\t\t/* This is a good place to trace that we are exiting SMM.  */\n\t\ttrace_kvm_enter_smm(vcpu->vcpu_id, vcpu->arch.smbase, false);\n\n\t\tif (unlikely(vcpu->arch.smi_pending)) {\n\t\t\tkvm_make_request(KVM_REQ_SMI, vcpu);\n\t\t\tvcpu->arch.smi_pending = 0;\n\t\t} else {\n\t\t\t/* Process a latched INIT, if any.  */\n\t\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t\t}\n\t}\n\n\tkvm_mmu_reset_context(vcpu);\n}"
  },
  {
    "function_name": "retry_instruction",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "5242-5284",
    "snippet": "static bool retry_instruction(struct x86_emulate_ctxt *ctxt,\n\t\t\t      unsigned long cr2,  int emulation_type)\n{\n\tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n\tunsigned long last_retry_eip, last_retry_addr, gpa = cr2;\n\n\tlast_retry_eip = vcpu->arch.last_retry_eip;\n\tlast_retry_addr = vcpu->arch.last_retry_addr;\n\n\t/*\n\t * If the emulation is caused by #PF and it is non-page_table\n\t * writing instruction, it means the VM-EXIT is caused by shadow\n\t * page protected, we can zap the shadow page and retry this\n\t * instruction directly.\n\t *\n\t * Note: if the guest uses a non-page-table modifying instruction\n\t * on the PDE that points to the instruction, then we will unmap\n\t * the instruction and go to an infinite loop. So, we cache the\n\t * last retried eip and the last fault address, if we meet the eip\n\t * and the address again, we can break out of the potential infinite\n\t * loop.\n\t */\n\tvcpu->arch.last_retry_eip = vcpu->arch.last_retry_addr = 0;\n\n\tif (!(emulation_type & EMULTYPE_RETRY))\n\t\treturn false;\n\n\tif (x86_page_table_writing_insn(ctxt))\n\t\treturn false;\n\n\tif (ctxt->eip == last_retry_eip && last_retry_addr == cr2)\n\t\treturn false;\n\n\tvcpu->arch.last_retry_eip = ctxt->eip;\n\tvcpu->arch.last_retry_addr = cr2;\n\n\tif (!vcpu->arch.mmu.direct_map)\n\t\tgpa = kvm_mmu_gva_to_gpa_write(vcpu, cr2, NULL);\n\n\tkvm_mmu_unprotect_page(vcpu->kvm, gpa_to_gfn(gpa));\n\n\treturn true;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);",
      "static int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_mmu_unprotect_page",
          "args": [
            "vcpu->kvm",
            "gpa_to_gfn(gpa)"
          ],
          "line": 5281
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_unprotect_page_virt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "4472-4485",
          "snippet": "int kvm_mmu_unprotect_page_virt(struct kvm_vcpu *vcpu, gva_t gva)\n{\n\tgpa_t gpa;\n\tint r;\n\n\tif (vcpu->arch.mmu.direct_map)\n\t\treturn 0;\n\n\tgpa = kvm_mmu_gva_to_gpa_read(vcpu, gva, NULL);\n\n\tr = kvm_mmu_unprotect_page(vcpu->kvm, gpa >> PAGE_SHIFT);\n\n\treturn r;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nint kvm_mmu_unprotect_page_virt(struct kvm_vcpu *vcpu, gva_t gva)\n{\n\tgpa_t gpa;\n\tint r;\n\n\tif (vcpu->arch.mmu.direct_map)\n\t\treturn 0;\n\n\tgpa = kvm_mmu_gva_to_gpa_read(vcpu, gva, NULL);\n\n\tr = kvm_mmu_unprotect_page(vcpu->kvm, gpa >> PAGE_SHIFT);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gpa_to_gfn",
          "args": [
            "gpa"
          ],
          "line": 5281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_mmu_gva_to_gpa_write",
          "args": [
            "vcpu",
            "cr2",
            "NULL"
          ],
          "line": 5279
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_gva_to_gpa_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "4192-4198",
          "snippet": "gpa_t kvm_mmu_gva_to_gpa_write(struct kvm_vcpu *vcpu, gva_t gva,\n\t\t\t       struct x86_exception *exception)\n{\n\tu32 access = (kvm_x86_ops->get_cpl(vcpu) == 3) ? PFERR_USER_MASK : 0;\n\taccess |= PFERR_WRITE_MASK;\n\treturn vcpu->arch.walk_mmu->gva_to_gpa(vcpu, gva, access, exception);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "struct kvm_x86_ops *kvm_x86_ops"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\ngpa_t kvm_mmu_gva_to_gpa_write(struct kvm_vcpu *vcpu, gva_t gva,\n\t\t\t       struct x86_exception *exception)\n{\n\tu32 access = (kvm_x86_ops->get_cpl(vcpu) == 3) ? PFERR_USER_MASK : 0;\n\taccess |= PFERR_WRITE_MASK;\n\treturn vcpu->arch.walk_mmu->gva_to_gpa(vcpu, gva, access, exception);\n}"
        }
      },
      {
        "call_info": {
          "callee": "x86_page_table_writing_insn",
          "args": [
            "ctxt"
          ],
          "line": 5269
        },
        "resolved": true,
        "details": {
          "function_name": "x86_page_table_writing_insn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "5057-5060",
          "snippet": "bool x86_page_table_writing_insn(struct x86_emulate_ctxt *ctxt)\n{\n\treturn ctxt->d & PageTable;\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define PageTable   (1 << 29)   /* instruction used to write page table */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\n#define PageTable   (1 << 29)   /* instruction used to write page table */\n\nbool x86_page_table_writing_insn(struct x86_emulate_ctxt *ctxt)\n{\n\treturn ctxt->d & PageTable;\n}"
        }
      },
      {
        "call_info": {
          "callee": "emul_to_vcpu",
          "args": [
            "ctxt"
          ],
          "line": 5245
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);\n\nstatic bool retry_instruction(struct x86_emulate_ctxt *ctxt,\n\t\t\t      unsigned long cr2,  int emulation_type)\n{\n\tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n\tunsigned long last_retry_eip, last_retry_addr, gpa = cr2;\n\n\tlast_retry_eip = vcpu->arch.last_retry_eip;\n\tlast_retry_addr = vcpu->arch.last_retry_addr;\n\n\t/*\n\t * If the emulation is caused by #PF and it is non-page_table\n\t * writing instruction, it means the VM-EXIT is caused by shadow\n\t * page protected, we can zap the shadow page and retry this\n\t * instruction directly.\n\t *\n\t * Note: if the guest uses a non-page-table modifying instruction\n\t * on the PDE that points to the instruction, then we will unmap\n\t * the instruction and go to an infinite loop. So, we cache the\n\t * last retried eip and the last fault address, if we meet the eip\n\t * and the address again, we can break out of the potential infinite\n\t * loop.\n\t */\n\tvcpu->arch.last_retry_eip = vcpu->arch.last_retry_addr = 0;\n\n\tif (!(emulation_type & EMULTYPE_RETRY))\n\t\treturn false;\n\n\tif (x86_page_table_writing_insn(ctxt))\n\t\treturn false;\n\n\tif (ctxt->eip == last_retry_eip && last_retry_addr == cr2)\n\t\treturn false;\n\n\tvcpu->arch.last_retry_eip = ctxt->eip;\n\tvcpu->arch.last_retry_addr = cr2;\n\n\tif (!vcpu->arch.mmu.direct_map)\n\t\tgpa = kvm_mmu_gva_to_gpa_write(vcpu, cr2, NULL);\n\n\tkvm_mmu_unprotect_page(vcpu->kvm, gpa_to_gfn(gpa));\n\n\treturn true;\n}"
  },
  {
    "function_name": "reexecute_instruction",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "5171-5240",
    "snippet": "static bool reexecute_instruction(struct kvm_vcpu *vcpu, gva_t cr2,\n\t\t\t\t  bool write_fault_to_shadow_pgtable,\n\t\t\t\t  int emulation_type)\n{\n\tgpa_t gpa = cr2;\n\tkvm_pfn_t pfn;\n\n\tif (emulation_type & EMULTYPE_NO_REEXECUTE)\n\t\treturn false;\n\n\tif (!vcpu->arch.mmu.direct_map) {\n\t\t/*\n\t\t * Write permission should be allowed since only\n\t\t * write access need to be emulated.\n\t\t */\n\t\tgpa = kvm_mmu_gva_to_gpa_write(vcpu, cr2, NULL);\n\n\t\t/*\n\t\t * If the mapping is invalid in guest, let cpu retry\n\t\t * it to generate fault.\n\t\t */\n\t\tif (gpa == UNMAPPED_GVA)\n\t\t\treturn true;\n\t}\n\n\t/*\n\t * Do not retry the unhandleable instruction if it faults on the\n\t * readonly host memory, otherwise it will goto a infinite loop:\n\t * retry instruction -> write #PF -> emulation fail -> retry\n\t * instruction -> ...\n\t */\n\tpfn = gfn_to_pfn(vcpu->kvm, gpa_to_gfn(gpa));\n\n\t/*\n\t * If the instruction failed on the error pfn, it can not be fixed,\n\t * report the error to userspace.\n\t */\n\tif (is_error_noslot_pfn(pfn))\n\t\treturn false;\n\n\tkvm_release_pfn_clean(pfn);\n\n\t/* The instructions are well-emulated on direct mmu. */\n\tif (vcpu->arch.mmu.direct_map) {\n\t\tunsigned int indirect_shadow_pages;\n\n\t\tspin_lock(&vcpu->kvm->mmu_lock);\n\t\tindirect_shadow_pages = vcpu->kvm->arch.indirect_shadow_pages;\n\t\tspin_unlock(&vcpu->kvm->mmu_lock);\n\n\t\tif (indirect_shadow_pages)\n\t\t\tkvm_mmu_unprotect_page(vcpu->kvm, gpa_to_gfn(gpa));\n\n\t\treturn true;\n\t}\n\n\t/*\n\t * if emulation was due to access to shadowed page table\n\t * and it failed try to unshadow page and re-enter the\n\t * guest to let CPU execute the instruction.\n\t */\n\tkvm_mmu_unprotect_page(vcpu->kvm, gpa_to_gfn(gpa));\n\n\t/*\n\t * If the access faults on its page table, it can not\n\t * be fixed by unprotecting shadow page and it should\n\t * be reported to userspace.\n\t */\n\treturn !write_fault_to_shadow_pgtable;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_mmu_unprotect_page",
          "args": [
            "vcpu->kvm",
            "gpa_to_gfn(gpa)"
          ],
          "line": 5232
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_unprotect_page_virt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "4472-4485",
          "snippet": "int kvm_mmu_unprotect_page_virt(struct kvm_vcpu *vcpu, gva_t gva)\n{\n\tgpa_t gpa;\n\tint r;\n\n\tif (vcpu->arch.mmu.direct_map)\n\t\treturn 0;\n\n\tgpa = kvm_mmu_gva_to_gpa_read(vcpu, gva, NULL);\n\n\tr = kvm_mmu_unprotect_page(vcpu->kvm, gpa >> PAGE_SHIFT);\n\n\treturn r;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nint kvm_mmu_unprotect_page_virt(struct kvm_vcpu *vcpu, gva_t gva)\n{\n\tgpa_t gpa;\n\tint r;\n\n\tif (vcpu->arch.mmu.direct_map)\n\t\treturn 0;\n\n\tgpa = kvm_mmu_gva_to_gpa_read(vcpu, gva, NULL);\n\n\tr = kvm_mmu_unprotect_page(vcpu->kvm, gpa >> PAGE_SHIFT);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gpa_to_gfn",
          "args": [
            "gpa"
          ],
          "line": 5232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gpa_to_gfn",
          "args": [
            "gpa"
          ],
          "line": 5222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&vcpu->kvm->mmu_lock"
          ],
          "line": 5219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&vcpu->kvm->mmu_lock"
          ],
          "line": 5217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_release_pfn_clean",
          "args": [
            "pfn"
          ],
          "line": 5211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_error_noslot_pfn",
          "args": [
            "pfn"
          ],
          "line": 5208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfn_to_pfn",
          "args": [
            "vcpu->kvm",
            "gpa_to_gfn(gpa)"
          ],
          "line": 5202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gpa_to_gfn",
          "args": [
            "gpa"
          ],
          "line": 5202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_mmu_gva_to_gpa_write",
          "args": [
            "vcpu",
            "cr2",
            "NULL"
          ],
          "line": 5186
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_gva_to_gpa_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "4192-4198",
          "snippet": "gpa_t kvm_mmu_gva_to_gpa_write(struct kvm_vcpu *vcpu, gva_t gva,\n\t\t\t       struct x86_exception *exception)\n{\n\tu32 access = (kvm_x86_ops->get_cpl(vcpu) == 3) ? PFERR_USER_MASK : 0;\n\taccess |= PFERR_WRITE_MASK;\n\treturn vcpu->arch.walk_mmu->gva_to_gpa(vcpu, gva, access, exception);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "struct kvm_x86_ops *kvm_x86_ops"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\ngpa_t kvm_mmu_gva_to_gpa_write(struct kvm_vcpu *vcpu, gva_t gva,\n\t\t\t       struct x86_exception *exception)\n{\n\tu32 access = (kvm_x86_ops->get_cpl(vcpu) == 3) ? PFERR_USER_MASK : 0;\n\taccess |= PFERR_WRITE_MASK;\n\treturn vcpu->arch.walk_mmu->gva_to_gpa(vcpu, gva, access, exception);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic bool reexecute_instruction(struct kvm_vcpu *vcpu, gva_t cr2,\n\t\t\t\t  bool write_fault_to_shadow_pgtable,\n\t\t\t\t  int emulation_type)\n{\n\tgpa_t gpa = cr2;\n\tkvm_pfn_t pfn;\n\n\tif (emulation_type & EMULTYPE_NO_REEXECUTE)\n\t\treturn false;\n\n\tif (!vcpu->arch.mmu.direct_map) {\n\t\t/*\n\t\t * Write permission should be allowed since only\n\t\t * write access need to be emulated.\n\t\t */\n\t\tgpa = kvm_mmu_gva_to_gpa_write(vcpu, cr2, NULL);\n\n\t\t/*\n\t\t * If the mapping is invalid in guest, let cpu retry\n\t\t * it to generate fault.\n\t\t */\n\t\tif (gpa == UNMAPPED_GVA)\n\t\t\treturn true;\n\t}\n\n\t/*\n\t * Do not retry the unhandleable instruction if it faults on the\n\t * readonly host memory, otherwise it will goto a infinite loop:\n\t * retry instruction -> write #PF -> emulation fail -> retry\n\t * instruction -> ...\n\t */\n\tpfn = gfn_to_pfn(vcpu->kvm, gpa_to_gfn(gpa));\n\n\t/*\n\t * If the instruction failed on the error pfn, it can not be fixed,\n\t * report the error to userspace.\n\t */\n\tif (is_error_noslot_pfn(pfn))\n\t\treturn false;\n\n\tkvm_release_pfn_clean(pfn);\n\n\t/* The instructions are well-emulated on direct mmu. */\n\tif (vcpu->arch.mmu.direct_map) {\n\t\tunsigned int indirect_shadow_pages;\n\n\t\tspin_lock(&vcpu->kvm->mmu_lock);\n\t\tindirect_shadow_pages = vcpu->kvm->arch.indirect_shadow_pages;\n\t\tspin_unlock(&vcpu->kvm->mmu_lock);\n\n\t\tif (indirect_shadow_pages)\n\t\t\tkvm_mmu_unprotect_page(vcpu->kvm, gpa_to_gfn(gpa));\n\n\t\treturn true;\n\t}\n\n\t/*\n\t * if emulation was due to access to shadowed page table\n\t * and it failed try to unshadow page and re-enter the\n\t * guest to let CPU execute the instruction.\n\t */\n\tkvm_mmu_unprotect_page(vcpu->kvm, gpa_to_gfn(gpa));\n\n\t/*\n\t * If the access faults on its page table, it can not\n\t * be fixed by unprotecting shadow page and it should\n\t * be reported to userspace.\n\t */\n\treturn !write_fault_to_shadow_pgtable;\n}"
  },
  {
    "function_name": "handle_emulation_failure",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "5154-5169",
    "snippet": "static int handle_emulation_failure(struct kvm_vcpu *vcpu)\n{\n\tint r = EMULATE_DONE;\n\n\t++vcpu->stat.insn_emulation_fail;\n\ttrace_kvm_emulate_insn_failed(vcpu);\n\tif (!is_guest_mode(vcpu) && kvm_x86_ops->get_cpl(vcpu) == 0) {\n\t\tvcpu->run->exit_reason = KVM_EXIT_INTERNAL_ERROR;\n\t\tvcpu->run->internal.suberror = KVM_INTERNAL_ERROR_EMULATION;\n\t\tvcpu->run->internal.ndata = 0;\n\t\tr = EMULATE_FAIL;\n\t}\n\tkvm_queue_exception(vcpu, UD_VECTOR);\n\n\treturn r;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);",
      "struct kvm_x86_ops *kvm_x86_ops"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_queue_exception",
          "args": [
            "vcpu",
            "UD_VECTOR"
          ],
          "line": 5166
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_queue_exception",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "409-412",
          "snippet": "void kvm_queue_exception(struct kvm_vcpu *vcpu, unsigned nr)\n{\n\tkvm_multiple_exception(vcpu, nr, false, 0, false);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nvoid kvm_queue_exception(struct kvm_vcpu *vcpu, unsigned nr)\n{\n\tkvm_multiple_exception(vcpu, nr, false, 0, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_x86_ops->get_cpl",
          "args": [
            "vcpu"
          ],
          "line": 5160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_guest_mode",
          "args": [
            "vcpu"
          ],
          "line": 5160
        },
        "resolved": true,
        "details": {
          "function_name": "is_guest_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "102-105",
          "snippet": "static inline bool is_guest_mode(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.hflags & HF_GUEST_MASK;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline bool is_guest_mode(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.hflags & HF_GUEST_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_kvm_emulate_insn_failed",
          "args": [
            "vcpu"
          ],
          "line": 5159
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nstatic int handle_emulation_failure(struct kvm_vcpu *vcpu)\n{\n\tint r = EMULATE_DONE;\n\n\t++vcpu->stat.insn_emulation_fail;\n\ttrace_kvm_emulate_insn_failed(vcpu);\n\tif (!is_guest_mode(vcpu) && kvm_x86_ops->get_cpl(vcpu) == 0) {\n\t\tvcpu->run->exit_reason = KVM_EXIT_INTERNAL_ERROR;\n\t\tvcpu->run->internal.suberror = KVM_INTERNAL_ERROR_EMULATION;\n\t\tvcpu->run->internal.ndata = 0;\n\t\tr = EMULATE_FAIL;\n\t}\n\tkvm_queue_exception(vcpu, UD_VECTOR);\n\n\treturn r;\n}"
  },
  {
    "function_name": "kvm_inject_realmode_interrupt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "5126-5151",
    "snippet": "int kvm_inject_realmode_interrupt(struct kvm_vcpu *vcpu, int irq, int inc_eip)\n{\n\tstruct x86_emulate_ctxt *ctxt = &vcpu->arch.emulate_ctxt;\n\tint ret;\n\n\tinit_emulate_ctxt(vcpu);\n\n\tctxt->op_bytes = 2;\n\tctxt->ad_bytes = 2;\n\tctxt->_eip = ctxt->eip + inc_eip;\n\tret = emulate_int_real(ctxt, irq);\n\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn EMULATE_FAIL;\n\n\tctxt->eip = ctxt->_eip;\n\tkvm_rip_write(vcpu, ctxt->eip);\n\tkvm_set_rflags(vcpu, ctxt->eflags);\n\n\tif (irq == NMI_VECTOR)\n\t\tvcpu->arch.nmi_pending = 0;\n\telse\n\t\tvcpu->arch.interrupt.pending = false;\n\n\treturn EMULATE_DONE;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);",
      "static int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_set_rflags",
          "args": [
            "vcpu",
            "ctxt->eflags"
          ],
          "line": 5143
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_set_rflags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "8182-8186",
          "snippet": "void kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags)\n{\n\t__kvm_set_rflags(vcpu, rflags);\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void __kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void __kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags);\n\nvoid kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags)\n{\n\t__kvm_set_rflags(vcpu, rflags);\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_rip_write",
          "args": [
            "vcpu",
            "ctxt->eip"
          ],
          "line": 5142
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_rip_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "32-35",
          "snippet": "static inline void kvm_rip_write(struct kvm_vcpu *vcpu, unsigned long val)\n{\n\tkvm_register_write(vcpu, VCPU_REGS_RIP, val);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void kvm_rip_write(struct kvm_vcpu *vcpu, unsigned long val)\n{\n\tkvm_register_write(vcpu, VCPU_REGS_RIP, val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "emulate_int_real",
          "args": [
            "ctxt",
            "irq"
          ],
          "line": 5136
        },
        "resolved": true,
        "details": {
          "function_name": "emulate_int_real",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "2009-2018",
          "snippet": "int emulate_int_real(struct x86_emulate_ctxt *ctxt, int irq)\n{\n\tint rc;\n\n\tinvalidate_registers(ctxt);\n\trc = __emulate_int_real(ctxt, irq);\n\tif (rc == X86EMUL_CONTINUE)\n\t\twriteback_registers(ctxt);\n\treturn rc;\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nint emulate_int_real(struct x86_emulate_ctxt *ctxt, int irq)\n{\n\tint rc;\n\n\tinvalidate_registers(ctxt);\n\trc = __emulate_int_real(ctxt, irq);\n\tif (rc == X86EMUL_CONTINUE)\n\t\twriteback_registers(ctxt);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_emulate_ctxt",
          "args": [
            "vcpu"
          ],
          "line": 5131
        },
        "resolved": true,
        "details": {
          "function_name": "init_emulate_ctxt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "5103-5124",
          "snippet": "static void init_emulate_ctxt(struct kvm_vcpu *vcpu)\n{\n\tstruct x86_emulate_ctxt *ctxt = &vcpu->arch.emulate_ctxt;\n\tint cs_db, cs_l;\n\n\tkvm_x86_ops->get_cs_db_l_bits(vcpu, &cs_db, &cs_l);\n\n\tctxt->eflags = kvm_get_rflags(vcpu);\n\tctxt->eip = kvm_rip_read(vcpu);\n\tctxt->mode = (!is_protmode(vcpu))\t\t? X86EMUL_MODE_REAL :\n\t\t     (ctxt->eflags & X86_EFLAGS_VM)\t? X86EMUL_MODE_VM86 :\n\t\t     (cs_l && is_long_mode(vcpu))\t? X86EMUL_MODE_PROT64 :\n\t\t     cs_db\t\t\t\t? X86EMUL_MODE_PROT32 :\n\t\t\t\t\t\t\t  X86EMUL_MODE_PROT16;\n\tBUILD_BUG_ON(HF_GUEST_MASK != X86EMUL_GUEST_MASK);\n\tBUILD_BUG_ON(HF_SMM_MASK != X86EMUL_SMM_MASK);\n\tBUILD_BUG_ON(HF_SMM_INSIDE_NMI_MASK != X86EMUL_SMM_INSIDE_NMI_MASK);\n\tctxt->emul_flags = vcpu->arch.hflags;\n\n\tinit_decode_cache(ctxt);\n\tvcpu->arch.emulate_regs_need_sync_from_vcpu = false;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "struct kvm_x86_ops *kvm_x86_ops",
            "static int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\nstatic int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);\n\nstatic void init_emulate_ctxt(struct kvm_vcpu *vcpu)\n{\n\tstruct x86_emulate_ctxt *ctxt = &vcpu->arch.emulate_ctxt;\n\tint cs_db, cs_l;\n\n\tkvm_x86_ops->get_cs_db_l_bits(vcpu, &cs_db, &cs_l);\n\n\tctxt->eflags = kvm_get_rflags(vcpu);\n\tctxt->eip = kvm_rip_read(vcpu);\n\tctxt->mode = (!is_protmode(vcpu))\t\t? X86EMUL_MODE_REAL :\n\t\t     (ctxt->eflags & X86_EFLAGS_VM)\t? X86EMUL_MODE_VM86 :\n\t\t     (cs_l && is_long_mode(vcpu))\t? X86EMUL_MODE_PROT64 :\n\t\t     cs_db\t\t\t\t? X86EMUL_MODE_PROT32 :\n\t\t\t\t\t\t\t  X86EMUL_MODE_PROT16;\n\tBUILD_BUG_ON(HF_GUEST_MASK != X86EMUL_GUEST_MASK);\n\tBUILD_BUG_ON(HF_SMM_MASK != X86EMUL_SMM_MASK);\n\tBUILD_BUG_ON(HF_SMM_INSIDE_NMI_MASK != X86EMUL_SMM_INSIDE_NMI_MASK);\n\tctxt->emul_flags = vcpu->arch.hflags;\n\n\tinit_decode_cache(ctxt);\n\tvcpu->arch.emulate_regs_need_sync_from_vcpu = false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);\n\nint kvm_inject_realmode_interrupt(struct kvm_vcpu *vcpu, int irq, int inc_eip)\n{\n\tstruct x86_emulate_ctxt *ctxt = &vcpu->arch.emulate_ctxt;\n\tint ret;\n\n\tinit_emulate_ctxt(vcpu);\n\n\tctxt->op_bytes = 2;\n\tctxt->ad_bytes = 2;\n\tctxt->_eip = ctxt->eip + inc_eip;\n\tret = emulate_int_real(ctxt, irq);\n\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn EMULATE_FAIL;\n\n\tctxt->eip = ctxt->_eip;\n\tkvm_rip_write(vcpu, ctxt->eip);\n\tkvm_set_rflags(vcpu, ctxt->eflags);\n\n\tif (irq == NMI_VECTOR)\n\t\tvcpu->arch.nmi_pending = 0;\n\telse\n\t\tvcpu->arch.interrupt.pending = false;\n\n\treturn EMULATE_DONE;\n}"
  },
  {
    "function_name": "init_emulate_ctxt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "5103-5124",
    "snippet": "static void init_emulate_ctxt(struct kvm_vcpu *vcpu)\n{\n\tstruct x86_emulate_ctxt *ctxt = &vcpu->arch.emulate_ctxt;\n\tint cs_db, cs_l;\n\n\tkvm_x86_ops->get_cs_db_l_bits(vcpu, &cs_db, &cs_l);\n\n\tctxt->eflags = kvm_get_rflags(vcpu);\n\tctxt->eip = kvm_rip_read(vcpu);\n\tctxt->mode = (!is_protmode(vcpu))\t\t? X86EMUL_MODE_REAL :\n\t\t     (ctxt->eflags & X86_EFLAGS_VM)\t? X86EMUL_MODE_VM86 :\n\t\t     (cs_l && is_long_mode(vcpu))\t? X86EMUL_MODE_PROT64 :\n\t\t     cs_db\t\t\t\t? X86EMUL_MODE_PROT32 :\n\t\t\t\t\t\t\t  X86EMUL_MODE_PROT16;\n\tBUILD_BUG_ON(HF_GUEST_MASK != X86EMUL_GUEST_MASK);\n\tBUILD_BUG_ON(HF_SMM_MASK != X86EMUL_SMM_MASK);\n\tBUILD_BUG_ON(HF_SMM_INSIDE_NMI_MASK != X86EMUL_SMM_INSIDE_NMI_MASK);\n\tctxt->emul_flags = vcpu->arch.hflags;\n\n\tinit_decode_cache(ctxt);\n\tvcpu->arch.emulate_regs_need_sync_from_vcpu = false;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);",
      "struct kvm_x86_ops *kvm_x86_ops",
      "static int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "init_decode_cache",
          "args": [
            "ctxt"
          ],
          "line": 5122
        },
        "resolved": true,
        "details": {
          "function_name": "init_decode_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/emulate.c",
          "lines": "5126-5134",
          "snippet": "void init_decode_cache(struct x86_emulate_ctxt *ctxt)\n{\n\tmemset(&ctxt->rip_relative, 0,\n\t       (void *)&ctxt->modrm - (void *)&ctxt->rip_relative);\n\n\tctxt->io_read.pos = 0;\n\tctxt->io_read.end = 0;\n\tctxt->mem_read.end = 0;\n}",
          "includes": [
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/debugreg.h>",
            "#include <linux/stringify.h>",
            "#include <asm/kvm_emulate.h>",
            "#include <linux/module.h>",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/debugreg.h>\n#include <linux/stringify.h>\n#include <asm/kvm_emulate.h>\n#include <linux/module.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nvoid init_decode_cache(struct x86_emulate_ctxt *ctxt)\n{\n\tmemset(&ctxt->rip_relative, 0,\n\t       (void *)&ctxt->modrm - (void *)&ctxt->rip_relative);\n\n\tctxt->io_read.pos = 0;\n\tctxt->io_read.end = 0;\n\tctxt->mem_read.end = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "HF_SMM_INSIDE_NMI_MASK != X86EMUL_SMM_INSIDE_NMI_MASK"
          ],
          "line": 5119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "HF_SMM_MASK != X86EMUL_SMM_MASK"
          ],
          "line": 5118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "HF_GUEST_MASK != X86EMUL_GUEST_MASK"
          ],
          "line": 5117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_long_mode",
          "args": [
            "vcpu"
          ],
          "line": 5114
        },
        "resolved": true,
        "details": {
          "function_name": "is_long_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.h",
          "lines": "43-50",
          "snippet": "static inline int is_long_mode(struct kvm_vcpu *vcpu)\n{\n#ifdef CONFIG_X86_64\n\treturn vcpu->arch.efer & EFER_LMA;\n#else\n\treturn 0;\n#endif\n}",
          "includes": [
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline int is_long_mode(struct kvm_vcpu *vcpu)\n{\n#ifdef CONFIG_X86_64\n\treturn vcpu->arch.efer & EFER_LMA;\n#else\n\treturn 0;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_protmode",
          "args": [
            "vcpu"
          ],
          "line": 5112
        },
        "resolved": true,
        "details": {
          "function_name": "is_protmode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.h",
          "lines": "38-41",
          "snippet": "static inline bool is_protmode(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_read_cr0_bits(vcpu, X86_CR0_PE);\n}",
          "includes": [
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline bool is_protmode(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_read_cr0_bits(vcpu, X86_CR0_PE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_rip_read",
          "args": [
            "vcpu"
          ],
          "line": 5111
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_rip_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "27-30",
          "snippet": "static inline unsigned long kvm_rip_read(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_register_read(vcpu, VCPU_REGS_RIP);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline unsigned long kvm_rip_read(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_register_read(vcpu, VCPU_REGS_RIP);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_get_rflags",
          "args": [
            "vcpu"
          ],
          "line": 5110
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_get_rflags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "8163-8171",
          "snippet": "unsigned long kvm_get_rflags(struct kvm_vcpu *vcpu)\n{\n\tunsigned long rflags;\n\n\trflags = kvm_x86_ops->get_rflags(vcpu);\n\tif (vcpu->guest_debug & KVM_GUESTDBG_SINGLESTEP)\n\t\trflags &= ~X86_EFLAGS_TF;\n\treturn rflags;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void __kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags);",
            "struct kvm_x86_ops *kvm_x86_ops"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void __kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nunsigned long kvm_get_rflags(struct kvm_vcpu *vcpu)\n{\n\tunsigned long rflags;\n\n\trflags = kvm_x86_ops->get_rflags(vcpu);\n\tif (vcpu->guest_debug & KVM_GUESTDBG_SINGLESTEP)\n\t\trflags &= ~X86_EFLAGS_TF;\n\treturn rflags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_x86_ops->get_cs_db_l_bits",
          "args": [
            "vcpu",
            "&cs_db",
            "&cs_l"
          ],
          "line": 5108
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\nstatic int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);\n\nstatic void init_emulate_ctxt(struct kvm_vcpu *vcpu)\n{\n\tstruct x86_emulate_ctxt *ctxt = &vcpu->arch.emulate_ctxt;\n\tint cs_db, cs_l;\n\n\tkvm_x86_ops->get_cs_db_l_bits(vcpu, &cs_db, &cs_l);\n\n\tctxt->eflags = kvm_get_rflags(vcpu);\n\tctxt->eip = kvm_rip_read(vcpu);\n\tctxt->mode = (!is_protmode(vcpu))\t\t? X86EMUL_MODE_REAL :\n\t\t     (ctxt->eflags & X86_EFLAGS_VM)\t? X86EMUL_MODE_VM86 :\n\t\t     (cs_l && is_long_mode(vcpu))\t? X86EMUL_MODE_PROT64 :\n\t\t     cs_db\t\t\t\t? X86EMUL_MODE_PROT32 :\n\t\t\t\t\t\t\t  X86EMUL_MODE_PROT16;\n\tBUILD_BUG_ON(HF_GUEST_MASK != X86EMUL_GUEST_MASK);\n\tBUILD_BUG_ON(HF_SMM_MASK != X86EMUL_SMM_MASK);\n\tBUILD_BUG_ON(HF_SMM_INSIDE_NMI_MASK != X86EMUL_SMM_INSIDE_NMI_MASK);\n\tctxt->emul_flags = vcpu->arch.hflags;\n\n\tinit_decode_cache(ctxt);\n\tvcpu->arch.emulate_regs_need_sync_from_vcpu = false;\n}"
  },
  {
    "function_name": "inject_emulated_exception",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "5089-5101",
    "snippet": "static bool inject_emulated_exception(struct kvm_vcpu *vcpu)\n{\n\tstruct x86_emulate_ctxt *ctxt = &vcpu->arch.emulate_ctxt;\n\tif (ctxt->exception.vector == PF_VECTOR)\n\t\treturn kvm_propagate_fault(vcpu, &ctxt->exception);\n\n\tif (ctxt->exception.error_code_valid)\n\t\tkvm_queue_exception_e(vcpu, ctxt->exception.vector,\n\t\t\t\t      ctxt->exception.error_code);\n\telse\n\t\tkvm_queue_exception(vcpu, ctxt->exception.vector);\n\treturn false;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);",
      "static int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_queue_exception",
          "args": [
            "vcpu",
            "ctxt->exception.vector"
          ],
          "line": 5099
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_queue_exception",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "409-412",
          "snippet": "void kvm_queue_exception(struct kvm_vcpu *vcpu, unsigned nr)\n{\n\tkvm_multiple_exception(vcpu, nr, false, 0, false);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nvoid kvm_queue_exception(struct kvm_vcpu *vcpu, unsigned nr)\n{\n\tkvm_multiple_exception(vcpu, nr, false, 0, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_queue_exception_e",
          "args": [
            "vcpu",
            "ctxt->exception.vector",
            "ctxt->exception.error_code"
          ],
          "line": 5096
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_queue_exception_e",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "455-458",
          "snippet": "void kvm_queue_exception_e(struct kvm_vcpu *vcpu, unsigned nr, u32 error_code)\n{\n\tkvm_multiple_exception(vcpu, nr, true, error_code, false);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nvoid kvm_queue_exception_e(struct kvm_vcpu *vcpu, unsigned nr, u32 error_code)\n{\n\tkvm_multiple_exception(vcpu, nr, true, error_code, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_propagate_fault",
          "args": [
            "vcpu",
            "&ctxt->exception"
          ],
          "line": 5093
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_propagate_fault",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "438-446",
          "snippet": "static bool kvm_propagate_fault(struct kvm_vcpu *vcpu, struct x86_exception *fault)\n{\n\tif (mmu_is_nested(vcpu) && !fault->nested_page_fault)\n\t\tvcpu->arch.nested_mmu.inject_page_fault(vcpu, fault);\n\telse\n\t\tvcpu->arch.mmu.inject_page_fault(vcpu, fault);\n\n\treturn fault->nested_page_fault;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic bool kvm_propagate_fault(struct kvm_vcpu *vcpu, struct x86_exception *fault)\n{\n\tif (mmu_is_nested(vcpu) && !fault->nested_page_fault)\n\t\tvcpu->arch.nested_mmu.inject_page_fault(vcpu, fault);\n\telse\n\t\tvcpu->arch.mmu.inject_page_fault(vcpu, fault);\n\n\treturn fault->nested_page_fault;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);\n\nstatic bool inject_emulated_exception(struct kvm_vcpu *vcpu)\n{\n\tstruct x86_emulate_ctxt *ctxt = &vcpu->arch.emulate_ctxt;\n\tif (ctxt->exception.vector == PF_VECTOR)\n\t\treturn kvm_propagate_fault(vcpu, &ctxt->exception);\n\n\tif (ctxt->exception.error_code_valid)\n\t\tkvm_queue_exception_e(vcpu, ctxt->exception.vector,\n\t\t\t\t      ctxt->exception.error_code);\n\telse\n\t\tkvm_queue_exception(vcpu, ctxt->exception.vector);\n\treturn false;\n}"
  },
  {
    "function_name": "toggle_interruptibility",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "5070-5087",
    "snippet": "static void toggle_interruptibility(struct kvm_vcpu *vcpu, u32 mask)\n{\n\tu32 int_shadow = kvm_x86_ops->get_interrupt_shadow(vcpu);\n\t/*\n\t * an sti; sti; sequence only disable interrupts for the first\n\t * instruction. So, if the last instruction, be it emulated or\n\t * not, left the system with the INT_STI flag enabled, it\n\t * means that the last instruction is an sti. We should not\n\t * leave the flag on in this case. The same goes for mov ss\n\t */\n\tif (int_shadow & mask)\n\t\tmask = 0;\n\tif (unlikely(int_shadow || mask)) {\n\t\tkvm_x86_ops->set_interrupt_shadow(vcpu, mask);\n\t\tif (!mask)\n\t\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t}\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);",
      "struct kvm_x86_ops *kvm_x86_ops"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_make_request",
          "args": [
            "KVM_REQ_EVENT",
            "vcpu"
          ],
          "line": 5085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_x86_ops->set_interrupt_shadow",
          "args": [
            "vcpu",
            "mask"
          ],
          "line": 5083
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "int_shadow || mask"
          ],
          "line": 5082
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_x86_ops->get_interrupt_shadow",
          "args": [
            "vcpu"
          ],
          "line": 5072
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nstatic void toggle_interruptibility(struct kvm_vcpu *vcpu, u32 mask)\n{\n\tu32 int_shadow = kvm_x86_ops->get_interrupt_shadow(vcpu);\n\t/*\n\t * an sti; sti; sequence only disable interrupts for the first\n\t * instruction. So, if the last instruction, be it emulated or\n\t * not, left the system with the INT_STI flag enabled, it\n\t * means that the last instruction is an sti. We should not\n\t * leave the flag on in this case. The same goes for mov ss\n\t */\n\tif (int_shadow & mask)\n\t\tmask = 0;\n\tif (unlikely(int_shadow || mask)) {\n\t\tkvm_x86_ops->set_interrupt_shadow(vcpu, mask);\n\t\tif (!mask)\n\t\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t}\n}"
  },
  {
    "function_name": "emulator_set_nmi_mask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "5024-5027",
    "snippet": "static void emulator_set_nmi_mask(struct x86_emulate_ctxt *ctxt, bool masked)\n{\n\tkvm_x86_ops->set_nmi_mask(emul_to_vcpu(ctxt), masked);\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct kvm_x86_ops *kvm_x86_ops",
      "static int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_x86_ops->set_nmi_mask",
          "args": [
            "emul_to_vcpu(ctxt)",
            "masked"
          ],
          "line": 5026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "emul_to_vcpu",
          "args": [
            "ctxt"
          ],
          "line": 5026
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstruct kvm_x86_ops *kvm_x86_ops;\nstatic int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);\n\nstatic void emulator_set_nmi_mask(struct x86_emulate_ctxt *ctxt, bool masked)\n{\n\tkvm_x86_ops->set_nmi_mask(emul_to_vcpu(ctxt), masked);\n}"
  },
  {
    "function_name": "emulator_write_gpr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "5019-5022",
    "snippet": "static void emulator_write_gpr(struct x86_emulate_ctxt *ctxt, unsigned reg, ulong val)\n{\n\tkvm_register_write(emul_to_vcpu(ctxt), reg, val);\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_register_write",
          "args": [
            "emul_to_vcpu(ctxt)",
            "reg",
            "val"
          ],
          "line": 5021
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_register_writel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.h",
          "lines": "141-148",
          "snippet": "static inline void kvm_register_writel(struct kvm_vcpu *vcpu,\n\t\t\t\t       enum kvm_reg reg,\n\t\t\t\t       unsigned long val)\n{\n\tif (!is_64_bit_mode(vcpu))\n\t\tval = (u32)val;\n\treturn kvm_register_write(vcpu, reg, val);\n}",
          "includes": [
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline void kvm_register_writel(struct kvm_vcpu *vcpu,\n\t\t\t\t       enum kvm_reg reg,\n\t\t\t\t       unsigned long val)\n{\n\tif (!is_64_bit_mode(vcpu))\n\t\tval = (u32)val;\n\treturn kvm_register_write(vcpu, reg, val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "emul_to_vcpu",
          "args": [
            "ctxt"
          ],
          "line": 5021
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);\n\nstatic void emulator_write_gpr(struct x86_emulate_ctxt *ctxt, unsigned reg, ulong val)\n{\n\tkvm_register_write(emul_to_vcpu(ctxt), reg, val);\n}"
  },
  {
    "function_name": "emulator_read_gpr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "5014-5017",
    "snippet": "static ulong emulator_read_gpr(struct x86_emulate_ctxt *ctxt, unsigned reg)\n{\n\treturn kvm_register_read(emul_to_vcpu(ctxt), reg);\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_register_read",
          "args": [
            "emul_to_vcpu(ctxt)",
            "reg"
          ],
          "line": 5016
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_register_readl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.h",
          "lines": "133-139",
          "snippet": "static inline unsigned long kvm_register_readl(struct kvm_vcpu *vcpu,\n\t\t\t\t\t       enum kvm_reg reg)\n{\n\tunsigned long val = kvm_register_read(vcpu, reg);\n\n\treturn is_64_bit_mode(vcpu) ? val : (u32)val;\n}",
          "includes": [
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline unsigned long kvm_register_readl(struct kvm_vcpu *vcpu,\n\t\t\t\t\t       enum kvm_reg reg)\n{\n\tunsigned long val = kvm_register_read(vcpu, reg);\n\n\treturn is_64_bit_mode(vcpu) ? val : (u32)val;\n}"
        }
      },
      {
        "call_info": {
          "callee": "emul_to_vcpu",
          "args": [
            "ctxt"
          ],
          "line": 5016
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);\n\nstatic ulong emulator_read_gpr(struct x86_emulate_ctxt *ctxt, unsigned reg)\n{\n\treturn kvm_register_read(emul_to_vcpu(ctxt), reg);\n}"
  },
  {
    "function_name": "emulator_get_cpuid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "5008-5012",
    "snippet": "static void emulator_get_cpuid(struct x86_emulate_ctxt *ctxt,\n\t\t\t       u32 *eax, u32 *ebx, u32 *ecx, u32 *edx)\n{\n\tkvm_cpuid(emul_to_vcpu(ctxt), eax, ebx, ecx, edx);\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_cpuid",
          "args": [
            "emul_to_vcpu(ctxt)",
            "eax",
            "ebx",
            "ecx",
            "edx"
          ],
          "line": 5011
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_cpuid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/cpuid.c",
          "lines": "836-860",
          "snippet": "void kvm_cpuid(struct kvm_vcpu *vcpu, u32 *eax, u32 *ebx, u32 *ecx, u32 *edx)\n{\n\tu32 function = *eax, index = *ecx;\n\tstruct kvm_cpuid_entry2 *best;\n\n\tbest = kvm_find_cpuid_entry(vcpu, function, index);\n\n\tif (!best)\n\t\tbest = check_cpuid_limit(vcpu, function, index);\n\n\t/*\n\t * Perfmon not yet supported for L2 guest.\n\t */\n\tif (is_guest_mode(vcpu) && function == 0xa)\n\t\tbest = NULL;\n\n\tif (best) {\n\t\t*eax = best->eax;\n\t\t*ebx = best->ebx;\n\t\t*ecx = best->ecx;\n\t\t*edx = best->edx;\n\t} else\n\t\t*eax = *ebx = *ecx = *edx = 0;\n\ttrace_kvm_cpuid(function, *eax, *ebx, *ecx, *edx);\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"trace.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"cpuid.h\"",
            "#include <asm/fpu/xstate.h>",
            "#include <asm/user.h>",
            "#include <asm/fpu/internal.h> /* For use_eager_fpu.  Ugh! */",
            "#include <linux/uaccess.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"trace.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include <asm/fpu/xstate.h>\n#include <asm/user.h>\n#include <asm/fpu/internal.h> /* For use_eager_fpu.  Ugh! */\n#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n\nvoid kvm_cpuid(struct kvm_vcpu *vcpu, u32 *eax, u32 *ebx, u32 *ecx, u32 *edx)\n{\n\tu32 function = *eax, index = *ecx;\n\tstruct kvm_cpuid_entry2 *best;\n\n\tbest = kvm_find_cpuid_entry(vcpu, function, index);\n\n\tif (!best)\n\t\tbest = check_cpuid_limit(vcpu, function, index);\n\n\t/*\n\t * Perfmon not yet supported for L2 guest.\n\t */\n\tif (is_guest_mode(vcpu) && function == 0xa)\n\t\tbest = NULL;\n\n\tif (best) {\n\t\t*eax = best->eax;\n\t\t*ebx = best->ebx;\n\t\t*ecx = best->ecx;\n\t\t*edx = best->edx;\n\t} else\n\t\t*eax = *ebx = *ecx = *edx = 0;\n\ttrace_kvm_cpuid(function, *eax, *ebx, *ecx, *edx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "emul_to_vcpu",
          "args": [
            "ctxt"
          ],
          "line": 5011
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);\n\nstatic void emulator_get_cpuid(struct x86_emulate_ctxt *ctxt,\n\t\t\t       u32 *eax, u32 *ebx, u32 *ecx, u32 *edx)\n{\n\tkvm_cpuid(emul_to_vcpu(ctxt), eax, ebx, ecx, edx);\n}"
  },
  {
    "function_name": "emulator_intercept",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "5001-5006",
    "snippet": "static int emulator_intercept(struct x86_emulate_ctxt *ctxt,\n\t\t\t      struct x86_instruction_info *info,\n\t\t\t      enum x86_intercept_stage stage)\n{\n\treturn kvm_x86_ops->check_intercept(emul_to_vcpu(ctxt), info, stage);\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct kvm_x86_ops *kvm_x86_ops",
      "static int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_x86_ops->check_intercept",
          "args": [
            "emul_to_vcpu(ctxt)",
            "info",
            "stage"
          ],
          "line": 5005
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "emul_to_vcpu",
          "args": [
            "ctxt"
          ],
          "line": 5005
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstruct kvm_x86_ops *kvm_x86_ops;\nstatic int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);\n\nstatic int emulator_intercept(struct x86_emulate_ctxt *ctxt,\n\t\t\t      struct x86_instruction_info *info,\n\t\t\t      enum x86_intercept_stage stage)\n{\n\treturn kvm_x86_ops->check_intercept(emul_to_vcpu(ctxt), info, stage);\n}"
  },
  {
    "function_name": "emulator_put_fpu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "4996-4999",
    "snippet": "static void emulator_put_fpu(struct x86_emulate_ctxt *ctxt)\n{\n\tpreempt_enable();\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 4998
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);\n\nstatic void emulator_put_fpu(struct x86_emulate_ctxt *ctxt)\n{\n\tpreempt_enable();\n}"
  },
  {
    "function_name": "emulator_get_fpu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "4985-4994",
    "snippet": "static void emulator_get_fpu(struct x86_emulate_ctxt *ctxt)\n{\n\tpreempt_disable();\n\tkvm_load_guest_fpu(emul_to_vcpu(ctxt));\n\t/*\n\t * CR0.TS may reference the host fpu state, not the guest fpu state,\n\t * so it may be clear at this point.\n\t */\n\tclts();\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "clts",
          "args": [],
          "line": 4993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_load_guest_fpu",
          "args": [
            "emul_to_vcpu(ctxt)"
          ],
          "line": 4988
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_load_guest_fpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "7312-7326",
          "snippet": "void kvm_load_guest_fpu(struct kvm_vcpu *vcpu)\n{\n\tif (vcpu->guest_fpu_loaded)\n\t\treturn;\n\n\t/*\n\t * Restore all possible states in the guest,\n\t * and assume host would use all available bits.\n\t * Guest xcr0 would be loaded later.\n\t */\n\tvcpu->guest_fpu_loaded = 1;\n\t__kernel_fpu_begin();\n\t__copy_kernel_to_fpregs(&vcpu->arch.guest_fpu.state);\n\ttrace_kvm_fpu(1);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nvoid kvm_load_guest_fpu(struct kvm_vcpu *vcpu)\n{\n\tif (vcpu->guest_fpu_loaded)\n\t\treturn;\n\n\t/*\n\t * Restore all possible states in the guest,\n\t * and assume host would use all available bits.\n\t * Guest xcr0 would be loaded later.\n\t */\n\tvcpu->guest_fpu_loaded = 1;\n\t__kernel_fpu_begin();\n\t__copy_kernel_to_fpregs(&vcpu->arch.guest_fpu.state);\n\ttrace_kvm_fpu(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "emul_to_vcpu",
          "args": [
            "ctxt"
          ],
          "line": 4988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 4987
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);\n\nstatic void emulator_get_fpu(struct x86_emulate_ctxt *ctxt)\n{\n\tpreempt_disable();\n\tkvm_load_guest_fpu(emul_to_vcpu(ctxt));\n\t/*\n\t * CR0.TS may reference the host fpu state, not the guest fpu state,\n\t * so it may be clear at this point.\n\t */\n\tclts();\n}"
  },
  {
    "function_name": "emulator_halt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "4980-4983",
    "snippet": "static void emulator_halt(struct x86_emulate_ctxt *ctxt)\n{\n\temul_to_vcpu(ctxt)->arch.halt_request = 1;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "emul_to_vcpu",
          "args": [
            "ctxt"
          ],
          "line": 4982
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);\n\nstatic void emulator_halt(struct x86_emulate_ctxt *ctxt)\n{\n\temul_to_vcpu(ctxt)->arch.halt_request = 1;\n}"
  },
  {
    "function_name": "emulator_read_pmc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "4974-4978",
    "snippet": "static int emulator_read_pmc(struct x86_emulate_ctxt *ctxt,\n\t\t\t     u32 pmc, u64 *pdata)\n{\n\treturn kvm_pmu_rdpmc(emul_to_vcpu(ctxt), pmc, pdata);\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_pmu_rdpmc",
          "args": [
            "emul_to_vcpu(ctxt)",
            "pmc",
            "pdata"
          ],
          "line": 4977
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_pmu_rdpmc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/pmu.c",
          "lines": "240-256",
          "snippet": "int kvm_pmu_rdpmc(struct kvm_vcpu *vcpu, unsigned idx, u64 *data)\n{\n\tbool fast_mode = idx & (1u << 31);\n\tstruct kvm_pmc *pmc;\n\tu64 ctr_val;\n\n\tpmc = kvm_x86_ops->pmu_ops->msr_idx_to_pmc(vcpu, idx);\n\tif (!pmc)\n\t\treturn 1;\n\n\tctr_val = pmc_read_counter(pmc);\n\tif (fast_mode)\n\t\tctr_val = (u32)ctr_val;\n\n\t*data = ctr_val;\n\treturn 0;\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"lapic.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include <asm/perf_event.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include <asm/perf_event.h>\n#include <linux/perf_event.h>\n#include <linux/kvm_host.h>\n#include <linux/types.h>\n\nint kvm_pmu_rdpmc(struct kvm_vcpu *vcpu, unsigned idx, u64 *data)\n{\n\tbool fast_mode = idx & (1u << 31);\n\tstruct kvm_pmc *pmc;\n\tu64 ctr_val;\n\n\tpmc = kvm_x86_ops->pmu_ops->msr_idx_to_pmc(vcpu, idx);\n\tif (!pmc)\n\t\treturn 1;\n\n\tctr_val = pmc_read_counter(pmc);\n\tif (fast_mode)\n\t\tctr_val = (u32)ctr_val;\n\n\t*data = ctr_val;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "emul_to_vcpu",
          "args": [
            "ctxt"
          ],
          "line": 4977
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);\n\nstatic int emulator_read_pmc(struct x86_emulate_ctxt *ctxt,\n\t\t\t     u32 pmc, u64 *pdata)\n{\n\treturn kvm_pmu_rdpmc(emul_to_vcpu(ctxt), pmc, pdata);\n}"
  },
  {
    "function_name": "emulator_check_pmc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "4968-4972",
    "snippet": "static int emulator_check_pmc(struct x86_emulate_ctxt *ctxt,\n\t\t\t      u32 pmc)\n{\n\treturn kvm_pmu_is_valid_msr_idx(emul_to_vcpu(ctxt), pmc);\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_pmu_is_valid_msr_idx",
          "args": [
            "emul_to_vcpu(ctxt)",
            "pmc"
          ],
          "line": 4971
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_pmu_is_valid_msr_idx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/pmu.c",
          "lines": "235-238",
          "snippet": "int kvm_pmu_is_valid_msr_idx(struct kvm_vcpu *vcpu, unsigned idx)\n{\n\treturn kvm_x86_ops->pmu_ops->is_valid_msr_idx(vcpu, idx);\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"lapic.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include <asm/perf_event.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include <asm/perf_event.h>\n#include <linux/perf_event.h>\n#include <linux/kvm_host.h>\n#include <linux/types.h>\n\nint kvm_pmu_is_valid_msr_idx(struct kvm_vcpu *vcpu, unsigned idx)\n{\n\treturn kvm_x86_ops->pmu_ops->is_valid_msr_idx(vcpu, idx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "emul_to_vcpu",
          "args": [
            "ctxt"
          ],
          "line": 4971
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);\n\nstatic int emulator_check_pmc(struct x86_emulate_ctxt *ctxt,\n\t\t\t      u32 pmc)\n{\n\treturn kvm_pmu_is_valid_msr_idx(emul_to_vcpu(ctxt), pmc);\n}"
  },
  {
    "function_name": "emulator_set_smbase",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "4961-4966",
    "snippet": "static void emulator_set_smbase(struct x86_emulate_ctxt *ctxt, u64 smbase)\n{\n\tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n\n\tvcpu->arch.smbase = smbase;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);",
      "static int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "emul_to_vcpu",
          "args": [
            "ctxt"
          ],
          "line": 4963
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);\n\nstatic void emulator_set_smbase(struct x86_emulate_ctxt *ctxt, u64 smbase)\n{\n\tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n\n\tvcpu->arch.smbase = smbase;\n}"
  },
  {
    "function_name": "emulator_get_smbase",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "4954-4959",
    "snippet": "static u64 emulator_get_smbase(struct x86_emulate_ctxt *ctxt)\n{\n\tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n\n\treturn vcpu->arch.smbase;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);",
      "static int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "emul_to_vcpu",
          "args": [
            "ctxt"
          ],
          "line": 4956
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);\n\nstatic u64 emulator_get_smbase(struct x86_emulate_ctxt *ctxt)\n{\n\tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n\n\treturn vcpu->arch.smbase;\n}"
  },
  {
    "function_name": "emulator_set_msr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "4943-4952",
    "snippet": "static int emulator_set_msr(struct x86_emulate_ctxt *ctxt,\n\t\t\t    u32 msr_index, u64 data)\n{\n\tstruct msr_data msr;\n\n\tmsr.data = data;\n\tmsr.index = msr_index;\n\tmsr.host_initiated = false;\n\treturn kvm_set_msr(emul_to_vcpu(ctxt), &msr);\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_set_msr",
          "args": [
            "emul_to_vcpu(ctxt)",
            "&msr"
          ],
          "line": 4951
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_set_msr_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "2040-2248",
          "snippet": "int kvm_set_msr_common(struct kvm_vcpu *vcpu, struct msr_data *msr_info)\n{\n\tbool pr = false;\n\tu32 msr = msr_info->index;\n\tu64 data = msr_info->data;\n\n\tswitch (msr) {\n\tcase MSR_AMD64_NB_CFG:\n\tcase MSR_IA32_UCODE_REV:\n\tcase MSR_IA32_UCODE_WRITE:\n\tcase MSR_VM_HSAVE_PA:\n\tcase MSR_AMD64_PATCH_LOADER:\n\tcase MSR_AMD64_BU_CFG2:\n\t\tbreak;\n\n\tcase MSR_EFER:\n\t\treturn set_efer(vcpu, data);\n\tcase MSR_K7_HWCR:\n\t\tdata &= ~(u64)0x40;\t/* ignore flush filter disable */\n\t\tdata &= ~(u64)0x100;\t/* ignore ignne emulation enable */\n\t\tdata &= ~(u64)0x8;\t/* ignore TLB cache disable */\n\t\tdata &= ~(u64)0x40000;  /* ignore Mc status write enable */\n\t\tif (data != 0) {\n\t\t\tvcpu_unimpl(vcpu, \"unimplemented HWCR wrmsr: 0x%llx\\n\",\n\t\t\t\t    data);\n\t\t\treturn 1;\n\t\t}\n\t\tbreak;\n\tcase MSR_FAM10H_MMIO_CONF_BASE:\n\t\tif (data != 0) {\n\t\t\tvcpu_unimpl(vcpu, \"unimplemented MMIO_CONF_BASE wrmsr: \"\n\t\t\t\t    \"0x%llx\\n\", data);\n\t\t\treturn 1;\n\t\t}\n\t\tbreak;\n\tcase MSR_IA32_DEBUGCTLMSR:\n\t\tif (!data) {\n\t\t\t/* We support the non-activated case already */\n\t\t\tbreak;\n\t\t} else if (data & ~(DEBUGCTLMSR_LBR | DEBUGCTLMSR_BTF)) {\n\t\t\t/* Values other than LBR and BTF are vendor-specific,\n\t\t\t   thus reserved and should throw a #GP */\n\t\t\treturn 1;\n\t\t}\n\t\tvcpu_unimpl(vcpu, \"%s: MSR_IA32_DEBUGCTLMSR 0x%llx, nop\\n\",\n\t\t\t    __func__, data);\n\t\tbreak;\n\tcase 0x200 ... 0x2ff:\n\t\treturn kvm_mtrr_set_msr(vcpu, msr, data);\n\tcase MSR_IA32_APICBASE:\n\t\treturn kvm_set_apic_base(vcpu, msr_info);\n\tcase APIC_BASE_MSR ... APIC_BASE_MSR + 0x3ff:\n\t\treturn kvm_x2apic_msr_write(vcpu, msr, data);\n\tcase MSR_IA32_TSCDEADLINE:\n\t\tkvm_set_lapic_tscdeadline_msr(vcpu, data);\n\t\tbreak;\n\tcase MSR_IA32_TSC_ADJUST:\n\t\tif (guest_cpuid_has_tsc_adjust(vcpu)) {\n\t\t\tif (!msr_info->host_initiated) {\n\t\t\t\ts64 adj = data - vcpu->arch.ia32_tsc_adjust_msr;\n\t\t\t\tadjust_tsc_offset_guest(vcpu, adj);\n\t\t\t}\n\t\t\tvcpu->arch.ia32_tsc_adjust_msr = data;\n\t\t}\n\t\tbreak;\n\tcase MSR_IA32_MISC_ENABLE:\n\t\tvcpu->arch.ia32_misc_enable_msr = data;\n\t\tbreak;\n\tcase MSR_IA32_SMBASE:\n\t\tif (!msr_info->host_initiated)\n\t\t\treturn 1;\n\t\tvcpu->arch.smbase = data;\n\t\tbreak;\n\tcase MSR_KVM_WALL_CLOCK_NEW:\n\tcase MSR_KVM_WALL_CLOCK:\n\t\tvcpu->kvm->arch.wall_clock = data;\n\t\tkvm_write_wall_clock(vcpu->kvm, data);\n\t\tbreak;\n\tcase MSR_KVM_SYSTEM_TIME_NEW:\n\tcase MSR_KVM_SYSTEM_TIME: {\n\t\tu64 gpa_offset;\n\t\tstruct kvm_arch *ka = &vcpu->kvm->arch;\n\n\t\tkvmclock_reset(vcpu);\n\n\t\tif (vcpu->vcpu_id == 0 && !msr_info->host_initiated) {\n\t\t\tbool tmp = (msr == MSR_KVM_SYSTEM_TIME);\n\n\t\t\tif (ka->boot_vcpu_runs_old_kvmclock != tmp)\n\t\t\t\tset_bit(KVM_REQ_MASTERCLOCK_UPDATE,\n\t\t\t\t\t&vcpu->requests);\n\n\t\t\tka->boot_vcpu_runs_old_kvmclock = tmp;\n\t\t}\n\n\t\tvcpu->arch.time = data;\n\t\tkvm_make_request(KVM_REQ_GLOBAL_CLOCK_UPDATE, vcpu);\n\n\t\t/* we verify if the enable bit is set... */\n\t\tif (!(data & 1))\n\t\t\tbreak;\n\n\t\tgpa_offset = data & ~(PAGE_MASK | 1);\n\n\t\tif (kvm_gfn_to_hva_cache_init(vcpu->kvm,\n\t\t     &vcpu->arch.pv_time, data & ~1ULL,\n\t\t     sizeof(struct pvclock_vcpu_time_info)))\n\t\t\tvcpu->arch.pv_time_enabled = false;\n\t\telse\n\t\t\tvcpu->arch.pv_time_enabled = true;\n\n\t\tbreak;\n\t}\n\tcase MSR_KVM_ASYNC_PF_EN:\n\t\tif (kvm_pv_enable_async_pf(vcpu, data))\n\t\t\treturn 1;\n\t\tbreak;\n\tcase MSR_KVM_STEAL_TIME:\n\n\t\tif (unlikely(!sched_info_on()))\n\t\t\treturn 1;\n\n\t\tif (data & KVM_STEAL_RESERVED_MASK)\n\t\t\treturn 1;\n\n\t\tif (kvm_gfn_to_hva_cache_init(vcpu->kvm, &vcpu->arch.st.stime,\n\t\t\t\t\t\tdata & KVM_STEAL_VALID_BITS,\n\t\t\t\t\t\tsizeof(struct kvm_steal_time)))\n\t\t\treturn 1;\n\n\t\tvcpu->arch.st.msr_val = data;\n\n\t\tif (!(data & KVM_MSR_ENABLED))\n\t\t\tbreak;\n\n\t\tkvm_make_request(KVM_REQ_STEAL_UPDATE, vcpu);\n\n\t\tbreak;\n\tcase MSR_KVM_PV_EOI_EN:\n\t\tif (kvm_lapic_enable_pv_eoi(vcpu, data))\n\t\t\treturn 1;\n\t\tbreak;\n\n\tcase MSR_IA32_MCG_CTL:\n\tcase MSR_IA32_MCG_STATUS:\n\tcase MSR_IA32_MC0_CTL ... MSR_IA32_MCx_CTL(KVM_MAX_MCE_BANKS) - 1:\n\t\treturn set_msr_mce(vcpu, msr, data);\n\n\tcase MSR_K7_PERFCTR0 ... MSR_K7_PERFCTR3:\n\tcase MSR_P6_PERFCTR0 ... MSR_P6_PERFCTR1:\n\t\tpr = true; /* fall through */\n\tcase MSR_K7_EVNTSEL0 ... MSR_K7_EVNTSEL3:\n\tcase MSR_P6_EVNTSEL0 ... MSR_P6_EVNTSEL1:\n\t\tif (kvm_pmu_is_valid_msr(vcpu, msr))\n\t\t\treturn kvm_pmu_set_msr(vcpu, msr_info);\n\n\t\tif (pr || data != 0)\n\t\t\tvcpu_unimpl(vcpu, \"disabled perfctr wrmsr: \"\n\t\t\t\t    \"0x%x data 0x%llx\\n\", msr, data);\n\t\tbreak;\n\tcase MSR_K7_CLK_CTL:\n\t\t/*\n\t\t * Ignore all writes to this no longer documented MSR.\n\t\t * Writes are only relevant for old K7 processors,\n\t\t * all pre-dating SVM, but a recommended workaround from\n\t\t * AMD for these chips. It is possible to specify the\n\t\t * affected processor models on the command line, hence\n\t\t * the need to ignore the workaround.\n\t\t */\n\t\tbreak;\n\tcase HV_X64_MSR_GUEST_OS_ID ... HV_X64_MSR_SINT15:\n\tcase HV_X64_MSR_CRASH_P0 ... HV_X64_MSR_CRASH_P4:\n\tcase HV_X64_MSR_CRASH_CTL:\n\tcase HV_X64_MSR_STIMER0_CONFIG ... HV_X64_MSR_STIMER3_COUNT:\n\t\treturn kvm_hv_set_msr_common(vcpu, msr, data,\n\t\t\t\t\t     msr_info->host_initiated);\n\tcase MSR_IA32_BBL_CR_CTL3:\n\t\t/* Drop writes to this legacy MSR -- see rdmsr\n\t\t * counterpart for further detail.\n\t\t */\n\t\tvcpu_unimpl(vcpu, \"ignored wrmsr: 0x%x data %llx\\n\", msr, data);\n\t\tbreak;\n\tcase MSR_AMD64_OSVW_ID_LENGTH:\n\t\tif (!guest_cpuid_has_osvw(vcpu))\n\t\t\treturn 1;\n\t\tvcpu->arch.osvw.length = data;\n\t\tbreak;\n\tcase MSR_AMD64_OSVW_STATUS:\n\t\tif (!guest_cpuid_has_osvw(vcpu))\n\t\t\treturn 1;\n\t\tvcpu->arch.osvw.status = data;\n\t\tbreak;\n\tdefault:\n\t\tif (msr && (msr == vcpu->kvm->arch.xen_hvm_config.msr))\n\t\t\treturn xen_hvm_config(vcpu, data);\n\t\tif (kvm_pmu_is_valid_msr(vcpu, msr))\n\t\t\treturn kvm_pmu_set_msr(vcpu, msr_info);\n\t\tif (!ignore_msrs) {\n\t\t\tvcpu_unimpl(vcpu, \"unhandled wrmsr: 0x%x data %llx\\n\",\n\t\t\t\t    msr, data);\n\t\t\treturn 1;\n\t\t} else {\n\t\t\tvcpu_unimpl(vcpu, \"ignored wrmsr: 0x%x data %llx\\n\",\n\t\t\t\t    msr, data);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define KVM_MAX_MCE_BANKS 32"
          ],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define KVM_MAX_MCE_BANKS 32\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nint kvm_set_msr_common(struct kvm_vcpu *vcpu, struct msr_data *msr_info)\n{\n\tbool pr = false;\n\tu32 msr = msr_info->index;\n\tu64 data = msr_info->data;\n\n\tswitch (msr) {\n\tcase MSR_AMD64_NB_CFG:\n\tcase MSR_IA32_UCODE_REV:\n\tcase MSR_IA32_UCODE_WRITE:\n\tcase MSR_VM_HSAVE_PA:\n\tcase MSR_AMD64_PATCH_LOADER:\n\tcase MSR_AMD64_BU_CFG2:\n\t\tbreak;\n\n\tcase MSR_EFER:\n\t\treturn set_efer(vcpu, data);\n\tcase MSR_K7_HWCR:\n\t\tdata &= ~(u64)0x40;\t/* ignore flush filter disable */\n\t\tdata &= ~(u64)0x100;\t/* ignore ignne emulation enable */\n\t\tdata &= ~(u64)0x8;\t/* ignore TLB cache disable */\n\t\tdata &= ~(u64)0x40000;  /* ignore Mc status write enable */\n\t\tif (data != 0) {\n\t\t\tvcpu_unimpl(vcpu, \"unimplemented HWCR wrmsr: 0x%llx\\n\",\n\t\t\t\t    data);\n\t\t\treturn 1;\n\t\t}\n\t\tbreak;\n\tcase MSR_FAM10H_MMIO_CONF_BASE:\n\t\tif (data != 0) {\n\t\t\tvcpu_unimpl(vcpu, \"unimplemented MMIO_CONF_BASE wrmsr: \"\n\t\t\t\t    \"0x%llx\\n\", data);\n\t\t\treturn 1;\n\t\t}\n\t\tbreak;\n\tcase MSR_IA32_DEBUGCTLMSR:\n\t\tif (!data) {\n\t\t\t/* We support the non-activated case already */\n\t\t\tbreak;\n\t\t} else if (data & ~(DEBUGCTLMSR_LBR | DEBUGCTLMSR_BTF)) {\n\t\t\t/* Values other than LBR and BTF are vendor-specific,\n\t\t\t   thus reserved and should throw a #GP */\n\t\t\treturn 1;\n\t\t}\n\t\tvcpu_unimpl(vcpu, \"%s: MSR_IA32_DEBUGCTLMSR 0x%llx, nop\\n\",\n\t\t\t    __func__, data);\n\t\tbreak;\n\tcase 0x200 ... 0x2ff:\n\t\treturn kvm_mtrr_set_msr(vcpu, msr, data);\n\tcase MSR_IA32_APICBASE:\n\t\treturn kvm_set_apic_base(vcpu, msr_info);\n\tcase APIC_BASE_MSR ... APIC_BASE_MSR + 0x3ff:\n\t\treturn kvm_x2apic_msr_write(vcpu, msr, data);\n\tcase MSR_IA32_TSCDEADLINE:\n\t\tkvm_set_lapic_tscdeadline_msr(vcpu, data);\n\t\tbreak;\n\tcase MSR_IA32_TSC_ADJUST:\n\t\tif (guest_cpuid_has_tsc_adjust(vcpu)) {\n\t\t\tif (!msr_info->host_initiated) {\n\t\t\t\ts64 adj = data - vcpu->arch.ia32_tsc_adjust_msr;\n\t\t\t\tadjust_tsc_offset_guest(vcpu, adj);\n\t\t\t}\n\t\t\tvcpu->arch.ia32_tsc_adjust_msr = data;\n\t\t}\n\t\tbreak;\n\tcase MSR_IA32_MISC_ENABLE:\n\t\tvcpu->arch.ia32_misc_enable_msr = data;\n\t\tbreak;\n\tcase MSR_IA32_SMBASE:\n\t\tif (!msr_info->host_initiated)\n\t\t\treturn 1;\n\t\tvcpu->arch.smbase = data;\n\t\tbreak;\n\tcase MSR_KVM_WALL_CLOCK_NEW:\n\tcase MSR_KVM_WALL_CLOCK:\n\t\tvcpu->kvm->arch.wall_clock = data;\n\t\tkvm_write_wall_clock(vcpu->kvm, data);\n\t\tbreak;\n\tcase MSR_KVM_SYSTEM_TIME_NEW:\n\tcase MSR_KVM_SYSTEM_TIME: {\n\t\tu64 gpa_offset;\n\t\tstruct kvm_arch *ka = &vcpu->kvm->arch;\n\n\t\tkvmclock_reset(vcpu);\n\n\t\tif (vcpu->vcpu_id == 0 && !msr_info->host_initiated) {\n\t\t\tbool tmp = (msr == MSR_KVM_SYSTEM_TIME);\n\n\t\t\tif (ka->boot_vcpu_runs_old_kvmclock != tmp)\n\t\t\t\tset_bit(KVM_REQ_MASTERCLOCK_UPDATE,\n\t\t\t\t\t&vcpu->requests);\n\n\t\t\tka->boot_vcpu_runs_old_kvmclock = tmp;\n\t\t}\n\n\t\tvcpu->arch.time = data;\n\t\tkvm_make_request(KVM_REQ_GLOBAL_CLOCK_UPDATE, vcpu);\n\n\t\t/* we verify if the enable bit is set... */\n\t\tif (!(data & 1))\n\t\t\tbreak;\n\n\t\tgpa_offset = data & ~(PAGE_MASK | 1);\n\n\t\tif (kvm_gfn_to_hva_cache_init(vcpu->kvm,\n\t\t     &vcpu->arch.pv_time, data & ~1ULL,\n\t\t     sizeof(struct pvclock_vcpu_time_info)))\n\t\t\tvcpu->arch.pv_time_enabled = false;\n\t\telse\n\t\t\tvcpu->arch.pv_time_enabled = true;\n\n\t\tbreak;\n\t}\n\tcase MSR_KVM_ASYNC_PF_EN:\n\t\tif (kvm_pv_enable_async_pf(vcpu, data))\n\t\t\treturn 1;\n\t\tbreak;\n\tcase MSR_KVM_STEAL_TIME:\n\n\t\tif (unlikely(!sched_info_on()))\n\t\t\treturn 1;\n\n\t\tif (data & KVM_STEAL_RESERVED_MASK)\n\t\t\treturn 1;\n\n\t\tif (kvm_gfn_to_hva_cache_init(vcpu->kvm, &vcpu->arch.st.stime,\n\t\t\t\t\t\tdata & KVM_STEAL_VALID_BITS,\n\t\t\t\t\t\tsizeof(struct kvm_steal_time)))\n\t\t\treturn 1;\n\n\t\tvcpu->arch.st.msr_val = data;\n\n\t\tif (!(data & KVM_MSR_ENABLED))\n\t\t\tbreak;\n\n\t\tkvm_make_request(KVM_REQ_STEAL_UPDATE, vcpu);\n\n\t\tbreak;\n\tcase MSR_KVM_PV_EOI_EN:\n\t\tif (kvm_lapic_enable_pv_eoi(vcpu, data))\n\t\t\treturn 1;\n\t\tbreak;\n\n\tcase MSR_IA32_MCG_CTL:\n\tcase MSR_IA32_MCG_STATUS:\n\tcase MSR_IA32_MC0_CTL ... MSR_IA32_MCx_CTL(KVM_MAX_MCE_BANKS) - 1:\n\t\treturn set_msr_mce(vcpu, msr, data);\n\n\tcase MSR_K7_PERFCTR0 ... MSR_K7_PERFCTR3:\n\tcase MSR_P6_PERFCTR0 ... MSR_P6_PERFCTR1:\n\t\tpr = true; /* fall through */\n\tcase MSR_K7_EVNTSEL0 ... MSR_K7_EVNTSEL3:\n\tcase MSR_P6_EVNTSEL0 ... MSR_P6_EVNTSEL1:\n\t\tif (kvm_pmu_is_valid_msr(vcpu, msr))\n\t\t\treturn kvm_pmu_set_msr(vcpu, msr_info);\n\n\t\tif (pr || data != 0)\n\t\t\tvcpu_unimpl(vcpu, \"disabled perfctr wrmsr: \"\n\t\t\t\t    \"0x%x data 0x%llx\\n\", msr, data);\n\t\tbreak;\n\tcase MSR_K7_CLK_CTL:\n\t\t/*\n\t\t * Ignore all writes to this no longer documented MSR.\n\t\t * Writes are only relevant for old K7 processors,\n\t\t * all pre-dating SVM, but a recommended workaround from\n\t\t * AMD for these chips. It is possible to specify the\n\t\t * affected processor models on the command line, hence\n\t\t * the need to ignore the workaround.\n\t\t */\n\t\tbreak;\n\tcase HV_X64_MSR_GUEST_OS_ID ... HV_X64_MSR_SINT15:\n\tcase HV_X64_MSR_CRASH_P0 ... HV_X64_MSR_CRASH_P4:\n\tcase HV_X64_MSR_CRASH_CTL:\n\tcase HV_X64_MSR_STIMER0_CONFIG ... HV_X64_MSR_STIMER3_COUNT:\n\t\treturn kvm_hv_set_msr_common(vcpu, msr, data,\n\t\t\t\t\t     msr_info->host_initiated);\n\tcase MSR_IA32_BBL_CR_CTL3:\n\t\t/* Drop writes to this legacy MSR -- see rdmsr\n\t\t * counterpart for further detail.\n\t\t */\n\t\tvcpu_unimpl(vcpu, \"ignored wrmsr: 0x%x data %llx\\n\", msr, data);\n\t\tbreak;\n\tcase MSR_AMD64_OSVW_ID_LENGTH:\n\t\tif (!guest_cpuid_has_osvw(vcpu))\n\t\t\treturn 1;\n\t\tvcpu->arch.osvw.length = data;\n\t\tbreak;\n\tcase MSR_AMD64_OSVW_STATUS:\n\t\tif (!guest_cpuid_has_osvw(vcpu))\n\t\t\treturn 1;\n\t\tvcpu->arch.osvw.status = data;\n\t\tbreak;\n\tdefault:\n\t\tif (msr && (msr == vcpu->kvm->arch.xen_hvm_config.msr))\n\t\t\treturn xen_hvm_config(vcpu, data);\n\t\tif (kvm_pmu_is_valid_msr(vcpu, msr))\n\t\t\treturn kvm_pmu_set_msr(vcpu, msr_info);\n\t\tif (!ignore_msrs) {\n\t\t\tvcpu_unimpl(vcpu, \"unhandled wrmsr: 0x%x data %llx\\n\",\n\t\t\t\t    msr, data);\n\t\t\treturn 1;\n\t\t} else {\n\t\t\tvcpu_unimpl(vcpu, \"ignored wrmsr: 0x%x data %llx\\n\",\n\t\t\t\t    msr, data);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "emul_to_vcpu",
          "args": [
            "ctxt"
          ],
          "line": 4951
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);\n\nstatic int emulator_set_msr(struct x86_emulate_ctxt *ctxt,\n\t\t\t    u32 msr_index, u64 data)\n{\n\tstruct msr_data msr;\n\n\tmsr.data = data;\n\tmsr.index = msr_index;\n\tmsr.host_initiated = false;\n\treturn kvm_set_msr(emul_to_vcpu(ctxt), &msr);\n}"
  },
  {
    "function_name": "emulator_get_msr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "4927-4941",
    "snippet": "static int emulator_get_msr(struct x86_emulate_ctxt *ctxt,\n\t\t\t    u32 msr_index, u64 *pdata)\n{\n\tstruct msr_data msr;\n\tint r;\n\n\tmsr.index = msr_index;\n\tmsr.host_initiated = false;\n\tr = kvm_get_msr(emul_to_vcpu(ctxt), &msr);\n\tif (r)\n\t\treturn r;\n\n\t*pdata = msr.data;\n\treturn 0;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_get_msr",
          "args": [
            "emul_to_vcpu(ctxt)",
            "&msr"
          ],
          "line": 4935
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_get_msr_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "2298-2458",
          "snippet": "int kvm_get_msr_common(struct kvm_vcpu *vcpu, struct msr_data *msr_info)\n{\n\tswitch (msr_info->index) {\n\tcase MSR_IA32_PLATFORM_ID:\n\tcase MSR_IA32_EBL_CR_POWERON:\n\tcase MSR_IA32_DEBUGCTLMSR:\n\tcase MSR_IA32_LASTBRANCHFROMIP:\n\tcase MSR_IA32_LASTBRANCHTOIP:\n\tcase MSR_IA32_LASTINTFROMIP:\n\tcase MSR_IA32_LASTINTTOIP:\n\tcase MSR_K8_SYSCFG:\n\tcase MSR_K8_TSEG_ADDR:\n\tcase MSR_K8_TSEG_MASK:\n\tcase MSR_K7_HWCR:\n\tcase MSR_VM_HSAVE_PA:\n\tcase MSR_K8_INT_PENDING_MSG:\n\tcase MSR_AMD64_NB_CFG:\n\tcase MSR_FAM10H_MMIO_CONF_BASE:\n\tcase MSR_AMD64_BU_CFG2:\n\t\tmsr_info->data = 0;\n\t\tbreak;\n\tcase MSR_K7_EVNTSEL0 ... MSR_K7_EVNTSEL3:\n\tcase MSR_K7_PERFCTR0 ... MSR_K7_PERFCTR3:\n\tcase MSR_P6_PERFCTR0 ... MSR_P6_PERFCTR1:\n\tcase MSR_P6_EVNTSEL0 ... MSR_P6_EVNTSEL1:\n\t\tif (kvm_pmu_is_valid_msr(vcpu, msr_info->index))\n\t\t\treturn kvm_pmu_get_msr(vcpu, msr_info->index, &msr_info->data);\n\t\tmsr_info->data = 0;\n\t\tbreak;\n\tcase MSR_IA32_UCODE_REV:\n\t\tmsr_info->data = 0x100000000ULL;\n\t\tbreak;\n\tcase MSR_MTRRcap:\n\tcase 0x200 ... 0x2ff:\n\t\treturn kvm_mtrr_get_msr(vcpu, msr_info->index, &msr_info->data);\n\tcase 0xcd: /* fsb frequency */\n\t\tmsr_info->data = 3;\n\t\tbreak;\n\t\t/*\n\t\t * MSR_EBC_FREQUENCY_ID\n\t\t * Conservative value valid for even the basic CPU models.\n\t\t * Models 0,1: 000 in bits 23:21 indicating a bus speed of\n\t\t * 100MHz, model 2 000 in bits 18:16 indicating 100MHz,\n\t\t * and 266MHz for model 3, or 4. Set Core Clock\n\t\t * Frequency to System Bus Frequency Ratio to 1 (bits\n\t\t * 31:24) even though these are only valid for CPU\n\t\t * models > 2, however guests may end up dividing or\n\t\t * multiplying by zero otherwise.\n\t\t */\n\tcase MSR_EBC_FREQUENCY_ID:\n\t\tmsr_info->data = 1 << 24;\n\t\tbreak;\n\tcase MSR_IA32_APICBASE:\n\t\tmsr_info->data = kvm_get_apic_base(vcpu);\n\t\tbreak;\n\tcase APIC_BASE_MSR ... APIC_BASE_MSR + 0x3ff:\n\t\treturn kvm_x2apic_msr_read(vcpu, msr_info->index, &msr_info->data);\n\t\tbreak;\n\tcase MSR_IA32_TSCDEADLINE:\n\t\tmsr_info->data = kvm_get_lapic_tscdeadline_msr(vcpu);\n\t\tbreak;\n\tcase MSR_IA32_TSC_ADJUST:\n\t\tmsr_info->data = (u64)vcpu->arch.ia32_tsc_adjust_msr;\n\t\tbreak;\n\tcase MSR_IA32_MISC_ENABLE:\n\t\tmsr_info->data = vcpu->arch.ia32_misc_enable_msr;\n\t\tbreak;\n\tcase MSR_IA32_SMBASE:\n\t\tif (!msr_info->host_initiated)\n\t\t\treturn 1;\n\t\tmsr_info->data = vcpu->arch.smbase;\n\t\tbreak;\n\tcase MSR_IA32_PERF_STATUS:\n\t\t/* TSC increment by tick */\n\t\tmsr_info->data = 1000ULL;\n\t\t/* CPU multiplier */\n\t\tmsr_info->data |= (((uint64_t)4ULL) << 40);\n\t\tbreak;\n\tcase MSR_EFER:\n\t\tmsr_info->data = vcpu->arch.efer;\n\t\tbreak;\n\tcase MSR_KVM_WALL_CLOCK:\n\tcase MSR_KVM_WALL_CLOCK_NEW:\n\t\tmsr_info->data = vcpu->kvm->arch.wall_clock;\n\t\tbreak;\n\tcase MSR_KVM_SYSTEM_TIME:\n\tcase MSR_KVM_SYSTEM_TIME_NEW:\n\t\tmsr_info->data = vcpu->arch.time;\n\t\tbreak;\n\tcase MSR_KVM_ASYNC_PF_EN:\n\t\tmsr_info->data = vcpu->arch.apf.msr_val;\n\t\tbreak;\n\tcase MSR_KVM_STEAL_TIME:\n\t\tmsr_info->data = vcpu->arch.st.msr_val;\n\t\tbreak;\n\tcase MSR_KVM_PV_EOI_EN:\n\t\tmsr_info->data = vcpu->arch.pv_eoi.msr_val;\n\t\tbreak;\n\tcase MSR_IA32_P5_MC_ADDR:\n\tcase MSR_IA32_P5_MC_TYPE:\n\tcase MSR_IA32_MCG_CAP:\n\tcase MSR_IA32_MCG_CTL:\n\tcase MSR_IA32_MCG_STATUS:\n\tcase MSR_IA32_MC0_CTL ... MSR_IA32_MCx_CTL(KVM_MAX_MCE_BANKS) - 1:\n\t\treturn get_msr_mce(vcpu, msr_info->index, &msr_info->data);\n\tcase MSR_K7_CLK_CTL:\n\t\t/*\n\t\t * Provide expected ramp-up count for K7. All other\n\t\t * are set to zero, indicating minimum divisors for\n\t\t * every field.\n\t\t *\n\t\t * This prevents guest kernels on AMD host with CPU\n\t\t * type 6, model 8 and higher from exploding due to\n\t\t * the rdmsr failing.\n\t\t */\n\t\tmsr_info->data = 0x20000000;\n\t\tbreak;\n\tcase HV_X64_MSR_GUEST_OS_ID ... HV_X64_MSR_SINT15:\n\tcase HV_X64_MSR_CRASH_P0 ... HV_X64_MSR_CRASH_P4:\n\tcase HV_X64_MSR_CRASH_CTL:\n\tcase HV_X64_MSR_STIMER0_CONFIG ... HV_X64_MSR_STIMER3_COUNT:\n\t\treturn kvm_hv_get_msr_common(vcpu,\n\t\t\t\t\t     msr_info->index, &msr_info->data);\n\t\tbreak;\n\tcase MSR_IA32_BBL_CR_CTL3:\n\t\t/* This legacy MSR exists but isn't fully documented in current\n\t\t * silicon.  It is however accessed by winxp in very narrow\n\t\t * scenarios where it sets bit #19, itself documented as\n\t\t * a \"reserved\" bit.  Best effort attempt to source coherent\n\t\t * read data here should the balance of the register be\n\t\t * interpreted by the guest:\n\t\t *\n\t\t * L2 cache control register 3: 64GB range, 256KB size,\n\t\t * enabled, latency 0x1, configured\n\t\t */\n\t\tmsr_info->data = 0xbe702111;\n\t\tbreak;\n\tcase MSR_AMD64_OSVW_ID_LENGTH:\n\t\tif (!guest_cpuid_has_osvw(vcpu))\n\t\t\treturn 1;\n\t\tmsr_info->data = vcpu->arch.osvw.length;\n\t\tbreak;\n\tcase MSR_AMD64_OSVW_STATUS:\n\t\tif (!guest_cpuid_has_osvw(vcpu))\n\t\t\treturn 1;\n\t\tmsr_info->data = vcpu->arch.osvw.status;\n\t\tbreak;\n\tdefault:\n\t\tif (kvm_pmu_is_valid_msr(vcpu, msr_info->index))\n\t\t\treturn kvm_pmu_get_msr(vcpu, msr_info->index, &msr_info->data);\n\t\tif (!ignore_msrs) {\n\t\t\tvcpu_unimpl(vcpu, \"unhandled rdmsr: 0x%x\\n\", msr_info->index);\n\t\t\treturn 1;\n\t\t} else {\n\t\t\tvcpu_unimpl(vcpu, \"ignored rdmsr: 0x%x\\n\", msr_info->index);\n\t\t\tmsr_info->data = 0;\n\t\t}\n\t\tbreak;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define KVM_MAX_MCE_BANKS 32"
          ],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define KVM_MAX_MCE_BANKS 32\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nint kvm_get_msr_common(struct kvm_vcpu *vcpu, struct msr_data *msr_info)\n{\n\tswitch (msr_info->index) {\n\tcase MSR_IA32_PLATFORM_ID:\n\tcase MSR_IA32_EBL_CR_POWERON:\n\tcase MSR_IA32_DEBUGCTLMSR:\n\tcase MSR_IA32_LASTBRANCHFROMIP:\n\tcase MSR_IA32_LASTBRANCHTOIP:\n\tcase MSR_IA32_LASTINTFROMIP:\n\tcase MSR_IA32_LASTINTTOIP:\n\tcase MSR_K8_SYSCFG:\n\tcase MSR_K8_TSEG_ADDR:\n\tcase MSR_K8_TSEG_MASK:\n\tcase MSR_K7_HWCR:\n\tcase MSR_VM_HSAVE_PA:\n\tcase MSR_K8_INT_PENDING_MSG:\n\tcase MSR_AMD64_NB_CFG:\n\tcase MSR_FAM10H_MMIO_CONF_BASE:\n\tcase MSR_AMD64_BU_CFG2:\n\t\tmsr_info->data = 0;\n\t\tbreak;\n\tcase MSR_K7_EVNTSEL0 ... MSR_K7_EVNTSEL3:\n\tcase MSR_K7_PERFCTR0 ... MSR_K7_PERFCTR3:\n\tcase MSR_P6_PERFCTR0 ... MSR_P6_PERFCTR1:\n\tcase MSR_P6_EVNTSEL0 ... MSR_P6_EVNTSEL1:\n\t\tif (kvm_pmu_is_valid_msr(vcpu, msr_info->index))\n\t\t\treturn kvm_pmu_get_msr(vcpu, msr_info->index, &msr_info->data);\n\t\tmsr_info->data = 0;\n\t\tbreak;\n\tcase MSR_IA32_UCODE_REV:\n\t\tmsr_info->data = 0x100000000ULL;\n\t\tbreak;\n\tcase MSR_MTRRcap:\n\tcase 0x200 ... 0x2ff:\n\t\treturn kvm_mtrr_get_msr(vcpu, msr_info->index, &msr_info->data);\n\tcase 0xcd: /* fsb frequency */\n\t\tmsr_info->data = 3;\n\t\tbreak;\n\t\t/*\n\t\t * MSR_EBC_FREQUENCY_ID\n\t\t * Conservative value valid for even the basic CPU models.\n\t\t * Models 0,1: 000 in bits 23:21 indicating a bus speed of\n\t\t * 100MHz, model 2 000 in bits 18:16 indicating 100MHz,\n\t\t * and 266MHz for model 3, or 4. Set Core Clock\n\t\t * Frequency to System Bus Frequency Ratio to 1 (bits\n\t\t * 31:24) even though these are only valid for CPU\n\t\t * models > 2, however guests may end up dividing or\n\t\t * multiplying by zero otherwise.\n\t\t */\n\tcase MSR_EBC_FREQUENCY_ID:\n\t\tmsr_info->data = 1 << 24;\n\t\tbreak;\n\tcase MSR_IA32_APICBASE:\n\t\tmsr_info->data = kvm_get_apic_base(vcpu);\n\t\tbreak;\n\tcase APIC_BASE_MSR ... APIC_BASE_MSR + 0x3ff:\n\t\treturn kvm_x2apic_msr_read(vcpu, msr_info->index, &msr_info->data);\n\t\tbreak;\n\tcase MSR_IA32_TSCDEADLINE:\n\t\tmsr_info->data = kvm_get_lapic_tscdeadline_msr(vcpu);\n\t\tbreak;\n\tcase MSR_IA32_TSC_ADJUST:\n\t\tmsr_info->data = (u64)vcpu->arch.ia32_tsc_adjust_msr;\n\t\tbreak;\n\tcase MSR_IA32_MISC_ENABLE:\n\t\tmsr_info->data = vcpu->arch.ia32_misc_enable_msr;\n\t\tbreak;\n\tcase MSR_IA32_SMBASE:\n\t\tif (!msr_info->host_initiated)\n\t\t\treturn 1;\n\t\tmsr_info->data = vcpu->arch.smbase;\n\t\tbreak;\n\tcase MSR_IA32_PERF_STATUS:\n\t\t/* TSC increment by tick */\n\t\tmsr_info->data = 1000ULL;\n\t\t/* CPU multiplier */\n\t\tmsr_info->data |= (((uint64_t)4ULL) << 40);\n\t\tbreak;\n\tcase MSR_EFER:\n\t\tmsr_info->data = vcpu->arch.efer;\n\t\tbreak;\n\tcase MSR_KVM_WALL_CLOCK:\n\tcase MSR_KVM_WALL_CLOCK_NEW:\n\t\tmsr_info->data = vcpu->kvm->arch.wall_clock;\n\t\tbreak;\n\tcase MSR_KVM_SYSTEM_TIME:\n\tcase MSR_KVM_SYSTEM_TIME_NEW:\n\t\tmsr_info->data = vcpu->arch.time;\n\t\tbreak;\n\tcase MSR_KVM_ASYNC_PF_EN:\n\t\tmsr_info->data = vcpu->arch.apf.msr_val;\n\t\tbreak;\n\tcase MSR_KVM_STEAL_TIME:\n\t\tmsr_info->data = vcpu->arch.st.msr_val;\n\t\tbreak;\n\tcase MSR_KVM_PV_EOI_EN:\n\t\tmsr_info->data = vcpu->arch.pv_eoi.msr_val;\n\t\tbreak;\n\tcase MSR_IA32_P5_MC_ADDR:\n\tcase MSR_IA32_P5_MC_TYPE:\n\tcase MSR_IA32_MCG_CAP:\n\tcase MSR_IA32_MCG_CTL:\n\tcase MSR_IA32_MCG_STATUS:\n\tcase MSR_IA32_MC0_CTL ... MSR_IA32_MCx_CTL(KVM_MAX_MCE_BANKS) - 1:\n\t\treturn get_msr_mce(vcpu, msr_info->index, &msr_info->data);\n\tcase MSR_K7_CLK_CTL:\n\t\t/*\n\t\t * Provide expected ramp-up count for K7. All other\n\t\t * are set to zero, indicating minimum divisors for\n\t\t * every field.\n\t\t *\n\t\t * This prevents guest kernels on AMD host with CPU\n\t\t * type 6, model 8 and higher from exploding due to\n\t\t * the rdmsr failing.\n\t\t */\n\t\tmsr_info->data = 0x20000000;\n\t\tbreak;\n\tcase HV_X64_MSR_GUEST_OS_ID ... HV_X64_MSR_SINT15:\n\tcase HV_X64_MSR_CRASH_P0 ... HV_X64_MSR_CRASH_P4:\n\tcase HV_X64_MSR_CRASH_CTL:\n\tcase HV_X64_MSR_STIMER0_CONFIG ... HV_X64_MSR_STIMER3_COUNT:\n\t\treturn kvm_hv_get_msr_common(vcpu,\n\t\t\t\t\t     msr_info->index, &msr_info->data);\n\t\tbreak;\n\tcase MSR_IA32_BBL_CR_CTL3:\n\t\t/* This legacy MSR exists but isn't fully documented in current\n\t\t * silicon.  It is however accessed by winxp in very narrow\n\t\t * scenarios where it sets bit #19, itself documented as\n\t\t * a \"reserved\" bit.  Best effort attempt to source coherent\n\t\t * read data here should the balance of the register be\n\t\t * interpreted by the guest:\n\t\t *\n\t\t * L2 cache control register 3: 64GB range, 256KB size,\n\t\t * enabled, latency 0x1, configured\n\t\t */\n\t\tmsr_info->data = 0xbe702111;\n\t\tbreak;\n\tcase MSR_AMD64_OSVW_ID_LENGTH:\n\t\tif (!guest_cpuid_has_osvw(vcpu))\n\t\t\treturn 1;\n\t\tmsr_info->data = vcpu->arch.osvw.length;\n\t\tbreak;\n\tcase MSR_AMD64_OSVW_STATUS:\n\t\tif (!guest_cpuid_has_osvw(vcpu))\n\t\t\treturn 1;\n\t\tmsr_info->data = vcpu->arch.osvw.status;\n\t\tbreak;\n\tdefault:\n\t\tif (kvm_pmu_is_valid_msr(vcpu, msr_info->index))\n\t\t\treturn kvm_pmu_get_msr(vcpu, msr_info->index, &msr_info->data);\n\t\tif (!ignore_msrs) {\n\t\t\tvcpu_unimpl(vcpu, \"unhandled rdmsr: 0x%x\\n\", msr_info->index);\n\t\t\treturn 1;\n\t\t} else {\n\t\t\tvcpu_unimpl(vcpu, \"ignored rdmsr: 0x%x\\n\", msr_info->index);\n\t\t\tmsr_info->data = 0;\n\t\t}\n\t\tbreak;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "emul_to_vcpu",
          "args": [
            "ctxt"
          ],
          "line": 4935
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);\n\nstatic int emulator_get_msr(struct x86_emulate_ctxt *ctxt,\n\t\t\t    u32 msr_index, u64 *pdata)\n{\n\tstruct msr_data msr;\n\tint r;\n\n\tmsr.index = msr_index;\n\tmsr.host_initiated = false;\n\tr = kvm_get_msr(emul_to_vcpu(ctxt), &msr);\n\tif (r)\n\t\treturn r;\n\n\t*pdata = msr.data;\n\treturn 0;\n}"
  },
  {
    "function_name": "emulator_set_segment",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "4897-4925",
    "snippet": "static void emulator_set_segment(struct x86_emulate_ctxt *ctxt, u16 selector,\n\t\t\t\t struct desc_struct *desc, u32 base3,\n\t\t\t\t int seg)\n{\n\tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n\tstruct kvm_segment var;\n\n\tvar.selector = selector;\n\tvar.base = get_desc_base(desc);\n#ifdef CONFIG_X86_64\n\tvar.base |= ((u64)base3) << 32;\n#endif\n\tvar.limit = get_desc_limit(desc);\n\tif (desc->g)\n\t\tvar.limit = (var.limit << 12) | 0xfff;\n\tvar.type = desc->type;\n\tvar.dpl = desc->dpl;\n\tvar.db = desc->d;\n\tvar.s = desc->s;\n\tvar.l = desc->l;\n\tvar.g = desc->g;\n\tvar.avl = desc->avl;\n\tvar.present = desc->p;\n\tvar.unusable = !var.present;\n\tvar.padding = 0;\n\n\tkvm_set_segment(vcpu, &var, seg);\n\treturn;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);",
      "static int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_set_segment",
          "args": [
            "vcpu",
            "&var",
            "seg"
          ],
          "line": 4923
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_set_segment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "4151-4155",
          "snippet": "static void kvm_set_segment(struct kvm_vcpu *vcpu,\n\t\t\tstruct kvm_segment *var, int seg)\n{\n\tkvm_x86_ops->set_segment(vcpu, var, seg);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "struct kvm_x86_ops *kvm_x86_ops"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nstatic void kvm_set_segment(struct kvm_vcpu *vcpu,\n\t\t\tstruct kvm_segment *var, int seg)\n{\n\tkvm_x86_ops->set_segment(vcpu, var, seg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_desc_limit",
          "args": [
            "desc"
          ],
          "line": 4909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_desc_base",
          "args": [
            "desc"
          ],
          "line": 4905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "emul_to_vcpu",
          "args": [
            "ctxt"
          ],
          "line": 4901
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);\n\nstatic void emulator_set_segment(struct x86_emulate_ctxt *ctxt, u16 selector,\n\t\t\t\t struct desc_struct *desc, u32 base3,\n\t\t\t\t int seg)\n{\n\tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n\tstruct kvm_segment var;\n\n\tvar.selector = selector;\n\tvar.base = get_desc_base(desc);\n#ifdef CONFIG_X86_64\n\tvar.base |= ((u64)base3) << 32;\n#endif\n\tvar.limit = get_desc_limit(desc);\n\tif (desc->g)\n\t\tvar.limit = (var.limit << 12) | 0xfff;\n\tvar.type = desc->type;\n\tvar.dpl = desc->dpl;\n\tvar.db = desc->d;\n\tvar.s = desc->s;\n\tvar.l = desc->l;\n\tvar.g = desc->g;\n\tvar.avl = desc->avl;\n\tvar.present = desc->p;\n\tvar.unusable = !var.present;\n\tvar.padding = 0;\n\n\tkvm_set_segment(vcpu, &var, seg);\n\treturn;\n}"
  },
  {
    "function_name": "emulator_get_segment",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "4863-4895",
    "snippet": "static bool emulator_get_segment(struct x86_emulate_ctxt *ctxt, u16 *selector,\n\t\t\t\t struct desc_struct *desc, u32 *base3,\n\t\t\t\t int seg)\n{\n\tstruct kvm_segment var;\n\n\tkvm_get_segment(emul_to_vcpu(ctxt), &var, seg);\n\t*selector = var.selector;\n\n\tif (var.unusable) {\n\t\tmemset(desc, 0, sizeof(*desc));\n\t\treturn false;\n\t}\n\n\tif (var.g)\n\t\tvar.limit >>= 12;\n\tset_desc_limit(desc, var.limit);\n\tset_desc_base(desc, (unsigned long)var.base);\n#ifdef CONFIG_X86_64\n\tif (base3)\n\t\t*base3 = var.base >> 32;\n#endif\n\tdesc->type = var.type;\n\tdesc->s = var.s;\n\tdesc->dpl = var.dpl;\n\tdesc->p = var.present;\n\tdesc->avl = var.avl;\n\tdesc->l = var.l;\n\tdesc->d = var.db;\n\tdesc->g = var.g;\n\n\treturn true;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_desc_base",
          "args": [
            "desc",
            "(unsigned long)var.base"
          ],
          "line": 4880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_desc_limit",
          "args": [
            "desc",
            "var.limit"
          ],
          "line": 4879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "desc",
            "0",
            "sizeof(*desc)"
          ],
          "line": 4873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_get_segment",
          "args": [
            "emul_to_vcpu(ctxt)",
            "&var",
            "seg"
          ],
          "line": 4869
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_get_segment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "4157-4161",
          "snippet": "void kvm_get_segment(struct kvm_vcpu *vcpu,\n\t\t     struct kvm_segment *var, int seg)\n{\n\tkvm_x86_ops->get_segment(vcpu, var, seg);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "struct kvm_x86_ops *kvm_x86_ops"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nvoid kvm_get_segment(struct kvm_vcpu *vcpu,\n\t\t     struct kvm_segment *var, int seg)\n{\n\tkvm_x86_ops->get_segment(vcpu, var, seg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "emul_to_vcpu",
          "args": [
            "ctxt"
          ],
          "line": 4869
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);\n\nstatic bool emulator_get_segment(struct x86_emulate_ctxt *ctxt, u16 *selector,\n\t\t\t\t struct desc_struct *desc, u32 *base3,\n\t\t\t\t int seg)\n{\n\tstruct kvm_segment var;\n\n\tkvm_get_segment(emul_to_vcpu(ctxt), &var, seg);\n\t*selector = var.selector;\n\n\tif (var.unusable) {\n\t\tmemset(desc, 0, sizeof(*desc));\n\t\treturn false;\n\t}\n\n\tif (var.g)\n\t\tvar.limit >>= 12;\n\tset_desc_limit(desc, var.limit);\n\tset_desc_base(desc, (unsigned long)var.base);\n#ifdef CONFIG_X86_64\n\tif (base3)\n\t\t*base3 = var.base >> 32;\n#endif\n\tdesc->type = var.type;\n\tdesc->s = var.s;\n\tdesc->dpl = var.dpl;\n\tdesc->p = var.present;\n\tdesc->avl = var.avl;\n\tdesc->l = var.l;\n\tdesc->d = var.db;\n\tdesc->g = var.g;\n\n\treturn true;\n}"
  },
  {
    "function_name": "emulator_get_cached_segment_base",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "4857-4861",
    "snippet": "static unsigned long emulator_get_cached_segment_base(\n\tstruct x86_emulate_ctxt *ctxt, int seg)\n{\n\treturn get_segment_base(emul_to_vcpu(ctxt), seg);\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_segment_base",
          "args": [
            "emul_to_vcpu(ctxt)",
            "seg"
          ],
          "line": 4860
        },
        "resolved": true,
        "details": {
          "function_name": "get_segment_base",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "4714-4717",
          "snippet": "static unsigned long get_segment_base(struct kvm_vcpu *vcpu, int seg)\n{\n\treturn kvm_x86_ops->get_segment_base(vcpu, seg);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "struct kvm_x86_ops *kvm_x86_ops"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nstatic unsigned long get_segment_base(struct kvm_vcpu *vcpu, int seg)\n{\n\treturn kvm_x86_ops->get_segment_base(vcpu, seg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "emul_to_vcpu",
          "args": [
            "ctxt"
          ],
          "line": 4860
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);\n\nstatic unsigned long emulator_get_cached_segment_base(\n\tstruct x86_emulate_ctxt *ctxt, int seg)\n{\n\treturn get_segment_base(emul_to_vcpu(ctxt), seg);\n}"
  },
  {
    "function_name": "emulator_set_idt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "4852-4855",
    "snippet": "static void emulator_set_idt(struct x86_emulate_ctxt *ctxt, struct desc_ptr *dt)\n{\n\tkvm_x86_ops->set_idt(emul_to_vcpu(ctxt), dt);\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct kvm_x86_ops *kvm_x86_ops",
      "static int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_x86_ops->set_idt",
          "args": [
            "emul_to_vcpu(ctxt)",
            "dt"
          ],
          "line": 4854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "emul_to_vcpu",
          "args": [
            "ctxt"
          ],
          "line": 4854
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstruct kvm_x86_ops *kvm_x86_ops;\nstatic int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);\n\nstatic void emulator_set_idt(struct x86_emulate_ctxt *ctxt, struct desc_ptr *dt)\n{\n\tkvm_x86_ops->set_idt(emul_to_vcpu(ctxt), dt);\n}"
  },
  {
    "function_name": "emulator_set_gdt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "4847-4850",
    "snippet": "static void emulator_set_gdt(struct x86_emulate_ctxt *ctxt, struct desc_ptr *dt)\n{\n\tkvm_x86_ops->set_gdt(emul_to_vcpu(ctxt), dt);\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct kvm_x86_ops *kvm_x86_ops",
      "static int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_x86_ops->set_gdt",
          "args": [
            "emul_to_vcpu(ctxt)",
            "dt"
          ],
          "line": 4849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "emul_to_vcpu",
          "args": [
            "ctxt"
          ],
          "line": 4849
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstruct kvm_x86_ops *kvm_x86_ops;\nstatic int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);\n\nstatic void emulator_set_gdt(struct x86_emulate_ctxt *ctxt, struct desc_ptr *dt)\n{\n\tkvm_x86_ops->set_gdt(emul_to_vcpu(ctxt), dt);\n}"
  },
  {
    "function_name": "emulator_get_idt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "4842-4845",
    "snippet": "static void emulator_get_idt(struct x86_emulate_ctxt *ctxt, struct desc_ptr *dt)\n{\n\tkvm_x86_ops->get_idt(emul_to_vcpu(ctxt), dt);\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct kvm_x86_ops *kvm_x86_ops",
      "static int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_x86_ops->get_idt",
          "args": [
            "emul_to_vcpu(ctxt)",
            "dt"
          ],
          "line": 4844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "emul_to_vcpu",
          "args": [
            "ctxt"
          ],
          "line": 4844
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstruct kvm_x86_ops *kvm_x86_ops;\nstatic int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);\n\nstatic void emulator_get_idt(struct x86_emulate_ctxt *ctxt, struct desc_ptr *dt)\n{\n\tkvm_x86_ops->get_idt(emul_to_vcpu(ctxt), dt);\n}"
  },
  {
    "function_name": "emulator_get_gdt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "4837-4840",
    "snippet": "static void emulator_get_gdt(struct x86_emulate_ctxt *ctxt, struct desc_ptr *dt)\n{\n\tkvm_x86_ops->get_gdt(emul_to_vcpu(ctxt), dt);\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct kvm_x86_ops *kvm_x86_ops",
      "static int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_x86_ops->get_gdt",
          "args": [
            "emul_to_vcpu(ctxt)",
            "dt"
          ],
          "line": 4839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "emul_to_vcpu",
          "args": [
            "ctxt"
          ],
          "line": 4839
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstruct kvm_x86_ops *kvm_x86_ops;\nstatic int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);\n\nstatic void emulator_get_gdt(struct x86_emulate_ctxt *ctxt, struct desc_ptr *dt)\n{\n\tkvm_x86_ops->get_gdt(emul_to_vcpu(ctxt), dt);\n}"
  },
  {
    "function_name": "emulator_get_cpl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "4832-4835",
    "snippet": "static int emulator_get_cpl(struct x86_emulate_ctxt *ctxt)\n{\n\treturn kvm_x86_ops->get_cpl(emul_to_vcpu(ctxt));\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct kvm_x86_ops *kvm_x86_ops",
      "static int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_x86_ops->get_cpl",
          "args": [
            "emul_to_vcpu(ctxt)"
          ],
          "line": 4834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "emul_to_vcpu",
          "args": [
            "ctxt"
          ],
          "line": 4834
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstruct kvm_x86_ops *kvm_x86_ops;\nstatic int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);\n\nstatic int emulator_get_cpl(struct x86_emulate_ctxt *ctxt)\n{\n\treturn kvm_x86_ops->get_cpl(emul_to_vcpu(ctxt));\n}"
  },
  {
    "function_name": "emulator_set_cr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "4803-4830",
    "snippet": "static int emulator_set_cr(struct x86_emulate_ctxt *ctxt, int cr, ulong val)\n{\n\tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n\tint res = 0;\n\n\tswitch (cr) {\n\tcase 0:\n\t\tres = kvm_set_cr0(vcpu, mk_cr_64(kvm_read_cr0(vcpu), val));\n\t\tbreak;\n\tcase 2:\n\t\tvcpu->arch.cr2 = val;\n\t\tbreak;\n\tcase 3:\n\t\tres = kvm_set_cr3(vcpu, val);\n\t\tbreak;\n\tcase 4:\n\t\tres = kvm_set_cr4(vcpu, mk_cr_64(kvm_read_cr4(vcpu), val));\n\t\tbreak;\n\tcase 8:\n\t\tres = kvm_set_cr8(vcpu, val);\n\t\tbreak;\n\tdefault:\n\t\tkvm_err(\"%s: unexpected cr %u\\n\", __func__, cr);\n\t\tres = -1;\n\t}\n\n\treturn res;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);",
      "static int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_err",
          "args": [
            "\"%s: unexpected cr %u\\n\"",
            "__func__",
            "cr"
          ],
          "line": 4825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_set_cr8",
          "args": [
            "vcpu",
            "val"
          ],
          "line": 4822
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_set_cr8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "804-813",
          "snippet": "int kvm_set_cr8(struct kvm_vcpu *vcpu, unsigned long cr8)\n{\n\tif (cr8 & CR8_RESERVED_BITS)\n\t\treturn 1;\n\tif (lapic_in_kernel(vcpu))\n\t\tkvm_lapic_set_tpr(vcpu, cr8);\n\telse\n\t\tvcpu->arch.cr8 = cr8;\n\treturn 0;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nint kvm_set_cr8(struct kvm_vcpu *vcpu, unsigned long cr8)\n{\n\tif (cr8 & CR8_RESERVED_BITS)\n\t\treturn 1;\n\tif (lapic_in_kernel(vcpu))\n\t\tkvm_lapic_set_tpr(vcpu, cr8);\n\telse\n\t\tvcpu->arch.cr8 = cr8;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_set_cr4",
          "args": [
            "vcpu",
            "mk_cr_64(kvm_read_cr4(vcpu), val)"
          ],
          "line": 4819
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_set_cr4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "722-775",
          "snippet": "int kvm_set_cr4(struct kvm_vcpu *vcpu, unsigned long cr4)\n{\n\tunsigned long old_cr4 = kvm_read_cr4(vcpu);\n\tunsigned long pdptr_bits = X86_CR4_PGE | X86_CR4_PSE | X86_CR4_PAE |\n\t\t\t\t   X86_CR4_SMEP | X86_CR4_SMAP | X86_CR4_PKE;\n\n\tif (cr4 & CR4_RESERVED_BITS)\n\t\treturn 1;\n\n\tif (!guest_cpuid_has_xsave(vcpu) && (cr4 & X86_CR4_OSXSAVE))\n\t\treturn 1;\n\n\tif (!guest_cpuid_has_smep(vcpu) && (cr4 & X86_CR4_SMEP))\n\t\treturn 1;\n\n\tif (!guest_cpuid_has_smap(vcpu) && (cr4 & X86_CR4_SMAP))\n\t\treturn 1;\n\n\tif (!guest_cpuid_has_fsgsbase(vcpu) && (cr4 & X86_CR4_FSGSBASE))\n\t\treturn 1;\n\n\tif (!guest_cpuid_has_pku(vcpu) && (cr4 & X86_CR4_PKE))\n\t\treturn 1;\n\n\tif (is_long_mode(vcpu)) {\n\t\tif (!(cr4 & X86_CR4_PAE))\n\t\t\treturn 1;\n\t} else if (is_paging(vcpu) && (cr4 & X86_CR4_PAE)\n\t\t   && ((cr4 ^ old_cr4) & pdptr_bits)\n\t\t   && !load_pdptrs(vcpu, vcpu->arch.walk_mmu,\n\t\t\t\t   kvm_read_cr3(vcpu)))\n\t\treturn 1;\n\n\tif ((cr4 & X86_CR4_PCIDE) && !(old_cr4 & X86_CR4_PCIDE)) {\n\t\tif (!guest_cpuid_has_pcid(vcpu))\n\t\t\treturn 1;\n\n\t\t/* PCID can not be enabled when cr3[11:0]!=000H or EFER.LMA=0 */\n\t\tif ((kvm_read_cr3(vcpu) & X86_CR3_PCID_MASK) || !is_long_mode(vcpu))\n\t\t\treturn 1;\n\t}\n\n\tif (kvm_x86_ops->set_cr4(vcpu, cr4))\n\t\treturn 1;\n\n\tif (((cr4 ^ old_cr4) & pdptr_bits) ||\n\t    (!(cr4 & X86_CR4_PCIDE) && (old_cr4 & X86_CR4_PCIDE)))\n\t\tkvm_mmu_reset_context(vcpu);\n\n\tif ((cr4 ^ old_cr4) & (X86_CR4_OSXSAVE | X86_CR4_PKE))\n\t\tkvm_update_cpuid(vcpu);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "struct kvm_x86_ops *kvm_x86_ops"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nint kvm_set_cr4(struct kvm_vcpu *vcpu, unsigned long cr4)\n{\n\tunsigned long old_cr4 = kvm_read_cr4(vcpu);\n\tunsigned long pdptr_bits = X86_CR4_PGE | X86_CR4_PSE | X86_CR4_PAE |\n\t\t\t\t   X86_CR4_SMEP | X86_CR4_SMAP | X86_CR4_PKE;\n\n\tif (cr4 & CR4_RESERVED_BITS)\n\t\treturn 1;\n\n\tif (!guest_cpuid_has_xsave(vcpu) && (cr4 & X86_CR4_OSXSAVE))\n\t\treturn 1;\n\n\tif (!guest_cpuid_has_smep(vcpu) && (cr4 & X86_CR4_SMEP))\n\t\treturn 1;\n\n\tif (!guest_cpuid_has_smap(vcpu) && (cr4 & X86_CR4_SMAP))\n\t\treturn 1;\n\n\tif (!guest_cpuid_has_fsgsbase(vcpu) && (cr4 & X86_CR4_FSGSBASE))\n\t\treturn 1;\n\n\tif (!guest_cpuid_has_pku(vcpu) && (cr4 & X86_CR4_PKE))\n\t\treturn 1;\n\n\tif (is_long_mode(vcpu)) {\n\t\tif (!(cr4 & X86_CR4_PAE))\n\t\t\treturn 1;\n\t} else if (is_paging(vcpu) && (cr4 & X86_CR4_PAE)\n\t\t   && ((cr4 ^ old_cr4) & pdptr_bits)\n\t\t   && !load_pdptrs(vcpu, vcpu->arch.walk_mmu,\n\t\t\t\t   kvm_read_cr3(vcpu)))\n\t\treturn 1;\n\n\tif ((cr4 & X86_CR4_PCIDE) && !(old_cr4 & X86_CR4_PCIDE)) {\n\t\tif (!guest_cpuid_has_pcid(vcpu))\n\t\t\treturn 1;\n\n\t\t/* PCID can not be enabled when cr3[11:0]!=000H or EFER.LMA=0 */\n\t\tif ((kvm_read_cr3(vcpu) & X86_CR3_PCID_MASK) || !is_long_mode(vcpu))\n\t\t\treturn 1;\n\t}\n\n\tif (kvm_x86_ops->set_cr4(vcpu, cr4))\n\t\treturn 1;\n\n\tif (((cr4 ^ old_cr4) & pdptr_bits) ||\n\t    (!(cr4 & X86_CR4_PCIDE) && (old_cr4 & X86_CR4_PCIDE)))\n\t\tkvm_mmu_reset_context(vcpu);\n\n\tif ((cr4 ^ old_cr4) & (X86_CR4_OSXSAVE | X86_CR4_PKE))\n\t\tkvm_update_cpuid(vcpu);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mk_cr_64",
          "args": [
            "kvm_read_cr4(vcpu)",
            "val"
          ],
          "line": 4819
        },
        "resolved": true,
        "details": {
          "function_name": "mk_cr_64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "4769-4772",
          "snippet": "static u64 mk_cr_64(u64 curr_cr, u32 new_val)\n{\n\treturn (curr_cr & ~((1ULL << 32) - 1)) | new_val;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic u64 mk_cr_64(u64 curr_cr, u32 new_val)\n{\n\treturn (curr_cr & ~((1ULL << 32) - 1)) | new_val;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_read_cr4",
          "args": [
            "vcpu"
          ],
          "line": 4819
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_read_cr4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "76-79",
          "snippet": "static inline ulong kvm_read_cr4(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_read_cr4_bits(vcpu, ~0UL);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline ulong kvm_read_cr4(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_read_cr4_bits(vcpu, ~0UL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_set_cr3",
          "args": [
            "vcpu",
            "val"
          ],
          "line": 4816
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_set_cr3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "778-801",
          "snippet": "int kvm_set_cr3(struct kvm_vcpu *vcpu, unsigned long cr3)\n{\n#ifdef CONFIG_X86_64\n\tcr3 &= ~CR3_PCID_INVD;\n#endif\n\n\tif (cr3 == kvm_read_cr3(vcpu) && !pdptrs_changed(vcpu)) {\n\t\tkvm_mmu_sync_roots(vcpu);\n\t\tkvm_make_request(KVM_REQ_TLB_FLUSH, vcpu);\n\t\treturn 0;\n\t}\n\n\tif (is_long_mode(vcpu)) {\n\t\tif (cr3 & CR3_L_MODE_RESERVED_BITS)\n\t\t\treturn 1;\n\t} else if (is_pae(vcpu) && is_paging(vcpu) &&\n\t\t   !load_pdptrs(vcpu, vcpu->arch.walk_mmu, cr3))\n\t\treturn 1;\n\n\tvcpu->arch.cr3 = cr3;\n\t__set_bit(VCPU_EXREG_CR3, (ulong *)&vcpu->arch.regs_avail);\n\tkvm_mmu_new_cr3(vcpu);\n\treturn 0;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nint kvm_set_cr3(struct kvm_vcpu *vcpu, unsigned long cr3)\n{\n#ifdef CONFIG_X86_64\n\tcr3 &= ~CR3_PCID_INVD;\n#endif\n\n\tif (cr3 == kvm_read_cr3(vcpu) && !pdptrs_changed(vcpu)) {\n\t\tkvm_mmu_sync_roots(vcpu);\n\t\tkvm_make_request(KVM_REQ_TLB_FLUSH, vcpu);\n\t\treturn 0;\n\t}\n\n\tif (is_long_mode(vcpu)) {\n\t\tif (cr3 & CR3_L_MODE_RESERVED_BITS)\n\t\t\treturn 1;\n\t} else if (is_pae(vcpu) && is_paging(vcpu) &&\n\t\t   !load_pdptrs(vcpu, vcpu->arch.walk_mmu, cr3))\n\t\treturn 1;\n\n\tvcpu->arch.cr3 = cr3;\n\t__set_bit(VCPU_EXREG_CR3, (ulong *)&vcpu->arch.regs_avail);\n\tkvm_mmu_new_cr3(vcpu);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_set_cr0",
          "args": [
            "vcpu",
            "mk_cr_64(kvm_read_cr0(vcpu), val)"
          ],
          "line": 4810
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_set_cr0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "587-643",
          "snippet": "int kvm_set_cr0(struct kvm_vcpu *vcpu, unsigned long cr0)\n{\n\tunsigned long old_cr0 = kvm_read_cr0(vcpu);\n\tunsigned long update_bits = X86_CR0_PG | X86_CR0_WP;\n\n\tcr0 |= X86_CR0_ET;\n\n#ifdef CONFIG_X86_64\n\tif (cr0 & 0xffffffff00000000UL)\n\t\treturn 1;\n#endif\n\n\tcr0 &= ~CR0_RESERVED_BITS;\n\n\tif ((cr0 & X86_CR0_NW) && !(cr0 & X86_CR0_CD))\n\t\treturn 1;\n\n\tif ((cr0 & X86_CR0_PG) && !(cr0 & X86_CR0_PE))\n\t\treturn 1;\n\n\tif (!is_paging(vcpu) && (cr0 & X86_CR0_PG)) {\n#ifdef CONFIG_X86_64\n\t\tif ((vcpu->arch.efer & EFER_LME)) {\n\t\t\tint cs_db, cs_l;\n\n\t\t\tif (!is_pae(vcpu))\n\t\t\t\treturn 1;\n\t\t\tkvm_x86_ops->get_cs_db_l_bits(vcpu, &cs_db, &cs_l);\n\t\t\tif (cs_l)\n\t\t\t\treturn 1;\n\t\t} else\n#endif\n\t\tif (is_pae(vcpu) && !load_pdptrs(vcpu, vcpu->arch.walk_mmu,\n\t\t\t\t\t\t kvm_read_cr3(vcpu)))\n\t\t\treturn 1;\n\t}\n\n\tif (!(cr0 & X86_CR0_PG) && kvm_read_cr4_bits(vcpu, X86_CR4_PCIDE))\n\t\treturn 1;\n\n\tkvm_x86_ops->set_cr0(vcpu, cr0);\n\n\tif ((cr0 ^ old_cr0) & X86_CR0_PG) {\n\t\tkvm_clear_async_pf_completion_queue(vcpu);\n\t\tkvm_async_pf_hash_reset(vcpu);\n\t}\n\n\tif ((cr0 ^ old_cr0) & update_bits)\n\t\tkvm_mmu_reset_context(vcpu);\n\n\tif (((cr0 ^ old_cr0) & X86_CR0_CD) &&\n\t    kvm_arch_has_noncoherent_dma(vcpu->kvm) &&\n\t    !kvm_check_has_quirk(vcpu->kvm, KVM_X86_QUIRK_CD_NW_CLEARED))\n\t\tkvm_zap_gfn_range(vcpu->kvm, 0, ~0ULL);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "struct kvm_x86_ops *kvm_x86_ops"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nint kvm_set_cr0(struct kvm_vcpu *vcpu, unsigned long cr0)\n{\n\tunsigned long old_cr0 = kvm_read_cr0(vcpu);\n\tunsigned long update_bits = X86_CR0_PG | X86_CR0_WP;\n\n\tcr0 |= X86_CR0_ET;\n\n#ifdef CONFIG_X86_64\n\tif (cr0 & 0xffffffff00000000UL)\n\t\treturn 1;\n#endif\n\n\tcr0 &= ~CR0_RESERVED_BITS;\n\n\tif ((cr0 & X86_CR0_NW) && !(cr0 & X86_CR0_CD))\n\t\treturn 1;\n\n\tif ((cr0 & X86_CR0_PG) && !(cr0 & X86_CR0_PE))\n\t\treturn 1;\n\n\tif (!is_paging(vcpu) && (cr0 & X86_CR0_PG)) {\n#ifdef CONFIG_X86_64\n\t\tif ((vcpu->arch.efer & EFER_LME)) {\n\t\t\tint cs_db, cs_l;\n\n\t\t\tif (!is_pae(vcpu))\n\t\t\t\treturn 1;\n\t\t\tkvm_x86_ops->get_cs_db_l_bits(vcpu, &cs_db, &cs_l);\n\t\t\tif (cs_l)\n\t\t\t\treturn 1;\n\t\t} else\n#endif\n\t\tif (is_pae(vcpu) && !load_pdptrs(vcpu, vcpu->arch.walk_mmu,\n\t\t\t\t\t\t kvm_read_cr3(vcpu)))\n\t\t\treturn 1;\n\t}\n\n\tif (!(cr0 & X86_CR0_PG) && kvm_read_cr4_bits(vcpu, X86_CR4_PCIDE))\n\t\treturn 1;\n\n\tkvm_x86_ops->set_cr0(vcpu, cr0);\n\n\tif ((cr0 ^ old_cr0) & X86_CR0_PG) {\n\t\tkvm_clear_async_pf_completion_queue(vcpu);\n\t\tkvm_async_pf_hash_reset(vcpu);\n\t}\n\n\tif ((cr0 ^ old_cr0) & update_bits)\n\t\tkvm_mmu_reset_context(vcpu);\n\n\tif (((cr0 ^ old_cr0) & X86_CR0_CD) &&\n\t    kvm_arch_has_noncoherent_dma(vcpu->kvm) &&\n\t    !kvm_check_has_quirk(vcpu->kvm, KVM_X86_QUIRK_CD_NW_CLEARED))\n\t\tkvm_zap_gfn_range(vcpu->kvm, 0, ~0ULL);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_read_cr0",
          "args": [
            "vcpu"
          ],
          "line": 4810
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_read_cr0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "56-59",
          "snippet": "static inline ulong kvm_read_cr0(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_read_cr0_bits(vcpu, ~0UL);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline ulong kvm_read_cr0(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_read_cr0_bits(vcpu, ~0UL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "emul_to_vcpu",
          "args": [
            "ctxt"
          ],
          "line": 4805
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);\n\nstatic int emulator_set_cr(struct x86_emulate_ctxt *ctxt, int cr, ulong val)\n{\n\tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n\tint res = 0;\n\n\tswitch (cr) {\n\tcase 0:\n\t\tres = kvm_set_cr0(vcpu, mk_cr_64(kvm_read_cr0(vcpu), val));\n\t\tbreak;\n\tcase 2:\n\t\tvcpu->arch.cr2 = val;\n\t\tbreak;\n\tcase 3:\n\t\tres = kvm_set_cr3(vcpu, val);\n\t\tbreak;\n\tcase 4:\n\t\tres = kvm_set_cr4(vcpu, mk_cr_64(kvm_read_cr4(vcpu), val));\n\t\tbreak;\n\tcase 8:\n\t\tres = kvm_set_cr8(vcpu, val);\n\t\tbreak;\n\tdefault:\n\t\tkvm_err(\"%s: unexpected cr %u\\n\", __func__, cr);\n\t\tres = -1;\n\t}\n\n\treturn res;\n}"
  },
  {
    "function_name": "emulator_get_cr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "4774-4801",
    "snippet": "static unsigned long emulator_get_cr(struct x86_emulate_ctxt *ctxt, int cr)\n{\n\tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n\tunsigned long value;\n\n\tswitch (cr) {\n\tcase 0:\n\t\tvalue = kvm_read_cr0(vcpu);\n\t\tbreak;\n\tcase 2:\n\t\tvalue = vcpu->arch.cr2;\n\t\tbreak;\n\tcase 3:\n\t\tvalue = kvm_read_cr3(vcpu);\n\t\tbreak;\n\tcase 4:\n\t\tvalue = kvm_read_cr4(vcpu);\n\t\tbreak;\n\tcase 8:\n\t\tvalue = kvm_get_cr8(vcpu);\n\t\tbreak;\n\tdefault:\n\t\tkvm_err(\"%s: unexpected cr %u\\n\", __func__, cr);\n\t\treturn 0;\n\t}\n\n\treturn value;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);",
      "static int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_err",
          "args": [
            "\"%s: unexpected cr %u\\n\"",
            "__func__",
            "cr"
          ],
          "line": 4796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_get_cr8",
          "args": [
            "vcpu"
          ],
          "line": 4793
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_get_cr8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "816-822",
          "snippet": "unsigned long kvm_get_cr8(struct kvm_vcpu *vcpu)\n{\n\tif (lapic_in_kernel(vcpu))\n\t\treturn kvm_lapic_get_cr8(vcpu);\n\telse\n\t\treturn vcpu->arch.cr8;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nunsigned long kvm_get_cr8(struct kvm_vcpu *vcpu)\n{\n\tif (lapic_in_kernel(vcpu))\n\t\treturn kvm_lapic_get_cr8(vcpu);\n\telse\n\t\treturn vcpu->arch.cr8;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_read_cr4",
          "args": [
            "vcpu"
          ],
          "line": 4790
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_read_cr4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "76-79",
          "snippet": "static inline ulong kvm_read_cr4(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_read_cr4_bits(vcpu, ~0UL);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline ulong kvm_read_cr4(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_read_cr4_bits(vcpu, ~0UL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_read_cr3",
          "args": [
            "vcpu"
          ],
          "line": 4787
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_read_cr3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "69-74",
          "snippet": "static inline ulong kvm_read_cr3(struct kvm_vcpu *vcpu)\n{\n\tif (!test_bit(VCPU_EXREG_CR3, (ulong *)&vcpu->arch.regs_avail))\n\t\tkvm_x86_ops->decache_cr3(vcpu);\n\treturn vcpu->arch.cr3;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline ulong kvm_read_cr3(struct kvm_vcpu *vcpu)\n{\n\tif (!test_bit(VCPU_EXREG_CR3, (ulong *)&vcpu->arch.regs_avail))\n\t\tkvm_x86_ops->decache_cr3(vcpu);\n\treturn vcpu->arch.cr3;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_read_cr0",
          "args": [
            "vcpu"
          ],
          "line": 4781
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_read_cr0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "56-59",
          "snippet": "static inline ulong kvm_read_cr0(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_read_cr0_bits(vcpu, ~0UL);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline ulong kvm_read_cr0(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_read_cr0_bits(vcpu, ~0UL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "emul_to_vcpu",
          "args": [
            "ctxt"
          ],
          "line": 4776
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);\n\nstatic unsigned long emulator_get_cr(struct x86_emulate_ctxt *ctxt, int cr)\n{\n\tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n\tunsigned long value;\n\n\tswitch (cr) {\n\tcase 0:\n\t\tvalue = kvm_read_cr0(vcpu);\n\t\tbreak;\n\tcase 2:\n\t\tvalue = vcpu->arch.cr2;\n\t\tbreak;\n\tcase 3:\n\t\tvalue = kvm_read_cr3(vcpu);\n\t\tbreak;\n\tcase 4:\n\t\tvalue = kvm_read_cr4(vcpu);\n\t\tbreak;\n\tcase 8:\n\t\tvalue = kvm_get_cr8(vcpu);\n\t\tbreak;\n\tdefault:\n\t\tkvm_err(\"%s: unexpected cr %u\\n\", __func__, cr);\n\t\treturn 0;\n\t}\n\n\treturn value;\n}"
  },
  {
    "function_name": "mk_cr_64",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "4769-4772",
    "snippet": "static u64 mk_cr_64(u64 curr_cr, u32 new_val)\n{\n\treturn (curr_cr & ~((1ULL << 32) - 1)) | new_val;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic u64 mk_cr_64(u64 curr_cr, u32 new_val)\n{\n\treturn (curr_cr & ~((1ULL << 32) - 1)) | new_val;\n}"
  },
  {
    "function_name": "emulator_set_dr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "4762-4767",
    "snippet": "static int emulator_set_dr(struct x86_emulate_ctxt *ctxt, int dr,\n\t\t\t   unsigned long value)\n{\n\n\treturn __kvm_set_dr(emul_to_vcpu(ctxt), dr, value);\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__kvm_set_dr",
          "args": [
            "emul_to_vcpu(ctxt)",
            "dr",
            "value"
          ],
          "line": 4766
        },
        "resolved": true,
        "details": {
          "function_name": "__kvm_set_dr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "865-892",
          "snippet": "static int __kvm_set_dr(struct kvm_vcpu *vcpu, int dr, unsigned long val)\n{\n\tswitch (dr) {\n\tcase 0 ... 3:\n\t\tvcpu->arch.db[dr] = val;\n\t\tif (!(vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP))\n\t\t\tvcpu->arch.eff_db[dr] = val;\n\t\tbreak;\n\tcase 4:\n\t\t/* fall through */\n\tcase 6:\n\t\tif (val & 0xffffffff00000000ULL)\n\t\t\treturn -1; /* #GP */\n\t\tvcpu->arch.dr6 = (val & DR6_VOLATILE) | kvm_dr6_fixed(vcpu);\n\t\tkvm_update_dr6(vcpu);\n\t\tbreak;\n\tcase 5:\n\t\t/* fall through */\n\tdefault: /* 7 */\n\t\tif (val & 0xffffffff00000000ULL)\n\t\t\treturn -1; /* #GP */\n\t\tvcpu->arch.dr7 = (val & DR7_VOLATILE) | DR7_FIXED_1;\n\t\tkvm_update_dr7(vcpu);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic int __kvm_set_dr(struct kvm_vcpu *vcpu, int dr, unsigned long val)\n{\n\tswitch (dr) {\n\tcase 0 ... 3:\n\t\tvcpu->arch.db[dr] = val;\n\t\tif (!(vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP))\n\t\t\tvcpu->arch.eff_db[dr] = val;\n\t\tbreak;\n\tcase 4:\n\t\t/* fall through */\n\tcase 6:\n\t\tif (val & 0xffffffff00000000ULL)\n\t\t\treturn -1; /* #GP */\n\t\tvcpu->arch.dr6 = (val & DR6_VOLATILE) | kvm_dr6_fixed(vcpu);\n\t\tkvm_update_dr6(vcpu);\n\t\tbreak;\n\tcase 5:\n\t\t/* fall through */\n\tdefault: /* 7 */\n\t\tif (val & 0xffffffff00000000ULL)\n\t\t\treturn -1; /* #GP */\n\t\tvcpu->arch.dr7 = (val & DR7_VOLATILE) | DR7_FIXED_1;\n\t\tkvm_update_dr7(vcpu);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "emul_to_vcpu",
          "args": [
            "ctxt"
          ],
          "line": 4766
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);\n\nstatic int emulator_set_dr(struct x86_emulate_ctxt *ctxt, int dr,\n\t\t\t   unsigned long value)\n{\n\n\treturn __kvm_set_dr(emul_to_vcpu(ctxt), dr, value);\n}"
  },
  {
    "function_name": "emulator_get_dr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "4756-4760",
    "snippet": "static int emulator_get_dr(struct x86_emulate_ctxt *ctxt, int dr,\n\t\t\t   unsigned long *dest)\n{\n\treturn kvm_get_dr(emul_to_vcpu(ctxt), dr, dest);\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_get_dr",
          "args": [
            "emul_to_vcpu(ctxt)",
            "dr",
            "dest"
          ],
          "line": 4759
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_get_dr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "904-925",
          "snippet": "int kvm_get_dr(struct kvm_vcpu *vcpu, int dr, unsigned long *val)\n{\n\tswitch (dr) {\n\tcase 0 ... 3:\n\t\t*val = vcpu->arch.db[dr];\n\t\tbreak;\n\tcase 4:\n\t\t/* fall through */\n\tcase 6:\n\t\tif (vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP)\n\t\t\t*val = vcpu->arch.dr6;\n\t\telse\n\t\t\t*val = kvm_x86_ops->get_dr6(vcpu);\n\t\tbreak;\n\tcase 5:\n\t\t/* fall through */\n\tdefault: /* 7 */\n\t\t*val = vcpu->arch.dr7;\n\t\tbreak;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "struct kvm_x86_ops *kvm_x86_ops"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nint kvm_get_dr(struct kvm_vcpu *vcpu, int dr, unsigned long *val)\n{\n\tswitch (dr) {\n\tcase 0 ... 3:\n\t\t*val = vcpu->arch.db[dr];\n\t\tbreak;\n\tcase 4:\n\t\t/* fall through */\n\tcase 6:\n\t\tif (vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP)\n\t\t\t*val = vcpu->arch.dr6;\n\t\telse\n\t\t\t*val = kvm_x86_ops->get_dr6(vcpu);\n\t\tbreak;\n\tcase 5:\n\t\t/* fall through */\n\tdefault: /* 7 */\n\t\t*val = vcpu->arch.dr7;\n\t\tbreak;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "emul_to_vcpu",
          "args": [
            "ctxt"
          ],
          "line": 4759
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);\n\nstatic int emulator_get_dr(struct x86_emulate_ctxt *ctxt, int dr,\n\t\t\t   unsigned long *dest)\n{\n\treturn kvm_get_dr(emul_to_vcpu(ctxt), dr, dest);\n}"
  },
  {
    "function_name": "emulator_wbinvd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "4751-4754",
    "snippet": "static void emulator_wbinvd(struct x86_emulate_ctxt *ctxt)\n{\n\tkvm_emulate_wbinvd_noskip(emul_to_vcpu(ctxt));\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_emulate_wbinvd_noskip",
          "args": [
            "emul_to_vcpu(ctxt)"
          ],
          "line": 4753
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_emulate_wbinvd_noskip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "4724-4740",
          "snippet": "int kvm_emulate_wbinvd_noskip(struct kvm_vcpu *vcpu)\n{\n\tif (!need_emulate_wbinvd(vcpu))\n\t\treturn X86EMUL_CONTINUE;\n\n\tif (kvm_x86_ops->has_wbinvd_exit()) {\n\t\tint cpu = get_cpu();\n\n\t\tcpumask_set_cpu(cpu, vcpu->arch.wbinvd_dirty_mask);\n\t\tsmp_call_function_many(vcpu->arch.wbinvd_dirty_mask,\n\t\t\t\twbinvd_ipi, NULL, 1);\n\t\tput_cpu();\n\t\tcpumask_clear(vcpu->arch.wbinvd_dirty_mask);\n\t} else\n\t\twbinvd();\n\treturn X86EMUL_CONTINUE;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "struct kvm_x86_ops *kvm_x86_ops"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nint kvm_emulate_wbinvd_noskip(struct kvm_vcpu *vcpu)\n{\n\tif (!need_emulate_wbinvd(vcpu))\n\t\treturn X86EMUL_CONTINUE;\n\n\tif (kvm_x86_ops->has_wbinvd_exit()) {\n\t\tint cpu = get_cpu();\n\n\t\tcpumask_set_cpu(cpu, vcpu->arch.wbinvd_dirty_mask);\n\t\tsmp_call_function_many(vcpu->arch.wbinvd_dirty_mask,\n\t\t\t\twbinvd_ipi, NULL, 1);\n\t\tput_cpu();\n\t\tcpumask_clear(vcpu->arch.wbinvd_dirty_mask);\n\t} else\n\t\twbinvd();\n\treturn X86EMUL_CONTINUE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "emul_to_vcpu",
          "args": [
            "ctxt"
          ],
          "line": 4753
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);\n\nstatic void emulator_wbinvd(struct x86_emulate_ctxt *ctxt)\n{\n\tkvm_emulate_wbinvd_noskip(emul_to_vcpu(ctxt));\n}"
  },
  {
    "function_name": "kvm_emulate_wbinvd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "4742-4746",
    "snippet": "int kvm_emulate_wbinvd(struct kvm_vcpu *vcpu)\n{\n\tkvm_x86_ops->skip_emulated_instruction(vcpu);\n\treturn kvm_emulate_wbinvd_noskip(vcpu);\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);",
      "struct kvm_x86_ops *kvm_x86_ops"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_emulate_wbinvd_noskip",
          "args": [
            "vcpu"
          ],
          "line": 4745
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_emulate_wbinvd_noskip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "4724-4740",
          "snippet": "int kvm_emulate_wbinvd_noskip(struct kvm_vcpu *vcpu)\n{\n\tif (!need_emulate_wbinvd(vcpu))\n\t\treturn X86EMUL_CONTINUE;\n\n\tif (kvm_x86_ops->has_wbinvd_exit()) {\n\t\tint cpu = get_cpu();\n\n\t\tcpumask_set_cpu(cpu, vcpu->arch.wbinvd_dirty_mask);\n\t\tsmp_call_function_many(vcpu->arch.wbinvd_dirty_mask,\n\t\t\t\twbinvd_ipi, NULL, 1);\n\t\tput_cpu();\n\t\tcpumask_clear(vcpu->arch.wbinvd_dirty_mask);\n\t} else\n\t\twbinvd();\n\treturn X86EMUL_CONTINUE;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "struct kvm_x86_ops *kvm_x86_ops"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nint kvm_emulate_wbinvd_noskip(struct kvm_vcpu *vcpu)\n{\n\tif (!need_emulate_wbinvd(vcpu))\n\t\treturn X86EMUL_CONTINUE;\n\n\tif (kvm_x86_ops->has_wbinvd_exit()) {\n\t\tint cpu = get_cpu();\n\n\t\tcpumask_set_cpu(cpu, vcpu->arch.wbinvd_dirty_mask);\n\t\tsmp_call_function_many(vcpu->arch.wbinvd_dirty_mask,\n\t\t\t\twbinvd_ipi, NULL, 1);\n\t\tput_cpu();\n\t\tcpumask_clear(vcpu->arch.wbinvd_dirty_mask);\n\t} else\n\t\twbinvd();\n\treturn X86EMUL_CONTINUE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_x86_ops->skip_emulated_instruction",
          "args": [
            "vcpu"
          ],
          "line": 4744
        },
        "resolved": true,
        "details": {
          "function_name": "skip_emulated_instruction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/vmx.c",
          "lines": "2329-2339",
          "snippet": "static void skip_emulated_instruction(struct kvm_vcpu *vcpu)\n{\n\tunsigned long rip;\n\n\trip = kvm_rip_read(vcpu);\n\trip += vmcs_read32(VM_EXIT_INSTRUCTION_LEN);\n\tkvm_rip_write(vcpu, rip);\n\n\t/* skipping an emulated instruction also counts */\n\tvmx_set_interrupt_shadow(vcpu, 0);\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"trace.h\"",
            "#include <asm/irq_remapping.h>",
            "#include <asm/apic.h>",
            "#include <asm/kexec.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/mce.h>",
            "#include <asm/virtext.h>",
            "#include <asm/vmx.h>",
            "#include <asm/desc.h>",
            "#include <asm/io.h>",
            "#include <asm/cpu.h>",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/hrtimer.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include \"lapic.h\"",
            "#include \"cpuid.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long nested_ept_get_cr3(struct kvm_vcpu *vcpu);",
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);",
            "static void ept_save_pdptrs(struct kvm_vcpu *vcpu);",
            "static void vmx_decache_cr0_guest_bits(struct kvm_vcpu *vcpu);",
            "static void vmx_leave_nested(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"trace.h\"\n#include <asm/irq_remapping.h>\n#include <asm/apic.h>\n#include <asm/kexec.h>\n#include <asm/debugreg.h>\n#include <asm/perf_event.h>\n#include <asm/fpu/internal.h>\n#include <asm/mce.h>\n#include <asm/virtext.h>\n#include <asm/vmx.h>\n#include <asm/desc.h>\n#include <asm/io.h>\n#include <asm/cpu.h>\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/hrtimer.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic unsigned long nested_ept_get_cr3(struct kvm_vcpu *vcpu);\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\nstatic void ept_save_pdptrs(struct kvm_vcpu *vcpu);\nstatic void vmx_decache_cr0_guest_bits(struct kvm_vcpu *vcpu);\nstatic void vmx_leave_nested(struct kvm_vcpu *vcpu);\n\nstatic void skip_emulated_instruction(struct kvm_vcpu *vcpu)\n{\n\tunsigned long rip;\n\n\trip = kvm_rip_read(vcpu);\n\trip += vmcs_read32(VM_EXIT_INSTRUCTION_LEN);\n\tkvm_rip_write(vcpu, rip);\n\n\t/* skipping an emulated instruction also counts */\n\tvmx_set_interrupt_shadow(vcpu, 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nint kvm_emulate_wbinvd(struct kvm_vcpu *vcpu)\n{\n\tkvm_x86_ops->skip_emulated_instruction(vcpu);\n\treturn kvm_emulate_wbinvd_noskip(vcpu);\n}"
  },
  {
    "function_name": "kvm_emulate_wbinvd_noskip",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "4724-4740",
    "snippet": "int kvm_emulate_wbinvd_noskip(struct kvm_vcpu *vcpu)\n{\n\tif (!need_emulate_wbinvd(vcpu))\n\t\treturn X86EMUL_CONTINUE;\n\n\tif (kvm_x86_ops->has_wbinvd_exit()) {\n\t\tint cpu = get_cpu();\n\n\t\tcpumask_set_cpu(cpu, vcpu->arch.wbinvd_dirty_mask);\n\t\tsmp_call_function_many(vcpu->arch.wbinvd_dirty_mask,\n\t\t\t\twbinvd_ipi, NULL, 1);\n\t\tput_cpu();\n\t\tcpumask_clear(vcpu->arch.wbinvd_dirty_mask);\n\t} else\n\t\twbinvd();\n\treturn X86EMUL_CONTINUE;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);",
      "struct kvm_x86_ops *kvm_x86_ops"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wbinvd",
          "args": [],
          "line": 4738
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_has_vmx_wbinvd_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/vmx.c",
          "lines": "1169-1173",
          "snippet": "static inline bool cpu_has_vmx_wbinvd_exit(void)\n{\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl &\n\t\tSECONDARY_EXEC_WBINVD_EXITING;\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"trace.h\"",
            "#include <asm/irq_remapping.h>",
            "#include <asm/apic.h>",
            "#include <asm/kexec.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/mce.h>",
            "#include <asm/virtext.h>",
            "#include <asm/vmx.h>",
            "#include <asm/desc.h>",
            "#include <asm/io.h>",
            "#include <asm/cpu.h>",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/hrtimer.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include \"lapic.h\"",
            "#include \"cpuid.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct vmcs_config {\n\tint size;\n\tint order;\n\tu32 revision_id;\n\tu32 pin_based_exec_ctrl;\n\tu32 cpu_based_exec_ctrl;\n\tu32 cpu_based_2nd_exec_ctrl;\n\tu32 vmexit_ctrl;\n\tu32 vmentry_ctrl;\n} vmcs_config;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"trace.h\"\n#include <asm/irq_remapping.h>\n#include <asm/apic.h>\n#include <asm/kexec.h>\n#include <asm/debugreg.h>\n#include <asm/perf_event.h>\n#include <asm/fpu/internal.h>\n#include <asm/mce.h>\n#include <asm/virtext.h>\n#include <asm/vmx.h>\n#include <asm/desc.h>\n#include <asm/io.h>\n#include <asm/cpu.h>\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/hrtimer.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic struct vmcs_config {\n\tint size;\n\tint order;\n\tu32 revision_id;\n\tu32 pin_based_exec_ctrl;\n\tu32 cpu_based_exec_ctrl;\n\tu32 cpu_based_2nd_exec_ctrl;\n\tu32 vmexit_ctrl;\n\tu32 vmentry_ctrl;\n} vmcs_config;\n\nstatic inline bool cpu_has_vmx_wbinvd_exit(void)\n{\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl &\n\t\tSECONDARY_EXEC_WBINVD_EXITING;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_clear",
          "args": [
            "vcpu->arch.wbinvd_dirty_mask"
          ],
          "line": 4736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_cpu",
          "args": [],
          "line": 4735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_call_function_many",
          "args": [
            "vcpu->arch.wbinvd_dirty_mask",
            "wbinvd_ipi",
            "NULL",
            "1"
          ],
          "line": 4733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_set_cpu",
          "args": [
            "cpu",
            "vcpu->arch.wbinvd_dirty_mask"
          ],
          "line": 4732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_cpu",
          "args": [],
          "line": 4730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_x86_ops->has_wbinvd_exit",
          "args": [],
          "line": 4729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "need_emulate_wbinvd",
          "args": [
            "vcpu"
          ],
          "line": 4726
        },
        "resolved": true,
        "details": {
          "function_name": "need_emulate_wbinvd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "2706-2709",
          "snippet": "static bool need_emulate_wbinvd(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_arch_has_noncoherent_dma(vcpu->kvm);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic bool need_emulate_wbinvd(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_arch_has_noncoherent_dma(vcpu->kvm);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nint kvm_emulate_wbinvd_noskip(struct kvm_vcpu *vcpu)\n{\n\tif (!need_emulate_wbinvd(vcpu))\n\t\treturn X86EMUL_CONTINUE;\n\n\tif (kvm_x86_ops->has_wbinvd_exit()) {\n\t\tint cpu = get_cpu();\n\n\t\tcpumask_set_cpu(cpu, vcpu->arch.wbinvd_dirty_mask);\n\t\tsmp_call_function_many(vcpu->arch.wbinvd_dirty_mask,\n\t\t\t\twbinvd_ipi, NULL, 1);\n\t\tput_cpu();\n\t\tcpumask_clear(vcpu->arch.wbinvd_dirty_mask);\n\t} else\n\t\twbinvd();\n\treturn X86EMUL_CONTINUE;\n}"
  },
  {
    "function_name": "emulator_invlpg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "4719-4722",
    "snippet": "static void emulator_invlpg(struct x86_emulate_ctxt *ctxt, ulong address)\n{\n\tkvm_mmu_invlpg(emul_to_vcpu(ctxt), address);\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_mmu_invlpg",
          "args": [
            "emul_to_vcpu(ctxt)",
            "address"
          ],
          "line": 4721
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_invlpg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "4548-4553",
          "snippet": "void kvm_mmu_invlpg(struct kvm_vcpu *vcpu, gva_t gva)\n{\n\tvcpu->arch.mmu.invlpg(vcpu, gva);\n\tkvm_make_request(KVM_REQ_TLB_FLUSH, vcpu);\n\t++vcpu->stat.invlpg;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nvoid kvm_mmu_invlpg(struct kvm_vcpu *vcpu, gva_t gva)\n{\n\tvcpu->arch.mmu.invlpg(vcpu, gva);\n\tkvm_make_request(KVM_REQ_TLB_FLUSH, vcpu);\n\t++vcpu->stat.invlpg;\n}"
        }
      },
      {
        "call_info": {
          "callee": "emul_to_vcpu",
          "args": [
            "ctxt"
          ],
          "line": 4721
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);\n\nstatic void emulator_invlpg(struct x86_emulate_ctxt *ctxt, ulong address)\n{\n\tkvm_mmu_invlpg(emul_to_vcpu(ctxt), address);\n}"
  },
  {
    "function_name": "get_segment_base",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "4714-4717",
    "snippet": "static unsigned long get_segment_base(struct kvm_vcpu *vcpu, int seg)\n{\n\treturn kvm_x86_ops->get_segment_base(vcpu, seg);\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);",
      "struct kvm_x86_ops *kvm_x86_ops"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_x86_ops->get_segment_base",
          "args": [
            "vcpu",
            "seg"
          ],
          "line": 4716
        },
        "resolved": true,
        "details": {
          "function_name": "get_segment_base",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "4714-4717",
          "snippet": "static unsigned long get_segment_base(struct kvm_vcpu *vcpu, int seg)\n{\n\treturn kvm_x86_ops->get_segment_base(vcpu, seg);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nstatic unsigned long get_segment_base(struct kvm_vcpu *vcpu, int seg)\n{\n\treturn kvm_x86_ops->get_segment_base(vcpu, seg);\n}"
  },
  {
    "function_name": "emulator_pio_out_emulated",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "4703-4712",
    "snippet": "static int emulator_pio_out_emulated(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t     int size, unsigned short port,\n\t\t\t\t     const void *val, unsigned int count)\n{\n\tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n\n\tmemcpy(vcpu->arch.pio_data, val, size * count);\n\ttrace_kvm_pio(KVM_PIO_OUT, port, size, count, vcpu->arch.pio_data);\n\treturn emulator_pio_in_out(vcpu, size, port, (void *)val, count, false);\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);",
      "static int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "emulator_pio_in_out",
          "args": [
            "vcpu",
            "size",
            "port",
            "(void *)val",
            "count",
            "false"
          ],
          "line": 4711
        },
        "resolved": true,
        "details": {
          "function_name": "emulator_pio_in_out",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "4657-4679",
          "snippet": "static int emulator_pio_in_out(struct kvm_vcpu *vcpu, int size,\n\t\t\t       unsigned short port, void *val,\n\t\t\t       unsigned int count, bool in)\n{\n\tvcpu->arch.pio.port = port;\n\tvcpu->arch.pio.in = in;\n\tvcpu->arch.pio.count  = count;\n\tvcpu->arch.pio.size = size;\n\n\tif (!kernel_pio(vcpu, vcpu->arch.pio_data)) {\n\t\tvcpu->arch.pio.count = 0;\n\t\treturn 1;\n\t}\n\n\tvcpu->run->exit_reason = KVM_EXIT_IO;\n\tvcpu->run->io.direction = in ? KVM_EXIT_IO_IN : KVM_EXIT_IO_OUT;\n\tvcpu->run->io.size = size;\n\tvcpu->run->io.data_offset = KVM_PIO_PAGE_OFFSET * PAGE_SIZE;\n\tvcpu->run->io.count = count;\n\tvcpu->run->io.port = port;\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic int emulator_pio_in_out(struct kvm_vcpu *vcpu, int size,\n\t\t\t       unsigned short port, void *val,\n\t\t\t       unsigned int count, bool in)\n{\n\tvcpu->arch.pio.port = port;\n\tvcpu->arch.pio.in = in;\n\tvcpu->arch.pio.count  = count;\n\tvcpu->arch.pio.size = size;\n\n\tif (!kernel_pio(vcpu, vcpu->arch.pio_data)) {\n\t\tvcpu->arch.pio.count = 0;\n\t\treturn 1;\n\t}\n\n\tvcpu->run->exit_reason = KVM_EXIT_IO;\n\tvcpu->run->io.direction = in ? KVM_EXIT_IO_IN : KVM_EXIT_IO_OUT;\n\tvcpu->run->io.size = size;\n\tvcpu->run->io.data_offset = KVM_PIO_PAGE_OFFSET * PAGE_SIZE;\n\tvcpu->run->io.count = count;\n\tvcpu->run->io.port = port;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_kvm_pio",
          "args": [
            "KVM_PIO_OUT",
            "port",
            "size",
            "count",
            "vcpu->arch.pio_data"
          ],
          "line": 4710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "vcpu->arch.pio_data",
            "val",
            "size * count"
          ],
          "line": 4709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "emul_to_vcpu",
          "args": [
            "ctxt"
          ],
          "line": 4707
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);\n\nstatic int emulator_pio_out_emulated(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t     int size, unsigned short port,\n\t\t\t\t     const void *val, unsigned int count)\n{\n\tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n\n\tmemcpy(vcpu->arch.pio_data, val, size * count);\n\ttrace_kvm_pio(KVM_PIO_OUT, port, size, count, vcpu->arch.pio_data);\n\treturn emulator_pio_in_out(vcpu, size, port, (void *)val, count, false);\n}"
  },
  {
    "function_name": "emulator_pio_in_emulated",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "4681-4701",
    "snippet": "static int emulator_pio_in_emulated(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t    int size, unsigned short port, void *val,\n\t\t\t\t    unsigned int count)\n{\n\tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n\tint ret;\n\n\tif (vcpu->arch.pio.count)\n\t\tgoto data_avail;\n\n\tret = emulator_pio_in_out(vcpu, size, port, val, count, true);\n\tif (ret) {\ndata_avail:\n\t\tmemcpy(val, vcpu->arch.pio_data, size * count);\n\t\ttrace_kvm_pio(KVM_PIO_IN, port, size, count, vcpu->arch.pio_data);\n\t\tvcpu->arch.pio.count = 0;\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);",
      "static int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_kvm_pio",
          "args": [
            "KVM_PIO_IN",
            "port",
            "size",
            "count",
            "vcpu->arch.pio_data"
          ],
          "line": 4695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "val",
            "vcpu->arch.pio_data",
            "size * count"
          ],
          "line": 4694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "emulator_pio_in_out",
          "args": [
            "vcpu",
            "size",
            "port",
            "val",
            "count",
            "true"
          ],
          "line": 4691
        },
        "resolved": true,
        "details": {
          "function_name": "emulator_pio_in_out",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "4657-4679",
          "snippet": "static int emulator_pio_in_out(struct kvm_vcpu *vcpu, int size,\n\t\t\t       unsigned short port, void *val,\n\t\t\t       unsigned int count, bool in)\n{\n\tvcpu->arch.pio.port = port;\n\tvcpu->arch.pio.in = in;\n\tvcpu->arch.pio.count  = count;\n\tvcpu->arch.pio.size = size;\n\n\tif (!kernel_pio(vcpu, vcpu->arch.pio_data)) {\n\t\tvcpu->arch.pio.count = 0;\n\t\treturn 1;\n\t}\n\n\tvcpu->run->exit_reason = KVM_EXIT_IO;\n\tvcpu->run->io.direction = in ? KVM_EXIT_IO_IN : KVM_EXIT_IO_OUT;\n\tvcpu->run->io.size = size;\n\tvcpu->run->io.data_offset = KVM_PIO_PAGE_OFFSET * PAGE_SIZE;\n\tvcpu->run->io.count = count;\n\tvcpu->run->io.port = port;\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic int emulator_pio_in_out(struct kvm_vcpu *vcpu, int size,\n\t\t\t       unsigned short port, void *val,\n\t\t\t       unsigned int count, bool in)\n{\n\tvcpu->arch.pio.port = port;\n\tvcpu->arch.pio.in = in;\n\tvcpu->arch.pio.count  = count;\n\tvcpu->arch.pio.size = size;\n\n\tif (!kernel_pio(vcpu, vcpu->arch.pio_data)) {\n\t\tvcpu->arch.pio.count = 0;\n\t\treturn 1;\n\t}\n\n\tvcpu->run->exit_reason = KVM_EXIT_IO;\n\tvcpu->run->io.direction = in ? KVM_EXIT_IO_IN : KVM_EXIT_IO_OUT;\n\tvcpu->run->io.size = size;\n\tvcpu->run->io.data_offset = KVM_PIO_PAGE_OFFSET * PAGE_SIZE;\n\tvcpu->run->io.count = count;\n\tvcpu->run->io.port = port;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "emul_to_vcpu",
          "args": [
            "ctxt"
          ],
          "line": 4685
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);\n\nstatic int emulator_pio_in_emulated(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t    int size, unsigned short port, void *val,\n\t\t\t\t    unsigned int count)\n{\n\tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n\tint ret;\n\n\tif (vcpu->arch.pio.count)\n\t\tgoto data_avail;\n\n\tret = emulator_pio_in_out(vcpu, size, port, val, count, true);\n\tif (ret) {\ndata_avail:\n\t\tmemcpy(val, vcpu->arch.pio_data, size * count);\n\t\ttrace_kvm_pio(KVM_PIO_IN, port, size, count, vcpu->arch.pio_data);\n\t\tvcpu->arch.pio.count = 0;\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "emulator_pio_in_out",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "4657-4679",
    "snippet": "static int emulator_pio_in_out(struct kvm_vcpu *vcpu, int size,\n\t\t\t       unsigned short port, void *val,\n\t\t\t       unsigned int count, bool in)\n{\n\tvcpu->arch.pio.port = port;\n\tvcpu->arch.pio.in = in;\n\tvcpu->arch.pio.count  = count;\n\tvcpu->arch.pio.size = size;\n\n\tif (!kernel_pio(vcpu, vcpu->arch.pio_data)) {\n\t\tvcpu->arch.pio.count = 0;\n\t\treturn 1;\n\t}\n\n\tvcpu->run->exit_reason = KVM_EXIT_IO;\n\tvcpu->run->io.direction = in ? KVM_EXIT_IO_IN : KVM_EXIT_IO_OUT;\n\tvcpu->run->io.size = size;\n\tvcpu->run->io.data_offset = KVM_PIO_PAGE_OFFSET * PAGE_SIZE;\n\tvcpu->run->io.count = count;\n\tvcpu->run->io.port = port;\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kernel_pio",
          "args": [
            "vcpu",
            "vcpu->arch.pio_data"
          ],
          "line": 4666
        },
        "resolved": true,
        "details": {
          "function_name": "kernel_pio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "4642-4655",
          "snippet": "static int kernel_pio(struct kvm_vcpu *vcpu, void *pd)\n{\n\t/* TODO: String I/O for in kernel device */\n\tint r;\n\n\tif (vcpu->arch.pio.in)\n\t\tr = kvm_io_bus_read(vcpu, KVM_PIO_BUS, vcpu->arch.pio.port,\n\t\t\t\t    vcpu->arch.pio.size, pd);\n\telse\n\t\tr = kvm_io_bus_write(vcpu, KVM_PIO_BUS,\n\t\t\t\t     vcpu->arch.pio.port, vcpu->arch.pio.size,\n\t\t\t\t     pd);\n\treturn r;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic int kernel_pio(struct kvm_vcpu *vcpu, void *pd)\n{\n\t/* TODO: String I/O for in kernel device */\n\tint r;\n\n\tif (vcpu->arch.pio.in)\n\t\tr = kvm_io_bus_read(vcpu, KVM_PIO_BUS, vcpu->arch.pio.port,\n\t\t\t\t    vcpu->arch.pio.size, pd);\n\telse\n\t\tr = kvm_io_bus_write(vcpu, KVM_PIO_BUS,\n\t\t\t\t     vcpu->arch.pio.port, vcpu->arch.pio.size,\n\t\t\t\t     pd);\n\treturn r;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic int emulator_pio_in_out(struct kvm_vcpu *vcpu, int size,\n\t\t\t       unsigned short port, void *val,\n\t\t\t       unsigned int count, bool in)\n{\n\tvcpu->arch.pio.port = port;\n\tvcpu->arch.pio.in = in;\n\tvcpu->arch.pio.count  = count;\n\tvcpu->arch.pio.size = size;\n\n\tif (!kernel_pio(vcpu, vcpu->arch.pio_data)) {\n\t\tvcpu->arch.pio.count = 0;\n\t\treturn 1;\n\t}\n\n\tvcpu->run->exit_reason = KVM_EXIT_IO;\n\tvcpu->run->io.direction = in ? KVM_EXIT_IO_IN : KVM_EXIT_IO_OUT;\n\tvcpu->run->io.size = size;\n\tvcpu->run->io.data_offset = KVM_PIO_PAGE_OFFSET * PAGE_SIZE;\n\tvcpu->run->io.count = count;\n\tvcpu->run->io.port = port;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "kernel_pio",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "4642-4655",
    "snippet": "static int kernel_pio(struct kvm_vcpu *vcpu, void *pd)\n{\n\t/* TODO: String I/O for in kernel device */\n\tint r;\n\n\tif (vcpu->arch.pio.in)\n\t\tr = kvm_io_bus_read(vcpu, KVM_PIO_BUS, vcpu->arch.pio.port,\n\t\t\t\t    vcpu->arch.pio.size, pd);\n\telse\n\t\tr = kvm_io_bus_write(vcpu, KVM_PIO_BUS,\n\t\t\t\t     vcpu->arch.pio.port, vcpu->arch.pio.size,\n\t\t\t\t     pd);\n\treturn r;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_io_bus_write",
          "args": [
            "vcpu",
            "KVM_PIO_BUS",
            "vcpu->arch.pio.port",
            "vcpu->arch.pio.size",
            "pd"
          ],
          "line": 4651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_io_bus_read",
          "args": [
            "vcpu",
            "KVM_PIO_BUS",
            "vcpu->arch.pio.port",
            "vcpu->arch.pio.size",
            "pd"
          ],
          "line": 4648
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic int kernel_pio(struct kvm_vcpu *vcpu, void *pd)\n{\n\t/* TODO: String I/O for in kernel device */\n\tint r;\n\n\tif (vcpu->arch.pio.in)\n\t\tr = kvm_io_bus_read(vcpu, KVM_PIO_BUS, vcpu->arch.pio.port,\n\t\t\t\t    vcpu->arch.pio.size, pd);\n\telse\n\t\tr = kvm_io_bus_write(vcpu, KVM_PIO_BUS,\n\t\t\t\t     vcpu->arch.pio.port, vcpu->arch.pio.size,\n\t\t\t\t     pd);\n\treturn r;\n}"
  },
  {
    "function_name": "emulator_cmpxchg_emulated",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "4577-4640",
    "snippet": "static int emulator_cmpxchg_emulated(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t     unsigned long addr,\n\t\t\t\t     const void *old,\n\t\t\t\t     const void *new,\n\t\t\t\t     unsigned int bytes,\n\t\t\t\t     struct x86_exception *exception)\n{\n\tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n\tgpa_t gpa;\n\tstruct page *page;\n\tchar *kaddr;\n\tbool exchanged;\n\n\t/* guests cmpxchg8b have to be emulated atomically */\n\tif (bytes > 8 || (bytes & (bytes - 1)))\n\t\tgoto emul_write;\n\n\tgpa = kvm_mmu_gva_to_gpa_write(vcpu, addr, NULL);\n\n\tif (gpa == UNMAPPED_GVA ||\n\t    (gpa & PAGE_MASK) == APIC_DEFAULT_PHYS_BASE)\n\t\tgoto emul_write;\n\n\tif (((gpa + bytes - 1) & PAGE_MASK) != (gpa & PAGE_MASK))\n\t\tgoto emul_write;\n\n\tpage = kvm_vcpu_gfn_to_page(vcpu, gpa >> PAGE_SHIFT);\n\tif (is_error_page(page))\n\t\tgoto emul_write;\n\n\tkaddr = kmap_atomic(page);\n\tkaddr += offset_in_page(gpa);\n\tswitch (bytes) {\n\tcase 1:\n\t\texchanged = CMPXCHG_TYPE(u8, kaddr, old, new);\n\t\tbreak;\n\tcase 2:\n\t\texchanged = CMPXCHG_TYPE(u16, kaddr, old, new);\n\t\tbreak;\n\tcase 4:\n\t\texchanged = CMPXCHG_TYPE(u32, kaddr, old, new);\n\t\tbreak;\n\tcase 8:\n\t\texchanged = CMPXCHG64(kaddr, old, new);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\tkunmap_atomic(kaddr);\n\tkvm_release_page_dirty(page);\n\n\tif (!exchanged)\n\t\treturn X86EMUL_CMPXCHG_FAILED;\n\n\tkvm_vcpu_mark_page_dirty(vcpu, gpa >> PAGE_SHIFT);\n\tkvm_page_track_write(vcpu, gpa, new, bytes);\n\n\treturn X86EMUL_CONTINUE;\n\nemul_write:\n\tprintk_once(KERN_WARNING \"kvm: emulating exchange as write\\n\");\n\n\treturn emulator_write_emulated(ctxt, addr, new, bytes, exception);\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);",
      "static int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "emulator_write_emulated",
          "args": [
            "ctxt",
            "addr",
            "new",
            "bytes",
            "exception"
          ],
          "line": 4639
        },
        "resolved": true,
        "details": {
          "function_name": "emulator_write_emulated",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "4557-4565",
          "snippet": "static int emulator_write_emulated(struct x86_emulate_ctxt *ctxt,\n\t\t\t    unsigned long addr,\n\t\t\t    const void *val,\n\t\t\t    unsigned int bytes,\n\t\t\t    struct x86_exception *exception)\n{\n\treturn emulator_read_write(ctxt, addr, (void *)val, bytes,\n\t\t\t\t   exception, &write_emultor);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);\n\nstatic int emulator_write_emulated(struct x86_emulate_ctxt *ctxt,\n\t\t\t    unsigned long addr,\n\t\t\t    const void *val,\n\t\t\t    unsigned int bytes,\n\t\t\t    struct x86_exception *exception)\n{\n\treturn emulator_read_write(ctxt, addr, (void *)val, bytes,\n\t\t\t\t   exception, &write_emultor);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk_once",
          "args": [
            "KERN_WARNING \"kvm: emulating exchange as write\\n\""
          ],
          "line": 4637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_page_track_write",
          "args": [
            "vcpu",
            "gpa",
            "new",
            "bytes"
          ],
          "line": 4632
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_page_track_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/page_track.c",
          "lines": "210-227",
          "snippet": "void kvm_page_track_write(struct kvm_vcpu *vcpu, gpa_t gpa, const u8 *new,\n\t\t\t  int bytes)\n{\n\tstruct kvm_page_track_notifier_head *head;\n\tstruct kvm_page_track_notifier_node *n;\n\tint idx;\n\n\thead = &vcpu->kvm->arch.track_notifier_head;\n\n\tif (hlist_empty(&head->track_notifier_list))\n\t\treturn;\n\n\tidx = srcu_read_lock(&head->track_srcu);\n\thlist_for_each_entry_rcu(n, &head->track_notifier_list, node)\n\t\tif (n->track_write)\n\t\t\tn->track_write(vcpu, gpa, new, bytes);\n\tsrcu_read_unlock(&head->track_srcu, idx);\n}",
          "includes": [
            "#include \"mmu.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mmu.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/kvm_host.h>\n#include <linux/kvm_host.h>\n\nvoid kvm_page_track_write(struct kvm_vcpu *vcpu, gpa_t gpa, const u8 *new,\n\t\t\t  int bytes)\n{\n\tstruct kvm_page_track_notifier_head *head;\n\tstruct kvm_page_track_notifier_node *n;\n\tint idx;\n\n\thead = &vcpu->kvm->arch.track_notifier_head;\n\n\tif (hlist_empty(&head->track_notifier_list))\n\t\treturn;\n\n\tidx = srcu_read_lock(&head->track_srcu);\n\thlist_for_each_entry_rcu(n, &head->track_notifier_list, node)\n\t\tif (n->track_write)\n\t\t\tn->track_write(vcpu, gpa, new, bytes);\n\tsrcu_read_unlock(&head->track_srcu, idx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_mark_page_dirty",
          "args": [
            "vcpu",
            "gpa >> PAGE_SHIFT"
          ],
          "line": 4631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_release_page_dirty",
          "args": [
            "page"
          ],
          "line": 4626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "kaddr"
          ],
          "line": 4625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 4623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CMPXCHG64",
          "args": [
            "kaddr",
            "old",
            "new"
          ],
          "line": 4620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CMPXCHG_TYPE",
          "args": [
            "u32",
            "kaddr",
            "old",
            "new"
          ],
          "line": 4617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CMPXCHG_TYPE",
          "args": [
            "u16",
            "kaddr",
            "old",
            "new"
          ],
          "line": 4614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CMPXCHG_TYPE",
          "args": [
            "u8",
            "kaddr",
            "old",
            "new"
          ],
          "line": 4611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "offset_in_page",
          "args": [
            "gpa"
          ],
          "line": 4608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "page"
          ],
          "line": 4607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_error_page",
          "args": [
            "page"
          ],
          "line": 4604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_gfn_to_page",
          "args": [
            "vcpu",
            "gpa >> PAGE_SHIFT"
          ],
          "line": 4603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_mmu_gva_to_gpa_write",
          "args": [
            "vcpu",
            "addr",
            "NULL"
          ],
          "line": 4594
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_gva_to_gpa_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "4192-4198",
          "snippet": "gpa_t kvm_mmu_gva_to_gpa_write(struct kvm_vcpu *vcpu, gva_t gva,\n\t\t\t       struct x86_exception *exception)\n{\n\tu32 access = (kvm_x86_ops->get_cpl(vcpu) == 3) ? PFERR_USER_MASK : 0;\n\taccess |= PFERR_WRITE_MASK;\n\treturn vcpu->arch.walk_mmu->gva_to_gpa(vcpu, gva, access, exception);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "struct kvm_x86_ops *kvm_x86_ops"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\ngpa_t kvm_mmu_gva_to_gpa_write(struct kvm_vcpu *vcpu, gva_t gva,\n\t\t\t       struct x86_exception *exception)\n{\n\tu32 access = (kvm_x86_ops->get_cpl(vcpu) == 3) ? PFERR_USER_MASK : 0;\n\taccess |= PFERR_WRITE_MASK;\n\treturn vcpu->arch.walk_mmu->gva_to_gpa(vcpu, gva, access, exception);\n}"
        }
      },
      {
        "call_info": {
          "callee": "emul_to_vcpu",
          "args": [
            "ctxt"
          ],
          "line": 4584
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);\n\nstatic int emulator_cmpxchg_emulated(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t     unsigned long addr,\n\t\t\t\t     const void *old,\n\t\t\t\t     const void *new,\n\t\t\t\t     unsigned int bytes,\n\t\t\t\t     struct x86_exception *exception)\n{\n\tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n\tgpa_t gpa;\n\tstruct page *page;\n\tchar *kaddr;\n\tbool exchanged;\n\n\t/* guests cmpxchg8b have to be emulated atomically */\n\tif (bytes > 8 || (bytes & (bytes - 1)))\n\t\tgoto emul_write;\n\n\tgpa = kvm_mmu_gva_to_gpa_write(vcpu, addr, NULL);\n\n\tif (gpa == UNMAPPED_GVA ||\n\t    (gpa & PAGE_MASK) == APIC_DEFAULT_PHYS_BASE)\n\t\tgoto emul_write;\n\n\tif (((gpa + bytes - 1) & PAGE_MASK) != (gpa & PAGE_MASK))\n\t\tgoto emul_write;\n\n\tpage = kvm_vcpu_gfn_to_page(vcpu, gpa >> PAGE_SHIFT);\n\tif (is_error_page(page))\n\t\tgoto emul_write;\n\n\tkaddr = kmap_atomic(page);\n\tkaddr += offset_in_page(gpa);\n\tswitch (bytes) {\n\tcase 1:\n\t\texchanged = CMPXCHG_TYPE(u8, kaddr, old, new);\n\t\tbreak;\n\tcase 2:\n\t\texchanged = CMPXCHG_TYPE(u16, kaddr, old, new);\n\t\tbreak;\n\tcase 4:\n\t\texchanged = CMPXCHG_TYPE(u32, kaddr, old, new);\n\t\tbreak;\n\tcase 8:\n\t\texchanged = CMPXCHG64(kaddr, old, new);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\tkunmap_atomic(kaddr);\n\tkvm_release_page_dirty(page);\n\n\tif (!exchanged)\n\t\treturn X86EMUL_CMPXCHG_FAILED;\n\n\tkvm_vcpu_mark_page_dirty(vcpu, gpa >> PAGE_SHIFT);\n\tkvm_page_track_write(vcpu, gpa, new, bytes);\n\n\treturn X86EMUL_CONTINUE;\n\nemul_write:\n\tprintk_once(KERN_WARNING \"kvm: emulating exchange as write\\n\");\n\n\treturn emulator_write_emulated(ctxt, addr, new, bytes, exception);\n}"
  },
  {
    "function_name": "emulator_write_emulated",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "4557-4565",
    "snippet": "static int emulator_write_emulated(struct x86_emulate_ctxt *ctxt,\n\t\t\t    unsigned long addr,\n\t\t\t    const void *val,\n\t\t\t    unsigned int bytes,\n\t\t\t    struct x86_exception *exception)\n{\n\treturn emulator_read_write(ctxt, addr, (void *)val, bytes,\n\t\t\t\t   exception, &write_emultor);\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "emulator_read_write",
          "args": [
            "ctxt",
            "addr",
            "(void *)val",
            "bytes",
            "exception",
            "&write_emultor"
          ],
          "line": 4563
        },
        "resolved": true,
        "details": {
          "function_name": "emulator_read_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "4493-4545",
          "snippet": "static int emulator_read_write(struct x86_emulate_ctxt *ctxt,\n\t\t\tunsigned long addr,\n\t\t\tvoid *val, unsigned int bytes,\n\t\t\tstruct x86_exception *exception,\n\t\t\tconst struct read_write_emulator_ops *ops)\n{\n\tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n\tgpa_t gpa;\n\tint rc;\n\n\tif (ops->read_write_prepare &&\n\t\t  ops->read_write_prepare(vcpu, val, bytes))\n\t\treturn X86EMUL_CONTINUE;\n\n\tvcpu->mmio_nr_fragments = 0;\n\n\t/* Crossing a page boundary? */\n\tif (((addr + bytes - 1) ^ addr) & PAGE_MASK) {\n\t\tint now;\n\n\t\tnow = -addr & ~PAGE_MASK;\n\t\trc = emulator_read_write_onepage(addr, val, now, exception,\n\t\t\t\t\t\t vcpu, ops);\n\n\t\tif (rc != X86EMUL_CONTINUE)\n\t\t\treturn rc;\n\t\taddr += now;\n\t\tif (ctxt->mode != X86EMUL_MODE_PROT64)\n\t\t\taddr = (u32)addr;\n\t\tval += now;\n\t\tbytes -= now;\n\t}\n\n\trc = emulator_read_write_onepage(addr, val, bytes, exception,\n\t\t\t\t\t vcpu, ops);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\tif (!vcpu->mmio_nr_fragments)\n\t\treturn rc;\n\n\tgpa = vcpu->mmio_fragments[0].gpa;\n\n\tvcpu->mmio_needed = 1;\n\tvcpu->mmio_cur_fragment = 0;\n\n\tvcpu->run->mmio.len = min(8u, vcpu->mmio_fragments[0].len);\n\tvcpu->run->mmio.is_write = vcpu->mmio_is_write = ops->write;\n\tvcpu->run->exit_reason = KVM_EXIT_MMIO;\n\tvcpu->run->mmio.phys_addr = gpa;\n\n\treturn ops->read_write_exit_mmio(vcpu, gpa, val, bytes);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);\n\nstatic int emulator_read_write(struct x86_emulate_ctxt *ctxt,\n\t\t\tunsigned long addr,\n\t\t\tvoid *val, unsigned int bytes,\n\t\t\tstruct x86_exception *exception,\n\t\t\tconst struct read_write_emulator_ops *ops)\n{\n\tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n\tgpa_t gpa;\n\tint rc;\n\n\tif (ops->read_write_prepare &&\n\t\t  ops->read_write_prepare(vcpu, val, bytes))\n\t\treturn X86EMUL_CONTINUE;\n\n\tvcpu->mmio_nr_fragments = 0;\n\n\t/* Crossing a page boundary? */\n\tif (((addr + bytes - 1) ^ addr) & PAGE_MASK) {\n\t\tint now;\n\n\t\tnow = -addr & ~PAGE_MASK;\n\t\trc = emulator_read_write_onepage(addr, val, now, exception,\n\t\t\t\t\t\t vcpu, ops);\n\n\t\tif (rc != X86EMUL_CONTINUE)\n\t\t\treturn rc;\n\t\taddr += now;\n\t\tif (ctxt->mode != X86EMUL_MODE_PROT64)\n\t\t\taddr = (u32)addr;\n\t\tval += now;\n\t\tbytes -= now;\n\t}\n\n\trc = emulator_read_write_onepage(addr, val, bytes, exception,\n\t\t\t\t\t vcpu, ops);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\tif (!vcpu->mmio_nr_fragments)\n\t\treturn rc;\n\n\tgpa = vcpu->mmio_fragments[0].gpa;\n\n\tvcpu->mmio_needed = 1;\n\tvcpu->mmio_cur_fragment = 0;\n\n\tvcpu->run->mmio.len = min(8u, vcpu->mmio_fragments[0].len);\n\tvcpu->run->mmio.is_write = vcpu->mmio_is_write = ops->write;\n\tvcpu->run->exit_reason = KVM_EXIT_MMIO;\n\tvcpu->run->mmio.phys_addr = gpa;\n\n\treturn ops->read_write_exit_mmio(vcpu, gpa, val, bytes);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);\n\nstatic int emulator_write_emulated(struct x86_emulate_ctxt *ctxt,\n\t\t\t    unsigned long addr,\n\t\t\t    const void *val,\n\t\t\t    unsigned int bytes,\n\t\t\t    struct x86_exception *exception)\n{\n\treturn emulator_read_write(ctxt, addr, (void *)val, bytes,\n\t\t\t\t   exception, &write_emultor);\n}"
  },
  {
    "function_name": "emulator_read_emulated",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "4547-4555",
    "snippet": "static int emulator_read_emulated(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t  unsigned long addr,\n\t\t\t\t  void *val,\n\t\t\t\t  unsigned int bytes,\n\t\t\t\t  struct x86_exception *exception)\n{\n\treturn emulator_read_write(ctxt, addr, val, bytes,\n\t\t\t\t   exception, &read_emultor);\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "emulator_read_write",
          "args": [
            "ctxt",
            "addr",
            "val",
            "bytes",
            "exception",
            "&read_emultor"
          ],
          "line": 4553
        },
        "resolved": true,
        "details": {
          "function_name": "emulator_read_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "4493-4545",
          "snippet": "static int emulator_read_write(struct x86_emulate_ctxt *ctxt,\n\t\t\tunsigned long addr,\n\t\t\tvoid *val, unsigned int bytes,\n\t\t\tstruct x86_exception *exception,\n\t\t\tconst struct read_write_emulator_ops *ops)\n{\n\tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n\tgpa_t gpa;\n\tint rc;\n\n\tif (ops->read_write_prepare &&\n\t\t  ops->read_write_prepare(vcpu, val, bytes))\n\t\treturn X86EMUL_CONTINUE;\n\n\tvcpu->mmio_nr_fragments = 0;\n\n\t/* Crossing a page boundary? */\n\tif (((addr + bytes - 1) ^ addr) & PAGE_MASK) {\n\t\tint now;\n\n\t\tnow = -addr & ~PAGE_MASK;\n\t\trc = emulator_read_write_onepage(addr, val, now, exception,\n\t\t\t\t\t\t vcpu, ops);\n\n\t\tif (rc != X86EMUL_CONTINUE)\n\t\t\treturn rc;\n\t\taddr += now;\n\t\tif (ctxt->mode != X86EMUL_MODE_PROT64)\n\t\t\taddr = (u32)addr;\n\t\tval += now;\n\t\tbytes -= now;\n\t}\n\n\trc = emulator_read_write_onepage(addr, val, bytes, exception,\n\t\t\t\t\t vcpu, ops);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\tif (!vcpu->mmio_nr_fragments)\n\t\treturn rc;\n\n\tgpa = vcpu->mmio_fragments[0].gpa;\n\n\tvcpu->mmio_needed = 1;\n\tvcpu->mmio_cur_fragment = 0;\n\n\tvcpu->run->mmio.len = min(8u, vcpu->mmio_fragments[0].len);\n\tvcpu->run->mmio.is_write = vcpu->mmio_is_write = ops->write;\n\tvcpu->run->exit_reason = KVM_EXIT_MMIO;\n\tvcpu->run->mmio.phys_addr = gpa;\n\n\treturn ops->read_write_exit_mmio(vcpu, gpa, val, bytes);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);\n\nstatic int emulator_read_write(struct x86_emulate_ctxt *ctxt,\n\t\t\tunsigned long addr,\n\t\t\tvoid *val, unsigned int bytes,\n\t\t\tstruct x86_exception *exception,\n\t\t\tconst struct read_write_emulator_ops *ops)\n{\n\tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n\tgpa_t gpa;\n\tint rc;\n\n\tif (ops->read_write_prepare &&\n\t\t  ops->read_write_prepare(vcpu, val, bytes))\n\t\treturn X86EMUL_CONTINUE;\n\n\tvcpu->mmio_nr_fragments = 0;\n\n\t/* Crossing a page boundary? */\n\tif (((addr + bytes - 1) ^ addr) & PAGE_MASK) {\n\t\tint now;\n\n\t\tnow = -addr & ~PAGE_MASK;\n\t\trc = emulator_read_write_onepage(addr, val, now, exception,\n\t\t\t\t\t\t vcpu, ops);\n\n\t\tif (rc != X86EMUL_CONTINUE)\n\t\t\treturn rc;\n\t\taddr += now;\n\t\tif (ctxt->mode != X86EMUL_MODE_PROT64)\n\t\t\taddr = (u32)addr;\n\t\tval += now;\n\t\tbytes -= now;\n\t}\n\n\trc = emulator_read_write_onepage(addr, val, bytes, exception,\n\t\t\t\t\t vcpu, ops);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\tif (!vcpu->mmio_nr_fragments)\n\t\treturn rc;\n\n\tgpa = vcpu->mmio_fragments[0].gpa;\n\n\tvcpu->mmio_needed = 1;\n\tvcpu->mmio_cur_fragment = 0;\n\n\tvcpu->run->mmio.len = min(8u, vcpu->mmio_fragments[0].len);\n\tvcpu->run->mmio.is_write = vcpu->mmio_is_write = ops->write;\n\tvcpu->run->exit_reason = KVM_EXIT_MMIO;\n\tvcpu->run->mmio.phys_addr = gpa;\n\n\treturn ops->read_write_exit_mmio(vcpu, gpa, val, bytes);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);\n\nstatic int emulator_read_emulated(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t  unsigned long addr,\n\t\t\t\t  void *val,\n\t\t\t\t  unsigned int bytes,\n\t\t\t\t  struct x86_exception *exception)\n{\n\treturn emulator_read_write(ctxt, addr, val, bytes,\n\t\t\t\t   exception, &read_emultor);\n}"
  },
  {
    "function_name": "emulator_read_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "4493-4545",
    "snippet": "static int emulator_read_write(struct x86_emulate_ctxt *ctxt,\n\t\t\tunsigned long addr,\n\t\t\tvoid *val, unsigned int bytes,\n\t\t\tstruct x86_exception *exception,\n\t\t\tconst struct read_write_emulator_ops *ops)\n{\n\tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n\tgpa_t gpa;\n\tint rc;\n\n\tif (ops->read_write_prepare &&\n\t\t  ops->read_write_prepare(vcpu, val, bytes))\n\t\treturn X86EMUL_CONTINUE;\n\n\tvcpu->mmio_nr_fragments = 0;\n\n\t/* Crossing a page boundary? */\n\tif (((addr + bytes - 1) ^ addr) & PAGE_MASK) {\n\t\tint now;\n\n\t\tnow = -addr & ~PAGE_MASK;\n\t\trc = emulator_read_write_onepage(addr, val, now, exception,\n\t\t\t\t\t\t vcpu, ops);\n\n\t\tif (rc != X86EMUL_CONTINUE)\n\t\t\treturn rc;\n\t\taddr += now;\n\t\tif (ctxt->mode != X86EMUL_MODE_PROT64)\n\t\t\taddr = (u32)addr;\n\t\tval += now;\n\t\tbytes -= now;\n\t}\n\n\trc = emulator_read_write_onepage(addr, val, bytes, exception,\n\t\t\t\t\t vcpu, ops);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\tif (!vcpu->mmio_nr_fragments)\n\t\treturn rc;\n\n\tgpa = vcpu->mmio_fragments[0].gpa;\n\n\tvcpu->mmio_needed = 1;\n\tvcpu->mmio_cur_fragment = 0;\n\n\tvcpu->run->mmio.len = min(8u, vcpu->mmio_fragments[0].len);\n\tvcpu->run->mmio.is_write = vcpu->mmio_is_write = ops->write;\n\tvcpu->run->exit_reason = KVM_EXIT_MMIO;\n\tvcpu->run->mmio.phys_addr = gpa;\n\n\treturn ops->read_write_exit_mmio(vcpu, gpa, val, bytes);\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);",
      "static int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ops->read_write_exit_mmio",
          "args": [
            "vcpu",
            "gpa",
            "val",
            "bytes"
          ],
          "line": 4544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "8u",
            "vcpu->mmio_fragments[0].len"
          ],
          "line": 4539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "emulator_read_write_onepage",
          "args": [
            "addr",
            "val",
            "bytes",
            "exception",
            "vcpu",
            "ops"
          ],
          "line": 4526
        },
        "resolved": true,
        "details": {
          "function_name": "emulator_read_write_onepage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "4450-4491",
          "snippet": "static int emulator_read_write_onepage(unsigned long addr, void *val,\n\t\t\t\t       unsigned int bytes,\n\t\t\t\t       struct x86_exception *exception,\n\t\t\t\t       struct kvm_vcpu *vcpu,\n\t\t\t\t       const struct read_write_emulator_ops *ops)\n{\n\tgpa_t gpa;\n\tint handled, ret;\n\tbool write = ops->write;\n\tstruct kvm_mmio_fragment *frag;\n\n\tret = vcpu_mmio_gva_to_gpa(vcpu, addr, &gpa, exception, write);\n\n\tif (ret < 0)\n\t\treturn X86EMUL_PROPAGATE_FAULT;\n\n\t/* For APIC access vmexit */\n\tif (ret)\n\t\tgoto mmio;\n\n\tif (ops->read_write_emulate(vcpu, gpa, val, bytes))\n\t\treturn X86EMUL_CONTINUE;\n\nmmio:\n\t/*\n\t * Is this MMIO handled locally?\n\t */\n\thandled = ops->read_write_mmio(vcpu, gpa, bytes, val);\n\tif (handled == bytes)\n\t\treturn X86EMUL_CONTINUE;\n\n\tgpa += handled;\n\tbytes -= handled;\n\tval += handled;\n\n\tWARN_ON(vcpu->mmio_nr_fragments >= KVM_MAX_MMIO_FRAGMENTS);\n\tfrag = &vcpu->mmio_fragments[vcpu->mmio_nr_fragments++];\n\tfrag->gpa = gpa;\n\tfrag->data = val;\n\tfrag->len = bytes;\n\treturn X86EMUL_CONTINUE;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic int emulator_read_write_onepage(unsigned long addr, void *val,\n\t\t\t\t       unsigned int bytes,\n\t\t\t\t       struct x86_exception *exception,\n\t\t\t\t       struct kvm_vcpu *vcpu,\n\t\t\t\t       const struct read_write_emulator_ops *ops)\n{\n\tgpa_t gpa;\n\tint handled, ret;\n\tbool write = ops->write;\n\tstruct kvm_mmio_fragment *frag;\n\n\tret = vcpu_mmio_gva_to_gpa(vcpu, addr, &gpa, exception, write);\n\n\tif (ret < 0)\n\t\treturn X86EMUL_PROPAGATE_FAULT;\n\n\t/* For APIC access vmexit */\n\tif (ret)\n\t\tgoto mmio;\n\n\tif (ops->read_write_emulate(vcpu, gpa, val, bytes))\n\t\treturn X86EMUL_CONTINUE;\n\nmmio:\n\t/*\n\t * Is this MMIO handled locally?\n\t */\n\thandled = ops->read_write_mmio(vcpu, gpa, bytes, val);\n\tif (handled == bytes)\n\t\treturn X86EMUL_CONTINUE;\n\n\tgpa += handled;\n\tbytes -= handled;\n\tval += handled;\n\n\tWARN_ON(vcpu->mmio_nr_fragments >= KVM_MAX_MMIO_FRAGMENTS);\n\tfrag = &vcpu->mmio_fragments[vcpu->mmio_nr_fragments++];\n\tfrag->gpa = gpa;\n\tfrag->data = val;\n\tfrag->len = bytes;\n\treturn X86EMUL_CONTINUE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ops->read_write_prepare",
          "args": [
            "vcpu",
            "val",
            "bytes"
          ],
          "line": 4504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "emul_to_vcpu",
          "args": [
            "ctxt"
          ],
          "line": 4499
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);\n\nstatic int emulator_read_write(struct x86_emulate_ctxt *ctxt,\n\t\t\tunsigned long addr,\n\t\t\tvoid *val, unsigned int bytes,\n\t\t\tstruct x86_exception *exception,\n\t\t\tconst struct read_write_emulator_ops *ops)\n{\n\tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n\tgpa_t gpa;\n\tint rc;\n\n\tif (ops->read_write_prepare &&\n\t\t  ops->read_write_prepare(vcpu, val, bytes))\n\t\treturn X86EMUL_CONTINUE;\n\n\tvcpu->mmio_nr_fragments = 0;\n\n\t/* Crossing a page boundary? */\n\tif (((addr + bytes - 1) ^ addr) & PAGE_MASK) {\n\t\tint now;\n\n\t\tnow = -addr & ~PAGE_MASK;\n\t\trc = emulator_read_write_onepage(addr, val, now, exception,\n\t\t\t\t\t\t vcpu, ops);\n\n\t\tif (rc != X86EMUL_CONTINUE)\n\t\t\treturn rc;\n\t\taddr += now;\n\t\tif (ctxt->mode != X86EMUL_MODE_PROT64)\n\t\t\taddr = (u32)addr;\n\t\tval += now;\n\t\tbytes -= now;\n\t}\n\n\trc = emulator_read_write_onepage(addr, val, bytes, exception,\n\t\t\t\t\t vcpu, ops);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\tif (!vcpu->mmio_nr_fragments)\n\t\treturn rc;\n\n\tgpa = vcpu->mmio_fragments[0].gpa;\n\n\tvcpu->mmio_needed = 1;\n\tvcpu->mmio_cur_fragment = 0;\n\n\tvcpu->run->mmio.len = min(8u, vcpu->mmio_fragments[0].len);\n\tvcpu->run->mmio.is_write = vcpu->mmio_is_write = ops->write;\n\tvcpu->run->exit_reason = KVM_EXIT_MMIO;\n\tvcpu->run->mmio.phys_addr = gpa;\n\n\treturn ops->read_write_exit_mmio(vcpu, gpa, val, bytes);\n}"
  },
  {
    "function_name": "emulator_read_write_onepage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "4450-4491",
    "snippet": "static int emulator_read_write_onepage(unsigned long addr, void *val,\n\t\t\t\t       unsigned int bytes,\n\t\t\t\t       struct x86_exception *exception,\n\t\t\t\t       struct kvm_vcpu *vcpu,\n\t\t\t\t       const struct read_write_emulator_ops *ops)\n{\n\tgpa_t gpa;\n\tint handled, ret;\n\tbool write = ops->write;\n\tstruct kvm_mmio_fragment *frag;\n\n\tret = vcpu_mmio_gva_to_gpa(vcpu, addr, &gpa, exception, write);\n\n\tif (ret < 0)\n\t\treturn X86EMUL_PROPAGATE_FAULT;\n\n\t/* For APIC access vmexit */\n\tif (ret)\n\t\tgoto mmio;\n\n\tif (ops->read_write_emulate(vcpu, gpa, val, bytes))\n\t\treturn X86EMUL_CONTINUE;\n\nmmio:\n\t/*\n\t * Is this MMIO handled locally?\n\t */\n\thandled = ops->read_write_mmio(vcpu, gpa, bytes, val);\n\tif (handled == bytes)\n\t\treturn X86EMUL_CONTINUE;\n\n\tgpa += handled;\n\tbytes -= handled;\n\tval += handled;\n\n\tWARN_ON(vcpu->mmio_nr_fragments >= KVM_MAX_MMIO_FRAGMENTS);\n\tfrag = &vcpu->mmio_fragments[vcpu->mmio_nr_fragments++];\n\tfrag->gpa = gpa;\n\tfrag->data = val;\n\tfrag->len = bytes;\n\treturn X86EMUL_CONTINUE;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "vcpu->mmio_nr_fragments >= KVM_MAX_MMIO_FRAGMENTS"
          ],
          "line": 4485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ops->read_write_mmio",
          "args": [
            "vcpu",
            "gpa",
            "bytes",
            "val"
          ],
          "line": 4477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ops->read_write_emulate",
          "args": [
            "vcpu",
            "gpa",
            "val",
            "bytes"
          ],
          "line": 4470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vcpu_mmio_gva_to_gpa",
          "args": [
            "vcpu",
            "addr",
            "&gpa",
            "exception",
            "write"
          ],
          "line": 4461
        },
        "resolved": true,
        "details": {
          "function_name": "vcpu_mmio_gva_to_gpa",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "4328-4364",
          "snippet": "static int vcpu_mmio_gva_to_gpa(struct kvm_vcpu *vcpu, unsigned long gva,\n\t\t\t\tgpa_t *gpa, struct x86_exception *exception,\n\t\t\t\tbool write)\n{\n\tu32 access = ((kvm_x86_ops->get_cpl(vcpu) == 3) ? PFERR_USER_MASK : 0)\n\t\t| (write ? PFERR_WRITE_MASK : 0);\n\n\t/*\n\t * currently PKRU is only applied to ept enabled guest so\n\t * there is no pkey in EPT page table for L1 guest or EPT\n\t * shadow page table for L2 guest.\n\t */\n\tif (vcpu_match_mmio_gva(vcpu, gva)\n\t    && !permission_fault(vcpu, vcpu->arch.walk_mmu,\n\t\t\t\t vcpu->arch.access, 0, access)) {\n\t\t*gpa = vcpu->arch.mmio_gfn << PAGE_SHIFT |\n\t\t\t\t\t(gva & (PAGE_SIZE - 1));\n\t\ttrace_vcpu_match_mmio(gva, *gpa, write, false);\n\t\treturn 1;\n\t}\n\n\t*gpa = vcpu->arch.walk_mmu->gva_to_gpa(vcpu, gva, access, exception);\n\n\tif (*gpa == UNMAPPED_GVA)\n\t\treturn -1;\n\n\t/* For APIC access vmexit */\n\tif ((*gpa & PAGE_MASK) == APIC_DEFAULT_PHYS_BASE)\n\t\treturn 1;\n\n\tif (vcpu_match_mmio_gpa(vcpu, *gpa)) {\n\t\ttrace_vcpu_match_mmio(gva, *gpa, write, true);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "struct kvm_x86_ops *kvm_x86_ops"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nstatic int vcpu_mmio_gva_to_gpa(struct kvm_vcpu *vcpu, unsigned long gva,\n\t\t\t\tgpa_t *gpa, struct x86_exception *exception,\n\t\t\t\tbool write)\n{\n\tu32 access = ((kvm_x86_ops->get_cpl(vcpu) == 3) ? PFERR_USER_MASK : 0)\n\t\t| (write ? PFERR_WRITE_MASK : 0);\n\n\t/*\n\t * currently PKRU is only applied to ept enabled guest so\n\t * there is no pkey in EPT page table for L1 guest or EPT\n\t * shadow page table for L2 guest.\n\t */\n\tif (vcpu_match_mmio_gva(vcpu, gva)\n\t    && !permission_fault(vcpu, vcpu->arch.walk_mmu,\n\t\t\t\t vcpu->arch.access, 0, access)) {\n\t\t*gpa = vcpu->arch.mmio_gfn << PAGE_SHIFT |\n\t\t\t\t\t(gva & (PAGE_SIZE - 1));\n\t\ttrace_vcpu_match_mmio(gva, *gpa, write, false);\n\t\treturn 1;\n\t}\n\n\t*gpa = vcpu->arch.walk_mmu->gva_to_gpa(vcpu, gva, access, exception);\n\n\tif (*gpa == UNMAPPED_GVA)\n\t\treturn -1;\n\n\t/* For APIC access vmexit */\n\tif ((*gpa & PAGE_MASK) == APIC_DEFAULT_PHYS_BASE)\n\t\treturn 1;\n\n\tif (vcpu_match_mmio_gpa(vcpu, *gpa)) {\n\t\ttrace_vcpu_match_mmio(gva, *gpa, write, true);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic int emulator_read_write_onepage(unsigned long addr, void *val,\n\t\t\t\t       unsigned int bytes,\n\t\t\t\t       struct x86_exception *exception,\n\t\t\t\t       struct kvm_vcpu *vcpu,\n\t\t\t\t       const struct read_write_emulator_ops *ops)\n{\n\tgpa_t gpa;\n\tint handled, ret;\n\tbool write = ops->write;\n\tstruct kvm_mmio_fragment *frag;\n\n\tret = vcpu_mmio_gva_to_gpa(vcpu, addr, &gpa, exception, write);\n\n\tif (ret < 0)\n\t\treturn X86EMUL_PROPAGATE_FAULT;\n\n\t/* For APIC access vmexit */\n\tif (ret)\n\t\tgoto mmio;\n\n\tif (ops->read_write_emulate(vcpu, gpa, val, bytes))\n\t\treturn X86EMUL_CONTINUE;\n\nmmio:\n\t/*\n\t * Is this MMIO handled locally?\n\t */\n\thandled = ops->read_write_mmio(vcpu, gpa, bytes, val);\n\tif (handled == bytes)\n\t\treturn X86EMUL_CONTINUE;\n\n\tgpa += handled;\n\tbytes -= handled;\n\tval += handled;\n\n\tWARN_ON(vcpu->mmio_nr_fragments >= KVM_MAX_MMIO_FRAGMENTS);\n\tfrag = &vcpu->mmio_fragments[vcpu->mmio_nr_fragments++];\n\tfrag->gpa = gpa;\n\tfrag->data = val;\n\tfrag->len = bytes;\n\treturn X86EMUL_CONTINUE;\n}"
  },
  {
    "function_name": "write_exit_mmio",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "4427-4434",
    "snippet": "static int write_exit_mmio(struct kvm_vcpu *vcpu, gpa_t gpa,\n\t\t\t   void *val, int bytes)\n{\n\tstruct kvm_mmio_fragment *frag = &vcpu->mmio_fragments[0];\n\n\tmemcpy(vcpu->run->mmio.data, frag->data, min(8u, frag->len));\n\treturn X86EMUL_CONTINUE;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "vcpu->run->mmio.data",
            "frag->data",
            "min(8u, frag->len)"
          ],
          "line": 4432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "8u",
            "frag->len"
          ],
          "line": 4432
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic int write_exit_mmio(struct kvm_vcpu *vcpu, gpa_t gpa,\n\t\t\t   void *val, int bytes)\n{\n\tstruct kvm_mmio_fragment *frag = &vcpu->mmio_fragments[0];\n\n\tmemcpy(vcpu->run->mmio.data, frag->data, min(8u, frag->len));\n\treturn X86EMUL_CONTINUE;\n}"
  },
  {
    "function_name": "read_exit_mmio",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "4420-4425",
    "snippet": "static int read_exit_mmio(struct kvm_vcpu *vcpu, gpa_t gpa,\n\t\t\t  void *val, int bytes)\n{\n\ttrace_kvm_mmio(KVM_TRACE_MMIO_READ_UNSATISFIED, bytes, gpa, 0);\n\treturn X86EMUL_IO_NEEDED;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_kvm_mmio",
          "args": [
            "KVM_TRACE_MMIO_READ_UNSATISFIED",
            "bytes",
            "gpa",
            "0"
          ],
          "line": 4423
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic int read_exit_mmio(struct kvm_vcpu *vcpu, gpa_t gpa,\n\t\t\t  void *val, int bytes)\n{\n\ttrace_kvm_mmio(KVM_TRACE_MMIO_READ_UNSATISFIED, bytes, gpa, 0);\n\treturn X86EMUL_IO_NEEDED;\n}"
  },
  {
    "function_name": "write_mmio",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "4414-4418",
    "snippet": "static int write_mmio(struct kvm_vcpu *vcpu, gpa_t gpa, int bytes, void *val)\n{\n\ttrace_kvm_mmio(KVM_TRACE_MMIO_WRITE, bytes, gpa, *(u64 *)val);\n\treturn vcpu_mmio_write(vcpu, gpa, bytes, val);\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vcpu_mmio_write",
          "args": [
            "vcpu",
            "gpa",
            "bytes",
            "val"
          ],
          "line": 4417
        },
        "resolved": true,
        "details": {
          "function_name": "vcpu_mmio_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "4108-4127",
          "snippet": "static int vcpu_mmio_write(struct kvm_vcpu *vcpu, gpa_t addr, int len,\n\t\t\t   const void *v)\n{\n\tint handled = 0;\n\tint n;\n\n\tdo {\n\t\tn = min(len, 8);\n\t\tif (!(lapic_in_kernel(vcpu) &&\n\t\t      !kvm_iodevice_write(vcpu, &vcpu->arch.apic->dev, addr, n, v))\n\t\t    && kvm_io_bus_write(vcpu, KVM_MMIO_BUS, addr, n, v))\n\t\t\tbreak;\n\t\thandled += n;\n\t\taddr += n;\n\t\tlen -= n;\n\t\tv += n;\n\t} while (len);\n\n\treturn handled;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic int vcpu_mmio_write(struct kvm_vcpu *vcpu, gpa_t addr, int len,\n\t\t\t   const void *v)\n{\n\tint handled = 0;\n\tint n;\n\n\tdo {\n\t\tn = min(len, 8);\n\t\tif (!(lapic_in_kernel(vcpu) &&\n\t\t      !kvm_iodevice_write(vcpu, &vcpu->arch.apic->dev, addr, n, v))\n\t\t    && kvm_io_bus_write(vcpu, KVM_MMIO_BUS, addr, n, v))\n\t\t\tbreak;\n\t\thandled += n;\n\t\taddr += n;\n\t\tlen -= n;\n\t\tv += n;\n\t} while (len);\n\n\treturn handled;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_kvm_mmio",
          "args": [
            "KVM_TRACE_MMIO_WRITE",
            "bytes",
            "gpa",
            "*(u64 *)val"
          ],
          "line": 4416
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic int write_mmio(struct kvm_vcpu *vcpu, gpa_t gpa, int bytes, void *val)\n{\n\ttrace_kvm_mmio(KVM_TRACE_MMIO_WRITE, bytes, gpa, *(u64 *)val);\n\treturn vcpu_mmio_write(vcpu, gpa, bytes, val);\n}"
  },
  {
    "function_name": "write_emulate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "4408-4412",
    "snippet": "static int write_emulate(struct kvm_vcpu *vcpu, gpa_t gpa,\n\t\t\t void *val, int bytes)\n{\n\treturn emulator_write_phys(vcpu, gpa, val, bytes);\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "emulator_write_phys",
          "args": [
            "vcpu",
            "gpa",
            "val",
            "bytes"
          ],
          "line": 4411
        },
        "resolved": true,
        "details": {
          "function_name": "emulator_write_phys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "4366-4376",
          "snippet": "int emulator_write_phys(struct kvm_vcpu *vcpu, gpa_t gpa,\n\t\t\tconst void *val, int bytes)\n{\n\tint ret;\n\n\tret = kvm_vcpu_write_guest(vcpu, gpa, val, bytes);\n\tif (ret < 0)\n\t\treturn 0;\n\tkvm_page_track_write(vcpu, gpa, val, bytes);\n\treturn 1;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nint emulator_write_phys(struct kvm_vcpu *vcpu, gpa_t gpa,\n\t\t\tconst void *val, int bytes)\n{\n\tint ret;\n\n\tret = kvm_vcpu_write_guest(vcpu, gpa, val, bytes);\n\tif (ret < 0)\n\t\treturn 0;\n\tkvm_page_track_write(vcpu, gpa, val, bytes);\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic int write_emulate(struct kvm_vcpu *vcpu, gpa_t gpa,\n\t\t\t void *val, int bytes)\n{\n\treturn emulator_write_phys(vcpu, gpa, val, bytes);\n}"
  },
  {
    "function_name": "read_emulate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "4402-4406",
    "snippet": "static int read_emulate(struct kvm_vcpu *vcpu, gpa_t gpa,\n\t\t\tvoid *val, int bytes)\n{\n\treturn !kvm_vcpu_read_guest(vcpu, gpa, val, bytes);\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_vcpu_read_guest",
          "args": [
            "vcpu",
            "gpa",
            "val",
            "bytes"
          ],
          "line": 4405
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic int read_emulate(struct kvm_vcpu *vcpu, gpa_t gpa,\n\t\t\tvoid *val, int bytes)\n{\n\treturn !kvm_vcpu_read_guest(vcpu, gpa, val, bytes);\n}"
  },
  {
    "function_name": "read_prepare",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "4390-4400",
    "snippet": "static int read_prepare(struct kvm_vcpu *vcpu, void *val, int bytes)\n{\n\tif (vcpu->mmio_read_completed) {\n\t\ttrace_kvm_mmio(KVM_TRACE_MMIO_READ, bytes,\n\t\t\t       vcpu->mmio_fragments[0].gpa, *(u64 *)val);\n\t\tvcpu->mmio_read_completed = 0;\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_kvm_mmio",
          "args": [
            "KVM_TRACE_MMIO_READ",
            "bytes",
            "vcpu->mmio_fragments[0].gpa",
            "*(u64 *)val"
          ],
          "line": 4393
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic int read_prepare(struct kvm_vcpu *vcpu, void *val, int bytes)\n{\n\tif (vcpu->mmio_read_completed) {\n\t\ttrace_kvm_mmio(KVM_TRACE_MMIO_READ, bytes,\n\t\t\t       vcpu->mmio_fragments[0].gpa, *(u64 *)val);\n\t\tvcpu->mmio_read_completed = 0;\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "emulator_write_phys",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "4366-4376",
    "snippet": "int emulator_write_phys(struct kvm_vcpu *vcpu, gpa_t gpa,\n\t\t\tconst void *val, int bytes)\n{\n\tint ret;\n\n\tret = kvm_vcpu_write_guest(vcpu, gpa, val, bytes);\n\tif (ret < 0)\n\t\treturn 0;\n\tkvm_page_track_write(vcpu, gpa, val, bytes);\n\treturn 1;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_page_track_write",
          "args": [
            "vcpu",
            "gpa",
            "val",
            "bytes"
          ],
          "line": 4374
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_page_track_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/page_track.c",
          "lines": "210-227",
          "snippet": "void kvm_page_track_write(struct kvm_vcpu *vcpu, gpa_t gpa, const u8 *new,\n\t\t\t  int bytes)\n{\n\tstruct kvm_page_track_notifier_head *head;\n\tstruct kvm_page_track_notifier_node *n;\n\tint idx;\n\n\thead = &vcpu->kvm->arch.track_notifier_head;\n\n\tif (hlist_empty(&head->track_notifier_list))\n\t\treturn;\n\n\tidx = srcu_read_lock(&head->track_srcu);\n\thlist_for_each_entry_rcu(n, &head->track_notifier_list, node)\n\t\tif (n->track_write)\n\t\t\tn->track_write(vcpu, gpa, new, bytes);\n\tsrcu_read_unlock(&head->track_srcu, idx);\n}",
          "includes": [
            "#include \"mmu.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mmu.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/kvm_host.h>\n#include <linux/kvm_host.h>\n\nvoid kvm_page_track_write(struct kvm_vcpu *vcpu, gpa_t gpa, const u8 *new,\n\t\t\t  int bytes)\n{\n\tstruct kvm_page_track_notifier_head *head;\n\tstruct kvm_page_track_notifier_node *n;\n\tint idx;\n\n\thead = &vcpu->kvm->arch.track_notifier_head;\n\n\tif (hlist_empty(&head->track_notifier_list))\n\t\treturn;\n\n\tidx = srcu_read_lock(&head->track_srcu);\n\thlist_for_each_entry_rcu(n, &head->track_notifier_list, node)\n\t\tif (n->track_write)\n\t\t\tn->track_write(vcpu, gpa, new, bytes);\n\tsrcu_read_unlock(&head->track_srcu, idx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_write_guest",
          "args": [
            "vcpu",
            "gpa",
            "val",
            "bytes"
          ],
          "line": 4371
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nint emulator_write_phys(struct kvm_vcpu *vcpu, gpa_t gpa,\n\t\t\tconst void *val, int bytes)\n{\n\tint ret;\n\n\tret = kvm_vcpu_write_guest(vcpu, gpa, val, bytes);\n\tif (ret < 0)\n\t\treturn 0;\n\tkvm_page_track_write(vcpu, gpa, val, bytes);\n\treturn 1;\n}"
  },
  {
    "function_name": "vcpu_mmio_gva_to_gpa",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "4328-4364",
    "snippet": "static int vcpu_mmio_gva_to_gpa(struct kvm_vcpu *vcpu, unsigned long gva,\n\t\t\t\tgpa_t *gpa, struct x86_exception *exception,\n\t\t\t\tbool write)\n{\n\tu32 access = ((kvm_x86_ops->get_cpl(vcpu) == 3) ? PFERR_USER_MASK : 0)\n\t\t| (write ? PFERR_WRITE_MASK : 0);\n\n\t/*\n\t * currently PKRU is only applied to ept enabled guest so\n\t * there is no pkey in EPT page table for L1 guest or EPT\n\t * shadow page table for L2 guest.\n\t */\n\tif (vcpu_match_mmio_gva(vcpu, gva)\n\t    && !permission_fault(vcpu, vcpu->arch.walk_mmu,\n\t\t\t\t vcpu->arch.access, 0, access)) {\n\t\t*gpa = vcpu->arch.mmio_gfn << PAGE_SHIFT |\n\t\t\t\t\t(gva & (PAGE_SIZE - 1));\n\t\ttrace_vcpu_match_mmio(gva, *gpa, write, false);\n\t\treturn 1;\n\t}\n\n\t*gpa = vcpu->arch.walk_mmu->gva_to_gpa(vcpu, gva, access, exception);\n\n\tif (*gpa == UNMAPPED_GVA)\n\t\treturn -1;\n\n\t/* For APIC access vmexit */\n\tif ((*gpa & PAGE_MASK) == APIC_DEFAULT_PHYS_BASE)\n\t\treturn 1;\n\n\tif (vcpu_match_mmio_gpa(vcpu, *gpa)) {\n\t\ttrace_vcpu_match_mmio(gva, *gpa, write, true);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);",
      "struct kvm_x86_ops *kvm_x86_ops"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_vcpu_match_mmio",
          "args": [
            "gva",
            "*gpa",
            "write",
            "true"
          ],
          "line": 4359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vcpu_match_mmio_gpa",
          "args": [
            "vcpu",
            "*gpa"
          ],
          "line": 4358
        },
        "resolved": true,
        "details": {
          "function_name": "vcpu_match_mmio_gpa",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.h",
          "lines": "124-131",
          "snippet": "static inline bool vcpu_match_mmio_gpa(struct kvm_vcpu *vcpu, gpa_t gpa)\n{\n\tif (vcpu_match_mmio_gen(vcpu) && vcpu->arch.mmio_gfn &&\n\t      vcpu->arch.mmio_gfn == gpa >> PAGE_SHIFT)\n\t\treturn true;\n\n\treturn false;\n}",
          "includes": [
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline bool vcpu_match_mmio_gpa(struct kvm_vcpu *vcpu, gpa_t gpa)\n{\n\tif (vcpu_match_mmio_gen(vcpu) && vcpu->arch.mmio_gfn &&\n\t      vcpu->arch.mmio_gfn == gpa >> PAGE_SHIFT)\n\t\treturn true;\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vcpu->arch.walk_mmu->gva_to_gpa",
          "args": [
            "vcpu",
            "gva",
            "access",
            "exception"
          ],
          "line": 4349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_vcpu_match_mmio",
          "args": [
            "gva",
            "*gpa",
            "write",
            "false"
          ],
          "line": 4345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "permission_fault",
          "args": [
            "vcpu",
            "vcpu->arch.walk_mmu",
            "vcpu->arch.access",
            "0",
            "access"
          ],
          "line": 4341
        },
        "resolved": true,
        "details": {
          "function_name": "permission_fault",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.h",
          "lines": "152-200",
          "snippet": "static inline u8 permission_fault(struct kvm_vcpu *vcpu, struct kvm_mmu *mmu,\n\t\t\t\t  unsigned pte_access, unsigned pte_pkey,\n\t\t\t\t  unsigned pfec)\n{\n\tint cpl = kvm_x86_ops->get_cpl(vcpu);\n\tunsigned long rflags = kvm_x86_ops->get_rflags(vcpu);\n\n\t/*\n\t * If CPL < 3, SMAP prevention are disabled if EFLAGS.AC = 1.\n\t *\n\t * If CPL = 3, SMAP applies to all supervisor-mode data accesses\n\t * (these are implicit supervisor accesses) regardless of the value\n\t * of EFLAGS.AC.\n\t *\n\t * This computes (cpl < 3) && (rflags & X86_EFLAGS_AC), leaving\n\t * the result in X86_EFLAGS_AC. We then insert it in place of\n\t * the PFERR_RSVD_MASK bit; this bit will always be zero in pfec,\n\t * but it will be one in index if SMAP checks are being overridden.\n\t * It is important to keep this branchless.\n\t */\n\tunsigned long smap = (cpl - 3) & (rflags & X86_EFLAGS_AC);\n\tint index = (pfec >> 1) +\n\t\t    (smap >> (X86_EFLAGS_AC_BIT - PFERR_RSVD_BIT + 1));\n\tbool fault = (mmu->permissions[index] >> pte_access) & 1;\n\tu32 errcode = PFERR_PRESENT_MASK;\n\n\tWARN_ON(pfec & (PFERR_PK_MASK | PFERR_RSVD_MASK));\n\tif (unlikely(mmu->pkru_mask)) {\n\t\tu32 pkru_bits, offset;\n\n\t\t/*\n\t\t* PKRU defines 32 bits, there are 16 domains and 2\n\t\t* attribute bits per domain in pkru.  pte_pkey is the\n\t\t* index of the protection domain, so pte_pkey * 2 is\n\t\t* is the index of the first bit for the domain.\n\t\t*/\n\t\tpkru_bits = (kvm_read_pkru(vcpu) >> (pte_pkey * 2)) & 3;\n\n\t\t/* clear present bit, replace PFEC.RSVD with ACC_USER_MASK. */\n\t\toffset = (pfec & ~1) +\n\t\t\t((pte_access & PT_USER_MASK) << (PFERR_RSVD_BIT - PT_USER_SHIFT));\n\n\t\tpkru_bits &= mmu->pkru_mask >> offset;\n\t\terrcode |= -pkru_bits & PFERR_PK_MASK;\n\t\tfault |= (pkru_bits != 0);\n\t}\n\n\treturn -(u32)fault & errcode;\n}",
          "includes": [
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define PT_USER_MASK (1ULL << PT_USER_SHIFT)",
            "#define PT_USER_SHIFT 2"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\n#define PT_USER_MASK (1ULL << PT_USER_SHIFT)\n#define PT_USER_SHIFT 2\n\nstatic inline u8 permission_fault(struct kvm_vcpu *vcpu, struct kvm_mmu *mmu,\n\t\t\t\t  unsigned pte_access, unsigned pte_pkey,\n\t\t\t\t  unsigned pfec)\n{\n\tint cpl = kvm_x86_ops->get_cpl(vcpu);\n\tunsigned long rflags = kvm_x86_ops->get_rflags(vcpu);\n\n\t/*\n\t * If CPL < 3, SMAP prevention are disabled if EFLAGS.AC = 1.\n\t *\n\t * If CPL = 3, SMAP applies to all supervisor-mode data accesses\n\t * (these are implicit supervisor accesses) regardless of the value\n\t * of EFLAGS.AC.\n\t *\n\t * This computes (cpl < 3) && (rflags & X86_EFLAGS_AC), leaving\n\t * the result in X86_EFLAGS_AC. We then insert it in place of\n\t * the PFERR_RSVD_MASK bit; this bit will always be zero in pfec,\n\t * but it will be one in index if SMAP checks are being overridden.\n\t * It is important to keep this branchless.\n\t */\n\tunsigned long smap = (cpl - 3) & (rflags & X86_EFLAGS_AC);\n\tint index = (pfec >> 1) +\n\t\t    (smap >> (X86_EFLAGS_AC_BIT - PFERR_RSVD_BIT + 1));\n\tbool fault = (mmu->permissions[index] >> pte_access) & 1;\n\tu32 errcode = PFERR_PRESENT_MASK;\n\n\tWARN_ON(pfec & (PFERR_PK_MASK | PFERR_RSVD_MASK));\n\tif (unlikely(mmu->pkru_mask)) {\n\t\tu32 pkru_bits, offset;\n\n\t\t/*\n\t\t* PKRU defines 32 bits, there are 16 domains and 2\n\t\t* attribute bits per domain in pkru.  pte_pkey is the\n\t\t* index of the protection domain, so pte_pkey * 2 is\n\t\t* is the index of the first bit for the domain.\n\t\t*/\n\t\tpkru_bits = (kvm_read_pkru(vcpu) >> (pte_pkey * 2)) & 3;\n\n\t\t/* clear present bit, replace PFEC.RSVD with ACC_USER_MASK. */\n\t\toffset = (pfec & ~1) +\n\t\t\t((pte_access & PT_USER_MASK) << (PFERR_RSVD_BIT - PT_USER_SHIFT));\n\n\t\tpkru_bits &= mmu->pkru_mask >> offset;\n\t\terrcode |= -pkru_bits & PFERR_PK_MASK;\n\t\tfault |= (pkru_bits != 0);\n\t}\n\n\treturn -(u32)fault & errcode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vcpu_match_mmio_gva",
          "args": [
            "vcpu",
            "gva"
          ],
          "line": 4340
        },
        "resolved": true,
        "details": {
          "function_name": "vcpu_match_mmio_gva",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.h",
          "lines": "115-122",
          "snippet": "static inline bool vcpu_match_mmio_gva(struct kvm_vcpu *vcpu, unsigned long gva)\n{\n\tif (vcpu_match_mmio_gen(vcpu) && vcpu->arch.mmio_gva &&\n\t      vcpu->arch.mmio_gva == (gva & PAGE_MASK))\n\t\treturn true;\n\n\treturn false;\n}",
          "includes": [
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline bool vcpu_match_mmio_gva(struct kvm_vcpu *vcpu, unsigned long gva)\n{\n\tif (vcpu_match_mmio_gen(vcpu) && vcpu->arch.mmio_gva &&\n\t      vcpu->arch.mmio_gva == (gva & PAGE_MASK))\n\t\treturn true;\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_x86_ops->get_cpl",
          "args": [
            "vcpu"
          ],
          "line": 4332
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nstatic int vcpu_mmio_gva_to_gpa(struct kvm_vcpu *vcpu, unsigned long gva,\n\t\t\t\tgpa_t *gpa, struct x86_exception *exception,\n\t\t\t\tbool write)\n{\n\tu32 access = ((kvm_x86_ops->get_cpl(vcpu) == 3) ? PFERR_USER_MASK : 0)\n\t\t| (write ? PFERR_WRITE_MASK : 0);\n\n\t/*\n\t * currently PKRU is only applied to ept enabled guest so\n\t * there is no pkey in EPT page table for L1 guest or EPT\n\t * shadow page table for L2 guest.\n\t */\n\tif (vcpu_match_mmio_gva(vcpu, gva)\n\t    && !permission_fault(vcpu, vcpu->arch.walk_mmu,\n\t\t\t\t vcpu->arch.access, 0, access)) {\n\t\t*gpa = vcpu->arch.mmio_gfn << PAGE_SHIFT |\n\t\t\t\t\t(gva & (PAGE_SIZE - 1));\n\t\ttrace_vcpu_match_mmio(gva, *gpa, write, false);\n\t\treturn 1;\n\t}\n\n\t*gpa = vcpu->arch.walk_mmu->gva_to_gpa(vcpu, gva, access, exception);\n\n\tif (*gpa == UNMAPPED_GVA)\n\t\treturn -1;\n\n\t/* For APIC access vmexit */\n\tif ((*gpa & PAGE_MASK) == APIC_DEFAULT_PHYS_BASE)\n\t\treturn 1;\n\n\tif (vcpu_match_mmio_gpa(vcpu, *gpa)) {\n\t\ttrace_vcpu_match_mmio(gva, *gpa, write, true);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "kvm_write_guest_virt_system",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "4294-4325",
    "snippet": "int kvm_write_guest_virt_system(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t       gva_t addr, void *val,\n\t\t\t\t       unsigned int bytes,\n\t\t\t\t       struct x86_exception *exception)\n{\n\tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n\tvoid *data = val;\n\tint r = X86EMUL_CONTINUE;\n\n\twhile (bytes) {\n\t\tgpa_t gpa =  vcpu->arch.walk_mmu->gva_to_gpa(vcpu, addr,\n\t\t\t\t\t\t\t     PFERR_WRITE_MASK,\n\t\t\t\t\t\t\t     exception);\n\t\tunsigned offset = addr & (PAGE_SIZE-1);\n\t\tunsigned towrite = min(bytes, (unsigned)PAGE_SIZE - offset);\n\t\tint ret;\n\n\t\tif (gpa == UNMAPPED_GVA)\n\t\t\treturn X86EMUL_PROPAGATE_FAULT;\n\t\tret = kvm_vcpu_write_guest(vcpu, gpa, data, towrite);\n\t\tif (ret < 0) {\n\t\t\tr = X86EMUL_IO_NEEDED;\n\t\t\tgoto out;\n\t\t}\n\n\t\tbytes -= towrite;\n\t\tdata += towrite;\n\t\taddr += towrite;\n\t}\nout:\n\treturn r;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);",
      "static int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_vcpu_write_guest",
          "args": [
            "vcpu",
            "gpa",
            "data",
            "towrite"
          ],
          "line": 4313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "bytes",
            "(unsigned)PAGE_SIZE - offset"
          ],
          "line": 4308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vcpu->arch.walk_mmu->gva_to_gpa",
          "args": [
            "vcpu",
            "addr",
            "PFERR_WRITE_MASK",
            "exception"
          ],
          "line": 4304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "emul_to_vcpu",
          "args": [
            "ctxt"
          ],
          "line": 4299
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);\n\nint kvm_write_guest_virt_system(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t       gva_t addr, void *val,\n\t\t\t\t       unsigned int bytes,\n\t\t\t\t       struct x86_exception *exception)\n{\n\tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n\tvoid *data = val;\n\tint r = X86EMUL_CONTINUE;\n\n\twhile (bytes) {\n\t\tgpa_t gpa =  vcpu->arch.walk_mmu->gva_to_gpa(vcpu, addr,\n\t\t\t\t\t\t\t     PFERR_WRITE_MASK,\n\t\t\t\t\t\t\t     exception);\n\t\tunsigned offset = addr & (PAGE_SIZE-1);\n\t\tunsigned towrite = min(bytes, (unsigned)PAGE_SIZE - offset);\n\t\tint ret;\n\n\t\tif (gpa == UNMAPPED_GVA)\n\t\t\treturn X86EMUL_PROPAGATE_FAULT;\n\t\tret = kvm_vcpu_write_guest(vcpu, gpa, data, towrite);\n\t\tif (ret < 0) {\n\t\t\tr = X86EMUL_IO_NEEDED;\n\t\t\tgoto out;\n\t\t}\n\n\t\tbytes -= towrite;\n\t\tdata += towrite;\n\t\taddr += towrite;\n\t}\nout:\n\treturn r;\n}"
  },
  {
    "function_name": "kvm_read_guest_phys_system",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "4285-4292",
    "snippet": "static int kvm_read_guest_phys_system(struct x86_emulate_ctxt *ctxt,\n\t\tunsigned long addr, void *val, unsigned int bytes)\n{\n\tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n\tint r = kvm_vcpu_read_guest(vcpu, addr, val, bytes);\n\n\treturn r < 0 ? X86EMUL_IO_NEEDED : X86EMUL_CONTINUE;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);",
      "static int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_vcpu_read_guest",
          "args": [
            "vcpu",
            "addr",
            "val",
            "bytes"
          ],
          "line": 4289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "emul_to_vcpu",
          "args": [
            "ctxt"
          ],
          "line": 4288
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);\n\nstatic int kvm_read_guest_phys_system(struct x86_emulate_ctxt *ctxt,\n\t\tunsigned long addr, void *val, unsigned int bytes)\n{\n\tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n\tint r = kvm_vcpu_read_guest(vcpu, addr, val, bytes);\n\n\treturn r < 0 ? X86EMUL_IO_NEEDED : X86EMUL_CONTINUE;\n}"
  },
  {
    "function_name": "kvm_read_guest_virt_system",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "4277-4283",
    "snippet": "static int kvm_read_guest_virt_system(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t      gva_t addr, void *val, unsigned int bytes,\n\t\t\t\t      struct x86_exception *exception)\n{\n\tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n\treturn kvm_read_guest_virt_helper(addr, val, bytes, vcpu, 0, exception);\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);",
      "static int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_read_guest_virt_helper",
          "args": [
            "addr",
            "val",
            "bytes",
            "vcpu",
            "0",
            "exception"
          ],
          "line": 4282
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_read_guest_virt_helper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "4207-4236",
          "snippet": "static int kvm_read_guest_virt_helper(gva_t addr, void *val, unsigned int bytes,\n\t\t\t\t      struct kvm_vcpu *vcpu, u32 access,\n\t\t\t\t      struct x86_exception *exception)\n{\n\tvoid *data = val;\n\tint r = X86EMUL_CONTINUE;\n\n\twhile (bytes) {\n\t\tgpa_t gpa = vcpu->arch.walk_mmu->gva_to_gpa(vcpu, addr, access,\n\t\t\t\t\t\t\t    exception);\n\t\tunsigned offset = addr & (PAGE_SIZE-1);\n\t\tunsigned toread = min(bytes, (unsigned)PAGE_SIZE - offset);\n\t\tint ret;\n\n\t\tif (gpa == UNMAPPED_GVA)\n\t\t\treturn X86EMUL_PROPAGATE_FAULT;\n\t\tret = kvm_vcpu_read_guest_page(vcpu, gpa >> PAGE_SHIFT, data,\n\t\t\t\t\t       offset, toread);\n\t\tif (ret < 0) {\n\t\t\tr = X86EMUL_IO_NEEDED;\n\t\t\tgoto out;\n\t\t}\n\n\t\tbytes -= toread;\n\t\tdata += toread;\n\t\taddr += toread;\n\t}\nout:\n\treturn r;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic int kvm_read_guest_virt_helper(gva_t addr, void *val, unsigned int bytes,\n\t\t\t\t      struct kvm_vcpu *vcpu, u32 access,\n\t\t\t\t      struct x86_exception *exception)\n{\n\tvoid *data = val;\n\tint r = X86EMUL_CONTINUE;\n\n\twhile (bytes) {\n\t\tgpa_t gpa = vcpu->arch.walk_mmu->gva_to_gpa(vcpu, addr, access,\n\t\t\t\t\t\t\t    exception);\n\t\tunsigned offset = addr & (PAGE_SIZE-1);\n\t\tunsigned toread = min(bytes, (unsigned)PAGE_SIZE - offset);\n\t\tint ret;\n\n\t\tif (gpa == UNMAPPED_GVA)\n\t\t\treturn X86EMUL_PROPAGATE_FAULT;\n\t\tret = kvm_vcpu_read_guest_page(vcpu, gpa >> PAGE_SHIFT, data,\n\t\t\t\t\t       offset, toread);\n\t\tif (ret < 0) {\n\t\t\tr = X86EMUL_IO_NEEDED;\n\t\t\tgoto out;\n\t\t}\n\n\t\tbytes -= toread;\n\t\tdata += toread;\n\t\taddr += toread;\n\t}\nout:\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "emul_to_vcpu",
          "args": [
            "ctxt"
          ],
          "line": 4281
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);\n\nstatic int kvm_read_guest_virt_system(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t      gva_t addr, void *val, unsigned int bytes,\n\t\t\t\t      struct x86_exception *exception)\n{\n\tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n\treturn kvm_read_guest_virt_helper(addr, val, bytes, vcpu, 0, exception);\n}"
  },
  {
    "function_name": "kvm_read_guest_virt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "4265-4274",
    "snippet": "int kvm_read_guest_virt(struct x86_emulate_ctxt *ctxt,\n\t\t\t       gva_t addr, void *val, unsigned int bytes,\n\t\t\t       struct x86_exception *exception)\n{\n\tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n\tu32 access = (kvm_x86_ops->get_cpl(vcpu) == 3) ? PFERR_USER_MASK : 0;\n\n\treturn kvm_read_guest_virt_helper(addr, val, bytes, vcpu, access,\n\t\t\t\t\t  exception);\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);",
      "struct kvm_x86_ops *kvm_x86_ops",
      "static int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_read_guest_virt_helper",
          "args": [
            "addr",
            "val",
            "bytes",
            "vcpu",
            "access",
            "exception"
          ],
          "line": 4272
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_read_guest_virt_helper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "4207-4236",
          "snippet": "static int kvm_read_guest_virt_helper(gva_t addr, void *val, unsigned int bytes,\n\t\t\t\t      struct kvm_vcpu *vcpu, u32 access,\n\t\t\t\t      struct x86_exception *exception)\n{\n\tvoid *data = val;\n\tint r = X86EMUL_CONTINUE;\n\n\twhile (bytes) {\n\t\tgpa_t gpa = vcpu->arch.walk_mmu->gva_to_gpa(vcpu, addr, access,\n\t\t\t\t\t\t\t    exception);\n\t\tunsigned offset = addr & (PAGE_SIZE-1);\n\t\tunsigned toread = min(bytes, (unsigned)PAGE_SIZE - offset);\n\t\tint ret;\n\n\t\tif (gpa == UNMAPPED_GVA)\n\t\t\treturn X86EMUL_PROPAGATE_FAULT;\n\t\tret = kvm_vcpu_read_guest_page(vcpu, gpa >> PAGE_SHIFT, data,\n\t\t\t\t\t       offset, toread);\n\t\tif (ret < 0) {\n\t\t\tr = X86EMUL_IO_NEEDED;\n\t\t\tgoto out;\n\t\t}\n\n\t\tbytes -= toread;\n\t\tdata += toread;\n\t\taddr += toread;\n\t}\nout:\n\treturn r;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic int kvm_read_guest_virt_helper(gva_t addr, void *val, unsigned int bytes,\n\t\t\t\t      struct kvm_vcpu *vcpu, u32 access,\n\t\t\t\t      struct x86_exception *exception)\n{\n\tvoid *data = val;\n\tint r = X86EMUL_CONTINUE;\n\n\twhile (bytes) {\n\t\tgpa_t gpa = vcpu->arch.walk_mmu->gva_to_gpa(vcpu, addr, access,\n\t\t\t\t\t\t\t    exception);\n\t\tunsigned offset = addr & (PAGE_SIZE-1);\n\t\tunsigned toread = min(bytes, (unsigned)PAGE_SIZE - offset);\n\t\tint ret;\n\n\t\tif (gpa == UNMAPPED_GVA)\n\t\t\treturn X86EMUL_PROPAGATE_FAULT;\n\t\tret = kvm_vcpu_read_guest_page(vcpu, gpa >> PAGE_SHIFT, data,\n\t\t\t\t\t       offset, toread);\n\t\tif (ret < 0) {\n\t\t\tr = X86EMUL_IO_NEEDED;\n\t\t\tgoto out;\n\t\t}\n\n\t\tbytes -= toread;\n\t\tdata += toread;\n\t\taddr += toread;\n\t}\nout:\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_x86_ops->get_cpl",
          "args": [
            "vcpu"
          ],
          "line": 4270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "emul_to_vcpu",
          "args": [
            "ctxt"
          ],
          "line": 4269
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\nstatic int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);\n\nint kvm_read_guest_virt(struct x86_emulate_ctxt *ctxt,\n\t\t\t       gva_t addr, void *val, unsigned int bytes,\n\t\t\t       struct x86_exception *exception)\n{\n\tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n\tu32 access = (kvm_x86_ops->get_cpl(vcpu) == 3) ? PFERR_USER_MASK : 0;\n\n\treturn kvm_read_guest_virt_helper(addr, val, bytes, vcpu, access,\n\t\t\t\t\t  exception);\n}"
  },
  {
    "function_name": "kvm_fetch_guest_virt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "4239-4263",
    "snippet": "static int kvm_fetch_guest_virt(struct x86_emulate_ctxt *ctxt,\n\t\t\t\tgva_t addr, void *val, unsigned int bytes,\n\t\t\t\tstruct x86_exception *exception)\n{\n\tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n\tu32 access = (kvm_x86_ops->get_cpl(vcpu) == 3) ? PFERR_USER_MASK : 0;\n\tunsigned offset;\n\tint ret;\n\n\t/* Inline kvm_read_guest_virt_helper for speed.  */\n\tgpa_t gpa = vcpu->arch.walk_mmu->gva_to_gpa(vcpu, addr, access|PFERR_FETCH_MASK,\n\t\t\t\t\t\t    exception);\n\tif (unlikely(gpa == UNMAPPED_GVA))\n\t\treturn X86EMUL_PROPAGATE_FAULT;\n\n\toffset = addr & (PAGE_SIZE-1);\n\tif (WARN_ON(offset + bytes > PAGE_SIZE))\n\t\tbytes = (unsigned)PAGE_SIZE - offset;\n\tret = kvm_vcpu_read_guest_page(vcpu, gpa >> PAGE_SHIFT, val,\n\t\t\t\t       offset, bytes);\n\tif (unlikely(ret < 0))\n\t\treturn X86EMUL_IO_NEEDED;\n\n\treturn X86EMUL_CONTINUE;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);",
      "struct kvm_x86_ops *kvm_x86_ops",
      "static int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret < 0"
          ],
          "line": 4259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_read_guest_page",
          "args": [
            "vcpu",
            "gpa >> PAGE_SHIFT",
            "val",
            "offset",
            "bytes"
          ],
          "line": 4257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "offset + bytes > PAGE_SIZE"
          ],
          "line": 4255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "gpa == UNMAPPED_GVA"
          ],
          "line": 4251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vcpu->arch.walk_mmu->gva_to_gpa",
          "args": [
            "vcpu",
            "addr",
            "access|PFERR_FETCH_MASK",
            "exception"
          ],
          "line": 4249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_x86_ops->get_cpl",
          "args": [
            "vcpu"
          ],
          "line": 4244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "emul_to_vcpu",
          "args": [
            "ctxt"
          ],
          "line": 4243
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\nstatic int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);\n\nstatic int kvm_fetch_guest_virt(struct x86_emulate_ctxt *ctxt,\n\t\t\t\tgva_t addr, void *val, unsigned int bytes,\n\t\t\t\tstruct x86_exception *exception)\n{\n\tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n\tu32 access = (kvm_x86_ops->get_cpl(vcpu) == 3) ? PFERR_USER_MASK : 0;\n\tunsigned offset;\n\tint ret;\n\n\t/* Inline kvm_read_guest_virt_helper for speed.  */\n\tgpa_t gpa = vcpu->arch.walk_mmu->gva_to_gpa(vcpu, addr, access|PFERR_FETCH_MASK,\n\t\t\t\t\t\t    exception);\n\tif (unlikely(gpa == UNMAPPED_GVA))\n\t\treturn X86EMUL_PROPAGATE_FAULT;\n\n\toffset = addr & (PAGE_SIZE-1);\n\tif (WARN_ON(offset + bytes > PAGE_SIZE))\n\t\tbytes = (unsigned)PAGE_SIZE - offset;\n\tret = kvm_vcpu_read_guest_page(vcpu, gpa >> PAGE_SHIFT, val,\n\t\t\t\t       offset, bytes);\n\tif (unlikely(ret < 0))\n\t\treturn X86EMUL_IO_NEEDED;\n\n\treturn X86EMUL_CONTINUE;\n}"
  },
  {
    "function_name": "kvm_read_guest_virt_helper",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "4207-4236",
    "snippet": "static int kvm_read_guest_virt_helper(gva_t addr, void *val, unsigned int bytes,\n\t\t\t\t      struct kvm_vcpu *vcpu, u32 access,\n\t\t\t\t      struct x86_exception *exception)\n{\n\tvoid *data = val;\n\tint r = X86EMUL_CONTINUE;\n\n\twhile (bytes) {\n\t\tgpa_t gpa = vcpu->arch.walk_mmu->gva_to_gpa(vcpu, addr, access,\n\t\t\t\t\t\t\t    exception);\n\t\tunsigned offset = addr & (PAGE_SIZE-1);\n\t\tunsigned toread = min(bytes, (unsigned)PAGE_SIZE - offset);\n\t\tint ret;\n\n\t\tif (gpa == UNMAPPED_GVA)\n\t\t\treturn X86EMUL_PROPAGATE_FAULT;\n\t\tret = kvm_vcpu_read_guest_page(vcpu, gpa >> PAGE_SHIFT, data,\n\t\t\t\t\t       offset, toread);\n\t\tif (ret < 0) {\n\t\t\tr = X86EMUL_IO_NEEDED;\n\t\t\tgoto out;\n\t\t}\n\n\t\tbytes -= toread;\n\t\tdata += toread;\n\t\taddr += toread;\n\t}\nout:\n\treturn r;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_vcpu_read_guest_page",
          "args": [
            "vcpu",
            "gpa >> PAGE_SHIFT",
            "data",
            "offset",
            "toread"
          ],
          "line": 4223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "bytes",
            "(unsigned)PAGE_SIZE - offset"
          ],
          "line": 4218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vcpu->arch.walk_mmu->gva_to_gpa",
          "args": [
            "vcpu",
            "addr",
            "access",
            "exception"
          ],
          "line": 4215
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic int kvm_read_guest_virt_helper(gva_t addr, void *val, unsigned int bytes,\n\t\t\t\t      struct kvm_vcpu *vcpu, u32 access,\n\t\t\t\t      struct x86_exception *exception)\n{\n\tvoid *data = val;\n\tint r = X86EMUL_CONTINUE;\n\n\twhile (bytes) {\n\t\tgpa_t gpa = vcpu->arch.walk_mmu->gva_to_gpa(vcpu, addr, access,\n\t\t\t\t\t\t\t    exception);\n\t\tunsigned offset = addr & (PAGE_SIZE-1);\n\t\tunsigned toread = min(bytes, (unsigned)PAGE_SIZE - offset);\n\t\tint ret;\n\n\t\tif (gpa == UNMAPPED_GVA)\n\t\t\treturn X86EMUL_PROPAGATE_FAULT;\n\t\tret = kvm_vcpu_read_guest_page(vcpu, gpa >> PAGE_SHIFT, data,\n\t\t\t\t\t       offset, toread);\n\t\tif (ret < 0) {\n\t\t\tr = X86EMUL_IO_NEEDED;\n\t\t\tgoto out;\n\t\t}\n\n\t\tbytes -= toread;\n\t\tdata += toread;\n\t\taddr += toread;\n\t}\nout:\n\treturn r;\n}"
  },
  {
    "function_name": "kvm_mmu_gva_to_gpa_system",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "4201-4205",
    "snippet": "gpa_t kvm_mmu_gva_to_gpa_system(struct kvm_vcpu *vcpu, gva_t gva,\n\t\t\t\tstruct x86_exception *exception)\n{\n\treturn vcpu->arch.walk_mmu->gva_to_gpa(vcpu, gva, 0, exception);\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vcpu->arch.walk_mmu->gva_to_gpa",
          "args": [
            "vcpu",
            "gva",
            "0",
            "exception"
          ],
          "line": 4204
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\ngpa_t kvm_mmu_gva_to_gpa_system(struct kvm_vcpu *vcpu, gva_t gva,\n\t\t\t\tstruct x86_exception *exception)\n{\n\treturn vcpu->arch.walk_mmu->gva_to_gpa(vcpu, gva, 0, exception);\n}"
  },
  {
    "function_name": "kvm_mmu_gva_to_gpa_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "4192-4198",
    "snippet": "gpa_t kvm_mmu_gva_to_gpa_write(struct kvm_vcpu *vcpu, gva_t gva,\n\t\t\t       struct x86_exception *exception)\n{\n\tu32 access = (kvm_x86_ops->get_cpl(vcpu) == 3) ? PFERR_USER_MASK : 0;\n\taccess |= PFERR_WRITE_MASK;\n\treturn vcpu->arch.walk_mmu->gva_to_gpa(vcpu, gva, access, exception);\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);",
      "struct kvm_x86_ops *kvm_x86_ops"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vcpu->arch.walk_mmu->gva_to_gpa",
          "args": [
            "vcpu",
            "gva",
            "access",
            "exception"
          ],
          "line": 4197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_x86_ops->get_cpl",
          "args": [
            "vcpu"
          ],
          "line": 4195
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\ngpa_t kvm_mmu_gva_to_gpa_write(struct kvm_vcpu *vcpu, gva_t gva,\n\t\t\t       struct x86_exception *exception)\n{\n\tu32 access = (kvm_x86_ops->get_cpl(vcpu) == 3) ? PFERR_USER_MASK : 0;\n\taccess |= PFERR_WRITE_MASK;\n\treturn vcpu->arch.walk_mmu->gva_to_gpa(vcpu, gva, access, exception);\n}"
  },
  {
    "function_name": "kvm_mmu_gva_to_gpa_fetch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "4184-4190",
    "snippet": "gpa_t kvm_mmu_gva_to_gpa_fetch(struct kvm_vcpu *vcpu, gva_t gva,\n\t\t\t\tstruct x86_exception *exception)\n{\n\tu32 access = (kvm_x86_ops->get_cpl(vcpu) == 3) ? PFERR_USER_MASK : 0;\n\taccess |= PFERR_FETCH_MASK;\n\treturn vcpu->arch.walk_mmu->gva_to_gpa(vcpu, gva, access, exception);\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);",
      "struct kvm_x86_ops *kvm_x86_ops"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vcpu->arch.walk_mmu->gva_to_gpa",
          "args": [
            "vcpu",
            "gva",
            "access",
            "exception"
          ],
          "line": 4189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_x86_ops->get_cpl",
          "args": [
            "vcpu"
          ],
          "line": 4187
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\ngpa_t kvm_mmu_gva_to_gpa_fetch(struct kvm_vcpu *vcpu, gva_t gva,\n\t\t\t\tstruct x86_exception *exception)\n{\n\tu32 access = (kvm_x86_ops->get_cpl(vcpu) == 3) ? PFERR_USER_MASK : 0;\n\taccess |= PFERR_FETCH_MASK;\n\treturn vcpu->arch.walk_mmu->gva_to_gpa(vcpu, gva, access, exception);\n}"
  },
  {
    "function_name": "kvm_mmu_gva_to_gpa_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "4177-4182",
    "snippet": "gpa_t kvm_mmu_gva_to_gpa_read(struct kvm_vcpu *vcpu, gva_t gva,\n\t\t\t      struct x86_exception *exception)\n{\n\tu32 access = (kvm_x86_ops->get_cpl(vcpu) == 3) ? PFERR_USER_MASK : 0;\n\treturn vcpu->arch.walk_mmu->gva_to_gpa(vcpu, gva, access, exception);\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);",
      "struct kvm_x86_ops *kvm_x86_ops"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vcpu->arch.walk_mmu->gva_to_gpa",
          "args": [
            "vcpu",
            "gva",
            "access",
            "exception"
          ],
          "line": 4181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_x86_ops->get_cpl",
          "args": [
            "vcpu"
          ],
          "line": 4180
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\ngpa_t kvm_mmu_gva_to_gpa_read(struct kvm_vcpu *vcpu, gva_t gva,\n\t\t\t      struct x86_exception *exception)\n{\n\tu32 access = (kvm_x86_ops->get_cpl(vcpu) == 3) ? PFERR_USER_MASK : 0;\n\treturn vcpu->arch.walk_mmu->gva_to_gpa(vcpu, gva, access, exception);\n}"
  },
  {
    "function_name": "translate_nested_gpa",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "4163-4175",
    "snippet": "gpa_t translate_nested_gpa(struct kvm_vcpu *vcpu, gpa_t gpa, u32 access,\n\t\t\t   struct x86_exception *exception)\n{\n\tgpa_t t_gpa;\n\n\tBUG_ON(!mmu_is_nested(vcpu));\n\n\t/* NPT walks are always user-walks */\n\taccess |= PFERR_USER_MASK;\n\tt_gpa  = vcpu->arch.mmu.gva_to_gpa(vcpu, gpa, access, exception);\n\n\treturn t_gpa;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vcpu->arch.mmu.gva_to_gpa",
          "args": [
            "vcpu",
            "gpa",
            "access",
            "exception"
          ],
          "line": 4172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!mmu_is_nested(vcpu)"
          ],
          "line": 4168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmu_is_nested",
          "args": [
            "vcpu"
          ],
          "line": 4168
        },
        "resolved": true,
        "details": {
          "function_name": "mmu_is_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.h",
          "lines": "62-65",
          "snippet": "static inline bool mmu_is_nested(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.walk_mmu == &vcpu->arch.nested_mmu;\n}",
          "includes": [
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline bool mmu_is_nested(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.walk_mmu == &vcpu->arch.nested_mmu;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\ngpa_t translate_nested_gpa(struct kvm_vcpu *vcpu, gpa_t gpa, u32 access,\n\t\t\t   struct x86_exception *exception)\n{\n\tgpa_t t_gpa;\n\n\tBUG_ON(!mmu_is_nested(vcpu));\n\n\t/* NPT walks are always user-walks */\n\taccess |= PFERR_USER_MASK;\n\tt_gpa  = vcpu->arch.mmu.gva_to_gpa(vcpu, gpa, access, exception);\n\n\treturn t_gpa;\n}"
  },
  {
    "function_name": "kvm_get_segment",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "4157-4161",
    "snippet": "void kvm_get_segment(struct kvm_vcpu *vcpu,\n\t\t     struct kvm_segment *var, int seg)\n{\n\tkvm_x86_ops->get_segment(vcpu, var, seg);\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);",
      "struct kvm_x86_ops *kvm_x86_ops"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_x86_ops->get_segment",
          "args": [
            "vcpu",
            "var",
            "seg"
          ],
          "line": 4160
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nvoid kvm_get_segment(struct kvm_vcpu *vcpu,\n\t\t     struct kvm_segment *var, int seg)\n{\n\tkvm_x86_ops->get_segment(vcpu, var, seg);\n}"
  },
  {
    "function_name": "kvm_set_segment",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "4151-4155",
    "snippet": "static void kvm_set_segment(struct kvm_vcpu *vcpu,\n\t\t\tstruct kvm_segment *var, int seg)\n{\n\tkvm_x86_ops->set_segment(vcpu, var, seg);\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);",
      "struct kvm_x86_ops *kvm_x86_ops"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_x86_ops->set_segment",
          "args": [
            "vcpu",
            "var",
            "seg"
          ],
          "line": 4154
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nstatic void kvm_set_segment(struct kvm_vcpu *vcpu,\n\t\t\tstruct kvm_segment *var, int seg)\n{\n\tkvm_x86_ops->set_segment(vcpu, var, seg);\n}"
  },
  {
    "function_name": "vcpu_mmio_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "4129-4149",
    "snippet": "static int vcpu_mmio_read(struct kvm_vcpu *vcpu, gpa_t addr, int len, void *v)\n{\n\tint handled = 0;\n\tint n;\n\n\tdo {\n\t\tn = min(len, 8);\n\t\tif (!(lapic_in_kernel(vcpu) &&\n\t\t      !kvm_iodevice_read(vcpu, &vcpu->arch.apic->dev,\n\t\t\t\t\t addr, n, v))\n\t\t    && kvm_io_bus_read(vcpu, KVM_MMIO_BUS, addr, n, v))\n\t\t\tbreak;\n\t\ttrace_kvm_mmio(KVM_TRACE_MMIO_READ, n, addr, *(u64 *)v);\n\t\thandled += n;\n\t\taddr += n;\n\t\tlen -= n;\n\t\tv += n;\n\t} while (len);\n\n\treturn handled;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_kvm_mmio",
          "args": [
            "KVM_TRACE_MMIO_READ",
            "n",
            "addr",
            "*(u64 *)v"
          ],
          "line": 4141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_io_bus_read",
          "args": [
            "vcpu",
            "KVM_MMIO_BUS",
            "addr",
            "n",
            "v"
          ],
          "line": 4139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_iodevice_read",
          "args": [
            "vcpu",
            "&vcpu->arch.apic->dev",
            "addr",
            "n",
            "v"
          ],
          "line": 4137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lapic_in_kernel",
          "args": [
            "vcpu"
          ],
          "line": 4136
        },
        "resolved": true,
        "details": {
          "function_name": "lapic_in_kernel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.h",
          "lines": "141-146",
          "snippet": "static inline bool lapic_in_kernel(struct kvm_vcpu *vcpu)\n{\n\tif (static_key_false(&kvm_no_apic_vcpu))\n\t\treturn vcpu->arch.apic;\n\treturn true;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline bool lapic_in_kernel(struct kvm_vcpu *vcpu)\n{\n\tif (static_key_false(&kvm_no_apic_vcpu))\n\t\treturn vcpu->arch.apic;\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "len",
            "8"
          ],
          "line": 4135
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic int vcpu_mmio_read(struct kvm_vcpu *vcpu, gpa_t addr, int len, void *v)\n{\n\tint handled = 0;\n\tint n;\n\n\tdo {\n\t\tn = min(len, 8);\n\t\tif (!(lapic_in_kernel(vcpu) &&\n\t\t      !kvm_iodevice_read(vcpu, &vcpu->arch.apic->dev,\n\t\t\t\t\t addr, n, v))\n\t\t    && kvm_io_bus_read(vcpu, KVM_MMIO_BUS, addr, n, v))\n\t\t\tbreak;\n\t\ttrace_kvm_mmio(KVM_TRACE_MMIO_READ, n, addr, *(u64 *)v);\n\t\thandled += n;\n\t\taddr += n;\n\t\tlen -= n;\n\t\tv += n;\n\t} while (len);\n\n\treturn handled;\n}"
  },
  {
    "function_name": "vcpu_mmio_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "4108-4127",
    "snippet": "static int vcpu_mmio_write(struct kvm_vcpu *vcpu, gpa_t addr, int len,\n\t\t\t   const void *v)\n{\n\tint handled = 0;\n\tint n;\n\n\tdo {\n\t\tn = min(len, 8);\n\t\tif (!(lapic_in_kernel(vcpu) &&\n\t\t      !kvm_iodevice_write(vcpu, &vcpu->arch.apic->dev, addr, n, v))\n\t\t    && kvm_io_bus_write(vcpu, KVM_MMIO_BUS, addr, n, v))\n\t\t\tbreak;\n\t\thandled += n;\n\t\taddr += n;\n\t\tlen -= n;\n\t\tv += n;\n\t} while (len);\n\n\treturn handled;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_io_bus_write",
          "args": [
            "vcpu",
            "KVM_MMIO_BUS",
            "addr",
            "n",
            "v"
          ],
          "line": 4118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_iodevice_write",
          "args": [
            "vcpu",
            "&vcpu->arch.apic->dev",
            "addr",
            "n",
            "v"
          ],
          "line": 4117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lapic_in_kernel",
          "args": [
            "vcpu"
          ],
          "line": 4116
        },
        "resolved": true,
        "details": {
          "function_name": "lapic_in_kernel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.h",
          "lines": "141-146",
          "snippet": "static inline bool lapic_in_kernel(struct kvm_vcpu *vcpu)\n{\n\tif (static_key_false(&kvm_no_apic_vcpu))\n\t\treturn vcpu->arch.apic;\n\treturn true;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline bool lapic_in_kernel(struct kvm_vcpu *vcpu)\n{\n\tif (static_key_false(&kvm_no_apic_vcpu))\n\t\treturn vcpu->arch.apic;\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "len",
            "8"
          ],
          "line": 4115
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic int vcpu_mmio_write(struct kvm_vcpu *vcpu, gpa_t addr, int len,\n\t\t\t   const void *v)\n{\n\tint handled = 0;\n\tint n;\n\n\tdo {\n\t\tn = min(len, 8);\n\t\tif (!(lapic_in_kernel(vcpu) &&\n\t\t      !kvm_iodevice_write(vcpu, &vcpu->arch.apic->dev, addr, n, v))\n\t\t    && kvm_io_bus_write(vcpu, KVM_MMIO_BUS, addr, n, v))\n\t\t\tbreak;\n\t\thandled += n;\n\t\taddr += n;\n\t\tlen -= n;\n\t\tv += n;\n\t} while (len);\n\n\treturn handled;\n}"
  },
  {
    "function_name": "kvm_init_msr_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "4059-4106",
    "snippet": "static void kvm_init_msr_list(void)\n{\n\tu32 dummy[2];\n\tunsigned i, j;\n\n\tfor (i = j = 0; i < ARRAY_SIZE(msrs_to_save); i++) {\n\t\tif (rdmsr_safe(msrs_to_save[i], &dummy[0], &dummy[1]) < 0)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Even MSRs that are valid in the host may not be exposed\n\t\t * to the guests in some cases.\n\t\t */\n\t\tswitch (msrs_to_save[i]) {\n\t\tcase MSR_IA32_BNDCFGS:\n\t\t\tif (!kvm_x86_ops->mpx_supported())\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\tcase MSR_TSC_AUX:\n\t\t\tif (!kvm_x86_ops->rdtscp_supported())\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tif (j < i)\n\t\t\tmsrs_to_save[j] = msrs_to_save[i];\n\t\tj++;\n\t}\n\tnum_msrs_to_save = j;\n\n\tfor (i = j = 0; i < ARRAY_SIZE(emulated_msrs); i++) {\n\t\tswitch (emulated_msrs[i]) {\n\t\tcase MSR_IA32_SMBASE:\n\t\t\tif (!kvm_x86_ops->cpu_has_high_real_mode_segbase())\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tif (j < i)\n\t\t\temulated_msrs[j] = emulated_msrs[i];\n\t\tj++;\n\t}\n\tnum_emulated_msrs = j;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct kvm_x86_ops *kvm_x86_ops",
      "static u32 msrs_to_save[] = {\n\tMSR_IA32_SYSENTER_CS, MSR_IA32_SYSENTER_ESP, MSR_IA32_SYSENTER_EIP,\n\tMSR_STAR,\n#ifdef CONFIG_X86_64\n\tMSR_CSTAR, MSR_KERNEL_GS_BASE, MSR_SYSCALL_MASK, MSR_LSTAR,\n#endif\n\tMSR_IA32_TSC, MSR_IA32_CR_PAT, MSR_VM_HSAVE_PA,\n\tMSR_IA32_FEATURE_CONTROL, MSR_IA32_BNDCFGS, MSR_TSC_AUX,\n};",
      "static unsigned num_msrs_to_save;",
      "static u32 emulated_msrs[] = {\n\tMSR_KVM_SYSTEM_TIME, MSR_KVM_WALL_CLOCK,\n\tMSR_KVM_SYSTEM_TIME_NEW, MSR_KVM_WALL_CLOCK_NEW,\n\tHV_X64_MSR_GUEST_OS_ID, HV_X64_MSR_HYPERCALL,\n\tHV_X64_MSR_TIME_REF_COUNT, HV_X64_MSR_REFERENCE_TSC,\n\tHV_X64_MSR_CRASH_P0, HV_X64_MSR_CRASH_P1, HV_X64_MSR_CRASH_P2,\n\tHV_X64_MSR_CRASH_P3, HV_X64_MSR_CRASH_P4, HV_X64_MSR_CRASH_CTL,\n\tHV_X64_MSR_RESET,\n\tHV_X64_MSR_VP_INDEX,\n\tHV_X64_MSR_VP_RUNTIME,\n\tHV_X64_MSR_SCONTROL,\n\tHV_X64_MSR_STIMER0_CONFIG,\n\tHV_X64_MSR_APIC_ASSIST_PAGE, MSR_KVM_ASYNC_PF_EN, MSR_KVM_STEAL_TIME,\n\tMSR_KVM_PV_EOI_EN,\n\n\tMSR_IA32_TSC_ADJUST,\n\tMSR_IA32_TSCDEADLINE,\n\tMSR_IA32_MISC_ENABLE,\n\tMSR_IA32_MCG_STATUS,\n\tMSR_IA32_MCG_CTL,\n\tMSR_IA32_SMBASE,\n};",
      "static unsigned num_emulated_msrs;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_x86_ops->cpu_has_high_real_mode_segbase",
          "args": [],
          "line": 4094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "emulated_msrs"
          ],
          "line": 4091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_x86_ops->rdtscp_supported",
          "args": [],
          "line": 4078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_x86_ops->mpx_supported",
          "args": [],
          "line": 4074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rdmsr_safe",
          "args": [
            "msrs_to_save[i]",
            "&dummy[0]",
            "&dummy[1]"
          ],
          "line": 4065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "msrs_to_save"
          ],
          "line": 4064
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstruct kvm_x86_ops *kvm_x86_ops;\nstatic u32 msrs_to_save[] = {\n\tMSR_IA32_SYSENTER_CS, MSR_IA32_SYSENTER_ESP, MSR_IA32_SYSENTER_EIP,\n\tMSR_STAR,\n#ifdef CONFIG_X86_64\n\tMSR_CSTAR, MSR_KERNEL_GS_BASE, MSR_SYSCALL_MASK, MSR_LSTAR,\n#endif\n\tMSR_IA32_TSC, MSR_IA32_CR_PAT, MSR_VM_HSAVE_PA,\n\tMSR_IA32_FEATURE_CONTROL, MSR_IA32_BNDCFGS, MSR_TSC_AUX,\n};\nstatic unsigned num_msrs_to_save;\nstatic u32 emulated_msrs[] = {\n\tMSR_KVM_SYSTEM_TIME, MSR_KVM_WALL_CLOCK,\n\tMSR_KVM_SYSTEM_TIME_NEW, MSR_KVM_WALL_CLOCK_NEW,\n\tHV_X64_MSR_GUEST_OS_ID, HV_X64_MSR_HYPERCALL,\n\tHV_X64_MSR_TIME_REF_COUNT, HV_X64_MSR_REFERENCE_TSC,\n\tHV_X64_MSR_CRASH_P0, HV_X64_MSR_CRASH_P1, HV_X64_MSR_CRASH_P2,\n\tHV_X64_MSR_CRASH_P3, HV_X64_MSR_CRASH_P4, HV_X64_MSR_CRASH_CTL,\n\tHV_X64_MSR_RESET,\n\tHV_X64_MSR_VP_INDEX,\n\tHV_X64_MSR_VP_RUNTIME,\n\tHV_X64_MSR_SCONTROL,\n\tHV_X64_MSR_STIMER0_CONFIG,\n\tHV_X64_MSR_APIC_ASSIST_PAGE, MSR_KVM_ASYNC_PF_EN, MSR_KVM_STEAL_TIME,\n\tMSR_KVM_PV_EOI_EN,\n\n\tMSR_IA32_TSC_ADJUST,\n\tMSR_IA32_TSCDEADLINE,\n\tMSR_IA32_MISC_ENABLE,\n\tMSR_IA32_MCG_STATUS,\n\tMSR_IA32_MCG_CTL,\n\tMSR_IA32_SMBASE,\n};\nstatic unsigned num_emulated_msrs;\n\nstatic void kvm_init_msr_list(void)\n{\n\tu32 dummy[2];\n\tunsigned i, j;\n\n\tfor (i = j = 0; i < ARRAY_SIZE(msrs_to_save); i++) {\n\t\tif (rdmsr_safe(msrs_to_save[i], &dummy[0], &dummy[1]) < 0)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Even MSRs that are valid in the host may not be exposed\n\t\t * to the guests in some cases.\n\t\t */\n\t\tswitch (msrs_to_save[i]) {\n\t\tcase MSR_IA32_BNDCFGS:\n\t\t\tif (!kvm_x86_ops->mpx_supported())\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\tcase MSR_TSC_AUX:\n\t\t\tif (!kvm_x86_ops->rdtscp_supported())\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tif (j < i)\n\t\t\tmsrs_to_save[j] = msrs_to_save[i];\n\t\tj++;\n\t}\n\tnum_msrs_to_save = j;\n\n\tfor (i = j = 0; i < ARRAY_SIZE(emulated_msrs); i++) {\n\t\tswitch (emulated_msrs[i]) {\n\t\tcase MSR_IA32_SMBASE:\n\t\t\tif (!kvm_x86_ops->cpu_has_high_real_mode_segbase())\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tif (j < i)\n\t\t\temulated_msrs[j] = emulated_msrs[i];\n\t\tj++;\n\t}\n\tnum_emulated_msrs = j;\n}"
  },
  {
    "function_name": "kvm_arch_vm_ioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "3787-4057",
    "snippet": "long kvm_arch_vm_ioctl(struct file *filp,\n\t\t       unsigned int ioctl, unsigned long arg)\n{\n\tstruct kvm *kvm = filp->private_data;\n\tvoid __user *argp = (void __user *)arg;\n\tint r = -ENOTTY;\n\t/*\n\t * This union makes it completely explicit to gcc-3.x\n\t * that these two variables' stack usage should be\n\t * combined, not added together.\n\t */\n\tunion {\n\t\tstruct kvm_pit_state ps;\n\t\tstruct kvm_pit_state2 ps2;\n\t\tstruct kvm_pit_config pit_config;\n\t} u;\n\n\tswitch (ioctl) {\n\tcase KVM_SET_TSS_ADDR:\n\t\tr = kvm_vm_ioctl_set_tss_addr(kvm, arg);\n\t\tbreak;\n\tcase KVM_SET_IDENTITY_MAP_ADDR: {\n\t\tu64 ident_addr;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&ident_addr, argp, sizeof ident_addr))\n\t\t\tgoto out;\n\t\tr = kvm_vm_ioctl_set_identity_map_addr(kvm, ident_addr);\n\t\tbreak;\n\t}\n\tcase KVM_SET_NR_MMU_PAGES:\n\t\tr = kvm_vm_ioctl_set_nr_mmu_pages(kvm, arg);\n\t\tbreak;\n\tcase KVM_GET_NR_MMU_PAGES:\n\t\tr = kvm_vm_ioctl_get_nr_mmu_pages(kvm);\n\t\tbreak;\n\tcase KVM_CREATE_IRQCHIP: {\n\t\tstruct kvm_pic *vpic;\n\n\t\tmutex_lock(&kvm->lock);\n\t\tr = -EEXIST;\n\t\tif (kvm->arch.vpic)\n\t\t\tgoto create_irqchip_unlock;\n\t\tr = -EINVAL;\n\t\tif (atomic_read(&kvm->online_vcpus))\n\t\t\tgoto create_irqchip_unlock;\n\t\tr = -ENOMEM;\n\t\tvpic = kvm_create_pic(kvm);\n\t\tif (vpic) {\n\t\t\tr = kvm_ioapic_init(kvm);\n\t\t\tif (r) {\n\t\t\t\tmutex_lock(&kvm->slots_lock);\n\t\t\t\tkvm_destroy_pic(vpic);\n\t\t\t\tmutex_unlock(&kvm->slots_lock);\n\t\t\t\tgoto create_irqchip_unlock;\n\t\t\t}\n\t\t} else\n\t\t\tgoto create_irqchip_unlock;\n\t\tr = kvm_setup_default_irq_routing(kvm);\n\t\tif (r) {\n\t\t\tmutex_lock(&kvm->slots_lock);\n\t\t\tmutex_lock(&kvm->irq_lock);\n\t\t\tkvm_ioapic_destroy(kvm);\n\t\t\tkvm_destroy_pic(vpic);\n\t\t\tmutex_unlock(&kvm->irq_lock);\n\t\t\tmutex_unlock(&kvm->slots_lock);\n\t\t\tgoto create_irqchip_unlock;\n\t\t}\n\t\t/* Write kvm->irq_routing before kvm->arch.vpic.  */\n\t\tsmp_wmb();\n\t\tkvm->arch.vpic = vpic;\n\tcreate_irqchip_unlock:\n\t\tmutex_unlock(&kvm->lock);\n\t\tbreak;\n\t}\n\tcase KVM_CREATE_PIT:\n\t\tu.pit_config.flags = KVM_PIT_SPEAKER_DUMMY;\n\t\tgoto create_pit;\n\tcase KVM_CREATE_PIT2:\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&u.pit_config, argp,\n\t\t\t\t   sizeof(struct kvm_pit_config)))\n\t\t\tgoto out;\n\tcreate_pit:\n\t\tmutex_lock(&kvm->slots_lock);\n\t\tr = -EEXIST;\n\t\tif (kvm->arch.vpit)\n\t\t\tgoto create_pit_unlock;\n\t\tr = -ENOMEM;\n\t\tkvm->arch.vpit = kvm_create_pit(kvm, u.pit_config.flags);\n\t\tif (kvm->arch.vpit)\n\t\t\tr = 0;\n\tcreate_pit_unlock:\n\t\tmutex_unlock(&kvm->slots_lock);\n\t\tbreak;\n\tcase KVM_GET_IRQCHIP: {\n\t\t/* 0: PIC master, 1: PIC slave, 2: IOAPIC */\n\t\tstruct kvm_irqchip *chip;\n\n\t\tchip = memdup_user(argp, sizeof(*chip));\n\t\tif (IS_ERR(chip)) {\n\t\t\tr = PTR_ERR(chip);\n\t\t\tgoto out;\n\t\t}\n\n\t\tr = -ENXIO;\n\t\tif (!irqchip_in_kernel(kvm) || irqchip_split(kvm))\n\t\t\tgoto get_irqchip_out;\n\t\tr = kvm_vm_ioctl_get_irqchip(kvm, chip);\n\t\tif (r)\n\t\t\tgoto get_irqchip_out;\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(argp, chip, sizeof *chip))\n\t\t\tgoto get_irqchip_out;\n\t\tr = 0;\n\tget_irqchip_out:\n\t\tkfree(chip);\n\t\tbreak;\n\t}\n\tcase KVM_SET_IRQCHIP: {\n\t\t/* 0: PIC master, 1: PIC slave, 2: IOAPIC */\n\t\tstruct kvm_irqchip *chip;\n\n\t\tchip = memdup_user(argp, sizeof(*chip));\n\t\tif (IS_ERR(chip)) {\n\t\t\tr = PTR_ERR(chip);\n\t\t\tgoto out;\n\t\t}\n\n\t\tr = -ENXIO;\n\t\tif (!irqchip_in_kernel(kvm) || irqchip_split(kvm))\n\t\t\tgoto set_irqchip_out;\n\t\tr = kvm_vm_ioctl_set_irqchip(kvm, chip);\n\t\tif (r)\n\t\t\tgoto set_irqchip_out;\n\t\tr = 0;\n\tset_irqchip_out:\n\t\tkfree(chip);\n\t\tbreak;\n\t}\n\tcase KVM_GET_PIT: {\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&u.ps, argp, sizeof(struct kvm_pit_state)))\n\t\t\tgoto out;\n\t\tr = -ENXIO;\n\t\tif (!kvm->arch.vpit)\n\t\t\tgoto out;\n\t\tr = kvm_vm_ioctl_get_pit(kvm, &u.ps);\n\t\tif (r)\n\t\t\tgoto out;\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(argp, &u.ps, sizeof(struct kvm_pit_state)))\n\t\t\tgoto out;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_SET_PIT: {\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&u.ps, argp, sizeof u.ps))\n\t\t\tgoto out;\n\t\tr = -ENXIO;\n\t\tif (!kvm->arch.vpit)\n\t\t\tgoto out;\n\t\tr = kvm_vm_ioctl_set_pit(kvm, &u.ps);\n\t\tbreak;\n\t}\n\tcase KVM_GET_PIT2: {\n\t\tr = -ENXIO;\n\t\tif (!kvm->arch.vpit)\n\t\t\tgoto out;\n\t\tr = kvm_vm_ioctl_get_pit2(kvm, &u.ps2);\n\t\tif (r)\n\t\t\tgoto out;\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(argp, &u.ps2, sizeof(u.ps2)))\n\t\t\tgoto out;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_SET_PIT2: {\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&u.ps2, argp, sizeof(u.ps2)))\n\t\t\tgoto out;\n\t\tr = -ENXIO;\n\t\tif (!kvm->arch.vpit)\n\t\t\tgoto out;\n\t\tr = kvm_vm_ioctl_set_pit2(kvm, &u.ps2);\n\t\tbreak;\n\t}\n\tcase KVM_REINJECT_CONTROL: {\n\t\tstruct kvm_reinject_control control;\n\t\tr =  -EFAULT;\n\t\tif (copy_from_user(&control, argp, sizeof(control)))\n\t\t\tgoto out;\n\t\tr = kvm_vm_ioctl_reinject(kvm, &control);\n\t\tbreak;\n\t}\n\tcase KVM_SET_BOOT_CPU_ID:\n\t\tr = 0;\n\t\tmutex_lock(&kvm->lock);\n\t\tif (atomic_read(&kvm->online_vcpus) != 0)\n\t\t\tr = -EBUSY;\n\t\telse\n\t\t\tkvm->arch.bsp_vcpu_id = arg;\n\t\tmutex_unlock(&kvm->lock);\n\t\tbreak;\n\tcase KVM_XEN_HVM_CONFIG: {\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&kvm->arch.xen_hvm_config, argp,\n\t\t\t\t   sizeof(struct kvm_xen_hvm_config)))\n\t\t\tgoto out;\n\t\tr = -EINVAL;\n\t\tif (kvm->arch.xen_hvm_config.flags)\n\t\t\tgoto out;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_SET_CLOCK: {\n\t\tstruct kvm_clock_data user_ns;\n\t\tu64 now_ns;\n\t\ts64 delta;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&user_ns, argp, sizeof(user_ns)))\n\t\t\tgoto out;\n\n\t\tr = -EINVAL;\n\t\tif (user_ns.flags)\n\t\t\tgoto out;\n\n\t\tr = 0;\n\t\tlocal_irq_disable();\n\t\tnow_ns = get_kernel_ns();\n\t\tdelta = user_ns.clock - now_ns;\n\t\tlocal_irq_enable();\n\t\tkvm->arch.kvmclock_offset = delta;\n\t\tkvm_gen_update_masterclock(kvm);\n\t\tbreak;\n\t}\n\tcase KVM_GET_CLOCK: {\n\t\tstruct kvm_clock_data user_ns;\n\t\tu64 now_ns;\n\n\t\tlocal_irq_disable();\n\t\tnow_ns = get_kernel_ns();\n\t\tuser_ns.clock = kvm->arch.kvmclock_offset + now_ns;\n\t\tlocal_irq_enable();\n\t\tuser_ns.flags = 0;\n\t\tmemset(&user_ns.pad, 0, sizeof(user_ns.pad));\n\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(argp, &user_ns, sizeof(user_ns)))\n\t\t\tgoto out;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_ENABLE_CAP: {\n\t\tstruct kvm_enable_cap cap;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&cap, argp, sizeof(cap)))\n\t\t\tgoto out;\n\t\tr = kvm_vm_ioctl_enable_cap(kvm, &cap);\n\t\tbreak;\n\t}\n\tdefault:\n\t\tr = kvm_vm_ioctl_assigned_device(kvm, ioctl, arg);\n\t}\nout:\n\treturn r;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_vm_ioctl_assigned_device",
          "args": [
            "kvm",
            "ioctl",
            "arg"
          ],
          "line": 4053
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_vm_ioctl_assigned_device",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/assigned-dev.c",
          "lines": "968-1058",
          "snippet": "long kvm_vm_ioctl_assigned_device(struct kvm *kvm, unsigned ioctl,\n\t\t\t\t  unsigned long arg)\n{\n\tvoid __user *argp = (void __user *)arg;\n\tint r;\n\n\tswitch (ioctl) {\n\tcase KVM_ASSIGN_PCI_DEVICE: {\n\t\tstruct kvm_assigned_pci_dev assigned_dev;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&assigned_dev, argp, sizeof assigned_dev))\n\t\t\tgoto out;\n\t\tr = kvm_vm_ioctl_assign_device(kvm, &assigned_dev);\n\t\tif (r)\n\t\t\tgoto out;\n\t\tbreak;\n\t}\n\tcase KVM_ASSIGN_IRQ: {\n\t\tr = -EOPNOTSUPP;\n\t\tbreak;\n\t}\n\tcase KVM_ASSIGN_DEV_IRQ: {\n\t\tstruct kvm_assigned_irq assigned_irq;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&assigned_irq, argp, sizeof assigned_irq))\n\t\t\tgoto out;\n\t\tr = kvm_vm_ioctl_assign_irq(kvm, &assigned_irq);\n\t\tif (r)\n\t\t\tgoto out;\n\t\tbreak;\n\t}\n\tcase KVM_DEASSIGN_DEV_IRQ: {\n\t\tstruct kvm_assigned_irq assigned_irq;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&assigned_irq, argp, sizeof assigned_irq))\n\t\t\tgoto out;\n\t\tr = kvm_vm_ioctl_deassign_dev_irq(kvm, &assigned_irq);\n\t\tif (r)\n\t\t\tgoto out;\n\t\tbreak;\n\t}\n\tcase KVM_DEASSIGN_PCI_DEVICE: {\n\t\tstruct kvm_assigned_pci_dev assigned_dev;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&assigned_dev, argp, sizeof assigned_dev))\n\t\t\tgoto out;\n\t\tr = kvm_vm_ioctl_deassign_device(kvm, &assigned_dev);\n\t\tif (r)\n\t\t\tgoto out;\n\t\tbreak;\n\t}\n\tcase KVM_ASSIGN_SET_MSIX_NR: {\n\t\tstruct kvm_assigned_msix_nr entry_nr;\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&entry_nr, argp, sizeof entry_nr))\n\t\t\tgoto out;\n\t\tr = kvm_vm_ioctl_set_msix_nr(kvm, &entry_nr);\n\t\tif (r)\n\t\t\tgoto out;\n\t\tbreak;\n\t}\n\tcase KVM_ASSIGN_SET_MSIX_ENTRY: {\n\t\tstruct kvm_assigned_msix_entry entry;\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&entry, argp, sizeof entry))\n\t\t\tgoto out;\n\t\tr = kvm_vm_ioctl_set_msix_entry(kvm, &entry);\n\t\tif (r)\n\t\t\tgoto out;\n\t\tbreak;\n\t}\n\tcase KVM_ASSIGN_SET_INTX_MASK: {\n\t\tstruct kvm_assigned_pci_dev assigned_dev;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&assigned_dev, argp, sizeof assigned_dev))\n\t\t\tgoto out;\n\t\tr = kvm_vm_ioctl_set_pci_irq_mask(kvm, &assigned_dev);\n\t\tbreak;\n\t}\n\tdefault:\n\t\tr = -ENOTTY;\n\t\tbreak;\n\t}\nout:\n\treturn r;\n}",
          "includes": [
            "#include \"trace/events/kvm.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"irq.h\"",
            "#include <linux/fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/pci.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/errno.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace/events/kvm.h\"\n#include \"assigned-dev.h\"\n#include \"irq.h\"\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/spinlock.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nlong kvm_vm_ioctl_assigned_device(struct kvm *kvm, unsigned ioctl,\n\t\t\t\t  unsigned long arg)\n{\n\tvoid __user *argp = (void __user *)arg;\n\tint r;\n\n\tswitch (ioctl) {\n\tcase KVM_ASSIGN_PCI_DEVICE: {\n\t\tstruct kvm_assigned_pci_dev assigned_dev;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&assigned_dev, argp, sizeof assigned_dev))\n\t\t\tgoto out;\n\t\tr = kvm_vm_ioctl_assign_device(kvm, &assigned_dev);\n\t\tif (r)\n\t\t\tgoto out;\n\t\tbreak;\n\t}\n\tcase KVM_ASSIGN_IRQ: {\n\t\tr = -EOPNOTSUPP;\n\t\tbreak;\n\t}\n\tcase KVM_ASSIGN_DEV_IRQ: {\n\t\tstruct kvm_assigned_irq assigned_irq;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&assigned_irq, argp, sizeof assigned_irq))\n\t\t\tgoto out;\n\t\tr = kvm_vm_ioctl_assign_irq(kvm, &assigned_irq);\n\t\tif (r)\n\t\t\tgoto out;\n\t\tbreak;\n\t}\n\tcase KVM_DEASSIGN_DEV_IRQ: {\n\t\tstruct kvm_assigned_irq assigned_irq;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&assigned_irq, argp, sizeof assigned_irq))\n\t\t\tgoto out;\n\t\tr = kvm_vm_ioctl_deassign_dev_irq(kvm, &assigned_irq);\n\t\tif (r)\n\t\t\tgoto out;\n\t\tbreak;\n\t}\n\tcase KVM_DEASSIGN_PCI_DEVICE: {\n\t\tstruct kvm_assigned_pci_dev assigned_dev;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&assigned_dev, argp, sizeof assigned_dev))\n\t\t\tgoto out;\n\t\tr = kvm_vm_ioctl_deassign_device(kvm, &assigned_dev);\n\t\tif (r)\n\t\t\tgoto out;\n\t\tbreak;\n\t}\n\tcase KVM_ASSIGN_SET_MSIX_NR: {\n\t\tstruct kvm_assigned_msix_nr entry_nr;\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&entry_nr, argp, sizeof entry_nr))\n\t\t\tgoto out;\n\t\tr = kvm_vm_ioctl_set_msix_nr(kvm, &entry_nr);\n\t\tif (r)\n\t\t\tgoto out;\n\t\tbreak;\n\t}\n\tcase KVM_ASSIGN_SET_MSIX_ENTRY: {\n\t\tstruct kvm_assigned_msix_entry entry;\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&entry, argp, sizeof entry))\n\t\t\tgoto out;\n\t\tr = kvm_vm_ioctl_set_msix_entry(kvm, &entry);\n\t\tif (r)\n\t\t\tgoto out;\n\t\tbreak;\n\t}\n\tcase KVM_ASSIGN_SET_INTX_MASK: {\n\t\tstruct kvm_assigned_pci_dev assigned_dev;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&assigned_dev, argp, sizeof assigned_dev))\n\t\t\tgoto out;\n\t\tr = kvm_vm_ioctl_set_pci_irq_mask(kvm, &assigned_dev);\n\t\tbreak;\n\t}\n\tdefault:\n\t\tr = -ENOTTY;\n\t\tbreak;\n\t}\nout:\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_vm_ioctl_enable_cap",
          "args": [
            "kvm",
            "&cap"
          ],
          "line": 4049
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_vm_ioctl_enable_cap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "3745-3785",
          "snippet": "static int kvm_vm_ioctl_enable_cap(struct kvm *kvm,\n\t\t\t\t   struct kvm_enable_cap *cap)\n{\n\tint r;\n\n\tif (cap->flags)\n\t\treturn -EINVAL;\n\n\tswitch (cap->cap) {\n\tcase KVM_CAP_DISABLE_QUIRKS:\n\t\tkvm->arch.disabled_quirks = cap->args[0];\n\t\tr = 0;\n\t\tbreak;\n\tcase KVM_CAP_SPLIT_IRQCHIP: {\n\t\tmutex_lock(&kvm->lock);\n\t\tr = -EINVAL;\n\t\tif (cap->args[0] > MAX_NR_RESERVED_IOAPIC_PINS)\n\t\t\tgoto split_irqchip_unlock;\n\t\tr = -EEXIST;\n\t\tif (irqchip_in_kernel(kvm))\n\t\t\tgoto split_irqchip_unlock;\n\t\tif (atomic_read(&kvm->online_vcpus))\n\t\t\tgoto split_irqchip_unlock;\n\t\tr = kvm_setup_empty_irq_routing(kvm);\n\t\tif (r)\n\t\t\tgoto split_irqchip_unlock;\n\t\t/* Pairs with irqchip_in_kernel. */\n\t\tsmp_wmb();\n\t\tkvm->arch.irqchip_split = true;\n\t\tkvm->arch.nr_reserved_ioapic_pins = cap->args[0];\n\t\tr = 0;\nsplit_irqchip_unlock:\n\t\tmutex_unlock(&kvm->lock);\n\t\tbreak;\n\t}\n\tdefault:\n\t\tr = -EINVAL;\n\t\tbreak;\n\t}\n\treturn r;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int kvm_vm_ioctl_enable_cap(struct kvm *kvm,\n\t\t\t\t   struct kvm_enable_cap *cap)\n{\n\tint r;\n\n\tif (cap->flags)\n\t\treturn -EINVAL;\n\n\tswitch (cap->cap) {\n\tcase KVM_CAP_DISABLE_QUIRKS:\n\t\tkvm->arch.disabled_quirks = cap->args[0];\n\t\tr = 0;\n\t\tbreak;\n\tcase KVM_CAP_SPLIT_IRQCHIP: {\n\t\tmutex_lock(&kvm->lock);\n\t\tr = -EINVAL;\n\t\tif (cap->args[0] > MAX_NR_RESERVED_IOAPIC_PINS)\n\t\t\tgoto split_irqchip_unlock;\n\t\tr = -EEXIST;\n\t\tif (irqchip_in_kernel(kvm))\n\t\t\tgoto split_irqchip_unlock;\n\t\tif (atomic_read(&kvm->online_vcpus))\n\t\t\tgoto split_irqchip_unlock;\n\t\tr = kvm_setup_empty_irq_routing(kvm);\n\t\tif (r)\n\t\t\tgoto split_irqchip_unlock;\n\t\t/* Pairs with irqchip_in_kernel. */\n\t\tsmp_wmb();\n\t\tkvm->arch.irqchip_split = true;\n\t\tkvm->arch.nr_reserved_ioapic_pins = cap->args[0];\n\t\tr = 0;\nsplit_irqchip_unlock:\n\t\tmutex_unlock(&kvm->lock);\n\t\tbreak;\n\t}\n\tdefault:\n\t\tr = -EINVAL;\n\t\tbreak;\n\t}\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&cap",
            "argp",
            "sizeof(cap)"
          ],
          "line": 4047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "argp",
            "&user_ns",
            "sizeof(user_ns)"
          ],
          "line": 4038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&user_ns.pad",
            "0",
            "sizeof(user_ns.pad)"
          ],
          "line": 4035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_enable",
          "args": [],
          "line": 4033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_kernel_ns",
          "args": [],
          "line": 4031
        },
        "resolved": true,
        "details": {
          "function_name": "get_kernel_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.h",
          "lines": "150-153",
          "snippet": "static inline u64 get_kernel_ns(void)\n{\n\treturn ktime_get_boot_ns();\n}",
          "includes": [
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline u64 get_kernel_ns(void)\n{\n\treturn ktime_get_boot_ns();\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_disable",
          "args": [],
          "line": 4030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_gen_update_masterclock",
          "args": [
            "kvm"
          ],
          "line": 4023
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_gen_update_masterclock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "1694-1715",
          "snippet": "static void kvm_gen_update_masterclock(struct kvm *kvm)\n{\n#ifdef CONFIG_X86_64\n\tint i;\n\tstruct kvm_vcpu *vcpu;\n\tstruct kvm_arch *ka = &kvm->arch;\n\n\tspin_lock(&ka->pvclock_gtod_sync_lock);\n\tkvm_make_mclock_inprogress_request(kvm);\n\t/* no guest entries from this point */\n\tpvclock_update_vm_gtod_copy(kvm);\n\n\tkvm_for_each_vcpu(i, vcpu, kvm)\n\t\tkvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);\n\n\t/* guest entries allowed */\n\tkvm_for_each_vcpu(i, vcpu, kvm)\n\t\tclear_bit(KVM_REQ_MCLOCK_INPROGRESS, &vcpu->requests);\n\n\tspin_unlock(&ka->pvclock_gtod_sync_lock);\n#endif\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic void kvm_gen_update_masterclock(struct kvm *kvm)\n{\n#ifdef CONFIG_X86_64\n\tint i;\n\tstruct kvm_vcpu *vcpu;\n\tstruct kvm_arch *ka = &kvm->arch;\n\n\tspin_lock(&ka->pvclock_gtod_sync_lock);\n\tkvm_make_mclock_inprogress_request(kvm);\n\t/* no guest entries from this point */\n\tpvclock_update_vm_gtod_copy(kvm);\n\n\tkvm_for_each_vcpu(i, vcpu, kvm)\n\t\tkvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);\n\n\t/* guest entries allowed */\n\tkvm_for_each_vcpu(i, vcpu, kvm)\n\t\tclear_bit(KVM_REQ_MCLOCK_INPROGRESS, &vcpu->requests);\n\n\tspin_unlock(&ka->pvclock_gtod_sync_lock);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_enable",
          "args": [],
          "line": 4021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_disable",
          "args": [],
          "line": 4018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&user_ns",
            "argp",
            "sizeof(user_ns)"
          ],
          "line": 4010
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&kvm->arch.xen_hvm_config",
            "argp",
            "sizeof(struct kvm_xen_hvm_config)"
          ],
          "line": 3995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&kvm->lock"
          ],
          "line": 3991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&kvm->online_vcpus"
          ],
          "line": 3987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&kvm->lock"
          ],
          "line": 3986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_vm_ioctl_reinject",
          "args": [
            "kvm",
            "&control"
          ],
          "line": 3981
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_vm_ioctl_reinject",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "3668-3685",
          "snippet": "static int kvm_vm_ioctl_reinject(struct kvm *kvm,\n\t\t\t\t struct kvm_reinject_control *control)\n{\n\tstruct kvm_pit *pit = kvm->arch.vpit;\n\n\tif (!pit)\n\t\treturn -ENXIO;\n\n\t/* pit->pit_state.lock was overloaded to prevent userspace from getting\n\t * an inconsistent state after running multiple KVM_REINJECT_CONTROL\n\t * ioctls in parallel.  Use a separate lock if that ioctl isn't rare.\n\t */\n\tmutex_lock(&pit->pit_state.lock);\n\tkvm_pit_set_reinject(pit, control->pit_reinject);\n\tmutex_unlock(&pit->pit_state.lock);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int kvm_vm_ioctl_reinject(struct kvm *kvm,\n\t\t\t\t struct kvm_reinject_control *control)\n{\n\tstruct kvm_pit *pit = kvm->arch.vpit;\n\n\tif (!pit)\n\t\treturn -ENXIO;\n\n\t/* pit->pit_state.lock was overloaded to prevent userspace from getting\n\t * an inconsistent state after running multiple KVM_REINJECT_CONTROL\n\t * ioctls in parallel.  Use a separate lock if that ioctl isn't rare.\n\t */\n\tmutex_lock(&pit->pit_state.lock);\n\tkvm_pit_set_reinject(pit, control->pit_reinject);\n\tmutex_unlock(&pit->pit_state.lock);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&control",
            "argp",
            "sizeof(control)"
          ],
          "line": 3979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_vm_ioctl_set_pit2",
          "args": [
            "kvm",
            "&u.ps2"
          ],
          "line": 3973
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_vm_ioctl_set_pit2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "3646-3666",
          "snippet": "static int kvm_vm_ioctl_set_pit2(struct kvm *kvm, struct kvm_pit_state2 *ps)\n{\n\tint start = 0;\n\tint i;\n\tu32 prev_legacy, cur_legacy;\n\tstruct kvm_pit *pit = kvm->arch.vpit;\n\n\tmutex_lock(&pit->pit_state.lock);\n\tprev_legacy = pit->pit_state.flags & KVM_PIT_FLAGS_HPET_LEGACY;\n\tcur_legacy = ps->flags & KVM_PIT_FLAGS_HPET_LEGACY;\n\tif (!prev_legacy && cur_legacy)\n\t\tstart = 1;\n\tmemcpy(&pit->pit_state.channels, &ps->channels,\n\t       sizeof(pit->pit_state.channels));\n\tpit->pit_state.flags = ps->flags;\n\tfor (i = 0; i < 3; i++)\n\t\tkvm_pit_load_count(pit, i, pit->pit_state.channels[i].count,\n\t\t\t\t   start && i == 0);\n\tmutex_unlock(&pit->pit_state.lock);\n\treturn 0;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int kvm_vm_ioctl_set_pit2(struct kvm *kvm, struct kvm_pit_state2 *ps)\n{\n\tint start = 0;\n\tint i;\n\tu32 prev_legacy, cur_legacy;\n\tstruct kvm_pit *pit = kvm->arch.vpit;\n\n\tmutex_lock(&pit->pit_state.lock);\n\tprev_legacy = pit->pit_state.flags & KVM_PIT_FLAGS_HPET_LEGACY;\n\tcur_legacy = ps->flags & KVM_PIT_FLAGS_HPET_LEGACY;\n\tif (!prev_legacy && cur_legacy)\n\t\tstart = 1;\n\tmemcpy(&pit->pit_state.channels, &ps->channels,\n\t       sizeof(pit->pit_state.channels));\n\tpit->pit_state.flags = ps->flags;\n\tfor (i = 0; i < 3; i++)\n\t\tkvm_pit_load_count(pit, i, pit->pit_state.channels[i].count,\n\t\t\t\t   start && i == 0);\n\tmutex_unlock(&pit->pit_state.lock);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&u.ps2",
            "argp",
            "sizeof(u.ps2)"
          ],
          "line": 3968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "argp",
            "&u.ps2",
            "sizeof(u.ps2)"
          ],
          "line": 3961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_vm_ioctl_get_pit2",
          "args": [
            "kvm",
            "&u.ps2"
          ],
          "line": 3957
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_vm_ioctl_get_pit2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "3635-3644",
          "snippet": "static int kvm_vm_ioctl_get_pit2(struct kvm *kvm, struct kvm_pit_state2 *ps)\n{\n\tmutex_lock(&kvm->arch.vpit->pit_state.lock);\n\tmemcpy(ps->channels, &kvm->arch.vpit->pit_state.channels,\n\t\tsizeof(ps->channels));\n\tps->flags = kvm->arch.vpit->pit_state.flags;\n\tmutex_unlock(&kvm->arch.vpit->pit_state.lock);\n\tmemset(&ps->reserved, 0, sizeof(ps->reserved));\n\treturn 0;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int kvm_vm_ioctl_get_pit2(struct kvm *kvm, struct kvm_pit_state2 *ps)\n{\n\tmutex_lock(&kvm->arch.vpit->pit_state.lock);\n\tmemcpy(ps->channels, &kvm->arch.vpit->pit_state.channels,\n\t\tsizeof(ps->channels));\n\tps->flags = kvm->arch.vpit->pit_state.flags;\n\tmutex_unlock(&kvm->arch.vpit->pit_state.lock);\n\tmemset(&ps->reserved, 0, sizeof(ps->reserved));\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&u.ps",
            "argp",
            "sizeof u.ps"
          ],
          "line": 3945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "argp",
            "&u.ps",
            "sizeof(struct kvm_pit_state)"
          ],
          "line": 3938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&u.ps",
            "argp",
            "sizeof(struct kvm_pit_state)"
          ],
          "line": 3929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "chip"
          ],
          "line": 3924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_vm_ioctl_set_irqchip",
          "args": [
            "kvm",
            "chip"
          ],
          "line": 3919
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_vm_ioctl_set_irqchip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "3579-3608",
          "snippet": "static int kvm_vm_ioctl_set_irqchip(struct kvm *kvm, struct kvm_irqchip *chip)\n{\n\tint r;\n\n\tr = 0;\n\tswitch (chip->chip_id) {\n\tcase KVM_IRQCHIP_PIC_MASTER:\n\t\tspin_lock(&pic_irqchip(kvm)->lock);\n\t\tmemcpy(&pic_irqchip(kvm)->pics[0],\n\t\t\t&chip->chip.pic,\n\t\t\tsizeof(struct kvm_pic_state));\n\t\tspin_unlock(&pic_irqchip(kvm)->lock);\n\t\tbreak;\n\tcase KVM_IRQCHIP_PIC_SLAVE:\n\t\tspin_lock(&pic_irqchip(kvm)->lock);\n\t\tmemcpy(&pic_irqchip(kvm)->pics[1],\n\t\t\t&chip->chip.pic,\n\t\t\tsizeof(struct kvm_pic_state));\n\t\tspin_unlock(&pic_irqchip(kvm)->lock);\n\t\tbreak;\n\tcase KVM_IRQCHIP_IOAPIC:\n\t\tr = kvm_set_ioapic(kvm, &chip->chip.ioapic);\n\t\tbreak;\n\tdefault:\n\t\tr = -EINVAL;\n\t\tbreak;\n\t}\n\tkvm_pic_update_irq(pic_irqchip(kvm));\n\treturn r;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int kvm_vm_ioctl_set_irqchip(struct kvm *kvm, struct kvm_irqchip *chip)\n{\n\tint r;\n\n\tr = 0;\n\tswitch (chip->chip_id) {\n\tcase KVM_IRQCHIP_PIC_MASTER:\n\t\tspin_lock(&pic_irqchip(kvm)->lock);\n\t\tmemcpy(&pic_irqchip(kvm)->pics[0],\n\t\t\t&chip->chip.pic,\n\t\t\tsizeof(struct kvm_pic_state));\n\t\tspin_unlock(&pic_irqchip(kvm)->lock);\n\t\tbreak;\n\tcase KVM_IRQCHIP_PIC_SLAVE:\n\t\tspin_lock(&pic_irqchip(kvm)->lock);\n\t\tmemcpy(&pic_irqchip(kvm)->pics[1],\n\t\t\t&chip->chip.pic,\n\t\t\tsizeof(struct kvm_pic_state));\n\t\tspin_unlock(&pic_irqchip(kvm)->lock);\n\t\tbreak;\n\tcase KVM_IRQCHIP_IOAPIC:\n\t\tr = kvm_set_ioapic(kvm, &chip->chip.ioapic);\n\t\tbreak;\n\tdefault:\n\t\tr = -EINVAL;\n\t\tbreak;\n\t}\n\tkvm_pic_update_irq(pic_irqchip(kvm));\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irqchip_split",
          "args": [
            "kvm"
          ],
          "line": 3917
        },
        "resolved": true,
        "details": {
          "function_name": "irqchip_split",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/irq.h",
          "lines": "94-97",
          "snippet": "static inline int irqchip_split(struct kvm *kvm)\n{\n\treturn kvm->arch.irqchip_split;\n}",
          "includes": [
            "#include \"lapic.h\"",
            "#include \"ioapic.h\"",
            "#include <kvm/iodev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/mm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <kvm/iodev.h>\n#include <linux/spinlock.h>\n#include <linux/kvm_host.h>\n#include <linux/hrtimer.h>\n#include <linux/mm_types.h>\n\nstatic inline int irqchip_split(struct kvm *kvm)\n{\n\treturn kvm->arch.irqchip_split;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irqchip_in_kernel",
          "args": [
            "kvm"
          ],
          "line": 3917
        },
        "resolved": true,
        "details": {
          "function_name": "irqchip_in_kernel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/irq.h",
          "lines": "99-110",
          "snippet": "static inline int irqchip_in_kernel(struct kvm *kvm)\n{\n\tstruct kvm_pic *vpic = pic_irqchip(kvm);\n\tbool ret;\n\n\tret = (vpic != NULL);\n\tret |= irqchip_split(kvm);\n\n\t/* Read vpic before kvm->irq_routing.  */\n\tsmp_rmb();\n\treturn ret;\n}",
          "includes": [
            "#include \"lapic.h\"",
            "#include \"ioapic.h\"",
            "#include <kvm/iodev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/mm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <kvm/iodev.h>\n#include <linux/spinlock.h>\n#include <linux/kvm_host.h>\n#include <linux/hrtimer.h>\n#include <linux/mm_types.h>\n\nstatic inline int irqchip_in_kernel(struct kvm *kvm)\n{\n\tstruct kvm_pic *vpic = pic_irqchip(kvm);\n\tbool ret;\n\n\tret = (vpic != NULL);\n\tret |= irqchip_split(kvm);\n\n\t/* Read vpic before kvm->irq_routing.  */\n\tsmp_rmb();\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "chip"
          ],
          "line": 3912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "chip"
          ],
          "line": 3911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memdup_user",
          "args": [
            "argp",
            "sizeof(*chip)"
          ],
          "line": 3910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "chip"
          ],
          "line": 3903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "argp",
            "chip",
            "sizeof *chip"
          ],
          "line": 3899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_vm_ioctl_get_irqchip",
          "args": [
            "kvm",
            "chip"
          ],
          "line": 3895
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_vm_ioctl_get_irqchip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "3553-3577",
          "snippet": "static int kvm_vm_ioctl_get_irqchip(struct kvm *kvm, struct kvm_irqchip *chip)\n{\n\tint r;\n\n\tr = 0;\n\tswitch (chip->chip_id) {\n\tcase KVM_IRQCHIP_PIC_MASTER:\n\t\tmemcpy(&chip->chip.pic,\n\t\t\t&pic_irqchip(kvm)->pics[0],\n\t\t\tsizeof(struct kvm_pic_state));\n\t\tbreak;\n\tcase KVM_IRQCHIP_PIC_SLAVE:\n\t\tmemcpy(&chip->chip.pic,\n\t\t\t&pic_irqchip(kvm)->pics[1],\n\t\t\tsizeof(struct kvm_pic_state));\n\t\tbreak;\n\tcase KVM_IRQCHIP_IOAPIC:\n\t\tr = kvm_get_ioapic(kvm, &chip->chip.ioapic);\n\t\tbreak;\n\tdefault:\n\t\tr = -EINVAL;\n\t\tbreak;\n\t}\n\treturn r;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int kvm_vm_ioctl_get_irqchip(struct kvm *kvm, struct kvm_irqchip *chip)\n{\n\tint r;\n\n\tr = 0;\n\tswitch (chip->chip_id) {\n\tcase KVM_IRQCHIP_PIC_MASTER:\n\t\tmemcpy(&chip->chip.pic,\n\t\t\t&pic_irqchip(kvm)->pics[0],\n\t\t\tsizeof(struct kvm_pic_state));\n\t\tbreak;\n\tcase KVM_IRQCHIP_PIC_SLAVE:\n\t\tmemcpy(&chip->chip.pic,\n\t\t\t&pic_irqchip(kvm)->pics[1],\n\t\t\tsizeof(struct kvm_pic_state));\n\t\tbreak;\n\tcase KVM_IRQCHIP_IOAPIC:\n\t\tr = kvm_get_ioapic(kvm, &chip->chip.ioapic);\n\t\tbreak;\n\tdefault:\n\t\tr = -EINVAL;\n\t\tbreak;\n\t}\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "chip"
          ],
          "line": 3888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "chip"
          ],
          "line": 3887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memdup_user",
          "args": [
            "argp",
            "sizeof(*chip)"
          ],
          "line": 3886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&kvm->slots_lock"
          ],
          "line": 3880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_create_pit",
          "args": [
            "kvm",
            "u.pit_config.flags"
          ],
          "line": 3876
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_create_pit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/i8254.c",
          "lines": "649-720",
          "snippet": "struct kvm_pit *kvm_create_pit(struct kvm *kvm, u32 flags)\n{\n\tstruct kvm_pit *pit;\n\tstruct kvm_kpit_state *pit_state;\n\tstruct pid *pid;\n\tpid_t pid_nr;\n\tint ret;\n\n\tpit = kzalloc(sizeof(struct kvm_pit), GFP_KERNEL);\n\tif (!pit)\n\t\treturn NULL;\n\n\tpit->irq_source_id = kvm_request_irq_source_id(kvm);\n\tif (pit->irq_source_id < 0)\n\t\tgoto fail_request;\n\n\tmutex_init(&pit->pit_state.lock);\n\n\tpid = get_pid(task_tgid(current));\n\tpid_nr = pid_vnr(pid);\n\tput_pid(pid);\n\n\tinit_kthread_worker(&pit->worker);\n\tpit->worker_task = kthread_run(kthread_worker_fn, &pit->worker,\n\t\t\t\t       \"kvm-pit/%d\", pid_nr);\n\tif (IS_ERR(pit->worker_task))\n\t\tgoto fail_kthread;\n\n\tinit_kthread_work(&pit->expired, pit_do_work);\n\n\tpit->kvm = kvm;\n\n\tpit_state = &pit->pit_state;\n\thrtimer_init(&pit_state->timer, CLOCK_MONOTONIC, HRTIMER_MODE_ABS);\n\tpit_state->timer.function = pit_timer_fn;\n\n\tpit_state->irq_ack_notifier.gsi = 0;\n\tpit_state->irq_ack_notifier.irq_acked = kvm_pit_ack_irq;\n\tpit->mask_notifier.func = pit_mask_notifer;\n\n\tkvm_pit_reset(pit);\n\n\tkvm_pit_set_reinject(pit, true);\n\n\tkvm_iodevice_init(&pit->dev, &pit_dev_ops);\n\tret = kvm_io_bus_register_dev(kvm, KVM_PIO_BUS, KVM_PIT_BASE_ADDRESS,\n\t\t\t\t      KVM_PIT_MEM_LENGTH, &pit->dev);\n\tif (ret < 0)\n\t\tgoto fail_register_pit;\n\n\tif (flags & KVM_PIT_SPEAKER_DUMMY) {\n\t\tkvm_iodevice_init(&pit->speaker_dev, &speaker_dev_ops);\n\t\tret = kvm_io_bus_register_dev(kvm, KVM_PIO_BUS,\n\t\t\t\t\t      KVM_SPEAKER_BASE_ADDRESS, 4,\n\t\t\t\t\t      &pit->speaker_dev);\n\t\tif (ret < 0)\n\t\t\tgoto fail_register_speaker;\n\t}\n\n\treturn pit;\n\nfail_register_speaker:\n\tkvm_io_bus_unregister_dev(kvm, KVM_PIO_BUS, &pit->dev);\nfail_register_pit:\n\tkvm_pit_set_reinject(pit, false);\n\tkthread_stop(pit->worker_task);\nfail_kthread:\n\tkvm_free_irq_source_id(kvm, pit->irq_source_id);\nfail_request:\n\tkfree(pit);\n\treturn NULL;\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"i8254.h\"",
            "#include \"irq.h\"",
            "#include \"ioapic.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct kvm_io_device_ops pit_dev_ops = {\n\t.read     = pit_ioport_read,\n\t.write    = pit_ioport_write,\n};",
            "static const struct kvm_io_device_ops speaker_dev_ops = {\n\t.read     = speaker_ioport_read,\n\t.write    = speaker_ioport_write,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"i8254.h\"\n#include \"irq.h\"\n#include \"ioapic.h\"\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nstatic const struct kvm_io_device_ops pit_dev_ops = {\n\t.read     = pit_ioport_read,\n\t.write    = pit_ioport_write,\n};\nstatic const struct kvm_io_device_ops speaker_dev_ops = {\n\t.read     = speaker_ioport_read,\n\t.write    = speaker_ioport_write,\n};\n\nstruct kvm_pit *kvm_create_pit(struct kvm *kvm, u32 flags)\n{\n\tstruct kvm_pit *pit;\n\tstruct kvm_kpit_state *pit_state;\n\tstruct pid *pid;\n\tpid_t pid_nr;\n\tint ret;\n\n\tpit = kzalloc(sizeof(struct kvm_pit), GFP_KERNEL);\n\tif (!pit)\n\t\treturn NULL;\n\n\tpit->irq_source_id = kvm_request_irq_source_id(kvm);\n\tif (pit->irq_source_id < 0)\n\t\tgoto fail_request;\n\n\tmutex_init(&pit->pit_state.lock);\n\n\tpid = get_pid(task_tgid(current));\n\tpid_nr = pid_vnr(pid);\n\tput_pid(pid);\n\n\tinit_kthread_worker(&pit->worker);\n\tpit->worker_task = kthread_run(kthread_worker_fn, &pit->worker,\n\t\t\t\t       \"kvm-pit/%d\", pid_nr);\n\tif (IS_ERR(pit->worker_task))\n\t\tgoto fail_kthread;\n\n\tinit_kthread_work(&pit->expired, pit_do_work);\n\n\tpit->kvm = kvm;\n\n\tpit_state = &pit->pit_state;\n\thrtimer_init(&pit_state->timer, CLOCK_MONOTONIC, HRTIMER_MODE_ABS);\n\tpit_state->timer.function = pit_timer_fn;\n\n\tpit_state->irq_ack_notifier.gsi = 0;\n\tpit_state->irq_ack_notifier.irq_acked = kvm_pit_ack_irq;\n\tpit->mask_notifier.func = pit_mask_notifer;\n\n\tkvm_pit_reset(pit);\n\n\tkvm_pit_set_reinject(pit, true);\n\n\tkvm_iodevice_init(&pit->dev, &pit_dev_ops);\n\tret = kvm_io_bus_register_dev(kvm, KVM_PIO_BUS, KVM_PIT_BASE_ADDRESS,\n\t\t\t\t      KVM_PIT_MEM_LENGTH, &pit->dev);\n\tif (ret < 0)\n\t\tgoto fail_register_pit;\n\n\tif (flags & KVM_PIT_SPEAKER_DUMMY) {\n\t\tkvm_iodevice_init(&pit->speaker_dev, &speaker_dev_ops);\n\t\tret = kvm_io_bus_register_dev(kvm, KVM_PIO_BUS,\n\t\t\t\t\t      KVM_SPEAKER_BASE_ADDRESS, 4,\n\t\t\t\t\t      &pit->speaker_dev);\n\t\tif (ret < 0)\n\t\t\tgoto fail_register_speaker;\n\t}\n\n\treturn pit;\n\nfail_register_speaker:\n\tkvm_io_bus_unregister_dev(kvm, KVM_PIO_BUS, &pit->dev);\nfail_register_pit:\n\tkvm_pit_set_reinject(pit, false);\n\tkthread_stop(pit->worker_task);\nfail_kthread:\n\tkvm_free_irq_source_id(kvm, pit->irq_source_id);\nfail_request:\n\tkfree(pit);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&kvm->slots_lock"
          ],
          "line": 3871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&u.pit_config",
            "argp",
            "sizeof(struct kvm_pit_config)"
          ],
          "line": 3867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&kvm->lock"
          ],
          "line": 3859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_wmb",
          "args": [],
          "line": 3856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&kvm->slots_lock"
          ],
          "line": 3852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&kvm->irq_lock"
          ],
          "line": 3851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_destroy_pic",
          "args": [
            "vpic"
          ],
          "line": 3850
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_destroy_pic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/i8259.c",
          "lines": "654-660",
          "snippet": "void kvm_destroy_pic(struct kvm_pic *vpic)\n{\n\tkvm_io_bus_unregister_dev(vpic->kvm, KVM_PIO_BUS, &vpic->dev_master);\n\tkvm_io_bus_unregister_dev(vpic->kvm, KVM_PIO_BUS, &vpic->dev_slave);\n\tkvm_io_bus_unregister_dev(vpic->kvm, KVM_PIO_BUS, &vpic->dev_eclr);\n\tkfree(vpic);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/kvm_host.h>",
            "#include \"irq.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nvoid kvm_destroy_pic(struct kvm_pic *vpic)\n{\n\tkvm_io_bus_unregister_dev(vpic->kvm, KVM_PIO_BUS, &vpic->dev_master);\n\tkvm_io_bus_unregister_dev(vpic->kvm, KVM_PIO_BUS, &vpic->dev_slave);\n\tkvm_io_bus_unregister_dev(vpic->kvm, KVM_PIO_BUS, &vpic->dev_eclr);\n\tkfree(vpic);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_ioapic_destroy",
          "args": [
            "kvm"
          ],
          "line": 3849
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_ioapic_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/ioapic.c",
          "lines": "632-640",
          "snippet": "void kvm_ioapic_destroy(struct kvm *kvm)\n{\n\tstruct kvm_ioapic *ioapic = kvm->arch.vioapic;\n\n\tcancel_delayed_work_sync(&ioapic->eoi_inject);\n\tkvm_io_bus_unregister_dev(kvm, KVM_MMIO_BUS, &ioapic->dev);\n\tkvm->arch.vioapic = NULL;\n\tkfree(ioapic);\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"lapic.h\"",
            "#include \"ioapic.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/processor.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <trace/events/kvm.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/processor.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);\n\nvoid kvm_ioapic_destroy(struct kvm *kvm)\n{\n\tstruct kvm_ioapic *ioapic = kvm->arch.vioapic;\n\n\tcancel_delayed_work_sync(&ioapic->eoi_inject);\n\tkvm_io_bus_unregister_dev(kvm, KVM_MMIO_BUS, &ioapic->dev);\n\tkvm->arch.vioapic = NULL;\n\tkfree(ioapic);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&kvm->irq_lock"
          ],
          "line": 3848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&kvm->slots_lock"
          ],
          "line": 3847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_setup_default_irq_routing",
          "args": [
            "kvm"
          ],
          "line": 3845
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_setup_default_irq_routing",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/irq_comm.c",
          "lines": "356-360",
          "snippet": "int kvm_setup_default_irq_routing(struct kvm *kvm)\n{\n\treturn kvm_set_irq_routing(kvm, default_routing,\n\t\t\t\t   ARRAY_SIZE(default_routing), 0);\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"hyperv.h\"",
            "#include \"lapic.h\"",
            "#include \"ioapic.h\"",
            "#include \"irq.h\"",
            "#include <asm/msidef.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct kvm_irq_routing_entry default_routing[] = {\n\tROUTING_ENTRY2(0), ROUTING_ENTRY2(1),\n\tROUTING_ENTRY2(2), ROUTING_ENTRY2(3),\n\tROUTING_ENTRY2(4), ROUTING_ENTRY2(5),\n\tROUTING_ENTRY2(6), ROUTING_ENTRY2(7),\n\tROUTING_ENTRY2(8), ROUTING_ENTRY2(9),\n\tROUTING_ENTRY2(10), ROUTING_ENTRY2(11),\n\tROUTING_ENTRY2(12), ROUTING_ENTRY2(13),\n\tROUTING_ENTRY2(14), ROUTING_ENTRY2(15),\n\tROUTING_ENTRY1(16), ROUTING_ENTRY1(17),\n\tROUTING_ENTRY1(18), ROUTING_ENTRY1(19),\n\tROUTING_ENTRY1(20), ROUTING_ENTRY1(21),\n\tROUTING_ENTRY1(22), ROUTING_ENTRY1(23),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"hyperv.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include \"irq.h\"\n#include <asm/msidef.h>\n#include <trace/events/kvm.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nstatic const struct kvm_irq_routing_entry default_routing[] = {\n\tROUTING_ENTRY2(0), ROUTING_ENTRY2(1),\n\tROUTING_ENTRY2(2), ROUTING_ENTRY2(3),\n\tROUTING_ENTRY2(4), ROUTING_ENTRY2(5),\n\tROUTING_ENTRY2(6), ROUTING_ENTRY2(7),\n\tROUTING_ENTRY2(8), ROUTING_ENTRY2(9),\n\tROUTING_ENTRY2(10), ROUTING_ENTRY2(11),\n\tROUTING_ENTRY2(12), ROUTING_ENTRY2(13),\n\tROUTING_ENTRY2(14), ROUTING_ENTRY2(15),\n\tROUTING_ENTRY1(16), ROUTING_ENTRY1(17),\n\tROUTING_ENTRY1(18), ROUTING_ENTRY1(19),\n\tROUTING_ENTRY1(20), ROUTING_ENTRY1(21),\n\tROUTING_ENTRY1(22), ROUTING_ENTRY1(23),\n};\n\nint kvm_setup_default_irq_routing(struct kvm *kvm)\n{\n\treturn kvm_set_irq_routing(kvm, default_routing,\n\t\t\t\t   ARRAY_SIZE(default_routing), 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&kvm->slots_lock"
          ],
          "line": 3840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&kvm->slots_lock"
          ],
          "line": 3838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_ioapic_init",
          "args": [
            "kvm"
          ],
          "line": 3836
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_ioapic_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/ioapic.c",
          "lines": "604-630",
          "snippet": "int kvm_ioapic_init(struct kvm *kvm)\n{\n\tstruct kvm_ioapic *ioapic;\n\tint ret;\n\n\tioapic = kzalloc(sizeof(struct kvm_ioapic), GFP_KERNEL);\n\tif (!ioapic)\n\t\treturn -ENOMEM;\n\tspin_lock_init(&ioapic->lock);\n\tINIT_DELAYED_WORK(&ioapic->eoi_inject, kvm_ioapic_eoi_inject_work);\n\tkvm->arch.vioapic = ioapic;\n\tkvm_ioapic_reset(ioapic);\n\tkvm_iodevice_init(&ioapic->dev, &ioapic_mmio_ops);\n\tioapic->kvm = kvm;\n\tmutex_lock(&kvm->slots_lock);\n\tret = kvm_io_bus_register_dev(kvm, KVM_MMIO_BUS, ioapic->base_address,\n\t\t\t\t      IOAPIC_MEM_LENGTH, &ioapic->dev);\n\tmutex_unlock(&kvm->slots_lock);\n\tif (ret < 0) {\n\t\tkvm->arch.vioapic = NULL;\n\t\tkfree(ioapic);\n\t\treturn ret;\n\t}\n\n\tkvm_vcpu_request_scan_ioapic(kvm);\n\treturn ret;\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"lapic.h\"",
            "#include \"ioapic.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/processor.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);",
            "static const struct kvm_io_device_ops ioapic_mmio_ops = {\n\t.read     = ioapic_mmio_read,\n\t.write    = ioapic_mmio_write,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <trace/events/kvm.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/processor.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);\nstatic const struct kvm_io_device_ops ioapic_mmio_ops = {\n\t.read     = ioapic_mmio_read,\n\t.write    = ioapic_mmio_write,\n};\n\nint kvm_ioapic_init(struct kvm *kvm)\n{\n\tstruct kvm_ioapic *ioapic;\n\tint ret;\n\n\tioapic = kzalloc(sizeof(struct kvm_ioapic), GFP_KERNEL);\n\tif (!ioapic)\n\t\treturn -ENOMEM;\n\tspin_lock_init(&ioapic->lock);\n\tINIT_DELAYED_WORK(&ioapic->eoi_inject, kvm_ioapic_eoi_inject_work);\n\tkvm->arch.vioapic = ioapic;\n\tkvm_ioapic_reset(ioapic);\n\tkvm_iodevice_init(&ioapic->dev, &ioapic_mmio_ops);\n\tioapic->kvm = kvm;\n\tmutex_lock(&kvm->slots_lock);\n\tret = kvm_io_bus_register_dev(kvm, KVM_MMIO_BUS, ioapic->base_address,\n\t\t\t\t      IOAPIC_MEM_LENGTH, &ioapic->dev);\n\tmutex_unlock(&kvm->slots_lock);\n\tif (ret < 0) {\n\t\tkvm->arch.vioapic = NULL;\n\t\tkfree(ioapic);\n\t\treturn ret;\n\t}\n\n\tkvm_vcpu_request_scan_ioapic(kvm);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_create_pic",
          "args": [
            "kvm"
          ],
          "line": 3834
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_create_pic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/i8259.c",
          "lines": "601-652",
          "snippet": "struct kvm_pic *kvm_create_pic(struct kvm *kvm)\n{\n\tstruct kvm_pic *s;\n\tint ret;\n\n\ts = kzalloc(sizeof(struct kvm_pic), GFP_KERNEL);\n\tif (!s)\n\t\treturn NULL;\n\tspin_lock_init(&s->lock);\n\ts->kvm = kvm;\n\ts->pics[0].elcr_mask = 0xf8;\n\ts->pics[1].elcr_mask = 0xde;\n\ts->pics[0].pics_state = s;\n\ts->pics[1].pics_state = s;\n\n\t/*\n\t * Initialize PIO device\n\t */\n\tkvm_iodevice_init(&s->dev_master, &picdev_master_ops);\n\tkvm_iodevice_init(&s->dev_slave, &picdev_slave_ops);\n\tkvm_iodevice_init(&s->dev_eclr, &picdev_eclr_ops);\n\tmutex_lock(&kvm->slots_lock);\n\tret = kvm_io_bus_register_dev(kvm, KVM_PIO_BUS, 0x20, 2,\n\t\t\t\t      &s->dev_master);\n\tif (ret < 0)\n\t\tgoto fail_unlock;\n\n\tret = kvm_io_bus_register_dev(kvm, KVM_PIO_BUS, 0xa0, 2, &s->dev_slave);\n\tif (ret < 0)\n\t\tgoto fail_unreg_2;\n\n\tret = kvm_io_bus_register_dev(kvm, KVM_PIO_BUS, 0x4d0, 2, &s->dev_eclr);\n\tif (ret < 0)\n\t\tgoto fail_unreg_1;\n\n\tmutex_unlock(&kvm->slots_lock);\n\n\treturn s;\n\nfail_unreg_1:\n\tkvm_io_bus_unregister_dev(kvm, KVM_PIO_BUS, &s->dev_slave);\n\nfail_unreg_2:\n\tkvm_io_bus_unregister_dev(kvm, KVM_PIO_BUS, &s->dev_master);\n\nfail_unlock:\n\tmutex_unlock(&kvm->slots_lock);\n\n\tkfree(s);\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/kvm_host.h>",
            "#include \"irq.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct kvm_io_device_ops picdev_master_ops = {\n\t.read     = picdev_master_read,\n\t.write    = picdev_master_write,\n};",
            "static const struct kvm_io_device_ops picdev_slave_ops = {\n\t.read     = picdev_slave_read,\n\t.write    = picdev_slave_write,\n};",
            "static const struct kvm_io_device_ops picdev_eclr_ops = {\n\t.read     = picdev_eclr_read,\n\t.write    = picdev_eclr_write,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic const struct kvm_io_device_ops picdev_master_ops = {\n\t.read     = picdev_master_read,\n\t.write    = picdev_master_write,\n};\nstatic const struct kvm_io_device_ops picdev_slave_ops = {\n\t.read     = picdev_slave_read,\n\t.write    = picdev_slave_write,\n};\nstatic const struct kvm_io_device_ops picdev_eclr_ops = {\n\t.read     = picdev_eclr_read,\n\t.write    = picdev_eclr_write,\n};\n\nstruct kvm_pic *kvm_create_pic(struct kvm *kvm)\n{\n\tstruct kvm_pic *s;\n\tint ret;\n\n\ts = kzalloc(sizeof(struct kvm_pic), GFP_KERNEL);\n\tif (!s)\n\t\treturn NULL;\n\tspin_lock_init(&s->lock);\n\ts->kvm = kvm;\n\ts->pics[0].elcr_mask = 0xf8;\n\ts->pics[1].elcr_mask = 0xde;\n\ts->pics[0].pics_state = s;\n\ts->pics[1].pics_state = s;\n\n\t/*\n\t * Initialize PIO device\n\t */\n\tkvm_iodevice_init(&s->dev_master, &picdev_master_ops);\n\tkvm_iodevice_init(&s->dev_slave, &picdev_slave_ops);\n\tkvm_iodevice_init(&s->dev_eclr, &picdev_eclr_ops);\n\tmutex_lock(&kvm->slots_lock);\n\tret = kvm_io_bus_register_dev(kvm, KVM_PIO_BUS, 0x20, 2,\n\t\t\t\t      &s->dev_master);\n\tif (ret < 0)\n\t\tgoto fail_unlock;\n\n\tret = kvm_io_bus_register_dev(kvm, KVM_PIO_BUS, 0xa0, 2, &s->dev_slave);\n\tif (ret < 0)\n\t\tgoto fail_unreg_2;\n\n\tret = kvm_io_bus_register_dev(kvm, KVM_PIO_BUS, 0x4d0, 2, &s->dev_eclr);\n\tif (ret < 0)\n\t\tgoto fail_unreg_1;\n\n\tmutex_unlock(&kvm->slots_lock);\n\n\treturn s;\n\nfail_unreg_1:\n\tkvm_io_bus_unregister_dev(kvm, KVM_PIO_BUS, &s->dev_slave);\n\nfail_unreg_2:\n\tkvm_io_bus_unregister_dev(kvm, KVM_PIO_BUS, &s->dev_master);\n\nfail_unlock:\n\tmutex_unlock(&kvm->slots_lock);\n\n\tkfree(s);\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&kvm->online_vcpus"
          ],
          "line": 3831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&kvm->lock"
          ],
          "line": 3826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_vm_ioctl_get_nr_mmu_pages",
          "args": [
            "kvm"
          ],
          "line": 3821
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_vm_ioctl_get_nr_mmu_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "3548-3551",
          "snippet": "static int kvm_vm_ioctl_get_nr_mmu_pages(struct kvm *kvm)\n{\n\treturn kvm->arch.n_max_mmu_pages;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int kvm_vm_ioctl_get_nr_mmu_pages(struct kvm *kvm)\n{\n\treturn kvm->arch.n_max_mmu_pages;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_vm_ioctl_set_nr_mmu_pages",
          "args": [
            "kvm",
            "arg"
          ],
          "line": 3818
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_vm_ioctl_set_nr_mmu_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "3533-3546",
          "snippet": "static int kvm_vm_ioctl_set_nr_mmu_pages(struct kvm *kvm,\n\t\t\t\t\t  u32 kvm_nr_mmu_pages)\n{\n\tif (kvm_nr_mmu_pages < KVM_MIN_ALLOC_MMU_PAGES)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&kvm->slots_lock);\n\n\tkvm_mmu_change_mmu_pages(kvm, kvm_nr_mmu_pages);\n\tkvm->arch.n_requested_mmu_pages = kvm_nr_mmu_pages;\n\n\tmutex_unlock(&kvm->slots_lock);\n\treturn 0;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int kvm_vm_ioctl_set_nr_mmu_pages(struct kvm *kvm,\n\t\t\t\t\t  u32 kvm_nr_mmu_pages)\n{\n\tif (kvm_nr_mmu_pages < KVM_MIN_ALLOC_MMU_PAGES)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&kvm->slots_lock);\n\n\tkvm_mmu_change_mmu_pages(kvm, kvm_nr_mmu_pages);\n\tkvm->arch.n_requested_mmu_pages = kvm_nr_mmu_pages;\n\n\tmutex_unlock(&kvm->slots_lock);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_vm_ioctl_set_identity_map_addr",
          "args": [
            "kvm",
            "ident_addr"
          ],
          "line": 3814
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_vm_ioctl_set_identity_map_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "3526-3531",
          "snippet": "static int kvm_vm_ioctl_set_identity_map_addr(struct kvm *kvm,\n\t\t\t\t\t      u64 ident_addr)\n{\n\tkvm->arch.ept_identity_map_addr = ident_addr;\n\treturn 0;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int kvm_vm_ioctl_set_identity_map_addr(struct kvm *kvm,\n\t\t\t\t\t      u64 ident_addr)\n{\n\tkvm->arch.ept_identity_map_addr = ident_addr;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&ident_addr",
            "argp",
            "sizeof ident_addr"
          ],
          "line": 3812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_vm_ioctl_set_tss_addr",
          "args": [
            "kvm",
            "arg"
          ],
          "line": 3806
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_vm_ioctl_set_tss_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "3516-3524",
          "snippet": "static int kvm_vm_ioctl_set_tss_addr(struct kvm *kvm, unsigned long addr)\n{\n\tint ret;\n\n\tif (addr > (unsigned int)(-3 * PAGE_SIZE))\n\t\treturn -EINVAL;\n\tret = kvm_x86_ops->set_tss_addr(kvm, addr);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct kvm_x86_ops *kvm_x86_ops"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstruct kvm_x86_ops *kvm_x86_ops;\n\nstatic int kvm_vm_ioctl_set_tss_addr(struct kvm *kvm, unsigned long addr)\n{\n\tint ret;\n\n\tif (addr > (unsigned int)(-3 * PAGE_SIZE))\n\t\treturn -EINVAL;\n\tret = kvm_x86_ops->set_tss_addr(kvm, addr);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nlong kvm_arch_vm_ioctl(struct file *filp,\n\t\t       unsigned int ioctl, unsigned long arg)\n{\n\tstruct kvm *kvm = filp->private_data;\n\tvoid __user *argp = (void __user *)arg;\n\tint r = -ENOTTY;\n\t/*\n\t * This union makes it completely explicit to gcc-3.x\n\t * that these two variables' stack usage should be\n\t * combined, not added together.\n\t */\n\tunion {\n\t\tstruct kvm_pit_state ps;\n\t\tstruct kvm_pit_state2 ps2;\n\t\tstruct kvm_pit_config pit_config;\n\t} u;\n\n\tswitch (ioctl) {\n\tcase KVM_SET_TSS_ADDR:\n\t\tr = kvm_vm_ioctl_set_tss_addr(kvm, arg);\n\t\tbreak;\n\tcase KVM_SET_IDENTITY_MAP_ADDR: {\n\t\tu64 ident_addr;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&ident_addr, argp, sizeof ident_addr))\n\t\t\tgoto out;\n\t\tr = kvm_vm_ioctl_set_identity_map_addr(kvm, ident_addr);\n\t\tbreak;\n\t}\n\tcase KVM_SET_NR_MMU_PAGES:\n\t\tr = kvm_vm_ioctl_set_nr_mmu_pages(kvm, arg);\n\t\tbreak;\n\tcase KVM_GET_NR_MMU_PAGES:\n\t\tr = kvm_vm_ioctl_get_nr_mmu_pages(kvm);\n\t\tbreak;\n\tcase KVM_CREATE_IRQCHIP: {\n\t\tstruct kvm_pic *vpic;\n\n\t\tmutex_lock(&kvm->lock);\n\t\tr = -EEXIST;\n\t\tif (kvm->arch.vpic)\n\t\t\tgoto create_irqchip_unlock;\n\t\tr = -EINVAL;\n\t\tif (atomic_read(&kvm->online_vcpus))\n\t\t\tgoto create_irqchip_unlock;\n\t\tr = -ENOMEM;\n\t\tvpic = kvm_create_pic(kvm);\n\t\tif (vpic) {\n\t\t\tr = kvm_ioapic_init(kvm);\n\t\t\tif (r) {\n\t\t\t\tmutex_lock(&kvm->slots_lock);\n\t\t\t\tkvm_destroy_pic(vpic);\n\t\t\t\tmutex_unlock(&kvm->slots_lock);\n\t\t\t\tgoto create_irqchip_unlock;\n\t\t\t}\n\t\t} else\n\t\t\tgoto create_irqchip_unlock;\n\t\tr = kvm_setup_default_irq_routing(kvm);\n\t\tif (r) {\n\t\t\tmutex_lock(&kvm->slots_lock);\n\t\t\tmutex_lock(&kvm->irq_lock);\n\t\t\tkvm_ioapic_destroy(kvm);\n\t\t\tkvm_destroy_pic(vpic);\n\t\t\tmutex_unlock(&kvm->irq_lock);\n\t\t\tmutex_unlock(&kvm->slots_lock);\n\t\t\tgoto create_irqchip_unlock;\n\t\t}\n\t\t/* Write kvm->irq_routing before kvm->arch.vpic.  */\n\t\tsmp_wmb();\n\t\tkvm->arch.vpic = vpic;\n\tcreate_irqchip_unlock:\n\t\tmutex_unlock(&kvm->lock);\n\t\tbreak;\n\t}\n\tcase KVM_CREATE_PIT:\n\t\tu.pit_config.flags = KVM_PIT_SPEAKER_DUMMY;\n\t\tgoto create_pit;\n\tcase KVM_CREATE_PIT2:\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&u.pit_config, argp,\n\t\t\t\t   sizeof(struct kvm_pit_config)))\n\t\t\tgoto out;\n\tcreate_pit:\n\t\tmutex_lock(&kvm->slots_lock);\n\t\tr = -EEXIST;\n\t\tif (kvm->arch.vpit)\n\t\t\tgoto create_pit_unlock;\n\t\tr = -ENOMEM;\n\t\tkvm->arch.vpit = kvm_create_pit(kvm, u.pit_config.flags);\n\t\tif (kvm->arch.vpit)\n\t\t\tr = 0;\n\tcreate_pit_unlock:\n\t\tmutex_unlock(&kvm->slots_lock);\n\t\tbreak;\n\tcase KVM_GET_IRQCHIP: {\n\t\t/* 0: PIC master, 1: PIC slave, 2: IOAPIC */\n\t\tstruct kvm_irqchip *chip;\n\n\t\tchip = memdup_user(argp, sizeof(*chip));\n\t\tif (IS_ERR(chip)) {\n\t\t\tr = PTR_ERR(chip);\n\t\t\tgoto out;\n\t\t}\n\n\t\tr = -ENXIO;\n\t\tif (!irqchip_in_kernel(kvm) || irqchip_split(kvm))\n\t\t\tgoto get_irqchip_out;\n\t\tr = kvm_vm_ioctl_get_irqchip(kvm, chip);\n\t\tif (r)\n\t\t\tgoto get_irqchip_out;\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(argp, chip, sizeof *chip))\n\t\t\tgoto get_irqchip_out;\n\t\tr = 0;\n\tget_irqchip_out:\n\t\tkfree(chip);\n\t\tbreak;\n\t}\n\tcase KVM_SET_IRQCHIP: {\n\t\t/* 0: PIC master, 1: PIC slave, 2: IOAPIC */\n\t\tstruct kvm_irqchip *chip;\n\n\t\tchip = memdup_user(argp, sizeof(*chip));\n\t\tif (IS_ERR(chip)) {\n\t\t\tr = PTR_ERR(chip);\n\t\t\tgoto out;\n\t\t}\n\n\t\tr = -ENXIO;\n\t\tif (!irqchip_in_kernel(kvm) || irqchip_split(kvm))\n\t\t\tgoto set_irqchip_out;\n\t\tr = kvm_vm_ioctl_set_irqchip(kvm, chip);\n\t\tif (r)\n\t\t\tgoto set_irqchip_out;\n\t\tr = 0;\n\tset_irqchip_out:\n\t\tkfree(chip);\n\t\tbreak;\n\t}\n\tcase KVM_GET_PIT: {\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&u.ps, argp, sizeof(struct kvm_pit_state)))\n\t\t\tgoto out;\n\t\tr = -ENXIO;\n\t\tif (!kvm->arch.vpit)\n\t\t\tgoto out;\n\t\tr = kvm_vm_ioctl_get_pit(kvm, &u.ps);\n\t\tif (r)\n\t\t\tgoto out;\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(argp, &u.ps, sizeof(struct kvm_pit_state)))\n\t\t\tgoto out;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_SET_PIT: {\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&u.ps, argp, sizeof u.ps))\n\t\t\tgoto out;\n\t\tr = -ENXIO;\n\t\tif (!kvm->arch.vpit)\n\t\t\tgoto out;\n\t\tr = kvm_vm_ioctl_set_pit(kvm, &u.ps);\n\t\tbreak;\n\t}\n\tcase KVM_GET_PIT2: {\n\t\tr = -ENXIO;\n\t\tif (!kvm->arch.vpit)\n\t\t\tgoto out;\n\t\tr = kvm_vm_ioctl_get_pit2(kvm, &u.ps2);\n\t\tif (r)\n\t\t\tgoto out;\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(argp, &u.ps2, sizeof(u.ps2)))\n\t\t\tgoto out;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_SET_PIT2: {\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&u.ps2, argp, sizeof(u.ps2)))\n\t\t\tgoto out;\n\t\tr = -ENXIO;\n\t\tif (!kvm->arch.vpit)\n\t\t\tgoto out;\n\t\tr = kvm_vm_ioctl_set_pit2(kvm, &u.ps2);\n\t\tbreak;\n\t}\n\tcase KVM_REINJECT_CONTROL: {\n\t\tstruct kvm_reinject_control control;\n\t\tr =  -EFAULT;\n\t\tif (copy_from_user(&control, argp, sizeof(control)))\n\t\t\tgoto out;\n\t\tr = kvm_vm_ioctl_reinject(kvm, &control);\n\t\tbreak;\n\t}\n\tcase KVM_SET_BOOT_CPU_ID:\n\t\tr = 0;\n\t\tmutex_lock(&kvm->lock);\n\t\tif (atomic_read(&kvm->online_vcpus) != 0)\n\t\t\tr = -EBUSY;\n\t\telse\n\t\t\tkvm->arch.bsp_vcpu_id = arg;\n\t\tmutex_unlock(&kvm->lock);\n\t\tbreak;\n\tcase KVM_XEN_HVM_CONFIG: {\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&kvm->arch.xen_hvm_config, argp,\n\t\t\t\t   sizeof(struct kvm_xen_hvm_config)))\n\t\t\tgoto out;\n\t\tr = -EINVAL;\n\t\tif (kvm->arch.xen_hvm_config.flags)\n\t\t\tgoto out;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_SET_CLOCK: {\n\t\tstruct kvm_clock_data user_ns;\n\t\tu64 now_ns;\n\t\ts64 delta;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&user_ns, argp, sizeof(user_ns)))\n\t\t\tgoto out;\n\n\t\tr = -EINVAL;\n\t\tif (user_ns.flags)\n\t\t\tgoto out;\n\n\t\tr = 0;\n\t\tlocal_irq_disable();\n\t\tnow_ns = get_kernel_ns();\n\t\tdelta = user_ns.clock - now_ns;\n\t\tlocal_irq_enable();\n\t\tkvm->arch.kvmclock_offset = delta;\n\t\tkvm_gen_update_masterclock(kvm);\n\t\tbreak;\n\t}\n\tcase KVM_GET_CLOCK: {\n\t\tstruct kvm_clock_data user_ns;\n\t\tu64 now_ns;\n\n\t\tlocal_irq_disable();\n\t\tnow_ns = get_kernel_ns();\n\t\tuser_ns.clock = kvm->arch.kvmclock_offset + now_ns;\n\t\tlocal_irq_enable();\n\t\tuser_ns.flags = 0;\n\t\tmemset(&user_ns.pad, 0, sizeof(user_ns.pad));\n\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(argp, &user_ns, sizeof(user_ns)))\n\t\t\tgoto out;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_ENABLE_CAP: {\n\t\tstruct kvm_enable_cap cap;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&cap, argp, sizeof(cap)))\n\t\t\tgoto out;\n\t\tr = kvm_vm_ioctl_enable_cap(kvm, &cap);\n\t\tbreak;\n\t}\n\tdefault:\n\t\tr = kvm_vm_ioctl_assigned_device(kvm, ioctl, arg);\n\t}\nout:\n\treturn r;\n}"
  },
  {
    "function_name": "kvm_vm_ioctl_enable_cap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "3745-3785",
    "snippet": "static int kvm_vm_ioctl_enable_cap(struct kvm *kvm,\n\t\t\t\t   struct kvm_enable_cap *cap)\n{\n\tint r;\n\n\tif (cap->flags)\n\t\treturn -EINVAL;\n\n\tswitch (cap->cap) {\n\tcase KVM_CAP_DISABLE_QUIRKS:\n\t\tkvm->arch.disabled_quirks = cap->args[0];\n\t\tr = 0;\n\t\tbreak;\n\tcase KVM_CAP_SPLIT_IRQCHIP: {\n\t\tmutex_lock(&kvm->lock);\n\t\tr = -EINVAL;\n\t\tif (cap->args[0] > MAX_NR_RESERVED_IOAPIC_PINS)\n\t\t\tgoto split_irqchip_unlock;\n\t\tr = -EEXIST;\n\t\tif (irqchip_in_kernel(kvm))\n\t\t\tgoto split_irqchip_unlock;\n\t\tif (atomic_read(&kvm->online_vcpus))\n\t\t\tgoto split_irqchip_unlock;\n\t\tr = kvm_setup_empty_irq_routing(kvm);\n\t\tif (r)\n\t\t\tgoto split_irqchip_unlock;\n\t\t/* Pairs with irqchip_in_kernel. */\n\t\tsmp_wmb();\n\t\tkvm->arch.irqchip_split = true;\n\t\tkvm->arch.nr_reserved_ioapic_pins = cap->args[0];\n\t\tr = 0;\nsplit_irqchip_unlock:\n\t\tmutex_unlock(&kvm->lock);\n\t\tbreak;\n\t}\n\tdefault:\n\t\tr = -EINVAL;\n\t\tbreak;\n\t}\n\treturn r;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&kvm->lock"
          ],
          "line": 3777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_wmb",
          "args": [],
          "line": 3772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_setup_empty_irq_routing",
          "args": [
            "kvm"
          ],
          "line": 3768
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_setup_empty_irq_routing",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/irq_comm.c",
          "lines": "364-367",
          "snippet": "int kvm_setup_empty_irq_routing(struct kvm *kvm)\n{\n\treturn kvm_set_irq_routing(kvm, empty_routing, 0, 0);\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"hyperv.h\"",
            "#include \"lapic.h\"",
            "#include \"ioapic.h\"",
            "#include \"irq.h\"",
            "#include <asm/msidef.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct kvm_irq_routing_entry empty_routing[] = {};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"hyperv.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include \"irq.h\"\n#include <asm/msidef.h>\n#include <trace/events/kvm.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nstatic const struct kvm_irq_routing_entry empty_routing[] = {};\n\nint kvm_setup_empty_irq_routing(struct kvm *kvm)\n{\n\treturn kvm_set_irq_routing(kvm, empty_routing, 0, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&kvm->online_vcpus"
          ],
          "line": 3766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irqchip_in_kernel",
          "args": [
            "kvm"
          ],
          "line": 3764
        },
        "resolved": true,
        "details": {
          "function_name": "irqchip_in_kernel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/irq.h",
          "lines": "99-110",
          "snippet": "static inline int irqchip_in_kernel(struct kvm *kvm)\n{\n\tstruct kvm_pic *vpic = pic_irqchip(kvm);\n\tbool ret;\n\n\tret = (vpic != NULL);\n\tret |= irqchip_split(kvm);\n\n\t/* Read vpic before kvm->irq_routing.  */\n\tsmp_rmb();\n\treturn ret;\n}",
          "includes": [
            "#include \"lapic.h\"",
            "#include \"ioapic.h\"",
            "#include <kvm/iodev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/mm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <kvm/iodev.h>\n#include <linux/spinlock.h>\n#include <linux/kvm_host.h>\n#include <linux/hrtimer.h>\n#include <linux/mm_types.h>\n\nstatic inline int irqchip_in_kernel(struct kvm *kvm)\n{\n\tstruct kvm_pic *vpic = pic_irqchip(kvm);\n\tbool ret;\n\n\tret = (vpic != NULL);\n\tret |= irqchip_split(kvm);\n\n\t/* Read vpic before kvm->irq_routing.  */\n\tsmp_rmb();\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&kvm->lock"
          ],
          "line": 3759
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int kvm_vm_ioctl_enable_cap(struct kvm *kvm,\n\t\t\t\t   struct kvm_enable_cap *cap)\n{\n\tint r;\n\n\tif (cap->flags)\n\t\treturn -EINVAL;\n\n\tswitch (cap->cap) {\n\tcase KVM_CAP_DISABLE_QUIRKS:\n\t\tkvm->arch.disabled_quirks = cap->args[0];\n\t\tr = 0;\n\t\tbreak;\n\tcase KVM_CAP_SPLIT_IRQCHIP: {\n\t\tmutex_lock(&kvm->lock);\n\t\tr = -EINVAL;\n\t\tif (cap->args[0] > MAX_NR_RESERVED_IOAPIC_PINS)\n\t\t\tgoto split_irqchip_unlock;\n\t\tr = -EEXIST;\n\t\tif (irqchip_in_kernel(kvm))\n\t\t\tgoto split_irqchip_unlock;\n\t\tif (atomic_read(&kvm->online_vcpus))\n\t\t\tgoto split_irqchip_unlock;\n\t\tr = kvm_setup_empty_irq_routing(kvm);\n\t\tif (r)\n\t\t\tgoto split_irqchip_unlock;\n\t\t/* Pairs with irqchip_in_kernel. */\n\t\tsmp_wmb();\n\t\tkvm->arch.irqchip_split = true;\n\t\tkvm->arch.nr_reserved_ioapic_pins = cap->args[0];\n\t\tr = 0;\nsplit_irqchip_unlock:\n\t\tmutex_unlock(&kvm->lock);\n\t\tbreak;\n\t}\n\tdefault:\n\t\tr = -EINVAL;\n\t\tbreak;\n\t}\n\treturn r;\n}"
  },
  {
    "function_name": "kvm_vm_ioctl_irq_line",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "3733-3743",
    "snippet": "int kvm_vm_ioctl_irq_line(struct kvm *kvm, struct kvm_irq_level *irq_event,\n\t\t\tbool line_status)\n{\n\tif (!irqchip_in_kernel(kvm))\n\t\treturn -ENXIO;\n\n\tirq_event->status = kvm_set_irq(kvm, KVM_USERSPACE_IRQ_SOURCE_ID,\n\t\t\t\t\tirq_event->irq, irq_event->level,\n\t\t\t\t\tline_status);\n\treturn 0;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_set_irq",
          "args": [
            "kvm",
            "KVM_USERSPACE_IRQ_SOURCE_ID",
            "irq_event->irq",
            "irq_event->level",
            "line_status"
          ],
          "line": 3739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irqchip_in_kernel",
          "args": [
            "kvm"
          ],
          "line": 3736
        },
        "resolved": true,
        "details": {
          "function_name": "irqchip_in_kernel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/irq.h",
          "lines": "99-110",
          "snippet": "static inline int irqchip_in_kernel(struct kvm *kvm)\n{\n\tstruct kvm_pic *vpic = pic_irqchip(kvm);\n\tbool ret;\n\n\tret = (vpic != NULL);\n\tret |= irqchip_split(kvm);\n\n\t/* Read vpic before kvm->irq_routing.  */\n\tsmp_rmb();\n\treturn ret;\n}",
          "includes": [
            "#include \"lapic.h\"",
            "#include \"ioapic.h\"",
            "#include <kvm/iodev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/mm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <kvm/iodev.h>\n#include <linux/spinlock.h>\n#include <linux/kvm_host.h>\n#include <linux/hrtimer.h>\n#include <linux/mm_types.h>\n\nstatic inline int irqchip_in_kernel(struct kvm *kvm)\n{\n\tstruct kvm_pic *vpic = pic_irqchip(kvm);\n\tbool ret;\n\n\tret = (vpic != NULL);\n\tret |= irqchip_split(kvm);\n\n\t/* Read vpic before kvm->irq_routing.  */\n\tsmp_rmb();\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nint kvm_vm_ioctl_irq_line(struct kvm *kvm, struct kvm_irq_level *irq_event,\n\t\t\tbool line_status)\n{\n\tif (!irqchip_in_kernel(kvm))\n\t\treturn -ENXIO;\n\n\tirq_event->status = kvm_set_irq(kvm, KVM_USERSPACE_IRQ_SOURCE_ID,\n\t\t\t\t\tirq_event->irq, irq_event->level,\n\t\t\t\t\tline_status);\n\treturn 0;\n}"
  },
  {
    "function_name": "kvm_vm_ioctl_get_dirty_log",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "3706-3731",
    "snippet": "int kvm_vm_ioctl_get_dirty_log(struct kvm *kvm, struct kvm_dirty_log *log)\n{\n\tbool is_dirty = false;\n\tint r;\n\n\tmutex_lock(&kvm->slots_lock);\n\n\t/*\n\t * Flush potentially hardware-cached dirty pages to dirty_bitmap.\n\t */\n\tif (kvm_x86_ops->flush_log_dirty)\n\t\tkvm_x86_ops->flush_log_dirty(kvm);\n\n\tr = kvm_get_dirty_log_protect(kvm, log, &is_dirty);\n\n\t/*\n\t * All the TLBs can be flushed out of mmu lock, see the comments in\n\t * kvm_mmu_slot_remove_write_access().\n\t */\n\tlockdep_assert_held(&kvm->slots_lock);\n\tif (is_dirty)\n\t\tkvm_flush_remote_tlbs(kvm);\n\n\tmutex_unlock(&kvm->slots_lock);\n\treturn r;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct kvm_x86_ops *kvm_x86_ops"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&kvm->slots_lock"
          ],
          "line": 3729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_flush_remote_tlbs",
          "args": [
            "kvm"
          ],
          "line": 3727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&kvm->slots_lock"
          ],
          "line": 3725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_get_dirty_log_protect",
          "args": [
            "kvm",
            "log",
            "&is_dirty"
          ],
          "line": 3719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_x86_ops->flush_log_dirty",
          "args": [
            "kvm"
          ],
          "line": 3717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&kvm->slots_lock"
          ],
          "line": 3711
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstruct kvm_x86_ops *kvm_x86_ops;\n\nint kvm_vm_ioctl_get_dirty_log(struct kvm *kvm, struct kvm_dirty_log *log)\n{\n\tbool is_dirty = false;\n\tint r;\n\n\tmutex_lock(&kvm->slots_lock);\n\n\t/*\n\t * Flush potentially hardware-cached dirty pages to dirty_bitmap.\n\t */\n\tif (kvm_x86_ops->flush_log_dirty)\n\t\tkvm_x86_ops->flush_log_dirty(kvm);\n\n\tr = kvm_get_dirty_log_protect(kvm, log, &is_dirty);\n\n\t/*\n\t * All the TLBs can be flushed out of mmu lock, see the comments in\n\t * kvm_mmu_slot_remove_write_access().\n\t */\n\tlockdep_assert_held(&kvm->slots_lock);\n\tif (is_dirty)\n\t\tkvm_flush_remote_tlbs(kvm);\n\n\tmutex_unlock(&kvm->slots_lock);\n\treturn r;\n}"
  },
  {
    "function_name": "kvm_vm_ioctl_reinject",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "3668-3685",
    "snippet": "static int kvm_vm_ioctl_reinject(struct kvm *kvm,\n\t\t\t\t struct kvm_reinject_control *control)\n{\n\tstruct kvm_pit *pit = kvm->arch.vpit;\n\n\tif (!pit)\n\t\treturn -ENXIO;\n\n\t/* pit->pit_state.lock was overloaded to prevent userspace from getting\n\t * an inconsistent state after running multiple KVM_REINJECT_CONTROL\n\t * ioctls in parallel.  Use a separate lock if that ioctl isn't rare.\n\t */\n\tmutex_lock(&pit->pit_state.lock);\n\tkvm_pit_set_reinject(pit, control->pit_reinject);\n\tmutex_unlock(&pit->pit_state.lock);\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&pit->pit_state.lock"
          ],
          "line": 3682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_pit_set_reinject",
          "args": [
            "pit",
            "control->pit_reinject"
          ],
          "line": 3681
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_pit_set_reinject",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/i8254.c",
          "lines": "290-309",
          "snippet": "void kvm_pit_set_reinject(struct kvm_pit *pit, bool reinject)\n{\n\tstruct kvm_kpit_state *ps = &pit->pit_state;\n\tstruct kvm *kvm = pit->kvm;\n\n\tif (atomic_read(&ps->reinject) == reinject)\n\t\treturn;\n\n\tif (reinject) {\n\t\t/* The initial state is preserved while ps->reinject == 0. */\n\t\tkvm_pit_reset_reinject(pit);\n\t\tkvm_register_irq_ack_notifier(kvm, &ps->irq_ack_notifier);\n\t\tkvm_register_irq_mask_notifier(kvm, 0, &pit->mask_notifier);\n\t} else {\n\t\tkvm_unregister_irq_ack_notifier(kvm, &ps->irq_ack_notifier);\n\t\tkvm_unregister_irq_mask_notifier(kvm, 0, &pit->mask_notifier);\n\t}\n\n\tatomic_set(&ps->reinject, reinject);\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"i8254.h\"",
            "#include \"irq.h\"",
            "#include \"ioapic.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"i8254.h\"\n#include \"irq.h\"\n#include \"ioapic.h\"\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nvoid kvm_pit_set_reinject(struct kvm_pit *pit, bool reinject)\n{\n\tstruct kvm_kpit_state *ps = &pit->pit_state;\n\tstruct kvm *kvm = pit->kvm;\n\n\tif (atomic_read(&ps->reinject) == reinject)\n\t\treturn;\n\n\tif (reinject) {\n\t\t/* The initial state is preserved while ps->reinject == 0. */\n\t\tkvm_pit_reset_reinject(pit);\n\t\tkvm_register_irq_ack_notifier(kvm, &ps->irq_ack_notifier);\n\t\tkvm_register_irq_mask_notifier(kvm, 0, &pit->mask_notifier);\n\t} else {\n\t\tkvm_unregister_irq_ack_notifier(kvm, &ps->irq_ack_notifier);\n\t\tkvm_unregister_irq_mask_notifier(kvm, 0, &pit->mask_notifier);\n\t}\n\n\tatomic_set(&ps->reinject, reinject);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&pit->pit_state.lock"
          ],
          "line": 3680
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int kvm_vm_ioctl_reinject(struct kvm *kvm,\n\t\t\t\t struct kvm_reinject_control *control)\n{\n\tstruct kvm_pit *pit = kvm->arch.vpit;\n\n\tif (!pit)\n\t\treturn -ENXIO;\n\n\t/* pit->pit_state.lock was overloaded to prevent userspace from getting\n\t * an inconsistent state after running multiple KVM_REINJECT_CONTROL\n\t * ioctls in parallel.  Use a separate lock if that ioctl isn't rare.\n\t */\n\tmutex_lock(&pit->pit_state.lock);\n\tkvm_pit_set_reinject(pit, control->pit_reinject);\n\tmutex_unlock(&pit->pit_state.lock);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "kvm_vm_ioctl_set_pit2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "3646-3666",
    "snippet": "static int kvm_vm_ioctl_set_pit2(struct kvm *kvm, struct kvm_pit_state2 *ps)\n{\n\tint start = 0;\n\tint i;\n\tu32 prev_legacy, cur_legacy;\n\tstruct kvm_pit *pit = kvm->arch.vpit;\n\n\tmutex_lock(&pit->pit_state.lock);\n\tprev_legacy = pit->pit_state.flags & KVM_PIT_FLAGS_HPET_LEGACY;\n\tcur_legacy = ps->flags & KVM_PIT_FLAGS_HPET_LEGACY;\n\tif (!prev_legacy && cur_legacy)\n\t\tstart = 1;\n\tmemcpy(&pit->pit_state.channels, &ps->channels,\n\t       sizeof(pit->pit_state.channels));\n\tpit->pit_state.flags = ps->flags;\n\tfor (i = 0; i < 3; i++)\n\t\tkvm_pit_load_count(pit, i, pit->pit_state.channels[i].count,\n\t\t\t\t   start && i == 0);\n\tmutex_unlock(&pit->pit_state.lock);\n\treturn 0;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&pit->pit_state.lock"
          ],
          "line": 3664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_pit_load_count",
          "args": [
            "pit",
            "i",
            "pit->pit_state.channels[i].count",
            "start && i == 0"
          ],
          "line": 3662
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_pit_load_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/i8254.c",
          "lines": "392-409",
          "snippet": "void kvm_pit_load_count(struct kvm_pit *pit, int channel, u32 val,\n\t\tint hpet_legacy_start)\n{\n\tu8 saved_mode;\n\n\tWARN_ON_ONCE(!mutex_is_locked(&pit->pit_state.lock));\n\n\tif (hpet_legacy_start) {\n\t\t/* save existing mode for later reenablement */\n\t\tWARN_ON(channel != 0);\n\t\tsaved_mode = pit->pit_state.channels[0].mode;\n\t\tpit->pit_state.channels[0].mode = 0xff; /* disable timer */\n\t\tpit_load_count(pit, channel, val);\n\t\tpit->pit_state.channels[0].mode = saved_mode;\n\t} else {\n\t\tpit_load_count(pit, channel, val);\n\t}\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"i8254.h\"",
            "#include \"irq.h\"",
            "#include \"ioapic.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"i8254.h\"\n#include \"irq.h\"\n#include \"ioapic.h\"\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nvoid kvm_pit_load_count(struct kvm_pit *pit, int channel, u32 val,\n\t\tint hpet_legacy_start)\n{\n\tu8 saved_mode;\n\n\tWARN_ON_ONCE(!mutex_is_locked(&pit->pit_state.lock));\n\n\tif (hpet_legacy_start) {\n\t\t/* save existing mode for later reenablement */\n\t\tWARN_ON(channel != 0);\n\t\tsaved_mode = pit->pit_state.channels[0].mode;\n\t\tpit->pit_state.channels[0].mode = 0xff; /* disable timer */\n\t\tpit_load_count(pit, channel, val);\n\t\tpit->pit_state.channels[0].mode = saved_mode;\n\t} else {\n\t\tpit_load_count(pit, channel, val);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&pit->pit_state.channels",
            "&ps->channels",
            "sizeof(pit->pit_state.channels)"
          ],
          "line": 3658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&pit->pit_state.lock"
          ],
          "line": 3653
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int kvm_vm_ioctl_set_pit2(struct kvm *kvm, struct kvm_pit_state2 *ps)\n{\n\tint start = 0;\n\tint i;\n\tu32 prev_legacy, cur_legacy;\n\tstruct kvm_pit *pit = kvm->arch.vpit;\n\n\tmutex_lock(&pit->pit_state.lock);\n\tprev_legacy = pit->pit_state.flags & KVM_PIT_FLAGS_HPET_LEGACY;\n\tcur_legacy = ps->flags & KVM_PIT_FLAGS_HPET_LEGACY;\n\tif (!prev_legacy && cur_legacy)\n\t\tstart = 1;\n\tmemcpy(&pit->pit_state.channels, &ps->channels,\n\t       sizeof(pit->pit_state.channels));\n\tpit->pit_state.flags = ps->flags;\n\tfor (i = 0; i < 3; i++)\n\t\tkvm_pit_load_count(pit, i, pit->pit_state.channels[i].count,\n\t\t\t\t   start && i == 0);\n\tmutex_unlock(&pit->pit_state.lock);\n\treturn 0;\n}"
  },
  {
    "function_name": "kvm_vm_ioctl_get_pit2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "3635-3644",
    "snippet": "static int kvm_vm_ioctl_get_pit2(struct kvm *kvm, struct kvm_pit_state2 *ps)\n{\n\tmutex_lock(&kvm->arch.vpit->pit_state.lock);\n\tmemcpy(ps->channels, &kvm->arch.vpit->pit_state.channels,\n\t\tsizeof(ps->channels));\n\tps->flags = kvm->arch.vpit->pit_state.flags;\n\tmutex_unlock(&kvm->arch.vpit->pit_state.lock);\n\tmemset(&ps->reserved, 0, sizeof(ps->reserved));\n\treturn 0;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&ps->reserved",
            "0",
            "sizeof(ps->reserved)"
          ],
          "line": 3642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&kvm->arch.vpit->pit_state.lock"
          ],
          "line": 3641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ps->channels",
            "&kvm->arch.vpit->pit_state.channels",
            "sizeof(ps->channels)"
          ],
          "line": 3638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&kvm->arch.vpit->pit_state.lock"
          ],
          "line": 3637
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int kvm_vm_ioctl_get_pit2(struct kvm *kvm, struct kvm_pit_state2 *ps)\n{\n\tmutex_lock(&kvm->arch.vpit->pit_state.lock);\n\tmemcpy(ps->channels, &kvm->arch.vpit->pit_state.channels,\n\t\tsizeof(ps->channels));\n\tps->flags = kvm->arch.vpit->pit_state.flags;\n\tmutex_unlock(&kvm->arch.vpit->pit_state.lock);\n\tmemset(&ps->reserved, 0, sizeof(ps->reserved));\n\treturn 0;\n}"
  },
  {
    "function_name": "kvm_vm_ioctl_set_pit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "3622-3633",
    "snippet": "static int kvm_vm_ioctl_set_pit(struct kvm *kvm, struct kvm_pit_state *ps)\n{\n\tint i;\n\tstruct kvm_pit *pit = kvm->arch.vpit;\n\n\tmutex_lock(&pit->pit_state.lock);\n\tmemcpy(&pit->pit_state.channels, ps, sizeof(*ps));\n\tfor (i = 0; i < 3; i++)\n\t\tkvm_pit_load_count(pit, i, ps->channels[i].count, 0);\n\tmutex_unlock(&pit->pit_state.lock);\n\treturn 0;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&pit->pit_state.lock"
          ],
          "line": 3631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_pit_load_count",
          "args": [
            "pit",
            "i",
            "ps->channels[i].count",
            "0"
          ],
          "line": 3630
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_pit_load_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/i8254.c",
          "lines": "392-409",
          "snippet": "void kvm_pit_load_count(struct kvm_pit *pit, int channel, u32 val,\n\t\tint hpet_legacy_start)\n{\n\tu8 saved_mode;\n\n\tWARN_ON_ONCE(!mutex_is_locked(&pit->pit_state.lock));\n\n\tif (hpet_legacy_start) {\n\t\t/* save existing mode for later reenablement */\n\t\tWARN_ON(channel != 0);\n\t\tsaved_mode = pit->pit_state.channels[0].mode;\n\t\tpit->pit_state.channels[0].mode = 0xff; /* disable timer */\n\t\tpit_load_count(pit, channel, val);\n\t\tpit->pit_state.channels[0].mode = saved_mode;\n\t} else {\n\t\tpit_load_count(pit, channel, val);\n\t}\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"i8254.h\"",
            "#include \"irq.h\"",
            "#include \"ioapic.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"i8254.h\"\n#include \"irq.h\"\n#include \"ioapic.h\"\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nvoid kvm_pit_load_count(struct kvm_pit *pit, int channel, u32 val,\n\t\tint hpet_legacy_start)\n{\n\tu8 saved_mode;\n\n\tWARN_ON_ONCE(!mutex_is_locked(&pit->pit_state.lock));\n\n\tif (hpet_legacy_start) {\n\t\t/* save existing mode for later reenablement */\n\t\tWARN_ON(channel != 0);\n\t\tsaved_mode = pit->pit_state.channels[0].mode;\n\t\tpit->pit_state.channels[0].mode = 0xff; /* disable timer */\n\t\tpit_load_count(pit, channel, val);\n\t\tpit->pit_state.channels[0].mode = saved_mode;\n\t} else {\n\t\tpit_load_count(pit, channel, val);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&pit->pit_state.channels",
            "ps",
            "sizeof(*ps)"
          ],
          "line": 3628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&pit->pit_state.lock"
          ],
          "line": 3627
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int kvm_vm_ioctl_set_pit(struct kvm *kvm, struct kvm_pit_state *ps)\n{\n\tint i;\n\tstruct kvm_pit *pit = kvm->arch.vpit;\n\n\tmutex_lock(&pit->pit_state.lock);\n\tmemcpy(&pit->pit_state.channels, ps, sizeof(*ps));\n\tfor (i = 0; i < 3; i++)\n\t\tkvm_pit_load_count(pit, i, ps->channels[i].count, 0);\n\tmutex_unlock(&pit->pit_state.lock);\n\treturn 0;\n}"
  },
  {
    "function_name": "kvm_vm_ioctl_get_pit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "3610-3620",
    "snippet": "static int kvm_vm_ioctl_get_pit(struct kvm *kvm, struct kvm_pit_state *ps)\n{\n\tstruct kvm_kpit_state *kps = &kvm->arch.vpit->pit_state;\n\n\tBUILD_BUG_ON(sizeof(*ps) != sizeof(kps->channels));\n\n\tmutex_lock(&kps->lock);\n\tmemcpy(ps, &kps->channels, sizeof(*ps));\n\tmutex_unlock(&kps->lock);\n\treturn 0;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&kps->lock"
          ],
          "line": 3618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ps",
            "&kps->channels",
            "sizeof(*ps)"
          ],
          "line": 3617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&kps->lock"
          ],
          "line": 3616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "sizeof(*ps) != sizeof(kps->channels)"
          ],
          "line": 3614
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int kvm_vm_ioctl_get_pit(struct kvm *kvm, struct kvm_pit_state *ps)\n{\n\tstruct kvm_kpit_state *kps = &kvm->arch.vpit->pit_state;\n\n\tBUILD_BUG_ON(sizeof(*ps) != sizeof(kps->channels));\n\n\tmutex_lock(&kps->lock);\n\tmemcpy(ps, &kps->channels, sizeof(*ps));\n\tmutex_unlock(&kps->lock);\n\treturn 0;\n}"
  },
  {
    "function_name": "kvm_vm_ioctl_set_irqchip",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "3579-3608",
    "snippet": "static int kvm_vm_ioctl_set_irqchip(struct kvm *kvm, struct kvm_irqchip *chip)\n{\n\tint r;\n\n\tr = 0;\n\tswitch (chip->chip_id) {\n\tcase KVM_IRQCHIP_PIC_MASTER:\n\t\tspin_lock(&pic_irqchip(kvm)->lock);\n\t\tmemcpy(&pic_irqchip(kvm)->pics[0],\n\t\t\t&chip->chip.pic,\n\t\t\tsizeof(struct kvm_pic_state));\n\t\tspin_unlock(&pic_irqchip(kvm)->lock);\n\t\tbreak;\n\tcase KVM_IRQCHIP_PIC_SLAVE:\n\t\tspin_lock(&pic_irqchip(kvm)->lock);\n\t\tmemcpy(&pic_irqchip(kvm)->pics[1],\n\t\t\t&chip->chip.pic,\n\t\t\tsizeof(struct kvm_pic_state));\n\t\tspin_unlock(&pic_irqchip(kvm)->lock);\n\t\tbreak;\n\tcase KVM_IRQCHIP_IOAPIC:\n\t\tr = kvm_set_ioapic(kvm, &chip->chip.ioapic);\n\t\tbreak;\n\tdefault:\n\t\tr = -EINVAL;\n\t\tbreak;\n\t}\n\tkvm_pic_update_irq(pic_irqchip(kvm));\n\treturn r;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_pic_update_irq",
          "args": [
            "pic_irqchip(kvm)"
          ],
          "line": 3606
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_pic_update_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/i8259.c",
          "lines": "184-189",
          "snippet": "void kvm_pic_update_irq(struct kvm_pic *s)\n{\n\tpic_lock(s);\n\tpic_update_irq(s);\n\tpic_unlock(s);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/kvm_host.h>",
            "#include \"irq.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nvoid kvm_pic_update_irq(struct kvm_pic *s)\n{\n\tpic_lock(s);\n\tpic_update_irq(s);\n\tpic_unlock(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pic_irqchip",
          "args": [
            "kvm"
          ],
          "line": 3606
        },
        "resolved": true,
        "details": {
          "function_name": "ioapic_irqchip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/ioapic.h",
          "lines": "108-111",
          "snippet": "static inline struct kvm_ioapic *ioapic_irqchip(struct kvm *kvm)\n{\n\treturn kvm->arch.vioapic;\n}",
          "includes": [
            "#include <kvm/iodev.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kvm/iodev.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct kvm_ioapic *ioapic_irqchip(struct kvm *kvm)\n{\n\treturn kvm->arch.vioapic;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_set_ioapic",
          "args": [
            "kvm",
            "&chip->chip.ioapic"
          ],
          "line": 3600
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_set_ioapic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/ioapic.c",
          "lines": "655-669",
          "snippet": "int kvm_set_ioapic(struct kvm *kvm, struct kvm_ioapic_state *state)\n{\n\tstruct kvm_ioapic *ioapic = ioapic_irqchip(kvm);\n\tif (!ioapic)\n\t\treturn -EINVAL;\n\n\tspin_lock(&ioapic->lock);\n\tmemcpy(ioapic, state, sizeof(struct kvm_ioapic_state));\n\tioapic->irr = 0;\n\tioapic->irr_delivered = 0;\n\tkvm_vcpu_request_scan_ioapic(kvm);\n\tkvm_ioapic_inject_all(ioapic, state->irr);\n\tspin_unlock(&ioapic->lock);\n\treturn 0;\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"lapic.h\"",
            "#include \"ioapic.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/processor.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <trace/events/kvm.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/processor.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);\n\nint kvm_set_ioapic(struct kvm *kvm, struct kvm_ioapic_state *state)\n{\n\tstruct kvm_ioapic *ioapic = ioapic_irqchip(kvm);\n\tif (!ioapic)\n\t\treturn -EINVAL;\n\n\tspin_lock(&ioapic->lock);\n\tmemcpy(ioapic, state, sizeof(struct kvm_ioapic_state));\n\tioapic->irr = 0;\n\tioapic->irr_delivered = 0;\n\tkvm_vcpu_request_scan_ioapic(kvm);\n\tkvm_ioapic_inject_all(ioapic, state->irr);\n\tspin_unlock(&ioapic->lock);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&pic_irqchip(kvm)->lock"
          ],
          "line": 3597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&pic_irqchip(kvm)->pics[1]",
            "&chip->chip.pic",
            "sizeof(struct kvm_pic_state)"
          ],
          "line": 3594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&pic_irqchip(kvm)->lock"
          ],
          "line": 3593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&pic_irqchip(kvm)->lock"
          ],
          "line": 3590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&pic_irqchip(kvm)->pics[0]",
            "&chip->chip.pic",
            "sizeof(struct kvm_pic_state)"
          ],
          "line": 3587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&pic_irqchip(kvm)->lock"
          ],
          "line": 3586
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int kvm_vm_ioctl_set_irqchip(struct kvm *kvm, struct kvm_irqchip *chip)\n{\n\tint r;\n\n\tr = 0;\n\tswitch (chip->chip_id) {\n\tcase KVM_IRQCHIP_PIC_MASTER:\n\t\tspin_lock(&pic_irqchip(kvm)->lock);\n\t\tmemcpy(&pic_irqchip(kvm)->pics[0],\n\t\t\t&chip->chip.pic,\n\t\t\tsizeof(struct kvm_pic_state));\n\t\tspin_unlock(&pic_irqchip(kvm)->lock);\n\t\tbreak;\n\tcase KVM_IRQCHIP_PIC_SLAVE:\n\t\tspin_lock(&pic_irqchip(kvm)->lock);\n\t\tmemcpy(&pic_irqchip(kvm)->pics[1],\n\t\t\t&chip->chip.pic,\n\t\t\tsizeof(struct kvm_pic_state));\n\t\tspin_unlock(&pic_irqchip(kvm)->lock);\n\t\tbreak;\n\tcase KVM_IRQCHIP_IOAPIC:\n\t\tr = kvm_set_ioapic(kvm, &chip->chip.ioapic);\n\t\tbreak;\n\tdefault:\n\t\tr = -EINVAL;\n\t\tbreak;\n\t}\n\tkvm_pic_update_irq(pic_irqchip(kvm));\n\treturn r;\n}"
  },
  {
    "function_name": "kvm_vm_ioctl_get_irqchip",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "3553-3577",
    "snippet": "static int kvm_vm_ioctl_get_irqchip(struct kvm *kvm, struct kvm_irqchip *chip)\n{\n\tint r;\n\n\tr = 0;\n\tswitch (chip->chip_id) {\n\tcase KVM_IRQCHIP_PIC_MASTER:\n\t\tmemcpy(&chip->chip.pic,\n\t\t\t&pic_irqchip(kvm)->pics[0],\n\t\t\tsizeof(struct kvm_pic_state));\n\t\tbreak;\n\tcase KVM_IRQCHIP_PIC_SLAVE:\n\t\tmemcpy(&chip->chip.pic,\n\t\t\t&pic_irqchip(kvm)->pics[1],\n\t\t\tsizeof(struct kvm_pic_state));\n\t\tbreak;\n\tcase KVM_IRQCHIP_IOAPIC:\n\t\tr = kvm_get_ioapic(kvm, &chip->chip.ioapic);\n\t\tbreak;\n\tdefault:\n\t\tr = -EINVAL;\n\t\tbreak;\n\t}\n\treturn r;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_get_ioapic",
          "args": [
            "kvm",
            "&chip->chip.ioapic"
          ],
          "line": 3570
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_get_ioapic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/ioapic.c",
          "lines": "642-653",
          "snippet": "int kvm_get_ioapic(struct kvm *kvm, struct kvm_ioapic_state *state)\n{\n\tstruct kvm_ioapic *ioapic = ioapic_irqchip(kvm);\n\tif (!ioapic)\n\t\treturn -EINVAL;\n\n\tspin_lock(&ioapic->lock);\n\tmemcpy(state, ioapic, sizeof(struct kvm_ioapic_state));\n\tstate->irr &= ~ioapic->irr_delivered;\n\tspin_unlock(&ioapic->lock);\n\treturn 0;\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"lapic.h\"",
            "#include \"ioapic.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/processor.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <trace/events/kvm.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/processor.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);\n\nint kvm_get_ioapic(struct kvm *kvm, struct kvm_ioapic_state *state)\n{\n\tstruct kvm_ioapic *ioapic = ioapic_irqchip(kvm);\n\tif (!ioapic)\n\t\treturn -EINVAL;\n\n\tspin_lock(&ioapic->lock);\n\tmemcpy(state, ioapic, sizeof(struct kvm_ioapic_state));\n\tstate->irr &= ~ioapic->irr_delivered;\n\tspin_unlock(&ioapic->lock);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&chip->chip.pic",
            "&pic_irqchip(kvm)->pics[1]",
            "sizeof(struct kvm_pic_state)"
          ],
          "line": 3565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pic_irqchip",
          "args": [
            "kvm"
          ],
          "line": 3566
        },
        "resolved": true,
        "details": {
          "function_name": "ioapic_irqchip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/ioapic.h",
          "lines": "108-111",
          "snippet": "static inline struct kvm_ioapic *ioapic_irqchip(struct kvm *kvm)\n{\n\treturn kvm->arch.vioapic;\n}",
          "includes": [
            "#include <kvm/iodev.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kvm/iodev.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct kvm_ioapic *ioapic_irqchip(struct kvm *kvm)\n{\n\treturn kvm->arch.vioapic;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&chip->chip.pic",
            "&pic_irqchip(kvm)->pics[0]",
            "sizeof(struct kvm_pic_state)"
          ],
          "line": 3560
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int kvm_vm_ioctl_get_irqchip(struct kvm *kvm, struct kvm_irqchip *chip)\n{\n\tint r;\n\n\tr = 0;\n\tswitch (chip->chip_id) {\n\tcase KVM_IRQCHIP_PIC_MASTER:\n\t\tmemcpy(&chip->chip.pic,\n\t\t\t&pic_irqchip(kvm)->pics[0],\n\t\t\tsizeof(struct kvm_pic_state));\n\t\tbreak;\n\tcase KVM_IRQCHIP_PIC_SLAVE:\n\t\tmemcpy(&chip->chip.pic,\n\t\t\t&pic_irqchip(kvm)->pics[1],\n\t\t\tsizeof(struct kvm_pic_state));\n\t\tbreak;\n\tcase KVM_IRQCHIP_IOAPIC:\n\t\tr = kvm_get_ioapic(kvm, &chip->chip.ioapic);\n\t\tbreak;\n\tdefault:\n\t\tr = -EINVAL;\n\t\tbreak;\n\t}\n\treturn r;\n}"
  },
  {
    "function_name": "kvm_vm_ioctl_get_nr_mmu_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "3548-3551",
    "snippet": "static int kvm_vm_ioctl_get_nr_mmu_pages(struct kvm *kvm)\n{\n\treturn kvm->arch.n_max_mmu_pages;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int kvm_vm_ioctl_get_nr_mmu_pages(struct kvm *kvm)\n{\n\treturn kvm->arch.n_max_mmu_pages;\n}"
  },
  {
    "function_name": "kvm_vm_ioctl_set_nr_mmu_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "3533-3546",
    "snippet": "static int kvm_vm_ioctl_set_nr_mmu_pages(struct kvm *kvm,\n\t\t\t\t\t  u32 kvm_nr_mmu_pages)\n{\n\tif (kvm_nr_mmu_pages < KVM_MIN_ALLOC_MMU_PAGES)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&kvm->slots_lock);\n\n\tkvm_mmu_change_mmu_pages(kvm, kvm_nr_mmu_pages);\n\tkvm->arch.n_requested_mmu_pages = kvm_nr_mmu_pages;\n\n\tmutex_unlock(&kvm->slots_lock);\n\treturn 0;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&kvm->slots_lock"
          ],
          "line": 3544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_mmu_change_mmu_pages",
          "args": [
            "kvm",
            "kvm_nr_mmu_pages"
          ],
          "line": 3541
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_change_mmu_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "2431-2450",
          "snippet": "void kvm_mmu_change_mmu_pages(struct kvm *kvm, unsigned int goal_nr_mmu_pages)\n{\n\tLIST_HEAD(invalid_list);\n\n\tspin_lock(&kvm->mmu_lock);\n\n\tif (kvm->arch.n_used_mmu_pages > goal_nr_mmu_pages) {\n\t\t/* Need to free some mmu pages to achieve the goal. */\n\t\twhile (kvm->arch.n_used_mmu_pages > goal_nr_mmu_pages)\n\t\t\tif (!prepare_zap_oldest_mmu_page(kvm, &invalid_list))\n\t\t\t\tbreak;\n\n\t\tkvm_mmu_commit_zap_page(kvm, &invalid_list);\n\t\tgoal_nr_mmu_pages = kvm->arch.n_used_mmu_pages;\n\t}\n\n\tkvm->arch.n_max_mmu_pages = goal_nr_mmu_pages;\n\n\tspin_unlock(&kvm->mmu_lock);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t    struct list_head *invalid_list);",
            "static void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t    struct list_head *invalid_list);\nstatic void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);\n\nvoid kvm_mmu_change_mmu_pages(struct kvm *kvm, unsigned int goal_nr_mmu_pages)\n{\n\tLIST_HEAD(invalid_list);\n\n\tspin_lock(&kvm->mmu_lock);\n\n\tif (kvm->arch.n_used_mmu_pages > goal_nr_mmu_pages) {\n\t\t/* Need to free some mmu pages to achieve the goal. */\n\t\twhile (kvm->arch.n_used_mmu_pages > goal_nr_mmu_pages)\n\t\t\tif (!prepare_zap_oldest_mmu_page(kvm, &invalid_list))\n\t\t\t\tbreak;\n\n\t\tkvm_mmu_commit_zap_page(kvm, &invalid_list);\n\t\tgoal_nr_mmu_pages = kvm->arch.n_used_mmu_pages;\n\t}\n\n\tkvm->arch.n_max_mmu_pages = goal_nr_mmu_pages;\n\n\tspin_unlock(&kvm->mmu_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&kvm->slots_lock"
          ],
          "line": 3539
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int kvm_vm_ioctl_set_nr_mmu_pages(struct kvm *kvm,\n\t\t\t\t\t  u32 kvm_nr_mmu_pages)\n{\n\tif (kvm_nr_mmu_pages < KVM_MIN_ALLOC_MMU_PAGES)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&kvm->slots_lock);\n\n\tkvm_mmu_change_mmu_pages(kvm, kvm_nr_mmu_pages);\n\tkvm->arch.n_requested_mmu_pages = kvm_nr_mmu_pages;\n\n\tmutex_unlock(&kvm->slots_lock);\n\treturn 0;\n}"
  },
  {
    "function_name": "kvm_vm_ioctl_set_identity_map_addr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "3526-3531",
    "snippet": "static int kvm_vm_ioctl_set_identity_map_addr(struct kvm *kvm,\n\t\t\t\t\t      u64 ident_addr)\n{\n\tkvm->arch.ept_identity_map_addr = ident_addr;\n\treturn 0;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int kvm_vm_ioctl_set_identity_map_addr(struct kvm *kvm,\n\t\t\t\t\t      u64 ident_addr)\n{\n\tkvm->arch.ept_identity_map_addr = ident_addr;\n\treturn 0;\n}"
  },
  {
    "function_name": "kvm_vm_ioctl_set_tss_addr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "3516-3524",
    "snippet": "static int kvm_vm_ioctl_set_tss_addr(struct kvm *kvm, unsigned long addr)\n{\n\tint ret;\n\n\tif (addr > (unsigned int)(-3 * PAGE_SIZE))\n\t\treturn -EINVAL;\n\tret = kvm_x86_ops->set_tss_addr(kvm, addr);\n\treturn ret;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct kvm_x86_ops *kvm_x86_ops"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_x86_ops->set_tss_addr",
          "args": [
            "kvm",
            "addr"
          ],
          "line": 3522
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstruct kvm_x86_ops *kvm_x86_ops;\n\nstatic int kvm_vm_ioctl_set_tss_addr(struct kvm *kvm, unsigned long addr)\n{\n\tint ret;\n\n\tif (addr > (unsigned int)(-3 * PAGE_SIZE))\n\t\treturn -EINVAL;\n\tret = kvm_x86_ops->set_tss_addr(kvm, addr);\n\treturn ret;\n}"
  },
  {
    "function_name": "kvm_arch_vcpu_fault",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "3511-3514",
    "snippet": "int kvm_arch_vcpu_fault(struct kvm_vcpu *vcpu, struct vm_fault *vmf)\n{\n\treturn VM_FAULT_SIGBUS;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nint kvm_arch_vcpu_fault(struct kvm_vcpu *vcpu, struct vm_fault *vmf)\n{\n\treturn VM_FAULT_SIGBUS;\n}"
  },
  {
    "function_name": "kvm_arch_vcpu_ioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "3230-3509",
    "snippet": "long kvm_arch_vcpu_ioctl(struct file *filp,\n\t\t\t unsigned int ioctl, unsigned long arg)\n{\n\tstruct kvm_vcpu *vcpu = filp->private_data;\n\tvoid __user *argp = (void __user *)arg;\n\tint r;\n\tunion {\n\t\tstruct kvm_lapic_state *lapic;\n\t\tstruct kvm_xsave *xsave;\n\t\tstruct kvm_xcrs *xcrs;\n\t\tvoid *buffer;\n\t} u;\n\n\tu.buffer = NULL;\n\tswitch (ioctl) {\n\tcase KVM_GET_LAPIC: {\n\t\tr = -EINVAL;\n\t\tif (!lapic_in_kernel(vcpu))\n\t\t\tgoto out;\n\t\tu.lapic = kzalloc(sizeof(struct kvm_lapic_state), GFP_KERNEL);\n\n\t\tr = -ENOMEM;\n\t\tif (!u.lapic)\n\t\t\tgoto out;\n\t\tr = kvm_vcpu_ioctl_get_lapic(vcpu, u.lapic);\n\t\tif (r)\n\t\t\tgoto out;\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(argp, u.lapic, sizeof(struct kvm_lapic_state)))\n\t\t\tgoto out;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_SET_LAPIC: {\n\t\tr = -EINVAL;\n\t\tif (!lapic_in_kernel(vcpu))\n\t\t\tgoto out;\n\t\tu.lapic = memdup_user(argp, sizeof(*u.lapic));\n\t\tif (IS_ERR(u.lapic))\n\t\t\treturn PTR_ERR(u.lapic);\n\n\t\tr = kvm_vcpu_ioctl_set_lapic(vcpu, u.lapic);\n\t\tbreak;\n\t}\n\tcase KVM_INTERRUPT: {\n\t\tstruct kvm_interrupt irq;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&irq, argp, sizeof irq))\n\t\t\tgoto out;\n\t\tr = kvm_vcpu_ioctl_interrupt(vcpu, &irq);\n\t\tbreak;\n\t}\n\tcase KVM_NMI: {\n\t\tr = kvm_vcpu_ioctl_nmi(vcpu);\n\t\tbreak;\n\t}\n\tcase KVM_SMI: {\n\t\tr = kvm_vcpu_ioctl_smi(vcpu);\n\t\tbreak;\n\t}\n\tcase KVM_SET_CPUID: {\n\t\tstruct kvm_cpuid __user *cpuid_arg = argp;\n\t\tstruct kvm_cpuid cpuid;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&cpuid, cpuid_arg, sizeof cpuid))\n\t\t\tgoto out;\n\t\tr = kvm_vcpu_ioctl_set_cpuid(vcpu, &cpuid, cpuid_arg->entries);\n\t\tbreak;\n\t}\n\tcase KVM_SET_CPUID2: {\n\t\tstruct kvm_cpuid2 __user *cpuid_arg = argp;\n\t\tstruct kvm_cpuid2 cpuid;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&cpuid, cpuid_arg, sizeof cpuid))\n\t\t\tgoto out;\n\t\tr = kvm_vcpu_ioctl_set_cpuid2(vcpu, &cpuid,\n\t\t\t\t\t      cpuid_arg->entries);\n\t\tbreak;\n\t}\n\tcase KVM_GET_CPUID2: {\n\t\tstruct kvm_cpuid2 __user *cpuid_arg = argp;\n\t\tstruct kvm_cpuid2 cpuid;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&cpuid, cpuid_arg, sizeof cpuid))\n\t\t\tgoto out;\n\t\tr = kvm_vcpu_ioctl_get_cpuid2(vcpu, &cpuid,\n\t\t\t\t\t      cpuid_arg->entries);\n\t\tif (r)\n\t\t\tgoto out;\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(cpuid_arg, &cpuid, sizeof cpuid))\n\t\t\tgoto out;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_GET_MSRS:\n\t\tr = msr_io(vcpu, argp, do_get_msr, 1);\n\t\tbreak;\n\tcase KVM_SET_MSRS:\n\t\tr = msr_io(vcpu, argp, do_set_msr, 0);\n\t\tbreak;\n\tcase KVM_TPR_ACCESS_REPORTING: {\n\t\tstruct kvm_tpr_access_ctl tac;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&tac, argp, sizeof tac))\n\t\t\tgoto out;\n\t\tr = vcpu_ioctl_tpr_access_reporting(vcpu, &tac);\n\t\tif (r)\n\t\t\tgoto out;\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(argp, &tac, sizeof tac))\n\t\t\tgoto out;\n\t\tr = 0;\n\t\tbreak;\n\t};\n\tcase KVM_SET_VAPIC_ADDR: {\n\t\tstruct kvm_vapic_addr va;\n\n\t\tr = -EINVAL;\n\t\tif (!lapic_in_kernel(vcpu))\n\t\t\tgoto out;\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&va, argp, sizeof va))\n\t\t\tgoto out;\n\t\tr = kvm_lapic_set_vapic_addr(vcpu, va.vapic_addr);\n\t\tbreak;\n\t}\n\tcase KVM_X86_SETUP_MCE: {\n\t\tu64 mcg_cap;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&mcg_cap, argp, sizeof mcg_cap))\n\t\t\tgoto out;\n\t\tr = kvm_vcpu_ioctl_x86_setup_mce(vcpu, mcg_cap);\n\t\tbreak;\n\t}\n\tcase KVM_X86_SET_MCE: {\n\t\tstruct kvm_x86_mce mce;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&mce, argp, sizeof mce))\n\t\t\tgoto out;\n\t\tr = kvm_vcpu_ioctl_x86_set_mce(vcpu, &mce);\n\t\tbreak;\n\t}\n\tcase KVM_GET_VCPU_EVENTS: {\n\t\tstruct kvm_vcpu_events events;\n\n\t\tkvm_vcpu_ioctl_x86_get_vcpu_events(vcpu, &events);\n\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(argp, &events, sizeof(struct kvm_vcpu_events)))\n\t\t\tbreak;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_SET_VCPU_EVENTS: {\n\t\tstruct kvm_vcpu_events events;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&events, argp, sizeof(struct kvm_vcpu_events)))\n\t\t\tbreak;\n\n\t\tr = kvm_vcpu_ioctl_x86_set_vcpu_events(vcpu, &events);\n\t\tbreak;\n\t}\n\tcase KVM_GET_DEBUGREGS: {\n\t\tstruct kvm_debugregs dbgregs;\n\n\t\tkvm_vcpu_ioctl_x86_get_debugregs(vcpu, &dbgregs);\n\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(argp, &dbgregs,\n\t\t\t\t sizeof(struct kvm_debugregs)))\n\t\t\tbreak;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_SET_DEBUGREGS: {\n\t\tstruct kvm_debugregs dbgregs;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&dbgregs, argp,\n\t\t\t\t   sizeof(struct kvm_debugregs)))\n\t\t\tbreak;\n\n\t\tr = kvm_vcpu_ioctl_x86_set_debugregs(vcpu, &dbgregs);\n\t\tbreak;\n\t}\n\tcase KVM_GET_XSAVE: {\n\t\tu.xsave = kzalloc(sizeof(struct kvm_xsave), GFP_KERNEL);\n\t\tr = -ENOMEM;\n\t\tif (!u.xsave)\n\t\t\tbreak;\n\n\t\tkvm_vcpu_ioctl_x86_get_xsave(vcpu, u.xsave);\n\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(argp, u.xsave, sizeof(struct kvm_xsave)))\n\t\t\tbreak;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_SET_XSAVE: {\n\t\tu.xsave = memdup_user(argp, sizeof(*u.xsave));\n\t\tif (IS_ERR(u.xsave))\n\t\t\treturn PTR_ERR(u.xsave);\n\n\t\tr = kvm_vcpu_ioctl_x86_set_xsave(vcpu, u.xsave);\n\t\tbreak;\n\t}\n\tcase KVM_GET_XCRS: {\n\t\tu.xcrs = kzalloc(sizeof(struct kvm_xcrs), GFP_KERNEL);\n\t\tr = -ENOMEM;\n\t\tif (!u.xcrs)\n\t\t\tbreak;\n\n\t\tkvm_vcpu_ioctl_x86_get_xcrs(vcpu, u.xcrs);\n\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(argp, u.xcrs,\n\t\t\t\t sizeof(struct kvm_xcrs)))\n\t\t\tbreak;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_SET_XCRS: {\n\t\tu.xcrs = memdup_user(argp, sizeof(*u.xcrs));\n\t\tif (IS_ERR(u.xcrs))\n\t\t\treturn PTR_ERR(u.xcrs);\n\n\t\tr = kvm_vcpu_ioctl_x86_set_xcrs(vcpu, u.xcrs);\n\t\tbreak;\n\t}\n\tcase KVM_SET_TSC_KHZ: {\n\t\tu32 user_tsc_khz;\n\n\t\tr = -EINVAL;\n\t\tuser_tsc_khz = (u32)arg;\n\n\t\tif (user_tsc_khz >= kvm_max_guest_tsc_khz)\n\t\t\tgoto out;\n\n\t\tif (user_tsc_khz == 0)\n\t\t\tuser_tsc_khz = tsc_khz;\n\n\t\tif (!kvm_set_tsc_khz(vcpu, user_tsc_khz))\n\t\t\tr = 0;\n\n\t\tgoto out;\n\t}\n\tcase KVM_GET_TSC_KHZ: {\n\t\tr = vcpu->arch.virtual_tsc_khz;\n\t\tgoto out;\n\t}\n\tcase KVM_KVMCLOCK_CTRL: {\n\t\tr = kvm_set_guest_paused(vcpu);\n\t\tgoto out;\n\t}\n\tcase KVM_ENABLE_CAP: {\n\t\tstruct kvm_enable_cap cap;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&cap, argp, sizeof(cap)))\n\t\t\tgoto out;\n\t\tr = kvm_vcpu_ioctl_enable_cap(vcpu, &cap);\n\t\tbreak;\n\t}\n\tdefault:\n\t\tr = -EINVAL;\n\t}\nout:\n\tkfree(u.buffer);\n\treturn r;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "u.buffer"
          ],
          "line": 3507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_ioctl_enable_cap",
          "args": [
            "vcpu",
            "&cap"
          ],
          "line": 3500
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_vcpu_ioctl_enable_cap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "3216-3228",
          "snippet": "static int kvm_vcpu_ioctl_enable_cap(struct kvm_vcpu *vcpu,\n\t\t\t\t     struct kvm_enable_cap *cap)\n{\n\tif (cap->flags)\n\t\treturn -EINVAL;\n\n\tswitch (cap->cap) {\n\tcase KVM_CAP_HYPERV_SYNIC:\n\t\treturn kvm_hv_activate_synic(vcpu);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic int kvm_vcpu_ioctl_enable_cap(struct kvm_vcpu *vcpu,\n\t\t\t\t     struct kvm_enable_cap *cap)\n{\n\tif (cap->flags)\n\t\treturn -EINVAL;\n\n\tswitch (cap->cap) {\n\tcase KVM_CAP_HYPERV_SYNIC:\n\t\treturn kvm_hv_activate_synic(vcpu);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&cap",
            "argp",
            "sizeof(cap)"
          ],
          "line": 3498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_set_guest_paused",
          "args": [
            "vcpu"
          ],
          "line": 3491
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_set_guest_paused",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "3207-3214",
          "snippet": "static int kvm_set_guest_paused(struct kvm_vcpu *vcpu)\n{\n\tif (!vcpu->arch.pv_time_enabled)\n\t\treturn -EINVAL;\n\tvcpu->arch.pvclock_set_guest_stopped_request = true;\n\tkvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);\n\treturn 0;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic int kvm_set_guest_paused(struct kvm_vcpu *vcpu)\n{\n\tif (!vcpu->arch.pv_time_enabled)\n\t\treturn -EINVAL;\n\tvcpu->arch.pvclock_set_guest_stopped_request = true;\n\tkvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_set_tsc_khz",
          "args": [
            "vcpu",
            "user_tsc_khz"
          ],
          "line": 3481
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_set_tsc_khz",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "1296-1327",
          "snippet": "static int kvm_set_tsc_khz(struct kvm_vcpu *vcpu, u32 user_tsc_khz)\n{\n\tu32 thresh_lo, thresh_hi;\n\tint use_scaling = 0;\n\n\t/* tsc_khz can be zero if TSC calibration fails */\n\tif (user_tsc_khz == 0) {\n\t\t/* set tsc_scaling_ratio to a safe value */\n\t\tvcpu->arch.tsc_scaling_ratio = kvm_default_tsc_scaling_ratio;\n\t\treturn -1;\n\t}\n\n\t/* Compute a scale to convert nanoseconds in TSC cycles */\n\tkvm_get_time_scale(user_tsc_khz * 1000LL, NSEC_PER_SEC,\n\t\t\t   &vcpu->arch.virtual_tsc_shift,\n\t\t\t   &vcpu->arch.virtual_tsc_mult);\n\tvcpu->arch.virtual_tsc_khz = user_tsc_khz;\n\n\t/*\n\t * Compute the variation in TSC rate which is acceptable\n\t * within the range of tolerance and decide if the\n\t * rate being applied is within that bounds of the hardware\n\t * rate.  If so, no scaling or compensation need be done.\n\t */\n\tthresh_lo = adjust_tsc_khz(tsc_khz, -tsc_tolerance_ppm);\n\tthresh_hi = adjust_tsc_khz(tsc_khz, tsc_tolerance_ppm);\n\tif (user_tsc_khz < thresh_lo || user_tsc_khz > thresh_hi) {\n\t\tpr_debug(\"kvm: requested TSC rate %u falls outside tolerance [%u,%u]\\n\", user_tsc_khz, thresh_lo, thresh_hi);\n\t\tuse_scaling = 1;\n\t}\n\treturn set_tsc_khz(vcpu, user_tsc_khz, use_scaling);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic int kvm_set_tsc_khz(struct kvm_vcpu *vcpu, u32 user_tsc_khz)\n{\n\tu32 thresh_lo, thresh_hi;\n\tint use_scaling = 0;\n\n\t/* tsc_khz can be zero if TSC calibration fails */\n\tif (user_tsc_khz == 0) {\n\t\t/* set tsc_scaling_ratio to a safe value */\n\t\tvcpu->arch.tsc_scaling_ratio = kvm_default_tsc_scaling_ratio;\n\t\treturn -1;\n\t}\n\n\t/* Compute a scale to convert nanoseconds in TSC cycles */\n\tkvm_get_time_scale(user_tsc_khz * 1000LL, NSEC_PER_SEC,\n\t\t\t   &vcpu->arch.virtual_tsc_shift,\n\t\t\t   &vcpu->arch.virtual_tsc_mult);\n\tvcpu->arch.virtual_tsc_khz = user_tsc_khz;\n\n\t/*\n\t * Compute the variation in TSC rate which is acceptable\n\t * within the range of tolerance and decide if the\n\t * rate being applied is within that bounds of the hardware\n\t * rate.  If so, no scaling or compensation need be done.\n\t */\n\tthresh_lo = adjust_tsc_khz(tsc_khz, -tsc_tolerance_ppm);\n\tthresh_hi = adjust_tsc_khz(tsc_khz, tsc_tolerance_ppm);\n\tif (user_tsc_khz < thresh_lo || user_tsc_khz > thresh_hi) {\n\t\tpr_debug(\"kvm: requested TSC rate %u falls outside tolerance [%u,%u]\\n\", user_tsc_khz, thresh_lo, thresh_hi);\n\t\tuse_scaling = 1;\n\t}\n\treturn set_tsc_khz(vcpu, user_tsc_khz, use_scaling);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_ioctl_x86_set_xcrs",
          "args": [
            "vcpu",
            "u.xcrs"
          ],
          "line": 3466
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_vcpu_ioctl_x86_set_xcrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "3178-3199",
          "snippet": "static int kvm_vcpu_ioctl_x86_set_xcrs(struct kvm_vcpu *vcpu,\n\t\t\t\t       struct kvm_xcrs *guest_xcrs)\n{\n\tint i, r = 0;\n\n\tif (!cpu_has_xsave)\n\t\treturn -EINVAL;\n\n\tif (guest_xcrs->nr_xcrs > KVM_MAX_XCRS || guest_xcrs->flags)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < guest_xcrs->nr_xcrs; i++)\n\t\t/* Only support XCR0 currently */\n\t\tif (guest_xcrs->xcrs[i].xcr == XCR_XFEATURE_ENABLED_MASK) {\n\t\t\tr = __kvm_set_xcr(vcpu, XCR_XFEATURE_ENABLED_MASK,\n\t\t\t\tguest_xcrs->xcrs[i].value);\n\t\t\tbreak;\n\t\t}\n\tif (r)\n\t\tr = -EINVAL;\n\treturn r;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic int kvm_vcpu_ioctl_x86_set_xcrs(struct kvm_vcpu *vcpu,\n\t\t\t\t       struct kvm_xcrs *guest_xcrs)\n{\n\tint i, r = 0;\n\n\tif (!cpu_has_xsave)\n\t\treturn -EINVAL;\n\n\tif (guest_xcrs->nr_xcrs > KVM_MAX_XCRS || guest_xcrs->flags)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < guest_xcrs->nr_xcrs; i++)\n\t\t/* Only support XCR0 currently */\n\t\tif (guest_xcrs->xcrs[i].xcr == XCR_XFEATURE_ENABLED_MASK) {\n\t\t\tr = __kvm_set_xcr(vcpu, XCR_XFEATURE_ENABLED_MASK,\n\t\t\t\tguest_xcrs->xcrs[i].value);\n\t\t\tbreak;\n\t\t}\n\tif (r)\n\t\tr = -EINVAL;\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "u.xcrs"
          ],
          "line": 3464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "u.xcrs"
          ],
          "line": 3463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memdup_user",
          "args": [
            "argp",
            "sizeof(*u.xcrs)"
          ],
          "line": 3462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "argp",
            "u.xcrs",
            "sizeof(struct kvm_xcrs)"
          ],
          "line": 3455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_ioctl_x86_get_xcrs",
          "args": [
            "vcpu",
            "u.xcrs"
          ],
          "line": 3452
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_vcpu_ioctl_x86_get_xcrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "3164-3176",
          "snippet": "static void kvm_vcpu_ioctl_x86_get_xcrs(struct kvm_vcpu *vcpu,\n\t\t\t\t\tstruct kvm_xcrs *guest_xcrs)\n{\n\tif (!cpu_has_xsave) {\n\t\tguest_xcrs->nr_xcrs = 0;\n\t\treturn;\n\t}\n\n\tguest_xcrs->nr_xcrs = 1;\n\tguest_xcrs->flags = 0;\n\tguest_xcrs->xcrs[0].xcr = XCR_XFEATURE_ENABLED_MASK;\n\tguest_xcrs->xcrs[0].value = vcpu->arch.xcr0;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic void kvm_vcpu_ioctl_x86_get_xcrs(struct kvm_vcpu *vcpu,\n\t\t\t\t\tstruct kvm_xcrs *guest_xcrs)\n{\n\tif (!cpu_has_xsave) {\n\t\tguest_xcrs->nr_xcrs = 0;\n\t\treturn;\n\t}\n\n\tguest_xcrs->nr_xcrs = 1;\n\tguest_xcrs->flags = 0;\n\tguest_xcrs->xcrs[0].xcr = XCR_XFEATURE_ENABLED_MASK;\n\tguest_xcrs->xcrs[0].value = vcpu->arch.xcr0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct kvm_xcrs)",
            "GFP_KERNEL"
          ],
          "line": 3447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_ioctl_x86_set_xsave",
          "args": [
            "vcpu",
            "u.xsave"
          ],
          "line": 3443
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_vcpu_ioctl_x86_set_xsave",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "3140-3162",
          "snippet": "static int kvm_vcpu_ioctl_x86_set_xsave(struct kvm_vcpu *vcpu,\n\t\t\t\t\tstruct kvm_xsave *guest_xsave)\n{\n\tu64 xstate_bv =\n\t\t*(u64 *)&guest_xsave->region[XSAVE_HDR_OFFSET / sizeof(u32)];\n\n\tif (cpu_has_xsave) {\n\t\t/*\n\t\t * Here we allow setting states that are not present in\n\t\t * CPUID leaf 0xD, index 0, EDX:EAX.  This is for compatibility\n\t\t * with old userspace.\n\t\t */\n\t\tif (xstate_bv & ~kvm_supported_xcr0())\n\t\t\treturn -EINVAL;\n\t\tload_xsave(vcpu, (u8 *)guest_xsave->region);\n\t} else {\n\t\tif (xstate_bv & ~XFEATURE_MASK_FPSSE)\n\t\t\treturn -EINVAL;\n\t\tmemcpy(&vcpu->arch.guest_fpu.state.fxsave,\n\t\t\tguest_xsave->region, sizeof(struct fxregs_state));\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic int kvm_vcpu_ioctl_x86_set_xsave(struct kvm_vcpu *vcpu,\n\t\t\t\t\tstruct kvm_xsave *guest_xsave)\n{\n\tu64 xstate_bv =\n\t\t*(u64 *)&guest_xsave->region[XSAVE_HDR_OFFSET / sizeof(u32)];\n\n\tif (cpu_has_xsave) {\n\t\t/*\n\t\t * Here we allow setting states that are not present in\n\t\t * CPUID leaf 0xD, index 0, EDX:EAX.  This is for compatibility\n\t\t * with old userspace.\n\t\t */\n\t\tif (xstate_bv & ~kvm_supported_xcr0())\n\t\t\treturn -EINVAL;\n\t\tload_xsave(vcpu, (u8 *)guest_xsave->region);\n\t} else {\n\t\tif (xstate_bv & ~XFEATURE_MASK_FPSSE)\n\t\t\treturn -EINVAL;\n\t\tmemcpy(&vcpu->arch.guest_fpu.state.fxsave,\n\t\t\tguest_xsave->region, sizeof(struct fxregs_state));\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "u.xsave"
          ],
          "line": 3441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "u.xsave"
          ],
          "line": 3440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memdup_user",
          "args": [
            "argp",
            "sizeof(*u.xsave)"
          ],
          "line": 3439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "argp",
            "u.xsave",
            "sizeof(struct kvm_xsave)"
          ],
          "line": 3433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_ioctl_x86_get_xsave",
          "args": [
            "vcpu",
            "u.xsave"
          ],
          "line": 3430
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_vcpu_ioctl_x86_get_xsave",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "3125-3138",
          "snippet": "static void kvm_vcpu_ioctl_x86_get_xsave(struct kvm_vcpu *vcpu,\n\t\t\t\t\t struct kvm_xsave *guest_xsave)\n{\n\tif (cpu_has_xsave) {\n\t\tmemset(guest_xsave, 0, sizeof(struct kvm_xsave));\n\t\tfill_xsave((u8 *) guest_xsave->region, vcpu);\n\t} else {\n\t\tmemcpy(guest_xsave->region,\n\t\t\t&vcpu->arch.guest_fpu.state.fxsave,\n\t\t\tsizeof(struct fxregs_state));\n\t\t*(u64 *)&guest_xsave->region[XSAVE_HDR_OFFSET / sizeof(u32)] =\n\t\t\tXFEATURE_MASK_FPSSE;\n\t}\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic void kvm_vcpu_ioctl_x86_get_xsave(struct kvm_vcpu *vcpu,\n\t\t\t\t\t struct kvm_xsave *guest_xsave)\n{\n\tif (cpu_has_xsave) {\n\t\tmemset(guest_xsave, 0, sizeof(struct kvm_xsave));\n\t\tfill_xsave((u8 *) guest_xsave->region, vcpu);\n\t} else {\n\t\tmemcpy(guest_xsave->region,\n\t\t\t&vcpu->arch.guest_fpu.state.fxsave,\n\t\t\tsizeof(struct fxregs_state));\n\t\t*(u64 *)&guest_xsave->region[XSAVE_HDR_OFFSET / sizeof(u32)] =\n\t\t\tXFEATURE_MASK_FPSSE;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct kvm_xsave)",
            "GFP_KERNEL"
          ],
          "line": 3425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_ioctl_x86_set_debugregs",
          "args": [
            "vcpu",
            "&dbgregs"
          ],
          "line": 3421
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_vcpu_ioctl_x86_set_debugregs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "3033-3047",
          "snippet": "static int kvm_vcpu_ioctl_x86_set_debugregs(struct kvm_vcpu *vcpu,\n\t\t\t\t\t    struct kvm_debugregs *dbgregs)\n{\n\tif (dbgregs->flags)\n\t\treturn -EINVAL;\n\n\tmemcpy(vcpu->arch.db, dbgregs->db, sizeof(vcpu->arch.db));\n\tkvm_update_dr0123(vcpu);\n\tvcpu->arch.dr6 = dbgregs->dr6;\n\tkvm_update_dr6(vcpu);\n\tvcpu->arch.dr7 = dbgregs->dr7;\n\tkvm_update_dr7(vcpu);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic int kvm_vcpu_ioctl_x86_set_debugregs(struct kvm_vcpu *vcpu,\n\t\t\t\t\t    struct kvm_debugregs *dbgregs)\n{\n\tif (dbgregs->flags)\n\t\treturn -EINVAL;\n\n\tmemcpy(vcpu->arch.db, dbgregs->db, sizeof(vcpu->arch.db));\n\tkvm_update_dr0123(vcpu);\n\tvcpu->arch.dr6 = dbgregs->dr6;\n\tkvm_update_dr6(vcpu);\n\tvcpu->arch.dr7 = dbgregs->dr7;\n\tkvm_update_dr7(vcpu);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&dbgregs",
            "argp",
            "sizeof(struct kvm_debugregs)"
          ],
          "line": 3417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "argp",
            "&dbgregs",
            "sizeof(struct kvm_debugregs)"
          ],
          "line": 3407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_ioctl_x86_get_debugregs",
          "args": [
            "vcpu",
            "&dbgregs"
          ],
          "line": 3404
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_vcpu_ioctl_x86_get_debugregs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "3020-3031",
          "snippet": "static void kvm_vcpu_ioctl_x86_get_debugregs(struct kvm_vcpu *vcpu,\n\t\t\t\t\t     struct kvm_debugregs *dbgregs)\n{\n\tunsigned long val;\n\n\tmemcpy(dbgregs->db, vcpu->arch.db, sizeof(vcpu->arch.db));\n\tkvm_get_dr(vcpu, 6, &val);\n\tdbgregs->dr6 = val;\n\tdbgregs->dr7 = vcpu->arch.dr7;\n\tdbgregs->flags = 0;\n\tmemset(&dbgregs->reserved, 0, sizeof(dbgregs->reserved));\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic void kvm_vcpu_ioctl_x86_get_debugregs(struct kvm_vcpu *vcpu,\n\t\t\t\t\t     struct kvm_debugregs *dbgregs)\n{\n\tunsigned long val;\n\n\tmemcpy(dbgregs->db, vcpu->arch.db, sizeof(vcpu->arch.db));\n\tkvm_get_dr(vcpu, 6, &val);\n\tdbgregs->dr6 = val;\n\tdbgregs->dr7 = vcpu->arch.dr7;\n\tdbgregs->flags = 0;\n\tmemset(&dbgregs->reserved, 0, sizeof(dbgregs->reserved));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_ioctl_x86_set_vcpu_events",
          "args": [
            "vcpu",
            "&events"
          ],
          "line": 3398
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_vcpu_ioctl_x86_set_vcpu_events",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "2966-3018",
          "snippet": "static int kvm_vcpu_ioctl_x86_set_vcpu_events(struct kvm_vcpu *vcpu,\n\t\t\t\t\t      struct kvm_vcpu_events *events)\n{\n\tif (events->flags & ~(KVM_VCPUEVENT_VALID_NMI_PENDING\n\t\t\t      | KVM_VCPUEVENT_VALID_SIPI_VECTOR\n\t\t\t      | KVM_VCPUEVENT_VALID_SHADOW\n\t\t\t      | KVM_VCPUEVENT_VALID_SMM))\n\t\treturn -EINVAL;\n\n\tprocess_nmi(vcpu);\n\tvcpu->arch.exception.pending = events->exception.injected;\n\tvcpu->arch.exception.nr = events->exception.nr;\n\tvcpu->arch.exception.has_error_code = events->exception.has_error_code;\n\tvcpu->arch.exception.error_code = events->exception.error_code;\n\n\tvcpu->arch.interrupt.pending = events->interrupt.injected;\n\tvcpu->arch.interrupt.nr = events->interrupt.nr;\n\tvcpu->arch.interrupt.soft = events->interrupt.soft;\n\tif (events->flags & KVM_VCPUEVENT_VALID_SHADOW)\n\t\tkvm_x86_ops->set_interrupt_shadow(vcpu,\n\t\t\t\t\t\t  events->interrupt.shadow);\n\n\tvcpu->arch.nmi_injected = events->nmi.injected;\n\tif (events->flags & KVM_VCPUEVENT_VALID_NMI_PENDING)\n\t\tvcpu->arch.nmi_pending = events->nmi.pending;\n\tkvm_x86_ops->set_nmi_mask(vcpu, events->nmi.masked);\n\n\tif (events->flags & KVM_VCPUEVENT_VALID_SIPI_VECTOR &&\n\t    lapic_in_kernel(vcpu))\n\t\tvcpu->arch.apic->sipi_vector = events->sipi_vector;\n\n\tif (events->flags & KVM_VCPUEVENT_VALID_SMM) {\n\t\tif (events->smi.smm)\n\t\t\tvcpu->arch.hflags |= HF_SMM_MASK;\n\t\telse\n\t\t\tvcpu->arch.hflags &= ~HF_SMM_MASK;\n\t\tvcpu->arch.smi_pending = events->smi.pending;\n\t\tif (events->smi.smm_inside_nmi)\n\t\t\tvcpu->arch.hflags |= HF_SMM_INSIDE_NMI_MASK;\n\t\telse\n\t\t\tvcpu->arch.hflags &= ~HF_SMM_INSIDE_NMI_MASK;\n\t\tif (lapic_in_kernel(vcpu)) {\n\t\t\tif (events->smi.latched_init)\n\t\t\t\tset_bit(KVM_APIC_INIT, &vcpu->arch.apic->pending_events);\n\t\t\telse\n\t\t\t\tclear_bit(KVM_APIC_INIT, &vcpu->arch.apic->pending_events);\n\t\t}\n\t}\n\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "struct kvm_x86_ops *kvm_x86_ops"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nstatic int kvm_vcpu_ioctl_x86_set_vcpu_events(struct kvm_vcpu *vcpu,\n\t\t\t\t\t      struct kvm_vcpu_events *events)\n{\n\tif (events->flags & ~(KVM_VCPUEVENT_VALID_NMI_PENDING\n\t\t\t      | KVM_VCPUEVENT_VALID_SIPI_VECTOR\n\t\t\t      | KVM_VCPUEVENT_VALID_SHADOW\n\t\t\t      | KVM_VCPUEVENT_VALID_SMM))\n\t\treturn -EINVAL;\n\n\tprocess_nmi(vcpu);\n\tvcpu->arch.exception.pending = events->exception.injected;\n\tvcpu->arch.exception.nr = events->exception.nr;\n\tvcpu->arch.exception.has_error_code = events->exception.has_error_code;\n\tvcpu->arch.exception.error_code = events->exception.error_code;\n\n\tvcpu->arch.interrupt.pending = events->interrupt.injected;\n\tvcpu->arch.interrupt.nr = events->interrupt.nr;\n\tvcpu->arch.interrupt.soft = events->interrupt.soft;\n\tif (events->flags & KVM_VCPUEVENT_VALID_SHADOW)\n\t\tkvm_x86_ops->set_interrupt_shadow(vcpu,\n\t\t\t\t\t\t  events->interrupt.shadow);\n\n\tvcpu->arch.nmi_injected = events->nmi.injected;\n\tif (events->flags & KVM_VCPUEVENT_VALID_NMI_PENDING)\n\t\tvcpu->arch.nmi_pending = events->nmi.pending;\n\tkvm_x86_ops->set_nmi_mask(vcpu, events->nmi.masked);\n\n\tif (events->flags & KVM_VCPUEVENT_VALID_SIPI_VECTOR &&\n\t    lapic_in_kernel(vcpu))\n\t\tvcpu->arch.apic->sipi_vector = events->sipi_vector;\n\n\tif (events->flags & KVM_VCPUEVENT_VALID_SMM) {\n\t\tif (events->smi.smm)\n\t\t\tvcpu->arch.hflags |= HF_SMM_MASK;\n\t\telse\n\t\t\tvcpu->arch.hflags &= ~HF_SMM_MASK;\n\t\tvcpu->arch.smi_pending = events->smi.pending;\n\t\tif (events->smi.smm_inside_nmi)\n\t\t\tvcpu->arch.hflags |= HF_SMM_INSIDE_NMI_MASK;\n\t\telse\n\t\t\tvcpu->arch.hflags &= ~HF_SMM_INSIDE_NMI_MASK;\n\t\tif (lapic_in_kernel(vcpu)) {\n\t\t\tif (events->smi.latched_init)\n\t\t\t\tset_bit(KVM_APIC_INIT, &vcpu->arch.apic->pending_events);\n\t\t\telse\n\t\t\t\tclear_bit(KVM_APIC_INIT, &vcpu->arch.apic->pending_events);\n\t\t}\n\t}\n\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&events",
            "argp",
            "sizeof(struct kvm_vcpu_events)"
          ],
          "line": 3395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "argp",
            "&events",
            "sizeof(struct kvm_vcpu_events)"
          ],
          "line": 3386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_ioctl_x86_get_vcpu_events",
          "args": [
            "vcpu",
            "&events"
          ],
          "line": 3383
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_vcpu_ioctl_x86_get_vcpu_events",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "2929-2964",
          "snippet": "static void kvm_vcpu_ioctl_x86_get_vcpu_events(struct kvm_vcpu *vcpu,\n\t\t\t\t\t       struct kvm_vcpu_events *events)\n{\n\tprocess_nmi(vcpu);\n\tevents->exception.injected =\n\t\tvcpu->arch.exception.pending &&\n\t\t!kvm_exception_is_soft(vcpu->arch.exception.nr);\n\tevents->exception.nr = vcpu->arch.exception.nr;\n\tevents->exception.has_error_code = vcpu->arch.exception.has_error_code;\n\tevents->exception.pad = 0;\n\tevents->exception.error_code = vcpu->arch.exception.error_code;\n\n\tevents->interrupt.injected =\n\t\tvcpu->arch.interrupt.pending && !vcpu->arch.interrupt.soft;\n\tevents->interrupt.nr = vcpu->arch.interrupt.nr;\n\tevents->interrupt.soft = 0;\n\tevents->interrupt.shadow = kvm_x86_ops->get_interrupt_shadow(vcpu);\n\n\tevents->nmi.injected = vcpu->arch.nmi_injected;\n\tevents->nmi.pending = vcpu->arch.nmi_pending != 0;\n\tevents->nmi.masked = kvm_x86_ops->get_nmi_mask(vcpu);\n\tevents->nmi.pad = 0;\n\n\tevents->sipi_vector = 0; /* never valid when reporting to user space */\n\n\tevents->smi.smm = is_smm(vcpu);\n\tevents->smi.pending = vcpu->arch.smi_pending;\n\tevents->smi.smm_inside_nmi =\n\t\t!!(vcpu->arch.hflags & HF_SMM_INSIDE_NMI_MASK);\n\tevents->smi.latched_init = kvm_lapic_latched_init(vcpu);\n\n\tevents->flags = (KVM_VCPUEVENT_VALID_NMI_PENDING\n\t\t\t | KVM_VCPUEVENT_VALID_SHADOW\n\t\t\t | KVM_VCPUEVENT_VALID_SMM);\n\tmemset(&events->reserved, 0, sizeof(events->reserved));\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "struct kvm_x86_ops *kvm_x86_ops"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nstatic void kvm_vcpu_ioctl_x86_get_vcpu_events(struct kvm_vcpu *vcpu,\n\t\t\t\t\t       struct kvm_vcpu_events *events)\n{\n\tprocess_nmi(vcpu);\n\tevents->exception.injected =\n\t\tvcpu->arch.exception.pending &&\n\t\t!kvm_exception_is_soft(vcpu->arch.exception.nr);\n\tevents->exception.nr = vcpu->arch.exception.nr;\n\tevents->exception.has_error_code = vcpu->arch.exception.has_error_code;\n\tevents->exception.pad = 0;\n\tevents->exception.error_code = vcpu->arch.exception.error_code;\n\n\tevents->interrupt.injected =\n\t\tvcpu->arch.interrupt.pending && !vcpu->arch.interrupt.soft;\n\tevents->interrupt.nr = vcpu->arch.interrupt.nr;\n\tevents->interrupt.soft = 0;\n\tevents->interrupt.shadow = kvm_x86_ops->get_interrupt_shadow(vcpu);\n\n\tevents->nmi.injected = vcpu->arch.nmi_injected;\n\tevents->nmi.pending = vcpu->arch.nmi_pending != 0;\n\tevents->nmi.masked = kvm_x86_ops->get_nmi_mask(vcpu);\n\tevents->nmi.pad = 0;\n\n\tevents->sipi_vector = 0; /* never valid when reporting to user space */\n\n\tevents->smi.smm = is_smm(vcpu);\n\tevents->smi.pending = vcpu->arch.smi_pending;\n\tevents->smi.smm_inside_nmi =\n\t\t!!(vcpu->arch.hflags & HF_SMM_INSIDE_NMI_MASK);\n\tevents->smi.latched_init = kvm_lapic_latched_init(vcpu);\n\n\tevents->flags = (KVM_VCPUEVENT_VALID_NMI_PENDING\n\t\t\t | KVM_VCPUEVENT_VALID_SHADOW\n\t\t\t | KVM_VCPUEVENT_VALID_SMM);\n\tmemset(&events->reserved, 0, sizeof(events->reserved));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_ioctl_x86_set_mce",
          "args": [
            "vcpu",
            "&mce"
          ],
          "line": 3377
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_vcpu_ioctl_x86_set_mce",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "2881-2927",
          "snippet": "static int kvm_vcpu_ioctl_x86_set_mce(struct kvm_vcpu *vcpu,\n\t\t\t\t      struct kvm_x86_mce *mce)\n{\n\tu64 mcg_cap = vcpu->arch.mcg_cap;\n\tunsigned bank_num = mcg_cap & 0xff;\n\tu64 *banks = vcpu->arch.mce_banks;\n\n\tif (mce->bank >= bank_num || !(mce->status & MCI_STATUS_VAL))\n\t\treturn -EINVAL;\n\t/*\n\t * if IA32_MCG_CTL is not all 1s, the uncorrected error\n\t * reporting is disabled\n\t */\n\tif ((mce->status & MCI_STATUS_UC) && (mcg_cap & MCG_CTL_P) &&\n\t    vcpu->arch.mcg_ctl != ~(u64)0)\n\t\treturn 0;\n\tbanks += 4 * mce->bank;\n\t/*\n\t * if IA32_MCi_CTL is not all 1s, the uncorrected error\n\t * reporting is disabled for the bank\n\t */\n\tif ((mce->status & MCI_STATUS_UC) && banks[0] != ~(u64)0)\n\t\treturn 0;\n\tif (mce->status & MCI_STATUS_UC) {\n\t\tif ((vcpu->arch.mcg_status & MCG_STATUS_MCIP) ||\n\t\t    !kvm_read_cr4_bits(vcpu, X86_CR4_MCE)) {\n\t\t\tkvm_make_request(KVM_REQ_TRIPLE_FAULT, vcpu);\n\t\t\treturn 0;\n\t\t}\n\t\tif (banks[1] & MCI_STATUS_VAL)\n\t\t\tmce->status |= MCI_STATUS_OVER;\n\t\tbanks[2] = mce->addr;\n\t\tbanks[3] = mce->misc;\n\t\tvcpu->arch.mcg_status = mce->mcg_status;\n\t\tbanks[1] = mce->status;\n\t\tkvm_queue_exception(vcpu, MC_VECTOR);\n\t} else if (!(banks[1] & MCI_STATUS_VAL)\n\t\t   || !(banks[1] & MCI_STATUS_UC)) {\n\t\tif (banks[1] & MCI_STATUS_VAL)\n\t\t\tmce->status |= MCI_STATUS_OVER;\n\t\tbanks[2] = mce->addr;\n\t\tbanks[3] = mce->misc;\n\t\tbanks[1] = mce->status;\n\t} else\n\t\tbanks[1] |= MCI_STATUS_OVER;\n\treturn 0;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic int kvm_vcpu_ioctl_x86_set_mce(struct kvm_vcpu *vcpu,\n\t\t\t\t      struct kvm_x86_mce *mce)\n{\n\tu64 mcg_cap = vcpu->arch.mcg_cap;\n\tunsigned bank_num = mcg_cap & 0xff;\n\tu64 *banks = vcpu->arch.mce_banks;\n\n\tif (mce->bank >= bank_num || !(mce->status & MCI_STATUS_VAL))\n\t\treturn -EINVAL;\n\t/*\n\t * if IA32_MCG_CTL is not all 1s, the uncorrected error\n\t * reporting is disabled\n\t */\n\tif ((mce->status & MCI_STATUS_UC) && (mcg_cap & MCG_CTL_P) &&\n\t    vcpu->arch.mcg_ctl != ~(u64)0)\n\t\treturn 0;\n\tbanks += 4 * mce->bank;\n\t/*\n\t * if IA32_MCi_CTL is not all 1s, the uncorrected error\n\t * reporting is disabled for the bank\n\t */\n\tif ((mce->status & MCI_STATUS_UC) && banks[0] != ~(u64)0)\n\t\treturn 0;\n\tif (mce->status & MCI_STATUS_UC) {\n\t\tif ((vcpu->arch.mcg_status & MCG_STATUS_MCIP) ||\n\t\t    !kvm_read_cr4_bits(vcpu, X86_CR4_MCE)) {\n\t\t\tkvm_make_request(KVM_REQ_TRIPLE_FAULT, vcpu);\n\t\t\treturn 0;\n\t\t}\n\t\tif (banks[1] & MCI_STATUS_VAL)\n\t\t\tmce->status |= MCI_STATUS_OVER;\n\t\tbanks[2] = mce->addr;\n\t\tbanks[3] = mce->misc;\n\t\tvcpu->arch.mcg_status = mce->mcg_status;\n\t\tbanks[1] = mce->status;\n\t\tkvm_queue_exception(vcpu, MC_VECTOR);\n\t} else if (!(banks[1] & MCI_STATUS_VAL)\n\t\t   || !(banks[1] & MCI_STATUS_UC)) {\n\t\tif (banks[1] & MCI_STATUS_VAL)\n\t\t\tmce->status |= MCI_STATUS_OVER;\n\t\tbanks[2] = mce->addr;\n\t\tbanks[3] = mce->misc;\n\t\tbanks[1] = mce->status;\n\t} else\n\t\tbanks[1] |= MCI_STATUS_OVER;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&mce",
            "argp",
            "sizeof mce"
          ],
          "line": 3375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_ioctl_x86_setup_mce",
          "args": [
            "vcpu",
            "mcg_cap"
          ],
          "line": 3368
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_vcpu_ioctl_x86_setup_mce",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "2858-2879",
          "snippet": "static int kvm_vcpu_ioctl_x86_setup_mce(struct kvm_vcpu *vcpu,\n\t\t\t\t\tu64 mcg_cap)\n{\n\tint r;\n\tunsigned bank_num = mcg_cap & 0xff, bank;\n\n\tr = -EINVAL;\n\tif (!bank_num || bank_num >= KVM_MAX_MCE_BANKS)\n\t\tgoto out;\n\tif (mcg_cap & ~(KVM_MCE_CAP_SUPPORTED | 0xff | 0xff0000))\n\t\tgoto out;\n\tr = 0;\n\tvcpu->arch.mcg_cap = mcg_cap;\n\t/* Init IA32_MCG_CTL to all 1s */\n\tif (mcg_cap & MCG_CTL_P)\n\t\tvcpu->arch.mcg_ctl = ~(u64)0;\n\t/* Init IA32_MCi_CTL to all 1s */\n\tfor (bank = 0; bank < bank_num; bank++)\n\t\tvcpu->arch.mce_banks[bank*4] = ~(u64)0;\nout:\n\treturn r;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define KVM_MCE_CAP_SUPPORTED (MCG_CTL_P | MCG_SER_P)",
            "#define KVM_MAX_MCE_BANKS 32"
          ],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define KVM_MCE_CAP_SUPPORTED (MCG_CTL_P | MCG_SER_P)\n#define KVM_MAX_MCE_BANKS 32\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic int kvm_vcpu_ioctl_x86_setup_mce(struct kvm_vcpu *vcpu,\n\t\t\t\t\tu64 mcg_cap)\n{\n\tint r;\n\tunsigned bank_num = mcg_cap & 0xff, bank;\n\n\tr = -EINVAL;\n\tif (!bank_num || bank_num >= KVM_MAX_MCE_BANKS)\n\t\tgoto out;\n\tif (mcg_cap & ~(KVM_MCE_CAP_SUPPORTED | 0xff | 0xff0000))\n\t\tgoto out;\n\tr = 0;\n\tvcpu->arch.mcg_cap = mcg_cap;\n\t/* Init IA32_MCG_CTL to all 1s */\n\tif (mcg_cap & MCG_CTL_P)\n\t\tvcpu->arch.mcg_ctl = ~(u64)0;\n\t/* Init IA32_MCi_CTL to all 1s */\n\tfor (bank = 0; bank < bank_num; bank++)\n\t\tvcpu->arch.mce_banks[bank*4] = ~(u64)0;\nout:\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&mcg_cap",
            "argp",
            "sizeof mcg_cap"
          ],
          "line": 3366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_lapic_set_vapic_addr",
          "args": [
            "vcpu",
            "va.vapic_addr"
          ],
          "line": 3359
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_set_vapic_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "2094-2108",
          "snippet": "int kvm_lapic_set_vapic_addr(struct kvm_vcpu *vcpu, gpa_t vapic_addr)\n{\n\tif (vapic_addr) {\n\t\tif (kvm_gfn_to_hva_cache_init(vcpu->kvm,\n\t\t\t\t\t&vcpu->arch.apic->vapic_cache,\n\t\t\t\t\tvapic_addr, sizeof(u32)))\n\t\t\treturn -EINVAL;\n\t\t__set_bit(KVM_APIC_CHECK_VAPIC, &vcpu->arch.apic_attention);\n\t} else {\n\t\t__clear_bit(KVM_APIC_CHECK_VAPIC, &vcpu->arch.apic_attention);\n\t}\n\n\tvcpu->arch.apic->vapic_addr = vapic_addr;\n\treturn 0;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nint kvm_lapic_set_vapic_addr(struct kvm_vcpu *vcpu, gpa_t vapic_addr)\n{\n\tif (vapic_addr) {\n\t\tif (kvm_gfn_to_hva_cache_init(vcpu->kvm,\n\t\t\t\t\t&vcpu->arch.apic->vapic_cache,\n\t\t\t\t\tvapic_addr, sizeof(u32)))\n\t\t\treturn -EINVAL;\n\t\t__set_bit(KVM_APIC_CHECK_VAPIC, &vcpu->arch.apic_attention);\n\t} else {\n\t\t__clear_bit(KVM_APIC_CHECK_VAPIC, &vcpu->arch.apic_attention);\n\t}\n\n\tvcpu->arch.apic->vapic_addr = vapic_addr;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&va",
            "argp",
            "sizeof va"
          ],
          "line": 3357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lapic_in_kernel",
          "args": [
            "vcpu"
          ],
          "line": 3354
        },
        "resolved": true,
        "details": {
          "function_name": "lapic_in_kernel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.h",
          "lines": "141-146",
          "snippet": "static inline bool lapic_in_kernel(struct kvm_vcpu *vcpu)\n{\n\tif (static_key_false(&kvm_no_apic_vcpu))\n\t\treturn vcpu->arch.apic;\n\treturn true;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline bool lapic_in_kernel(struct kvm_vcpu *vcpu)\n{\n\tif (static_key_false(&kvm_no_apic_vcpu))\n\t\treturn vcpu->arch.apic;\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "argp",
            "&tac",
            "sizeof tac"
          ],
          "line": 3345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vcpu_ioctl_tpr_access_reporting",
          "args": [
            "vcpu",
            "&tac"
          ],
          "line": 3341
        },
        "resolved": true,
        "details": {
          "function_name": "vcpu_ioctl_tpr_access_reporting",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "2849-2856",
          "snippet": "static int vcpu_ioctl_tpr_access_reporting(struct kvm_vcpu *vcpu,\n\t\t\t\t\t   struct kvm_tpr_access_ctl *tac)\n{\n\tif (tac->flags)\n\t\treturn -EINVAL;\n\tvcpu->arch.tpr_access_reporting = !!tac->enabled;\n\treturn 0;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic int vcpu_ioctl_tpr_access_reporting(struct kvm_vcpu *vcpu,\n\t\t\t\t\t   struct kvm_tpr_access_ctl *tac)\n{\n\tif (tac->flags)\n\t\treturn -EINVAL;\n\tvcpu->arch.tpr_access_reporting = !!tac->enabled;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&tac",
            "argp",
            "sizeof tac"
          ],
          "line": 3339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "msr_io",
          "args": [
            "vcpu",
            "argp",
            "do_set_msr",
            "0"
          ],
          "line": 3333
        },
        "resolved": true,
        "details": {
          "function_name": "msr_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "2487-2526",
          "snippet": "static int msr_io(struct kvm_vcpu *vcpu, struct kvm_msrs __user *user_msrs,\n\t\t  int (*do_msr)(struct kvm_vcpu *vcpu,\n\t\t\t\tunsigned index, u64 *data),\n\t\t  int writeback)\n{\n\tstruct kvm_msrs msrs;\n\tstruct kvm_msr_entry *entries;\n\tint r, n;\n\tunsigned size;\n\n\tr = -EFAULT;\n\tif (copy_from_user(&msrs, user_msrs, sizeof msrs))\n\t\tgoto out;\n\n\tr = -E2BIG;\n\tif (msrs.nmsrs >= MAX_IO_MSRS)\n\t\tgoto out;\n\n\tsize = sizeof(struct kvm_msr_entry) * msrs.nmsrs;\n\tentries = memdup_user(user_msrs->entries, size);\n\tif (IS_ERR(entries)) {\n\t\tr = PTR_ERR(entries);\n\t\tgoto out;\n\t}\n\n\tr = n = __msr_io(vcpu, &msrs, entries, do_msr);\n\tif (r < 0)\n\t\tgoto out_free;\n\n\tr = -EFAULT;\n\tif (writeback && copy_to_user(user_msrs->entries, entries, size))\n\t\tgoto out_free;\n\n\tr = n;\n\nout_free:\n\tkfree(entries);\nout:\n\treturn r;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define MAX_IO_MSRS 256"
          ],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define MAX_IO_MSRS 256\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic int msr_io(struct kvm_vcpu *vcpu, struct kvm_msrs __user *user_msrs,\n\t\t  int (*do_msr)(struct kvm_vcpu *vcpu,\n\t\t\t\tunsigned index, u64 *data),\n\t\t  int writeback)\n{\n\tstruct kvm_msrs msrs;\n\tstruct kvm_msr_entry *entries;\n\tint r, n;\n\tunsigned size;\n\n\tr = -EFAULT;\n\tif (copy_from_user(&msrs, user_msrs, sizeof msrs))\n\t\tgoto out;\n\n\tr = -E2BIG;\n\tif (msrs.nmsrs >= MAX_IO_MSRS)\n\t\tgoto out;\n\n\tsize = sizeof(struct kvm_msr_entry) * msrs.nmsrs;\n\tentries = memdup_user(user_msrs->entries, size);\n\tif (IS_ERR(entries)) {\n\t\tr = PTR_ERR(entries);\n\t\tgoto out;\n\t}\n\n\tr = n = __msr_io(vcpu, &msrs, entries, do_msr);\n\tif (r < 0)\n\t\tgoto out_free;\n\n\tr = -EFAULT;\n\tif (writeback && copy_to_user(user_msrs->entries, entries, size))\n\t\tgoto out_free;\n\n\tr = n;\n\nout_free:\n\tkfree(entries);\nout:\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "cpuid_arg",
            "&cpuid",
            "sizeof cpuid"
          ],
          "line": 3324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_ioctl_get_cpuid2",
          "args": [
            "vcpu",
            "&cpuid",
            "cpuid_arg->entries"
          ],
          "line": 3319
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_vcpu_ioctl_get_cpuid2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/cpuid.c",
          "lines": "242-260",
          "snippet": "int kvm_vcpu_ioctl_get_cpuid2(struct kvm_vcpu *vcpu,\n\t\t\t      struct kvm_cpuid2 *cpuid,\n\t\t\t      struct kvm_cpuid_entry2 __user *entries)\n{\n\tint r;\n\n\tr = -E2BIG;\n\tif (cpuid->nent < vcpu->arch.cpuid_nent)\n\t\tgoto out;\n\tr = -EFAULT;\n\tif (copy_to_user(entries, &vcpu->arch.cpuid_entries,\n\t\t\t vcpu->arch.cpuid_nent * sizeof(struct kvm_cpuid_entry2)))\n\t\tgoto out;\n\treturn 0;\n\nout:\n\tcpuid->nent = vcpu->arch.cpuid_nent;\n\treturn r;\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"trace.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"cpuid.h\"",
            "#include <asm/fpu/xstate.h>",
            "#include <asm/user.h>",
            "#include <asm/fpu/internal.h> /* For use_eager_fpu.  Ugh! */",
            "#include <linux/uaccess.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"trace.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include <asm/fpu/xstate.h>\n#include <asm/user.h>\n#include <asm/fpu/internal.h> /* For use_eager_fpu.  Ugh! */\n#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n\nint kvm_vcpu_ioctl_get_cpuid2(struct kvm_vcpu *vcpu,\n\t\t\t      struct kvm_cpuid2 *cpuid,\n\t\t\t      struct kvm_cpuid_entry2 __user *entries)\n{\n\tint r;\n\n\tr = -E2BIG;\n\tif (cpuid->nent < vcpu->arch.cpuid_nent)\n\t\tgoto out;\n\tr = -EFAULT;\n\tif (copy_to_user(entries, &vcpu->arch.cpuid_entries,\n\t\t\t vcpu->arch.cpuid_nent * sizeof(struct kvm_cpuid_entry2)))\n\t\tgoto out;\n\treturn 0;\n\nout:\n\tcpuid->nent = vcpu->arch.cpuid_nent;\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&cpuid",
            "cpuid_arg",
            "sizeof cpuid"
          ],
          "line": 3317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_ioctl_set_cpuid2",
          "args": [
            "vcpu",
            "&cpuid",
            "cpuid_arg->entries"
          ],
          "line": 3308
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_vcpu_ioctl_set_cpuid2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/cpuid.c",
          "lines": "221-240",
          "snippet": "int kvm_vcpu_ioctl_set_cpuid2(struct kvm_vcpu *vcpu,\n\t\t\t      struct kvm_cpuid2 *cpuid,\n\t\t\t      struct kvm_cpuid_entry2 __user *entries)\n{\n\tint r;\n\n\tr = -E2BIG;\n\tif (cpuid->nent > KVM_MAX_CPUID_ENTRIES)\n\t\tgoto out;\n\tr = -EFAULT;\n\tif (copy_from_user(&vcpu->arch.cpuid_entries, entries,\n\t\t\t   cpuid->nent * sizeof(struct kvm_cpuid_entry2)))\n\t\tgoto out;\n\tvcpu->arch.cpuid_nent = cpuid->nent;\n\tkvm_apic_set_version(vcpu);\n\tkvm_x86_ops->cpuid_update(vcpu);\n\tr = kvm_update_cpuid(vcpu);\nout:\n\treturn r;\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"trace.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"cpuid.h\"",
            "#include <asm/fpu/xstate.h>",
            "#include <asm/user.h>",
            "#include <asm/fpu/internal.h> /* For use_eager_fpu.  Ugh! */",
            "#include <linux/uaccess.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"trace.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include <asm/fpu/xstate.h>\n#include <asm/user.h>\n#include <asm/fpu/internal.h> /* For use_eager_fpu.  Ugh! */\n#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n\nint kvm_vcpu_ioctl_set_cpuid2(struct kvm_vcpu *vcpu,\n\t\t\t      struct kvm_cpuid2 *cpuid,\n\t\t\t      struct kvm_cpuid_entry2 __user *entries)\n{\n\tint r;\n\n\tr = -E2BIG;\n\tif (cpuid->nent > KVM_MAX_CPUID_ENTRIES)\n\t\tgoto out;\n\tr = -EFAULT;\n\tif (copy_from_user(&vcpu->arch.cpuid_entries, entries,\n\t\t\t   cpuid->nent * sizeof(struct kvm_cpuid_entry2)))\n\t\tgoto out;\n\tvcpu->arch.cpuid_nent = cpuid->nent;\n\tkvm_apic_set_version(vcpu);\n\tkvm_x86_ops->cpuid_update(vcpu);\n\tr = kvm_update_cpuid(vcpu);\nout:\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&cpuid",
            "cpuid_arg",
            "sizeof cpuid"
          ],
          "line": 3306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&cpuid",
            "cpuid_arg",
            "sizeof cpuid"
          ],
          "line": 3296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_ioctl_smi",
          "args": [
            "vcpu"
          ],
          "line": 3288
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_vcpu_ioctl_smi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "2842-2847",
          "snippet": "static int kvm_vcpu_ioctl_smi(struct kvm_vcpu *vcpu)\n{\n\tkvm_make_request(KVM_REQ_SMI, vcpu);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic int kvm_vcpu_ioctl_smi(struct kvm_vcpu *vcpu)\n{\n\tkvm_make_request(KVM_REQ_SMI, vcpu);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_ioctl_nmi",
          "args": [
            "vcpu"
          ],
          "line": 3284
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_vcpu_ioctl_nmi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "2835-2840",
          "snippet": "static int kvm_vcpu_ioctl_nmi(struct kvm_vcpu *vcpu)\n{\n\tkvm_inject_nmi(vcpu);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic int kvm_vcpu_ioctl_nmi(struct kvm_vcpu *vcpu)\n{\n\tkvm_inject_nmi(vcpu);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_ioctl_interrupt",
          "args": [
            "vcpu",
            "&irq"
          ],
          "line": 3280
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_vcpu_ioctl_interrupt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "2808-2833",
          "snippet": "static int kvm_vcpu_ioctl_interrupt(struct kvm_vcpu *vcpu,\n\t\t\t\t    struct kvm_interrupt *irq)\n{\n\tif (irq->irq >= KVM_NR_INTERRUPTS)\n\t\treturn -EINVAL;\n\n\tif (!irqchip_in_kernel(vcpu->kvm)) {\n\t\tkvm_queue_interrupt(vcpu, irq->irq, false);\n\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * With in-kernel LAPIC, we only use this to inject EXTINT, so\n\t * fail for in-kernel 8259.\n\t */\n\tif (pic_in_kernel(vcpu->kvm))\n\t\treturn -ENXIO;\n\n\tif (vcpu->arch.pending_external_vector != -1)\n\t\treturn -EEXIST;\n\n\tvcpu->arch.pending_external_vector = irq->irq;\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\treturn 0;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic int kvm_vcpu_ioctl_interrupt(struct kvm_vcpu *vcpu,\n\t\t\t\t    struct kvm_interrupt *irq)\n{\n\tif (irq->irq >= KVM_NR_INTERRUPTS)\n\t\treturn -EINVAL;\n\n\tif (!irqchip_in_kernel(vcpu->kvm)) {\n\t\tkvm_queue_interrupt(vcpu, irq->irq, false);\n\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * With in-kernel LAPIC, we only use this to inject EXTINT, so\n\t * fail for in-kernel 8259.\n\t */\n\tif (pic_in_kernel(vcpu->kvm))\n\t\treturn -ENXIO;\n\n\tif (vcpu->arch.pending_external_vector != -1)\n\t\treturn -EEXIST;\n\n\tvcpu->arch.pending_external_vector = irq->irq;\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&irq",
            "argp",
            "sizeof irq"
          ],
          "line": 3278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_ioctl_set_lapic",
          "args": [
            "vcpu",
            "u.lapic"
          ],
          "line": 3271
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_vcpu_ioctl_set_lapic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "2779-2786",
          "snippet": "static int kvm_vcpu_ioctl_set_lapic(struct kvm_vcpu *vcpu,\n\t\t\t\t    struct kvm_lapic_state *s)\n{\n\tkvm_apic_post_state_restore(vcpu, s);\n\tupdate_cr8_intercept(vcpu);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic int kvm_vcpu_ioctl_set_lapic(struct kvm_vcpu *vcpu,\n\t\t\t\t    struct kvm_lapic_state *s)\n{\n\tkvm_apic_post_state_restore(vcpu, s);\n\tupdate_cr8_intercept(vcpu);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "u.lapic"
          ],
          "line": 3269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "u.lapic"
          ],
          "line": 3268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memdup_user",
          "args": [
            "argp",
            "sizeof(*u.lapic)"
          ],
          "line": 3267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "argp",
            "u.lapic",
            "sizeof(struct kvm_lapic_state)"
          ],
          "line": 3258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_ioctl_get_lapic",
          "args": [
            "vcpu",
            "u.lapic"
          ],
          "line": 3254
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_vcpu_ioctl_get_lapic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "2768-2777",
          "snippet": "static int kvm_vcpu_ioctl_get_lapic(struct kvm_vcpu *vcpu,\n\t\t\t\t    struct kvm_lapic_state *s)\n{\n\tif (vcpu->arch.apicv_active)\n\t\tkvm_x86_ops->sync_pir_to_irr(vcpu);\n\n\tmemcpy(s->regs, vcpu->arch.apic->regs, sizeof *s);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "struct kvm_x86_ops *kvm_x86_ops"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nstatic int kvm_vcpu_ioctl_get_lapic(struct kvm_vcpu *vcpu,\n\t\t\t\t    struct kvm_lapic_state *s)\n{\n\tif (vcpu->arch.apicv_active)\n\t\tkvm_x86_ops->sync_pir_to_irr(vcpu);\n\n\tmemcpy(s->regs, vcpu->arch.apic->regs, sizeof *s);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct kvm_lapic_state)",
            "GFP_KERNEL"
          ],
          "line": 3249
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nlong kvm_arch_vcpu_ioctl(struct file *filp,\n\t\t\t unsigned int ioctl, unsigned long arg)\n{\n\tstruct kvm_vcpu *vcpu = filp->private_data;\n\tvoid __user *argp = (void __user *)arg;\n\tint r;\n\tunion {\n\t\tstruct kvm_lapic_state *lapic;\n\t\tstruct kvm_xsave *xsave;\n\t\tstruct kvm_xcrs *xcrs;\n\t\tvoid *buffer;\n\t} u;\n\n\tu.buffer = NULL;\n\tswitch (ioctl) {\n\tcase KVM_GET_LAPIC: {\n\t\tr = -EINVAL;\n\t\tif (!lapic_in_kernel(vcpu))\n\t\t\tgoto out;\n\t\tu.lapic = kzalloc(sizeof(struct kvm_lapic_state), GFP_KERNEL);\n\n\t\tr = -ENOMEM;\n\t\tif (!u.lapic)\n\t\t\tgoto out;\n\t\tr = kvm_vcpu_ioctl_get_lapic(vcpu, u.lapic);\n\t\tif (r)\n\t\t\tgoto out;\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(argp, u.lapic, sizeof(struct kvm_lapic_state)))\n\t\t\tgoto out;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_SET_LAPIC: {\n\t\tr = -EINVAL;\n\t\tif (!lapic_in_kernel(vcpu))\n\t\t\tgoto out;\n\t\tu.lapic = memdup_user(argp, sizeof(*u.lapic));\n\t\tif (IS_ERR(u.lapic))\n\t\t\treturn PTR_ERR(u.lapic);\n\n\t\tr = kvm_vcpu_ioctl_set_lapic(vcpu, u.lapic);\n\t\tbreak;\n\t}\n\tcase KVM_INTERRUPT: {\n\t\tstruct kvm_interrupt irq;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&irq, argp, sizeof irq))\n\t\t\tgoto out;\n\t\tr = kvm_vcpu_ioctl_interrupt(vcpu, &irq);\n\t\tbreak;\n\t}\n\tcase KVM_NMI: {\n\t\tr = kvm_vcpu_ioctl_nmi(vcpu);\n\t\tbreak;\n\t}\n\tcase KVM_SMI: {\n\t\tr = kvm_vcpu_ioctl_smi(vcpu);\n\t\tbreak;\n\t}\n\tcase KVM_SET_CPUID: {\n\t\tstruct kvm_cpuid __user *cpuid_arg = argp;\n\t\tstruct kvm_cpuid cpuid;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&cpuid, cpuid_arg, sizeof cpuid))\n\t\t\tgoto out;\n\t\tr = kvm_vcpu_ioctl_set_cpuid(vcpu, &cpuid, cpuid_arg->entries);\n\t\tbreak;\n\t}\n\tcase KVM_SET_CPUID2: {\n\t\tstruct kvm_cpuid2 __user *cpuid_arg = argp;\n\t\tstruct kvm_cpuid2 cpuid;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&cpuid, cpuid_arg, sizeof cpuid))\n\t\t\tgoto out;\n\t\tr = kvm_vcpu_ioctl_set_cpuid2(vcpu, &cpuid,\n\t\t\t\t\t      cpuid_arg->entries);\n\t\tbreak;\n\t}\n\tcase KVM_GET_CPUID2: {\n\t\tstruct kvm_cpuid2 __user *cpuid_arg = argp;\n\t\tstruct kvm_cpuid2 cpuid;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&cpuid, cpuid_arg, sizeof cpuid))\n\t\t\tgoto out;\n\t\tr = kvm_vcpu_ioctl_get_cpuid2(vcpu, &cpuid,\n\t\t\t\t\t      cpuid_arg->entries);\n\t\tif (r)\n\t\t\tgoto out;\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(cpuid_arg, &cpuid, sizeof cpuid))\n\t\t\tgoto out;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_GET_MSRS:\n\t\tr = msr_io(vcpu, argp, do_get_msr, 1);\n\t\tbreak;\n\tcase KVM_SET_MSRS:\n\t\tr = msr_io(vcpu, argp, do_set_msr, 0);\n\t\tbreak;\n\tcase KVM_TPR_ACCESS_REPORTING: {\n\t\tstruct kvm_tpr_access_ctl tac;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&tac, argp, sizeof tac))\n\t\t\tgoto out;\n\t\tr = vcpu_ioctl_tpr_access_reporting(vcpu, &tac);\n\t\tif (r)\n\t\t\tgoto out;\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(argp, &tac, sizeof tac))\n\t\t\tgoto out;\n\t\tr = 0;\n\t\tbreak;\n\t};\n\tcase KVM_SET_VAPIC_ADDR: {\n\t\tstruct kvm_vapic_addr va;\n\n\t\tr = -EINVAL;\n\t\tif (!lapic_in_kernel(vcpu))\n\t\t\tgoto out;\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&va, argp, sizeof va))\n\t\t\tgoto out;\n\t\tr = kvm_lapic_set_vapic_addr(vcpu, va.vapic_addr);\n\t\tbreak;\n\t}\n\tcase KVM_X86_SETUP_MCE: {\n\t\tu64 mcg_cap;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&mcg_cap, argp, sizeof mcg_cap))\n\t\t\tgoto out;\n\t\tr = kvm_vcpu_ioctl_x86_setup_mce(vcpu, mcg_cap);\n\t\tbreak;\n\t}\n\tcase KVM_X86_SET_MCE: {\n\t\tstruct kvm_x86_mce mce;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&mce, argp, sizeof mce))\n\t\t\tgoto out;\n\t\tr = kvm_vcpu_ioctl_x86_set_mce(vcpu, &mce);\n\t\tbreak;\n\t}\n\tcase KVM_GET_VCPU_EVENTS: {\n\t\tstruct kvm_vcpu_events events;\n\n\t\tkvm_vcpu_ioctl_x86_get_vcpu_events(vcpu, &events);\n\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(argp, &events, sizeof(struct kvm_vcpu_events)))\n\t\t\tbreak;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_SET_VCPU_EVENTS: {\n\t\tstruct kvm_vcpu_events events;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&events, argp, sizeof(struct kvm_vcpu_events)))\n\t\t\tbreak;\n\n\t\tr = kvm_vcpu_ioctl_x86_set_vcpu_events(vcpu, &events);\n\t\tbreak;\n\t}\n\tcase KVM_GET_DEBUGREGS: {\n\t\tstruct kvm_debugregs dbgregs;\n\n\t\tkvm_vcpu_ioctl_x86_get_debugregs(vcpu, &dbgregs);\n\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(argp, &dbgregs,\n\t\t\t\t sizeof(struct kvm_debugregs)))\n\t\t\tbreak;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_SET_DEBUGREGS: {\n\t\tstruct kvm_debugregs dbgregs;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&dbgregs, argp,\n\t\t\t\t   sizeof(struct kvm_debugregs)))\n\t\t\tbreak;\n\n\t\tr = kvm_vcpu_ioctl_x86_set_debugregs(vcpu, &dbgregs);\n\t\tbreak;\n\t}\n\tcase KVM_GET_XSAVE: {\n\t\tu.xsave = kzalloc(sizeof(struct kvm_xsave), GFP_KERNEL);\n\t\tr = -ENOMEM;\n\t\tif (!u.xsave)\n\t\t\tbreak;\n\n\t\tkvm_vcpu_ioctl_x86_get_xsave(vcpu, u.xsave);\n\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(argp, u.xsave, sizeof(struct kvm_xsave)))\n\t\t\tbreak;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_SET_XSAVE: {\n\t\tu.xsave = memdup_user(argp, sizeof(*u.xsave));\n\t\tif (IS_ERR(u.xsave))\n\t\t\treturn PTR_ERR(u.xsave);\n\n\t\tr = kvm_vcpu_ioctl_x86_set_xsave(vcpu, u.xsave);\n\t\tbreak;\n\t}\n\tcase KVM_GET_XCRS: {\n\t\tu.xcrs = kzalloc(sizeof(struct kvm_xcrs), GFP_KERNEL);\n\t\tr = -ENOMEM;\n\t\tif (!u.xcrs)\n\t\t\tbreak;\n\n\t\tkvm_vcpu_ioctl_x86_get_xcrs(vcpu, u.xcrs);\n\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(argp, u.xcrs,\n\t\t\t\t sizeof(struct kvm_xcrs)))\n\t\t\tbreak;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_SET_XCRS: {\n\t\tu.xcrs = memdup_user(argp, sizeof(*u.xcrs));\n\t\tif (IS_ERR(u.xcrs))\n\t\t\treturn PTR_ERR(u.xcrs);\n\n\t\tr = kvm_vcpu_ioctl_x86_set_xcrs(vcpu, u.xcrs);\n\t\tbreak;\n\t}\n\tcase KVM_SET_TSC_KHZ: {\n\t\tu32 user_tsc_khz;\n\n\t\tr = -EINVAL;\n\t\tuser_tsc_khz = (u32)arg;\n\n\t\tif (user_tsc_khz >= kvm_max_guest_tsc_khz)\n\t\t\tgoto out;\n\n\t\tif (user_tsc_khz == 0)\n\t\t\tuser_tsc_khz = tsc_khz;\n\n\t\tif (!kvm_set_tsc_khz(vcpu, user_tsc_khz))\n\t\t\tr = 0;\n\n\t\tgoto out;\n\t}\n\tcase KVM_GET_TSC_KHZ: {\n\t\tr = vcpu->arch.virtual_tsc_khz;\n\t\tgoto out;\n\t}\n\tcase KVM_KVMCLOCK_CTRL: {\n\t\tr = kvm_set_guest_paused(vcpu);\n\t\tgoto out;\n\t}\n\tcase KVM_ENABLE_CAP: {\n\t\tstruct kvm_enable_cap cap;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&cap, argp, sizeof(cap)))\n\t\t\tgoto out;\n\t\tr = kvm_vcpu_ioctl_enable_cap(vcpu, &cap);\n\t\tbreak;\n\t}\n\tdefault:\n\t\tr = -EINVAL;\n\t}\nout:\n\tkfree(u.buffer);\n\treturn r;\n}"
  },
  {
    "function_name": "kvm_vcpu_ioctl_enable_cap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "3216-3228",
    "snippet": "static int kvm_vcpu_ioctl_enable_cap(struct kvm_vcpu *vcpu,\n\t\t\t\t     struct kvm_enable_cap *cap)\n{\n\tif (cap->flags)\n\t\treturn -EINVAL;\n\n\tswitch (cap->cap) {\n\tcase KVM_CAP_HYPERV_SYNIC:\n\t\treturn kvm_hv_activate_synic(vcpu);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_hv_activate_synic",
          "args": [
            "vcpu"
          ],
          "line": 3224
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_hv_activate_synic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.c",
          "lines": "674-683",
          "snippet": "int kvm_hv_activate_synic(struct kvm_vcpu *vcpu)\n{\n\t/*\n\t * Hyper-V SynIC auto EOI SINT's are\n\t * not compatible with APICV, so deactivate APICV\n\t */\n\tkvm_vcpu_deactivate_apicv(vcpu);\n\tvcpu_to_synic(vcpu)->active = true;\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nint kvm_hv_activate_synic(struct kvm_vcpu *vcpu)\n{\n\t/*\n\t * Hyper-V SynIC auto EOI SINT's are\n\t * not compatible with APICV, so deactivate APICV\n\t */\n\tkvm_vcpu_deactivate_apicv(vcpu);\n\tvcpu_to_synic(vcpu)->active = true;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic int kvm_vcpu_ioctl_enable_cap(struct kvm_vcpu *vcpu,\n\t\t\t\t     struct kvm_enable_cap *cap)\n{\n\tif (cap->flags)\n\t\treturn -EINVAL;\n\n\tswitch (cap->cap) {\n\tcase KVM_CAP_HYPERV_SYNIC:\n\t\treturn kvm_hv_activate_synic(vcpu);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}"
  },
  {
    "function_name": "kvm_set_guest_paused",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "3207-3214",
    "snippet": "static int kvm_set_guest_paused(struct kvm_vcpu *vcpu)\n{\n\tif (!vcpu->arch.pv_time_enabled)\n\t\treturn -EINVAL;\n\tvcpu->arch.pvclock_set_guest_stopped_request = true;\n\tkvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);\n\treturn 0;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_make_request",
          "args": [
            "KVM_REQ_CLOCK_UPDATE",
            "vcpu"
          ],
          "line": 3212
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic int kvm_set_guest_paused(struct kvm_vcpu *vcpu)\n{\n\tif (!vcpu->arch.pv_time_enabled)\n\t\treturn -EINVAL;\n\tvcpu->arch.pvclock_set_guest_stopped_request = true;\n\tkvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);\n\treturn 0;\n}"
  },
  {
    "function_name": "kvm_vcpu_ioctl_x86_set_xcrs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "3178-3199",
    "snippet": "static int kvm_vcpu_ioctl_x86_set_xcrs(struct kvm_vcpu *vcpu,\n\t\t\t\t       struct kvm_xcrs *guest_xcrs)\n{\n\tint i, r = 0;\n\n\tif (!cpu_has_xsave)\n\t\treturn -EINVAL;\n\n\tif (guest_xcrs->nr_xcrs > KVM_MAX_XCRS || guest_xcrs->flags)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < guest_xcrs->nr_xcrs; i++)\n\t\t/* Only support XCR0 currently */\n\t\tif (guest_xcrs->xcrs[i].xcr == XCR_XFEATURE_ENABLED_MASK) {\n\t\t\tr = __kvm_set_xcr(vcpu, XCR_XFEATURE_ENABLED_MASK,\n\t\t\t\tguest_xcrs->xcrs[i].value);\n\t\t\tbreak;\n\t\t}\n\tif (r)\n\t\tr = -EINVAL;\n\treturn r;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__kvm_set_xcr",
          "args": [
            "vcpu",
            "XCR_XFEATURE_ENABLED_MASK",
            "guest_xcrs->xcrs[i].value"
          ],
          "line": 3192
        },
        "resolved": true,
        "details": {
          "function_name": "__kvm_set_xcr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "671-709",
          "snippet": "static int __kvm_set_xcr(struct kvm_vcpu *vcpu, u32 index, u64 xcr)\n{\n\tu64 xcr0 = xcr;\n\tu64 old_xcr0 = vcpu->arch.xcr0;\n\tu64 valid_bits;\n\n\t/* Only support XCR_XFEATURE_ENABLED_MASK(xcr0) now  */\n\tif (index != XCR_XFEATURE_ENABLED_MASK)\n\t\treturn 1;\n\tif (!(xcr0 & XFEATURE_MASK_FP))\n\t\treturn 1;\n\tif ((xcr0 & XFEATURE_MASK_YMM) && !(xcr0 & XFEATURE_MASK_SSE))\n\t\treturn 1;\n\n\t/*\n\t * Do not allow the guest to set bits that we do not support\n\t * saving.  However, xcr0 bit 0 is always set, even if the\n\t * emulated CPU does not support XSAVE (see fx_init).\n\t */\n\tvalid_bits = vcpu->arch.guest_supported_xcr0 | XFEATURE_MASK_FP;\n\tif (xcr0 & ~valid_bits)\n\t\treturn 1;\n\n\tif ((!(xcr0 & XFEATURE_MASK_BNDREGS)) !=\n\t    (!(xcr0 & XFEATURE_MASK_BNDCSR)))\n\t\treturn 1;\n\n\tif (xcr0 & XFEATURE_MASK_AVX512) {\n\t\tif (!(xcr0 & XFEATURE_MASK_YMM))\n\t\t\treturn 1;\n\t\tif ((xcr0 & XFEATURE_MASK_AVX512) != XFEATURE_MASK_AVX512)\n\t\t\treturn 1;\n\t}\n\tvcpu->arch.xcr0 = xcr0;\n\n\tif ((xcr0 ^ old_xcr0) & XFEATURE_MASK_EXTEND)\n\t\tkvm_update_cpuid(vcpu);\n\treturn 0;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic int __kvm_set_xcr(struct kvm_vcpu *vcpu, u32 index, u64 xcr)\n{\n\tu64 xcr0 = xcr;\n\tu64 old_xcr0 = vcpu->arch.xcr0;\n\tu64 valid_bits;\n\n\t/* Only support XCR_XFEATURE_ENABLED_MASK(xcr0) now  */\n\tif (index != XCR_XFEATURE_ENABLED_MASK)\n\t\treturn 1;\n\tif (!(xcr0 & XFEATURE_MASK_FP))\n\t\treturn 1;\n\tif ((xcr0 & XFEATURE_MASK_YMM) && !(xcr0 & XFEATURE_MASK_SSE))\n\t\treturn 1;\n\n\t/*\n\t * Do not allow the guest to set bits that we do not support\n\t * saving.  However, xcr0 bit 0 is always set, even if the\n\t * emulated CPU does not support XSAVE (see fx_init).\n\t */\n\tvalid_bits = vcpu->arch.guest_supported_xcr0 | XFEATURE_MASK_FP;\n\tif (xcr0 & ~valid_bits)\n\t\treturn 1;\n\n\tif ((!(xcr0 & XFEATURE_MASK_BNDREGS)) !=\n\t    (!(xcr0 & XFEATURE_MASK_BNDCSR)))\n\t\treturn 1;\n\n\tif (xcr0 & XFEATURE_MASK_AVX512) {\n\t\tif (!(xcr0 & XFEATURE_MASK_YMM))\n\t\t\treturn 1;\n\t\tif ((xcr0 & XFEATURE_MASK_AVX512) != XFEATURE_MASK_AVX512)\n\t\t\treturn 1;\n\t}\n\tvcpu->arch.xcr0 = xcr0;\n\n\tif ((xcr0 ^ old_xcr0) & XFEATURE_MASK_EXTEND)\n\t\tkvm_update_cpuid(vcpu);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic int kvm_vcpu_ioctl_x86_set_xcrs(struct kvm_vcpu *vcpu,\n\t\t\t\t       struct kvm_xcrs *guest_xcrs)\n{\n\tint i, r = 0;\n\n\tif (!cpu_has_xsave)\n\t\treturn -EINVAL;\n\n\tif (guest_xcrs->nr_xcrs > KVM_MAX_XCRS || guest_xcrs->flags)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < guest_xcrs->nr_xcrs; i++)\n\t\t/* Only support XCR0 currently */\n\t\tif (guest_xcrs->xcrs[i].xcr == XCR_XFEATURE_ENABLED_MASK) {\n\t\t\tr = __kvm_set_xcr(vcpu, XCR_XFEATURE_ENABLED_MASK,\n\t\t\t\tguest_xcrs->xcrs[i].value);\n\t\t\tbreak;\n\t\t}\n\tif (r)\n\t\tr = -EINVAL;\n\treturn r;\n}"
  },
  {
    "function_name": "kvm_vcpu_ioctl_x86_get_xcrs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "3164-3176",
    "snippet": "static void kvm_vcpu_ioctl_x86_get_xcrs(struct kvm_vcpu *vcpu,\n\t\t\t\t\tstruct kvm_xcrs *guest_xcrs)\n{\n\tif (!cpu_has_xsave) {\n\t\tguest_xcrs->nr_xcrs = 0;\n\t\treturn;\n\t}\n\n\tguest_xcrs->nr_xcrs = 1;\n\tguest_xcrs->flags = 0;\n\tguest_xcrs->xcrs[0].xcr = XCR_XFEATURE_ENABLED_MASK;\n\tguest_xcrs->xcrs[0].value = vcpu->arch.xcr0;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic void kvm_vcpu_ioctl_x86_get_xcrs(struct kvm_vcpu *vcpu,\n\t\t\t\t\tstruct kvm_xcrs *guest_xcrs)\n{\n\tif (!cpu_has_xsave) {\n\t\tguest_xcrs->nr_xcrs = 0;\n\t\treturn;\n\t}\n\n\tguest_xcrs->nr_xcrs = 1;\n\tguest_xcrs->flags = 0;\n\tguest_xcrs->xcrs[0].xcr = XCR_XFEATURE_ENABLED_MASK;\n\tguest_xcrs->xcrs[0].value = vcpu->arch.xcr0;\n}"
  },
  {
    "function_name": "kvm_vcpu_ioctl_x86_set_xsave",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "3140-3162",
    "snippet": "static int kvm_vcpu_ioctl_x86_set_xsave(struct kvm_vcpu *vcpu,\n\t\t\t\t\tstruct kvm_xsave *guest_xsave)\n{\n\tu64 xstate_bv =\n\t\t*(u64 *)&guest_xsave->region[XSAVE_HDR_OFFSET / sizeof(u32)];\n\n\tif (cpu_has_xsave) {\n\t\t/*\n\t\t * Here we allow setting states that are not present in\n\t\t * CPUID leaf 0xD, index 0, EDX:EAX.  This is for compatibility\n\t\t * with old userspace.\n\t\t */\n\t\tif (xstate_bv & ~kvm_supported_xcr0())\n\t\t\treturn -EINVAL;\n\t\tload_xsave(vcpu, (u8 *)guest_xsave->region);\n\t} else {\n\t\tif (xstate_bv & ~XFEATURE_MASK_FPSSE)\n\t\t\treturn -EINVAL;\n\t\tmemcpy(&vcpu->arch.guest_fpu.state.fxsave,\n\t\t\tguest_xsave->region, sizeof(struct fxregs_state));\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&vcpu->arch.guest_fpu.state.fxsave",
            "guest_xsave->region",
            "sizeof(struct fxregs_state)"
          ],
          "line": 3158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "load_xsave",
          "args": [
            "vcpu",
            "(u8 *)guest_xsave->region"
          ],
          "line": 3154
        },
        "resolved": true,
        "details": {
          "function_name": "load_xsave",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "3087-3123",
          "snippet": "static void load_xsave(struct kvm_vcpu *vcpu, u8 *src)\n{\n\tstruct xregs_state *xsave = &vcpu->arch.guest_fpu.state.xsave;\n\tu64 xstate_bv = *(u64 *)(src + XSAVE_HDR_OFFSET);\n\tu64 valid;\n\n\t/*\n\t * Copy legacy XSAVE area, to avoid complications with CPUID\n\t * leaves 0 and 1 in the loop below.\n\t */\n\tmemcpy(xsave, src, XSAVE_HDR_OFFSET);\n\n\t/* Set XSTATE_BV and possibly XCOMP_BV.  */\n\txsave->header.xfeatures = xstate_bv;\n\tif (cpu_has_xsaves)\n\t\txsave->header.xcomp_bv = host_xcr0 | XSTATE_COMPACTION_ENABLED;\n\n\t/*\n\t * Copy each region from the non-compacted offset to the\n\t * possibly compacted offset.\n\t */\n\tvalid = xstate_bv & ~XFEATURE_MASK_FPSSE;\n\twhile (valid) {\n\t\tu64 feature = valid & -valid;\n\t\tint index = fls64(feature) - 1;\n\t\tvoid *dest = get_xsave_addr(xsave, feature);\n\n\t\tif (dest) {\n\t\t\tu32 size, offset, ecx, edx;\n\t\t\tcpuid_count(XSTATE_CPUID, index,\n\t\t\t\t    &size, &offset, &ecx, &edx);\n\t\t\tmemcpy(dest, src + offset, size);\n\t\t}\n\n\t\tvalid -= feature;\n\t}\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define XSTATE_COMPACTION_ENABLED (1ULL << 63)"
          ],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "u64 __read_mostly host_xcr0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define XSTATE_COMPACTION_ENABLED (1ULL << 63)\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nu64 __read_mostly host_xcr0;\n\nstatic void load_xsave(struct kvm_vcpu *vcpu, u8 *src)\n{\n\tstruct xregs_state *xsave = &vcpu->arch.guest_fpu.state.xsave;\n\tu64 xstate_bv = *(u64 *)(src + XSAVE_HDR_OFFSET);\n\tu64 valid;\n\n\t/*\n\t * Copy legacy XSAVE area, to avoid complications with CPUID\n\t * leaves 0 and 1 in the loop below.\n\t */\n\tmemcpy(xsave, src, XSAVE_HDR_OFFSET);\n\n\t/* Set XSTATE_BV and possibly XCOMP_BV.  */\n\txsave->header.xfeatures = xstate_bv;\n\tif (cpu_has_xsaves)\n\t\txsave->header.xcomp_bv = host_xcr0 | XSTATE_COMPACTION_ENABLED;\n\n\t/*\n\t * Copy each region from the non-compacted offset to the\n\t * possibly compacted offset.\n\t */\n\tvalid = xstate_bv & ~XFEATURE_MASK_FPSSE;\n\twhile (valid) {\n\t\tu64 feature = valid & -valid;\n\t\tint index = fls64(feature) - 1;\n\t\tvoid *dest = get_xsave_addr(xsave, feature);\n\n\t\tif (dest) {\n\t\t\tu32 size, offset, ecx, edx;\n\t\t\tcpuid_count(XSTATE_CPUID, index,\n\t\t\t\t    &size, &offset, &ecx, &edx);\n\t\t\tmemcpy(dest, src + offset, size);\n\t\t}\n\n\t\tvalid -= feature;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_supported_xcr0",
          "args": [],
          "line": 3152
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_supported_xcr0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/cpuid.c",
          "lines": "56-64",
          "snippet": "u64 kvm_supported_xcr0(void)\n{\n\tu64 xcr0 = KVM_SUPPORTED_XCR0 & host_xcr0;\n\n\tif (!kvm_mpx_supported())\n\t\txcr0 &= ~(XFEATURE_MASK_BNDREGS | XFEATURE_MASK_BNDCSR);\n\n\treturn xcr0;\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"trace.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"cpuid.h\"",
            "#include <asm/fpu/xstate.h>",
            "#include <asm/user.h>",
            "#include <asm/fpu/internal.h> /* For use_eager_fpu.  Ugh! */",
            "#include <linux/uaccess.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"trace.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include <asm/fpu/xstate.h>\n#include <asm/user.h>\n#include <asm/fpu/internal.h> /* For use_eager_fpu.  Ugh! */\n#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n\nu64 kvm_supported_xcr0(void)\n{\n\tu64 xcr0 = KVM_SUPPORTED_XCR0 & host_xcr0;\n\n\tif (!kvm_mpx_supported())\n\t\txcr0 &= ~(XFEATURE_MASK_BNDREGS | XFEATURE_MASK_BNDCSR);\n\n\treturn xcr0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic int kvm_vcpu_ioctl_x86_set_xsave(struct kvm_vcpu *vcpu,\n\t\t\t\t\tstruct kvm_xsave *guest_xsave)\n{\n\tu64 xstate_bv =\n\t\t*(u64 *)&guest_xsave->region[XSAVE_HDR_OFFSET / sizeof(u32)];\n\n\tif (cpu_has_xsave) {\n\t\t/*\n\t\t * Here we allow setting states that are not present in\n\t\t * CPUID leaf 0xD, index 0, EDX:EAX.  This is for compatibility\n\t\t * with old userspace.\n\t\t */\n\t\tif (xstate_bv & ~kvm_supported_xcr0())\n\t\t\treturn -EINVAL;\n\t\tload_xsave(vcpu, (u8 *)guest_xsave->region);\n\t} else {\n\t\tif (xstate_bv & ~XFEATURE_MASK_FPSSE)\n\t\t\treturn -EINVAL;\n\t\tmemcpy(&vcpu->arch.guest_fpu.state.fxsave,\n\t\t\tguest_xsave->region, sizeof(struct fxregs_state));\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "kvm_vcpu_ioctl_x86_get_xsave",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "3125-3138",
    "snippet": "static void kvm_vcpu_ioctl_x86_get_xsave(struct kvm_vcpu *vcpu,\n\t\t\t\t\t struct kvm_xsave *guest_xsave)\n{\n\tif (cpu_has_xsave) {\n\t\tmemset(guest_xsave, 0, sizeof(struct kvm_xsave));\n\t\tfill_xsave((u8 *) guest_xsave->region, vcpu);\n\t} else {\n\t\tmemcpy(guest_xsave->region,\n\t\t\t&vcpu->arch.guest_fpu.state.fxsave,\n\t\t\tsizeof(struct fxregs_state));\n\t\t*(u64 *)&guest_xsave->region[XSAVE_HDR_OFFSET / sizeof(u32)] =\n\t\t\tXFEATURE_MASK_FPSSE;\n\t}\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "guest_xsave->region",
            "&vcpu->arch.guest_fpu.state.fxsave",
            "sizeof(struct fxregs_state)"
          ],
          "line": 3132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fill_xsave",
          "args": [
            "(u8 *) guest_xsave->region",
            "vcpu"
          ],
          "line": 3130
        },
        "resolved": true,
        "details": {
          "function_name": "fill_xsave",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "3051-3085",
          "snippet": "static void fill_xsave(u8 *dest, struct kvm_vcpu *vcpu)\n{\n\tstruct xregs_state *xsave = &vcpu->arch.guest_fpu.state.xsave;\n\tu64 xstate_bv = xsave->header.xfeatures;\n\tu64 valid;\n\n\t/*\n\t * Copy legacy XSAVE area, to avoid complications with CPUID\n\t * leaves 0 and 1 in the loop below.\n\t */\n\tmemcpy(dest, xsave, XSAVE_HDR_OFFSET);\n\n\t/* Set XSTATE_BV */\n\t*(u64 *)(dest + XSAVE_HDR_OFFSET) = xstate_bv;\n\n\t/*\n\t * Copy each region from the possibly compacted offset to the\n\t * non-compacted offset.\n\t */\n\tvalid = xstate_bv & ~XFEATURE_MASK_FPSSE;\n\twhile (valid) {\n\t\tu64 feature = valid & -valid;\n\t\tint index = fls64(feature) - 1;\n\t\tvoid *src = get_xsave_addr(xsave, feature);\n\n\t\tif (src) {\n\t\t\tu32 size, offset, ecx, edx;\n\t\t\tcpuid_count(XSTATE_CPUID, index,\n\t\t\t\t    &size, &offset, &ecx, &edx);\n\t\t\tmemcpy(dest + offset, src, size);\n\t\t}\n\n\t\tvalid -= feature;\n\t}\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic void fill_xsave(u8 *dest, struct kvm_vcpu *vcpu)\n{\n\tstruct xregs_state *xsave = &vcpu->arch.guest_fpu.state.xsave;\n\tu64 xstate_bv = xsave->header.xfeatures;\n\tu64 valid;\n\n\t/*\n\t * Copy legacy XSAVE area, to avoid complications with CPUID\n\t * leaves 0 and 1 in the loop below.\n\t */\n\tmemcpy(dest, xsave, XSAVE_HDR_OFFSET);\n\n\t/* Set XSTATE_BV */\n\t*(u64 *)(dest + XSAVE_HDR_OFFSET) = xstate_bv;\n\n\t/*\n\t * Copy each region from the possibly compacted offset to the\n\t * non-compacted offset.\n\t */\n\tvalid = xstate_bv & ~XFEATURE_MASK_FPSSE;\n\twhile (valid) {\n\t\tu64 feature = valid & -valid;\n\t\tint index = fls64(feature) - 1;\n\t\tvoid *src = get_xsave_addr(xsave, feature);\n\n\t\tif (src) {\n\t\t\tu32 size, offset, ecx, edx;\n\t\t\tcpuid_count(XSTATE_CPUID, index,\n\t\t\t\t    &size, &offset, &ecx, &edx);\n\t\t\tmemcpy(dest + offset, src, size);\n\t\t}\n\n\t\tvalid -= feature;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "guest_xsave",
            "0",
            "sizeof(struct kvm_xsave)"
          ],
          "line": 3129
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic void kvm_vcpu_ioctl_x86_get_xsave(struct kvm_vcpu *vcpu,\n\t\t\t\t\t struct kvm_xsave *guest_xsave)\n{\n\tif (cpu_has_xsave) {\n\t\tmemset(guest_xsave, 0, sizeof(struct kvm_xsave));\n\t\tfill_xsave((u8 *) guest_xsave->region, vcpu);\n\t} else {\n\t\tmemcpy(guest_xsave->region,\n\t\t\t&vcpu->arch.guest_fpu.state.fxsave,\n\t\t\tsizeof(struct fxregs_state));\n\t\t*(u64 *)&guest_xsave->region[XSAVE_HDR_OFFSET / sizeof(u32)] =\n\t\t\tXFEATURE_MASK_FPSSE;\n\t}\n}"
  },
  {
    "function_name": "load_xsave",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "3087-3123",
    "snippet": "static void load_xsave(struct kvm_vcpu *vcpu, u8 *src)\n{\n\tstruct xregs_state *xsave = &vcpu->arch.guest_fpu.state.xsave;\n\tu64 xstate_bv = *(u64 *)(src + XSAVE_HDR_OFFSET);\n\tu64 valid;\n\n\t/*\n\t * Copy legacy XSAVE area, to avoid complications with CPUID\n\t * leaves 0 and 1 in the loop below.\n\t */\n\tmemcpy(xsave, src, XSAVE_HDR_OFFSET);\n\n\t/* Set XSTATE_BV and possibly XCOMP_BV.  */\n\txsave->header.xfeatures = xstate_bv;\n\tif (cpu_has_xsaves)\n\t\txsave->header.xcomp_bv = host_xcr0 | XSTATE_COMPACTION_ENABLED;\n\n\t/*\n\t * Copy each region from the non-compacted offset to the\n\t * possibly compacted offset.\n\t */\n\tvalid = xstate_bv & ~XFEATURE_MASK_FPSSE;\n\twhile (valid) {\n\t\tu64 feature = valid & -valid;\n\t\tint index = fls64(feature) - 1;\n\t\tvoid *dest = get_xsave_addr(xsave, feature);\n\n\t\tif (dest) {\n\t\t\tu32 size, offset, ecx, edx;\n\t\t\tcpuid_count(XSTATE_CPUID, index,\n\t\t\t\t    &size, &offset, &ecx, &edx);\n\t\t\tmemcpy(dest, src + offset, size);\n\t\t}\n\n\t\tvalid -= feature;\n\t}\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define XSTATE_COMPACTION_ENABLED (1ULL << 63)"
    ],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);",
      "u64 __read_mostly host_xcr0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dest",
            "src + offset",
            "size"
          ],
          "line": 3118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpuid_count",
          "args": [
            "XSTATE_CPUID",
            "index",
            "&size",
            "&offset",
            "&ecx",
            "&edx"
          ],
          "line": 3116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_xsave_addr",
          "args": [
            "xsave",
            "feature"
          ],
          "line": 3112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fls64",
          "args": [
            "feature"
          ],
          "line": 3111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "xsave",
            "src",
            "XSAVE_HDR_OFFSET"
          ],
          "line": 3097
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define XSTATE_COMPACTION_ENABLED (1ULL << 63)\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nu64 __read_mostly host_xcr0;\n\nstatic void load_xsave(struct kvm_vcpu *vcpu, u8 *src)\n{\n\tstruct xregs_state *xsave = &vcpu->arch.guest_fpu.state.xsave;\n\tu64 xstate_bv = *(u64 *)(src + XSAVE_HDR_OFFSET);\n\tu64 valid;\n\n\t/*\n\t * Copy legacy XSAVE area, to avoid complications with CPUID\n\t * leaves 0 and 1 in the loop below.\n\t */\n\tmemcpy(xsave, src, XSAVE_HDR_OFFSET);\n\n\t/* Set XSTATE_BV and possibly XCOMP_BV.  */\n\txsave->header.xfeatures = xstate_bv;\n\tif (cpu_has_xsaves)\n\t\txsave->header.xcomp_bv = host_xcr0 | XSTATE_COMPACTION_ENABLED;\n\n\t/*\n\t * Copy each region from the non-compacted offset to the\n\t * possibly compacted offset.\n\t */\n\tvalid = xstate_bv & ~XFEATURE_MASK_FPSSE;\n\twhile (valid) {\n\t\tu64 feature = valid & -valid;\n\t\tint index = fls64(feature) - 1;\n\t\tvoid *dest = get_xsave_addr(xsave, feature);\n\n\t\tif (dest) {\n\t\t\tu32 size, offset, ecx, edx;\n\t\t\tcpuid_count(XSTATE_CPUID, index,\n\t\t\t\t    &size, &offset, &ecx, &edx);\n\t\t\tmemcpy(dest, src + offset, size);\n\t\t}\n\n\t\tvalid -= feature;\n\t}\n}"
  },
  {
    "function_name": "fill_xsave",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "3051-3085",
    "snippet": "static void fill_xsave(u8 *dest, struct kvm_vcpu *vcpu)\n{\n\tstruct xregs_state *xsave = &vcpu->arch.guest_fpu.state.xsave;\n\tu64 xstate_bv = xsave->header.xfeatures;\n\tu64 valid;\n\n\t/*\n\t * Copy legacy XSAVE area, to avoid complications with CPUID\n\t * leaves 0 and 1 in the loop below.\n\t */\n\tmemcpy(dest, xsave, XSAVE_HDR_OFFSET);\n\n\t/* Set XSTATE_BV */\n\t*(u64 *)(dest + XSAVE_HDR_OFFSET) = xstate_bv;\n\n\t/*\n\t * Copy each region from the possibly compacted offset to the\n\t * non-compacted offset.\n\t */\n\tvalid = xstate_bv & ~XFEATURE_MASK_FPSSE;\n\twhile (valid) {\n\t\tu64 feature = valid & -valid;\n\t\tint index = fls64(feature) - 1;\n\t\tvoid *src = get_xsave_addr(xsave, feature);\n\n\t\tif (src) {\n\t\t\tu32 size, offset, ecx, edx;\n\t\t\tcpuid_count(XSTATE_CPUID, index,\n\t\t\t\t    &size, &offset, &ecx, &edx);\n\t\t\tmemcpy(dest + offset, src, size);\n\t\t}\n\n\t\tvalid -= feature;\n\t}\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dest + offset",
            "src",
            "size"
          ],
          "line": 3080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpuid_count",
          "args": [
            "XSTATE_CPUID",
            "index",
            "&size",
            "&offset",
            "&ecx",
            "&edx"
          ],
          "line": 3078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_xsave_addr",
          "args": [
            "xsave",
            "feature"
          ],
          "line": 3074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fls64",
          "args": [
            "feature"
          ],
          "line": 3073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dest",
            "xsave",
            "XSAVE_HDR_OFFSET"
          ],
          "line": 3061
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic void fill_xsave(u8 *dest, struct kvm_vcpu *vcpu)\n{\n\tstruct xregs_state *xsave = &vcpu->arch.guest_fpu.state.xsave;\n\tu64 xstate_bv = xsave->header.xfeatures;\n\tu64 valid;\n\n\t/*\n\t * Copy legacy XSAVE area, to avoid complications with CPUID\n\t * leaves 0 and 1 in the loop below.\n\t */\n\tmemcpy(dest, xsave, XSAVE_HDR_OFFSET);\n\n\t/* Set XSTATE_BV */\n\t*(u64 *)(dest + XSAVE_HDR_OFFSET) = xstate_bv;\n\n\t/*\n\t * Copy each region from the possibly compacted offset to the\n\t * non-compacted offset.\n\t */\n\tvalid = xstate_bv & ~XFEATURE_MASK_FPSSE;\n\twhile (valid) {\n\t\tu64 feature = valid & -valid;\n\t\tint index = fls64(feature) - 1;\n\t\tvoid *src = get_xsave_addr(xsave, feature);\n\n\t\tif (src) {\n\t\t\tu32 size, offset, ecx, edx;\n\t\t\tcpuid_count(XSTATE_CPUID, index,\n\t\t\t\t    &size, &offset, &ecx, &edx);\n\t\t\tmemcpy(dest + offset, src, size);\n\t\t}\n\n\t\tvalid -= feature;\n\t}\n}"
  },
  {
    "function_name": "kvm_vcpu_ioctl_x86_set_debugregs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "3033-3047",
    "snippet": "static int kvm_vcpu_ioctl_x86_set_debugregs(struct kvm_vcpu *vcpu,\n\t\t\t\t\t    struct kvm_debugregs *dbgregs)\n{\n\tif (dbgregs->flags)\n\t\treturn -EINVAL;\n\n\tmemcpy(vcpu->arch.db, dbgregs->db, sizeof(vcpu->arch.db));\n\tkvm_update_dr0123(vcpu);\n\tvcpu->arch.dr6 = dbgregs->dr6;\n\tkvm_update_dr6(vcpu);\n\tvcpu->arch.dr7 = dbgregs->dr7;\n\tkvm_update_dr7(vcpu);\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_update_dr7",
          "args": [
            "vcpu"
          ],
          "line": 3044
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_update_dr7",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "842-854",
          "snippet": "static void kvm_update_dr7(struct kvm_vcpu *vcpu)\n{\n\tunsigned long dr7;\n\n\tif (vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP)\n\t\tdr7 = vcpu->arch.guest_debug_dr7;\n\telse\n\t\tdr7 = vcpu->arch.dr7;\n\tkvm_x86_ops->set_dr7(vcpu, dr7);\n\tvcpu->arch.switch_db_regs &= ~KVM_DEBUGREG_BP_ENABLED;\n\tif (dr7 & DR7_BP_EN_MASK)\n\t\tvcpu->arch.switch_db_regs |= KVM_DEBUGREG_BP_ENABLED;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "struct kvm_x86_ops *kvm_x86_ops"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nstatic void kvm_update_dr7(struct kvm_vcpu *vcpu)\n{\n\tunsigned long dr7;\n\n\tif (vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP)\n\t\tdr7 = vcpu->arch.guest_debug_dr7;\n\telse\n\t\tdr7 = vcpu->arch.dr7;\n\tkvm_x86_ops->set_dr7(vcpu, dr7);\n\tvcpu->arch.switch_db_regs &= ~KVM_DEBUGREG_BP_ENABLED;\n\tif (dr7 & DR7_BP_EN_MASK)\n\t\tvcpu->arch.switch_db_regs |= KVM_DEBUGREG_BP_ENABLED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_update_dr6",
          "args": [
            "vcpu"
          ],
          "line": 3042
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_update_dr6",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "836-840",
          "snippet": "static void kvm_update_dr6(struct kvm_vcpu *vcpu)\n{\n\tif (!(vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP))\n\t\tkvm_x86_ops->set_dr6(vcpu, vcpu->arch.dr6);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "struct kvm_x86_ops *kvm_x86_ops"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nstatic void kvm_update_dr6(struct kvm_vcpu *vcpu)\n{\n\tif (!(vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP))\n\t\tkvm_x86_ops->set_dr6(vcpu, vcpu->arch.dr6);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_update_dr0123",
          "args": [
            "vcpu"
          ],
          "line": 3040
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_update_dr0123",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "825-834",
          "snippet": "static void kvm_update_dr0123(struct kvm_vcpu *vcpu)\n{\n\tint i;\n\n\tif (!(vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP)) {\n\t\tfor (i = 0; i < KVM_NR_DB_REGS; i++)\n\t\t\tvcpu->arch.eff_db[i] = vcpu->arch.db[i];\n\t\tvcpu->arch.switch_db_regs |= KVM_DEBUGREG_RELOAD;\n\t}\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic void kvm_update_dr0123(struct kvm_vcpu *vcpu)\n{\n\tint i;\n\n\tif (!(vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP)) {\n\t\tfor (i = 0; i < KVM_NR_DB_REGS; i++)\n\t\t\tvcpu->arch.eff_db[i] = vcpu->arch.db[i];\n\t\tvcpu->arch.switch_db_regs |= KVM_DEBUGREG_RELOAD;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "vcpu->arch.db",
            "dbgregs->db",
            "sizeof(vcpu->arch.db)"
          ],
          "line": 3039
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic int kvm_vcpu_ioctl_x86_set_debugregs(struct kvm_vcpu *vcpu,\n\t\t\t\t\t    struct kvm_debugregs *dbgregs)\n{\n\tif (dbgregs->flags)\n\t\treturn -EINVAL;\n\n\tmemcpy(vcpu->arch.db, dbgregs->db, sizeof(vcpu->arch.db));\n\tkvm_update_dr0123(vcpu);\n\tvcpu->arch.dr6 = dbgregs->dr6;\n\tkvm_update_dr6(vcpu);\n\tvcpu->arch.dr7 = dbgregs->dr7;\n\tkvm_update_dr7(vcpu);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "kvm_vcpu_ioctl_x86_get_debugregs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "3020-3031",
    "snippet": "static void kvm_vcpu_ioctl_x86_get_debugregs(struct kvm_vcpu *vcpu,\n\t\t\t\t\t     struct kvm_debugregs *dbgregs)\n{\n\tunsigned long val;\n\n\tmemcpy(dbgregs->db, vcpu->arch.db, sizeof(vcpu->arch.db));\n\tkvm_get_dr(vcpu, 6, &val);\n\tdbgregs->dr6 = val;\n\tdbgregs->dr7 = vcpu->arch.dr7;\n\tdbgregs->flags = 0;\n\tmemset(&dbgregs->reserved, 0, sizeof(dbgregs->reserved));\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&dbgregs->reserved",
            "0",
            "sizeof(dbgregs->reserved)"
          ],
          "line": 3030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_get_dr",
          "args": [
            "vcpu",
            "6",
            "&val"
          ],
          "line": 3026
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_get_dr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "904-925",
          "snippet": "int kvm_get_dr(struct kvm_vcpu *vcpu, int dr, unsigned long *val)\n{\n\tswitch (dr) {\n\tcase 0 ... 3:\n\t\t*val = vcpu->arch.db[dr];\n\t\tbreak;\n\tcase 4:\n\t\t/* fall through */\n\tcase 6:\n\t\tif (vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP)\n\t\t\t*val = vcpu->arch.dr6;\n\t\telse\n\t\t\t*val = kvm_x86_ops->get_dr6(vcpu);\n\t\tbreak;\n\tcase 5:\n\t\t/* fall through */\n\tdefault: /* 7 */\n\t\t*val = vcpu->arch.dr7;\n\t\tbreak;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "struct kvm_x86_ops *kvm_x86_ops"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nint kvm_get_dr(struct kvm_vcpu *vcpu, int dr, unsigned long *val)\n{\n\tswitch (dr) {\n\tcase 0 ... 3:\n\t\t*val = vcpu->arch.db[dr];\n\t\tbreak;\n\tcase 4:\n\t\t/* fall through */\n\tcase 6:\n\t\tif (vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP)\n\t\t\t*val = vcpu->arch.dr6;\n\t\telse\n\t\t\t*val = kvm_x86_ops->get_dr6(vcpu);\n\t\tbreak;\n\tcase 5:\n\t\t/* fall through */\n\tdefault: /* 7 */\n\t\t*val = vcpu->arch.dr7;\n\t\tbreak;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dbgregs->db",
            "vcpu->arch.db",
            "sizeof(vcpu->arch.db)"
          ],
          "line": 3025
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic void kvm_vcpu_ioctl_x86_get_debugregs(struct kvm_vcpu *vcpu,\n\t\t\t\t\t     struct kvm_debugregs *dbgregs)\n{\n\tunsigned long val;\n\n\tmemcpy(dbgregs->db, vcpu->arch.db, sizeof(vcpu->arch.db));\n\tkvm_get_dr(vcpu, 6, &val);\n\tdbgregs->dr6 = val;\n\tdbgregs->dr7 = vcpu->arch.dr7;\n\tdbgregs->flags = 0;\n\tmemset(&dbgregs->reserved, 0, sizeof(dbgregs->reserved));\n}"
  },
  {
    "function_name": "kvm_vcpu_ioctl_x86_set_vcpu_events",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "2966-3018",
    "snippet": "static int kvm_vcpu_ioctl_x86_set_vcpu_events(struct kvm_vcpu *vcpu,\n\t\t\t\t\t      struct kvm_vcpu_events *events)\n{\n\tif (events->flags & ~(KVM_VCPUEVENT_VALID_NMI_PENDING\n\t\t\t      | KVM_VCPUEVENT_VALID_SIPI_VECTOR\n\t\t\t      | KVM_VCPUEVENT_VALID_SHADOW\n\t\t\t      | KVM_VCPUEVENT_VALID_SMM))\n\t\treturn -EINVAL;\n\n\tprocess_nmi(vcpu);\n\tvcpu->arch.exception.pending = events->exception.injected;\n\tvcpu->arch.exception.nr = events->exception.nr;\n\tvcpu->arch.exception.has_error_code = events->exception.has_error_code;\n\tvcpu->arch.exception.error_code = events->exception.error_code;\n\n\tvcpu->arch.interrupt.pending = events->interrupt.injected;\n\tvcpu->arch.interrupt.nr = events->interrupt.nr;\n\tvcpu->arch.interrupt.soft = events->interrupt.soft;\n\tif (events->flags & KVM_VCPUEVENT_VALID_SHADOW)\n\t\tkvm_x86_ops->set_interrupt_shadow(vcpu,\n\t\t\t\t\t\t  events->interrupt.shadow);\n\n\tvcpu->arch.nmi_injected = events->nmi.injected;\n\tif (events->flags & KVM_VCPUEVENT_VALID_NMI_PENDING)\n\t\tvcpu->arch.nmi_pending = events->nmi.pending;\n\tkvm_x86_ops->set_nmi_mask(vcpu, events->nmi.masked);\n\n\tif (events->flags & KVM_VCPUEVENT_VALID_SIPI_VECTOR &&\n\t    lapic_in_kernel(vcpu))\n\t\tvcpu->arch.apic->sipi_vector = events->sipi_vector;\n\n\tif (events->flags & KVM_VCPUEVENT_VALID_SMM) {\n\t\tif (events->smi.smm)\n\t\t\tvcpu->arch.hflags |= HF_SMM_MASK;\n\t\telse\n\t\t\tvcpu->arch.hflags &= ~HF_SMM_MASK;\n\t\tvcpu->arch.smi_pending = events->smi.pending;\n\t\tif (events->smi.smm_inside_nmi)\n\t\t\tvcpu->arch.hflags |= HF_SMM_INSIDE_NMI_MASK;\n\t\telse\n\t\t\tvcpu->arch.hflags &= ~HF_SMM_INSIDE_NMI_MASK;\n\t\tif (lapic_in_kernel(vcpu)) {\n\t\t\tif (events->smi.latched_init)\n\t\t\t\tset_bit(KVM_APIC_INIT, &vcpu->arch.apic->pending_events);\n\t\t\telse\n\t\t\t\tclear_bit(KVM_APIC_INIT, &vcpu->arch.apic->pending_events);\n\t\t}\n\t}\n\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);",
      "struct kvm_x86_ops *kvm_x86_ops"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_make_request",
          "args": [
            "KVM_REQ_EVENT",
            "vcpu"
          ],
          "line": 3015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "KVM_APIC_INIT",
            "&vcpu->arch.apic->pending_events"
          ],
          "line": 3011
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_clear_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/vmx.c",
          "lines": "1592-1597",
          "snippet": "static __always_inline void vmcs_clear_bits(unsigned long field, u32 mask)\n{\n        BUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x2000,\n\t\t\t \"vmcs_clear_bits does not support 64-bit fields\");\n\t__vmcs_writel(field, __vmcs_readl(field) & ~mask);\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"trace.h\"",
            "#include <asm/irq_remapping.h>",
            "#include <asm/apic.h>",
            "#include <asm/kexec.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/mce.h>",
            "#include <asm/virtext.h>",
            "#include <asm/vmx.h>",
            "#include <asm/desc.h>",
            "#include <asm/io.h>",
            "#include <asm/cpu.h>",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/hrtimer.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include \"lapic.h\"",
            "#include \"cpuid.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"trace.h\"\n#include <asm/irq_remapping.h>\n#include <asm/apic.h>\n#include <asm/kexec.h>\n#include <asm/debugreg.h>\n#include <asm/perf_event.h>\n#include <asm/fpu/internal.h>\n#include <asm/mce.h>\n#include <asm/virtext.h>\n#include <asm/vmx.h>\n#include <asm/desc.h>\n#include <asm/io.h>\n#include <asm/cpu.h>\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/hrtimer.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic __always_inline void vmcs_clear_bits(unsigned long field, u32 mask)\n{\n        BUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x2000,\n\t\t\t \"vmcs_clear_bits does not support 64-bit fields\");\n\t__vmcs_writel(field, __vmcs_readl(field) & ~mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "KVM_APIC_INIT",
            "&vcpu->arch.apic->pending_events"
          ],
          "line": 3009
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_set_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/vmx.c",
          "lines": "1599-1604",
          "snippet": "static __always_inline void vmcs_set_bits(unsigned long field, u32 mask)\n{\n        BUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x2000,\n\t\t\t \"vmcs_set_bits does not support 64-bit fields\");\n\t__vmcs_writel(field, __vmcs_readl(field) | mask);\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"trace.h\"",
            "#include <asm/irq_remapping.h>",
            "#include <asm/apic.h>",
            "#include <asm/kexec.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/mce.h>",
            "#include <asm/virtext.h>",
            "#include <asm/vmx.h>",
            "#include <asm/desc.h>",
            "#include <asm/io.h>",
            "#include <asm/cpu.h>",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/hrtimer.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include \"lapic.h\"",
            "#include \"cpuid.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"trace.h\"\n#include <asm/irq_remapping.h>\n#include <asm/apic.h>\n#include <asm/kexec.h>\n#include <asm/debugreg.h>\n#include <asm/perf_event.h>\n#include <asm/fpu/internal.h>\n#include <asm/mce.h>\n#include <asm/virtext.h>\n#include <asm/vmx.h>\n#include <asm/desc.h>\n#include <asm/io.h>\n#include <asm/cpu.h>\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/hrtimer.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic __always_inline void vmcs_set_bits(unsigned long field, u32 mask)\n{\n        BUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x2000,\n\t\t\t \"vmcs_set_bits does not support 64-bit fields\");\n\t__vmcs_writel(field, __vmcs_readl(field) | mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lapic_in_kernel",
          "args": [
            "vcpu"
          ],
          "line": 3007
        },
        "resolved": true,
        "details": {
          "function_name": "lapic_in_kernel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.h",
          "lines": "141-146",
          "snippet": "static inline bool lapic_in_kernel(struct kvm_vcpu *vcpu)\n{\n\tif (static_key_false(&kvm_no_apic_vcpu))\n\t\treturn vcpu->arch.apic;\n\treturn true;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline bool lapic_in_kernel(struct kvm_vcpu *vcpu)\n{\n\tif (static_key_false(&kvm_no_apic_vcpu))\n\t\treturn vcpu->arch.apic;\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_x86_ops->set_nmi_mask",
          "args": [
            "vcpu",
            "events->nmi.masked"
          ],
          "line": 2991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_x86_ops->set_interrupt_shadow",
          "args": [
            "vcpu",
            "events->interrupt.shadow"
          ],
          "line": 2985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "process_nmi",
          "args": [
            "vcpu"
          ],
          "line": 2975
        },
        "resolved": true,
        "details": {
          "function_name": "process_nmi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "6127-6142",
          "snippet": "static void process_nmi(struct kvm_vcpu *vcpu)\n{\n\tunsigned limit = 2;\n\n\t/*\n\t * x86 is limited to one NMI running, and one NMI pending after it.\n\t * If an NMI is already in progress, limit further NMIs to just one.\n\t * Otherwise, allow two (and we'll inject the first one immediately).\n\t */\n\tif (kvm_x86_ops->get_nmi_mask(vcpu) || vcpu->arch.nmi_injected)\n\t\tlimit = 1;\n\n\tvcpu->arch.nmi_pending += atomic_xchg(&vcpu->arch.nmi_queued, 0);\n\tvcpu->arch.nmi_pending = min(vcpu->arch.nmi_pending, limit);\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "struct kvm_x86_ops *kvm_x86_ops"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nstatic void process_nmi(struct kvm_vcpu *vcpu)\n{\n\tunsigned limit = 2;\n\n\t/*\n\t * x86 is limited to one NMI running, and one NMI pending after it.\n\t * If an NMI is already in progress, limit further NMIs to just one.\n\t * Otherwise, allow two (and we'll inject the first one immediately).\n\t */\n\tif (kvm_x86_ops->get_nmi_mask(vcpu) || vcpu->arch.nmi_injected)\n\t\tlimit = 1;\n\n\tvcpu->arch.nmi_pending += atomic_xchg(&vcpu->arch.nmi_queued, 0);\n\tvcpu->arch.nmi_pending = min(vcpu->arch.nmi_pending, limit);\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nstatic int kvm_vcpu_ioctl_x86_set_vcpu_events(struct kvm_vcpu *vcpu,\n\t\t\t\t\t      struct kvm_vcpu_events *events)\n{\n\tif (events->flags & ~(KVM_VCPUEVENT_VALID_NMI_PENDING\n\t\t\t      | KVM_VCPUEVENT_VALID_SIPI_VECTOR\n\t\t\t      | KVM_VCPUEVENT_VALID_SHADOW\n\t\t\t      | KVM_VCPUEVENT_VALID_SMM))\n\t\treturn -EINVAL;\n\n\tprocess_nmi(vcpu);\n\tvcpu->arch.exception.pending = events->exception.injected;\n\tvcpu->arch.exception.nr = events->exception.nr;\n\tvcpu->arch.exception.has_error_code = events->exception.has_error_code;\n\tvcpu->arch.exception.error_code = events->exception.error_code;\n\n\tvcpu->arch.interrupt.pending = events->interrupt.injected;\n\tvcpu->arch.interrupt.nr = events->interrupt.nr;\n\tvcpu->arch.interrupt.soft = events->interrupt.soft;\n\tif (events->flags & KVM_VCPUEVENT_VALID_SHADOW)\n\t\tkvm_x86_ops->set_interrupt_shadow(vcpu,\n\t\t\t\t\t\t  events->interrupt.shadow);\n\n\tvcpu->arch.nmi_injected = events->nmi.injected;\n\tif (events->flags & KVM_VCPUEVENT_VALID_NMI_PENDING)\n\t\tvcpu->arch.nmi_pending = events->nmi.pending;\n\tkvm_x86_ops->set_nmi_mask(vcpu, events->nmi.masked);\n\n\tif (events->flags & KVM_VCPUEVENT_VALID_SIPI_VECTOR &&\n\t    lapic_in_kernel(vcpu))\n\t\tvcpu->arch.apic->sipi_vector = events->sipi_vector;\n\n\tif (events->flags & KVM_VCPUEVENT_VALID_SMM) {\n\t\tif (events->smi.smm)\n\t\t\tvcpu->arch.hflags |= HF_SMM_MASK;\n\t\telse\n\t\t\tvcpu->arch.hflags &= ~HF_SMM_MASK;\n\t\tvcpu->arch.smi_pending = events->smi.pending;\n\t\tif (events->smi.smm_inside_nmi)\n\t\t\tvcpu->arch.hflags |= HF_SMM_INSIDE_NMI_MASK;\n\t\telse\n\t\t\tvcpu->arch.hflags &= ~HF_SMM_INSIDE_NMI_MASK;\n\t\tif (lapic_in_kernel(vcpu)) {\n\t\t\tif (events->smi.latched_init)\n\t\t\t\tset_bit(KVM_APIC_INIT, &vcpu->arch.apic->pending_events);\n\t\t\telse\n\t\t\t\tclear_bit(KVM_APIC_INIT, &vcpu->arch.apic->pending_events);\n\t\t}\n\t}\n\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "kvm_vcpu_ioctl_x86_get_vcpu_events",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "2929-2964",
    "snippet": "static void kvm_vcpu_ioctl_x86_get_vcpu_events(struct kvm_vcpu *vcpu,\n\t\t\t\t\t       struct kvm_vcpu_events *events)\n{\n\tprocess_nmi(vcpu);\n\tevents->exception.injected =\n\t\tvcpu->arch.exception.pending &&\n\t\t!kvm_exception_is_soft(vcpu->arch.exception.nr);\n\tevents->exception.nr = vcpu->arch.exception.nr;\n\tevents->exception.has_error_code = vcpu->arch.exception.has_error_code;\n\tevents->exception.pad = 0;\n\tevents->exception.error_code = vcpu->arch.exception.error_code;\n\n\tevents->interrupt.injected =\n\t\tvcpu->arch.interrupt.pending && !vcpu->arch.interrupt.soft;\n\tevents->interrupt.nr = vcpu->arch.interrupt.nr;\n\tevents->interrupt.soft = 0;\n\tevents->interrupt.shadow = kvm_x86_ops->get_interrupt_shadow(vcpu);\n\n\tevents->nmi.injected = vcpu->arch.nmi_injected;\n\tevents->nmi.pending = vcpu->arch.nmi_pending != 0;\n\tevents->nmi.masked = kvm_x86_ops->get_nmi_mask(vcpu);\n\tevents->nmi.pad = 0;\n\n\tevents->sipi_vector = 0; /* never valid when reporting to user space */\n\n\tevents->smi.smm = is_smm(vcpu);\n\tevents->smi.pending = vcpu->arch.smi_pending;\n\tevents->smi.smm_inside_nmi =\n\t\t!!(vcpu->arch.hflags & HF_SMM_INSIDE_NMI_MASK);\n\tevents->smi.latched_init = kvm_lapic_latched_init(vcpu);\n\n\tevents->flags = (KVM_VCPUEVENT_VALID_NMI_PENDING\n\t\t\t | KVM_VCPUEVENT_VALID_SHADOW\n\t\t\t | KVM_VCPUEVENT_VALID_SMM);\n\tmemset(&events->reserved, 0, sizeof(events->reserved));\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);",
      "struct kvm_x86_ops *kvm_x86_ops"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&events->reserved",
            "0",
            "sizeof(events->reserved)"
          ],
          "line": 2963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_lapic_latched_init",
          "args": [
            "vcpu"
          ],
          "line": 2958
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_latched_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.h",
          "lines": "197-200",
          "snippet": "static inline int kvm_lapic_latched_init(struct kvm_vcpu *vcpu)\n{\n\treturn lapic_in_kernel(vcpu) && test_bit(KVM_APIC_INIT, &vcpu->arch.apic->pending_events);\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [
            "#define KVM_APIC_INIT\t\t0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\n#define KVM_APIC_INIT\t\t0\n\nstatic inline int kvm_lapic_latched_init(struct kvm_vcpu *vcpu)\n{\n\treturn lapic_in_kernel(vcpu) && test_bit(KVM_APIC_INIT, &vcpu->arch.apic->pending_events);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_smm",
          "args": [
            "vcpu"
          ],
          "line": 2954
        },
        "resolved": true,
        "details": {
          "function_name": "is_smm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "107-110",
          "snippet": "static inline bool is_smm(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.hflags & HF_SMM_MASK;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline bool is_smm(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.hflags & HF_SMM_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_x86_ops->get_nmi_mask",
          "args": [
            "vcpu"
          ],
          "line": 2949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_x86_ops->get_interrupt_shadow",
          "args": [
            "vcpu"
          ],
          "line": 2945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_exception_is_soft",
          "args": [
            "vcpu->arch.exception.nr"
          ],
          "line": 2935
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_exception_is_soft",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.h",
          "lines": "33-36",
          "snippet": "static inline bool kvm_exception_is_soft(unsigned int nr)\n{\n\treturn (nr == BP_VECTOR) || (nr == OF_VECTOR);\n}",
          "includes": [
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline bool kvm_exception_is_soft(unsigned int nr)\n{\n\treturn (nr == BP_VECTOR) || (nr == OF_VECTOR);\n}"
        }
      },
      {
        "call_info": {
          "callee": "process_nmi",
          "args": [
            "vcpu"
          ],
          "line": 2932
        },
        "resolved": true,
        "details": {
          "function_name": "process_nmi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "6127-6142",
          "snippet": "static void process_nmi(struct kvm_vcpu *vcpu)\n{\n\tunsigned limit = 2;\n\n\t/*\n\t * x86 is limited to one NMI running, and one NMI pending after it.\n\t * If an NMI is already in progress, limit further NMIs to just one.\n\t * Otherwise, allow two (and we'll inject the first one immediately).\n\t */\n\tif (kvm_x86_ops->get_nmi_mask(vcpu) || vcpu->arch.nmi_injected)\n\t\tlimit = 1;\n\n\tvcpu->arch.nmi_pending += atomic_xchg(&vcpu->arch.nmi_queued, 0);\n\tvcpu->arch.nmi_pending = min(vcpu->arch.nmi_pending, limit);\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "struct kvm_x86_ops *kvm_x86_ops"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nstatic void process_nmi(struct kvm_vcpu *vcpu)\n{\n\tunsigned limit = 2;\n\n\t/*\n\t * x86 is limited to one NMI running, and one NMI pending after it.\n\t * If an NMI is already in progress, limit further NMIs to just one.\n\t * Otherwise, allow two (and we'll inject the first one immediately).\n\t */\n\tif (kvm_x86_ops->get_nmi_mask(vcpu) || vcpu->arch.nmi_injected)\n\t\tlimit = 1;\n\n\tvcpu->arch.nmi_pending += atomic_xchg(&vcpu->arch.nmi_queued, 0);\n\tvcpu->arch.nmi_pending = min(vcpu->arch.nmi_pending, limit);\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nstatic void kvm_vcpu_ioctl_x86_get_vcpu_events(struct kvm_vcpu *vcpu,\n\t\t\t\t\t       struct kvm_vcpu_events *events)\n{\n\tprocess_nmi(vcpu);\n\tevents->exception.injected =\n\t\tvcpu->arch.exception.pending &&\n\t\t!kvm_exception_is_soft(vcpu->arch.exception.nr);\n\tevents->exception.nr = vcpu->arch.exception.nr;\n\tevents->exception.has_error_code = vcpu->arch.exception.has_error_code;\n\tevents->exception.pad = 0;\n\tevents->exception.error_code = vcpu->arch.exception.error_code;\n\n\tevents->interrupt.injected =\n\t\tvcpu->arch.interrupt.pending && !vcpu->arch.interrupt.soft;\n\tevents->interrupt.nr = vcpu->arch.interrupt.nr;\n\tevents->interrupt.soft = 0;\n\tevents->interrupt.shadow = kvm_x86_ops->get_interrupt_shadow(vcpu);\n\n\tevents->nmi.injected = vcpu->arch.nmi_injected;\n\tevents->nmi.pending = vcpu->arch.nmi_pending != 0;\n\tevents->nmi.masked = kvm_x86_ops->get_nmi_mask(vcpu);\n\tevents->nmi.pad = 0;\n\n\tevents->sipi_vector = 0; /* never valid when reporting to user space */\n\n\tevents->smi.smm = is_smm(vcpu);\n\tevents->smi.pending = vcpu->arch.smi_pending;\n\tevents->smi.smm_inside_nmi =\n\t\t!!(vcpu->arch.hflags & HF_SMM_INSIDE_NMI_MASK);\n\tevents->smi.latched_init = kvm_lapic_latched_init(vcpu);\n\n\tevents->flags = (KVM_VCPUEVENT_VALID_NMI_PENDING\n\t\t\t | KVM_VCPUEVENT_VALID_SHADOW\n\t\t\t | KVM_VCPUEVENT_VALID_SMM);\n\tmemset(&events->reserved, 0, sizeof(events->reserved));\n}"
  },
  {
    "function_name": "kvm_vcpu_ioctl_x86_set_mce",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "2881-2927",
    "snippet": "static int kvm_vcpu_ioctl_x86_set_mce(struct kvm_vcpu *vcpu,\n\t\t\t\t      struct kvm_x86_mce *mce)\n{\n\tu64 mcg_cap = vcpu->arch.mcg_cap;\n\tunsigned bank_num = mcg_cap & 0xff;\n\tu64 *banks = vcpu->arch.mce_banks;\n\n\tif (mce->bank >= bank_num || !(mce->status & MCI_STATUS_VAL))\n\t\treturn -EINVAL;\n\t/*\n\t * if IA32_MCG_CTL is not all 1s, the uncorrected error\n\t * reporting is disabled\n\t */\n\tif ((mce->status & MCI_STATUS_UC) && (mcg_cap & MCG_CTL_P) &&\n\t    vcpu->arch.mcg_ctl != ~(u64)0)\n\t\treturn 0;\n\tbanks += 4 * mce->bank;\n\t/*\n\t * if IA32_MCi_CTL is not all 1s, the uncorrected error\n\t * reporting is disabled for the bank\n\t */\n\tif ((mce->status & MCI_STATUS_UC) && banks[0] != ~(u64)0)\n\t\treturn 0;\n\tif (mce->status & MCI_STATUS_UC) {\n\t\tif ((vcpu->arch.mcg_status & MCG_STATUS_MCIP) ||\n\t\t    !kvm_read_cr4_bits(vcpu, X86_CR4_MCE)) {\n\t\t\tkvm_make_request(KVM_REQ_TRIPLE_FAULT, vcpu);\n\t\t\treturn 0;\n\t\t}\n\t\tif (banks[1] & MCI_STATUS_VAL)\n\t\t\tmce->status |= MCI_STATUS_OVER;\n\t\tbanks[2] = mce->addr;\n\t\tbanks[3] = mce->misc;\n\t\tvcpu->arch.mcg_status = mce->mcg_status;\n\t\tbanks[1] = mce->status;\n\t\tkvm_queue_exception(vcpu, MC_VECTOR);\n\t} else if (!(banks[1] & MCI_STATUS_VAL)\n\t\t   || !(banks[1] & MCI_STATUS_UC)) {\n\t\tif (banks[1] & MCI_STATUS_VAL)\n\t\t\tmce->status |= MCI_STATUS_OVER;\n\t\tbanks[2] = mce->addr;\n\t\tbanks[3] = mce->misc;\n\t\tbanks[1] = mce->status;\n\t} else\n\t\tbanks[1] |= MCI_STATUS_OVER;\n\treturn 0;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_queue_exception",
          "args": [
            "vcpu",
            "MC_VECTOR"
          ],
          "line": 2916
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_queue_exception",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "409-412",
          "snippet": "void kvm_queue_exception(struct kvm_vcpu *vcpu, unsigned nr)\n{\n\tkvm_multiple_exception(vcpu, nr, false, 0, false);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nvoid kvm_queue_exception(struct kvm_vcpu *vcpu, unsigned nr)\n{\n\tkvm_multiple_exception(vcpu, nr, false, 0, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_make_request",
          "args": [
            "KVM_REQ_TRIPLE_FAULT",
            "vcpu"
          ],
          "line": 2907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_read_cr4_bits",
          "args": [
            "vcpu",
            "X86_CR4_MCE"
          ],
          "line": 2906
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_read_cr4_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "61-67",
          "snippet": "static inline ulong kvm_read_cr4_bits(struct kvm_vcpu *vcpu, ulong mask)\n{\n\tulong tmask = mask & KVM_POSSIBLE_CR4_GUEST_BITS;\n\tif (tmask & vcpu->arch.cr4_guest_owned_bits)\n\t\tkvm_x86_ops->decache_cr4_guest_bits(vcpu);\n\treturn vcpu->arch.cr4 & mask;\n}",
          "includes": [],
          "macros_used": [
            "#define KVM_POSSIBLE_CR4_GUEST_BITS\t\t\t\t  \\\n\t(X86_CR4_PVI | X86_CR4_DE | X86_CR4_PCE | X86_CR4_OSFXSR  \\\n\t | X86_CR4_OSXMMEXCPT | X86_CR4_PGE)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define KVM_POSSIBLE_CR4_GUEST_BITS\t\t\t\t  \\\n\t(X86_CR4_PVI | X86_CR4_DE | X86_CR4_PCE | X86_CR4_OSFXSR  \\\n\t | X86_CR4_OSXMMEXCPT | X86_CR4_PGE)\n\nstatic inline ulong kvm_read_cr4_bits(struct kvm_vcpu *vcpu, ulong mask)\n{\n\tulong tmask = mask & KVM_POSSIBLE_CR4_GUEST_BITS;\n\tif (tmask & vcpu->arch.cr4_guest_owned_bits)\n\t\tkvm_x86_ops->decache_cr4_guest_bits(vcpu);\n\treturn vcpu->arch.cr4 & mask;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic int kvm_vcpu_ioctl_x86_set_mce(struct kvm_vcpu *vcpu,\n\t\t\t\t      struct kvm_x86_mce *mce)\n{\n\tu64 mcg_cap = vcpu->arch.mcg_cap;\n\tunsigned bank_num = mcg_cap & 0xff;\n\tu64 *banks = vcpu->arch.mce_banks;\n\n\tif (mce->bank >= bank_num || !(mce->status & MCI_STATUS_VAL))\n\t\treturn -EINVAL;\n\t/*\n\t * if IA32_MCG_CTL is not all 1s, the uncorrected error\n\t * reporting is disabled\n\t */\n\tif ((mce->status & MCI_STATUS_UC) && (mcg_cap & MCG_CTL_P) &&\n\t    vcpu->arch.mcg_ctl != ~(u64)0)\n\t\treturn 0;\n\tbanks += 4 * mce->bank;\n\t/*\n\t * if IA32_MCi_CTL is not all 1s, the uncorrected error\n\t * reporting is disabled for the bank\n\t */\n\tif ((mce->status & MCI_STATUS_UC) && banks[0] != ~(u64)0)\n\t\treturn 0;\n\tif (mce->status & MCI_STATUS_UC) {\n\t\tif ((vcpu->arch.mcg_status & MCG_STATUS_MCIP) ||\n\t\t    !kvm_read_cr4_bits(vcpu, X86_CR4_MCE)) {\n\t\t\tkvm_make_request(KVM_REQ_TRIPLE_FAULT, vcpu);\n\t\t\treturn 0;\n\t\t}\n\t\tif (banks[1] & MCI_STATUS_VAL)\n\t\t\tmce->status |= MCI_STATUS_OVER;\n\t\tbanks[2] = mce->addr;\n\t\tbanks[3] = mce->misc;\n\t\tvcpu->arch.mcg_status = mce->mcg_status;\n\t\tbanks[1] = mce->status;\n\t\tkvm_queue_exception(vcpu, MC_VECTOR);\n\t} else if (!(banks[1] & MCI_STATUS_VAL)\n\t\t   || !(banks[1] & MCI_STATUS_UC)) {\n\t\tif (banks[1] & MCI_STATUS_VAL)\n\t\t\tmce->status |= MCI_STATUS_OVER;\n\t\tbanks[2] = mce->addr;\n\t\tbanks[3] = mce->misc;\n\t\tbanks[1] = mce->status;\n\t} else\n\t\tbanks[1] |= MCI_STATUS_OVER;\n\treturn 0;\n}"
  },
  {
    "function_name": "kvm_vcpu_ioctl_x86_setup_mce",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "2858-2879",
    "snippet": "static int kvm_vcpu_ioctl_x86_setup_mce(struct kvm_vcpu *vcpu,\n\t\t\t\t\tu64 mcg_cap)\n{\n\tint r;\n\tunsigned bank_num = mcg_cap & 0xff, bank;\n\n\tr = -EINVAL;\n\tif (!bank_num || bank_num >= KVM_MAX_MCE_BANKS)\n\t\tgoto out;\n\tif (mcg_cap & ~(KVM_MCE_CAP_SUPPORTED | 0xff | 0xff0000))\n\t\tgoto out;\n\tr = 0;\n\tvcpu->arch.mcg_cap = mcg_cap;\n\t/* Init IA32_MCG_CTL to all 1s */\n\tif (mcg_cap & MCG_CTL_P)\n\t\tvcpu->arch.mcg_ctl = ~(u64)0;\n\t/* Init IA32_MCi_CTL to all 1s */\n\tfor (bank = 0; bank < bank_num; bank++)\n\t\tvcpu->arch.mce_banks[bank*4] = ~(u64)0;\nout:\n\treturn r;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define KVM_MCE_CAP_SUPPORTED (MCG_CTL_P | MCG_SER_P)",
      "#define KVM_MAX_MCE_BANKS 32"
    ],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define KVM_MCE_CAP_SUPPORTED (MCG_CTL_P | MCG_SER_P)\n#define KVM_MAX_MCE_BANKS 32\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic int kvm_vcpu_ioctl_x86_setup_mce(struct kvm_vcpu *vcpu,\n\t\t\t\t\tu64 mcg_cap)\n{\n\tint r;\n\tunsigned bank_num = mcg_cap & 0xff, bank;\n\n\tr = -EINVAL;\n\tif (!bank_num || bank_num >= KVM_MAX_MCE_BANKS)\n\t\tgoto out;\n\tif (mcg_cap & ~(KVM_MCE_CAP_SUPPORTED | 0xff | 0xff0000))\n\t\tgoto out;\n\tr = 0;\n\tvcpu->arch.mcg_cap = mcg_cap;\n\t/* Init IA32_MCG_CTL to all 1s */\n\tif (mcg_cap & MCG_CTL_P)\n\t\tvcpu->arch.mcg_ctl = ~(u64)0;\n\t/* Init IA32_MCi_CTL to all 1s */\n\tfor (bank = 0; bank < bank_num; bank++)\n\t\tvcpu->arch.mce_banks[bank*4] = ~(u64)0;\nout:\n\treturn r;\n}"
  },
  {
    "function_name": "vcpu_ioctl_tpr_access_reporting",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "2849-2856",
    "snippet": "static int vcpu_ioctl_tpr_access_reporting(struct kvm_vcpu *vcpu,\n\t\t\t\t\t   struct kvm_tpr_access_ctl *tac)\n{\n\tif (tac->flags)\n\t\treturn -EINVAL;\n\tvcpu->arch.tpr_access_reporting = !!tac->enabled;\n\treturn 0;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic int vcpu_ioctl_tpr_access_reporting(struct kvm_vcpu *vcpu,\n\t\t\t\t\t   struct kvm_tpr_access_ctl *tac)\n{\n\tif (tac->flags)\n\t\treturn -EINVAL;\n\tvcpu->arch.tpr_access_reporting = !!tac->enabled;\n\treturn 0;\n}"
  },
  {
    "function_name": "kvm_vcpu_ioctl_smi",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "2842-2847",
    "snippet": "static int kvm_vcpu_ioctl_smi(struct kvm_vcpu *vcpu)\n{\n\tkvm_make_request(KVM_REQ_SMI, vcpu);\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_make_request",
          "args": [
            "KVM_REQ_SMI",
            "vcpu"
          ],
          "line": 2844
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic int kvm_vcpu_ioctl_smi(struct kvm_vcpu *vcpu)\n{\n\tkvm_make_request(KVM_REQ_SMI, vcpu);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "kvm_vcpu_ioctl_nmi",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "2835-2840",
    "snippet": "static int kvm_vcpu_ioctl_nmi(struct kvm_vcpu *vcpu)\n{\n\tkvm_inject_nmi(vcpu);\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_inject_nmi",
          "args": [
            "vcpu"
          ],
          "line": 2837
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_inject_nmi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "448-452",
          "snippet": "void kvm_inject_nmi(struct kvm_vcpu *vcpu)\n{\n\tatomic_inc(&vcpu->arch.nmi_queued);\n\tkvm_make_request(KVM_REQ_NMI, vcpu);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nvoid kvm_inject_nmi(struct kvm_vcpu *vcpu)\n{\n\tatomic_inc(&vcpu->arch.nmi_queued);\n\tkvm_make_request(KVM_REQ_NMI, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic int kvm_vcpu_ioctl_nmi(struct kvm_vcpu *vcpu)\n{\n\tkvm_inject_nmi(vcpu);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "kvm_vcpu_ioctl_interrupt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "2808-2833",
    "snippet": "static int kvm_vcpu_ioctl_interrupt(struct kvm_vcpu *vcpu,\n\t\t\t\t    struct kvm_interrupt *irq)\n{\n\tif (irq->irq >= KVM_NR_INTERRUPTS)\n\t\treturn -EINVAL;\n\n\tif (!irqchip_in_kernel(vcpu->kvm)) {\n\t\tkvm_queue_interrupt(vcpu, irq->irq, false);\n\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * With in-kernel LAPIC, we only use this to inject EXTINT, so\n\t * fail for in-kernel 8259.\n\t */\n\tif (pic_in_kernel(vcpu->kvm))\n\t\treturn -ENXIO;\n\n\tif (vcpu->arch.pending_external_vector != -1)\n\t\treturn -EEXIST;\n\n\tvcpu->arch.pending_external_vector = irq->irq;\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\treturn 0;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_make_request",
          "args": [
            "KVM_REQ_EVENT",
            "vcpu"
          ],
          "line": 2831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pic_in_kernel",
          "args": [
            "vcpu->kvm"
          ],
          "line": 2824
        },
        "resolved": true,
        "details": {
          "function_name": "ioapic_in_kernel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/ioapic.h",
          "lines": "113-119",
          "snippet": "static inline int ioapic_in_kernel(struct kvm *kvm)\n{\n\tint ret;\n\n\tret = (ioapic_irqchip(kvm) != NULL);\n\treturn ret;\n}",
          "includes": [
            "#include <kvm/iodev.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kvm/iodev.h>\n#include <linux/kvm_host.h>\n\nstatic inline int ioapic_in_kernel(struct kvm *kvm)\n{\n\tint ret;\n\n\tret = (ioapic_irqchip(kvm) != NULL);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_make_request",
          "args": [
            "KVM_REQ_EVENT",
            "vcpu"
          ],
          "line": 2816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_queue_interrupt",
          "args": [
            "vcpu",
            "irq->irq",
            "false"
          ],
          "line": 2815
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_queue_interrupt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.h",
          "lines": "14-20",
          "snippet": "static inline void kvm_queue_interrupt(struct kvm_vcpu *vcpu, u8 vector,\n\tbool soft)\n{\n\tvcpu->arch.interrupt.pending = true;\n\tvcpu->arch.interrupt.soft = soft;\n\tvcpu->arch.interrupt.nr = vector;\n}",
          "includes": [
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline void kvm_queue_interrupt(struct kvm_vcpu *vcpu, u8 vector,\n\tbool soft)\n{\n\tvcpu->arch.interrupt.pending = true;\n\tvcpu->arch.interrupt.soft = soft;\n\tvcpu->arch.interrupt.nr = vector;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irqchip_in_kernel",
          "args": [
            "vcpu->kvm"
          ],
          "line": 2814
        },
        "resolved": true,
        "details": {
          "function_name": "irqchip_in_kernel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/irq.h",
          "lines": "99-110",
          "snippet": "static inline int irqchip_in_kernel(struct kvm *kvm)\n{\n\tstruct kvm_pic *vpic = pic_irqchip(kvm);\n\tbool ret;\n\n\tret = (vpic != NULL);\n\tret |= irqchip_split(kvm);\n\n\t/* Read vpic before kvm->irq_routing.  */\n\tsmp_rmb();\n\treturn ret;\n}",
          "includes": [
            "#include \"lapic.h\"",
            "#include \"ioapic.h\"",
            "#include <kvm/iodev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/mm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <kvm/iodev.h>\n#include <linux/spinlock.h>\n#include <linux/kvm_host.h>\n#include <linux/hrtimer.h>\n#include <linux/mm_types.h>\n\nstatic inline int irqchip_in_kernel(struct kvm *kvm)\n{\n\tstruct kvm_pic *vpic = pic_irqchip(kvm);\n\tbool ret;\n\n\tret = (vpic != NULL);\n\tret |= irqchip_split(kvm);\n\n\t/* Read vpic before kvm->irq_routing.  */\n\tsmp_rmb();\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic int kvm_vcpu_ioctl_interrupt(struct kvm_vcpu *vcpu,\n\t\t\t\t    struct kvm_interrupt *irq)\n{\n\tif (irq->irq >= KVM_NR_INTERRUPTS)\n\t\treturn -EINVAL;\n\n\tif (!irqchip_in_kernel(vcpu->kvm)) {\n\t\tkvm_queue_interrupt(vcpu, irq->irq, false);\n\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * With in-kernel LAPIC, we only use this to inject EXTINT, so\n\t * fail for in-kernel 8259.\n\t */\n\tif (pic_in_kernel(vcpu->kvm))\n\t\treturn -ENXIO;\n\n\tif (vcpu->arch.pending_external_vector != -1)\n\t\treturn -EEXIST;\n\n\tvcpu->arch.pending_external_vector = irq->irq;\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\treturn 0;\n}"
  },
  {
    "function_name": "kvm_vcpu_ready_for_interrupt_injection",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "2800-2806",
    "snippet": "static int kvm_vcpu_ready_for_interrupt_injection(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_arch_interrupt_allowed(vcpu) &&\n\t\t!kvm_cpu_has_interrupt(vcpu) &&\n\t\t!kvm_event_needs_reinjection(vcpu) &&\n\t\tkvm_cpu_accept_dm_intr(vcpu);\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_cpu_accept_dm_intr",
          "args": [
            "vcpu"
          ],
          "line": 2805
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_cpu_accept_dm_intr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "2788-2792",
          "snippet": "static int kvm_cpu_accept_dm_intr(struct kvm_vcpu *vcpu)\n{\n\treturn (!lapic_in_kernel(vcpu) ||\n\t\tkvm_apic_accept_pic_intr(vcpu));\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic int kvm_cpu_accept_dm_intr(struct kvm_vcpu *vcpu)\n{\n\treturn (!lapic_in_kernel(vcpu) ||\n\t\tkvm_apic_accept_pic_intr(vcpu));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_event_needs_reinjection",
          "args": [
            "vcpu"
          ],
          "line": 2804
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_event_needs_reinjection",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.h",
          "lines": "27-31",
          "snippet": "static inline bool kvm_event_needs_reinjection(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.exception.pending || vcpu->arch.interrupt.pending ||\n\t\tvcpu->arch.nmi_injected;\n}",
          "includes": [
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline bool kvm_event_needs_reinjection(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.exception.pending || vcpu->arch.interrupt.pending ||\n\t\tvcpu->arch.nmi_injected;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_cpu_has_interrupt",
          "args": [
            "vcpu"
          ],
          "line": 2803
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_cpu_has_interrupt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/irq.c",
          "lines": "92-101",
          "snippet": "int kvm_cpu_has_interrupt(struct kvm_vcpu *v)\n{\n\tif (!lapic_in_kernel(v))\n\t\treturn v->arch.interrupt.pending;\n\n\tif (kvm_cpu_has_extint(v))\n\t\treturn 1;\n\n\treturn kvm_apic_has_interrupt(v) != -1;\t/* LAPIC */\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"i8254.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"i8254.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n#include <linux/module.h>\n\nint kvm_cpu_has_interrupt(struct kvm_vcpu *v)\n{\n\tif (!lapic_in_kernel(v))\n\t\treturn v->arch.interrupt.pending;\n\n\tif (kvm_cpu_has_extint(v))\n\t\treturn 1;\n\n\treturn kvm_apic_has_interrupt(v) != -1;\t/* LAPIC */\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_arch_interrupt_allowed",
          "args": [
            "vcpu"
          ],
          "line": 2802
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_arch_interrupt_allowed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "8143-8146",
          "snippet": "int kvm_arch_interrupt_allowed(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_x86_ops->interrupt_allowed(vcpu);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "struct kvm_x86_ops *kvm_x86_ops"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nint kvm_arch_interrupt_allowed(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_x86_ops->interrupt_allowed(vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic int kvm_vcpu_ready_for_interrupt_injection(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_arch_interrupt_allowed(vcpu) &&\n\t\t!kvm_cpu_has_interrupt(vcpu) &&\n\t\t!kvm_event_needs_reinjection(vcpu) &&\n\t\tkvm_cpu_accept_dm_intr(vcpu);\n}"
  },
  {
    "function_name": "kvm_cpu_accept_dm_intr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "2788-2792",
    "snippet": "static int kvm_cpu_accept_dm_intr(struct kvm_vcpu *vcpu)\n{\n\treturn (!lapic_in_kernel(vcpu) ||\n\t\tkvm_apic_accept_pic_intr(vcpu));\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_apic_accept_pic_intr",
          "args": [
            "vcpu"
          ],
          "line": 2791
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_accept_pic_intr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "1888-1899",
          "snippet": "int kvm_apic_accept_pic_intr(struct kvm_vcpu *vcpu)\n{\n\tu32 lvt0 = kvm_lapic_get_reg(vcpu->arch.apic, APIC_LVT0);\n\tint r = 0;\n\n\tif (!kvm_apic_hw_enabled(vcpu->arch.apic))\n\t\tr = 1;\n\tif ((lvt0 & APIC_LVT_MASKED) == 0 &&\n\t    GET_APIC_DELIVERY_MODE(lvt0) == APIC_MODE_EXTINT)\n\t\tr = 1;\n\treturn r;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nint kvm_apic_accept_pic_intr(struct kvm_vcpu *vcpu)\n{\n\tu32 lvt0 = kvm_lapic_get_reg(vcpu->arch.apic, APIC_LVT0);\n\tint r = 0;\n\n\tif (!kvm_apic_hw_enabled(vcpu->arch.apic))\n\t\tr = 1;\n\tif ((lvt0 & APIC_LVT_MASKED) == 0 &&\n\t    GET_APIC_DELIVERY_MODE(lvt0) == APIC_MODE_EXTINT)\n\t\tr = 1;\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lapic_in_kernel",
          "args": [
            "vcpu"
          ],
          "line": 2790
        },
        "resolved": true,
        "details": {
          "function_name": "lapic_in_kernel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.h",
          "lines": "141-146",
          "snippet": "static inline bool lapic_in_kernel(struct kvm_vcpu *vcpu)\n{\n\tif (static_key_false(&kvm_no_apic_vcpu))\n\t\treturn vcpu->arch.apic;\n\treturn true;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline bool lapic_in_kernel(struct kvm_vcpu *vcpu)\n{\n\tif (static_key_false(&kvm_no_apic_vcpu))\n\t\treturn vcpu->arch.apic;\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic int kvm_cpu_accept_dm_intr(struct kvm_vcpu *vcpu)\n{\n\treturn (!lapic_in_kernel(vcpu) ||\n\t\tkvm_apic_accept_pic_intr(vcpu));\n}"
  },
  {
    "function_name": "kvm_vcpu_ioctl_set_lapic",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "2779-2786",
    "snippet": "static int kvm_vcpu_ioctl_set_lapic(struct kvm_vcpu *vcpu,\n\t\t\t\t    struct kvm_lapic_state *s)\n{\n\tkvm_apic_post_state_restore(vcpu, s);\n\tupdate_cr8_intercept(vcpu);\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "update_cr8_intercept",
          "args": [
            "vcpu"
          ],
          "line": 2783
        },
        "resolved": true,
        "details": {
          "function_name": "update_cr8_intercept",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "6031-6055",
          "snippet": "static void update_cr8_intercept(struct kvm_vcpu *vcpu)\n{\n\tint max_irr, tpr;\n\n\tif (!kvm_x86_ops->update_cr8_intercept)\n\t\treturn;\n\n\tif (!lapic_in_kernel(vcpu))\n\t\treturn;\n\n\tif (vcpu->arch.apicv_active)\n\t\treturn;\n\n\tif (!vcpu->arch.apic->vapic_addr)\n\t\tmax_irr = kvm_lapic_find_highest_irr(vcpu);\n\telse\n\t\tmax_irr = -1;\n\n\tif (max_irr != -1)\n\t\tmax_irr >>= 4;\n\n\ttpr = kvm_lapic_get_cr8(vcpu);\n\n\tkvm_x86_ops->update_cr8_intercept(vcpu, tpr, max_irr);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "struct kvm_x86_ops *kvm_x86_ops"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu)\n{\n\tint max_irr, tpr;\n\n\tif (!kvm_x86_ops->update_cr8_intercept)\n\t\treturn;\n\n\tif (!lapic_in_kernel(vcpu))\n\t\treturn;\n\n\tif (vcpu->arch.apicv_active)\n\t\treturn;\n\n\tif (!vcpu->arch.apic->vapic_addr)\n\t\tmax_irr = kvm_lapic_find_highest_irr(vcpu);\n\telse\n\t\tmax_irr = -1;\n\n\tif (max_irr != -1)\n\t\tmax_irr >>= 4;\n\n\ttpr = kvm_lapic_get_cr8(vcpu);\n\n\tkvm_x86_ops->update_cr8_intercept(vcpu, tpr, max_irr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_apic_post_state_restore",
          "args": [
            "vcpu",
            "s"
          ],
          "line": 2782
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_post_state_restore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "1940-1976",
          "snippet": "void kvm_apic_post_state_restore(struct kvm_vcpu *vcpu,\n\t\tstruct kvm_lapic_state *s)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tkvm_lapic_set_base(vcpu, vcpu->arch.apic_base);\n\t/* set SPIV separately to get count of SW disabled APICs right */\n\tapic_set_spiv(apic, *((u32 *)(s->regs + APIC_SPIV)));\n\tmemcpy(vcpu->arch.apic->regs, s->regs, sizeof *s);\n\t/* call kvm_apic_set_id() to put apic into apic_map */\n\tkvm_apic_set_id(apic, kvm_apic_id(apic));\n\tkvm_apic_set_version(vcpu);\n\n\tapic_update_ppr(apic);\n\thrtimer_cancel(&apic->lapic_timer.timer);\n\tapic_update_lvtt(apic);\n\tapic_manage_nmi_watchdog(apic, kvm_lapic_get_reg(apic, APIC_LVT0));\n\tupdate_divide_count(apic);\n\tstart_apic_timer(apic);\n\tapic->irr_pending = true;\n\tapic->isr_count = vcpu->arch.apicv_active ?\n\t\t\t\t1 : count_vectors(apic->regs + APIC_ISR);\n\tapic->highest_isr_cache = -1;\n\tif (vcpu->arch.apicv_active) {\n\t\tif (kvm_x86_ops->apicv_post_state_restore)\n\t\t\tkvm_x86_ops->apicv_post_state_restore(vcpu);\n\t\tkvm_x86_ops->hwapic_irr_update(vcpu,\n\t\t\t\tapic_find_highest_irr(apic));\n\t\tkvm_x86_ops->hwapic_isr_update(vcpu,\n\t\t\t\tapic_find_highest_isr(apic));\n\t}\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\tif (ioapic_in_kernel(vcpu->kvm))\n\t\tkvm_rtc_eoi_tracking_restore_one(vcpu);\n\n\tvcpu->arch.apic_arb_prio = 0;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nvoid kvm_apic_post_state_restore(struct kvm_vcpu *vcpu,\n\t\tstruct kvm_lapic_state *s)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tkvm_lapic_set_base(vcpu, vcpu->arch.apic_base);\n\t/* set SPIV separately to get count of SW disabled APICs right */\n\tapic_set_spiv(apic, *((u32 *)(s->regs + APIC_SPIV)));\n\tmemcpy(vcpu->arch.apic->regs, s->regs, sizeof *s);\n\t/* call kvm_apic_set_id() to put apic into apic_map */\n\tkvm_apic_set_id(apic, kvm_apic_id(apic));\n\tkvm_apic_set_version(vcpu);\n\n\tapic_update_ppr(apic);\n\thrtimer_cancel(&apic->lapic_timer.timer);\n\tapic_update_lvtt(apic);\n\tapic_manage_nmi_watchdog(apic, kvm_lapic_get_reg(apic, APIC_LVT0));\n\tupdate_divide_count(apic);\n\tstart_apic_timer(apic);\n\tapic->irr_pending = true;\n\tapic->isr_count = vcpu->arch.apicv_active ?\n\t\t\t\t1 : count_vectors(apic->regs + APIC_ISR);\n\tapic->highest_isr_cache = -1;\n\tif (vcpu->arch.apicv_active) {\n\t\tif (kvm_x86_ops->apicv_post_state_restore)\n\t\t\tkvm_x86_ops->apicv_post_state_restore(vcpu);\n\t\tkvm_x86_ops->hwapic_irr_update(vcpu,\n\t\t\t\tapic_find_highest_irr(apic));\n\t\tkvm_x86_ops->hwapic_isr_update(vcpu,\n\t\t\t\tapic_find_highest_isr(apic));\n\t}\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\tif (ioapic_in_kernel(vcpu->kvm))\n\t\tkvm_rtc_eoi_tracking_restore_one(vcpu);\n\n\tvcpu->arch.apic_arb_prio = 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic int kvm_vcpu_ioctl_set_lapic(struct kvm_vcpu *vcpu,\n\t\t\t\t    struct kvm_lapic_state *s)\n{\n\tkvm_apic_post_state_restore(vcpu, s);\n\tupdate_cr8_intercept(vcpu);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "kvm_vcpu_ioctl_get_lapic",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "2768-2777",
    "snippet": "static int kvm_vcpu_ioctl_get_lapic(struct kvm_vcpu *vcpu,\n\t\t\t\t    struct kvm_lapic_state *s)\n{\n\tif (vcpu->arch.apicv_active)\n\t\tkvm_x86_ops->sync_pir_to_irr(vcpu);\n\n\tmemcpy(s->regs, vcpu->arch.apic->regs, sizeof *s);\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);",
      "struct kvm_x86_ops *kvm_x86_ops"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "s->regs",
            "vcpu->arch.apic->regs",
            "sizeof *s"
          ],
          "line": 2774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_x86_ops->sync_pir_to_irr",
          "args": [
            "vcpu"
          ],
          "line": 2772
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nstatic int kvm_vcpu_ioctl_get_lapic(struct kvm_vcpu *vcpu,\n\t\t\t\t    struct kvm_lapic_state *s)\n{\n\tif (vcpu->arch.apicv_active)\n\t\tkvm_x86_ops->sync_pir_to_irr(vcpu);\n\n\tmemcpy(s->regs, vcpu->arch.apic->regs, sizeof *s);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "kvm_arch_vcpu_put",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "2761-2766",
    "snippet": "void kvm_arch_vcpu_put(struct kvm_vcpu *vcpu)\n{\n\tkvm_x86_ops->vcpu_put(vcpu);\n\tkvm_put_guest_fpu(vcpu);\n\tvcpu->arch.last_host_tsc = rdtsc();\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);",
      "struct kvm_x86_ops *kvm_x86_ops"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rdtsc",
          "args": [],
          "line": 2765
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_rdtscp_supported",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/vmx.c",
          "lines": "2393-2396",
          "snippet": "static bool vmx_rdtscp_supported(void)\n{\n\treturn cpu_has_vmx_rdtscp();\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"trace.h\"",
            "#include <asm/irq_remapping.h>",
            "#include <asm/apic.h>",
            "#include <asm/kexec.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/mce.h>",
            "#include <asm/virtext.h>",
            "#include <asm/vmx.h>",
            "#include <asm/desc.h>",
            "#include <asm/io.h>",
            "#include <asm/cpu.h>",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/hrtimer.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include \"lapic.h\"",
            "#include \"cpuid.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"trace.h\"\n#include <asm/irq_remapping.h>\n#include <asm/apic.h>\n#include <asm/kexec.h>\n#include <asm/debugreg.h>\n#include <asm/perf_event.h>\n#include <asm/fpu/internal.h>\n#include <asm/mce.h>\n#include <asm/virtext.h>\n#include <asm/vmx.h>\n#include <asm/desc.h>\n#include <asm/io.h>\n#include <asm/cpu.h>\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/hrtimer.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic bool vmx_rdtscp_supported(void)\n{\n\treturn cpu_has_vmx_rdtscp();\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_put_guest_fpu",
          "args": [
            "vcpu"
          ],
          "line": 2764
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_put_guest_fpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "7328-7350",
          "snippet": "void kvm_put_guest_fpu(struct kvm_vcpu *vcpu)\n{\n\tif (!vcpu->guest_fpu_loaded) {\n\t\tvcpu->fpu_counter = 0;\n\t\treturn;\n\t}\n\n\tvcpu->guest_fpu_loaded = 0;\n\tcopy_fpregs_to_fpstate(&vcpu->arch.guest_fpu);\n\t__kernel_fpu_end();\n\t++vcpu->stat.fpu_reload;\n\t/*\n\t * If using eager FPU mode, or if the guest is a frequent user\n\t * of the FPU, just leave the FPU active for next time.\n\t * Every 255 times fpu_counter rolls over to 0; a guest that uses\n\t * the FPU in bursts will revert to loading it on demand.\n\t */\n\tif (!use_eager_fpu()) {\n\t\tif (++vcpu->fpu_counter < 5)\n\t\t\tkvm_make_request(KVM_REQ_DEACTIVATE_FPU, vcpu);\n\t}\n\ttrace_kvm_fpu(0);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nvoid kvm_put_guest_fpu(struct kvm_vcpu *vcpu)\n{\n\tif (!vcpu->guest_fpu_loaded) {\n\t\tvcpu->fpu_counter = 0;\n\t\treturn;\n\t}\n\n\tvcpu->guest_fpu_loaded = 0;\n\tcopy_fpregs_to_fpstate(&vcpu->arch.guest_fpu);\n\t__kernel_fpu_end();\n\t++vcpu->stat.fpu_reload;\n\t/*\n\t * If using eager FPU mode, or if the guest is a frequent user\n\t * of the FPU, just leave the FPU active for next time.\n\t * Every 255 times fpu_counter rolls over to 0; a guest that uses\n\t * the FPU in bursts will revert to loading it on demand.\n\t */\n\tif (!use_eager_fpu()) {\n\t\tif (++vcpu->fpu_counter < 5)\n\t\t\tkvm_make_request(KVM_REQ_DEACTIVATE_FPU, vcpu);\n\t}\n\ttrace_kvm_fpu(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_x86_ops->vcpu_put",
          "args": [
            "vcpu"
          ],
          "line": 2763
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nvoid kvm_arch_vcpu_put(struct kvm_vcpu *vcpu)\n{\n\tkvm_x86_ops->vcpu_put(vcpu);\n\tkvm_put_guest_fpu(vcpu);\n\tvcpu->arch.last_host_tsc = rdtsc();\n}"
  },
  {
    "function_name": "kvm_arch_vcpu_load",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "2716-2759",
    "snippet": "void kvm_arch_vcpu_load(struct kvm_vcpu *vcpu, int cpu)\n{\n\t/* Address WBINVD may be executed by guest */\n\tif (need_emulate_wbinvd(vcpu)) {\n\t\tif (kvm_x86_ops->has_wbinvd_exit())\n\t\t\tcpumask_set_cpu(cpu, vcpu->arch.wbinvd_dirty_mask);\n\t\telse if (vcpu->cpu != -1 && vcpu->cpu != cpu)\n\t\t\tsmp_call_function_single(vcpu->cpu,\n\t\t\t\t\twbinvd_ipi, NULL, 1);\n\t}\n\n\tkvm_x86_ops->vcpu_load(vcpu, cpu);\n\n\t/* Apply any externally detected TSC adjustments (due to suspend) */\n\tif (unlikely(vcpu->arch.tsc_offset_adjustment)) {\n\t\tadjust_tsc_offset_host(vcpu, vcpu->arch.tsc_offset_adjustment);\n\t\tvcpu->arch.tsc_offset_adjustment = 0;\n\t\tkvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);\n\t}\n\n\tif (unlikely(vcpu->cpu != cpu) || check_tsc_unstable()) {\n\t\ts64 tsc_delta = !vcpu->arch.last_host_tsc ? 0 :\n\t\t\t\trdtsc() - vcpu->arch.last_host_tsc;\n\t\tif (tsc_delta < 0)\n\t\t\tmark_tsc_unstable(\"KVM discovered backwards TSC\");\n\t\tif (check_tsc_unstable()) {\n\t\t\tu64 offset = kvm_compute_tsc_offset(vcpu,\n\t\t\t\t\t\tvcpu->arch.last_guest_tsc);\n\t\t\tkvm_x86_ops->write_tsc_offset(vcpu, offset);\n\t\t\tvcpu->arch.tsc_catchup = 1;\n\t\t}\n\t\t/*\n\t\t * On a host with synchronized TSC, there is no need to update\n\t\t * kvmclock on vcpu->cpu migration\n\t\t */\n\t\tif (!vcpu->kvm->arch.use_master_clock || vcpu->cpu == -1)\n\t\t\tkvm_make_request(KVM_REQ_GLOBAL_CLOCK_UPDATE, vcpu);\n\t\tif (vcpu->cpu != cpu)\n\t\t\tkvm_migrate_timers(vcpu);\n\t\tvcpu->cpu = cpu;\n\t}\n\n\tkvm_make_request(KVM_REQ_STEAL_UPDATE, vcpu);\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);",
      "struct kvm_x86_ops *kvm_x86_ops"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_make_request",
          "args": [
            "KVM_REQ_STEAL_UPDATE",
            "vcpu"
          ],
          "line": 2758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_migrate_timers",
          "args": [
            "vcpu"
          ],
          "line": 2754
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_migrate_timers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "2711-2714",
          "snippet": "static inline void kvm_migrate_timers(struct kvm_vcpu *vcpu)\n{\n\tset_bit(KVM_REQ_MIGRATE_TIMER, &vcpu->requests);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic inline void kvm_migrate_timers(struct kvm_vcpu *vcpu)\n{\n\tset_bit(KVM_REQ_MIGRATE_TIMER, &vcpu->requests);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_make_request",
          "args": [
            "KVM_REQ_GLOBAL_CLOCK_UPDATE",
            "vcpu"
          ],
          "line": 2752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_x86_ops->write_tsc_offset",
          "args": [
            "vcpu",
            "offset"
          ],
          "line": 2744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_compute_tsc_offset",
          "args": [
            "vcpu",
            "vcpu->arch.last_guest_tsc"
          ],
          "line": 2742
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_compute_tsc_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "1399-1406",
          "snippet": "static u64 kvm_compute_tsc_offset(struct kvm_vcpu *vcpu, u64 target_tsc)\n{\n\tu64 tsc;\n\n\ttsc = kvm_scale_tsc(vcpu, rdtsc());\n\n\treturn target_tsc - tsc;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic u64 kvm_compute_tsc_offset(struct kvm_vcpu *vcpu, u64 target_tsc)\n{\n\tu64 tsc;\n\n\ttsc = kvm_scale_tsc(vcpu, rdtsc());\n\n\treturn target_tsc - tsc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_tsc_unstable",
          "args": [],
          "line": 2741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_tsc_unstable",
          "args": [
            "\"KVM discovered backwards TSC\""
          ],
          "line": 2740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rdtsc",
          "args": [],
          "line": 2738
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_rdtscp_supported",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/vmx.c",
          "lines": "2393-2396",
          "snippet": "static bool vmx_rdtscp_supported(void)\n{\n\treturn cpu_has_vmx_rdtscp();\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"trace.h\"",
            "#include <asm/irq_remapping.h>",
            "#include <asm/apic.h>",
            "#include <asm/kexec.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/mce.h>",
            "#include <asm/virtext.h>",
            "#include <asm/vmx.h>",
            "#include <asm/desc.h>",
            "#include <asm/io.h>",
            "#include <asm/cpu.h>",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/hrtimer.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include \"lapic.h\"",
            "#include \"cpuid.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"trace.h\"\n#include <asm/irq_remapping.h>\n#include <asm/apic.h>\n#include <asm/kexec.h>\n#include <asm/debugreg.h>\n#include <asm/perf_event.h>\n#include <asm/fpu/internal.h>\n#include <asm/mce.h>\n#include <asm/virtext.h>\n#include <asm/vmx.h>\n#include <asm/desc.h>\n#include <asm/io.h>\n#include <asm/cpu.h>\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/hrtimer.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic bool vmx_rdtscp_supported(void)\n{\n\treturn cpu_has_vmx_rdtscp();\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_tsc_unstable",
          "args": [],
          "line": 2736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "vcpu->cpu != cpu"
          ],
          "line": 2736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_make_request",
          "args": [
            "KVM_REQ_CLOCK_UPDATE",
            "vcpu"
          ],
          "line": 2733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "adjust_tsc_offset_host",
          "args": [
            "vcpu",
            "vcpu->arch.tsc_offset_adjustment"
          ],
          "line": 2731
        },
        "resolved": true,
        "details": {
          "function_name": "adjust_tsc_offset_host",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "1545-1551",
          "snippet": "static inline void adjust_tsc_offset_host(struct kvm_vcpu *vcpu, s64 adjustment)\n{\n\tif (vcpu->arch.tsc_scaling_ratio != kvm_default_tsc_scaling_ratio)\n\t\tWARN_ON(adjustment < 0);\n\tadjustment = kvm_scale_tsc(vcpu, (u64) adjustment);\n\tkvm_x86_ops->adjust_tsc_offset_guest(vcpu, adjustment);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "struct kvm_x86_ops *kvm_x86_ops"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nstatic inline void adjust_tsc_offset_host(struct kvm_vcpu *vcpu, s64 adjustment)\n{\n\tif (vcpu->arch.tsc_scaling_ratio != kvm_default_tsc_scaling_ratio)\n\t\tWARN_ON(adjustment < 0);\n\tadjustment = kvm_scale_tsc(vcpu, (u64) adjustment);\n\tkvm_x86_ops->adjust_tsc_offset_guest(vcpu, adjustment);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "vcpu->arch.tsc_offset_adjustment"
          ],
          "line": 2730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_x86_ops->vcpu_load",
          "args": [
            "vcpu",
            "cpu"
          ],
          "line": 2727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_call_function_single",
          "args": [
            "vcpu->cpu",
            "wbinvd_ipi",
            "NULL",
            "1"
          ],
          "line": 2723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_set_cpu",
          "args": [
            "cpu",
            "vcpu->arch.wbinvd_dirty_mask"
          ],
          "line": 2721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_x86_ops->has_wbinvd_exit",
          "args": [],
          "line": 2720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "need_emulate_wbinvd",
          "args": [
            "vcpu"
          ],
          "line": 2719
        },
        "resolved": true,
        "details": {
          "function_name": "need_emulate_wbinvd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "2706-2709",
          "snippet": "static bool need_emulate_wbinvd(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_arch_has_noncoherent_dma(vcpu->kvm);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic bool need_emulate_wbinvd(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_arch_has_noncoherent_dma(vcpu->kvm);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nvoid kvm_arch_vcpu_load(struct kvm_vcpu *vcpu, int cpu)\n{\n\t/* Address WBINVD may be executed by guest */\n\tif (need_emulate_wbinvd(vcpu)) {\n\t\tif (kvm_x86_ops->has_wbinvd_exit())\n\t\t\tcpumask_set_cpu(cpu, vcpu->arch.wbinvd_dirty_mask);\n\t\telse if (vcpu->cpu != -1 && vcpu->cpu != cpu)\n\t\t\tsmp_call_function_single(vcpu->cpu,\n\t\t\t\t\twbinvd_ipi, NULL, 1);\n\t}\n\n\tkvm_x86_ops->vcpu_load(vcpu, cpu);\n\n\t/* Apply any externally detected TSC adjustments (due to suspend) */\n\tif (unlikely(vcpu->arch.tsc_offset_adjustment)) {\n\t\tadjust_tsc_offset_host(vcpu, vcpu->arch.tsc_offset_adjustment);\n\t\tvcpu->arch.tsc_offset_adjustment = 0;\n\t\tkvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);\n\t}\n\n\tif (unlikely(vcpu->cpu != cpu) || check_tsc_unstable()) {\n\t\ts64 tsc_delta = !vcpu->arch.last_host_tsc ? 0 :\n\t\t\t\trdtsc() - vcpu->arch.last_host_tsc;\n\t\tif (tsc_delta < 0)\n\t\t\tmark_tsc_unstable(\"KVM discovered backwards TSC\");\n\t\tif (check_tsc_unstable()) {\n\t\t\tu64 offset = kvm_compute_tsc_offset(vcpu,\n\t\t\t\t\t\tvcpu->arch.last_guest_tsc);\n\t\t\tkvm_x86_ops->write_tsc_offset(vcpu, offset);\n\t\t\tvcpu->arch.tsc_catchup = 1;\n\t\t}\n\t\t/*\n\t\t * On a host with synchronized TSC, there is no need to update\n\t\t * kvmclock on vcpu->cpu migration\n\t\t */\n\t\tif (!vcpu->kvm->arch.use_master_clock || vcpu->cpu == -1)\n\t\t\tkvm_make_request(KVM_REQ_GLOBAL_CLOCK_UPDATE, vcpu);\n\t\tif (vcpu->cpu != cpu)\n\t\t\tkvm_migrate_timers(vcpu);\n\t\tvcpu->cpu = cpu;\n\t}\n\n\tkvm_make_request(KVM_REQ_STEAL_UPDATE, vcpu);\n}"
  },
  {
    "function_name": "kvm_migrate_timers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "2711-2714",
    "snippet": "static inline void kvm_migrate_timers(struct kvm_vcpu *vcpu)\n{\n\tset_bit(KVM_REQ_MIGRATE_TIMER, &vcpu->requests);\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "KVM_REQ_MIGRATE_TIMER",
            "&vcpu->requests"
          ],
          "line": 2713
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_set_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/vmx.c",
          "lines": "1599-1604",
          "snippet": "static __always_inline void vmcs_set_bits(unsigned long field, u32 mask)\n{\n        BUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x2000,\n\t\t\t \"vmcs_set_bits does not support 64-bit fields\");\n\t__vmcs_writel(field, __vmcs_readl(field) | mask);\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"trace.h\"",
            "#include <asm/irq_remapping.h>",
            "#include <asm/apic.h>",
            "#include <asm/kexec.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/mce.h>",
            "#include <asm/virtext.h>",
            "#include <asm/vmx.h>",
            "#include <asm/desc.h>",
            "#include <asm/io.h>",
            "#include <asm/cpu.h>",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/hrtimer.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include \"lapic.h\"",
            "#include \"cpuid.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"trace.h\"\n#include <asm/irq_remapping.h>\n#include <asm/apic.h>\n#include <asm/kexec.h>\n#include <asm/debugreg.h>\n#include <asm/perf_event.h>\n#include <asm/fpu/internal.h>\n#include <asm/mce.h>\n#include <asm/virtext.h>\n#include <asm/vmx.h>\n#include <asm/desc.h>\n#include <asm/io.h>\n#include <asm/cpu.h>\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/hrtimer.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic __always_inline void vmcs_set_bits(unsigned long field, u32 mask)\n{\n        BUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x2000,\n\t\t\t \"vmcs_set_bits does not support 64-bit fields\");\n\t__vmcs_writel(field, __vmcs_readl(field) | mask);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic inline void kvm_migrate_timers(struct kvm_vcpu *vcpu)\n{\n\tset_bit(KVM_REQ_MIGRATE_TIMER, &vcpu->requests);\n}"
  },
  {
    "function_name": "need_emulate_wbinvd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "2706-2709",
    "snippet": "static bool need_emulate_wbinvd(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_arch_has_noncoherent_dma(vcpu->kvm);\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_arch_has_noncoherent_dma",
          "args": [
            "vcpu->kvm"
          ],
          "line": 2708
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_arch_has_noncoherent_dma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "8361-8364",
          "snippet": "bool kvm_arch_has_noncoherent_dma(struct kvm *kvm)\n{\n\treturn atomic_read(&kvm->arch.noncoherent_dma_count);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nbool kvm_arch_has_noncoherent_dma(struct kvm *kvm)\n{\n\treturn atomic_read(&kvm->arch.noncoherent_dma_count);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic bool need_emulate_wbinvd(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_arch_has_noncoherent_dma(vcpu->kvm);\n}"
  },
  {
    "function_name": "wbinvd_ipi",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "2701-2704",
    "snippet": "static void wbinvd_ipi(void *garbage)\n{\n\twbinvd();\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wbinvd",
          "args": [],
          "line": 2703
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_has_vmx_wbinvd_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/vmx.c",
          "lines": "1169-1173",
          "snippet": "static inline bool cpu_has_vmx_wbinvd_exit(void)\n{\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl &\n\t\tSECONDARY_EXEC_WBINVD_EXITING;\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"trace.h\"",
            "#include <asm/irq_remapping.h>",
            "#include <asm/apic.h>",
            "#include <asm/kexec.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/mce.h>",
            "#include <asm/virtext.h>",
            "#include <asm/vmx.h>",
            "#include <asm/desc.h>",
            "#include <asm/io.h>",
            "#include <asm/cpu.h>",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/hrtimer.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include \"lapic.h\"",
            "#include \"cpuid.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct vmcs_config {\n\tint size;\n\tint order;\n\tu32 revision_id;\n\tu32 pin_based_exec_ctrl;\n\tu32 cpu_based_exec_ctrl;\n\tu32 cpu_based_2nd_exec_ctrl;\n\tu32 vmexit_ctrl;\n\tu32 vmentry_ctrl;\n} vmcs_config;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"trace.h\"\n#include <asm/irq_remapping.h>\n#include <asm/apic.h>\n#include <asm/kexec.h>\n#include <asm/debugreg.h>\n#include <asm/perf_event.h>\n#include <asm/fpu/internal.h>\n#include <asm/mce.h>\n#include <asm/virtext.h>\n#include <asm/vmx.h>\n#include <asm/desc.h>\n#include <asm/io.h>\n#include <asm/cpu.h>\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/hrtimer.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic struct vmcs_config {\n\tint size;\n\tint order;\n\tu32 revision_id;\n\tu32 pin_based_exec_ctrl;\n\tu32 cpu_based_exec_ctrl;\n\tu32 cpu_based_2nd_exec_ctrl;\n\tu32 vmexit_ctrl;\n\tu32 vmentry_ctrl;\n} vmcs_config;\n\nstatic inline bool cpu_has_vmx_wbinvd_exit(void)\n{\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl &\n\t\tSECONDARY_EXEC_WBINVD_EXITING;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void wbinvd_ipi(void *garbage)\n{\n\twbinvd();\n}"
  },
  {
    "function_name": "kvm_arch_dev_ioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "2631-2699",
    "snippet": "long kvm_arch_dev_ioctl(struct file *filp,\n\t\t\tunsigned int ioctl, unsigned long arg)\n{\n\tvoid __user *argp = (void __user *)arg;\n\tlong r;\n\n\tswitch (ioctl) {\n\tcase KVM_GET_MSR_INDEX_LIST: {\n\t\tstruct kvm_msr_list __user *user_msr_list = argp;\n\t\tstruct kvm_msr_list msr_list;\n\t\tunsigned n;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&msr_list, user_msr_list, sizeof msr_list))\n\t\t\tgoto out;\n\t\tn = msr_list.nmsrs;\n\t\tmsr_list.nmsrs = num_msrs_to_save + num_emulated_msrs;\n\t\tif (copy_to_user(user_msr_list, &msr_list, sizeof msr_list))\n\t\t\tgoto out;\n\t\tr = -E2BIG;\n\t\tif (n < msr_list.nmsrs)\n\t\t\tgoto out;\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(user_msr_list->indices, &msrs_to_save,\n\t\t\t\t num_msrs_to_save * sizeof(u32)))\n\t\t\tgoto out;\n\t\tif (copy_to_user(user_msr_list->indices + num_msrs_to_save,\n\t\t\t\t &emulated_msrs,\n\t\t\t\t num_emulated_msrs * sizeof(u32)))\n\t\t\tgoto out;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_GET_SUPPORTED_CPUID:\n\tcase KVM_GET_EMULATED_CPUID: {\n\t\tstruct kvm_cpuid2 __user *cpuid_arg = argp;\n\t\tstruct kvm_cpuid2 cpuid;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&cpuid, cpuid_arg, sizeof cpuid))\n\t\t\tgoto out;\n\n\t\tr = kvm_dev_ioctl_get_cpuid(&cpuid, cpuid_arg->entries,\n\t\t\t\t\t    ioctl);\n\t\tif (r)\n\t\t\tgoto out;\n\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(cpuid_arg, &cpuid, sizeof cpuid))\n\t\t\tgoto out;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_X86_GET_MCE_CAP_SUPPORTED: {\n\t\tu64 mce_cap;\n\n\t\tmce_cap = KVM_MCE_CAP_SUPPORTED;\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(argp, &mce_cap, sizeof mce_cap))\n\t\t\tgoto out;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tdefault:\n\t\tr = -EINVAL;\n\t}\nout:\n\treturn r;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define KVM_MCE_CAP_SUPPORTED (MCG_CTL_P | MCG_SER_P)"
    ],
    "globals_used": [
      "static u32 msrs_to_save[] = {\n\tMSR_IA32_SYSENTER_CS, MSR_IA32_SYSENTER_ESP, MSR_IA32_SYSENTER_EIP,\n\tMSR_STAR,\n#ifdef CONFIG_X86_64\n\tMSR_CSTAR, MSR_KERNEL_GS_BASE, MSR_SYSCALL_MASK, MSR_LSTAR,\n#endif\n\tMSR_IA32_TSC, MSR_IA32_CR_PAT, MSR_VM_HSAVE_PA,\n\tMSR_IA32_FEATURE_CONTROL, MSR_IA32_BNDCFGS, MSR_TSC_AUX,\n};",
      "static unsigned num_msrs_to_save;",
      "static u32 emulated_msrs[] = {\n\tMSR_KVM_SYSTEM_TIME, MSR_KVM_WALL_CLOCK,\n\tMSR_KVM_SYSTEM_TIME_NEW, MSR_KVM_WALL_CLOCK_NEW,\n\tHV_X64_MSR_GUEST_OS_ID, HV_X64_MSR_HYPERCALL,\n\tHV_X64_MSR_TIME_REF_COUNT, HV_X64_MSR_REFERENCE_TSC,\n\tHV_X64_MSR_CRASH_P0, HV_X64_MSR_CRASH_P1, HV_X64_MSR_CRASH_P2,\n\tHV_X64_MSR_CRASH_P3, HV_X64_MSR_CRASH_P4, HV_X64_MSR_CRASH_CTL,\n\tHV_X64_MSR_RESET,\n\tHV_X64_MSR_VP_INDEX,\n\tHV_X64_MSR_VP_RUNTIME,\n\tHV_X64_MSR_SCONTROL,\n\tHV_X64_MSR_STIMER0_CONFIG,\n\tHV_X64_MSR_APIC_ASSIST_PAGE, MSR_KVM_ASYNC_PF_EN, MSR_KVM_STEAL_TIME,\n\tMSR_KVM_PV_EOI_EN,\n\n\tMSR_IA32_TSC_ADJUST,\n\tMSR_IA32_TSCDEADLINE,\n\tMSR_IA32_MISC_ENABLE,\n\tMSR_IA32_MCG_STATUS,\n\tMSR_IA32_MCG_CTL,\n\tMSR_IA32_SMBASE,\n};",
      "static unsigned num_emulated_msrs;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "argp",
            "&mce_cap",
            "sizeof mce_cap"
          ],
          "line": 2689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "cpuid_arg",
            "&cpuid",
            "sizeof cpuid"
          ],
          "line": 2679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_dev_ioctl_get_cpuid",
          "args": [
            "&cpuid",
            "cpuid_arg->entries",
            "ioctl"
          ],
          "line": 2673
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_dev_ioctl_get_cpuid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/cpuid.c",
          "lines": "696-760",
          "snippet": "int kvm_dev_ioctl_get_cpuid(struct kvm_cpuid2 *cpuid,\n\t\t\t    struct kvm_cpuid_entry2 __user *entries,\n\t\t\t    unsigned int type)\n{\n\tstruct kvm_cpuid_entry2 *cpuid_entries;\n\tint limit, nent = 0, r = -E2BIG, i;\n\tu32 func;\n\tstatic const struct kvm_cpuid_param param[] = {\n\t\t{ .func = 0, .has_leaf_count = true },\n\t\t{ .func = 0x80000000, .has_leaf_count = true },\n\t\t{ .func = 0xC0000000, .qualifier = is_centaur_cpu, .has_leaf_count = true },\n\t\t{ .func = KVM_CPUID_SIGNATURE },\n\t\t{ .func = KVM_CPUID_FEATURES },\n\t};\n\n\tif (cpuid->nent < 1)\n\t\tgoto out;\n\tif (cpuid->nent > KVM_MAX_CPUID_ENTRIES)\n\t\tcpuid->nent = KVM_MAX_CPUID_ENTRIES;\n\n\tif (sanity_check_entries(entries, cpuid->nent, type))\n\t\treturn -EINVAL;\n\n\tr = -ENOMEM;\n\tcpuid_entries = vzalloc(sizeof(struct kvm_cpuid_entry2) * cpuid->nent);\n\tif (!cpuid_entries)\n\t\tgoto out;\n\n\tr = 0;\n\tfor (i = 0; i < ARRAY_SIZE(param); i++) {\n\t\tconst struct kvm_cpuid_param *ent = &param[i];\n\n\t\tif (ent->qualifier && !ent->qualifier(ent))\n\t\t\tcontinue;\n\n\t\tr = do_cpuid_ent(&cpuid_entries[nent], ent->func, ent->idx,\n\t\t\t\t&nent, cpuid->nent, type);\n\n\t\tif (r)\n\t\t\tgoto out_free;\n\n\t\tif (!ent->has_leaf_count)\n\t\t\tcontinue;\n\n\t\tlimit = cpuid_entries[nent - 1].eax;\n\t\tfor (func = ent->func + 1; func <= limit && nent < cpuid->nent && r == 0; ++func)\n\t\t\tr = do_cpuid_ent(&cpuid_entries[nent], func, ent->idx,\n\t\t\t\t     &nent, cpuid->nent, type);\n\n\t\tif (r)\n\t\t\tgoto out_free;\n\t}\n\n\tr = -EFAULT;\n\tif (copy_to_user(entries, cpuid_entries,\n\t\t\t nent * sizeof(struct kvm_cpuid_entry2)))\n\t\tgoto out_free;\n\tcpuid->nent = nent;\n\tr = 0;\n\nout_free:\n\tvfree(cpuid_entries);\nout:\n\treturn r;\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"trace.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"cpuid.h\"",
            "#include <asm/fpu/xstate.h>",
            "#include <asm/user.h>",
            "#include <asm/fpu/internal.h> /* For use_eager_fpu.  Ugh! */",
            "#include <linux/uaccess.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"trace.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include <asm/fpu/xstate.h>\n#include <asm/user.h>\n#include <asm/fpu/internal.h> /* For use_eager_fpu.  Ugh! */\n#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n\nint kvm_dev_ioctl_get_cpuid(struct kvm_cpuid2 *cpuid,\n\t\t\t    struct kvm_cpuid_entry2 __user *entries,\n\t\t\t    unsigned int type)\n{\n\tstruct kvm_cpuid_entry2 *cpuid_entries;\n\tint limit, nent = 0, r = -E2BIG, i;\n\tu32 func;\n\tstatic const struct kvm_cpuid_param param[] = {\n\t\t{ .func = 0, .has_leaf_count = true },\n\t\t{ .func = 0x80000000, .has_leaf_count = true },\n\t\t{ .func = 0xC0000000, .qualifier = is_centaur_cpu, .has_leaf_count = true },\n\t\t{ .func = KVM_CPUID_SIGNATURE },\n\t\t{ .func = KVM_CPUID_FEATURES },\n\t};\n\n\tif (cpuid->nent < 1)\n\t\tgoto out;\n\tif (cpuid->nent > KVM_MAX_CPUID_ENTRIES)\n\t\tcpuid->nent = KVM_MAX_CPUID_ENTRIES;\n\n\tif (sanity_check_entries(entries, cpuid->nent, type))\n\t\treturn -EINVAL;\n\n\tr = -ENOMEM;\n\tcpuid_entries = vzalloc(sizeof(struct kvm_cpuid_entry2) * cpuid->nent);\n\tif (!cpuid_entries)\n\t\tgoto out;\n\n\tr = 0;\n\tfor (i = 0; i < ARRAY_SIZE(param); i++) {\n\t\tconst struct kvm_cpuid_param *ent = &param[i];\n\n\t\tif (ent->qualifier && !ent->qualifier(ent))\n\t\t\tcontinue;\n\n\t\tr = do_cpuid_ent(&cpuid_entries[nent], ent->func, ent->idx,\n\t\t\t\t&nent, cpuid->nent, type);\n\n\t\tif (r)\n\t\t\tgoto out_free;\n\n\t\tif (!ent->has_leaf_count)\n\t\t\tcontinue;\n\n\t\tlimit = cpuid_entries[nent - 1].eax;\n\t\tfor (func = ent->func + 1; func <= limit && nent < cpuid->nent && r == 0; ++func)\n\t\t\tr = do_cpuid_ent(&cpuid_entries[nent], func, ent->idx,\n\t\t\t\t     &nent, cpuid->nent, type);\n\n\t\tif (r)\n\t\t\tgoto out_free;\n\t}\n\n\tr = -EFAULT;\n\tif (copy_to_user(entries, cpuid_entries,\n\t\t\t nent * sizeof(struct kvm_cpuid_entry2)))\n\t\tgoto out_free;\n\tcpuid->nent = nent;\n\tr = 0;\n\nout_free:\n\tvfree(cpuid_entries);\nout:\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&cpuid",
            "cpuid_arg",
            "sizeof cpuid"
          ],
          "line": 2670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "user_msr_list->indices + num_msrs_to_save",
            "&emulated_msrs",
            "num_emulated_msrs * sizeof(u32)"
          ],
          "line": 2657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "user_msr_list->indices",
            "&msrs_to_save",
            "num_msrs_to_save * sizeof(u32)"
          ],
          "line": 2654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "user_msr_list",
            "&msr_list",
            "sizeof msr_list"
          ],
          "line": 2648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&msr_list",
            "user_msr_list",
            "sizeof msr_list"
          ],
          "line": 2644
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define KVM_MCE_CAP_SUPPORTED (MCG_CTL_P | MCG_SER_P)\n\nstatic u32 msrs_to_save[] = {\n\tMSR_IA32_SYSENTER_CS, MSR_IA32_SYSENTER_ESP, MSR_IA32_SYSENTER_EIP,\n\tMSR_STAR,\n#ifdef CONFIG_X86_64\n\tMSR_CSTAR, MSR_KERNEL_GS_BASE, MSR_SYSCALL_MASK, MSR_LSTAR,\n#endif\n\tMSR_IA32_TSC, MSR_IA32_CR_PAT, MSR_VM_HSAVE_PA,\n\tMSR_IA32_FEATURE_CONTROL, MSR_IA32_BNDCFGS, MSR_TSC_AUX,\n};\nstatic unsigned num_msrs_to_save;\nstatic u32 emulated_msrs[] = {\n\tMSR_KVM_SYSTEM_TIME, MSR_KVM_WALL_CLOCK,\n\tMSR_KVM_SYSTEM_TIME_NEW, MSR_KVM_WALL_CLOCK_NEW,\n\tHV_X64_MSR_GUEST_OS_ID, HV_X64_MSR_HYPERCALL,\n\tHV_X64_MSR_TIME_REF_COUNT, HV_X64_MSR_REFERENCE_TSC,\n\tHV_X64_MSR_CRASH_P0, HV_X64_MSR_CRASH_P1, HV_X64_MSR_CRASH_P2,\n\tHV_X64_MSR_CRASH_P3, HV_X64_MSR_CRASH_P4, HV_X64_MSR_CRASH_CTL,\n\tHV_X64_MSR_RESET,\n\tHV_X64_MSR_VP_INDEX,\n\tHV_X64_MSR_VP_RUNTIME,\n\tHV_X64_MSR_SCONTROL,\n\tHV_X64_MSR_STIMER0_CONFIG,\n\tHV_X64_MSR_APIC_ASSIST_PAGE, MSR_KVM_ASYNC_PF_EN, MSR_KVM_STEAL_TIME,\n\tMSR_KVM_PV_EOI_EN,\n\n\tMSR_IA32_TSC_ADJUST,\n\tMSR_IA32_TSCDEADLINE,\n\tMSR_IA32_MISC_ENABLE,\n\tMSR_IA32_MCG_STATUS,\n\tMSR_IA32_MCG_CTL,\n\tMSR_IA32_SMBASE,\n};\nstatic unsigned num_emulated_msrs;\n\nlong kvm_arch_dev_ioctl(struct file *filp,\n\t\t\tunsigned int ioctl, unsigned long arg)\n{\n\tvoid __user *argp = (void __user *)arg;\n\tlong r;\n\n\tswitch (ioctl) {\n\tcase KVM_GET_MSR_INDEX_LIST: {\n\t\tstruct kvm_msr_list __user *user_msr_list = argp;\n\t\tstruct kvm_msr_list msr_list;\n\t\tunsigned n;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&msr_list, user_msr_list, sizeof msr_list))\n\t\t\tgoto out;\n\t\tn = msr_list.nmsrs;\n\t\tmsr_list.nmsrs = num_msrs_to_save + num_emulated_msrs;\n\t\tif (copy_to_user(user_msr_list, &msr_list, sizeof msr_list))\n\t\t\tgoto out;\n\t\tr = -E2BIG;\n\t\tif (n < msr_list.nmsrs)\n\t\t\tgoto out;\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(user_msr_list->indices, &msrs_to_save,\n\t\t\t\t num_msrs_to_save * sizeof(u32)))\n\t\t\tgoto out;\n\t\tif (copy_to_user(user_msr_list->indices + num_msrs_to_save,\n\t\t\t\t &emulated_msrs,\n\t\t\t\t num_emulated_msrs * sizeof(u32)))\n\t\t\tgoto out;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_GET_SUPPORTED_CPUID:\n\tcase KVM_GET_EMULATED_CPUID: {\n\t\tstruct kvm_cpuid2 __user *cpuid_arg = argp;\n\t\tstruct kvm_cpuid2 cpuid;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&cpuid, cpuid_arg, sizeof cpuid))\n\t\t\tgoto out;\n\n\t\tr = kvm_dev_ioctl_get_cpuid(&cpuid, cpuid_arg->entries,\n\t\t\t\t\t    ioctl);\n\t\tif (r)\n\t\t\tgoto out;\n\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(cpuid_arg, &cpuid, sizeof cpuid))\n\t\t\tgoto out;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_X86_GET_MCE_CAP_SUPPORTED: {\n\t\tu64 mce_cap;\n\n\t\tmce_cap = KVM_MCE_CAP_SUPPORTED;\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(argp, &mce_cap, sizeof mce_cap))\n\t\t\tgoto out;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tdefault:\n\t\tr = -EINVAL;\n\t}\nout:\n\treturn r;\n}"
  },
  {
    "function_name": "kvm_vm_ioctl_check_extension",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "2528-2629",
    "snippet": "int kvm_vm_ioctl_check_extension(struct kvm *kvm, long ext)\n{\n\tint r;\n\n\tswitch (ext) {\n\tcase KVM_CAP_IRQCHIP:\n\tcase KVM_CAP_HLT:\n\tcase KVM_CAP_MMU_SHADOW_CACHE_CONTROL:\n\tcase KVM_CAP_SET_TSS_ADDR:\n\tcase KVM_CAP_EXT_CPUID:\n\tcase KVM_CAP_EXT_EMUL_CPUID:\n\tcase KVM_CAP_CLOCKSOURCE:\n\tcase KVM_CAP_PIT:\n\tcase KVM_CAP_NOP_IO_DELAY:\n\tcase KVM_CAP_MP_STATE:\n\tcase KVM_CAP_SYNC_MMU:\n\tcase KVM_CAP_USER_NMI:\n\tcase KVM_CAP_REINJECT_CONTROL:\n\tcase KVM_CAP_IRQ_INJECT_STATUS:\n\tcase KVM_CAP_IOEVENTFD:\n\tcase KVM_CAP_IOEVENTFD_NO_LENGTH:\n\tcase KVM_CAP_PIT2:\n\tcase KVM_CAP_PIT_STATE2:\n\tcase KVM_CAP_SET_IDENTITY_MAP_ADDR:\n\tcase KVM_CAP_XEN_HVM:\n\tcase KVM_CAP_ADJUST_CLOCK:\n\tcase KVM_CAP_VCPU_EVENTS:\n\tcase KVM_CAP_HYPERV:\n\tcase KVM_CAP_HYPERV_VAPIC:\n\tcase KVM_CAP_HYPERV_SPIN:\n\tcase KVM_CAP_HYPERV_SYNIC:\n\tcase KVM_CAP_PCI_SEGMENT:\n\tcase KVM_CAP_DEBUGREGS:\n\tcase KVM_CAP_X86_ROBUST_SINGLESTEP:\n\tcase KVM_CAP_XSAVE:\n\tcase KVM_CAP_ASYNC_PF:\n\tcase KVM_CAP_GET_TSC_KHZ:\n\tcase KVM_CAP_KVMCLOCK_CTRL:\n\tcase KVM_CAP_READONLY_MEM:\n\tcase KVM_CAP_HYPERV_TIME:\n\tcase KVM_CAP_IOAPIC_POLARITY_IGNORED:\n\tcase KVM_CAP_TSC_DEADLINE_TIMER:\n\tcase KVM_CAP_ENABLE_CAP_VM:\n\tcase KVM_CAP_DISABLE_QUIRKS:\n\tcase KVM_CAP_SET_BOOT_CPU_ID:\n \tcase KVM_CAP_SPLIT_IRQCHIP:\n#ifdef CONFIG_KVM_DEVICE_ASSIGNMENT\n\tcase KVM_CAP_ASSIGN_DEV_IRQ:\n\tcase KVM_CAP_PCI_2_3:\n#endif\n\t\tr = 1;\n\t\tbreak;\n\tcase KVM_CAP_X86_SMM:\n\t\t/* SMBASE is usually relocated above 1M on modern chipsets,\n\t\t * and SMM handlers might indeed rely on 4G segment limits,\n\t\t * so do not report SMM to be available if real mode is\n\t\t * emulated via vm86 mode.  Still, do not go to great lengths\n\t\t * to avoid userspace's usage of the feature, because it is a\n\t\t * fringe case that is not enabled except via specific settings\n\t\t * of the module parameters.\n\t\t */\n\t\tr = kvm_x86_ops->cpu_has_high_real_mode_segbase();\n\t\tbreak;\n\tcase KVM_CAP_COALESCED_MMIO:\n\t\tr = KVM_COALESCED_MMIO_PAGE_OFFSET;\n\t\tbreak;\n\tcase KVM_CAP_VAPIC:\n\t\tr = !kvm_x86_ops->cpu_has_accelerated_tpr();\n\t\tbreak;\n\tcase KVM_CAP_NR_VCPUS:\n\t\tr = KVM_SOFT_MAX_VCPUS;\n\t\tbreak;\n\tcase KVM_CAP_MAX_VCPUS:\n\t\tr = KVM_MAX_VCPUS;\n\t\tbreak;\n\tcase KVM_CAP_NR_MEMSLOTS:\n\t\tr = KVM_USER_MEM_SLOTS;\n\t\tbreak;\n\tcase KVM_CAP_PV_MMU:\t/* obsolete */\n\t\tr = 0;\n\t\tbreak;\n#ifdef CONFIG_KVM_DEVICE_ASSIGNMENT\n\tcase KVM_CAP_IOMMU:\n\t\tr = iommu_present(&pci_bus_type);\n\t\tbreak;\n#endif\n\tcase KVM_CAP_MCE:\n\t\tr = KVM_MAX_MCE_BANKS;\n\t\tbreak;\n\tcase KVM_CAP_XCRS:\n\t\tr = cpu_has_xsave;\n\t\tbreak;\n\tcase KVM_CAP_TSC_CONTROL:\n\t\tr = kvm_has_tsc_control;\n\t\tbreak;\n\tdefault:\n\t\tr = 0;\n\t\tbreak;\n\t}\n\treturn r;\n\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define KVM_MAX_MCE_BANKS 32"
    ],
    "globals_used": [
      "struct kvm_x86_ops *kvm_x86_ops"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "iommu_present",
          "args": [
            "&pci_bus_type"
          ],
          "line": 2611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_x86_ops->cpu_has_accelerated_tpr",
          "args": [],
          "line": 2595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_x86_ops->cpu_has_high_real_mode_segbase",
          "args": [],
          "line": 2589
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define KVM_MAX_MCE_BANKS 32\n\nstruct kvm_x86_ops *kvm_x86_ops;\n\nint kvm_vm_ioctl_check_extension(struct kvm *kvm, long ext)\n{\n\tint r;\n\n\tswitch (ext) {\n\tcase KVM_CAP_IRQCHIP:\n\tcase KVM_CAP_HLT:\n\tcase KVM_CAP_MMU_SHADOW_CACHE_CONTROL:\n\tcase KVM_CAP_SET_TSS_ADDR:\n\tcase KVM_CAP_EXT_CPUID:\n\tcase KVM_CAP_EXT_EMUL_CPUID:\n\tcase KVM_CAP_CLOCKSOURCE:\n\tcase KVM_CAP_PIT:\n\tcase KVM_CAP_NOP_IO_DELAY:\n\tcase KVM_CAP_MP_STATE:\n\tcase KVM_CAP_SYNC_MMU:\n\tcase KVM_CAP_USER_NMI:\n\tcase KVM_CAP_REINJECT_CONTROL:\n\tcase KVM_CAP_IRQ_INJECT_STATUS:\n\tcase KVM_CAP_IOEVENTFD:\n\tcase KVM_CAP_IOEVENTFD_NO_LENGTH:\n\tcase KVM_CAP_PIT2:\n\tcase KVM_CAP_PIT_STATE2:\n\tcase KVM_CAP_SET_IDENTITY_MAP_ADDR:\n\tcase KVM_CAP_XEN_HVM:\n\tcase KVM_CAP_ADJUST_CLOCK:\n\tcase KVM_CAP_VCPU_EVENTS:\n\tcase KVM_CAP_HYPERV:\n\tcase KVM_CAP_HYPERV_VAPIC:\n\tcase KVM_CAP_HYPERV_SPIN:\n\tcase KVM_CAP_HYPERV_SYNIC:\n\tcase KVM_CAP_PCI_SEGMENT:\n\tcase KVM_CAP_DEBUGREGS:\n\tcase KVM_CAP_X86_ROBUST_SINGLESTEP:\n\tcase KVM_CAP_XSAVE:\n\tcase KVM_CAP_ASYNC_PF:\n\tcase KVM_CAP_GET_TSC_KHZ:\n\tcase KVM_CAP_KVMCLOCK_CTRL:\n\tcase KVM_CAP_READONLY_MEM:\n\tcase KVM_CAP_HYPERV_TIME:\n\tcase KVM_CAP_IOAPIC_POLARITY_IGNORED:\n\tcase KVM_CAP_TSC_DEADLINE_TIMER:\n\tcase KVM_CAP_ENABLE_CAP_VM:\n\tcase KVM_CAP_DISABLE_QUIRKS:\n\tcase KVM_CAP_SET_BOOT_CPU_ID:\n \tcase KVM_CAP_SPLIT_IRQCHIP:\n#ifdef CONFIG_KVM_DEVICE_ASSIGNMENT\n\tcase KVM_CAP_ASSIGN_DEV_IRQ:\n\tcase KVM_CAP_PCI_2_3:\n#endif\n\t\tr = 1;\n\t\tbreak;\n\tcase KVM_CAP_X86_SMM:\n\t\t/* SMBASE is usually relocated above 1M on modern chipsets,\n\t\t * and SMM handlers might indeed rely on 4G segment limits,\n\t\t * so do not report SMM to be available if real mode is\n\t\t * emulated via vm86 mode.  Still, do not go to great lengths\n\t\t * to avoid userspace's usage of the feature, because it is a\n\t\t * fringe case that is not enabled except via specific settings\n\t\t * of the module parameters.\n\t\t */\n\t\tr = kvm_x86_ops->cpu_has_high_real_mode_segbase();\n\t\tbreak;\n\tcase KVM_CAP_COALESCED_MMIO:\n\t\tr = KVM_COALESCED_MMIO_PAGE_OFFSET;\n\t\tbreak;\n\tcase KVM_CAP_VAPIC:\n\t\tr = !kvm_x86_ops->cpu_has_accelerated_tpr();\n\t\tbreak;\n\tcase KVM_CAP_NR_VCPUS:\n\t\tr = KVM_SOFT_MAX_VCPUS;\n\t\tbreak;\n\tcase KVM_CAP_MAX_VCPUS:\n\t\tr = KVM_MAX_VCPUS;\n\t\tbreak;\n\tcase KVM_CAP_NR_MEMSLOTS:\n\t\tr = KVM_USER_MEM_SLOTS;\n\t\tbreak;\n\tcase KVM_CAP_PV_MMU:\t/* obsolete */\n\t\tr = 0;\n\t\tbreak;\n#ifdef CONFIG_KVM_DEVICE_ASSIGNMENT\n\tcase KVM_CAP_IOMMU:\n\t\tr = iommu_present(&pci_bus_type);\n\t\tbreak;\n#endif\n\tcase KVM_CAP_MCE:\n\t\tr = KVM_MAX_MCE_BANKS;\n\t\tbreak;\n\tcase KVM_CAP_XCRS:\n\t\tr = cpu_has_xsave;\n\t\tbreak;\n\tcase KVM_CAP_TSC_CONTROL:\n\t\tr = kvm_has_tsc_control;\n\t\tbreak;\n\tdefault:\n\t\tr = 0;\n\t\tbreak;\n\t}\n\treturn r;\n\n}"
  },
  {
    "function_name": "msr_io",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "2487-2526",
    "snippet": "static int msr_io(struct kvm_vcpu *vcpu, struct kvm_msrs __user *user_msrs,\n\t\t  int (*do_msr)(struct kvm_vcpu *vcpu,\n\t\t\t\tunsigned index, u64 *data),\n\t\t  int writeback)\n{\n\tstruct kvm_msrs msrs;\n\tstruct kvm_msr_entry *entries;\n\tint r, n;\n\tunsigned size;\n\n\tr = -EFAULT;\n\tif (copy_from_user(&msrs, user_msrs, sizeof msrs))\n\t\tgoto out;\n\n\tr = -E2BIG;\n\tif (msrs.nmsrs >= MAX_IO_MSRS)\n\t\tgoto out;\n\n\tsize = sizeof(struct kvm_msr_entry) * msrs.nmsrs;\n\tentries = memdup_user(user_msrs->entries, size);\n\tif (IS_ERR(entries)) {\n\t\tr = PTR_ERR(entries);\n\t\tgoto out;\n\t}\n\n\tr = n = __msr_io(vcpu, &msrs, entries, do_msr);\n\tif (r < 0)\n\t\tgoto out_free;\n\n\tr = -EFAULT;\n\tif (writeback && copy_to_user(user_msrs->entries, entries, size))\n\t\tgoto out_free;\n\n\tr = n;\n\nout_free:\n\tkfree(entries);\nout:\n\treturn r;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define MAX_IO_MSRS 256"
    ],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "entries"
          ],
          "line": 2523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "user_msrs->entries",
            "entries",
            "size"
          ],
          "line": 2517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__msr_io",
          "args": [
            "vcpu",
            "&msrs",
            "entries",
            "do_msr"
          ],
          "line": 2512
        },
        "resolved": true,
        "details": {
          "function_name": "__msr_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "2466-2480",
          "snippet": "static int __msr_io(struct kvm_vcpu *vcpu, struct kvm_msrs *msrs,\n\t\t    struct kvm_msr_entry *entries,\n\t\t    int (*do_msr)(struct kvm_vcpu *vcpu,\n\t\t\t\t  unsigned index, u64 *data))\n{\n\tint i, idx;\n\n\tidx = srcu_read_lock(&vcpu->kvm->srcu);\n\tfor (i = 0; i < msrs->nmsrs; ++i)\n\t\tif (do_msr(vcpu, entries[i].index, &entries[i].data))\n\t\t\tbreak;\n\tsrcu_read_unlock(&vcpu->kvm->srcu, idx);\n\n\treturn i;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic int __msr_io(struct kvm_vcpu *vcpu, struct kvm_msrs *msrs,\n\t\t    struct kvm_msr_entry *entries,\n\t\t    int (*do_msr)(struct kvm_vcpu *vcpu,\n\t\t\t\t  unsigned index, u64 *data))\n{\n\tint i, idx;\n\n\tidx = srcu_read_lock(&vcpu->kvm->srcu);\n\tfor (i = 0; i < msrs->nmsrs; ++i)\n\t\tif (do_msr(vcpu, entries[i].index, &entries[i].data))\n\t\t\tbreak;\n\tsrcu_read_unlock(&vcpu->kvm->srcu, idx);\n\n\treturn i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "entries"
          ],
          "line": 2508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "entries"
          ],
          "line": 2507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memdup_user",
          "args": [
            "user_msrs->entries",
            "size"
          ],
          "line": 2506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&msrs",
            "user_msrs",
            "sizeof msrs"
          ],
          "line": 2498
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define MAX_IO_MSRS 256\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic int msr_io(struct kvm_vcpu *vcpu, struct kvm_msrs __user *user_msrs,\n\t\t  int (*do_msr)(struct kvm_vcpu *vcpu,\n\t\t\t\tunsigned index, u64 *data),\n\t\t  int writeback)\n{\n\tstruct kvm_msrs msrs;\n\tstruct kvm_msr_entry *entries;\n\tint r, n;\n\tunsigned size;\n\n\tr = -EFAULT;\n\tif (copy_from_user(&msrs, user_msrs, sizeof msrs))\n\t\tgoto out;\n\n\tr = -E2BIG;\n\tif (msrs.nmsrs >= MAX_IO_MSRS)\n\t\tgoto out;\n\n\tsize = sizeof(struct kvm_msr_entry) * msrs.nmsrs;\n\tentries = memdup_user(user_msrs->entries, size);\n\tif (IS_ERR(entries)) {\n\t\tr = PTR_ERR(entries);\n\t\tgoto out;\n\t}\n\n\tr = n = __msr_io(vcpu, &msrs, entries, do_msr);\n\tif (r < 0)\n\t\tgoto out_free;\n\n\tr = -EFAULT;\n\tif (writeback && copy_to_user(user_msrs->entries, entries, size))\n\t\tgoto out_free;\n\n\tr = n;\n\nout_free:\n\tkfree(entries);\nout:\n\treturn r;\n}"
  },
  {
    "function_name": "__msr_io",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "2466-2480",
    "snippet": "static int __msr_io(struct kvm_vcpu *vcpu, struct kvm_msrs *msrs,\n\t\t    struct kvm_msr_entry *entries,\n\t\t    int (*do_msr)(struct kvm_vcpu *vcpu,\n\t\t\t\t  unsigned index, u64 *data))\n{\n\tint i, idx;\n\n\tidx = srcu_read_lock(&vcpu->kvm->srcu);\n\tfor (i = 0; i < msrs->nmsrs; ++i)\n\t\tif (do_msr(vcpu, entries[i].index, &entries[i].data))\n\t\t\tbreak;\n\tsrcu_read_unlock(&vcpu->kvm->srcu, idx);\n\n\treturn i;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "srcu_read_unlock",
          "args": [
            "&vcpu->kvm->srcu",
            "idx"
          ],
          "line": 2477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_msr",
          "args": [
            "vcpu",
            "entries[i].index",
            "&entries[i].data"
          ],
          "line": 2475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "srcu_read_lock",
          "args": [
            "&vcpu->kvm->srcu"
          ],
          "line": 2473
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic int __msr_io(struct kvm_vcpu *vcpu, struct kvm_msrs *msrs,\n\t\t    struct kvm_msr_entry *entries,\n\t\t    int (*do_msr)(struct kvm_vcpu *vcpu,\n\t\t\t\t  unsigned index, u64 *data))\n{\n\tint i, idx;\n\n\tidx = srcu_read_lock(&vcpu->kvm->srcu);\n\tfor (i = 0; i < msrs->nmsrs; ++i)\n\t\tif (do_msr(vcpu, entries[i].index, &entries[i].data))\n\t\t\tbreak;\n\tsrcu_read_unlock(&vcpu->kvm->srcu, idx);\n\n\treturn i;\n}"
  },
  {
    "function_name": "kvm_get_msr_common",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "2298-2458",
    "snippet": "int kvm_get_msr_common(struct kvm_vcpu *vcpu, struct msr_data *msr_info)\n{\n\tswitch (msr_info->index) {\n\tcase MSR_IA32_PLATFORM_ID:\n\tcase MSR_IA32_EBL_CR_POWERON:\n\tcase MSR_IA32_DEBUGCTLMSR:\n\tcase MSR_IA32_LASTBRANCHFROMIP:\n\tcase MSR_IA32_LASTBRANCHTOIP:\n\tcase MSR_IA32_LASTINTFROMIP:\n\tcase MSR_IA32_LASTINTTOIP:\n\tcase MSR_K8_SYSCFG:\n\tcase MSR_K8_TSEG_ADDR:\n\tcase MSR_K8_TSEG_MASK:\n\tcase MSR_K7_HWCR:\n\tcase MSR_VM_HSAVE_PA:\n\tcase MSR_K8_INT_PENDING_MSG:\n\tcase MSR_AMD64_NB_CFG:\n\tcase MSR_FAM10H_MMIO_CONF_BASE:\n\tcase MSR_AMD64_BU_CFG2:\n\t\tmsr_info->data = 0;\n\t\tbreak;\n\tcase MSR_K7_EVNTSEL0 ... MSR_K7_EVNTSEL3:\n\tcase MSR_K7_PERFCTR0 ... MSR_K7_PERFCTR3:\n\tcase MSR_P6_PERFCTR0 ... MSR_P6_PERFCTR1:\n\tcase MSR_P6_EVNTSEL0 ... MSR_P6_EVNTSEL1:\n\t\tif (kvm_pmu_is_valid_msr(vcpu, msr_info->index))\n\t\t\treturn kvm_pmu_get_msr(vcpu, msr_info->index, &msr_info->data);\n\t\tmsr_info->data = 0;\n\t\tbreak;\n\tcase MSR_IA32_UCODE_REV:\n\t\tmsr_info->data = 0x100000000ULL;\n\t\tbreak;\n\tcase MSR_MTRRcap:\n\tcase 0x200 ... 0x2ff:\n\t\treturn kvm_mtrr_get_msr(vcpu, msr_info->index, &msr_info->data);\n\tcase 0xcd: /* fsb frequency */\n\t\tmsr_info->data = 3;\n\t\tbreak;\n\t\t/*\n\t\t * MSR_EBC_FREQUENCY_ID\n\t\t * Conservative value valid for even the basic CPU models.\n\t\t * Models 0,1: 000 in bits 23:21 indicating a bus speed of\n\t\t * 100MHz, model 2 000 in bits 18:16 indicating 100MHz,\n\t\t * and 266MHz for model 3, or 4. Set Core Clock\n\t\t * Frequency to System Bus Frequency Ratio to 1 (bits\n\t\t * 31:24) even though these are only valid for CPU\n\t\t * models > 2, however guests may end up dividing or\n\t\t * multiplying by zero otherwise.\n\t\t */\n\tcase MSR_EBC_FREQUENCY_ID:\n\t\tmsr_info->data = 1 << 24;\n\t\tbreak;\n\tcase MSR_IA32_APICBASE:\n\t\tmsr_info->data = kvm_get_apic_base(vcpu);\n\t\tbreak;\n\tcase APIC_BASE_MSR ... APIC_BASE_MSR + 0x3ff:\n\t\treturn kvm_x2apic_msr_read(vcpu, msr_info->index, &msr_info->data);\n\t\tbreak;\n\tcase MSR_IA32_TSCDEADLINE:\n\t\tmsr_info->data = kvm_get_lapic_tscdeadline_msr(vcpu);\n\t\tbreak;\n\tcase MSR_IA32_TSC_ADJUST:\n\t\tmsr_info->data = (u64)vcpu->arch.ia32_tsc_adjust_msr;\n\t\tbreak;\n\tcase MSR_IA32_MISC_ENABLE:\n\t\tmsr_info->data = vcpu->arch.ia32_misc_enable_msr;\n\t\tbreak;\n\tcase MSR_IA32_SMBASE:\n\t\tif (!msr_info->host_initiated)\n\t\t\treturn 1;\n\t\tmsr_info->data = vcpu->arch.smbase;\n\t\tbreak;\n\tcase MSR_IA32_PERF_STATUS:\n\t\t/* TSC increment by tick */\n\t\tmsr_info->data = 1000ULL;\n\t\t/* CPU multiplier */\n\t\tmsr_info->data |= (((uint64_t)4ULL) << 40);\n\t\tbreak;\n\tcase MSR_EFER:\n\t\tmsr_info->data = vcpu->arch.efer;\n\t\tbreak;\n\tcase MSR_KVM_WALL_CLOCK:\n\tcase MSR_KVM_WALL_CLOCK_NEW:\n\t\tmsr_info->data = vcpu->kvm->arch.wall_clock;\n\t\tbreak;\n\tcase MSR_KVM_SYSTEM_TIME:\n\tcase MSR_KVM_SYSTEM_TIME_NEW:\n\t\tmsr_info->data = vcpu->arch.time;\n\t\tbreak;\n\tcase MSR_KVM_ASYNC_PF_EN:\n\t\tmsr_info->data = vcpu->arch.apf.msr_val;\n\t\tbreak;\n\tcase MSR_KVM_STEAL_TIME:\n\t\tmsr_info->data = vcpu->arch.st.msr_val;\n\t\tbreak;\n\tcase MSR_KVM_PV_EOI_EN:\n\t\tmsr_info->data = vcpu->arch.pv_eoi.msr_val;\n\t\tbreak;\n\tcase MSR_IA32_P5_MC_ADDR:\n\tcase MSR_IA32_P5_MC_TYPE:\n\tcase MSR_IA32_MCG_CAP:\n\tcase MSR_IA32_MCG_CTL:\n\tcase MSR_IA32_MCG_STATUS:\n\tcase MSR_IA32_MC0_CTL ... MSR_IA32_MCx_CTL(KVM_MAX_MCE_BANKS) - 1:\n\t\treturn get_msr_mce(vcpu, msr_info->index, &msr_info->data);\n\tcase MSR_K7_CLK_CTL:\n\t\t/*\n\t\t * Provide expected ramp-up count for K7. All other\n\t\t * are set to zero, indicating minimum divisors for\n\t\t * every field.\n\t\t *\n\t\t * This prevents guest kernels on AMD host with CPU\n\t\t * type 6, model 8 and higher from exploding due to\n\t\t * the rdmsr failing.\n\t\t */\n\t\tmsr_info->data = 0x20000000;\n\t\tbreak;\n\tcase HV_X64_MSR_GUEST_OS_ID ... HV_X64_MSR_SINT15:\n\tcase HV_X64_MSR_CRASH_P0 ... HV_X64_MSR_CRASH_P4:\n\tcase HV_X64_MSR_CRASH_CTL:\n\tcase HV_X64_MSR_STIMER0_CONFIG ... HV_X64_MSR_STIMER3_COUNT:\n\t\treturn kvm_hv_get_msr_common(vcpu,\n\t\t\t\t\t     msr_info->index, &msr_info->data);\n\t\tbreak;\n\tcase MSR_IA32_BBL_CR_CTL3:\n\t\t/* This legacy MSR exists but isn't fully documented in current\n\t\t * silicon.  It is however accessed by winxp in very narrow\n\t\t * scenarios where it sets bit #19, itself documented as\n\t\t * a \"reserved\" bit.  Best effort attempt to source coherent\n\t\t * read data here should the balance of the register be\n\t\t * interpreted by the guest:\n\t\t *\n\t\t * L2 cache control register 3: 64GB range, 256KB size,\n\t\t * enabled, latency 0x1, configured\n\t\t */\n\t\tmsr_info->data = 0xbe702111;\n\t\tbreak;\n\tcase MSR_AMD64_OSVW_ID_LENGTH:\n\t\tif (!guest_cpuid_has_osvw(vcpu))\n\t\t\treturn 1;\n\t\tmsr_info->data = vcpu->arch.osvw.length;\n\t\tbreak;\n\tcase MSR_AMD64_OSVW_STATUS:\n\t\tif (!guest_cpuid_has_osvw(vcpu))\n\t\t\treturn 1;\n\t\tmsr_info->data = vcpu->arch.osvw.status;\n\t\tbreak;\n\tdefault:\n\t\tif (kvm_pmu_is_valid_msr(vcpu, msr_info->index))\n\t\t\treturn kvm_pmu_get_msr(vcpu, msr_info->index, &msr_info->data);\n\t\tif (!ignore_msrs) {\n\t\t\tvcpu_unimpl(vcpu, \"unhandled rdmsr: 0x%x\\n\", msr_info->index);\n\t\t\treturn 1;\n\t\t} else {\n\t\t\tvcpu_unimpl(vcpu, \"ignored rdmsr: 0x%x\\n\", msr_info->index);\n\t\t\tmsr_info->data = 0;\n\t\t}\n\t\tbreak;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define KVM_MAX_MCE_BANKS 32"
    ],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vcpu_unimpl",
          "args": [
            "vcpu",
            "\"ignored rdmsr: 0x%x\\n\"",
            "msr_info->index"
          ],
          "line": 2452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vcpu_unimpl",
          "args": [
            "vcpu",
            "\"unhandled rdmsr: 0x%x\\n\"",
            "msr_info->index"
          ],
          "line": 2449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_pmu_get_msr",
          "args": [
            "vcpu",
            "msr_info->index",
            "&msr_info->data"
          ],
          "line": 2447
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_pmu_get_msr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/pmu.c",
          "lines": "269-272",
          "snippet": "int kvm_pmu_get_msr(struct kvm_vcpu *vcpu, u32 msr, u64 *data)\n{\n\treturn kvm_x86_ops->pmu_ops->get_msr(vcpu, msr, data);\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"lapic.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include <asm/perf_event.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include <asm/perf_event.h>\n#include <linux/perf_event.h>\n#include <linux/kvm_host.h>\n#include <linux/types.h>\n\nint kvm_pmu_get_msr(struct kvm_vcpu *vcpu, u32 msr, u64 *data)\n{\n\treturn kvm_x86_ops->pmu_ops->get_msr(vcpu, msr, data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_pmu_is_valid_msr",
          "args": [
            "vcpu",
            "msr_info->index"
          ],
          "line": 2446
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_pmu_is_valid_msr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/pmu.c",
          "lines": "264-267",
          "snippet": "bool kvm_pmu_is_valid_msr(struct kvm_vcpu *vcpu, u32 msr)\n{\n\treturn kvm_x86_ops->pmu_ops->is_valid_msr(vcpu, msr);\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"lapic.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include <asm/perf_event.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include <asm/perf_event.h>\n#include <linux/perf_event.h>\n#include <linux/kvm_host.h>\n#include <linux/types.h>\n\nbool kvm_pmu_is_valid_msr(struct kvm_vcpu *vcpu, u32 msr)\n{\n\treturn kvm_x86_ops->pmu_ops->is_valid_msr(vcpu, msr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "guest_cpuid_has_osvw",
          "args": [
            "vcpu"
          ],
          "line": 2441
        },
        "resolved": true,
        "details": {
          "function_name": "guest_cpuid_has_osvw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/cpuid.h",
          "lines": "99-105",
          "snippet": "static inline bool guest_cpuid_has_osvw(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_cpuid_entry2 *best;\n\n\tbest = kvm_find_cpuid_entry(vcpu, 0x80000001, 0);\n\treturn best && (best->ecx & bit(X86_FEATURE_OSVW));\n}",
          "includes": [
            "#include <asm/cpu.h>",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpu.h>\n#include \"x86.h\"\n\nstatic inline bool guest_cpuid_has_osvw(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_cpuid_entry2 *best;\n\n\tbest = kvm_find_cpuid_entry(vcpu, 0x80000001, 0);\n\treturn best && (best->ecx & bit(X86_FEATURE_OSVW));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_hv_get_msr_common",
          "args": [
            "vcpu",
            "msr_info->index",
            "&msr_info->data"
          ],
          "line": 2419
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_hv_get_msr_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.c",
          "lines": "1028-1039",
          "snippet": "int kvm_hv_get_msr_common(struct kvm_vcpu *vcpu, u32 msr, u64 *pdata)\n{\n\tif (kvm_hv_msr_partition_wide(msr)) {\n\t\tint r;\n\n\t\tmutex_lock(&vcpu->kvm->lock);\n\t\tr = kvm_hv_get_msr_pw(vcpu, msr, pdata);\n\t\tmutex_unlock(&vcpu->kvm->lock);\n\t\treturn r;\n\t} else\n\t\treturn kvm_hv_get_msr(vcpu, msr, pdata);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nint kvm_hv_get_msr_common(struct kvm_vcpu *vcpu, u32 msr, u64 *pdata)\n{\n\tif (kvm_hv_msr_partition_wide(msr)) {\n\t\tint r;\n\n\t\tmutex_lock(&vcpu->kvm->lock);\n\t\tr = kvm_hv_get_msr_pw(vcpu, msr, pdata);\n\t\tmutex_unlock(&vcpu->kvm->lock);\n\t\treturn r;\n\t} else\n\t\treturn kvm_hv_get_msr(vcpu, msr, pdata);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_msr_mce",
          "args": [
            "vcpu",
            "msr_info->index",
            "&msr_info->data"
          ],
          "line": 2402
        },
        "resolved": true,
        "details": {
          "function_name": "get_msr_mce",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "2263-2296",
          "snippet": "static int get_msr_mce(struct kvm_vcpu *vcpu, u32 msr, u64 *pdata)\n{\n\tu64 data;\n\tu64 mcg_cap = vcpu->arch.mcg_cap;\n\tunsigned bank_num = mcg_cap & 0xff;\n\n\tswitch (msr) {\n\tcase MSR_IA32_P5_MC_ADDR:\n\tcase MSR_IA32_P5_MC_TYPE:\n\t\tdata = 0;\n\t\tbreak;\n\tcase MSR_IA32_MCG_CAP:\n\t\tdata = vcpu->arch.mcg_cap;\n\t\tbreak;\n\tcase MSR_IA32_MCG_CTL:\n\t\tif (!(mcg_cap & MCG_CTL_P))\n\t\t\treturn 1;\n\t\tdata = vcpu->arch.mcg_ctl;\n\t\tbreak;\n\tcase MSR_IA32_MCG_STATUS:\n\t\tdata = vcpu->arch.mcg_status;\n\t\tbreak;\n\tdefault:\n\t\tif (msr >= MSR_IA32_MC0_CTL &&\n\t\t    msr < MSR_IA32_MCx_CTL(bank_num)) {\n\t\t\tu32 offset = msr - MSR_IA32_MC0_CTL;\n\t\t\tdata = vcpu->arch.mce_banks[offset];\n\t\t\tbreak;\n\t\t}\n\t\treturn 1;\n\t}\n\t*pdata = data;\n\treturn 0;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic int get_msr_mce(struct kvm_vcpu *vcpu, u32 msr, u64 *pdata)\n{\n\tu64 data;\n\tu64 mcg_cap = vcpu->arch.mcg_cap;\n\tunsigned bank_num = mcg_cap & 0xff;\n\n\tswitch (msr) {\n\tcase MSR_IA32_P5_MC_ADDR:\n\tcase MSR_IA32_P5_MC_TYPE:\n\t\tdata = 0;\n\t\tbreak;\n\tcase MSR_IA32_MCG_CAP:\n\t\tdata = vcpu->arch.mcg_cap;\n\t\tbreak;\n\tcase MSR_IA32_MCG_CTL:\n\t\tif (!(mcg_cap & MCG_CTL_P))\n\t\t\treturn 1;\n\t\tdata = vcpu->arch.mcg_ctl;\n\t\tbreak;\n\tcase MSR_IA32_MCG_STATUS:\n\t\tdata = vcpu->arch.mcg_status;\n\t\tbreak;\n\tdefault:\n\t\tif (msr >= MSR_IA32_MC0_CTL &&\n\t\t    msr < MSR_IA32_MCx_CTL(bank_num)) {\n\t\t\tu32 offset = msr - MSR_IA32_MC0_CTL;\n\t\t\tdata = vcpu->arch.mce_banks[offset];\n\t\t\tbreak;\n\t\t}\n\t\treturn 1;\n\t}\n\t*pdata = data;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MSR_IA32_MCx_CTL",
          "args": [
            "KVM_MAX_MCE_BANKS"
          ],
          "line": 2401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_get_lapic_tscdeadline_msr",
          "args": [
            "vcpu"
          ],
          "line": 2357
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_get_lapic_tscdeadline_msr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "1620-1629",
          "snippet": "u64 kvm_get_lapic_tscdeadline_msr(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tif (!lapic_in_kernel(vcpu) || apic_lvtt_oneshot(apic) ||\n\t\t\tapic_lvtt_period(apic))\n\t\treturn 0;\n\n\treturn apic->lapic_timer.tscdeadline;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nu64 kvm_get_lapic_tscdeadline_msr(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tif (!lapic_in_kernel(vcpu) || apic_lvtt_oneshot(apic) ||\n\t\t\tapic_lvtt_period(apic))\n\t\treturn 0;\n\n\treturn apic->lapic_timer.tscdeadline;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_x2apic_msr_read",
          "args": [
            "vcpu",
            "msr_info->index",
            "&msr_info->data"
          ],
          "line": 2354
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_x2apic_msr_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "2127-2149",
          "snippet": "int kvm_x2apic_msr_read(struct kvm_vcpu *vcpu, u32 msr, u64 *data)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tu32 reg = (msr - APIC_BASE_MSR) << 4, low, high = 0;\n\n\tif (!lapic_in_kernel(vcpu) || !apic_x2apic_mode(apic))\n\t\treturn 1;\n\n\tif (reg == APIC_DFR || reg == APIC_ICR2) {\n\t\tapic_debug(\"KVM_APIC_READ: read x2apic reserved register %x\\n\",\n\t\t\t   reg);\n\t\treturn 1;\n\t}\n\n\tif (kvm_lapic_reg_read(apic, reg, 4, &low))\n\t\treturn 1;\n\tif (reg == APIC_ICR)\n\t\tkvm_lapic_reg_read(apic, APIC_ICR2, 4, &high);\n\n\t*data = (((u64)high) << 32) | low;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nint kvm_x2apic_msr_read(struct kvm_vcpu *vcpu, u32 msr, u64 *data)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tu32 reg = (msr - APIC_BASE_MSR) << 4, low, high = 0;\n\n\tif (!lapic_in_kernel(vcpu) || !apic_x2apic_mode(apic))\n\t\treturn 1;\n\n\tif (reg == APIC_DFR || reg == APIC_ICR2) {\n\t\tapic_debug(\"KVM_APIC_READ: read x2apic reserved register %x\\n\",\n\t\t\t   reg);\n\t\treturn 1;\n\t}\n\n\tif (kvm_lapic_reg_read(apic, reg, 4, &low))\n\t\treturn 1;\n\tif (reg == APIC_ICR)\n\t\tkvm_lapic_reg_read(apic, APIC_ICR2, 4, &high);\n\n\t*data = (((u64)high) << 32) | low;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_get_apic_base",
          "args": [
            "vcpu"
          ],
          "line": 2351
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_get_apic_base",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "283-286",
          "snippet": "u64 kvm_get_apic_base(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.apic_base;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nu64 kvm_get_apic_base(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.apic_base;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_mtrr_get_msr",
          "args": [
            "vcpu",
            "msr_info->index",
            "&msr_info->data"
          ],
          "line": 2332
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mtrr_get_msr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mtrr.c",
          "lines": "405-445",
          "snippet": "int kvm_mtrr_get_msr(struct kvm_vcpu *vcpu, u32 msr, u64 *pdata)\n{\n\tint index;\n\n\t/* MSR_MTRRcap is a readonly MSR. */\n\tif (msr == MSR_MTRRcap) {\n\t\t/*\n\t\t * SMRR = 0\n\t\t * WC = 1\n\t\t * FIX = 1\n\t\t * VCNT = KVM_NR_VAR_MTRR\n\t\t */\n\t\t*pdata = 0x500 | KVM_NR_VAR_MTRR;\n\t\treturn 0;\n\t}\n\n\tif (!msr_mtrr_valid(msr))\n\t\treturn 1;\n\n\tindex = fixed_msr_to_range_index(msr);\n\tif (index >= 0)\n\t\t*pdata = *(u64 *)&vcpu->arch.mtrr_state.fixed_ranges[index];\n\telse if (msr == MSR_MTRRdefType)\n\t\t*pdata = vcpu->arch.mtrr_state.deftype;\n\telse if (msr == MSR_IA32_CR_PAT)\n\t\t*pdata = vcpu->arch.pat;\n\telse {\t/* Variable MTRRs */\n\t\tint is_mtrr_mask;\n\n\t\tindex = (msr - 0x200) / 2;\n\t\tis_mtrr_mask = msr - 0x200 - 2 * index;\n\t\tif (!is_mtrr_mask)\n\t\t\t*pdata = vcpu->arch.mtrr_state.var_ranges[index].base;\n\t\telse\n\t\t\t*pdata = vcpu->arch.mtrr_state.var_ranges[index].mask;\n\n\t\t*pdata &= (1ULL << cpuid_maxphyaddr(vcpu)) - 1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"mmu.h\"",
            "#include \"cpuid.h\"",
            "#include <asm/mtrr.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mmu.h\"\n#include \"cpuid.h\"\n#include <asm/mtrr.h>\n#include <linux/kvm_host.h>\n\nint kvm_mtrr_get_msr(struct kvm_vcpu *vcpu, u32 msr, u64 *pdata)\n{\n\tint index;\n\n\t/* MSR_MTRRcap is a readonly MSR. */\n\tif (msr == MSR_MTRRcap) {\n\t\t/*\n\t\t * SMRR = 0\n\t\t * WC = 1\n\t\t * FIX = 1\n\t\t * VCNT = KVM_NR_VAR_MTRR\n\t\t */\n\t\t*pdata = 0x500 | KVM_NR_VAR_MTRR;\n\t\treturn 0;\n\t}\n\n\tif (!msr_mtrr_valid(msr))\n\t\treturn 1;\n\n\tindex = fixed_msr_to_range_index(msr);\n\tif (index >= 0)\n\t\t*pdata = *(u64 *)&vcpu->arch.mtrr_state.fixed_ranges[index];\n\telse if (msr == MSR_MTRRdefType)\n\t\t*pdata = vcpu->arch.mtrr_state.deftype;\n\telse if (msr == MSR_IA32_CR_PAT)\n\t\t*pdata = vcpu->arch.pat;\n\telse {\t/* Variable MTRRs */\n\t\tint is_mtrr_mask;\n\n\t\tindex = (msr - 0x200) / 2;\n\t\tis_mtrr_mask = msr - 0x200 - 2 * index;\n\t\tif (!is_mtrr_mask)\n\t\t\t*pdata = vcpu->arch.mtrr_state.var_ranges[index].base;\n\t\telse\n\t\t\t*pdata = vcpu->arch.mtrr_state.var_ranges[index].mask;\n\n\t\t*pdata &= (1ULL << cpuid_maxphyaddr(vcpu)) - 1;\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define KVM_MAX_MCE_BANKS 32\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nint kvm_get_msr_common(struct kvm_vcpu *vcpu, struct msr_data *msr_info)\n{\n\tswitch (msr_info->index) {\n\tcase MSR_IA32_PLATFORM_ID:\n\tcase MSR_IA32_EBL_CR_POWERON:\n\tcase MSR_IA32_DEBUGCTLMSR:\n\tcase MSR_IA32_LASTBRANCHFROMIP:\n\tcase MSR_IA32_LASTBRANCHTOIP:\n\tcase MSR_IA32_LASTINTFROMIP:\n\tcase MSR_IA32_LASTINTTOIP:\n\tcase MSR_K8_SYSCFG:\n\tcase MSR_K8_TSEG_ADDR:\n\tcase MSR_K8_TSEG_MASK:\n\tcase MSR_K7_HWCR:\n\tcase MSR_VM_HSAVE_PA:\n\tcase MSR_K8_INT_PENDING_MSG:\n\tcase MSR_AMD64_NB_CFG:\n\tcase MSR_FAM10H_MMIO_CONF_BASE:\n\tcase MSR_AMD64_BU_CFG2:\n\t\tmsr_info->data = 0;\n\t\tbreak;\n\tcase MSR_K7_EVNTSEL0 ... MSR_K7_EVNTSEL3:\n\tcase MSR_K7_PERFCTR0 ... MSR_K7_PERFCTR3:\n\tcase MSR_P6_PERFCTR0 ... MSR_P6_PERFCTR1:\n\tcase MSR_P6_EVNTSEL0 ... MSR_P6_EVNTSEL1:\n\t\tif (kvm_pmu_is_valid_msr(vcpu, msr_info->index))\n\t\t\treturn kvm_pmu_get_msr(vcpu, msr_info->index, &msr_info->data);\n\t\tmsr_info->data = 0;\n\t\tbreak;\n\tcase MSR_IA32_UCODE_REV:\n\t\tmsr_info->data = 0x100000000ULL;\n\t\tbreak;\n\tcase MSR_MTRRcap:\n\tcase 0x200 ... 0x2ff:\n\t\treturn kvm_mtrr_get_msr(vcpu, msr_info->index, &msr_info->data);\n\tcase 0xcd: /* fsb frequency */\n\t\tmsr_info->data = 3;\n\t\tbreak;\n\t\t/*\n\t\t * MSR_EBC_FREQUENCY_ID\n\t\t * Conservative value valid for even the basic CPU models.\n\t\t * Models 0,1: 000 in bits 23:21 indicating a bus speed of\n\t\t * 100MHz, model 2 000 in bits 18:16 indicating 100MHz,\n\t\t * and 266MHz for model 3, or 4. Set Core Clock\n\t\t * Frequency to System Bus Frequency Ratio to 1 (bits\n\t\t * 31:24) even though these are only valid for CPU\n\t\t * models > 2, however guests may end up dividing or\n\t\t * multiplying by zero otherwise.\n\t\t */\n\tcase MSR_EBC_FREQUENCY_ID:\n\t\tmsr_info->data = 1 << 24;\n\t\tbreak;\n\tcase MSR_IA32_APICBASE:\n\t\tmsr_info->data = kvm_get_apic_base(vcpu);\n\t\tbreak;\n\tcase APIC_BASE_MSR ... APIC_BASE_MSR + 0x3ff:\n\t\treturn kvm_x2apic_msr_read(vcpu, msr_info->index, &msr_info->data);\n\t\tbreak;\n\tcase MSR_IA32_TSCDEADLINE:\n\t\tmsr_info->data = kvm_get_lapic_tscdeadline_msr(vcpu);\n\t\tbreak;\n\tcase MSR_IA32_TSC_ADJUST:\n\t\tmsr_info->data = (u64)vcpu->arch.ia32_tsc_adjust_msr;\n\t\tbreak;\n\tcase MSR_IA32_MISC_ENABLE:\n\t\tmsr_info->data = vcpu->arch.ia32_misc_enable_msr;\n\t\tbreak;\n\tcase MSR_IA32_SMBASE:\n\t\tif (!msr_info->host_initiated)\n\t\t\treturn 1;\n\t\tmsr_info->data = vcpu->arch.smbase;\n\t\tbreak;\n\tcase MSR_IA32_PERF_STATUS:\n\t\t/* TSC increment by tick */\n\t\tmsr_info->data = 1000ULL;\n\t\t/* CPU multiplier */\n\t\tmsr_info->data |= (((uint64_t)4ULL) << 40);\n\t\tbreak;\n\tcase MSR_EFER:\n\t\tmsr_info->data = vcpu->arch.efer;\n\t\tbreak;\n\tcase MSR_KVM_WALL_CLOCK:\n\tcase MSR_KVM_WALL_CLOCK_NEW:\n\t\tmsr_info->data = vcpu->kvm->arch.wall_clock;\n\t\tbreak;\n\tcase MSR_KVM_SYSTEM_TIME:\n\tcase MSR_KVM_SYSTEM_TIME_NEW:\n\t\tmsr_info->data = vcpu->arch.time;\n\t\tbreak;\n\tcase MSR_KVM_ASYNC_PF_EN:\n\t\tmsr_info->data = vcpu->arch.apf.msr_val;\n\t\tbreak;\n\tcase MSR_KVM_STEAL_TIME:\n\t\tmsr_info->data = vcpu->arch.st.msr_val;\n\t\tbreak;\n\tcase MSR_KVM_PV_EOI_EN:\n\t\tmsr_info->data = vcpu->arch.pv_eoi.msr_val;\n\t\tbreak;\n\tcase MSR_IA32_P5_MC_ADDR:\n\tcase MSR_IA32_P5_MC_TYPE:\n\tcase MSR_IA32_MCG_CAP:\n\tcase MSR_IA32_MCG_CTL:\n\tcase MSR_IA32_MCG_STATUS:\n\tcase MSR_IA32_MC0_CTL ... MSR_IA32_MCx_CTL(KVM_MAX_MCE_BANKS) - 1:\n\t\treturn get_msr_mce(vcpu, msr_info->index, &msr_info->data);\n\tcase MSR_K7_CLK_CTL:\n\t\t/*\n\t\t * Provide expected ramp-up count for K7. All other\n\t\t * are set to zero, indicating minimum divisors for\n\t\t * every field.\n\t\t *\n\t\t * This prevents guest kernels on AMD host with CPU\n\t\t * type 6, model 8 and higher from exploding due to\n\t\t * the rdmsr failing.\n\t\t */\n\t\tmsr_info->data = 0x20000000;\n\t\tbreak;\n\tcase HV_X64_MSR_GUEST_OS_ID ... HV_X64_MSR_SINT15:\n\tcase HV_X64_MSR_CRASH_P0 ... HV_X64_MSR_CRASH_P4:\n\tcase HV_X64_MSR_CRASH_CTL:\n\tcase HV_X64_MSR_STIMER0_CONFIG ... HV_X64_MSR_STIMER3_COUNT:\n\t\treturn kvm_hv_get_msr_common(vcpu,\n\t\t\t\t\t     msr_info->index, &msr_info->data);\n\t\tbreak;\n\tcase MSR_IA32_BBL_CR_CTL3:\n\t\t/* This legacy MSR exists but isn't fully documented in current\n\t\t * silicon.  It is however accessed by winxp in very narrow\n\t\t * scenarios where it sets bit #19, itself documented as\n\t\t * a \"reserved\" bit.  Best effort attempt to source coherent\n\t\t * read data here should the balance of the register be\n\t\t * interpreted by the guest:\n\t\t *\n\t\t * L2 cache control register 3: 64GB range, 256KB size,\n\t\t * enabled, latency 0x1, configured\n\t\t */\n\t\tmsr_info->data = 0xbe702111;\n\t\tbreak;\n\tcase MSR_AMD64_OSVW_ID_LENGTH:\n\t\tif (!guest_cpuid_has_osvw(vcpu))\n\t\t\treturn 1;\n\t\tmsr_info->data = vcpu->arch.osvw.length;\n\t\tbreak;\n\tcase MSR_AMD64_OSVW_STATUS:\n\t\tif (!guest_cpuid_has_osvw(vcpu))\n\t\t\treturn 1;\n\t\tmsr_info->data = vcpu->arch.osvw.status;\n\t\tbreak;\n\tdefault:\n\t\tif (kvm_pmu_is_valid_msr(vcpu, msr_info->index))\n\t\t\treturn kvm_pmu_get_msr(vcpu, msr_info->index, &msr_info->data);\n\t\tif (!ignore_msrs) {\n\t\t\tvcpu_unimpl(vcpu, \"unhandled rdmsr: 0x%x\\n\", msr_info->index);\n\t\t\treturn 1;\n\t\t} else {\n\t\t\tvcpu_unimpl(vcpu, \"ignored rdmsr: 0x%x\\n\", msr_info->index);\n\t\t\tmsr_info->data = 0;\n\t\t}\n\t\tbreak;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "get_msr_mce",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "2263-2296",
    "snippet": "static int get_msr_mce(struct kvm_vcpu *vcpu, u32 msr, u64 *pdata)\n{\n\tu64 data;\n\tu64 mcg_cap = vcpu->arch.mcg_cap;\n\tunsigned bank_num = mcg_cap & 0xff;\n\n\tswitch (msr) {\n\tcase MSR_IA32_P5_MC_ADDR:\n\tcase MSR_IA32_P5_MC_TYPE:\n\t\tdata = 0;\n\t\tbreak;\n\tcase MSR_IA32_MCG_CAP:\n\t\tdata = vcpu->arch.mcg_cap;\n\t\tbreak;\n\tcase MSR_IA32_MCG_CTL:\n\t\tif (!(mcg_cap & MCG_CTL_P))\n\t\t\treturn 1;\n\t\tdata = vcpu->arch.mcg_ctl;\n\t\tbreak;\n\tcase MSR_IA32_MCG_STATUS:\n\t\tdata = vcpu->arch.mcg_status;\n\t\tbreak;\n\tdefault:\n\t\tif (msr >= MSR_IA32_MC0_CTL &&\n\t\t    msr < MSR_IA32_MCx_CTL(bank_num)) {\n\t\t\tu32 offset = msr - MSR_IA32_MC0_CTL;\n\t\t\tdata = vcpu->arch.mce_banks[offset];\n\t\t\tbreak;\n\t\t}\n\t\treturn 1;\n\t}\n\t*pdata = data;\n\treturn 0;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "MSR_IA32_MCx_CTL",
          "args": [
            "bank_num"
          ],
          "line": 2287
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic int get_msr_mce(struct kvm_vcpu *vcpu, u32 msr, u64 *pdata)\n{\n\tu64 data;\n\tu64 mcg_cap = vcpu->arch.mcg_cap;\n\tunsigned bank_num = mcg_cap & 0xff;\n\n\tswitch (msr) {\n\tcase MSR_IA32_P5_MC_ADDR:\n\tcase MSR_IA32_P5_MC_TYPE:\n\t\tdata = 0;\n\t\tbreak;\n\tcase MSR_IA32_MCG_CAP:\n\t\tdata = vcpu->arch.mcg_cap;\n\t\tbreak;\n\tcase MSR_IA32_MCG_CTL:\n\t\tif (!(mcg_cap & MCG_CTL_P))\n\t\t\treturn 1;\n\t\tdata = vcpu->arch.mcg_ctl;\n\t\tbreak;\n\tcase MSR_IA32_MCG_STATUS:\n\t\tdata = vcpu->arch.mcg_status;\n\t\tbreak;\n\tdefault:\n\t\tif (msr >= MSR_IA32_MC0_CTL &&\n\t\t    msr < MSR_IA32_MCx_CTL(bank_num)) {\n\t\t\tu32 offset = msr - MSR_IA32_MC0_CTL;\n\t\t\tdata = vcpu->arch.mce_banks[offset];\n\t\t\tbreak;\n\t\t}\n\t\treturn 1;\n\t}\n\t*pdata = data;\n\treturn 0;\n}"
  },
  {
    "function_name": "kvm_get_msr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "2257-2260",
    "snippet": "int kvm_get_msr(struct kvm_vcpu *vcpu, struct msr_data *msr)\n{\n\treturn kvm_x86_ops->get_msr(vcpu, msr);\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);",
      "struct kvm_x86_ops *kvm_x86_ops"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_x86_ops->get_msr",
          "args": [
            "vcpu",
            "msr"
          ],
          "line": 2259
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nint kvm_get_msr(struct kvm_vcpu *vcpu, struct msr_data *msr)\n{\n\treturn kvm_x86_ops->get_msr(vcpu, msr);\n}"
  },
  {
    "function_name": "kvm_set_msr_common",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "2040-2248",
    "snippet": "int kvm_set_msr_common(struct kvm_vcpu *vcpu, struct msr_data *msr_info)\n{\n\tbool pr = false;\n\tu32 msr = msr_info->index;\n\tu64 data = msr_info->data;\n\n\tswitch (msr) {\n\tcase MSR_AMD64_NB_CFG:\n\tcase MSR_IA32_UCODE_REV:\n\tcase MSR_IA32_UCODE_WRITE:\n\tcase MSR_VM_HSAVE_PA:\n\tcase MSR_AMD64_PATCH_LOADER:\n\tcase MSR_AMD64_BU_CFG2:\n\t\tbreak;\n\n\tcase MSR_EFER:\n\t\treturn set_efer(vcpu, data);\n\tcase MSR_K7_HWCR:\n\t\tdata &= ~(u64)0x40;\t/* ignore flush filter disable */\n\t\tdata &= ~(u64)0x100;\t/* ignore ignne emulation enable */\n\t\tdata &= ~(u64)0x8;\t/* ignore TLB cache disable */\n\t\tdata &= ~(u64)0x40000;  /* ignore Mc status write enable */\n\t\tif (data != 0) {\n\t\t\tvcpu_unimpl(vcpu, \"unimplemented HWCR wrmsr: 0x%llx\\n\",\n\t\t\t\t    data);\n\t\t\treturn 1;\n\t\t}\n\t\tbreak;\n\tcase MSR_FAM10H_MMIO_CONF_BASE:\n\t\tif (data != 0) {\n\t\t\tvcpu_unimpl(vcpu, \"unimplemented MMIO_CONF_BASE wrmsr: \"\n\t\t\t\t    \"0x%llx\\n\", data);\n\t\t\treturn 1;\n\t\t}\n\t\tbreak;\n\tcase MSR_IA32_DEBUGCTLMSR:\n\t\tif (!data) {\n\t\t\t/* We support the non-activated case already */\n\t\t\tbreak;\n\t\t} else if (data & ~(DEBUGCTLMSR_LBR | DEBUGCTLMSR_BTF)) {\n\t\t\t/* Values other than LBR and BTF are vendor-specific,\n\t\t\t   thus reserved and should throw a #GP */\n\t\t\treturn 1;\n\t\t}\n\t\tvcpu_unimpl(vcpu, \"%s: MSR_IA32_DEBUGCTLMSR 0x%llx, nop\\n\",\n\t\t\t    __func__, data);\n\t\tbreak;\n\tcase 0x200 ... 0x2ff:\n\t\treturn kvm_mtrr_set_msr(vcpu, msr, data);\n\tcase MSR_IA32_APICBASE:\n\t\treturn kvm_set_apic_base(vcpu, msr_info);\n\tcase APIC_BASE_MSR ... APIC_BASE_MSR + 0x3ff:\n\t\treturn kvm_x2apic_msr_write(vcpu, msr, data);\n\tcase MSR_IA32_TSCDEADLINE:\n\t\tkvm_set_lapic_tscdeadline_msr(vcpu, data);\n\t\tbreak;\n\tcase MSR_IA32_TSC_ADJUST:\n\t\tif (guest_cpuid_has_tsc_adjust(vcpu)) {\n\t\t\tif (!msr_info->host_initiated) {\n\t\t\t\ts64 adj = data - vcpu->arch.ia32_tsc_adjust_msr;\n\t\t\t\tadjust_tsc_offset_guest(vcpu, adj);\n\t\t\t}\n\t\t\tvcpu->arch.ia32_tsc_adjust_msr = data;\n\t\t}\n\t\tbreak;\n\tcase MSR_IA32_MISC_ENABLE:\n\t\tvcpu->arch.ia32_misc_enable_msr = data;\n\t\tbreak;\n\tcase MSR_IA32_SMBASE:\n\t\tif (!msr_info->host_initiated)\n\t\t\treturn 1;\n\t\tvcpu->arch.smbase = data;\n\t\tbreak;\n\tcase MSR_KVM_WALL_CLOCK_NEW:\n\tcase MSR_KVM_WALL_CLOCK:\n\t\tvcpu->kvm->arch.wall_clock = data;\n\t\tkvm_write_wall_clock(vcpu->kvm, data);\n\t\tbreak;\n\tcase MSR_KVM_SYSTEM_TIME_NEW:\n\tcase MSR_KVM_SYSTEM_TIME: {\n\t\tu64 gpa_offset;\n\t\tstruct kvm_arch *ka = &vcpu->kvm->arch;\n\n\t\tkvmclock_reset(vcpu);\n\n\t\tif (vcpu->vcpu_id == 0 && !msr_info->host_initiated) {\n\t\t\tbool tmp = (msr == MSR_KVM_SYSTEM_TIME);\n\n\t\t\tif (ka->boot_vcpu_runs_old_kvmclock != tmp)\n\t\t\t\tset_bit(KVM_REQ_MASTERCLOCK_UPDATE,\n\t\t\t\t\t&vcpu->requests);\n\n\t\t\tka->boot_vcpu_runs_old_kvmclock = tmp;\n\t\t}\n\n\t\tvcpu->arch.time = data;\n\t\tkvm_make_request(KVM_REQ_GLOBAL_CLOCK_UPDATE, vcpu);\n\n\t\t/* we verify if the enable bit is set... */\n\t\tif (!(data & 1))\n\t\t\tbreak;\n\n\t\tgpa_offset = data & ~(PAGE_MASK | 1);\n\n\t\tif (kvm_gfn_to_hva_cache_init(vcpu->kvm,\n\t\t     &vcpu->arch.pv_time, data & ~1ULL,\n\t\t     sizeof(struct pvclock_vcpu_time_info)))\n\t\t\tvcpu->arch.pv_time_enabled = false;\n\t\telse\n\t\t\tvcpu->arch.pv_time_enabled = true;\n\n\t\tbreak;\n\t}\n\tcase MSR_KVM_ASYNC_PF_EN:\n\t\tif (kvm_pv_enable_async_pf(vcpu, data))\n\t\t\treturn 1;\n\t\tbreak;\n\tcase MSR_KVM_STEAL_TIME:\n\n\t\tif (unlikely(!sched_info_on()))\n\t\t\treturn 1;\n\n\t\tif (data & KVM_STEAL_RESERVED_MASK)\n\t\t\treturn 1;\n\n\t\tif (kvm_gfn_to_hva_cache_init(vcpu->kvm, &vcpu->arch.st.stime,\n\t\t\t\t\t\tdata & KVM_STEAL_VALID_BITS,\n\t\t\t\t\t\tsizeof(struct kvm_steal_time)))\n\t\t\treturn 1;\n\n\t\tvcpu->arch.st.msr_val = data;\n\n\t\tif (!(data & KVM_MSR_ENABLED))\n\t\t\tbreak;\n\n\t\tkvm_make_request(KVM_REQ_STEAL_UPDATE, vcpu);\n\n\t\tbreak;\n\tcase MSR_KVM_PV_EOI_EN:\n\t\tif (kvm_lapic_enable_pv_eoi(vcpu, data))\n\t\t\treturn 1;\n\t\tbreak;\n\n\tcase MSR_IA32_MCG_CTL:\n\tcase MSR_IA32_MCG_STATUS:\n\tcase MSR_IA32_MC0_CTL ... MSR_IA32_MCx_CTL(KVM_MAX_MCE_BANKS) - 1:\n\t\treturn set_msr_mce(vcpu, msr, data);\n\n\tcase MSR_K7_PERFCTR0 ... MSR_K7_PERFCTR3:\n\tcase MSR_P6_PERFCTR0 ... MSR_P6_PERFCTR1:\n\t\tpr = true; /* fall through */\n\tcase MSR_K7_EVNTSEL0 ... MSR_K7_EVNTSEL3:\n\tcase MSR_P6_EVNTSEL0 ... MSR_P6_EVNTSEL1:\n\t\tif (kvm_pmu_is_valid_msr(vcpu, msr))\n\t\t\treturn kvm_pmu_set_msr(vcpu, msr_info);\n\n\t\tif (pr || data != 0)\n\t\t\tvcpu_unimpl(vcpu, \"disabled perfctr wrmsr: \"\n\t\t\t\t    \"0x%x data 0x%llx\\n\", msr, data);\n\t\tbreak;\n\tcase MSR_K7_CLK_CTL:\n\t\t/*\n\t\t * Ignore all writes to this no longer documented MSR.\n\t\t * Writes are only relevant for old K7 processors,\n\t\t * all pre-dating SVM, but a recommended workaround from\n\t\t * AMD for these chips. It is possible to specify the\n\t\t * affected processor models on the command line, hence\n\t\t * the need to ignore the workaround.\n\t\t */\n\t\tbreak;\n\tcase HV_X64_MSR_GUEST_OS_ID ... HV_X64_MSR_SINT15:\n\tcase HV_X64_MSR_CRASH_P0 ... HV_X64_MSR_CRASH_P4:\n\tcase HV_X64_MSR_CRASH_CTL:\n\tcase HV_X64_MSR_STIMER0_CONFIG ... HV_X64_MSR_STIMER3_COUNT:\n\t\treturn kvm_hv_set_msr_common(vcpu, msr, data,\n\t\t\t\t\t     msr_info->host_initiated);\n\tcase MSR_IA32_BBL_CR_CTL3:\n\t\t/* Drop writes to this legacy MSR -- see rdmsr\n\t\t * counterpart for further detail.\n\t\t */\n\t\tvcpu_unimpl(vcpu, \"ignored wrmsr: 0x%x data %llx\\n\", msr, data);\n\t\tbreak;\n\tcase MSR_AMD64_OSVW_ID_LENGTH:\n\t\tif (!guest_cpuid_has_osvw(vcpu))\n\t\t\treturn 1;\n\t\tvcpu->arch.osvw.length = data;\n\t\tbreak;\n\tcase MSR_AMD64_OSVW_STATUS:\n\t\tif (!guest_cpuid_has_osvw(vcpu))\n\t\t\treturn 1;\n\t\tvcpu->arch.osvw.status = data;\n\t\tbreak;\n\tdefault:\n\t\tif (msr && (msr == vcpu->kvm->arch.xen_hvm_config.msr))\n\t\t\treturn xen_hvm_config(vcpu, data);\n\t\tif (kvm_pmu_is_valid_msr(vcpu, msr))\n\t\t\treturn kvm_pmu_set_msr(vcpu, msr_info);\n\t\tif (!ignore_msrs) {\n\t\t\tvcpu_unimpl(vcpu, \"unhandled wrmsr: 0x%x data %llx\\n\",\n\t\t\t\t    msr, data);\n\t\t\treturn 1;\n\t\t} else {\n\t\t\tvcpu_unimpl(vcpu, \"ignored wrmsr: 0x%x data %llx\\n\",\n\t\t\t\t    msr, data);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define KVM_MAX_MCE_BANKS 32"
    ],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vcpu_unimpl",
          "args": [
            "vcpu",
            "\"ignored wrmsr: 0x%x data %llx\\n\"",
            "msr",
            "data"
          ],
          "line": 2242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vcpu_unimpl",
          "args": [
            "vcpu",
            "\"unhandled wrmsr: 0x%x data %llx\\n\"",
            "msr",
            "data"
          ],
          "line": 2238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_pmu_set_msr",
          "args": [
            "vcpu",
            "msr_info"
          ],
          "line": 2236
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_pmu_set_msr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/pmu.c",
          "lines": "274-277",
          "snippet": "int kvm_pmu_set_msr(struct kvm_vcpu *vcpu, struct msr_data *msr_info)\n{\n\treturn kvm_x86_ops->pmu_ops->set_msr(vcpu, msr_info);\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"lapic.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include <asm/perf_event.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include <asm/perf_event.h>\n#include <linux/perf_event.h>\n#include <linux/kvm_host.h>\n#include <linux/types.h>\n\nint kvm_pmu_set_msr(struct kvm_vcpu *vcpu, struct msr_data *msr_info)\n{\n\treturn kvm_x86_ops->pmu_ops->set_msr(vcpu, msr_info);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_pmu_is_valid_msr",
          "args": [
            "vcpu",
            "msr"
          ],
          "line": 2235
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_pmu_is_valid_msr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/pmu.c",
          "lines": "264-267",
          "snippet": "bool kvm_pmu_is_valid_msr(struct kvm_vcpu *vcpu, u32 msr)\n{\n\treturn kvm_x86_ops->pmu_ops->is_valid_msr(vcpu, msr);\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"lapic.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include <asm/perf_event.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include <asm/perf_event.h>\n#include <linux/perf_event.h>\n#include <linux/kvm_host.h>\n#include <linux/types.h>\n\nbool kvm_pmu_is_valid_msr(struct kvm_vcpu *vcpu, u32 msr)\n{\n\treturn kvm_x86_ops->pmu_ops->is_valid_msr(vcpu, msr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xen_hvm_config",
          "args": [
            "vcpu",
            "data"
          ],
          "line": 2234
        },
        "resolved": true,
        "details": {
          "function_name": "xen_hvm_config",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "1945-1974",
          "snippet": "static int xen_hvm_config(struct kvm_vcpu *vcpu, u64 data)\n{\n\tstruct kvm *kvm = vcpu->kvm;\n\tint lm = is_long_mode(vcpu);\n\tu8 *blob_addr = lm ? (u8 *)(long)kvm->arch.xen_hvm_config.blob_addr_64\n\t\t: (u8 *)(long)kvm->arch.xen_hvm_config.blob_addr_32;\n\tu8 blob_size = lm ? kvm->arch.xen_hvm_config.blob_size_64\n\t\t: kvm->arch.xen_hvm_config.blob_size_32;\n\tu32 page_num = data & ~PAGE_MASK;\n\tu64 page_addr = data & PAGE_MASK;\n\tu8 *page;\n\tint r;\n\n\tr = -E2BIG;\n\tif (page_num >= blob_size)\n\t\tgoto out;\n\tr = -ENOMEM;\n\tpage = memdup_user(blob_addr + (page_num * PAGE_SIZE), PAGE_SIZE);\n\tif (IS_ERR(page)) {\n\t\tr = PTR_ERR(page);\n\t\tgoto out;\n\t}\n\tif (kvm_vcpu_write_guest(vcpu, page_addr, page, PAGE_SIZE))\n\t\tgoto out_free;\n\tr = 0;\nout_free:\n\tkfree(page);\nout:\n\treturn r;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic int xen_hvm_config(struct kvm_vcpu *vcpu, u64 data)\n{\n\tstruct kvm *kvm = vcpu->kvm;\n\tint lm = is_long_mode(vcpu);\n\tu8 *blob_addr = lm ? (u8 *)(long)kvm->arch.xen_hvm_config.blob_addr_64\n\t\t: (u8 *)(long)kvm->arch.xen_hvm_config.blob_addr_32;\n\tu8 blob_size = lm ? kvm->arch.xen_hvm_config.blob_size_64\n\t\t: kvm->arch.xen_hvm_config.blob_size_32;\n\tu32 page_num = data & ~PAGE_MASK;\n\tu64 page_addr = data & PAGE_MASK;\n\tu8 *page;\n\tint r;\n\n\tr = -E2BIG;\n\tif (page_num >= blob_size)\n\t\tgoto out;\n\tr = -ENOMEM;\n\tpage = memdup_user(blob_addr + (page_num * PAGE_SIZE), PAGE_SIZE);\n\tif (IS_ERR(page)) {\n\t\tr = PTR_ERR(page);\n\t\tgoto out;\n\t}\n\tif (kvm_vcpu_write_guest(vcpu, page_addr, page, PAGE_SIZE))\n\t\tgoto out_free;\n\tr = 0;\nout_free:\n\tkfree(page);\nout:\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "guest_cpuid_has_osvw",
          "args": [
            "vcpu"
          ],
          "line": 2228
        },
        "resolved": true,
        "details": {
          "function_name": "guest_cpuid_has_osvw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/cpuid.h",
          "lines": "99-105",
          "snippet": "static inline bool guest_cpuid_has_osvw(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_cpuid_entry2 *best;\n\n\tbest = kvm_find_cpuid_entry(vcpu, 0x80000001, 0);\n\treturn best && (best->ecx & bit(X86_FEATURE_OSVW));\n}",
          "includes": [
            "#include <asm/cpu.h>",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpu.h>\n#include \"x86.h\"\n\nstatic inline bool guest_cpuid_has_osvw(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_cpuid_entry2 *best;\n\n\tbest = kvm_find_cpuid_entry(vcpu, 0x80000001, 0);\n\treturn best && (best->ecx & bit(X86_FEATURE_OSVW));\n}"
        }
      },
      {
        "call_info": {
          "callee": "vcpu_unimpl",
          "args": [
            "vcpu",
            "\"ignored wrmsr: 0x%x data %llx\\n\"",
            "msr",
            "data"
          ],
          "line": 2220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_hv_set_msr_common",
          "args": [
            "vcpu",
            "msr",
            "data",
            "msr_info->host_initiated"
          ],
          "line": 2214
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_hv_set_msr_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.c",
          "lines": "1015-1026",
          "snippet": "int kvm_hv_set_msr_common(struct kvm_vcpu *vcpu, u32 msr, u64 data, bool host)\n{\n\tif (kvm_hv_msr_partition_wide(msr)) {\n\t\tint r;\n\n\t\tmutex_lock(&vcpu->kvm->lock);\n\t\tr = kvm_hv_set_msr_pw(vcpu, msr, data, host);\n\t\tmutex_unlock(&vcpu->kvm->lock);\n\t\treturn r;\n\t} else\n\t\treturn kvm_hv_set_msr(vcpu, msr, data, host);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nint kvm_hv_set_msr_common(struct kvm_vcpu *vcpu, u32 msr, u64 data, bool host)\n{\n\tif (kvm_hv_msr_partition_wide(msr)) {\n\t\tint r;\n\n\t\tmutex_lock(&vcpu->kvm->lock);\n\t\tr = kvm_hv_set_msr_pw(vcpu, msr, data, host);\n\t\tmutex_unlock(&vcpu->kvm->lock);\n\t\treturn r;\n\t} else\n\t\treturn kvm_hv_set_msr(vcpu, msr, data, host);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vcpu_unimpl",
          "args": [
            "vcpu",
            "\"disabled perfctr wrmsr: \"\n\t\t\t\t    \"0x%x data 0x%llx\\n\"",
            "msr",
            "data"
          ],
          "line": 2197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_msr_mce",
          "args": [
            "vcpu",
            "msr",
            "data"
          ],
          "line": 2186
        },
        "resolved": true,
        "details": {
          "function_name": "set_msr_mce",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "1909-1943",
          "snippet": "static int set_msr_mce(struct kvm_vcpu *vcpu, u32 msr, u64 data)\n{\n\tu64 mcg_cap = vcpu->arch.mcg_cap;\n\tunsigned bank_num = mcg_cap & 0xff;\n\n\tswitch (msr) {\n\tcase MSR_IA32_MCG_STATUS:\n\t\tvcpu->arch.mcg_status = data;\n\t\tbreak;\n\tcase MSR_IA32_MCG_CTL:\n\t\tif (!(mcg_cap & MCG_CTL_P))\n\t\t\treturn 1;\n\t\tif (data != 0 && data != ~(u64)0)\n\t\t\treturn -1;\n\t\tvcpu->arch.mcg_ctl = data;\n\t\tbreak;\n\tdefault:\n\t\tif (msr >= MSR_IA32_MC0_CTL &&\n\t\t    msr < MSR_IA32_MCx_CTL(bank_num)) {\n\t\t\tu32 offset = msr - MSR_IA32_MC0_CTL;\n\t\t\t/* only 0 or all 1s can be written to IA32_MCi_CTL\n\t\t\t * some Linux kernels though clear bit 10 in bank 4 to\n\t\t\t * workaround a BIOS/GART TBL issue on AMD K8s, ignore\n\t\t\t * this to avoid an uncatched #GP in the guest\n\t\t\t */\n\t\t\tif ((offset & 0x3) == 0 &&\n\t\t\t    data != 0 && (data | (1 << 10)) != ~(u64)0)\n\t\t\t\treturn -1;\n\t\t\tvcpu->arch.mce_banks[offset] = data;\n\t\t\tbreak;\n\t\t}\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic int set_msr_mce(struct kvm_vcpu *vcpu, u32 msr, u64 data)\n{\n\tu64 mcg_cap = vcpu->arch.mcg_cap;\n\tunsigned bank_num = mcg_cap & 0xff;\n\n\tswitch (msr) {\n\tcase MSR_IA32_MCG_STATUS:\n\t\tvcpu->arch.mcg_status = data;\n\t\tbreak;\n\tcase MSR_IA32_MCG_CTL:\n\t\tif (!(mcg_cap & MCG_CTL_P))\n\t\t\treturn 1;\n\t\tif (data != 0 && data != ~(u64)0)\n\t\t\treturn -1;\n\t\tvcpu->arch.mcg_ctl = data;\n\t\tbreak;\n\tdefault:\n\t\tif (msr >= MSR_IA32_MC0_CTL &&\n\t\t    msr < MSR_IA32_MCx_CTL(bank_num)) {\n\t\t\tu32 offset = msr - MSR_IA32_MC0_CTL;\n\t\t\t/* only 0 or all 1s can be written to IA32_MCi_CTL\n\t\t\t * some Linux kernels though clear bit 10 in bank 4 to\n\t\t\t * workaround a BIOS/GART TBL issue on AMD K8s, ignore\n\t\t\t * this to avoid an uncatched #GP in the guest\n\t\t\t */\n\t\t\tif ((offset & 0x3) == 0 &&\n\t\t\t    data != 0 && (data | (1 << 10)) != ~(u64)0)\n\t\t\t\treturn -1;\n\t\t\tvcpu->arch.mce_banks[offset] = data;\n\t\t\tbreak;\n\t\t}\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MSR_IA32_MCx_CTL",
          "args": [
            "KVM_MAX_MCE_BANKS"
          ],
          "line": 2185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_lapic_enable_pv_eoi",
          "args": [
            "vcpu",
            "data"
          ],
          "line": 2179
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_enable_pv_eoi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "2182-2193",
          "snippet": "int kvm_lapic_enable_pv_eoi(struct kvm_vcpu *vcpu, u64 data)\n{\n\tu64 addr = data & ~KVM_MSR_ENABLED;\n\tif (!IS_ALIGNED(addr, 4))\n\t\treturn 1;\n\n\tvcpu->arch.pv_eoi.msr_val = data;\n\tif (!pv_eoi_enabled(vcpu))\n\t\treturn 0;\n\treturn kvm_gfn_to_hva_cache_init(vcpu->kvm, &vcpu->arch.pv_eoi.data,\n\t\t\t\t\t addr, sizeof(u8));\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nint kvm_lapic_enable_pv_eoi(struct kvm_vcpu *vcpu, u64 data)\n{\n\tu64 addr = data & ~KVM_MSR_ENABLED;\n\tif (!IS_ALIGNED(addr, 4))\n\t\treturn 1;\n\n\tvcpu->arch.pv_eoi.msr_val = data;\n\tif (!pv_eoi_enabled(vcpu))\n\t\treturn 0;\n\treturn kvm_gfn_to_hva_cache_init(vcpu->kvm, &vcpu->arch.pv_eoi.data,\n\t\t\t\t\t addr, sizeof(u8));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_make_request",
          "args": [
            "KVM_REQ_STEAL_UPDATE",
            "vcpu"
          ],
          "line": 2175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_gfn_to_hva_cache_init",
          "args": [
            "vcpu->kvm",
            "&vcpu->arch.st.stime",
            "data & KVM_STEAL_VALID_BITS",
            "sizeof(struct kvm_steal_time)"
          ],
          "line": 2165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!sched_info_on()"
          ],
          "line": 2159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_info_on",
          "args": [],
          "line": 2159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_pv_enable_async_pf",
          "args": [
            "vcpu",
            "data"
          ],
          "line": 2154
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_pv_enable_async_pf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "1976-1999",
          "snippet": "static int kvm_pv_enable_async_pf(struct kvm_vcpu *vcpu, u64 data)\n{\n\tgpa_t gpa = data & ~0x3f;\n\n\t/* Bits 2:5 are reserved, Should be zero */\n\tif (data & 0x3c)\n\t\treturn 1;\n\n\tvcpu->arch.apf.msr_val = data;\n\n\tif (!(data & KVM_ASYNC_PF_ENABLED)) {\n\t\tkvm_clear_async_pf_completion_queue(vcpu);\n\t\tkvm_async_pf_hash_reset(vcpu);\n\t\treturn 0;\n\t}\n\n\tif (kvm_gfn_to_hva_cache_init(vcpu->kvm, &vcpu->arch.apf.data, gpa,\n\t\t\t\t\tsizeof(u32)))\n\t\treturn 1;\n\n\tvcpu->arch.apf.send_user_only = !(data & KVM_ASYNC_PF_SEND_ALWAYS);\n\tkvm_async_pf_wakeup_all(vcpu);\n\treturn 0;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic int kvm_pv_enable_async_pf(struct kvm_vcpu *vcpu, u64 data)\n{\n\tgpa_t gpa = data & ~0x3f;\n\n\t/* Bits 2:5 are reserved, Should be zero */\n\tif (data & 0x3c)\n\t\treturn 1;\n\n\tvcpu->arch.apf.msr_val = data;\n\n\tif (!(data & KVM_ASYNC_PF_ENABLED)) {\n\t\tkvm_clear_async_pf_completion_queue(vcpu);\n\t\tkvm_async_pf_hash_reset(vcpu);\n\t\treturn 0;\n\t}\n\n\tif (kvm_gfn_to_hva_cache_init(vcpu->kvm, &vcpu->arch.apf.data, gpa,\n\t\t\t\t\tsizeof(u32)))\n\t\treturn 1;\n\n\tvcpu->arch.apf.send_user_only = !(data & KVM_ASYNC_PF_SEND_ALWAYS);\n\tkvm_async_pf_wakeup_all(vcpu);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_gfn_to_hva_cache_init",
          "args": [
            "vcpu->kvm",
            "&vcpu->arch.pv_time",
            "data & ~1ULL",
            "sizeof(struct pvclock_vcpu_time_info)"
          ],
          "line": 2144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_make_request",
          "args": [
            "KVM_REQ_GLOBAL_CLOCK_UPDATE",
            "vcpu"
          ],
          "line": 2136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "KVM_REQ_MASTERCLOCK_UPDATE",
            "&vcpu->requests"
          ],
          "line": 2129
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_set_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/vmx.c",
          "lines": "1599-1604",
          "snippet": "static __always_inline void vmcs_set_bits(unsigned long field, u32 mask)\n{\n        BUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x2000,\n\t\t\t \"vmcs_set_bits does not support 64-bit fields\");\n\t__vmcs_writel(field, __vmcs_readl(field) | mask);\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"trace.h\"",
            "#include <asm/irq_remapping.h>",
            "#include <asm/apic.h>",
            "#include <asm/kexec.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/mce.h>",
            "#include <asm/virtext.h>",
            "#include <asm/vmx.h>",
            "#include <asm/desc.h>",
            "#include <asm/io.h>",
            "#include <asm/cpu.h>",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/hrtimer.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include \"lapic.h\"",
            "#include \"cpuid.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"trace.h\"\n#include <asm/irq_remapping.h>\n#include <asm/apic.h>\n#include <asm/kexec.h>\n#include <asm/debugreg.h>\n#include <asm/perf_event.h>\n#include <asm/fpu/internal.h>\n#include <asm/mce.h>\n#include <asm/virtext.h>\n#include <asm/vmx.h>\n#include <asm/desc.h>\n#include <asm/io.h>\n#include <asm/cpu.h>\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/hrtimer.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic __always_inline void vmcs_set_bits(unsigned long field, u32 mask)\n{\n        BUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x2000,\n\t\t\t \"vmcs_set_bits does not support 64-bit fields\");\n\t__vmcs_writel(field, __vmcs_readl(field) | mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvmclock_reset",
          "args": [
            "vcpu"
          ],
          "line": 2123
        },
        "resolved": true,
        "details": {
          "function_name": "kvmclock_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "2001-2004",
          "snippet": "static void kvmclock_reset(struct kvm_vcpu *vcpu)\n{\n\tvcpu->arch.pv_time_enabled = false;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic void kvmclock_reset(struct kvm_vcpu *vcpu)\n{\n\tvcpu->arch.pv_time_enabled = false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_write_wall_clock",
          "args": [
            "vcpu->kvm",
            "data"
          ],
          "line": 2116
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_write_wall_clock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "1159-1201",
          "snippet": "static void kvm_write_wall_clock(struct kvm *kvm, gpa_t wall_clock)\n{\n\tint version;\n\tint r;\n\tstruct pvclock_wall_clock wc;\n\tstruct timespec boot;\n\n\tif (!wall_clock)\n\t\treturn;\n\n\tr = kvm_read_guest(kvm, wall_clock, &version, sizeof(version));\n\tif (r)\n\t\treturn;\n\n\tif (version & 1)\n\t\t++version;  /* first time write, random junk */\n\n\t++version;\n\n\tif (kvm_write_guest(kvm, wall_clock, &version, sizeof(version)))\n\t\treturn;\n\n\t/*\n\t * The guest calculates current wall clock time by adding\n\t * system time (updated by kvm_guest_time_update below) to the\n\t * wall clock specified here.  guest system time equals host\n\t * system time for us, thus we must fill in host boot time here.\n\t */\n\tgetboottime(&boot);\n\n\tif (kvm->arch.kvmclock_offset) {\n\t\tstruct timespec ts = ns_to_timespec(kvm->arch.kvmclock_offset);\n\t\tboot = timespec_sub(boot, ts);\n\t}\n\twc.sec = boot.tv_sec;\n\twc.nsec = boot.tv_nsec;\n\twc.version = version;\n\n\tkvm_write_guest(kvm, wall_clock, &wc, sizeof(wc));\n\n\tversion++;\n\tkvm_write_guest(kvm, wall_clock, &version, sizeof(version));\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void kvm_write_wall_clock(struct kvm *kvm, gpa_t wall_clock)\n{\n\tint version;\n\tint r;\n\tstruct pvclock_wall_clock wc;\n\tstruct timespec boot;\n\n\tif (!wall_clock)\n\t\treturn;\n\n\tr = kvm_read_guest(kvm, wall_clock, &version, sizeof(version));\n\tif (r)\n\t\treturn;\n\n\tif (version & 1)\n\t\t++version;  /* first time write, random junk */\n\n\t++version;\n\n\tif (kvm_write_guest(kvm, wall_clock, &version, sizeof(version)))\n\t\treturn;\n\n\t/*\n\t * The guest calculates current wall clock time by adding\n\t * system time (updated by kvm_guest_time_update below) to the\n\t * wall clock specified here.  guest system time equals host\n\t * system time for us, thus we must fill in host boot time here.\n\t */\n\tgetboottime(&boot);\n\n\tif (kvm->arch.kvmclock_offset) {\n\t\tstruct timespec ts = ns_to_timespec(kvm->arch.kvmclock_offset);\n\t\tboot = timespec_sub(boot, ts);\n\t}\n\twc.sec = boot.tv_sec;\n\twc.nsec = boot.tv_nsec;\n\twc.version = version;\n\n\tkvm_write_guest(kvm, wall_clock, &wc, sizeof(wc));\n\n\tversion++;\n\tkvm_write_guest(kvm, wall_clock, &version, sizeof(version));\n}"
        }
      },
      {
        "call_info": {
          "callee": "adjust_tsc_offset_guest",
          "args": [
            "vcpu",
            "adj"
          ],
          "line": 2100
        },
        "resolved": true,
        "details": {
          "function_name": "adjust_tsc_offset_guest",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "1539-1543",
          "snippet": "static inline void adjust_tsc_offset_guest(struct kvm_vcpu *vcpu,\n\t\t\t\t\t   s64 adjustment)\n{\n\tkvm_x86_ops->adjust_tsc_offset_guest(vcpu, adjustment);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "struct kvm_x86_ops *kvm_x86_ops"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nstatic inline void adjust_tsc_offset_guest(struct kvm_vcpu *vcpu,\n\t\t\t\t\t   s64 adjustment)\n{\n\tkvm_x86_ops->adjust_tsc_offset_guest(vcpu, adjustment);\n}"
        }
      },
      {
        "call_info": {
          "callee": "guest_cpuid_has_tsc_adjust",
          "args": [
            "vcpu"
          ],
          "line": 2097
        },
        "resolved": true,
        "details": {
          "function_name": "guest_cpuid_has_tsc_adjust",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/cpuid.h",
          "lines": "51-57",
          "snippet": "static inline bool guest_cpuid_has_tsc_adjust(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_cpuid_entry2 *best;\n\n\tbest = kvm_find_cpuid_entry(vcpu, 7, 0);\n\treturn best && (best->ebx & bit(X86_FEATURE_TSC_ADJUST));\n}",
          "includes": [
            "#include <asm/cpu.h>",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpu.h>\n#include \"x86.h\"\n\nstatic inline bool guest_cpuid_has_tsc_adjust(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_cpuid_entry2 *best;\n\n\tbest = kvm_find_cpuid_entry(vcpu, 7, 0);\n\treturn best && (best->ebx & bit(X86_FEATURE_TSC_ADJUST));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_set_lapic_tscdeadline_msr",
          "args": [
            "vcpu",
            "data"
          ],
          "line": 2094
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_set_lapic_tscdeadline_msr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "1631-1642",
          "snippet": "void kvm_set_lapic_tscdeadline_msr(struct kvm_vcpu *vcpu, u64 data)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tif (!lapic_in_kernel(vcpu) || apic_lvtt_oneshot(apic) ||\n\t\t\tapic_lvtt_period(apic))\n\t\treturn;\n\n\thrtimer_cancel(&apic->lapic_timer.timer);\n\tapic->lapic_timer.tscdeadline = data;\n\tstart_apic_timer(apic);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nvoid kvm_set_lapic_tscdeadline_msr(struct kvm_vcpu *vcpu, u64 data)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tif (!lapic_in_kernel(vcpu) || apic_lvtt_oneshot(apic) ||\n\t\t\tapic_lvtt_period(apic))\n\t\treturn;\n\n\thrtimer_cancel(&apic->lapic_timer.timer);\n\tapic->lapic_timer.tscdeadline = data;\n\tstart_apic_timer(apic);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_x2apic_msr_write",
          "args": [
            "vcpu",
            "msr",
            "data"
          ],
          "line": 2092
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_x2apic_msr_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "2110-2125",
          "snippet": "int kvm_x2apic_msr_write(struct kvm_vcpu *vcpu, u32 msr, u64 data)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tu32 reg = (msr - APIC_BASE_MSR) << 4;\n\n\tif (!lapic_in_kernel(vcpu) || !apic_x2apic_mode(apic))\n\t\treturn 1;\n\n\tif (reg == APIC_ICR2)\n\t\treturn 1;\n\n\t/* if this is ICR write vector before command */\n\tif (reg == APIC_ICR)\n\t\tkvm_lapic_reg_write(apic, APIC_ICR2, (u32)(data >> 32));\n\treturn kvm_lapic_reg_write(apic, reg, (u32)data);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nint kvm_x2apic_msr_write(struct kvm_vcpu *vcpu, u32 msr, u64 data)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tu32 reg = (msr - APIC_BASE_MSR) << 4;\n\n\tif (!lapic_in_kernel(vcpu) || !apic_x2apic_mode(apic))\n\t\treturn 1;\n\n\tif (reg == APIC_ICR2)\n\t\treturn 1;\n\n\t/* if this is ICR write vector before command */\n\tif (reg == APIC_ICR)\n\t\tkvm_lapic_reg_write(apic, APIC_ICR2, (u32)(data >> 32));\n\treturn kvm_lapic_reg_write(apic, reg, (u32)data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_set_apic_base",
          "args": [
            "vcpu",
            "msr_info"
          ],
          "line": 2090
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_set_apic_base",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "289-309",
          "snippet": "int kvm_set_apic_base(struct kvm_vcpu *vcpu, struct msr_data *msr_info)\n{\n\tu64 old_state = vcpu->arch.apic_base &\n\t\t(MSR_IA32_APICBASE_ENABLE | X2APIC_ENABLE);\n\tu64 new_state = msr_info->data &\n\t\t(MSR_IA32_APICBASE_ENABLE | X2APIC_ENABLE);\n\tu64 reserved_bits = ((~0ULL) << cpuid_maxphyaddr(vcpu)) |\n\t\t0x2ff | (guest_cpuid_has_x2apic(vcpu) ? 0 : X2APIC_ENABLE);\n\n\tif (!msr_info->host_initiated &&\n\t    ((msr_info->data & reserved_bits) != 0 ||\n\t     new_state == X2APIC_ENABLE ||\n\t     (new_state == MSR_IA32_APICBASE_ENABLE &&\n\t      old_state == (MSR_IA32_APICBASE_ENABLE | X2APIC_ENABLE)) ||\n\t     (new_state == (MSR_IA32_APICBASE_ENABLE | X2APIC_ENABLE) &&\n\t      old_state == 0)))\n\t\treturn 1;\n\n\tkvm_lapic_set_base(vcpu, msr_info->data);\n\treturn 0;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nint kvm_set_apic_base(struct kvm_vcpu *vcpu, struct msr_data *msr_info)\n{\n\tu64 old_state = vcpu->arch.apic_base &\n\t\t(MSR_IA32_APICBASE_ENABLE | X2APIC_ENABLE);\n\tu64 new_state = msr_info->data &\n\t\t(MSR_IA32_APICBASE_ENABLE | X2APIC_ENABLE);\n\tu64 reserved_bits = ((~0ULL) << cpuid_maxphyaddr(vcpu)) |\n\t\t0x2ff | (guest_cpuid_has_x2apic(vcpu) ? 0 : X2APIC_ENABLE);\n\n\tif (!msr_info->host_initiated &&\n\t    ((msr_info->data & reserved_bits) != 0 ||\n\t     new_state == X2APIC_ENABLE ||\n\t     (new_state == MSR_IA32_APICBASE_ENABLE &&\n\t      old_state == (MSR_IA32_APICBASE_ENABLE | X2APIC_ENABLE)) ||\n\t     (new_state == (MSR_IA32_APICBASE_ENABLE | X2APIC_ENABLE) &&\n\t      old_state == 0)))\n\t\treturn 1;\n\n\tkvm_lapic_set_base(vcpu, msr_info->data);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_mtrr_set_msr",
          "args": [
            "vcpu",
            "msr",
            "data"
          ],
          "line": 2088
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mtrr_set_msr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mtrr.c",
          "lines": "384-403",
          "snippet": "int kvm_mtrr_set_msr(struct kvm_vcpu *vcpu, u32 msr, u64 data)\n{\n\tint index;\n\n\tif (!kvm_mtrr_valid(vcpu, msr, data))\n\t\treturn 1;\n\n\tindex = fixed_msr_to_range_index(msr);\n\tif (index >= 0)\n\t\t*(u64 *)&vcpu->arch.mtrr_state.fixed_ranges[index] = data;\n\telse if (msr == MSR_MTRRdefType)\n\t\tvcpu->arch.mtrr_state.deftype = data;\n\telse if (msr == MSR_IA32_CR_PAT)\n\t\tvcpu->arch.pat = data;\n\telse\n\t\tset_var_mtrr_msr(vcpu, msr, data);\n\n\tupdate_mtrr(vcpu, msr);\n\treturn 0;\n}",
          "includes": [
            "#include \"mmu.h\"",
            "#include \"cpuid.h\"",
            "#include <asm/mtrr.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mmu.h\"\n#include \"cpuid.h\"\n#include <asm/mtrr.h>\n#include <linux/kvm_host.h>\n\nint kvm_mtrr_set_msr(struct kvm_vcpu *vcpu, u32 msr, u64 data)\n{\n\tint index;\n\n\tif (!kvm_mtrr_valid(vcpu, msr, data))\n\t\treturn 1;\n\n\tindex = fixed_msr_to_range_index(msr);\n\tif (index >= 0)\n\t\t*(u64 *)&vcpu->arch.mtrr_state.fixed_ranges[index] = data;\n\telse if (msr == MSR_MTRRdefType)\n\t\tvcpu->arch.mtrr_state.deftype = data;\n\telse if (msr == MSR_IA32_CR_PAT)\n\t\tvcpu->arch.pat = data;\n\telse\n\t\tset_var_mtrr_msr(vcpu, msr, data);\n\n\tupdate_mtrr(vcpu, msr);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vcpu_unimpl",
          "args": [
            "vcpu",
            "\"%s: MSR_IA32_DEBUGCTLMSR 0x%llx, nop\\n\"",
            "__func__",
            "data"
          ],
          "line": 2084
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vcpu_unimpl",
          "args": [
            "vcpu",
            "\"unimplemented MMIO_CONF_BASE wrmsr: \"\n\t\t\t\t    \"0x%llx\\n\"",
            "data"
          ],
          "line": 2070
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vcpu_unimpl",
          "args": [
            "vcpu",
            "\"unimplemented HWCR wrmsr: 0x%llx\\n\"",
            "data"
          ],
          "line": 2063
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_efer",
          "args": [
            "vcpu",
            "data"
          ],
          "line": 2056
        },
        "resolved": true,
        "details": {
          "function_name": "set_efer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "1015-1036",
          "snippet": "static int set_efer(struct kvm_vcpu *vcpu, u64 efer)\n{\n\tu64 old_efer = vcpu->arch.efer;\n\n\tif (!kvm_valid_efer(vcpu, efer))\n\t\treturn 1;\n\n\tif (is_paging(vcpu)\n\t    && (vcpu->arch.efer & EFER_LME) != (efer & EFER_LME))\n\t\treturn 1;\n\n\tefer &= ~EFER_LMA;\n\tefer |= vcpu->arch.efer & EFER_LMA;\n\n\tkvm_x86_ops->set_efer(vcpu, efer);\n\n\t/* Update reserved bits */\n\tif ((efer ^ old_efer) & EFER_NX)\n\t\tkvm_mmu_reset_context(vcpu);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "struct kvm_x86_ops *kvm_x86_ops"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nstatic int set_efer(struct kvm_vcpu *vcpu, u64 efer)\n{\n\tu64 old_efer = vcpu->arch.efer;\n\n\tif (!kvm_valid_efer(vcpu, efer))\n\t\treturn 1;\n\n\tif (is_paging(vcpu)\n\t    && (vcpu->arch.efer & EFER_LME) != (efer & EFER_LME))\n\t\treturn 1;\n\n\tefer &= ~EFER_LMA;\n\tefer |= vcpu->arch.efer & EFER_LMA;\n\n\tkvm_x86_ops->set_efer(vcpu, efer);\n\n\t/* Update reserved bits */\n\tif ((efer ^ old_efer) & EFER_NX)\n\t\tkvm_mmu_reset_context(vcpu);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define KVM_MAX_MCE_BANKS 32\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nint kvm_set_msr_common(struct kvm_vcpu *vcpu, struct msr_data *msr_info)\n{\n\tbool pr = false;\n\tu32 msr = msr_info->index;\n\tu64 data = msr_info->data;\n\n\tswitch (msr) {\n\tcase MSR_AMD64_NB_CFG:\n\tcase MSR_IA32_UCODE_REV:\n\tcase MSR_IA32_UCODE_WRITE:\n\tcase MSR_VM_HSAVE_PA:\n\tcase MSR_AMD64_PATCH_LOADER:\n\tcase MSR_AMD64_BU_CFG2:\n\t\tbreak;\n\n\tcase MSR_EFER:\n\t\treturn set_efer(vcpu, data);\n\tcase MSR_K7_HWCR:\n\t\tdata &= ~(u64)0x40;\t/* ignore flush filter disable */\n\t\tdata &= ~(u64)0x100;\t/* ignore ignne emulation enable */\n\t\tdata &= ~(u64)0x8;\t/* ignore TLB cache disable */\n\t\tdata &= ~(u64)0x40000;  /* ignore Mc status write enable */\n\t\tif (data != 0) {\n\t\t\tvcpu_unimpl(vcpu, \"unimplemented HWCR wrmsr: 0x%llx\\n\",\n\t\t\t\t    data);\n\t\t\treturn 1;\n\t\t}\n\t\tbreak;\n\tcase MSR_FAM10H_MMIO_CONF_BASE:\n\t\tif (data != 0) {\n\t\t\tvcpu_unimpl(vcpu, \"unimplemented MMIO_CONF_BASE wrmsr: \"\n\t\t\t\t    \"0x%llx\\n\", data);\n\t\t\treturn 1;\n\t\t}\n\t\tbreak;\n\tcase MSR_IA32_DEBUGCTLMSR:\n\t\tif (!data) {\n\t\t\t/* We support the non-activated case already */\n\t\t\tbreak;\n\t\t} else if (data & ~(DEBUGCTLMSR_LBR | DEBUGCTLMSR_BTF)) {\n\t\t\t/* Values other than LBR and BTF are vendor-specific,\n\t\t\t   thus reserved and should throw a #GP */\n\t\t\treturn 1;\n\t\t}\n\t\tvcpu_unimpl(vcpu, \"%s: MSR_IA32_DEBUGCTLMSR 0x%llx, nop\\n\",\n\t\t\t    __func__, data);\n\t\tbreak;\n\tcase 0x200 ... 0x2ff:\n\t\treturn kvm_mtrr_set_msr(vcpu, msr, data);\n\tcase MSR_IA32_APICBASE:\n\t\treturn kvm_set_apic_base(vcpu, msr_info);\n\tcase APIC_BASE_MSR ... APIC_BASE_MSR + 0x3ff:\n\t\treturn kvm_x2apic_msr_write(vcpu, msr, data);\n\tcase MSR_IA32_TSCDEADLINE:\n\t\tkvm_set_lapic_tscdeadline_msr(vcpu, data);\n\t\tbreak;\n\tcase MSR_IA32_TSC_ADJUST:\n\t\tif (guest_cpuid_has_tsc_adjust(vcpu)) {\n\t\t\tif (!msr_info->host_initiated) {\n\t\t\t\ts64 adj = data - vcpu->arch.ia32_tsc_adjust_msr;\n\t\t\t\tadjust_tsc_offset_guest(vcpu, adj);\n\t\t\t}\n\t\t\tvcpu->arch.ia32_tsc_adjust_msr = data;\n\t\t}\n\t\tbreak;\n\tcase MSR_IA32_MISC_ENABLE:\n\t\tvcpu->arch.ia32_misc_enable_msr = data;\n\t\tbreak;\n\tcase MSR_IA32_SMBASE:\n\t\tif (!msr_info->host_initiated)\n\t\t\treturn 1;\n\t\tvcpu->arch.smbase = data;\n\t\tbreak;\n\tcase MSR_KVM_WALL_CLOCK_NEW:\n\tcase MSR_KVM_WALL_CLOCK:\n\t\tvcpu->kvm->arch.wall_clock = data;\n\t\tkvm_write_wall_clock(vcpu->kvm, data);\n\t\tbreak;\n\tcase MSR_KVM_SYSTEM_TIME_NEW:\n\tcase MSR_KVM_SYSTEM_TIME: {\n\t\tu64 gpa_offset;\n\t\tstruct kvm_arch *ka = &vcpu->kvm->arch;\n\n\t\tkvmclock_reset(vcpu);\n\n\t\tif (vcpu->vcpu_id == 0 && !msr_info->host_initiated) {\n\t\t\tbool tmp = (msr == MSR_KVM_SYSTEM_TIME);\n\n\t\t\tif (ka->boot_vcpu_runs_old_kvmclock != tmp)\n\t\t\t\tset_bit(KVM_REQ_MASTERCLOCK_UPDATE,\n\t\t\t\t\t&vcpu->requests);\n\n\t\t\tka->boot_vcpu_runs_old_kvmclock = tmp;\n\t\t}\n\n\t\tvcpu->arch.time = data;\n\t\tkvm_make_request(KVM_REQ_GLOBAL_CLOCK_UPDATE, vcpu);\n\n\t\t/* we verify if the enable bit is set... */\n\t\tif (!(data & 1))\n\t\t\tbreak;\n\n\t\tgpa_offset = data & ~(PAGE_MASK | 1);\n\n\t\tif (kvm_gfn_to_hva_cache_init(vcpu->kvm,\n\t\t     &vcpu->arch.pv_time, data & ~1ULL,\n\t\t     sizeof(struct pvclock_vcpu_time_info)))\n\t\t\tvcpu->arch.pv_time_enabled = false;\n\t\telse\n\t\t\tvcpu->arch.pv_time_enabled = true;\n\n\t\tbreak;\n\t}\n\tcase MSR_KVM_ASYNC_PF_EN:\n\t\tif (kvm_pv_enable_async_pf(vcpu, data))\n\t\t\treturn 1;\n\t\tbreak;\n\tcase MSR_KVM_STEAL_TIME:\n\n\t\tif (unlikely(!sched_info_on()))\n\t\t\treturn 1;\n\n\t\tif (data & KVM_STEAL_RESERVED_MASK)\n\t\t\treturn 1;\n\n\t\tif (kvm_gfn_to_hva_cache_init(vcpu->kvm, &vcpu->arch.st.stime,\n\t\t\t\t\t\tdata & KVM_STEAL_VALID_BITS,\n\t\t\t\t\t\tsizeof(struct kvm_steal_time)))\n\t\t\treturn 1;\n\n\t\tvcpu->arch.st.msr_val = data;\n\n\t\tif (!(data & KVM_MSR_ENABLED))\n\t\t\tbreak;\n\n\t\tkvm_make_request(KVM_REQ_STEAL_UPDATE, vcpu);\n\n\t\tbreak;\n\tcase MSR_KVM_PV_EOI_EN:\n\t\tif (kvm_lapic_enable_pv_eoi(vcpu, data))\n\t\t\treturn 1;\n\t\tbreak;\n\n\tcase MSR_IA32_MCG_CTL:\n\tcase MSR_IA32_MCG_STATUS:\n\tcase MSR_IA32_MC0_CTL ... MSR_IA32_MCx_CTL(KVM_MAX_MCE_BANKS) - 1:\n\t\treturn set_msr_mce(vcpu, msr, data);\n\n\tcase MSR_K7_PERFCTR0 ... MSR_K7_PERFCTR3:\n\tcase MSR_P6_PERFCTR0 ... MSR_P6_PERFCTR1:\n\t\tpr = true; /* fall through */\n\tcase MSR_K7_EVNTSEL0 ... MSR_K7_EVNTSEL3:\n\tcase MSR_P6_EVNTSEL0 ... MSR_P6_EVNTSEL1:\n\t\tif (kvm_pmu_is_valid_msr(vcpu, msr))\n\t\t\treturn kvm_pmu_set_msr(vcpu, msr_info);\n\n\t\tif (pr || data != 0)\n\t\t\tvcpu_unimpl(vcpu, \"disabled perfctr wrmsr: \"\n\t\t\t\t    \"0x%x data 0x%llx\\n\", msr, data);\n\t\tbreak;\n\tcase MSR_K7_CLK_CTL:\n\t\t/*\n\t\t * Ignore all writes to this no longer documented MSR.\n\t\t * Writes are only relevant for old K7 processors,\n\t\t * all pre-dating SVM, but a recommended workaround from\n\t\t * AMD for these chips. It is possible to specify the\n\t\t * affected processor models on the command line, hence\n\t\t * the need to ignore the workaround.\n\t\t */\n\t\tbreak;\n\tcase HV_X64_MSR_GUEST_OS_ID ... HV_X64_MSR_SINT15:\n\tcase HV_X64_MSR_CRASH_P0 ... HV_X64_MSR_CRASH_P4:\n\tcase HV_X64_MSR_CRASH_CTL:\n\tcase HV_X64_MSR_STIMER0_CONFIG ... HV_X64_MSR_STIMER3_COUNT:\n\t\treturn kvm_hv_set_msr_common(vcpu, msr, data,\n\t\t\t\t\t     msr_info->host_initiated);\n\tcase MSR_IA32_BBL_CR_CTL3:\n\t\t/* Drop writes to this legacy MSR -- see rdmsr\n\t\t * counterpart for further detail.\n\t\t */\n\t\tvcpu_unimpl(vcpu, \"ignored wrmsr: 0x%x data %llx\\n\", msr, data);\n\t\tbreak;\n\tcase MSR_AMD64_OSVW_ID_LENGTH:\n\t\tif (!guest_cpuid_has_osvw(vcpu))\n\t\t\treturn 1;\n\t\tvcpu->arch.osvw.length = data;\n\t\tbreak;\n\tcase MSR_AMD64_OSVW_STATUS:\n\t\tif (!guest_cpuid_has_osvw(vcpu))\n\t\t\treturn 1;\n\t\tvcpu->arch.osvw.status = data;\n\t\tbreak;\n\tdefault:\n\t\tif (msr && (msr == vcpu->kvm->arch.xen_hvm_config.msr))\n\t\t\treturn xen_hvm_config(vcpu, data);\n\t\tif (kvm_pmu_is_valid_msr(vcpu, msr))\n\t\t\treturn kvm_pmu_set_msr(vcpu, msr_info);\n\t\tif (!ignore_msrs) {\n\t\t\tvcpu_unimpl(vcpu, \"unhandled wrmsr: 0x%x data %llx\\n\",\n\t\t\t\t    msr, data);\n\t\t\treturn 1;\n\t\t} else {\n\t\t\tvcpu_unimpl(vcpu, \"ignored wrmsr: 0x%x data %llx\\n\",\n\t\t\t\t    msr, data);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "record_steal_time",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "2006-2038",
    "snippet": "static void record_steal_time(struct kvm_vcpu *vcpu)\n{\n\tif (!(vcpu->arch.st.msr_val & KVM_MSR_ENABLED))\n\t\treturn;\n\n\tif (unlikely(kvm_read_guest_cached(vcpu->kvm, &vcpu->arch.st.stime,\n\t\t&vcpu->arch.st.steal, sizeof(struct kvm_steal_time))))\n\t\treturn;\n\n\tif (vcpu->arch.st.steal.version & 1)\n\t\tvcpu->arch.st.steal.version += 1;  /* first time write, random junk */\n\n\tvcpu->arch.st.steal.version += 1;\n\n\tkvm_write_guest_cached(vcpu->kvm, &vcpu->arch.st.stime,\n\t\t&vcpu->arch.st.steal, sizeof(struct kvm_steal_time));\n\n\tsmp_wmb();\n\n\tvcpu->arch.st.steal.steal += current->sched_info.run_delay -\n\t\tvcpu->arch.st.last_steal;\n\tvcpu->arch.st.last_steal = current->sched_info.run_delay;\n\n\tkvm_write_guest_cached(vcpu->kvm, &vcpu->arch.st.stime,\n\t\t&vcpu->arch.st.steal, sizeof(struct kvm_steal_time));\n\n\tsmp_wmb();\n\n\tvcpu->arch.st.steal.version += 1;\n\n\tkvm_write_guest_cached(vcpu->kvm, &vcpu->arch.st.stime,\n\t\t&vcpu->arch.st.steal, sizeof(struct kvm_steal_time));\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_write_guest_cached",
          "args": [
            "vcpu->kvm",
            "&vcpu->arch.st.stime",
            "&vcpu->arch.st.steal",
            "sizeof(struct kvm_steal_time)"
          ],
          "line": 2036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_wmb",
          "args": [],
          "line": 2032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_write_guest_cached",
          "args": [
            "vcpu->kvm",
            "&vcpu->arch.st.stime",
            "&vcpu->arch.st.steal",
            "sizeof(struct kvm_steal_time)"
          ],
          "line": 2029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_wmb",
          "args": [],
          "line": 2023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_write_guest_cached",
          "args": [
            "vcpu->kvm",
            "&vcpu->arch.st.stime",
            "&vcpu->arch.st.steal",
            "sizeof(struct kvm_steal_time)"
          ],
          "line": 2020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "kvm_read_guest_cached(vcpu->kvm, &vcpu->arch.st.stime,\n\t\t&vcpu->arch.st.steal, sizeof(struct kvm_steal_time))"
          ],
          "line": 2011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_read_guest_cached",
          "args": [
            "vcpu->kvm",
            "&vcpu->arch.st.stime",
            "&vcpu->arch.st.steal",
            "sizeof(struct kvm_steal_time)"
          ],
          "line": 2011
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic void record_steal_time(struct kvm_vcpu *vcpu)\n{\n\tif (!(vcpu->arch.st.msr_val & KVM_MSR_ENABLED))\n\t\treturn;\n\n\tif (unlikely(kvm_read_guest_cached(vcpu->kvm, &vcpu->arch.st.stime,\n\t\t&vcpu->arch.st.steal, sizeof(struct kvm_steal_time))))\n\t\treturn;\n\n\tif (vcpu->arch.st.steal.version & 1)\n\t\tvcpu->arch.st.steal.version += 1;  /* first time write, random junk */\n\n\tvcpu->arch.st.steal.version += 1;\n\n\tkvm_write_guest_cached(vcpu->kvm, &vcpu->arch.st.stime,\n\t\t&vcpu->arch.st.steal, sizeof(struct kvm_steal_time));\n\n\tsmp_wmb();\n\n\tvcpu->arch.st.steal.steal += current->sched_info.run_delay -\n\t\tvcpu->arch.st.last_steal;\n\tvcpu->arch.st.last_steal = current->sched_info.run_delay;\n\n\tkvm_write_guest_cached(vcpu->kvm, &vcpu->arch.st.stime,\n\t\t&vcpu->arch.st.steal, sizeof(struct kvm_steal_time));\n\n\tsmp_wmb();\n\n\tvcpu->arch.st.steal.version += 1;\n\n\tkvm_write_guest_cached(vcpu->kvm, &vcpu->arch.st.stime,\n\t\t&vcpu->arch.st.steal, sizeof(struct kvm_steal_time));\n}"
  },
  {
    "function_name": "kvmclock_reset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "2001-2004",
    "snippet": "static void kvmclock_reset(struct kvm_vcpu *vcpu)\n{\n\tvcpu->arch.pv_time_enabled = false;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic void kvmclock_reset(struct kvm_vcpu *vcpu)\n{\n\tvcpu->arch.pv_time_enabled = false;\n}"
  },
  {
    "function_name": "kvm_pv_enable_async_pf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "1976-1999",
    "snippet": "static int kvm_pv_enable_async_pf(struct kvm_vcpu *vcpu, u64 data)\n{\n\tgpa_t gpa = data & ~0x3f;\n\n\t/* Bits 2:5 are reserved, Should be zero */\n\tif (data & 0x3c)\n\t\treturn 1;\n\n\tvcpu->arch.apf.msr_val = data;\n\n\tif (!(data & KVM_ASYNC_PF_ENABLED)) {\n\t\tkvm_clear_async_pf_completion_queue(vcpu);\n\t\tkvm_async_pf_hash_reset(vcpu);\n\t\treturn 0;\n\t}\n\n\tif (kvm_gfn_to_hva_cache_init(vcpu->kvm, &vcpu->arch.apf.data, gpa,\n\t\t\t\t\tsizeof(u32)))\n\t\treturn 1;\n\n\tvcpu->arch.apf.send_user_only = !(data & KVM_ASYNC_PF_SEND_ALWAYS);\n\tkvm_async_pf_wakeup_all(vcpu);\n\treturn 0;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_async_pf_wakeup_all",
          "args": [
            "vcpu"
          ],
          "line": 1997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_gfn_to_hva_cache_init",
          "args": [
            "vcpu->kvm",
            "&vcpu->arch.apf.data",
            "gpa",
            "sizeof(u32)"
          ],
          "line": 1992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_async_pf_hash_reset",
          "args": [
            "vcpu"
          ],
          "line": 1988
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_async_pf_hash_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "193-198",
          "snippet": "static inline void kvm_async_pf_hash_reset(struct kvm_vcpu *vcpu)\n{\n\tint i;\n\tfor (i = 0; i < roundup_pow_of_two(ASYNC_PF_PER_VCPU); i++)\n\t\tvcpu->arch.apf.gfns[i] = ~0;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic inline void kvm_async_pf_hash_reset(struct kvm_vcpu *vcpu)\n{\n\tint i;\n\tfor (i = 0; i < roundup_pow_of_two(ASYNC_PF_PER_VCPU); i++)\n\t\tvcpu->arch.apf.gfns[i] = ~0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_clear_async_pf_completion_queue",
          "args": [
            "vcpu"
          ],
          "line": 1987
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic int kvm_pv_enable_async_pf(struct kvm_vcpu *vcpu, u64 data)\n{\n\tgpa_t gpa = data & ~0x3f;\n\n\t/* Bits 2:5 are reserved, Should be zero */\n\tif (data & 0x3c)\n\t\treturn 1;\n\n\tvcpu->arch.apf.msr_val = data;\n\n\tif (!(data & KVM_ASYNC_PF_ENABLED)) {\n\t\tkvm_clear_async_pf_completion_queue(vcpu);\n\t\tkvm_async_pf_hash_reset(vcpu);\n\t\treturn 0;\n\t}\n\n\tif (kvm_gfn_to_hva_cache_init(vcpu->kvm, &vcpu->arch.apf.data, gpa,\n\t\t\t\t\tsizeof(u32)))\n\t\treturn 1;\n\n\tvcpu->arch.apf.send_user_only = !(data & KVM_ASYNC_PF_SEND_ALWAYS);\n\tkvm_async_pf_wakeup_all(vcpu);\n\treturn 0;\n}"
  },
  {
    "function_name": "xen_hvm_config",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "1945-1974",
    "snippet": "static int xen_hvm_config(struct kvm_vcpu *vcpu, u64 data)\n{\n\tstruct kvm *kvm = vcpu->kvm;\n\tint lm = is_long_mode(vcpu);\n\tu8 *blob_addr = lm ? (u8 *)(long)kvm->arch.xen_hvm_config.blob_addr_64\n\t\t: (u8 *)(long)kvm->arch.xen_hvm_config.blob_addr_32;\n\tu8 blob_size = lm ? kvm->arch.xen_hvm_config.blob_size_64\n\t\t: kvm->arch.xen_hvm_config.blob_size_32;\n\tu32 page_num = data & ~PAGE_MASK;\n\tu64 page_addr = data & PAGE_MASK;\n\tu8 *page;\n\tint r;\n\n\tr = -E2BIG;\n\tif (page_num >= blob_size)\n\t\tgoto out;\n\tr = -ENOMEM;\n\tpage = memdup_user(blob_addr + (page_num * PAGE_SIZE), PAGE_SIZE);\n\tif (IS_ERR(page)) {\n\t\tr = PTR_ERR(page);\n\t\tgoto out;\n\t}\n\tif (kvm_vcpu_write_guest(vcpu, page_addr, page, PAGE_SIZE))\n\t\tgoto out_free;\n\tr = 0;\nout_free:\n\tkfree(page);\nout:\n\treturn r;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "page"
          ],
          "line": 1971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_write_guest",
          "args": [
            "vcpu",
            "page_addr",
            "page",
            "PAGE_SIZE"
          ],
          "line": 1967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "page"
          ],
          "line": 1964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "page"
          ],
          "line": 1963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memdup_user",
          "args": [
            "blob_addr + (page_num * PAGE_SIZE)",
            "PAGE_SIZE"
          ],
          "line": 1962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_long_mode",
          "args": [
            "vcpu"
          ],
          "line": 1948
        },
        "resolved": true,
        "details": {
          "function_name": "is_long_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.h",
          "lines": "43-50",
          "snippet": "static inline int is_long_mode(struct kvm_vcpu *vcpu)\n{\n#ifdef CONFIG_X86_64\n\treturn vcpu->arch.efer & EFER_LMA;\n#else\n\treturn 0;\n#endif\n}",
          "includes": [
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline int is_long_mode(struct kvm_vcpu *vcpu)\n{\n#ifdef CONFIG_X86_64\n\treturn vcpu->arch.efer & EFER_LMA;\n#else\n\treturn 0;\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic int xen_hvm_config(struct kvm_vcpu *vcpu, u64 data)\n{\n\tstruct kvm *kvm = vcpu->kvm;\n\tint lm = is_long_mode(vcpu);\n\tu8 *blob_addr = lm ? (u8 *)(long)kvm->arch.xen_hvm_config.blob_addr_64\n\t\t: (u8 *)(long)kvm->arch.xen_hvm_config.blob_addr_32;\n\tu8 blob_size = lm ? kvm->arch.xen_hvm_config.blob_size_64\n\t\t: kvm->arch.xen_hvm_config.blob_size_32;\n\tu32 page_num = data & ~PAGE_MASK;\n\tu64 page_addr = data & PAGE_MASK;\n\tu8 *page;\n\tint r;\n\n\tr = -E2BIG;\n\tif (page_num >= blob_size)\n\t\tgoto out;\n\tr = -ENOMEM;\n\tpage = memdup_user(blob_addr + (page_num * PAGE_SIZE), PAGE_SIZE);\n\tif (IS_ERR(page)) {\n\t\tr = PTR_ERR(page);\n\t\tgoto out;\n\t}\n\tif (kvm_vcpu_write_guest(vcpu, page_addr, page, PAGE_SIZE))\n\t\tgoto out_free;\n\tr = 0;\nout_free:\n\tkfree(page);\nout:\n\treturn r;\n}"
  },
  {
    "function_name": "set_msr_mce",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "1909-1943",
    "snippet": "static int set_msr_mce(struct kvm_vcpu *vcpu, u32 msr, u64 data)\n{\n\tu64 mcg_cap = vcpu->arch.mcg_cap;\n\tunsigned bank_num = mcg_cap & 0xff;\n\n\tswitch (msr) {\n\tcase MSR_IA32_MCG_STATUS:\n\t\tvcpu->arch.mcg_status = data;\n\t\tbreak;\n\tcase MSR_IA32_MCG_CTL:\n\t\tif (!(mcg_cap & MCG_CTL_P))\n\t\t\treturn 1;\n\t\tif (data != 0 && data != ~(u64)0)\n\t\t\treturn -1;\n\t\tvcpu->arch.mcg_ctl = data;\n\t\tbreak;\n\tdefault:\n\t\tif (msr >= MSR_IA32_MC0_CTL &&\n\t\t    msr < MSR_IA32_MCx_CTL(bank_num)) {\n\t\t\tu32 offset = msr - MSR_IA32_MC0_CTL;\n\t\t\t/* only 0 or all 1s can be written to IA32_MCi_CTL\n\t\t\t * some Linux kernels though clear bit 10 in bank 4 to\n\t\t\t * workaround a BIOS/GART TBL issue on AMD K8s, ignore\n\t\t\t * this to avoid an uncatched #GP in the guest\n\t\t\t */\n\t\t\tif ((offset & 0x3) == 0 &&\n\t\t\t    data != 0 && (data | (1 << 10)) != ~(u64)0)\n\t\t\t\treturn -1;\n\t\t\tvcpu->arch.mce_banks[offset] = data;\n\t\t\tbreak;\n\t\t}\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "MSR_IA32_MCx_CTL",
          "args": [
            "bank_num"
          ],
          "line": 1927
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic int set_msr_mce(struct kvm_vcpu *vcpu, u32 msr, u64 data)\n{\n\tu64 mcg_cap = vcpu->arch.mcg_cap;\n\tunsigned bank_num = mcg_cap & 0xff;\n\n\tswitch (msr) {\n\tcase MSR_IA32_MCG_STATUS:\n\t\tvcpu->arch.mcg_status = data;\n\t\tbreak;\n\tcase MSR_IA32_MCG_CTL:\n\t\tif (!(mcg_cap & MCG_CTL_P))\n\t\t\treturn 1;\n\t\tif (data != 0 && data != ~(u64)0)\n\t\t\treturn -1;\n\t\tvcpu->arch.mcg_ctl = data;\n\t\tbreak;\n\tdefault:\n\t\tif (msr >= MSR_IA32_MC0_CTL &&\n\t\t    msr < MSR_IA32_MCx_CTL(bank_num)) {\n\t\t\tu32 offset = msr - MSR_IA32_MC0_CTL;\n\t\t\t/* only 0 or all 1s can be written to IA32_MCi_CTL\n\t\t\t * some Linux kernels though clear bit 10 in bank 4 to\n\t\t\t * workaround a BIOS/GART TBL issue on AMD K8s, ignore\n\t\t\t * this to avoid an uncatched #GP in the guest\n\t\t\t */\n\t\t\tif ((offset & 0x3) == 0 &&\n\t\t\t    data != 0 && (data | (1 << 10)) != ~(u64)0)\n\t\t\t\treturn -1;\n\t\t\tvcpu->arch.mce_banks[offset] = data;\n\t\t\tbreak;\n\t\t}\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "kvmclock_sync_fn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "1894-1907",
    "snippet": "static void kvmclock_sync_fn(struct work_struct *work)\n{\n\tstruct delayed_work *dwork = to_delayed_work(work);\n\tstruct kvm_arch *ka = container_of(dwork, struct kvm_arch,\n\t\t\t\t\t   kvmclock_sync_work);\n\tstruct kvm *kvm = container_of(ka, struct kvm, arch);\n\n\tif (!kvmclock_periodic_sync)\n\t\treturn;\n\n\tschedule_delayed_work(&kvm->arch.kvmclock_update_work, 0);\n\tschedule_delayed_work(&kvm->arch.kvmclock_sync_work,\n\t\t\t\t\tKVMCLOCK_SYNC_PERIOD);\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define KVMCLOCK_SYNC_PERIOD (300 * HZ)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "schedule_delayed_work",
          "args": [
            "&kvm->arch.kvmclock_sync_work",
            "KVMCLOCK_SYNC_PERIOD"
          ],
          "line": 1905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule_delayed_work",
          "args": [
            "&kvm->arch.kvmclock_update_work",
            "0"
          ],
          "line": 1904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "ka",
            "structkvm",
            "arch"
          ],
          "line": 1899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "dwork",
            "structkvm_arch",
            "kvmclock_sync_work"
          ],
          "line": 1897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_delayed_work",
          "args": [
            "work"
          ],
          "line": 1896
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define KVMCLOCK_SYNC_PERIOD (300 * HZ)\n\nstatic void kvmclock_sync_fn(struct work_struct *work)\n{\n\tstruct delayed_work *dwork = to_delayed_work(work);\n\tstruct kvm_arch *ka = container_of(dwork, struct kvm_arch,\n\t\t\t\t\t   kvmclock_sync_work);\n\tstruct kvm *kvm = container_of(ka, struct kvm, arch);\n\n\tif (!kvmclock_periodic_sync)\n\t\treturn;\n\n\tschedule_delayed_work(&kvm->arch.kvmclock_update_work, 0);\n\tschedule_delayed_work(&kvm->arch.kvmclock_sync_work,\n\t\t\t\t\tKVMCLOCK_SYNC_PERIOD);\n}"
  },
  {
    "function_name": "kvm_gen_kvmclock_update",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "1883-1890",
    "snippet": "static void kvm_gen_kvmclock_update(struct kvm_vcpu *v)\n{\n\tstruct kvm *kvm = v->kvm;\n\n\tkvm_make_request(KVM_REQ_CLOCK_UPDATE, v);\n\tschedule_delayed_work(&kvm->arch.kvmclock_update_work,\n\t\t\t\t\tKVMCLOCK_UPDATE_DELAY);\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define KVMCLOCK_UPDATE_DELAY msecs_to_jiffies(100)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "schedule_delayed_work",
          "args": [
            "&kvm->arch.kvmclock_update_work",
            "KVMCLOCK_UPDATE_DELAY"
          ],
          "line": 1888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_make_request",
          "args": [
            "KVM_REQ_CLOCK_UPDATE",
            "v"
          ],
          "line": 1887
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define KVMCLOCK_UPDATE_DELAY msecs_to_jiffies(100)\n\nstatic void kvm_gen_kvmclock_update(struct kvm_vcpu *v)\n{\n\tstruct kvm *kvm = v->kvm;\n\n\tkvm_make_request(KVM_REQ_CLOCK_UPDATE, v);\n\tschedule_delayed_work(&kvm->arch.kvmclock_update_work,\n\t\t\t\t\tKVMCLOCK_UPDATE_DELAY);\n}"
  },
  {
    "function_name": "kvmclock_update_fn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "1868-1881",
    "snippet": "static void kvmclock_update_fn(struct work_struct *work)\n{\n\tint i;\n\tstruct delayed_work *dwork = to_delayed_work(work);\n\tstruct kvm_arch *ka = container_of(dwork, struct kvm_arch,\n\t\t\t\t\t   kvmclock_update_work);\n\tstruct kvm *kvm = container_of(ka, struct kvm, arch);\n\tstruct kvm_vcpu *vcpu;\n\n\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\tkvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);\n\t\tkvm_vcpu_kick(vcpu);\n\t}\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_vcpu_kick",
          "args": [
            "vcpu"
          ],
          "line": 1879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_make_request",
          "args": [
            "KVM_REQ_CLOCK_UPDATE",
            "vcpu"
          ],
          "line": 1878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_for_each_vcpu",
          "args": [
            "i",
            "vcpu",
            "kvm"
          ],
          "line": 1877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "ka",
            "structkvm",
            "arch"
          ],
          "line": 1874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "dwork",
            "structkvm_arch",
            "kvmclock_update_work"
          ],
          "line": 1872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_delayed_work",
          "args": [
            "work"
          ],
          "line": 1871
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic void kvmclock_update_fn(struct work_struct *work)\n{\n\tint i;\n\tstruct delayed_work *dwork = to_delayed_work(work);\n\tstruct kvm_arch *ka = container_of(dwork, struct kvm_arch,\n\t\t\t\t\t   kvmclock_update_work);\n\tstruct kvm *kvm = container_of(ka, struct kvm, arch);\n\tstruct kvm_vcpu *vcpu;\n\n\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\tkvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);\n\t\tkvm_vcpu_kick(vcpu);\n\t}\n}"
  },
  {
    "function_name": "kvm_guest_time_update",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "1717-1850",
    "snippet": "static int kvm_guest_time_update(struct kvm_vcpu *v)\n{\n\tunsigned long flags, tgt_tsc_khz;\n\tstruct kvm_vcpu_arch *vcpu = &v->arch;\n\tstruct kvm_arch *ka = &v->kvm->arch;\n\ts64 kernel_ns;\n\tu64 tsc_timestamp, host_tsc;\n\tstruct pvclock_vcpu_time_info guest_hv_clock;\n\tu8 pvclock_flags;\n\tbool use_master_clock;\n\n\tkernel_ns = 0;\n\thost_tsc = 0;\n\n\t/*\n\t * If the host uses TSC clock, then passthrough TSC as stable\n\t * to the guest.\n\t */\n\tspin_lock(&ka->pvclock_gtod_sync_lock);\n\tuse_master_clock = ka->use_master_clock;\n\tif (use_master_clock) {\n\t\thost_tsc = ka->master_cycle_now;\n\t\tkernel_ns = ka->master_kernel_ns;\n\t}\n\tspin_unlock(&ka->pvclock_gtod_sync_lock);\n\n\t/* Keep irq disabled to prevent changes to the clock */\n\tlocal_irq_save(flags);\n\ttgt_tsc_khz = __this_cpu_read(cpu_tsc_khz);\n\tif (unlikely(tgt_tsc_khz == 0)) {\n\t\tlocal_irq_restore(flags);\n\t\tkvm_make_request(KVM_REQ_CLOCK_UPDATE, v);\n\t\treturn 1;\n\t}\n\tif (!use_master_clock) {\n\t\thost_tsc = rdtsc();\n\t\tkernel_ns = get_kernel_ns();\n\t}\n\n\ttsc_timestamp = kvm_read_l1_tsc(v, host_tsc);\n\n\t/*\n\t * We may have to catch up the TSC to match elapsed wall clock\n\t * time for two reasons, even if kvmclock is used.\n\t *   1) CPU could have been running below the maximum TSC rate\n\t *   2) Broken TSC compensation resets the base at each VCPU\n\t *      entry to avoid unknown leaps of TSC even when running\n\t *      again on the same CPU.  This may cause apparent elapsed\n\t *      time to disappear, and the guest to stand still or run\n\t *\tvery slowly.\n\t */\n\tif (vcpu->tsc_catchup) {\n\t\tu64 tsc = compute_guest_tsc(v, kernel_ns);\n\t\tif (tsc > tsc_timestamp) {\n\t\t\tadjust_tsc_offset_guest(v, tsc - tsc_timestamp);\n\t\t\ttsc_timestamp = tsc;\n\t\t}\n\t}\n\n\tlocal_irq_restore(flags);\n\n\tif (!vcpu->pv_time_enabled)\n\t\treturn 0;\n\n\tif (kvm_has_tsc_control)\n\t\ttgt_tsc_khz = kvm_scale_tsc(v, tgt_tsc_khz);\n\n\tif (unlikely(vcpu->hw_tsc_khz != tgt_tsc_khz)) {\n\t\tkvm_get_time_scale(NSEC_PER_SEC, tgt_tsc_khz * 1000LL,\n\t\t\t\t   &vcpu->hv_clock.tsc_shift,\n\t\t\t\t   &vcpu->hv_clock.tsc_to_system_mul);\n\t\tvcpu->hw_tsc_khz = tgt_tsc_khz;\n\t}\n\n\t/* With all the info we got, fill in the values */\n\tvcpu->hv_clock.tsc_timestamp = tsc_timestamp;\n\tvcpu->hv_clock.system_time = kernel_ns + v->kvm->arch.kvmclock_offset;\n\tvcpu->last_guest_tsc = tsc_timestamp;\n\n\tif (unlikely(kvm_read_guest_cached(v->kvm, &vcpu->pv_time,\n\t\t&guest_hv_clock, sizeof(guest_hv_clock))))\n\t\treturn 0;\n\n\t/* This VCPU is paused, but it's legal for a guest to read another\n\t * VCPU's kvmclock, so we really have to follow the specification where\n\t * it says that version is odd if data is being modified, and even after\n\t * it is consistent.\n\t *\n\t * Version field updates must be kept separate.  This is because\n\t * kvm_write_guest_cached might use a \"rep movs\" instruction, and\n\t * writes within a string instruction are weakly ordered.  So there\n\t * are three writes overall.\n\t *\n\t * As a small optimization, only write the version field in the first\n\t * and third write.  The vcpu->pv_time cache is still valid, because the\n\t * version field is the first in the struct.\n\t */\n\tBUILD_BUG_ON(offsetof(struct pvclock_vcpu_time_info, version) != 0);\n\n\tvcpu->hv_clock.version = guest_hv_clock.version + 1;\n\tkvm_write_guest_cached(v->kvm, &vcpu->pv_time,\n\t\t\t\t&vcpu->hv_clock,\n\t\t\t\tsizeof(vcpu->hv_clock.version));\n\n\tsmp_wmb();\n\n\t/* retain PVCLOCK_GUEST_STOPPED if set in guest copy */\n\tpvclock_flags = (guest_hv_clock.flags & PVCLOCK_GUEST_STOPPED);\n\n\tif (vcpu->pvclock_set_guest_stopped_request) {\n\t\tpvclock_flags |= PVCLOCK_GUEST_STOPPED;\n\t\tvcpu->pvclock_set_guest_stopped_request = false;\n\t}\n\n\t/* If the host uses TSC clocksource, then it is stable */\n\tif (use_master_clock)\n\t\tpvclock_flags |= PVCLOCK_TSC_STABLE_BIT;\n\n\tvcpu->hv_clock.flags = pvclock_flags;\n\n\ttrace_kvm_pvclock_update(v->vcpu_id, &vcpu->hv_clock);\n\n\tkvm_write_guest_cached(v->kvm, &vcpu->pv_time,\n\t\t\t\t&vcpu->hv_clock,\n\t\t\t\tsizeof(vcpu->hv_clock));\n\n\tsmp_wmb();\n\n\tvcpu->hv_clock.version++;\n\tkvm_write_guest_cached(v->kvm, &vcpu->pv_time,\n\t\t\t\t&vcpu->hv_clock,\n\t\t\t\tsizeof(vcpu->hv_clock.version));\n\treturn 0;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);",
      "static DEFINE_PER_CPU(unsigned long, cpu_tsc_khz);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_write_guest_cached",
          "args": [
            "v->kvm",
            "&vcpu->pv_time",
            "&vcpu->hv_clock",
            "sizeof(vcpu->hv_clock.version)"
          ],
          "line": 1846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_wmb",
          "args": [],
          "line": 1843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_write_guest_cached",
          "args": [
            "v->kvm",
            "&vcpu->pv_time",
            "&vcpu->hv_clock",
            "sizeof(vcpu->hv_clock)"
          ],
          "line": 1839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_kvm_pvclock_update",
          "args": [
            "v->vcpu_id",
            "&vcpu->hv_clock"
          ],
          "line": 1837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_wmb",
          "args": [],
          "line": 1821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_write_guest_cached",
          "args": [
            "v->kvm",
            "&vcpu->pv_time",
            "&vcpu->hv_clock",
            "sizeof(vcpu->hv_clock.version)"
          ],
          "line": 1817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "offsetof(struct pvclock_vcpu_time_info, version) != 0"
          ],
          "line": 1814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "kvm_read_guest_cached(v->kvm, &vcpu->pv_time,\n\t\t&guest_hv_clock, sizeof(guest_hv_clock))"
          ],
          "line": 1796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_read_guest_cached",
          "args": [
            "v->kvm",
            "&vcpu->pv_time",
            "&guest_hv_clock",
            "sizeof(guest_hv_clock)"
          ],
          "line": 1796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_get_time_scale",
          "args": [
            "NSEC_PER_SEC",
            "tgt_tsc_khz * 1000LL",
            "&vcpu->hv_clock.tsc_shift",
            "&vcpu->hv_clock.tsc_to_system_mul"
          ],
          "line": 1785
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_get_time_scale",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "1209-1238",
          "snippet": "static void kvm_get_time_scale(uint64_t scaled_hz, uint64_t base_hz,\n\t\t\t       s8 *pshift, u32 *pmultiplier)\n{\n\tuint64_t scaled64;\n\tint32_t  shift = 0;\n\tuint64_t tps64;\n\tuint32_t tps32;\n\n\ttps64 = base_hz;\n\tscaled64 = scaled_hz;\n\twhile (tps64 > scaled64*2 || tps64 & 0xffffffff00000000ULL) {\n\t\ttps64 >>= 1;\n\t\tshift--;\n\t}\n\n\ttps32 = (uint32_t)tps64;\n\twhile (tps32 <= scaled64 || scaled64 & 0xffffffff00000000ULL) {\n\t\tif (scaled64 & 0xffffffff00000000ULL || tps32 & 0x80000000)\n\t\t\tscaled64 >>= 1;\n\t\telse\n\t\t\ttps32 <<= 1;\n\t\tshift++;\n\t}\n\n\t*pshift = shift;\n\t*pmultiplier = div_frac(scaled64, tps32);\n\n\tpr_debug(\"%s: base_hz %llu => %llu, shift %d, mul %u\\n\",\n\t\t __func__, base_hz, scaled_hz, shift, *pmultiplier);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void kvm_get_time_scale(uint64_t scaled_hz, uint64_t base_hz,\n\t\t\t       s8 *pshift, u32 *pmultiplier)\n{\n\tuint64_t scaled64;\n\tint32_t  shift = 0;\n\tuint64_t tps64;\n\tuint32_t tps32;\n\n\ttps64 = base_hz;\n\tscaled64 = scaled_hz;\n\twhile (tps64 > scaled64*2 || tps64 & 0xffffffff00000000ULL) {\n\t\ttps64 >>= 1;\n\t\tshift--;\n\t}\n\n\ttps32 = (uint32_t)tps64;\n\twhile (tps32 <= scaled64 || scaled64 & 0xffffffff00000000ULL) {\n\t\tif (scaled64 & 0xffffffff00000000ULL || tps32 & 0x80000000)\n\t\t\tscaled64 >>= 1;\n\t\telse\n\t\t\ttps32 <<= 1;\n\t\tshift++;\n\t}\n\n\t*pshift = shift;\n\t*pmultiplier = div_frac(scaled64, tps32);\n\n\tpr_debug(\"%s: base_hz %llu => %llu, shift %d, mul %u\\n\",\n\t\t __func__, base_hz, scaled_hz, shift, *pmultiplier);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "vcpu->hw_tsc_khz != tgt_tsc_khz"
          ],
          "line": 1784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_scale_tsc",
          "args": [
            "v",
            "tgt_tsc_khz"
          ],
          "line": 1782
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_scale_tsc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "1387-1396",
          "snippet": "u64 kvm_scale_tsc(struct kvm_vcpu *vcpu, u64 tsc)\n{\n\tu64 _tsc = tsc;\n\tu64 ratio = vcpu->arch.tsc_scaling_ratio;\n\n\tif (ratio != kvm_default_tsc_scaling_ratio)\n\t\t_tsc = __scale_tsc(ratio, tsc);\n\n\treturn _tsc;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nu64 kvm_scale_tsc(struct kvm_vcpu *vcpu, u64 tsc)\n{\n\tu64 _tsc = tsc;\n\tu64 ratio = vcpu->arch.tsc_scaling_ratio;\n\n\tif (ratio != kvm_default_tsc_scaling_ratio)\n\t\t_tsc = __scale_tsc(ratio, tsc);\n\n\treturn _tsc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 1776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "adjust_tsc_offset_guest",
          "args": [
            "v",
            "tsc - tsc_timestamp"
          ],
          "line": 1771
        },
        "resolved": true,
        "details": {
          "function_name": "adjust_tsc_offset_guest",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "1539-1543",
          "snippet": "static inline void adjust_tsc_offset_guest(struct kvm_vcpu *vcpu,\n\t\t\t\t\t   s64 adjustment)\n{\n\tkvm_x86_ops->adjust_tsc_offset_guest(vcpu, adjustment);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "struct kvm_x86_ops *kvm_x86_ops"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nstatic inline void adjust_tsc_offset_guest(struct kvm_vcpu *vcpu,\n\t\t\t\t\t   s64 adjustment)\n{\n\tkvm_x86_ops->adjust_tsc_offset_guest(vcpu, adjustment);\n}"
        }
      },
      {
        "call_info": {
          "callee": "compute_guest_tsc",
          "args": [
            "v",
            "kernel_ns"
          ],
          "line": 1769
        },
        "resolved": true,
        "details": {
          "function_name": "compute_guest_tsc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "1329-1336",
          "snippet": "static u64 compute_guest_tsc(struct kvm_vcpu *vcpu, s64 kernel_ns)\n{\n\tu64 tsc = pvclock_scale_delta(kernel_ns-vcpu->arch.this_tsc_nsec,\n\t\t\t\t      vcpu->arch.virtual_tsc_mult,\n\t\t\t\t      vcpu->arch.virtual_tsc_shift);\n\ttsc += vcpu->arch.this_tsc_write;\n\treturn tsc;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic u64 compute_guest_tsc(struct kvm_vcpu *vcpu, s64 kernel_ns)\n{\n\tu64 tsc = pvclock_scale_delta(kernel_ns-vcpu->arch.this_tsc_nsec,\n\t\t\t\t      vcpu->arch.virtual_tsc_mult,\n\t\t\t\t      vcpu->arch.virtual_tsc_shift);\n\ttsc += vcpu->arch.this_tsc_write;\n\treturn tsc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_read_l1_tsc",
          "args": [
            "v",
            "host_tsc"
          ],
          "line": 1756
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_read_l1_tsc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "1408-1411",
          "snippet": "u64 kvm_read_l1_tsc(struct kvm_vcpu *vcpu, u64 host_tsc)\n{\n\treturn kvm_x86_ops->read_l1_tsc(vcpu, kvm_scale_tsc(vcpu, host_tsc));\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "struct kvm_x86_ops *kvm_x86_ops"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nu64 kvm_read_l1_tsc(struct kvm_vcpu *vcpu, u64 host_tsc)\n{\n\treturn kvm_x86_ops->read_l1_tsc(vcpu, kvm_scale_tsc(vcpu, host_tsc));\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_kernel_ns",
          "args": [],
          "line": 1753
        },
        "resolved": true,
        "details": {
          "function_name": "get_kernel_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.h",
          "lines": "150-153",
          "snippet": "static inline u64 get_kernel_ns(void)\n{\n\treturn ktime_get_boot_ns();\n}",
          "includes": [
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline u64 get_kernel_ns(void)\n{\n\treturn ktime_get_boot_ns();\n}"
        }
      },
      {
        "call_info": {
          "callee": "rdtsc",
          "args": [],
          "line": 1752
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_rdtscp_supported",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/vmx.c",
          "lines": "2393-2396",
          "snippet": "static bool vmx_rdtscp_supported(void)\n{\n\treturn cpu_has_vmx_rdtscp();\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"trace.h\"",
            "#include <asm/irq_remapping.h>",
            "#include <asm/apic.h>",
            "#include <asm/kexec.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/mce.h>",
            "#include <asm/virtext.h>",
            "#include <asm/vmx.h>",
            "#include <asm/desc.h>",
            "#include <asm/io.h>",
            "#include <asm/cpu.h>",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/hrtimer.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include \"lapic.h\"",
            "#include \"cpuid.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"trace.h\"\n#include <asm/irq_remapping.h>\n#include <asm/apic.h>\n#include <asm/kexec.h>\n#include <asm/debugreg.h>\n#include <asm/perf_event.h>\n#include <asm/fpu/internal.h>\n#include <asm/mce.h>\n#include <asm/virtext.h>\n#include <asm/vmx.h>\n#include <asm/desc.h>\n#include <asm/io.h>\n#include <asm/cpu.h>\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/hrtimer.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic bool vmx_rdtscp_supported(void)\n{\n\treturn cpu_has_vmx_rdtscp();\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_make_request",
          "args": [
            "KVM_REQ_CLOCK_UPDATE",
            "v"
          ],
          "line": 1748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 1747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "tgt_tsc_khz == 0"
          ],
          "line": 1746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_read",
          "args": [
            "cpu_tsc_khz"
          ],
          "line": 1745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 1744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ka->pvclock_gtod_sync_lock"
          ],
          "line": 1741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ka->pvclock_gtod_sync_lock"
          ],
          "line": 1735
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic DEFINE_PER_CPU(unsigned long, cpu_tsc_khz);\n\nstatic int kvm_guest_time_update(struct kvm_vcpu *v)\n{\n\tunsigned long flags, tgt_tsc_khz;\n\tstruct kvm_vcpu_arch *vcpu = &v->arch;\n\tstruct kvm_arch *ka = &v->kvm->arch;\n\ts64 kernel_ns;\n\tu64 tsc_timestamp, host_tsc;\n\tstruct pvclock_vcpu_time_info guest_hv_clock;\n\tu8 pvclock_flags;\n\tbool use_master_clock;\n\n\tkernel_ns = 0;\n\thost_tsc = 0;\n\n\t/*\n\t * If the host uses TSC clock, then passthrough TSC as stable\n\t * to the guest.\n\t */\n\tspin_lock(&ka->pvclock_gtod_sync_lock);\n\tuse_master_clock = ka->use_master_clock;\n\tif (use_master_clock) {\n\t\thost_tsc = ka->master_cycle_now;\n\t\tkernel_ns = ka->master_kernel_ns;\n\t}\n\tspin_unlock(&ka->pvclock_gtod_sync_lock);\n\n\t/* Keep irq disabled to prevent changes to the clock */\n\tlocal_irq_save(flags);\n\ttgt_tsc_khz = __this_cpu_read(cpu_tsc_khz);\n\tif (unlikely(tgt_tsc_khz == 0)) {\n\t\tlocal_irq_restore(flags);\n\t\tkvm_make_request(KVM_REQ_CLOCK_UPDATE, v);\n\t\treturn 1;\n\t}\n\tif (!use_master_clock) {\n\t\thost_tsc = rdtsc();\n\t\tkernel_ns = get_kernel_ns();\n\t}\n\n\ttsc_timestamp = kvm_read_l1_tsc(v, host_tsc);\n\n\t/*\n\t * We may have to catch up the TSC to match elapsed wall clock\n\t * time for two reasons, even if kvmclock is used.\n\t *   1) CPU could have been running below the maximum TSC rate\n\t *   2) Broken TSC compensation resets the base at each VCPU\n\t *      entry to avoid unknown leaps of TSC even when running\n\t *      again on the same CPU.  This may cause apparent elapsed\n\t *      time to disappear, and the guest to stand still or run\n\t *\tvery slowly.\n\t */\n\tif (vcpu->tsc_catchup) {\n\t\tu64 tsc = compute_guest_tsc(v, kernel_ns);\n\t\tif (tsc > tsc_timestamp) {\n\t\t\tadjust_tsc_offset_guest(v, tsc - tsc_timestamp);\n\t\t\ttsc_timestamp = tsc;\n\t\t}\n\t}\n\n\tlocal_irq_restore(flags);\n\n\tif (!vcpu->pv_time_enabled)\n\t\treturn 0;\n\n\tif (kvm_has_tsc_control)\n\t\ttgt_tsc_khz = kvm_scale_tsc(v, tgt_tsc_khz);\n\n\tif (unlikely(vcpu->hw_tsc_khz != tgt_tsc_khz)) {\n\t\tkvm_get_time_scale(NSEC_PER_SEC, tgt_tsc_khz * 1000LL,\n\t\t\t\t   &vcpu->hv_clock.tsc_shift,\n\t\t\t\t   &vcpu->hv_clock.tsc_to_system_mul);\n\t\tvcpu->hw_tsc_khz = tgt_tsc_khz;\n\t}\n\n\t/* With all the info we got, fill in the values */\n\tvcpu->hv_clock.tsc_timestamp = tsc_timestamp;\n\tvcpu->hv_clock.system_time = kernel_ns + v->kvm->arch.kvmclock_offset;\n\tvcpu->last_guest_tsc = tsc_timestamp;\n\n\tif (unlikely(kvm_read_guest_cached(v->kvm, &vcpu->pv_time,\n\t\t&guest_hv_clock, sizeof(guest_hv_clock))))\n\t\treturn 0;\n\n\t/* This VCPU is paused, but it's legal for a guest to read another\n\t * VCPU's kvmclock, so we really have to follow the specification where\n\t * it says that version is odd if data is being modified, and even after\n\t * it is consistent.\n\t *\n\t * Version field updates must be kept separate.  This is because\n\t * kvm_write_guest_cached might use a \"rep movs\" instruction, and\n\t * writes within a string instruction are weakly ordered.  So there\n\t * are three writes overall.\n\t *\n\t * As a small optimization, only write the version field in the first\n\t * and third write.  The vcpu->pv_time cache is still valid, because the\n\t * version field is the first in the struct.\n\t */\n\tBUILD_BUG_ON(offsetof(struct pvclock_vcpu_time_info, version) != 0);\n\n\tvcpu->hv_clock.version = guest_hv_clock.version + 1;\n\tkvm_write_guest_cached(v->kvm, &vcpu->pv_time,\n\t\t\t\t&vcpu->hv_clock,\n\t\t\t\tsizeof(vcpu->hv_clock.version));\n\n\tsmp_wmb();\n\n\t/* retain PVCLOCK_GUEST_STOPPED if set in guest copy */\n\tpvclock_flags = (guest_hv_clock.flags & PVCLOCK_GUEST_STOPPED);\n\n\tif (vcpu->pvclock_set_guest_stopped_request) {\n\t\tpvclock_flags |= PVCLOCK_GUEST_STOPPED;\n\t\tvcpu->pvclock_set_guest_stopped_request = false;\n\t}\n\n\t/* If the host uses TSC clocksource, then it is stable */\n\tif (use_master_clock)\n\t\tpvclock_flags |= PVCLOCK_TSC_STABLE_BIT;\n\n\tvcpu->hv_clock.flags = pvclock_flags;\n\n\ttrace_kvm_pvclock_update(v->vcpu_id, &vcpu->hv_clock);\n\n\tkvm_write_guest_cached(v->kvm, &vcpu->pv_time,\n\t\t\t\t&vcpu->hv_clock,\n\t\t\t\tsizeof(vcpu->hv_clock));\n\n\tsmp_wmb();\n\n\tvcpu->hv_clock.version++;\n\tkvm_write_guest_cached(v->kvm, &vcpu->pv_time,\n\t\t\t\t&vcpu->hv_clock,\n\t\t\t\tsizeof(vcpu->hv_clock.version));\n\treturn 0;\n}"
  },
  {
    "function_name": "kvm_gen_update_masterclock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "1694-1715",
    "snippet": "static void kvm_gen_update_masterclock(struct kvm *kvm)\n{\n#ifdef CONFIG_X86_64\n\tint i;\n\tstruct kvm_vcpu *vcpu;\n\tstruct kvm_arch *ka = &kvm->arch;\n\n\tspin_lock(&ka->pvclock_gtod_sync_lock);\n\tkvm_make_mclock_inprogress_request(kvm);\n\t/* no guest entries from this point */\n\tpvclock_update_vm_gtod_copy(kvm);\n\n\tkvm_for_each_vcpu(i, vcpu, kvm)\n\t\tkvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);\n\n\t/* guest entries allowed */\n\tkvm_for_each_vcpu(i, vcpu, kvm)\n\t\tclear_bit(KVM_REQ_MCLOCK_INPROGRESS, &vcpu->requests);\n\n\tspin_unlock(&ka->pvclock_gtod_sync_lock);\n#endif\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ka->pvclock_gtod_sync_lock"
          ],
          "line": 1713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "KVM_REQ_MCLOCK_INPROGRESS",
            "&vcpu->requests"
          ],
          "line": 1711
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_clear_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/vmx.c",
          "lines": "1592-1597",
          "snippet": "static __always_inline void vmcs_clear_bits(unsigned long field, u32 mask)\n{\n        BUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x2000,\n\t\t\t \"vmcs_clear_bits does not support 64-bit fields\");\n\t__vmcs_writel(field, __vmcs_readl(field) & ~mask);\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"trace.h\"",
            "#include <asm/irq_remapping.h>",
            "#include <asm/apic.h>",
            "#include <asm/kexec.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/mce.h>",
            "#include <asm/virtext.h>",
            "#include <asm/vmx.h>",
            "#include <asm/desc.h>",
            "#include <asm/io.h>",
            "#include <asm/cpu.h>",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/hrtimer.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include \"lapic.h\"",
            "#include \"cpuid.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"trace.h\"\n#include <asm/irq_remapping.h>\n#include <asm/apic.h>\n#include <asm/kexec.h>\n#include <asm/debugreg.h>\n#include <asm/perf_event.h>\n#include <asm/fpu/internal.h>\n#include <asm/mce.h>\n#include <asm/virtext.h>\n#include <asm/vmx.h>\n#include <asm/desc.h>\n#include <asm/io.h>\n#include <asm/cpu.h>\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/hrtimer.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic __always_inline void vmcs_clear_bits(unsigned long field, u32 mask)\n{\n        BUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x2000,\n\t\t\t \"vmcs_clear_bits does not support 64-bit fields\");\n\t__vmcs_writel(field, __vmcs_readl(field) & ~mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_for_each_vcpu",
          "args": [
            "i",
            "vcpu",
            "kvm"
          ],
          "line": 1710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_make_request",
          "args": [
            "KVM_REQ_CLOCK_UPDATE",
            "vcpu"
          ],
          "line": 1707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_for_each_vcpu",
          "args": [
            "i",
            "vcpu",
            "kvm"
          ],
          "line": 1706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pvclock_update_vm_gtod_copy",
          "args": [
            "kvm"
          ],
          "line": 1704
        },
        "resolved": true,
        "details": {
          "function_name": "pvclock_update_vm_gtod_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "1658-1687",
          "snippet": "static void pvclock_update_vm_gtod_copy(struct kvm *kvm)\n{\n#ifdef CONFIG_X86_64\n\tstruct kvm_arch *ka = &kvm->arch;\n\tint vclock_mode;\n\tbool host_tsc_clocksource, vcpus_matched;\n\n\tvcpus_matched = (ka->nr_vcpus_matched_tsc + 1 ==\n\t\t\tatomic_read(&kvm->online_vcpus));\n\n\t/*\n\t * If the host uses TSC clock, then passthrough TSC as stable\n\t * to the guest.\n\t */\n\thost_tsc_clocksource = kvm_get_time_and_clockread(\n\t\t\t\t\t&ka->master_kernel_ns,\n\t\t\t\t\t&ka->master_cycle_now);\n\n\tka->use_master_clock = host_tsc_clocksource && vcpus_matched\n\t\t\t\t&& !backwards_tsc_observed\n\t\t\t\t&& !ka->boot_vcpu_runs_old_kvmclock;\n\n\tif (ka->use_master_clock)\n\t\tatomic_set(&kvm_guest_has_master_clock, 1);\n\n\tvclock_mode = pvclock_gtod_data.clock.vclock_mode;\n\ttrace_kvm_update_master_clock(ka->use_master_clock, vclock_mode,\n\t\t\t\t\tvcpus_matched);\n#endif\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void pvclock_update_vm_gtod_copy(struct kvm *kvm)\n{\n#ifdef CONFIG_X86_64\n\tstruct kvm_arch *ka = &kvm->arch;\n\tint vclock_mode;\n\tbool host_tsc_clocksource, vcpus_matched;\n\n\tvcpus_matched = (ka->nr_vcpus_matched_tsc + 1 ==\n\t\t\tatomic_read(&kvm->online_vcpus));\n\n\t/*\n\t * If the host uses TSC clock, then passthrough TSC as stable\n\t * to the guest.\n\t */\n\thost_tsc_clocksource = kvm_get_time_and_clockread(\n\t\t\t\t\t&ka->master_kernel_ns,\n\t\t\t\t\t&ka->master_cycle_now);\n\n\tka->use_master_clock = host_tsc_clocksource && vcpus_matched\n\t\t\t\t&& !backwards_tsc_observed\n\t\t\t\t&& !ka->boot_vcpu_runs_old_kvmclock;\n\n\tif (ka->use_master_clock)\n\t\tatomic_set(&kvm_guest_has_master_clock, 1);\n\n\tvclock_mode = pvclock_gtod_data.clock.vclock_mode;\n\ttrace_kvm_update_master_clock(ka->use_master_clock, vclock_mode,\n\t\t\t\t\tvcpus_matched);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_make_mclock_inprogress_request",
          "args": [
            "kvm"
          ],
          "line": 1702
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_make_mclock_inprogress_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "1689-1692",
          "snippet": "void kvm_make_mclock_inprogress_request(struct kvm *kvm)\n{\n\tkvm_make_all_cpus_request(kvm, KVM_REQ_MCLOCK_INPROGRESS);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nvoid kvm_make_mclock_inprogress_request(struct kvm *kvm)\n{\n\tkvm_make_all_cpus_request(kvm, KVM_REQ_MCLOCK_INPROGRESS);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ka->pvclock_gtod_sync_lock"
          ],
          "line": 1701
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic void kvm_gen_update_masterclock(struct kvm *kvm)\n{\n#ifdef CONFIG_X86_64\n\tint i;\n\tstruct kvm_vcpu *vcpu;\n\tstruct kvm_arch *ka = &kvm->arch;\n\n\tspin_lock(&ka->pvclock_gtod_sync_lock);\n\tkvm_make_mclock_inprogress_request(kvm);\n\t/* no guest entries from this point */\n\tpvclock_update_vm_gtod_copy(kvm);\n\n\tkvm_for_each_vcpu(i, vcpu, kvm)\n\t\tkvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);\n\n\t/* guest entries allowed */\n\tkvm_for_each_vcpu(i, vcpu, kvm)\n\t\tclear_bit(KVM_REQ_MCLOCK_INPROGRESS, &vcpu->requests);\n\n\tspin_unlock(&ka->pvclock_gtod_sync_lock);\n#endif\n}"
  },
  {
    "function_name": "kvm_make_mclock_inprogress_request",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "1689-1692",
    "snippet": "void kvm_make_mclock_inprogress_request(struct kvm *kvm)\n{\n\tkvm_make_all_cpus_request(kvm, KVM_REQ_MCLOCK_INPROGRESS);\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_make_all_cpus_request",
          "args": [
            "kvm",
            "KVM_REQ_MCLOCK_INPROGRESS"
          ],
          "line": 1691
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nvoid kvm_make_mclock_inprogress_request(struct kvm *kvm)\n{\n\tkvm_make_all_cpus_request(kvm, KVM_REQ_MCLOCK_INPROGRESS);\n}"
  },
  {
    "function_name": "pvclock_update_vm_gtod_copy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "1658-1687",
    "snippet": "static void pvclock_update_vm_gtod_copy(struct kvm *kvm)\n{\n#ifdef CONFIG_X86_64\n\tstruct kvm_arch *ka = &kvm->arch;\n\tint vclock_mode;\n\tbool host_tsc_clocksource, vcpus_matched;\n\n\tvcpus_matched = (ka->nr_vcpus_matched_tsc + 1 ==\n\t\t\tatomic_read(&kvm->online_vcpus));\n\n\t/*\n\t * If the host uses TSC clock, then passthrough TSC as stable\n\t * to the guest.\n\t */\n\thost_tsc_clocksource = kvm_get_time_and_clockread(\n\t\t\t\t\t&ka->master_kernel_ns,\n\t\t\t\t\t&ka->master_cycle_now);\n\n\tka->use_master_clock = host_tsc_clocksource && vcpus_matched\n\t\t\t\t&& !backwards_tsc_observed\n\t\t\t\t&& !ka->boot_vcpu_runs_old_kvmclock;\n\n\tif (ka->use_master_clock)\n\t\tatomic_set(&kvm_guest_has_master_clock, 1);\n\n\tvclock_mode = pvclock_gtod_data.clock.vclock_mode;\n\ttrace_kvm_update_master_clock(ka->use_master_clock, vclock_mode,\n\t\t\t\t\tvcpus_matched);\n#endif\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_kvm_update_master_clock",
          "args": [
            "ka->use_master_clock",
            "vclock_mode",
            "vcpus_matched"
          ],
          "line": 1684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&kvm_guest_has_master_clock",
            "1"
          ],
          "line": 1681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_get_time_and_clockread",
          "args": [
            "&ka->master_kernel_ns",
            "&ka->master_cycle_now"
          ],
          "line": 1672
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_get_time_and_clockread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "1607-1614",
          "snippet": "static bool kvm_get_time_and_clockread(s64 *kernel_ns, cycle_t *cycle_now)\n{\n\t/* checked again under seqlock below */\n\tif (pvclock_gtod_data.clock.vclock_mode != VCLOCK_TSC)\n\t\treturn false;\n\n\treturn do_monotonic_boot(kernel_ns, cycle_now) == VCLOCK_TSC;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic bool kvm_get_time_and_clockread(s64 *kernel_ns, cycle_t *cycle_now)\n{\n\t/* checked again under seqlock below */\n\tif (pvclock_gtod_data.clock.vclock_mode != VCLOCK_TSC)\n\t\treturn false;\n\n\treturn do_monotonic_boot(kernel_ns, cycle_now) == VCLOCK_TSC;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&kvm->online_vcpus"
          ],
          "line": 1666
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void pvclock_update_vm_gtod_copy(struct kvm *kvm)\n{\n#ifdef CONFIG_X86_64\n\tstruct kvm_arch *ka = &kvm->arch;\n\tint vclock_mode;\n\tbool host_tsc_clocksource, vcpus_matched;\n\n\tvcpus_matched = (ka->nr_vcpus_matched_tsc + 1 ==\n\t\t\tatomic_read(&kvm->online_vcpus));\n\n\t/*\n\t * If the host uses TSC clock, then passthrough TSC as stable\n\t * to the guest.\n\t */\n\thost_tsc_clocksource = kvm_get_time_and_clockread(\n\t\t\t\t\t&ka->master_kernel_ns,\n\t\t\t\t\t&ka->master_cycle_now);\n\n\tka->use_master_clock = host_tsc_clocksource && vcpus_matched\n\t\t\t\t&& !backwards_tsc_observed\n\t\t\t\t&& !ka->boot_vcpu_runs_old_kvmclock;\n\n\tif (ka->use_master_clock)\n\t\tatomic_set(&kvm_guest_has_master_clock, 1);\n\n\tvclock_mode = pvclock_gtod_data.clock.vclock_mode;\n\ttrace_kvm_update_master_clock(ka->use_master_clock, vclock_mode,\n\t\t\t\t\tvcpus_matched);\n#endif\n}"
  },
  {
    "function_name": "kvm_get_time_and_clockread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "1607-1614",
    "snippet": "static bool kvm_get_time_and_clockread(s64 *kernel_ns, cycle_t *cycle_now)\n{\n\t/* checked again under seqlock below */\n\tif (pvclock_gtod_data.clock.vclock_mode != VCLOCK_TSC)\n\t\treturn false;\n\n\treturn do_monotonic_boot(kernel_ns, cycle_now) == VCLOCK_TSC;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_monotonic_boot",
          "args": [
            "kernel_ns",
            "cycle_now"
          ],
          "line": 1613
        },
        "resolved": true,
        "details": {
          "function_name": "do_monotonic_boot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "1586-1604",
          "snippet": "static int do_monotonic_boot(s64 *t, cycle_t *cycle_now)\n{\n\tstruct pvclock_gtod_data *gtod = &pvclock_gtod_data;\n\tunsigned long seq;\n\tint mode;\n\tu64 ns;\n\n\tdo {\n\t\tseq = read_seqcount_begin(&gtod->seq);\n\t\tmode = gtod->clock.vclock_mode;\n\t\tns = gtod->nsec_base;\n\t\tns += vgettsc(cycle_now);\n\t\tns >>= gtod->clock.shift;\n\t\tns += gtod->boot_ns;\n\t} while (unlikely(read_seqcount_retry(&gtod->seq, seq)));\n\t*t = ns;\n\n\treturn mode;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int do_monotonic_boot(s64 *t, cycle_t *cycle_now)\n{\n\tstruct pvclock_gtod_data *gtod = &pvclock_gtod_data;\n\tunsigned long seq;\n\tint mode;\n\tu64 ns;\n\n\tdo {\n\t\tseq = read_seqcount_begin(&gtod->seq);\n\t\tmode = gtod->clock.vclock_mode;\n\t\tns = gtod->nsec_base;\n\t\tns += vgettsc(cycle_now);\n\t\tns >>= gtod->clock.shift;\n\t\tns += gtod->boot_ns;\n\t} while (unlikely(read_seqcount_retry(&gtod->seq, seq)));\n\t*t = ns;\n\n\treturn mode;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic bool kvm_get_time_and_clockread(s64 *kernel_ns, cycle_t *cycle_now)\n{\n\t/* checked again under seqlock below */\n\tif (pvclock_gtod_data.clock.vclock_mode != VCLOCK_TSC)\n\t\treturn false;\n\n\treturn do_monotonic_boot(kernel_ns, cycle_now) == VCLOCK_TSC;\n}"
  },
  {
    "function_name": "do_monotonic_boot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "1586-1604",
    "snippet": "static int do_monotonic_boot(s64 *t, cycle_t *cycle_now)\n{\n\tstruct pvclock_gtod_data *gtod = &pvclock_gtod_data;\n\tunsigned long seq;\n\tint mode;\n\tu64 ns;\n\n\tdo {\n\t\tseq = read_seqcount_begin(&gtod->seq);\n\t\tmode = gtod->clock.vclock_mode;\n\t\tns = gtod->nsec_base;\n\t\tns += vgettsc(cycle_now);\n\t\tns >>= gtod->clock.shift;\n\t\tns += gtod->boot_ns;\n\t} while (unlikely(read_seqcount_retry(&gtod->seq, seq)));\n\t*t = ns;\n\n\treturn mode;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "read_seqcount_retry(&gtod->seq, seq)"
          ],
          "line": 1600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_seqcount_retry",
          "args": [
            "&gtod->seq",
            "seq"
          ],
          "line": 1600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vgettsc",
          "args": [
            "cycle_now"
          ],
          "line": 1597
        },
        "resolved": true,
        "details": {
          "function_name": "vgettsc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "1575-1584",
          "snippet": "static inline u64 vgettsc(cycle_t *cycle_now)\n{\n\tlong v;\n\tstruct pvclock_gtod_data *gtod = &pvclock_gtod_data;\n\n\t*cycle_now = read_tsc();\n\n\tv = (*cycle_now - gtod->clock.cycle_last) & gtod->clock.mask;\n\treturn v * gtod->clock.mult;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic inline u64 vgettsc(cycle_t *cycle_now)\n{\n\tlong v;\n\tstruct pvclock_gtod_data *gtod = &pvclock_gtod_data;\n\n\t*cycle_now = read_tsc();\n\n\tv = (*cycle_now - gtod->clock.cycle_last) & gtod->clock.mask;\n\treturn v * gtod->clock.mult;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_seqcount_begin",
          "args": [
            "&gtod->seq"
          ],
          "line": 1594
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int do_monotonic_boot(s64 *t, cycle_t *cycle_now)\n{\n\tstruct pvclock_gtod_data *gtod = &pvclock_gtod_data;\n\tunsigned long seq;\n\tint mode;\n\tu64 ns;\n\n\tdo {\n\t\tseq = read_seqcount_begin(&gtod->seq);\n\t\tmode = gtod->clock.vclock_mode;\n\t\tns = gtod->nsec_base;\n\t\tns += vgettsc(cycle_now);\n\t\tns >>= gtod->clock.shift;\n\t\tns += gtod->boot_ns;\n\t} while (unlikely(read_seqcount_retry(&gtod->seq, seq)));\n\t*t = ns;\n\n\treturn mode;\n}"
  },
  {
    "function_name": "vgettsc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "1575-1584",
    "snippet": "static inline u64 vgettsc(cycle_t *cycle_now)\n{\n\tlong v;\n\tstruct pvclock_gtod_data *gtod = &pvclock_gtod_data;\n\n\t*cycle_now = read_tsc();\n\n\tv = (*cycle_now - gtod->clock.cycle_last) & gtod->clock.mask;\n\treturn v * gtod->clock.mult;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_tsc",
          "args": [],
          "line": 1580
        },
        "resolved": true,
        "details": {
          "function_name": "read_tsc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "1555-1573",
          "snippet": "static cycle_t read_tsc(void)\n{\n\tcycle_t ret = (cycle_t)rdtsc_ordered();\n\tu64 last = pvclock_gtod_data.clock.cycle_last;\n\n\tif (likely(ret >= last))\n\t\treturn ret;\n\n\t/*\n\t * GCC likes to generate cmov here, but this branch is extremely\n\t * predictable (it's just a function of time and the likely is\n\t * very likely) and there's a data dependence, so force GCC\n\t * to generate a branch instead.  I don't barrier() because\n\t * we don't actually need a barrier, and if this function\n\t * ever gets inlined it will generate worse code.\n\t */\n\tasm volatile (\"\");\n\treturn last;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic cycle_t read_tsc(void)\n{\n\tcycle_t ret = (cycle_t)rdtsc_ordered();\n\tu64 last = pvclock_gtod_data.clock.cycle_last;\n\n\tif (likely(ret >= last))\n\t\treturn ret;\n\n\t/*\n\t * GCC likes to generate cmov here, but this branch is extremely\n\t * predictable (it's just a function of time and the likely is\n\t * very likely) and there's a data dependence, so force GCC\n\t * to generate a branch instead.  I don't barrier() because\n\t * we don't actually need a barrier, and if this function\n\t * ever gets inlined it will generate worse code.\n\t */\n\tasm volatile (\"\");\n\treturn last;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic inline u64 vgettsc(cycle_t *cycle_now)\n{\n\tlong v;\n\tstruct pvclock_gtod_data *gtod = &pvclock_gtod_data;\n\n\t*cycle_now = read_tsc();\n\n\tv = (*cycle_now - gtod->clock.cycle_last) & gtod->clock.mask;\n\treturn v * gtod->clock.mult;\n}"
  },
  {
    "function_name": "read_tsc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "1555-1573",
    "snippet": "static cycle_t read_tsc(void)\n{\n\tcycle_t ret = (cycle_t)rdtsc_ordered();\n\tu64 last = pvclock_gtod_data.clock.cycle_last;\n\n\tif (likely(ret >= last))\n\t\treturn ret;\n\n\t/*\n\t * GCC likes to generate cmov here, but this branch is extremely\n\t * predictable (it's just a function of time and the likely is\n\t * very likely) and there's a data dependence, so force GCC\n\t * to generate a branch instead.  I don't barrier() because\n\t * we don't actually need a barrier, and if this function\n\t * ever gets inlined it will generate worse code.\n\t */\n\tasm volatile (\"\");\n\treturn last;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "ret >= last"
          ],
          "line": 1560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rdtsc_ordered",
          "args": [],
          "line": 1557
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic cycle_t read_tsc(void)\n{\n\tcycle_t ret = (cycle_t)rdtsc_ordered();\n\tu64 last = pvclock_gtod_data.clock.cycle_last;\n\n\tif (likely(ret >= last))\n\t\treturn ret;\n\n\t/*\n\t * GCC likes to generate cmov here, but this branch is extremely\n\t * predictable (it's just a function of time and the likely is\n\t * very likely) and there's a data dependence, so force GCC\n\t * to generate a branch instead.  I don't barrier() because\n\t * we don't actually need a barrier, and if this function\n\t * ever gets inlined it will generate worse code.\n\t */\n\tasm volatile (\"\");\n\treturn last;\n}"
  },
  {
    "function_name": "adjust_tsc_offset_host",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "1545-1551",
    "snippet": "static inline void adjust_tsc_offset_host(struct kvm_vcpu *vcpu, s64 adjustment)\n{\n\tif (vcpu->arch.tsc_scaling_ratio != kvm_default_tsc_scaling_ratio)\n\t\tWARN_ON(adjustment < 0);\n\tadjustment = kvm_scale_tsc(vcpu, (u64) adjustment);\n\tkvm_x86_ops->adjust_tsc_offset_guest(vcpu, adjustment);\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);",
      "struct kvm_x86_ops *kvm_x86_ops"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_x86_ops->adjust_tsc_offset_guest",
          "args": [
            "vcpu",
            "adjustment"
          ],
          "line": 1550
        },
        "resolved": true,
        "details": {
          "function_name": "adjust_tsc_offset_guest",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "1539-1543",
          "snippet": "static inline void adjust_tsc_offset_guest(struct kvm_vcpu *vcpu,\n\t\t\t\t\t   s64 adjustment)\n{\n\tkvm_x86_ops->adjust_tsc_offset_guest(vcpu, adjustment);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "struct kvm_x86_ops *kvm_x86_ops"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nstatic inline void adjust_tsc_offset_guest(struct kvm_vcpu *vcpu,\n\t\t\t\t\t   s64 adjustment)\n{\n\tkvm_x86_ops->adjust_tsc_offset_guest(vcpu, adjustment);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_scale_tsc",
          "args": [
            "vcpu",
            "(u64) adjustment"
          ],
          "line": 1549
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_scale_tsc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "1387-1396",
          "snippet": "u64 kvm_scale_tsc(struct kvm_vcpu *vcpu, u64 tsc)\n{\n\tu64 _tsc = tsc;\n\tu64 ratio = vcpu->arch.tsc_scaling_ratio;\n\n\tif (ratio != kvm_default_tsc_scaling_ratio)\n\t\t_tsc = __scale_tsc(ratio, tsc);\n\n\treturn _tsc;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nu64 kvm_scale_tsc(struct kvm_vcpu *vcpu, u64 tsc)\n{\n\tu64 _tsc = tsc;\n\tu64 ratio = vcpu->arch.tsc_scaling_ratio;\n\n\tif (ratio != kvm_default_tsc_scaling_ratio)\n\t\t_tsc = __scale_tsc(ratio, tsc);\n\n\treturn _tsc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "adjustment < 0"
          ],
          "line": 1548
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nstatic inline void adjust_tsc_offset_host(struct kvm_vcpu *vcpu, s64 adjustment)\n{\n\tif (vcpu->arch.tsc_scaling_ratio != kvm_default_tsc_scaling_ratio)\n\t\tWARN_ON(adjustment < 0);\n\tadjustment = kvm_scale_tsc(vcpu, (u64) adjustment);\n\tkvm_x86_ops->adjust_tsc_offset_guest(vcpu, adjustment);\n}"
  },
  {
    "function_name": "adjust_tsc_offset_guest",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "1539-1543",
    "snippet": "static inline void adjust_tsc_offset_guest(struct kvm_vcpu *vcpu,\n\t\t\t\t\t   s64 adjustment)\n{\n\tkvm_x86_ops->adjust_tsc_offset_guest(vcpu, adjustment);\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);",
      "struct kvm_x86_ops *kvm_x86_ops"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_x86_ops->adjust_tsc_offset_guest",
          "args": [
            "vcpu",
            "adjustment"
          ],
          "line": 1542
        },
        "resolved": true,
        "details": {
          "function_name": "adjust_tsc_offset_guest",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "1539-1543",
          "snippet": "static inline void adjust_tsc_offset_guest(struct kvm_vcpu *vcpu,\n\t\t\t\t\t   s64 adjustment)\n{\n\tkvm_x86_ops->adjust_tsc_offset_guest(vcpu, adjustment);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nstatic inline void adjust_tsc_offset_guest(struct kvm_vcpu *vcpu,\n\t\t\t\t\t   s64 adjustment)\n{\n\tkvm_x86_ops->adjust_tsc_offset_guest(vcpu, adjustment);\n}"
  },
  {
    "function_name": "kvm_read_l1_tsc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "1408-1411",
    "snippet": "u64 kvm_read_l1_tsc(struct kvm_vcpu *vcpu, u64 host_tsc)\n{\n\treturn kvm_x86_ops->read_l1_tsc(vcpu, kvm_scale_tsc(vcpu, host_tsc));\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);",
      "struct kvm_x86_ops *kvm_x86_ops"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_x86_ops->read_l1_tsc",
          "args": [
            "vcpu",
            "kvm_scale_tsc(vcpu, host_tsc)"
          ],
          "line": 1410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_scale_tsc",
          "args": [
            "vcpu",
            "host_tsc"
          ],
          "line": 1410
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_scale_tsc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "1387-1396",
          "snippet": "u64 kvm_scale_tsc(struct kvm_vcpu *vcpu, u64 tsc)\n{\n\tu64 _tsc = tsc;\n\tu64 ratio = vcpu->arch.tsc_scaling_ratio;\n\n\tif (ratio != kvm_default_tsc_scaling_ratio)\n\t\t_tsc = __scale_tsc(ratio, tsc);\n\n\treturn _tsc;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nu64 kvm_scale_tsc(struct kvm_vcpu *vcpu, u64 tsc)\n{\n\tu64 _tsc = tsc;\n\tu64 ratio = vcpu->arch.tsc_scaling_ratio;\n\n\tif (ratio != kvm_default_tsc_scaling_ratio)\n\t\t_tsc = __scale_tsc(ratio, tsc);\n\n\treturn _tsc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nu64 kvm_read_l1_tsc(struct kvm_vcpu *vcpu, u64 host_tsc)\n{\n\treturn kvm_x86_ops->read_l1_tsc(vcpu, kvm_scale_tsc(vcpu, host_tsc));\n}"
  },
  {
    "function_name": "kvm_compute_tsc_offset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "1399-1406",
    "snippet": "static u64 kvm_compute_tsc_offset(struct kvm_vcpu *vcpu, u64 target_tsc)\n{\n\tu64 tsc;\n\n\ttsc = kvm_scale_tsc(vcpu, rdtsc());\n\n\treturn target_tsc - tsc;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_scale_tsc",
          "args": [
            "vcpu",
            "rdtsc()"
          ],
          "line": 1403
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_scale_tsc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "1387-1396",
          "snippet": "u64 kvm_scale_tsc(struct kvm_vcpu *vcpu, u64 tsc)\n{\n\tu64 _tsc = tsc;\n\tu64 ratio = vcpu->arch.tsc_scaling_ratio;\n\n\tif (ratio != kvm_default_tsc_scaling_ratio)\n\t\t_tsc = __scale_tsc(ratio, tsc);\n\n\treturn _tsc;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nu64 kvm_scale_tsc(struct kvm_vcpu *vcpu, u64 tsc)\n{\n\tu64 _tsc = tsc;\n\tu64 ratio = vcpu->arch.tsc_scaling_ratio;\n\n\tif (ratio != kvm_default_tsc_scaling_ratio)\n\t\t_tsc = __scale_tsc(ratio, tsc);\n\n\treturn _tsc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rdtsc",
          "args": [],
          "line": 1403
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_rdtscp_supported",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/vmx.c",
          "lines": "2393-2396",
          "snippet": "static bool vmx_rdtscp_supported(void)\n{\n\treturn cpu_has_vmx_rdtscp();\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"trace.h\"",
            "#include <asm/irq_remapping.h>",
            "#include <asm/apic.h>",
            "#include <asm/kexec.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/mce.h>",
            "#include <asm/virtext.h>",
            "#include <asm/vmx.h>",
            "#include <asm/desc.h>",
            "#include <asm/io.h>",
            "#include <asm/cpu.h>",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/hrtimer.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include \"lapic.h\"",
            "#include \"cpuid.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"trace.h\"\n#include <asm/irq_remapping.h>\n#include <asm/apic.h>\n#include <asm/kexec.h>\n#include <asm/debugreg.h>\n#include <asm/perf_event.h>\n#include <asm/fpu/internal.h>\n#include <asm/mce.h>\n#include <asm/virtext.h>\n#include <asm/vmx.h>\n#include <asm/desc.h>\n#include <asm/io.h>\n#include <asm/cpu.h>\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/hrtimer.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic bool vmx_rdtscp_supported(void)\n{\n\treturn cpu_has_vmx_rdtscp();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic u64 kvm_compute_tsc_offset(struct kvm_vcpu *vcpu, u64 target_tsc)\n{\n\tu64 tsc;\n\n\ttsc = kvm_scale_tsc(vcpu, rdtsc());\n\n\treturn target_tsc - tsc;\n}"
  },
  {
    "function_name": "kvm_scale_tsc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "1387-1396",
    "snippet": "u64 kvm_scale_tsc(struct kvm_vcpu *vcpu, u64 tsc)\n{\n\tu64 _tsc = tsc;\n\tu64 ratio = vcpu->arch.tsc_scaling_ratio;\n\n\tif (ratio != kvm_default_tsc_scaling_ratio)\n\t\t_tsc = __scale_tsc(ratio, tsc);\n\n\treturn _tsc;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__scale_tsc",
          "args": [
            "ratio",
            "tsc"
          ],
          "line": 1393
        },
        "resolved": true,
        "details": {
          "function_name": "__scale_tsc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "1382-1385",
          "snippet": "static inline u64 __scale_tsc(u64 ratio, u64 tsc)\n{\n\treturn mul_u64_u64_shr(tsc, ratio, kvm_tsc_scaling_ratio_frac_bits);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic inline u64 __scale_tsc(u64 ratio, u64 tsc)\n{\n\treturn mul_u64_u64_shr(tsc, ratio, kvm_tsc_scaling_ratio_frac_bits);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nu64 kvm_scale_tsc(struct kvm_vcpu *vcpu, u64 tsc)\n{\n\tu64 _tsc = tsc;\n\tu64 ratio = vcpu->arch.tsc_scaling_ratio;\n\n\tif (ratio != kvm_default_tsc_scaling_ratio)\n\t\t_tsc = __scale_tsc(ratio, tsc);\n\n\treturn _tsc;\n}"
  },
  {
    "function_name": "__scale_tsc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "1382-1385",
    "snippet": "static inline u64 __scale_tsc(u64 ratio, u64 tsc)\n{\n\treturn mul_u64_u64_shr(tsc, ratio, kvm_tsc_scaling_ratio_frac_bits);\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mul_u64_u64_shr",
          "args": [
            "tsc",
            "ratio",
            "kvm_tsc_scaling_ratio_frac_bits"
          ],
          "line": 1384
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic inline u64 __scale_tsc(u64 ratio, u64 tsc)\n{\n\treturn mul_u64_u64_shr(tsc, ratio, kvm_tsc_scaling_ratio_frac_bits);\n}"
  },
  {
    "function_name": "update_ia32_tsc_adjust_msr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "1366-1370",
    "snippet": "static void update_ia32_tsc_adjust_msr(struct kvm_vcpu *vcpu, s64 offset)\n{\n\tu64 curr_offset = kvm_x86_ops->read_tsc_offset(vcpu);\n\tvcpu->arch.ia32_tsc_adjust_msr += offset - curr_offset;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);",
      "struct kvm_x86_ops *kvm_x86_ops"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_x86_ops->read_tsc_offset",
          "args": [
            "vcpu"
          ],
          "line": 1368
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nstatic void update_ia32_tsc_adjust_msr(struct kvm_vcpu *vcpu, s64 offset)\n{\n\tu64 curr_offset = kvm_x86_ops->read_tsc_offset(vcpu);\n\tvcpu->arch.ia32_tsc_adjust_msr += offset - curr_offset;\n}"
  },
  {
    "function_name": "kvm_track_tsc_matching",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "1338-1364",
    "snippet": "static void kvm_track_tsc_matching(struct kvm_vcpu *vcpu)\n{\n#ifdef CONFIG_X86_64\n\tbool vcpus_matched;\n\tstruct kvm_arch *ka = &vcpu->kvm->arch;\n\tstruct pvclock_gtod_data *gtod = &pvclock_gtod_data;\n\n\tvcpus_matched = (ka->nr_vcpus_matched_tsc + 1 ==\n\t\t\t atomic_read(&vcpu->kvm->online_vcpus));\n\n\t/*\n\t * Once the masterclock is enabled, always perform request in\n\t * order to update it.\n\t *\n\t * In order to enable masterclock, the host clocksource must be TSC\n\t * and the vcpus need to have matched TSCs.  When that happens,\n\t * perform request to enable masterclock.\n\t */\n\tif (ka->use_master_clock ||\n\t    (gtod->clock.vclock_mode == VCLOCK_TSC && vcpus_matched))\n\t\tkvm_make_request(KVM_REQ_MASTERCLOCK_UPDATE, vcpu);\n\n\ttrace_kvm_track_tsc(vcpu->vcpu_id, ka->nr_vcpus_matched_tsc,\n\t\t\t    atomic_read(&vcpu->kvm->online_vcpus),\n\t\t            ka->use_master_clock, gtod->clock.vclock_mode);\n#endif\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_kvm_track_tsc",
          "args": [
            "vcpu->vcpu_id",
            "ka->nr_vcpus_matched_tsc",
            "atomic_read(&vcpu->kvm->online_vcpus)",
            "ka->use_master_clock",
            "gtod->clock.vclock_mode"
          ],
          "line": 1360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&vcpu->kvm->online_vcpus"
          ],
          "line": 1361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_make_request",
          "args": [
            "KVM_REQ_MASTERCLOCK_UPDATE",
            "vcpu"
          ],
          "line": 1358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&vcpu->kvm->online_vcpus"
          ],
          "line": 1346
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic void kvm_track_tsc_matching(struct kvm_vcpu *vcpu)\n{\n#ifdef CONFIG_X86_64\n\tbool vcpus_matched;\n\tstruct kvm_arch *ka = &vcpu->kvm->arch;\n\tstruct pvclock_gtod_data *gtod = &pvclock_gtod_data;\n\n\tvcpus_matched = (ka->nr_vcpus_matched_tsc + 1 ==\n\t\t\t atomic_read(&vcpu->kvm->online_vcpus));\n\n\t/*\n\t * Once the masterclock is enabled, always perform request in\n\t * order to update it.\n\t *\n\t * In order to enable masterclock, the host clocksource must be TSC\n\t * and the vcpus need to have matched TSCs.  When that happens,\n\t * perform request to enable masterclock.\n\t */\n\tif (ka->use_master_clock ||\n\t    (gtod->clock.vclock_mode == VCLOCK_TSC && vcpus_matched))\n\t\tkvm_make_request(KVM_REQ_MASTERCLOCK_UPDATE, vcpu);\n\n\ttrace_kvm_track_tsc(vcpu->vcpu_id, ka->nr_vcpus_matched_tsc,\n\t\t\t    atomic_read(&vcpu->kvm->online_vcpus),\n\t\t            ka->use_master_clock, gtod->clock.vclock_mode);\n#endif\n}"
  },
  {
    "function_name": "compute_guest_tsc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "1329-1336",
    "snippet": "static u64 compute_guest_tsc(struct kvm_vcpu *vcpu, s64 kernel_ns)\n{\n\tu64 tsc = pvclock_scale_delta(kernel_ns-vcpu->arch.this_tsc_nsec,\n\t\t\t\t      vcpu->arch.virtual_tsc_mult,\n\t\t\t\t      vcpu->arch.virtual_tsc_shift);\n\ttsc += vcpu->arch.this_tsc_write;\n\treturn tsc;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pvclock_scale_delta",
          "args": [
            "kernel_ns-vcpu->arch.this_tsc_nsec",
            "vcpu->arch.virtual_tsc_mult",
            "vcpu->arch.virtual_tsc_shift"
          ],
          "line": 1331
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic u64 compute_guest_tsc(struct kvm_vcpu *vcpu, s64 kernel_ns)\n{\n\tu64 tsc = pvclock_scale_delta(kernel_ns-vcpu->arch.this_tsc_nsec,\n\t\t\t\t      vcpu->arch.virtual_tsc_mult,\n\t\t\t\t      vcpu->arch.virtual_tsc_shift);\n\ttsc += vcpu->arch.this_tsc_write;\n\treturn tsc;\n}"
  },
  {
    "function_name": "kvm_set_tsc_khz",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "1296-1327",
    "snippet": "static int kvm_set_tsc_khz(struct kvm_vcpu *vcpu, u32 user_tsc_khz)\n{\n\tu32 thresh_lo, thresh_hi;\n\tint use_scaling = 0;\n\n\t/* tsc_khz can be zero if TSC calibration fails */\n\tif (user_tsc_khz == 0) {\n\t\t/* set tsc_scaling_ratio to a safe value */\n\t\tvcpu->arch.tsc_scaling_ratio = kvm_default_tsc_scaling_ratio;\n\t\treturn -1;\n\t}\n\n\t/* Compute a scale to convert nanoseconds in TSC cycles */\n\tkvm_get_time_scale(user_tsc_khz * 1000LL, NSEC_PER_SEC,\n\t\t\t   &vcpu->arch.virtual_tsc_shift,\n\t\t\t   &vcpu->arch.virtual_tsc_mult);\n\tvcpu->arch.virtual_tsc_khz = user_tsc_khz;\n\n\t/*\n\t * Compute the variation in TSC rate which is acceptable\n\t * within the range of tolerance and decide if the\n\t * rate being applied is within that bounds of the hardware\n\t * rate.  If so, no scaling or compensation need be done.\n\t */\n\tthresh_lo = adjust_tsc_khz(tsc_khz, -tsc_tolerance_ppm);\n\tthresh_hi = adjust_tsc_khz(tsc_khz, tsc_tolerance_ppm);\n\tif (user_tsc_khz < thresh_lo || user_tsc_khz > thresh_hi) {\n\t\tpr_debug(\"kvm: requested TSC rate %u falls outside tolerance [%u,%u]\\n\", user_tsc_khz, thresh_lo, thresh_hi);\n\t\tuse_scaling = 1;\n\t}\n\treturn set_tsc_khz(vcpu, user_tsc_khz, use_scaling);\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_tsc_khz",
          "args": [
            "vcpu",
            "user_tsc_khz",
            "use_scaling"
          ],
          "line": 1326
        },
        "resolved": true,
        "details": {
          "function_name": "set_tsc_khz",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "1260-1294",
          "snippet": "static int set_tsc_khz(struct kvm_vcpu *vcpu, u32 user_tsc_khz, bool scale)\n{\n\tu64 ratio;\n\n\t/* Guest TSC same frequency as host TSC? */\n\tif (!scale) {\n\t\tvcpu->arch.tsc_scaling_ratio = kvm_default_tsc_scaling_ratio;\n\t\treturn 0;\n\t}\n\n\t/* TSC scaling supported? */\n\tif (!kvm_has_tsc_control) {\n\t\tif (user_tsc_khz > tsc_khz) {\n\t\t\tvcpu->arch.tsc_catchup = 1;\n\t\t\tvcpu->arch.tsc_always_catchup = 1;\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tWARN(1, \"user requested TSC rate below hardware speed\\n\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/* TSC scaling required  - calculate ratio */\n\tratio = mul_u64_u32_div(1ULL << kvm_tsc_scaling_ratio_frac_bits,\n\t\t\t\tuser_tsc_khz, tsc_khz);\n\n\tif (ratio == 0 || ratio >= kvm_max_tsc_scaling_ratio) {\n\t\tWARN_ONCE(1, \"Invalid TSC scaling ratio - virtual-tsc-khz=%u\\n\",\n\t\t\t  user_tsc_khz);\n\t\treturn -1;\n\t}\n\n\tvcpu->arch.tsc_scaling_ratio = ratio;\n\treturn 0;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic int set_tsc_khz(struct kvm_vcpu *vcpu, u32 user_tsc_khz, bool scale)\n{\n\tu64 ratio;\n\n\t/* Guest TSC same frequency as host TSC? */\n\tif (!scale) {\n\t\tvcpu->arch.tsc_scaling_ratio = kvm_default_tsc_scaling_ratio;\n\t\treturn 0;\n\t}\n\n\t/* TSC scaling supported? */\n\tif (!kvm_has_tsc_control) {\n\t\tif (user_tsc_khz > tsc_khz) {\n\t\t\tvcpu->arch.tsc_catchup = 1;\n\t\t\tvcpu->arch.tsc_always_catchup = 1;\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tWARN(1, \"user requested TSC rate below hardware speed\\n\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/* TSC scaling required  - calculate ratio */\n\tratio = mul_u64_u32_div(1ULL << kvm_tsc_scaling_ratio_frac_bits,\n\t\t\t\tuser_tsc_khz, tsc_khz);\n\n\tif (ratio == 0 || ratio >= kvm_max_tsc_scaling_ratio) {\n\t\tWARN_ONCE(1, \"Invalid TSC scaling ratio - virtual-tsc-khz=%u\\n\",\n\t\t\t  user_tsc_khz);\n\t\treturn -1;\n\t}\n\n\tvcpu->arch.tsc_scaling_ratio = ratio;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"kvm: requested TSC rate %u falls outside tolerance [%u,%u]\\n\"",
            "user_tsc_khz",
            "thresh_lo",
            "thresh_hi"
          ],
          "line": 1323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "adjust_tsc_khz",
          "args": [
            "tsc_khz",
            "tsc_tolerance_ppm"
          ],
          "line": 1321
        },
        "resolved": true,
        "details": {
          "function_name": "adjust_tsc_khz",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "1253-1258",
          "snippet": "static u32 adjust_tsc_khz(u32 khz, s32 ppm)\n{\n\tu64 v = (u64)khz * (1000000 + ppm);\n\tdo_div(v, 1000000);\n\treturn v;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic u32 adjust_tsc_khz(u32 khz, s32 ppm)\n{\n\tu64 v = (u64)khz * (1000000 + ppm);\n\tdo_div(v, 1000000);\n\treturn v;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_get_time_scale",
          "args": [
            "user_tsc_khz * 1000LL",
            "NSEC_PER_SEC",
            "&vcpu->arch.virtual_tsc_shift",
            "&vcpu->arch.virtual_tsc_mult"
          ],
          "line": 1309
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_get_time_scale",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "1209-1238",
          "snippet": "static void kvm_get_time_scale(uint64_t scaled_hz, uint64_t base_hz,\n\t\t\t       s8 *pshift, u32 *pmultiplier)\n{\n\tuint64_t scaled64;\n\tint32_t  shift = 0;\n\tuint64_t tps64;\n\tuint32_t tps32;\n\n\ttps64 = base_hz;\n\tscaled64 = scaled_hz;\n\twhile (tps64 > scaled64*2 || tps64 & 0xffffffff00000000ULL) {\n\t\ttps64 >>= 1;\n\t\tshift--;\n\t}\n\n\ttps32 = (uint32_t)tps64;\n\twhile (tps32 <= scaled64 || scaled64 & 0xffffffff00000000ULL) {\n\t\tif (scaled64 & 0xffffffff00000000ULL || tps32 & 0x80000000)\n\t\t\tscaled64 >>= 1;\n\t\telse\n\t\t\ttps32 <<= 1;\n\t\tshift++;\n\t}\n\n\t*pshift = shift;\n\t*pmultiplier = div_frac(scaled64, tps32);\n\n\tpr_debug(\"%s: base_hz %llu => %llu, shift %d, mul %u\\n\",\n\t\t __func__, base_hz, scaled_hz, shift, *pmultiplier);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void kvm_get_time_scale(uint64_t scaled_hz, uint64_t base_hz,\n\t\t\t       s8 *pshift, u32 *pmultiplier)\n{\n\tuint64_t scaled64;\n\tint32_t  shift = 0;\n\tuint64_t tps64;\n\tuint32_t tps32;\n\n\ttps64 = base_hz;\n\tscaled64 = scaled_hz;\n\twhile (tps64 > scaled64*2 || tps64 & 0xffffffff00000000ULL) {\n\t\ttps64 >>= 1;\n\t\tshift--;\n\t}\n\n\ttps32 = (uint32_t)tps64;\n\twhile (tps32 <= scaled64 || scaled64 & 0xffffffff00000000ULL) {\n\t\tif (scaled64 & 0xffffffff00000000ULL || tps32 & 0x80000000)\n\t\t\tscaled64 >>= 1;\n\t\telse\n\t\t\ttps32 <<= 1;\n\t\tshift++;\n\t}\n\n\t*pshift = shift;\n\t*pmultiplier = div_frac(scaled64, tps32);\n\n\tpr_debug(\"%s: base_hz %llu => %llu, shift %d, mul %u\\n\",\n\t\t __func__, base_hz, scaled_hz, shift, *pmultiplier);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic int kvm_set_tsc_khz(struct kvm_vcpu *vcpu, u32 user_tsc_khz)\n{\n\tu32 thresh_lo, thresh_hi;\n\tint use_scaling = 0;\n\n\t/* tsc_khz can be zero if TSC calibration fails */\n\tif (user_tsc_khz == 0) {\n\t\t/* set tsc_scaling_ratio to a safe value */\n\t\tvcpu->arch.tsc_scaling_ratio = kvm_default_tsc_scaling_ratio;\n\t\treturn -1;\n\t}\n\n\t/* Compute a scale to convert nanoseconds in TSC cycles */\n\tkvm_get_time_scale(user_tsc_khz * 1000LL, NSEC_PER_SEC,\n\t\t\t   &vcpu->arch.virtual_tsc_shift,\n\t\t\t   &vcpu->arch.virtual_tsc_mult);\n\tvcpu->arch.virtual_tsc_khz = user_tsc_khz;\n\n\t/*\n\t * Compute the variation in TSC rate which is acceptable\n\t * within the range of tolerance and decide if the\n\t * rate being applied is within that bounds of the hardware\n\t * rate.  If so, no scaling or compensation need be done.\n\t */\n\tthresh_lo = adjust_tsc_khz(tsc_khz, -tsc_tolerance_ppm);\n\tthresh_hi = adjust_tsc_khz(tsc_khz, tsc_tolerance_ppm);\n\tif (user_tsc_khz < thresh_lo || user_tsc_khz > thresh_hi) {\n\t\tpr_debug(\"kvm: requested TSC rate %u falls outside tolerance [%u,%u]\\n\", user_tsc_khz, thresh_lo, thresh_hi);\n\t\tuse_scaling = 1;\n\t}\n\treturn set_tsc_khz(vcpu, user_tsc_khz, use_scaling);\n}"
  },
  {
    "function_name": "set_tsc_khz",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "1260-1294",
    "snippet": "static int set_tsc_khz(struct kvm_vcpu *vcpu, u32 user_tsc_khz, bool scale)\n{\n\tu64 ratio;\n\n\t/* Guest TSC same frequency as host TSC? */\n\tif (!scale) {\n\t\tvcpu->arch.tsc_scaling_ratio = kvm_default_tsc_scaling_ratio;\n\t\treturn 0;\n\t}\n\n\t/* TSC scaling supported? */\n\tif (!kvm_has_tsc_control) {\n\t\tif (user_tsc_khz > tsc_khz) {\n\t\t\tvcpu->arch.tsc_catchup = 1;\n\t\t\tvcpu->arch.tsc_always_catchup = 1;\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tWARN(1, \"user requested TSC rate below hardware speed\\n\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/* TSC scaling required  - calculate ratio */\n\tratio = mul_u64_u32_div(1ULL << kvm_tsc_scaling_ratio_frac_bits,\n\t\t\t\tuser_tsc_khz, tsc_khz);\n\n\tif (ratio == 0 || ratio >= kvm_max_tsc_scaling_ratio) {\n\t\tWARN_ONCE(1, \"Invalid TSC scaling ratio - virtual-tsc-khz=%u\\n\",\n\t\t\t  user_tsc_khz);\n\t\treturn -1;\n\t}\n\n\tvcpu->arch.tsc_scaling_ratio = ratio;\n\treturn 0;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ONCE",
          "args": [
            "1",
            "\"Invalid TSC scaling ratio - virtual-tsc-khz=%u\\n\"",
            "user_tsc_khz"
          ],
          "line": 1287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mul_u64_u32_div",
          "args": [
            "1ULL << kvm_tsc_scaling_ratio_frac_bits",
            "user_tsc_khz",
            "tsc_khz"
          ],
          "line": 1283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "1",
            "\"user requested TSC rate below hardware speed\\n\""
          ],
          "line": 1277
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic int set_tsc_khz(struct kvm_vcpu *vcpu, u32 user_tsc_khz, bool scale)\n{\n\tu64 ratio;\n\n\t/* Guest TSC same frequency as host TSC? */\n\tif (!scale) {\n\t\tvcpu->arch.tsc_scaling_ratio = kvm_default_tsc_scaling_ratio;\n\t\treturn 0;\n\t}\n\n\t/* TSC scaling supported? */\n\tif (!kvm_has_tsc_control) {\n\t\tif (user_tsc_khz > tsc_khz) {\n\t\t\tvcpu->arch.tsc_catchup = 1;\n\t\t\tvcpu->arch.tsc_always_catchup = 1;\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tWARN(1, \"user requested TSC rate below hardware speed\\n\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/* TSC scaling required  - calculate ratio */\n\tratio = mul_u64_u32_div(1ULL << kvm_tsc_scaling_ratio_frac_bits,\n\t\t\t\tuser_tsc_khz, tsc_khz);\n\n\tif (ratio == 0 || ratio >= kvm_max_tsc_scaling_ratio) {\n\t\tWARN_ONCE(1, \"Invalid TSC scaling ratio - virtual-tsc-khz=%u\\n\",\n\t\t\t  user_tsc_khz);\n\t\treturn -1;\n\t}\n\n\tvcpu->arch.tsc_scaling_ratio = ratio;\n\treturn 0;\n}"
  },
  {
    "function_name": "adjust_tsc_khz",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "1253-1258",
    "snippet": "static u32 adjust_tsc_khz(u32 khz, s32 ppm)\n{\n\tu64 v = (u64)khz * (1000000 + ppm);\n\tdo_div(v, 1000000);\n\treturn v;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "v",
            "1000000"
          ],
          "line": 1256
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic u32 adjust_tsc_khz(u32 khz, s32 ppm)\n{\n\tu64 v = (u64)khz * (1000000 + ppm);\n\tdo_div(v, 1000000);\n\treturn v;\n}"
  },
  {
    "function_name": "nsec_to_cycles",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "1247-1251",
    "snippet": "static inline u64 nsec_to_cycles(struct kvm_vcpu *vcpu, u64 nsec)\n{\n\treturn pvclock_scale_delta(nsec, vcpu->arch.virtual_tsc_mult,\n\t\t\t\t   vcpu->arch.virtual_tsc_shift);\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pvclock_scale_delta",
          "args": [
            "nsec",
            "vcpu->arch.virtual_tsc_mult",
            "vcpu->arch.virtual_tsc_shift"
          ],
          "line": 1249
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic inline u64 nsec_to_cycles(struct kvm_vcpu *vcpu, u64 nsec)\n{\n\treturn pvclock_scale_delta(nsec, vcpu->arch.virtual_tsc_mult,\n\t\t\t\t   vcpu->arch.virtual_tsc_shift);\n}"
  },
  {
    "function_name": "kvm_get_time_scale",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "1209-1238",
    "snippet": "static void kvm_get_time_scale(uint64_t scaled_hz, uint64_t base_hz,\n\t\t\t       s8 *pshift, u32 *pmultiplier)\n{\n\tuint64_t scaled64;\n\tint32_t  shift = 0;\n\tuint64_t tps64;\n\tuint32_t tps32;\n\n\ttps64 = base_hz;\n\tscaled64 = scaled_hz;\n\twhile (tps64 > scaled64*2 || tps64 & 0xffffffff00000000ULL) {\n\t\ttps64 >>= 1;\n\t\tshift--;\n\t}\n\n\ttps32 = (uint32_t)tps64;\n\twhile (tps32 <= scaled64 || scaled64 & 0xffffffff00000000ULL) {\n\t\tif (scaled64 & 0xffffffff00000000ULL || tps32 & 0x80000000)\n\t\t\tscaled64 >>= 1;\n\t\telse\n\t\t\ttps32 <<= 1;\n\t\tshift++;\n\t}\n\n\t*pshift = shift;\n\t*pmultiplier = div_frac(scaled64, tps32);\n\n\tpr_debug(\"%s: base_hz %llu => %llu, shift %d, mul %u\\n\",\n\t\t __func__, base_hz, scaled_hz, shift, *pmultiplier);\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"%s: base_hz %llu => %llu, shift %d, mul %u\\n\"",
            "__func__",
            "base_hz",
            "scaled_hz",
            "shift",
            "*pmultiplier"
          ],
          "line": 1236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "div_frac",
          "args": [
            "scaled64",
            "tps32"
          ],
          "line": 1234
        },
        "resolved": true,
        "details": {
          "function_name": "div_frac",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "1203-1207",
          "snippet": "static uint32_t div_frac(uint32_t dividend, uint32_t divisor)\n{\n\tdo_shl32_div32(dividend, divisor);\n\treturn dividend;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic uint32_t div_frac(uint32_t dividend, uint32_t divisor)\n{\n\tdo_shl32_div32(dividend, divisor);\n\treturn dividend;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void kvm_get_time_scale(uint64_t scaled_hz, uint64_t base_hz,\n\t\t\t       s8 *pshift, u32 *pmultiplier)\n{\n\tuint64_t scaled64;\n\tint32_t  shift = 0;\n\tuint64_t tps64;\n\tuint32_t tps32;\n\n\ttps64 = base_hz;\n\tscaled64 = scaled_hz;\n\twhile (tps64 > scaled64*2 || tps64 & 0xffffffff00000000ULL) {\n\t\ttps64 >>= 1;\n\t\tshift--;\n\t}\n\n\ttps32 = (uint32_t)tps64;\n\twhile (tps32 <= scaled64 || scaled64 & 0xffffffff00000000ULL) {\n\t\tif (scaled64 & 0xffffffff00000000ULL || tps32 & 0x80000000)\n\t\t\tscaled64 >>= 1;\n\t\telse\n\t\t\ttps32 <<= 1;\n\t\tshift++;\n\t}\n\n\t*pshift = shift;\n\t*pmultiplier = div_frac(scaled64, tps32);\n\n\tpr_debug(\"%s: base_hz %llu => %llu, shift %d, mul %u\\n\",\n\t\t __func__, base_hz, scaled_hz, shift, *pmultiplier);\n}"
  },
  {
    "function_name": "div_frac",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "1203-1207",
    "snippet": "static uint32_t div_frac(uint32_t dividend, uint32_t divisor)\n{\n\tdo_shl32_div32(dividend, divisor);\n\treturn dividend;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_shl32_div32",
          "args": [
            "dividend",
            "divisor"
          ],
          "line": 1205
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic uint32_t div_frac(uint32_t dividend, uint32_t divisor)\n{\n\tdo_shl32_div32(dividend, divisor);\n\treturn dividend;\n}"
  },
  {
    "function_name": "kvm_write_wall_clock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "1159-1201",
    "snippet": "static void kvm_write_wall_clock(struct kvm *kvm, gpa_t wall_clock)\n{\n\tint version;\n\tint r;\n\tstruct pvclock_wall_clock wc;\n\tstruct timespec boot;\n\n\tif (!wall_clock)\n\t\treturn;\n\n\tr = kvm_read_guest(kvm, wall_clock, &version, sizeof(version));\n\tif (r)\n\t\treturn;\n\n\tif (version & 1)\n\t\t++version;  /* first time write, random junk */\n\n\t++version;\n\n\tif (kvm_write_guest(kvm, wall_clock, &version, sizeof(version)))\n\t\treturn;\n\n\t/*\n\t * The guest calculates current wall clock time by adding\n\t * system time (updated by kvm_guest_time_update below) to the\n\t * wall clock specified here.  guest system time equals host\n\t * system time for us, thus we must fill in host boot time here.\n\t */\n\tgetboottime(&boot);\n\n\tif (kvm->arch.kvmclock_offset) {\n\t\tstruct timespec ts = ns_to_timespec(kvm->arch.kvmclock_offset);\n\t\tboot = timespec_sub(boot, ts);\n\t}\n\twc.sec = boot.tv_sec;\n\twc.nsec = boot.tv_nsec;\n\twc.version = version;\n\n\tkvm_write_guest(kvm, wall_clock, &wc, sizeof(wc));\n\n\tversion++;\n\tkvm_write_guest(kvm, wall_clock, &version, sizeof(version));\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_write_guest",
          "args": [
            "kvm",
            "wall_clock",
            "&version",
            "sizeof(version)"
          ],
          "line": 1200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_write_guest",
          "args": [
            "kvm",
            "wall_clock",
            "&wc",
            "sizeof(wc)"
          ],
          "line": 1197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timespec_sub",
          "args": [
            "boot",
            "ts"
          ],
          "line": 1191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ns_to_timespec",
          "args": [
            "kvm->arch.kvmclock_offset"
          ],
          "line": 1190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getboottime",
          "args": [
            "&boot"
          ],
          "line": 1187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_write_guest",
          "args": [
            "kvm",
            "wall_clock",
            "&version",
            "sizeof(version)"
          ],
          "line": 1178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_read_guest",
          "args": [
            "kvm",
            "wall_clock",
            "&version",
            "sizeof(version)"
          ],
          "line": 1169
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_read_guest_phys_system",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "4285-4292",
          "snippet": "static int kvm_read_guest_phys_system(struct x86_emulate_ctxt *ctxt,\n\t\tunsigned long addr, void *val, unsigned int bytes)\n{\n\tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n\tint r = kvm_vcpu_read_guest(vcpu, addr, val, bytes);\n\n\treturn r < 0 ? X86EMUL_IO_NEEDED : X86EMUL_CONTINUE;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);\n\nstatic int kvm_read_guest_phys_system(struct x86_emulate_ctxt *ctxt,\n\t\tunsigned long addr, void *val, unsigned int bytes)\n{\n\tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n\tint r = kvm_vcpu_read_guest(vcpu, addr, val, bytes);\n\n\treturn r < 0 ? X86EMUL_IO_NEEDED : X86EMUL_CONTINUE;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void kvm_write_wall_clock(struct kvm *kvm, gpa_t wall_clock)\n{\n\tint version;\n\tint r;\n\tstruct pvclock_wall_clock wc;\n\tstruct timespec boot;\n\n\tif (!wall_clock)\n\t\treturn;\n\n\tr = kvm_read_guest(kvm, wall_clock, &version, sizeof(version));\n\tif (r)\n\t\treturn;\n\n\tif (version & 1)\n\t\t++version;  /* first time write, random junk */\n\n\t++version;\n\n\tif (kvm_write_guest(kvm, wall_clock, &version, sizeof(version)))\n\t\treturn;\n\n\t/*\n\t * The guest calculates current wall clock time by adding\n\t * system time (updated by kvm_guest_time_update below) to the\n\t * wall clock specified here.  guest system time equals host\n\t * system time for us, thus we must fill in host boot time here.\n\t */\n\tgetboottime(&boot);\n\n\tif (kvm->arch.kvmclock_offset) {\n\t\tstruct timespec ts = ns_to_timespec(kvm->arch.kvmclock_offset);\n\t\tboot = timespec_sub(boot, ts);\n\t}\n\twc.sec = boot.tv_sec;\n\twc.nsec = boot.tv_nsec;\n\twc.version = version;\n\n\tkvm_write_guest(kvm, wall_clock, &wc, sizeof(wc));\n\n\tversion++;\n\tkvm_write_guest(kvm, wall_clock, &version, sizeof(version));\n}"
  },
  {
    "function_name": "kvm_set_pending_timer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "1149-1157",
    "snippet": "void kvm_set_pending_timer(struct kvm_vcpu *vcpu)\n{\n\t/*\n\t * Note: KVM_REQ_PENDING_TIMER is implicitly checked in\n\t * vcpu_enter_guest.  This function is only called from\n\t * the physical CPU that is running vcpu.\n\t */\n\tkvm_make_request(KVM_REQ_PENDING_TIMER, vcpu);\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_make_request",
          "args": [
            "KVM_REQ_PENDING_TIMER",
            "vcpu"
          ],
          "line": 1156
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nvoid kvm_set_pending_timer(struct kvm_vcpu *vcpu)\n{\n\t/*\n\t * Note: KVM_REQ_PENDING_TIMER is implicitly checked in\n\t * vcpu_enter_guest.  This function is only called from\n\t * the physical CPU that is running vcpu.\n\t */\n\tkvm_make_request(KVM_REQ_PENDING_TIMER, vcpu);\n}"
  },
  {
    "function_name": "update_pvclock_gtod",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "1126-1146",
    "snippet": "static void update_pvclock_gtod(struct timekeeper *tk)\n{\n\tstruct pvclock_gtod_data *vdata = &pvclock_gtod_data;\n\tu64 boot_ns;\n\n\tboot_ns = ktime_to_ns(ktime_add(tk->tkr_mono.base, tk->offs_boot));\n\n\twrite_seqcount_begin(&vdata->seq);\n\n\t/* copy pvclock gtod data */\n\tvdata->clock.vclock_mode\t= tk->tkr_mono.clock->archdata.vclock_mode;\n\tvdata->clock.cycle_last\t\t= tk->tkr_mono.cycle_last;\n\tvdata->clock.mask\t\t= tk->tkr_mono.mask;\n\tvdata->clock.mult\t\t= tk->tkr_mono.mult;\n\tvdata->clock.shift\t\t= tk->tkr_mono.shift;\n\n\tvdata->boot_ns\t\t\t= boot_ns;\n\tvdata->nsec_base\t\t= tk->tkr_mono.xtime_nsec;\n\n\twrite_seqcount_end(&vdata->seq);\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_seqcount_end",
          "args": [
            "&vdata->seq"
          ],
          "line": 1145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_seqcount_begin",
          "args": [
            "&vdata->seq"
          ],
          "line": 1133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_to_ns",
          "args": [
            "ktime_add(tk->tkr_mono.base, tk->offs_boot)"
          ],
          "line": 1131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_add",
          "args": [
            "tk->tkr_mono.base",
            "tk->offs_boot"
          ],
          "line": 1131
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_pvclock_gtod(struct timekeeper *tk)\n{\n\tstruct pvclock_gtod_data *vdata = &pvclock_gtod_data;\n\tu64 boot_ns;\n\n\tboot_ns = ktime_to_ns(ktime_add(tk->tkr_mono.base, tk->offs_boot));\n\n\twrite_seqcount_begin(&vdata->seq);\n\n\t/* copy pvclock gtod data */\n\tvdata->clock.vclock_mode\t= tk->tkr_mono.clock->archdata.vclock_mode;\n\tvdata->clock.cycle_last\t\t= tk->tkr_mono.cycle_last;\n\tvdata->clock.mask\t\t= tk->tkr_mono.mask;\n\tvdata->clock.mult\t\t= tk->tkr_mono.mult;\n\tvdata->clock.shift\t\t= tk->tkr_mono.shift;\n\n\tvdata->boot_ns\t\t\t= boot_ns;\n\tvdata->nsec_base\t\t= tk->tkr_mono.xtime_nsec;\n\n\twrite_seqcount_end(&vdata->seq);\n}"
  },
  {
    "function_name": "do_set_msr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "1098-1106",
    "snippet": "static int do_set_msr(struct kvm_vcpu *vcpu, unsigned index, u64 *data)\n{\n\tstruct msr_data msr;\n\n\tmsr.data = *data;\n\tmsr.index = index;\n\tmsr.host_initiated = true;\n\treturn kvm_set_msr(vcpu, &msr);\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_set_msr",
          "args": [
            "vcpu",
            "&msr"
          ],
          "line": 1105
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_set_msr_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "2040-2248",
          "snippet": "int kvm_set_msr_common(struct kvm_vcpu *vcpu, struct msr_data *msr_info)\n{\n\tbool pr = false;\n\tu32 msr = msr_info->index;\n\tu64 data = msr_info->data;\n\n\tswitch (msr) {\n\tcase MSR_AMD64_NB_CFG:\n\tcase MSR_IA32_UCODE_REV:\n\tcase MSR_IA32_UCODE_WRITE:\n\tcase MSR_VM_HSAVE_PA:\n\tcase MSR_AMD64_PATCH_LOADER:\n\tcase MSR_AMD64_BU_CFG2:\n\t\tbreak;\n\n\tcase MSR_EFER:\n\t\treturn set_efer(vcpu, data);\n\tcase MSR_K7_HWCR:\n\t\tdata &= ~(u64)0x40;\t/* ignore flush filter disable */\n\t\tdata &= ~(u64)0x100;\t/* ignore ignne emulation enable */\n\t\tdata &= ~(u64)0x8;\t/* ignore TLB cache disable */\n\t\tdata &= ~(u64)0x40000;  /* ignore Mc status write enable */\n\t\tif (data != 0) {\n\t\t\tvcpu_unimpl(vcpu, \"unimplemented HWCR wrmsr: 0x%llx\\n\",\n\t\t\t\t    data);\n\t\t\treturn 1;\n\t\t}\n\t\tbreak;\n\tcase MSR_FAM10H_MMIO_CONF_BASE:\n\t\tif (data != 0) {\n\t\t\tvcpu_unimpl(vcpu, \"unimplemented MMIO_CONF_BASE wrmsr: \"\n\t\t\t\t    \"0x%llx\\n\", data);\n\t\t\treturn 1;\n\t\t}\n\t\tbreak;\n\tcase MSR_IA32_DEBUGCTLMSR:\n\t\tif (!data) {\n\t\t\t/* We support the non-activated case already */\n\t\t\tbreak;\n\t\t} else if (data & ~(DEBUGCTLMSR_LBR | DEBUGCTLMSR_BTF)) {\n\t\t\t/* Values other than LBR and BTF are vendor-specific,\n\t\t\t   thus reserved and should throw a #GP */\n\t\t\treturn 1;\n\t\t}\n\t\tvcpu_unimpl(vcpu, \"%s: MSR_IA32_DEBUGCTLMSR 0x%llx, nop\\n\",\n\t\t\t    __func__, data);\n\t\tbreak;\n\tcase 0x200 ... 0x2ff:\n\t\treturn kvm_mtrr_set_msr(vcpu, msr, data);\n\tcase MSR_IA32_APICBASE:\n\t\treturn kvm_set_apic_base(vcpu, msr_info);\n\tcase APIC_BASE_MSR ... APIC_BASE_MSR + 0x3ff:\n\t\treturn kvm_x2apic_msr_write(vcpu, msr, data);\n\tcase MSR_IA32_TSCDEADLINE:\n\t\tkvm_set_lapic_tscdeadline_msr(vcpu, data);\n\t\tbreak;\n\tcase MSR_IA32_TSC_ADJUST:\n\t\tif (guest_cpuid_has_tsc_adjust(vcpu)) {\n\t\t\tif (!msr_info->host_initiated) {\n\t\t\t\ts64 adj = data - vcpu->arch.ia32_tsc_adjust_msr;\n\t\t\t\tadjust_tsc_offset_guest(vcpu, adj);\n\t\t\t}\n\t\t\tvcpu->arch.ia32_tsc_adjust_msr = data;\n\t\t}\n\t\tbreak;\n\tcase MSR_IA32_MISC_ENABLE:\n\t\tvcpu->arch.ia32_misc_enable_msr = data;\n\t\tbreak;\n\tcase MSR_IA32_SMBASE:\n\t\tif (!msr_info->host_initiated)\n\t\t\treturn 1;\n\t\tvcpu->arch.smbase = data;\n\t\tbreak;\n\tcase MSR_KVM_WALL_CLOCK_NEW:\n\tcase MSR_KVM_WALL_CLOCK:\n\t\tvcpu->kvm->arch.wall_clock = data;\n\t\tkvm_write_wall_clock(vcpu->kvm, data);\n\t\tbreak;\n\tcase MSR_KVM_SYSTEM_TIME_NEW:\n\tcase MSR_KVM_SYSTEM_TIME: {\n\t\tu64 gpa_offset;\n\t\tstruct kvm_arch *ka = &vcpu->kvm->arch;\n\n\t\tkvmclock_reset(vcpu);\n\n\t\tif (vcpu->vcpu_id == 0 && !msr_info->host_initiated) {\n\t\t\tbool tmp = (msr == MSR_KVM_SYSTEM_TIME);\n\n\t\t\tif (ka->boot_vcpu_runs_old_kvmclock != tmp)\n\t\t\t\tset_bit(KVM_REQ_MASTERCLOCK_UPDATE,\n\t\t\t\t\t&vcpu->requests);\n\n\t\t\tka->boot_vcpu_runs_old_kvmclock = tmp;\n\t\t}\n\n\t\tvcpu->arch.time = data;\n\t\tkvm_make_request(KVM_REQ_GLOBAL_CLOCK_UPDATE, vcpu);\n\n\t\t/* we verify if the enable bit is set... */\n\t\tif (!(data & 1))\n\t\t\tbreak;\n\n\t\tgpa_offset = data & ~(PAGE_MASK | 1);\n\n\t\tif (kvm_gfn_to_hva_cache_init(vcpu->kvm,\n\t\t     &vcpu->arch.pv_time, data & ~1ULL,\n\t\t     sizeof(struct pvclock_vcpu_time_info)))\n\t\t\tvcpu->arch.pv_time_enabled = false;\n\t\telse\n\t\t\tvcpu->arch.pv_time_enabled = true;\n\n\t\tbreak;\n\t}\n\tcase MSR_KVM_ASYNC_PF_EN:\n\t\tif (kvm_pv_enable_async_pf(vcpu, data))\n\t\t\treturn 1;\n\t\tbreak;\n\tcase MSR_KVM_STEAL_TIME:\n\n\t\tif (unlikely(!sched_info_on()))\n\t\t\treturn 1;\n\n\t\tif (data & KVM_STEAL_RESERVED_MASK)\n\t\t\treturn 1;\n\n\t\tif (kvm_gfn_to_hva_cache_init(vcpu->kvm, &vcpu->arch.st.stime,\n\t\t\t\t\t\tdata & KVM_STEAL_VALID_BITS,\n\t\t\t\t\t\tsizeof(struct kvm_steal_time)))\n\t\t\treturn 1;\n\n\t\tvcpu->arch.st.msr_val = data;\n\n\t\tif (!(data & KVM_MSR_ENABLED))\n\t\t\tbreak;\n\n\t\tkvm_make_request(KVM_REQ_STEAL_UPDATE, vcpu);\n\n\t\tbreak;\n\tcase MSR_KVM_PV_EOI_EN:\n\t\tif (kvm_lapic_enable_pv_eoi(vcpu, data))\n\t\t\treturn 1;\n\t\tbreak;\n\n\tcase MSR_IA32_MCG_CTL:\n\tcase MSR_IA32_MCG_STATUS:\n\tcase MSR_IA32_MC0_CTL ... MSR_IA32_MCx_CTL(KVM_MAX_MCE_BANKS) - 1:\n\t\treturn set_msr_mce(vcpu, msr, data);\n\n\tcase MSR_K7_PERFCTR0 ... MSR_K7_PERFCTR3:\n\tcase MSR_P6_PERFCTR0 ... MSR_P6_PERFCTR1:\n\t\tpr = true; /* fall through */\n\tcase MSR_K7_EVNTSEL0 ... MSR_K7_EVNTSEL3:\n\tcase MSR_P6_EVNTSEL0 ... MSR_P6_EVNTSEL1:\n\t\tif (kvm_pmu_is_valid_msr(vcpu, msr))\n\t\t\treturn kvm_pmu_set_msr(vcpu, msr_info);\n\n\t\tif (pr || data != 0)\n\t\t\tvcpu_unimpl(vcpu, \"disabled perfctr wrmsr: \"\n\t\t\t\t    \"0x%x data 0x%llx\\n\", msr, data);\n\t\tbreak;\n\tcase MSR_K7_CLK_CTL:\n\t\t/*\n\t\t * Ignore all writes to this no longer documented MSR.\n\t\t * Writes are only relevant for old K7 processors,\n\t\t * all pre-dating SVM, but a recommended workaround from\n\t\t * AMD for these chips. It is possible to specify the\n\t\t * affected processor models on the command line, hence\n\t\t * the need to ignore the workaround.\n\t\t */\n\t\tbreak;\n\tcase HV_X64_MSR_GUEST_OS_ID ... HV_X64_MSR_SINT15:\n\tcase HV_X64_MSR_CRASH_P0 ... HV_X64_MSR_CRASH_P4:\n\tcase HV_X64_MSR_CRASH_CTL:\n\tcase HV_X64_MSR_STIMER0_CONFIG ... HV_X64_MSR_STIMER3_COUNT:\n\t\treturn kvm_hv_set_msr_common(vcpu, msr, data,\n\t\t\t\t\t     msr_info->host_initiated);\n\tcase MSR_IA32_BBL_CR_CTL3:\n\t\t/* Drop writes to this legacy MSR -- see rdmsr\n\t\t * counterpart for further detail.\n\t\t */\n\t\tvcpu_unimpl(vcpu, \"ignored wrmsr: 0x%x data %llx\\n\", msr, data);\n\t\tbreak;\n\tcase MSR_AMD64_OSVW_ID_LENGTH:\n\t\tif (!guest_cpuid_has_osvw(vcpu))\n\t\t\treturn 1;\n\t\tvcpu->arch.osvw.length = data;\n\t\tbreak;\n\tcase MSR_AMD64_OSVW_STATUS:\n\t\tif (!guest_cpuid_has_osvw(vcpu))\n\t\t\treturn 1;\n\t\tvcpu->arch.osvw.status = data;\n\t\tbreak;\n\tdefault:\n\t\tif (msr && (msr == vcpu->kvm->arch.xen_hvm_config.msr))\n\t\t\treturn xen_hvm_config(vcpu, data);\n\t\tif (kvm_pmu_is_valid_msr(vcpu, msr))\n\t\t\treturn kvm_pmu_set_msr(vcpu, msr_info);\n\t\tif (!ignore_msrs) {\n\t\t\tvcpu_unimpl(vcpu, \"unhandled wrmsr: 0x%x data %llx\\n\",\n\t\t\t\t    msr, data);\n\t\t\treturn 1;\n\t\t} else {\n\t\t\tvcpu_unimpl(vcpu, \"ignored wrmsr: 0x%x data %llx\\n\",\n\t\t\t\t    msr, data);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define KVM_MAX_MCE_BANKS 32"
          ],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define KVM_MAX_MCE_BANKS 32\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nint kvm_set_msr_common(struct kvm_vcpu *vcpu, struct msr_data *msr_info)\n{\n\tbool pr = false;\n\tu32 msr = msr_info->index;\n\tu64 data = msr_info->data;\n\n\tswitch (msr) {\n\tcase MSR_AMD64_NB_CFG:\n\tcase MSR_IA32_UCODE_REV:\n\tcase MSR_IA32_UCODE_WRITE:\n\tcase MSR_VM_HSAVE_PA:\n\tcase MSR_AMD64_PATCH_LOADER:\n\tcase MSR_AMD64_BU_CFG2:\n\t\tbreak;\n\n\tcase MSR_EFER:\n\t\treturn set_efer(vcpu, data);\n\tcase MSR_K7_HWCR:\n\t\tdata &= ~(u64)0x40;\t/* ignore flush filter disable */\n\t\tdata &= ~(u64)0x100;\t/* ignore ignne emulation enable */\n\t\tdata &= ~(u64)0x8;\t/* ignore TLB cache disable */\n\t\tdata &= ~(u64)0x40000;  /* ignore Mc status write enable */\n\t\tif (data != 0) {\n\t\t\tvcpu_unimpl(vcpu, \"unimplemented HWCR wrmsr: 0x%llx\\n\",\n\t\t\t\t    data);\n\t\t\treturn 1;\n\t\t}\n\t\tbreak;\n\tcase MSR_FAM10H_MMIO_CONF_BASE:\n\t\tif (data != 0) {\n\t\t\tvcpu_unimpl(vcpu, \"unimplemented MMIO_CONF_BASE wrmsr: \"\n\t\t\t\t    \"0x%llx\\n\", data);\n\t\t\treturn 1;\n\t\t}\n\t\tbreak;\n\tcase MSR_IA32_DEBUGCTLMSR:\n\t\tif (!data) {\n\t\t\t/* We support the non-activated case already */\n\t\t\tbreak;\n\t\t} else if (data & ~(DEBUGCTLMSR_LBR | DEBUGCTLMSR_BTF)) {\n\t\t\t/* Values other than LBR and BTF are vendor-specific,\n\t\t\t   thus reserved and should throw a #GP */\n\t\t\treturn 1;\n\t\t}\n\t\tvcpu_unimpl(vcpu, \"%s: MSR_IA32_DEBUGCTLMSR 0x%llx, nop\\n\",\n\t\t\t    __func__, data);\n\t\tbreak;\n\tcase 0x200 ... 0x2ff:\n\t\treturn kvm_mtrr_set_msr(vcpu, msr, data);\n\tcase MSR_IA32_APICBASE:\n\t\treturn kvm_set_apic_base(vcpu, msr_info);\n\tcase APIC_BASE_MSR ... APIC_BASE_MSR + 0x3ff:\n\t\treturn kvm_x2apic_msr_write(vcpu, msr, data);\n\tcase MSR_IA32_TSCDEADLINE:\n\t\tkvm_set_lapic_tscdeadline_msr(vcpu, data);\n\t\tbreak;\n\tcase MSR_IA32_TSC_ADJUST:\n\t\tif (guest_cpuid_has_tsc_adjust(vcpu)) {\n\t\t\tif (!msr_info->host_initiated) {\n\t\t\t\ts64 adj = data - vcpu->arch.ia32_tsc_adjust_msr;\n\t\t\t\tadjust_tsc_offset_guest(vcpu, adj);\n\t\t\t}\n\t\t\tvcpu->arch.ia32_tsc_adjust_msr = data;\n\t\t}\n\t\tbreak;\n\tcase MSR_IA32_MISC_ENABLE:\n\t\tvcpu->arch.ia32_misc_enable_msr = data;\n\t\tbreak;\n\tcase MSR_IA32_SMBASE:\n\t\tif (!msr_info->host_initiated)\n\t\t\treturn 1;\n\t\tvcpu->arch.smbase = data;\n\t\tbreak;\n\tcase MSR_KVM_WALL_CLOCK_NEW:\n\tcase MSR_KVM_WALL_CLOCK:\n\t\tvcpu->kvm->arch.wall_clock = data;\n\t\tkvm_write_wall_clock(vcpu->kvm, data);\n\t\tbreak;\n\tcase MSR_KVM_SYSTEM_TIME_NEW:\n\tcase MSR_KVM_SYSTEM_TIME: {\n\t\tu64 gpa_offset;\n\t\tstruct kvm_arch *ka = &vcpu->kvm->arch;\n\n\t\tkvmclock_reset(vcpu);\n\n\t\tif (vcpu->vcpu_id == 0 && !msr_info->host_initiated) {\n\t\t\tbool tmp = (msr == MSR_KVM_SYSTEM_TIME);\n\n\t\t\tif (ka->boot_vcpu_runs_old_kvmclock != tmp)\n\t\t\t\tset_bit(KVM_REQ_MASTERCLOCK_UPDATE,\n\t\t\t\t\t&vcpu->requests);\n\n\t\t\tka->boot_vcpu_runs_old_kvmclock = tmp;\n\t\t}\n\n\t\tvcpu->arch.time = data;\n\t\tkvm_make_request(KVM_REQ_GLOBAL_CLOCK_UPDATE, vcpu);\n\n\t\t/* we verify if the enable bit is set... */\n\t\tif (!(data & 1))\n\t\t\tbreak;\n\n\t\tgpa_offset = data & ~(PAGE_MASK | 1);\n\n\t\tif (kvm_gfn_to_hva_cache_init(vcpu->kvm,\n\t\t     &vcpu->arch.pv_time, data & ~1ULL,\n\t\t     sizeof(struct pvclock_vcpu_time_info)))\n\t\t\tvcpu->arch.pv_time_enabled = false;\n\t\telse\n\t\t\tvcpu->arch.pv_time_enabled = true;\n\n\t\tbreak;\n\t}\n\tcase MSR_KVM_ASYNC_PF_EN:\n\t\tif (kvm_pv_enable_async_pf(vcpu, data))\n\t\t\treturn 1;\n\t\tbreak;\n\tcase MSR_KVM_STEAL_TIME:\n\n\t\tif (unlikely(!sched_info_on()))\n\t\t\treturn 1;\n\n\t\tif (data & KVM_STEAL_RESERVED_MASK)\n\t\t\treturn 1;\n\n\t\tif (kvm_gfn_to_hva_cache_init(vcpu->kvm, &vcpu->arch.st.stime,\n\t\t\t\t\t\tdata & KVM_STEAL_VALID_BITS,\n\t\t\t\t\t\tsizeof(struct kvm_steal_time)))\n\t\t\treturn 1;\n\n\t\tvcpu->arch.st.msr_val = data;\n\n\t\tif (!(data & KVM_MSR_ENABLED))\n\t\t\tbreak;\n\n\t\tkvm_make_request(KVM_REQ_STEAL_UPDATE, vcpu);\n\n\t\tbreak;\n\tcase MSR_KVM_PV_EOI_EN:\n\t\tif (kvm_lapic_enable_pv_eoi(vcpu, data))\n\t\t\treturn 1;\n\t\tbreak;\n\n\tcase MSR_IA32_MCG_CTL:\n\tcase MSR_IA32_MCG_STATUS:\n\tcase MSR_IA32_MC0_CTL ... MSR_IA32_MCx_CTL(KVM_MAX_MCE_BANKS) - 1:\n\t\treturn set_msr_mce(vcpu, msr, data);\n\n\tcase MSR_K7_PERFCTR0 ... MSR_K7_PERFCTR3:\n\tcase MSR_P6_PERFCTR0 ... MSR_P6_PERFCTR1:\n\t\tpr = true; /* fall through */\n\tcase MSR_K7_EVNTSEL0 ... MSR_K7_EVNTSEL3:\n\tcase MSR_P6_EVNTSEL0 ... MSR_P6_EVNTSEL1:\n\t\tif (kvm_pmu_is_valid_msr(vcpu, msr))\n\t\t\treturn kvm_pmu_set_msr(vcpu, msr_info);\n\n\t\tif (pr || data != 0)\n\t\t\tvcpu_unimpl(vcpu, \"disabled perfctr wrmsr: \"\n\t\t\t\t    \"0x%x data 0x%llx\\n\", msr, data);\n\t\tbreak;\n\tcase MSR_K7_CLK_CTL:\n\t\t/*\n\t\t * Ignore all writes to this no longer documented MSR.\n\t\t * Writes are only relevant for old K7 processors,\n\t\t * all pre-dating SVM, but a recommended workaround from\n\t\t * AMD for these chips. It is possible to specify the\n\t\t * affected processor models on the command line, hence\n\t\t * the need to ignore the workaround.\n\t\t */\n\t\tbreak;\n\tcase HV_X64_MSR_GUEST_OS_ID ... HV_X64_MSR_SINT15:\n\tcase HV_X64_MSR_CRASH_P0 ... HV_X64_MSR_CRASH_P4:\n\tcase HV_X64_MSR_CRASH_CTL:\n\tcase HV_X64_MSR_STIMER0_CONFIG ... HV_X64_MSR_STIMER3_COUNT:\n\t\treturn kvm_hv_set_msr_common(vcpu, msr, data,\n\t\t\t\t\t     msr_info->host_initiated);\n\tcase MSR_IA32_BBL_CR_CTL3:\n\t\t/* Drop writes to this legacy MSR -- see rdmsr\n\t\t * counterpart for further detail.\n\t\t */\n\t\tvcpu_unimpl(vcpu, \"ignored wrmsr: 0x%x data %llx\\n\", msr, data);\n\t\tbreak;\n\tcase MSR_AMD64_OSVW_ID_LENGTH:\n\t\tif (!guest_cpuid_has_osvw(vcpu))\n\t\t\treturn 1;\n\t\tvcpu->arch.osvw.length = data;\n\t\tbreak;\n\tcase MSR_AMD64_OSVW_STATUS:\n\t\tif (!guest_cpuid_has_osvw(vcpu))\n\t\t\treturn 1;\n\t\tvcpu->arch.osvw.status = data;\n\t\tbreak;\n\tdefault:\n\t\tif (msr && (msr == vcpu->kvm->arch.xen_hvm_config.msr))\n\t\t\treturn xen_hvm_config(vcpu, data);\n\t\tif (kvm_pmu_is_valid_msr(vcpu, msr))\n\t\t\treturn kvm_pmu_set_msr(vcpu, msr_info);\n\t\tif (!ignore_msrs) {\n\t\t\tvcpu_unimpl(vcpu, \"unhandled wrmsr: 0x%x data %llx\\n\",\n\t\t\t\t    msr, data);\n\t\t\treturn 1;\n\t\t} else {\n\t\t\tvcpu_unimpl(vcpu, \"ignored wrmsr: 0x%x data %llx\\n\",\n\t\t\t\t    msr, data);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic int do_set_msr(struct kvm_vcpu *vcpu, unsigned index, u64 *data)\n{\n\tstruct msr_data msr;\n\n\tmsr.data = *data;\n\tmsr.index = index;\n\tmsr.host_initiated = true;\n\treturn kvm_set_msr(vcpu, &msr);\n}"
  },
  {
    "function_name": "do_get_msr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "1083-1096",
    "snippet": "static int do_get_msr(struct kvm_vcpu *vcpu, unsigned index, u64 *data)\n{\n\tstruct msr_data msr;\n\tint r;\n\n\tmsr.index = index;\n\tmsr.host_initiated = true;\n\tr = kvm_get_msr(vcpu, &msr);\n\tif (r)\n\t\treturn r;\n\n\t*data = msr.data;\n\treturn 0;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_get_msr",
          "args": [
            "vcpu",
            "&msr"
          ],
          "line": 1090
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_get_msr_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "2298-2458",
          "snippet": "int kvm_get_msr_common(struct kvm_vcpu *vcpu, struct msr_data *msr_info)\n{\n\tswitch (msr_info->index) {\n\tcase MSR_IA32_PLATFORM_ID:\n\tcase MSR_IA32_EBL_CR_POWERON:\n\tcase MSR_IA32_DEBUGCTLMSR:\n\tcase MSR_IA32_LASTBRANCHFROMIP:\n\tcase MSR_IA32_LASTBRANCHTOIP:\n\tcase MSR_IA32_LASTINTFROMIP:\n\tcase MSR_IA32_LASTINTTOIP:\n\tcase MSR_K8_SYSCFG:\n\tcase MSR_K8_TSEG_ADDR:\n\tcase MSR_K8_TSEG_MASK:\n\tcase MSR_K7_HWCR:\n\tcase MSR_VM_HSAVE_PA:\n\tcase MSR_K8_INT_PENDING_MSG:\n\tcase MSR_AMD64_NB_CFG:\n\tcase MSR_FAM10H_MMIO_CONF_BASE:\n\tcase MSR_AMD64_BU_CFG2:\n\t\tmsr_info->data = 0;\n\t\tbreak;\n\tcase MSR_K7_EVNTSEL0 ... MSR_K7_EVNTSEL3:\n\tcase MSR_K7_PERFCTR0 ... MSR_K7_PERFCTR3:\n\tcase MSR_P6_PERFCTR0 ... MSR_P6_PERFCTR1:\n\tcase MSR_P6_EVNTSEL0 ... MSR_P6_EVNTSEL1:\n\t\tif (kvm_pmu_is_valid_msr(vcpu, msr_info->index))\n\t\t\treturn kvm_pmu_get_msr(vcpu, msr_info->index, &msr_info->data);\n\t\tmsr_info->data = 0;\n\t\tbreak;\n\tcase MSR_IA32_UCODE_REV:\n\t\tmsr_info->data = 0x100000000ULL;\n\t\tbreak;\n\tcase MSR_MTRRcap:\n\tcase 0x200 ... 0x2ff:\n\t\treturn kvm_mtrr_get_msr(vcpu, msr_info->index, &msr_info->data);\n\tcase 0xcd: /* fsb frequency */\n\t\tmsr_info->data = 3;\n\t\tbreak;\n\t\t/*\n\t\t * MSR_EBC_FREQUENCY_ID\n\t\t * Conservative value valid for even the basic CPU models.\n\t\t * Models 0,1: 000 in bits 23:21 indicating a bus speed of\n\t\t * 100MHz, model 2 000 in bits 18:16 indicating 100MHz,\n\t\t * and 266MHz for model 3, or 4. Set Core Clock\n\t\t * Frequency to System Bus Frequency Ratio to 1 (bits\n\t\t * 31:24) even though these are only valid for CPU\n\t\t * models > 2, however guests may end up dividing or\n\t\t * multiplying by zero otherwise.\n\t\t */\n\tcase MSR_EBC_FREQUENCY_ID:\n\t\tmsr_info->data = 1 << 24;\n\t\tbreak;\n\tcase MSR_IA32_APICBASE:\n\t\tmsr_info->data = kvm_get_apic_base(vcpu);\n\t\tbreak;\n\tcase APIC_BASE_MSR ... APIC_BASE_MSR + 0x3ff:\n\t\treturn kvm_x2apic_msr_read(vcpu, msr_info->index, &msr_info->data);\n\t\tbreak;\n\tcase MSR_IA32_TSCDEADLINE:\n\t\tmsr_info->data = kvm_get_lapic_tscdeadline_msr(vcpu);\n\t\tbreak;\n\tcase MSR_IA32_TSC_ADJUST:\n\t\tmsr_info->data = (u64)vcpu->arch.ia32_tsc_adjust_msr;\n\t\tbreak;\n\tcase MSR_IA32_MISC_ENABLE:\n\t\tmsr_info->data = vcpu->arch.ia32_misc_enable_msr;\n\t\tbreak;\n\tcase MSR_IA32_SMBASE:\n\t\tif (!msr_info->host_initiated)\n\t\t\treturn 1;\n\t\tmsr_info->data = vcpu->arch.smbase;\n\t\tbreak;\n\tcase MSR_IA32_PERF_STATUS:\n\t\t/* TSC increment by tick */\n\t\tmsr_info->data = 1000ULL;\n\t\t/* CPU multiplier */\n\t\tmsr_info->data |= (((uint64_t)4ULL) << 40);\n\t\tbreak;\n\tcase MSR_EFER:\n\t\tmsr_info->data = vcpu->arch.efer;\n\t\tbreak;\n\tcase MSR_KVM_WALL_CLOCK:\n\tcase MSR_KVM_WALL_CLOCK_NEW:\n\t\tmsr_info->data = vcpu->kvm->arch.wall_clock;\n\t\tbreak;\n\tcase MSR_KVM_SYSTEM_TIME:\n\tcase MSR_KVM_SYSTEM_TIME_NEW:\n\t\tmsr_info->data = vcpu->arch.time;\n\t\tbreak;\n\tcase MSR_KVM_ASYNC_PF_EN:\n\t\tmsr_info->data = vcpu->arch.apf.msr_val;\n\t\tbreak;\n\tcase MSR_KVM_STEAL_TIME:\n\t\tmsr_info->data = vcpu->arch.st.msr_val;\n\t\tbreak;\n\tcase MSR_KVM_PV_EOI_EN:\n\t\tmsr_info->data = vcpu->arch.pv_eoi.msr_val;\n\t\tbreak;\n\tcase MSR_IA32_P5_MC_ADDR:\n\tcase MSR_IA32_P5_MC_TYPE:\n\tcase MSR_IA32_MCG_CAP:\n\tcase MSR_IA32_MCG_CTL:\n\tcase MSR_IA32_MCG_STATUS:\n\tcase MSR_IA32_MC0_CTL ... MSR_IA32_MCx_CTL(KVM_MAX_MCE_BANKS) - 1:\n\t\treturn get_msr_mce(vcpu, msr_info->index, &msr_info->data);\n\tcase MSR_K7_CLK_CTL:\n\t\t/*\n\t\t * Provide expected ramp-up count for K7. All other\n\t\t * are set to zero, indicating minimum divisors for\n\t\t * every field.\n\t\t *\n\t\t * This prevents guest kernels on AMD host with CPU\n\t\t * type 6, model 8 and higher from exploding due to\n\t\t * the rdmsr failing.\n\t\t */\n\t\tmsr_info->data = 0x20000000;\n\t\tbreak;\n\tcase HV_X64_MSR_GUEST_OS_ID ... HV_X64_MSR_SINT15:\n\tcase HV_X64_MSR_CRASH_P0 ... HV_X64_MSR_CRASH_P4:\n\tcase HV_X64_MSR_CRASH_CTL:\n\tcase HV_X64_MSR_STIMER0_CONFIG ... HV_X64_MSR_STIMER3_COUNT:\n\t\treturn kvm_hv_get_msr_common(vcpu,\n\t\t\t\t\t     msr_info->index, &msr_info->data);\n\t\tbreak;\n\tcase MSR_IA32_BBL_CR_CTL3:\n\t\t/* This legacy MSR exists but isn't fully documented in current\n\t\t * silicon.  It is however accessed by winxp in very narrow\n\t\t * scenarios where it sets bit #19, itself documented as\n\t\t * a \"reserved\" bit.  Best effort attempt to source coherent\n\t\t * read data here should the balance of the register be\n\t\t * interpreted by the guest:\n\t\t *\n\t\t * L2 cache control register 3: 64GB range, 256KB size,\n\t\t * enabled, latency 0x1, configured\n\t\t */\n\t\tmsr_info->data = 0xbe702111;\n\t\tbreak;\n\tcase MSR_AMD64_OSVW_ID_LENGTH:\n\t\tif (!guest_cpuid_has_osvw(vcpu))\n\t\t\treturn 1;\n\t\tmsr_info->data = vcpu->arch.osvw.length;\n\t\tbreak;\n\tcase MSR_AMD64_OSVW_STATUS:\n\t\tif (!guest_cpuid_has_osvw(vcpu))\n\t\t\treturn 1;\n\t\tmsr_info->data = vcpu->arch.osvw.status;\n\t\tbreak;\n\tdefault:\n\t\tif (kvm_pmu_is_valid_msr(vcpu, msr_info->index))\n\t\t\treturn kvm_pmu_get_msr(vcpu, msr_info->index, &msr_info->data);\n\t\tif (!ignore_msrs) {\n\t\t\tvcpu_unimpl(vcpu, \"unhandled rdmsr: 0x%x\\n\", msr_info->index);\n\t\t\treturn 1;\n\t\t} else {\n\t\t\tvcpu_unimpl(vcpu, \"ignored rdmsr: 0x%x\\n\", msr_info->index);\n\t\t\tmsr_info->data = 0;\n\t\t}\n\t\tbreak;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define KVM_MAX_MCE_BANKS 32"
          ],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define KVM_MAX_MCE_BANKS 32\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nint kvm_get_msr_common(struct kvm_vcpu *vcpu, struct msr_data *msr_info)\n{\n\tswitch (msr_info->index) {\n\tcase MSR_IA32_PLATFORM_ID:\n\tcase MSR_IA32_EBL_CR_POWERON:\n\tcase MSR_IA32_DEBUGCTLMSR:\n\tcase MSR_IA32_LASTBRANCHFROMIP:\n\tcase MSR_IA32_LASTBRANCHTOIP:\n\tcase MSR_IA32_LASTINTFROMIP:\n\tcase MSR_IA32_LASTINTTOIP:\n\tcase MSR_K8_SYSCFG:\n\tcase MSR_K8_TSEG_ADDR:\n\tcase MSR_K8_TSEG_MASK:\n\tcase MSR_K7_HWCR:\n\tcase MSR_VM_HSAVE_PA:\n\tcase MSR_K8_INT_PENDING_MSG:\n\tcase MSR_AMD64_NB_CFG:\n\tcase MSR_FAM10H_MMIO_CONF_BASE:\n\tcase MSR_AMD64_BU_CFG2:\n\t\tmsr_info->data = 0;\n\t\tbreak;\n\tcase MSR_K7_EVNTSEL0 ... MSR_K7_EVNTSEL3:\n\tcase MSR_K7_PERFCTR0 ... MSR_K7_PERFCTR3:\n\tcase MSR_P6_PERFCTR0 ... MSR_P6_PERFCTR1:\n\tcase MSR_P6_EVNTSEL0 ... MSR_P6_EVNTSEL1:\n\t\tif (kvm_pmu_is_valid_msr(vcpu, msr_info->index))\n\t\t\treturn kvm_pmu_get_msr(vcpu, msr_info->index, &msr_info->data);\n\t\tmsr_info->data = 0;\n\t\tbreak;\n\tcase MSR_IA32_UCODE_REV:\n\t\tmsr_info->data = 0x100000000ULL;\n\t\tbreak;\n\tcase MSR_MTRRcap:\n\tcase 0x200 ... 0x2ff:\n\t\treturn kvm_mtrr_get_msr(vcpu, msr_info->index, &msr_info->data);\n\tcase 0xcd: /* fsb frequency */\n\t\tmsr_info->data = 3;\n\t\tbreak;\n\t\t/*\n\t\t * MSR_EBC_FREQUENCY_ID\n\t\t * Conservative value valid for even the basic CPU models.\n\t\t * Models 0,1: 000 in bits 23:21 indicating a bus speed of\n\t\t * 100MHz, model 2 000 in bits 18:16 indicating 100MHz,\n\t\t * and 266MHz for model 3, or 4. Set Core Clock\n\t\t * Frequency to System Bus Frequency Ratio to 1 (bits\n\t\t * 31:24) even though these are only valid for CPU\n\t\t * models > 2, however guests may end up dividing or\n\t\t * multiplying by zero otherwise.\n\t\t */\n\tcase MSR_EBC_FREQUENCY_ID:\n\t\tmsr_info->data = 1 << 24;\n\t\tbreak;\n\tcase MSR_IA32_APICBASE:\n\t\tmsr_info->data = kvm_get_apic_base(vcpu);\n\t\tbreak;\n\tcase APIC_BASE_MSR ... APIC_BASE_MSR + 0x3ff:\n\t\treturn kvm_x2apic_msr_read(vcpu, msr_info->index, &msr_info->data);\n\t\tbreak;\n\tcase MSR_IA32_TSCDEADLINE:\n\t\tmsr_info->data = kvm_get_lapic_tscdeadline_msr(vcpu);\n\t\tbreak;\n\tcase MSR_IA32_TSC_ADJUST:\n\t\tmsr_info->data = (u64)vcpu->arch.ia32_tsc_adjust_msr;\n\t\tbreak;\n\tcase MSR_IA32_MISC_ENABLE:\n\t\tmsr_info->data = vcpu->arch.ia32_misc_enable_msr;\n\t\tbreak;\n\tcase MSR_IA32_SMBASE:\n\t\tif (!msr_info->host_initiated)\n\t\t\treturn 1;\n\t\tmsr_info->data = vcpu->arch.smbase;\n\t\tbreak;\n\tcase MSR_IA32_PERF_STATUS:\n\t\t/* TSC increment by tick */\n\t\tmsr_info->data = 1000ULL;\n\t\t/* CPU multiplier */\n\t\tmsr_info->data |= (((uint64_t)4ULL) << 40);\n\t\tbreak;\n\tcase MSR_EFER:\n\t\tmsr_info->data = vcpu->arch.efer;\n\t\tbreak;\n\tcase MSR_KVM_WALL_CLOCK:\n\tcase MSR_KVM_WALL_CLOCK_NEW:\n\t\tmsr_info->data = vcpu->kvm->arch.wall_clock;\n\t\tbreak;\n\tcase MSR_KVM_SYSTEM_TIME:\n\tcase MSR_KVM_SYSTEM_TIME_NEW:\n\t\tmsr_info->data = vcpu->arch.time;\n\t\tbreak;\n\tcase MSR_KVM_ASYNC_PF_EN:\n\t\tmsr_info->data = vcpu->arch.apf.msr_val;\n\t\tbreak;\n\tcase MSR_KVM_STEAL_TIME:\n\t\tmsr_info->data = vcpu->arch.st.msr_val;\n\t\tbreak;\n\tcase MSR_KVM_PV_EOI_EN:\n\t\tmsr_info->data = vcpu->arch.pv_eoi.msr_val;\n\t\tbreak;\n\tcase MSR_IA32_P5_MC_ADDR:\n\tcase MSR_IA32_P5_MC_TYPE:\n\tcase MSR_IA32_MCG_CAP:\n\tcase MSR_IA32_MCG_CTL:\n\tcase MSR_IA32_MCG_STATUS:\n\tcase MSR_IA32_MC0_CTL ... MSR_IA32_MCx_CTL(KVM_MAX_MCE_BANKS) - 1:\n\t\treturn get_msr_mce(vcpu, msr_info->index, &msr_info->data);\n\tcase MSR_K7_CLK_CTL:\n\t\t/*\n\t\t * Provide expected ramp-up count for K7. All other\n\t\t * are set to zero, indicating minimum divisors for\n\t\t * every field.\n\t\t *\n\t\t * This prevents guest kernels on AMD host with CPU\n\t\t * type 6, model 8 and higher from exploding due to\n\t\t * the rdmsr failing.\n\t\t */\n\t\tmsr_info->data = 0x20000000;\n\t\tbreak;\n\tcase HV_X64_MSR_GUEST_OS_ID ... HV_X64_MSR_SINT15:\n\tcase HV_X64_MSR_CRASH_P0 ... HV_X64_MSR_CRASH_P4:\n\tcase HV_X64_MSR_CRASH_CTL:\n\tcase HV_X64_MSR_STIMER0_CONFIG ... HV_X64_MSR_STIMER3_COUNT:\n\t\treturn kvm_hv_get_msr_common(vcpu,\n\t\t\t\t\t     msr_info->index, &msr_info->data);\n\t\tbreak;\n\tcase MSR_IA32_BBL_CR_CTL3:\n\t\t/* This legacy MSR exists but isn't fully documented in current\n\t\t * silicon.  It is however accessed by winxp in very narrow\n\t\t * scenarios where it sets bit #19, itself documented as\n\t\t * a \"reserved\" bit.  Best effort attempt to source coherent\n\t\t * read data here should the balance of the register be\n\t\t * interpreted by the guest:\n\t\t *\n\t\t * L2 cache control register 3: 64GB range, 256KB size,\n\t\t * enabled, latency 0x1, configured\n\t\t */\n\t\tmsr_info->data = 0xbe702111;\n\t\tbreak;\n\tcase MSR_AMD64_OSVW_ID_LENGTH:\n\t\tif (!guest_cpuid_has_osvw(vcpu))\n\t\t\treturn 1;\n\t\tmsr_info->data = vcpu->arch.osvw.length;\n\t\tbreak;\n\tcase MSR_AMD64_OSVW_STATUS:\n\t\tif (!guest_cpuid_has_osvw(vcpu))\n\t\t\treturn 1;\n\t\tmsr_info->data = vcpu->arch.osvw.status;\n\t\tbreak;\n\tdefault:\n\t\tif (kvm_pmu_is_valid_msr(vcpu, msr_info->index))\n\t\t\treturn kvm_pmu_get_msr(vcpu, msr_info->index, &msr_info->data);\n\t\tif (!ignore_msrs) {\n\t\t\tvcpu_unimpl(vcpu, \"unhandled rdmsr: 0x%x\\n\", msr_info->index);\n\t\t\treturn 1;\n\t\t} else {\n\t\t\tvcpu_unimpl(vcpu, \"ignored rdmsr: 0x%x\\n\", msr_info->index);\n\t\t\tmsr_info->data = 0;\n\t\t}\n\t\tbreak;\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic int do_get_msr(struct kvm_vcpu *vcpu, unsigned index, u64 *data)\n{\n\tstruct msr_data msr;\n\tint r;\n\n\tmsr.index = index;\n\tmsr.host_initiated = true;\n\tr = kvm_get_msr(vcpu, &msr);\n\tif (r)\n\t\treturn r;\n\n\t*data = msr.data;\n\treturn 0;\n}"
  },
  {
    "function_name": "kvm_set_msr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "1049-1077",
    "snippet": "int kvm_set_msr(struct kvm_vcpu *vcpu, struct msr_data *msr)\n{\n\tswitch (msr->index) {\n\tcase MSR_FS_BASE:\n\tcase MSR_GS_BASE:\n\tcase MSR_KERNEL_GS_BASE:\n\tcase MSR_CSTAR:\n\tcase MSR_LSTAR:\n\t\tif (is_noncanonical_address(msr->data))\n\t\t\treturn 1;\n\t\tbreak;\n\tcase MSR_IA32_SYSENTER_EIP:\n\tcase MSR_IA32_SYSENTER_ESP:\n\t\t/*\n\t\t * IA32_SYSENTER_ESP and IA32_SYSENTER_EIP cause #GP if\n\t\t * non-canonical address is written on Intel but not on\n\t\t * AMD (which ignores the top 32-bits, because it does\n\t\t * not implement 64-bit SYSENTER).\n\t\t *\n\t\t * 64-bit code should hence be able to write a non-canonical\n\t\t * value on AMD.  Making the address canonical ensures that\n\t\t * vmentry does not fail on Intel after writing a non-canonical\n\t\t * value, and that something deterministic happens if the guest\n\t\t * invokes 64-bit SYSENTER.\n\t\t */\n\t\tmsr->data = get_canonical(msr->data);\n\t}\n\treturn kvm_x86_ops->set_msr(vcpu, msr);\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);",
      "struct kvm_x86_ops *kvm_x86_ops"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_x86_ops->set_msr",
          "args": [
            "vcpu",
            "msr"
          ],
          "line": 1076
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_canonical",
          "args": [
            "msr->data"
          ],
          "line": 1074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_noncanonical_address",
          "args": [
            "msr->data"
          ],
          "line": 1057
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nint kvm_set_msr(struct kvm_vcpu *vcpu, struct msr_data *msr)\n{\n\tswitch (msr->index) {\n\tcase MSR_FS_BASE:\n\tcase MSR_GS_BASE:\n\tcase MSR_KERNEL_GS_BASE:\n\tcase MSR_CSTAR:\n\tcase MSR_LSTAR:\n\t\tif (is_noncanonical_address(msr->data))\n\t\t\treturn 1;\n\t\tbreak;\n\tcase MSR_IA32_SYSENTER_EIP:\n\tcase MSR_IA32_SYSENTER_ESP:\n\t\t/*\n\t\t * IA32_SYSENTER_ESP and IA32_SYSENTER_EIP cause #GP if\n\t\t * non-canonical address is written on Intel but not on\n\t\t * AMD (which ignores the top 32-bits, because it does\n\t\t * not implement 64-bit SYSENTER).\n\t\t *\n\t\t * 64-bit code should hence be able to write a non-canonical\n\t\t * value on AMD.  Making the address canonical ensures that\n\t\t * vmentry does not fail on Intel after writing a non-canonical\n\t\t * value, and that something deterministic happens if the guest\n\t\t * invokes 64-bit SYSENTER.\n\t\t */\n\t\tmsr->data = get_canonical(msr->data);\n\t}\n\treturn kvm_x86_ops->set_msr(vcpu, msr);\n}"
  },
  {
    "function_name": "kvm_enable_efer_bits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "1038-1041",
    "snippet": "void kvm_enable_efer_bits(u64 mask)\n{\n       efer_reserved_bits &= ~mask;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nvoid kvm_enable_efer_bits(u64 mask)\n{\n       efer_reserved_bits &= ~mask;\n}"
  },
  {
    "function_name": "set_efer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "1015-1036",
    "snippet": "static int set_efer(struct kvm_vcpu *vcpu, u64 efer)\n{\n\tu64 old_efer = vcpu->arch.efer;\n\n\tif (!kvm_valid_efer(vcpu, efer))\n\t\treturn 1;\n\n\tif (is_paging(vcpu)\n\t    && (vcpu->arch.efer & EFER_LME) != (efer & EFER_LME))\n\t\treturn 1;\n\n\tefer &= ~EFER_LMA;\n\tefer |= vcpu->arch.efer & EFER_LMA;\n\n\tkvm_x86_ops->set_efer(vcpu, efer);\n\n\t/* Update reserved bits */\n\tif ((efer ^ old_efer) & EFER_NX)\n\t\tkvm_mmu_reset_context(vcpu);\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);",
      "struct kvm_x86_ops *kvm_x86_ops"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_mmu_reset_context",
          "args": [
            "vcpu"
          ],
          "line": 1033
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_reset_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "4230-4234",
          "snippet": "void kvm_mmu_reset_context(struct kvm_vcpu *vcpu)\n{\n\tkvm_mmu_unload(vcpu);\n\tinit_kvm_mmu(vcpu);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nvoid kvm_mmu_reset_context(struct kvm_vcpu *vcpu)\n{\n\tkvm_mmu_unload(vcpu);\n\tinit_kvm_mmu(vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_x86_ops->set_efer",
          "args": [
            "vcpu",
            "efer"
          ],
          "line": 1029
        },
        "resolved": true,
        "details": {
          "function_name": "set_efer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "1015-1036",
          "snippet": "static int set_efer(struct kvm_vcpu *vcpu, u64 efer)\n{\n\tu64 old_efer = vcpu->arch.efer;\n\n\tif (!kvm_valid_efer(vcpu, efer))\n\t\treturn 1;\n\n\tif (is_paging(vcpu)\n\t    && (vcpu->arch.efer & EFER_LME) != (efer & EFER_LME))\n\t\treturn 1;\n\n\tefer &= ~EFER_LMA;\n\tefer |= vcpu->arch.efer & EFER_LMA;\n\n\tkvm_x86_ops->set_efer(vcpu, efer);\n\n\t/* Update reserved bits */\n\tif ((efer ^ old_efer) & EFER_NX)\n\t\tkvm_mmu_reset_context(vcpu);\n\n\treturn 0;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "is_paging",
          "args": [
            "vcpu"
          ],
          "line": 1022
        },
        "resolved": true,
        "details": {
          "function_name": "is_paging",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.h",
          "lines": "77-80",
          "snippet": "static inline int is_paging(struct kvm_vcpu *vcpu)\n{\n\treturn likely(kvm_read_cr0_bits(vcpu, X86_CR0_PG));\n}",
          "includes": [
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline int is_paging(struct kvm_vcpu *vcpu)\n{\n\treturn likely(kvm_read_cr0_bits(vcpu, X86_CR0_PG));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_valid_efer",
          "args": [
            "vcpu",
            "efer"
          ],
          "line": 1019
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_valid_efer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "990-1012",
          "snippet": "bool kvm_valid_efer(struct kvm_vcpu *vcpu, u64 efer)\n{\n\tif (efer & efer_reserved_bits)\n\t\treturn false;\n\n\tif (efer & EFER_FFXSR) {\n\t\tstruct kvm_cpuid_entry2 *feat;\n\n\t\tfeat = kvm_find_cpuid_entry(vcpu, 0x80000001, 0);\n\t\tif (!feat || !(feat->edx & bit(X86_FEATURE_FXSR_OPT)))\n\t\t\treturn false;\n\t}\n\n\tif (efer & EFER_SVME) {\n\t\tstruct kvm_cpuid_entry2 *feat;\n\n\t\tfeat = kvm_find_cpuid_entry(vcpu, 0x80000001, 0);\n\t\tif (!feat || !(feat->ecx & bit(X86_FEATURE_SVM)))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nbool kvm_valid_efer(struct kvm_vcpu *vcpu, u64 efer)\n{\n\tif (efer & efer_reserved_bits)\n\t\treturn false;\n\n\tif (efer & EFER_FFXSR) {\n\t\tstruct kvm_cpuid_entry2 *feat;\n\n\t\tfeat = kvm_find_cpuid_entry(vcpu, 0x80000001, 0);\n\t\tif (!feat || !(feat->edx & bit(X86_FEATURE_FXSR_OPT)))\n\t\t\treturn false;\n\t}\n\n\tif (efer & EFER_SVME) {\n\t\tstruct kvm_cpuid_entry2 *feat;\n\n\t\tfeat = kvm_find_cpuid_entry(vcpu, 0x80000001, 0);\n\t\tif (!feat || !(feat->ecx & bit(X86_FEATURE_SVM)))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nstatic int set_efer(struct kvm_vcpu *vcpu, u64 efer)\n{\n\tu64 old_efer = vcpu->arch.efer;\n\n\tif (!kvm_valid_efer(vcpu, efer))\n\t\treturn 1;\n\n\tif (is_paging(vcpu)\n\t    && (vcpu->arch.efer & EFER_LME) != (efer & EFER_LME))\n\t\treturn 1;\n\n\tefer &= ~EFER_LMA;\n\tefer |= vcpu->arch.efer & EFER_LMA;\n\n\tkvm_x86_ops->set_efer(vcpu, efer);\n\n\t/* Update reserved bits */\n\tif ((efer ^ old_efer) & EFER_NX)\n\t\tkvm_mmu_reset_context(vcpu);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "kvm_valid_efer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "990-1012",
    "snippet": "bool kvm_valid_efer(struct kvm_vcpu *vcpu, u64 efer)\n{\n\tif (efer & efer_reserved_bits)\n\t\treturn false;\n\n\tif (efer & EFER_FFXSR) {\n\t\tstruct kvm_cpuid_entry2 *feat;\n\n\t\tfeat = kvm_find_cpuid_entry(vcpu, 0x80000001, 0);\n\t\tif (!feat || !(feat->edx & bit(X86_FEATURE_FXSR_OPT)))\n\t\t\treturn false;\n\t}\n\n\tif (efer & EFER_SVME) {\n\t\tstruct kvm_cpuid_entry2 *feat;\n\n\t\tfeat = kvm_find_cpuid_entry(vcpu, 0x80000001, 0);\n\t\tif (!feat || !(feat->ecx & bit(X86_FEATURE_SVM)))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bit",
          "args": [
            "X86_FEATURE_SVM"
          ],
          "line": 1007
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_enable_efer_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "1038-1041",
          "snippet": "void kvm_enable_efer_bits(u64 mask)\n{\n       efer_reserved_bits &= ~mask;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nvoid kvm_enable_efer_bits(u64 mask)\n{\n       efer_reserved_bits &= ~mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_find_cpuid_entry",
          "args": [
            "vcpu",
            "0x80000001",
            "0"
          ],
          "line": 1006
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_find_cpuid_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/cpuid.c",
          "lines": "794-812",
          "snippet": "struct kvm_cpuid_entry2 *kvm_find_cpuid_entry(struct kvm_vcpu *vcpu,\n\t\t\t\t\t      u32 function, u32 index)\n{\n\tint i;\n\tstruct kvm_cpuid_entry2 *best = NULL;\n\n\tfor (i = 0; i < vcpu->arch.cpuid_nent; ++i) {\n\t\tstruct kvm_cpuid_entry2 *e;\n\n\t\te = &vcpu->arch.cpuid_entries[i];\n\t\tif (is_matching_cpuid_entry(e, function, index)) {\n\t\t\tif (e->flags & KVM_CPUID_FLAG_STATEFUL_FUNC)\n\t\t\t\tmove_to_next_stateful_cpuid_entry(vcpu, i);\n\t\t\tbest = e;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn best;\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"trace.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"cpuid.h\"",
            "#include <asm/fpu/xstate.h>",
            "#include <asm/user.h>",
            "#include <asm/fpu/internal.h> /* For use_eager_fpu.  Ugh! */",
            "#include <linux/uaccess.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"trace.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include <asm/fpu/xstate.h>\n#include <asm/user.h>\n#include <asm/fpu/internal.h> /* For use_eager_fpu.  Ugh! */\n#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n\nstruct kvm_cpuid_entry2 *kvm_find_cpuid_entry(struct kvm_vcpu *vcpu,\n\t\t\t\t\t      u32 function, u32 index)\n{\n\tint i;\n\tstruct kvm_cpuid_entry2 *best = NULL;\n\n\tfor (i = 0; i < vcpu->arch.cpuid_nent; ++i) {\n\t\tstruct kvm_cpuid_entry2 *e;\n\n\t\te = &vcpu->arch.cpuid_entries[i];\n\t\tif (is_matching_cpuid_entry(e, function, index)) {\n\t\t\tif (e->flags & KVM_CPUID_FLAG_STATEFUL_FUNC)\n\t\t\t\tmove_to_next_stateful_cpuid_entry(vcpu, i);\n\t\t\tbest = e;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn best;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nbool kvm_valid_efer(struct kvm_vcpu *vcpu, u64 efer)\n{\n\tif (efer & efer_reserved_bits)\n\t\treturn false;\n\n\tif (efer & EFER_FFXSR) {\n\t\tstruct kvm_cpuid_entry2 *feat;\n\n\t\tfeat = kvm_find_cpuid_entry(vcpu, 0x80000001, 0);\n\t\tif (!feat || !(feat->edx & bit(X86_FEATURE_FXSR_OPT)))\n\t\t\treturn false;\n\t}\n\n\tif (efer & EFER_SVME) {\n\t\tstruct kvm_cpuid_entry2 *feat;\n\n\t\tfeat = kvm_find_cpuid_entry(vcpu, 0x80000001, 0);\n\t\tif (!feat || !(feat->ecx & bit(X86_FEATURE_SVM)))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}"
  },
  {
    "function_name": "kvm_rdpmc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "928-940",
    "snippet": "bool kvm_rdpmc(struct kvm_vcpu *vcpu)\n{\n\tu32 ecx = kvm_register_read(vcpu, VCPU_REGS_RCX);\n\tu64 data;\n\tint err;\n\n\terr = kvm_pmu_rdpmc(vcpu, ecx, &data);\n\tif (err)\n\t\treturn err;\n\tkvm_register_write(vcpu, VCPU_REGS_RAX, (u32)data);\n\tkvm_register_write(vcpu, VCPU_REGS_RDX, data >> 32);\n\treturn err;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_register_write",
          "args": [
            "vcpu",
            "VCPU_REGS_RDX",
            "data >> 32"
          ],
          "line": 938
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_register_writel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.h",
          "lines": "141-148",
          "snippet": "static inline void kvm_register_writel(struct kvm_vcpu *vcpu,\n\t\t\t\t       enum kvm_reg reg,\n\t\t\t\t       unsigned long val)\n{\n\tif (!is_64_bit_mode(vcpu))\n\t\tval = (u32)val;\n\treturn kvm_register_write(vcpu, reg, val);\n}",
          "includes": [
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline void kvm_register_writel(struct kvm_vcpu *vcpu,\n\t\t\t\t       enum kvm_reg reg,\n\t\t\t\t       unsigned long val)\n{\n\tif (!is_64_bit_mode(vcpu))\n\t\tval = (u32)val;\n\treturn kvm_register_write(vcpu, reg, val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_pmu_rdpmc",
          "args": [
            "vcpu",
            "ecx",
            "&data"
          ],
          "line": 934
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_pmu_rdpmc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/pmu.c",
          "lines": "240-256",
          "snippet": "int kvm_pmu_rdpmc(struct kvm_vcpu *vcpu, unsigned idx, u64 *data)\n{\n\tbool fast_mode = idx & (1u << 31);\n\tstruct kvm_pmc *pmc;\n\tu64 ctr_val;\n\n\tpmc = kvm_x86_ops->pmu_ops->msr_idx_to_pmc(vcpu, idx);\n\tif (!pmc)\n\t\treturn 1;\n\n\tctr_val = pmc_read_counter(pmc);\n\tif (fast_mode)\n\t\tctr_val = (u32)ctr_val;\n\n\t*data = ctr_val;\n\treturn 0;\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"lapic.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include <asm/perf_event.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include <asm/perf_event.h>\n#include <linux/perf_event.h>\n#include <linux/kvm_host.h>\n#include <linux/types.h>\n\nint kvm_pmu_rdpmc(struct kvm_vcpu *vcpu, unsigned idx, u64 *data)\n{\n\tbool fast_mode = idx & (1u << 31);\n\tstruct kvm_pmc *pmc;\n\tu64 ctr_val;\n\n\tpmc = kvm_x86_ops->pmu_ops->msr_idx_to_pmc(vcpu, idx);\n\tif (!pmc)\n\t\treturn 1;\n\n\tctr_val = pmc_read_counter(pmc);\n\tif (fast_mode)\n\t\tctr_val = (u32)ctr_val;\n\n\t*data = ctr_val;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_register_read",
          "args": [
            "vcpu",
            "VCPU_REGS_RCX"
          ],
          "line": 930
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_register_readl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.h",
          "lines": "133-139",
          "snippet": "static inline unsigned long kvm_register_readl(struct kvm_vcpu *vcpu,\n\t\t\t\t\t       enum kvm_reg reg)\n{\n\tunsigned long val = kvm_register_read(vcpu, reg);\n\n\treturn is_64_bit_mode(vcpu) ? val : (u32)val;\n}",
          "includes": [
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline unsigned long kvm_register_readl(struct kvm_vcpu *vcpu,\n\t\t\t\t\t       enum kvm_reg reg)\n{\n\tunsigned long val = kvm_register_read(vcpu, reg);\n\n\treturn is_64_bit_mode(vcpu) ? val : (u32)val;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nbool kvm_rdpmc(struct kvm_vcpu *vcpu)\n{\n\tu32 ecx = kvm_register_read(vcpu, VCPU_REGS_RCX);\n\tu64 data;\n\tint err;\n\n\terr = kvm_pmu_rdpmc(vcpu, ecx, &data);\n\tif (err)\n\t\treturn err;\n\tkvm_register_write(vcpu, VCPU_REGS_RAX, (u32)data);\n\tkvm_register_write(vcpu, VCPU_REGS_RDX, data >> 32);\n\treturn err;\n}"
  },
  {
    "function_name": "kvm_get_dr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "904-925",
    "snippet": "int kvm_get_dr(struct kvm_vcpu *vcpu, int dr, unsigned long *val)\n{\n\tswitch (dr) {\n\tcase 0 ... 3:\n\t\t*val = vcpu->arch.db[dr];\n\t\tbreak;\n\tcase 4:\n\t\t/* fall through */\n\tcase 6:\n\t\tif (vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP)\n\t\t\t*val = vcpu->arch.dr6;\n\t\telse\n\t\t\t*val = kvm_x86_ops->get_dr6(vcpu);\n\t\tbreak;\n\tcase 5:\n\t\t/* fall through */\n\tdefault: /* 7 */\n\t\t*val = vcpu->arch.dr7;\n\t\tbreak;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);",
      "struct kvm_x86_ops *kvm_x86_ops"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_x86_ops->get_dr6",
          "args": [
            "vcpu"
          ],
          "line": 916
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nint kvm_get_dr(struct kvm_vcpu *vcpu, int dr, unsigned long *val)\n{\n\tswitch (dr) {\n\tcase 0 ... 3:\n\t\t*val = vcpu->arch.db[dr];\n\t\tbreak;\n\tcase 4:\n\t\t/* fall through */\n\tcase 6:\n\t\tif (vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP)\n\t\t\t*val = vcpu->arch.dr6;\n\t\telse\n\t\t\t*val = kvm_x86_ops->get_dr6(vcpu);\n\t\tbreak;\n\tcase 5:\n\t\t/* fall through */\n\tdefault: /* 7 */\n\t\t*val = vcpu->arch.dr7;\n\t\tbreak;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "kvm_set_dr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "894-901",
    "snippet": "int kvm_set_dr(struct kvm_vcpu *vcpu, int dr, unsigned long val)\n{\n\tif (__kvm_set_dr(vcpu, dr, val)) {\n\t\tkvm_inject_gp(vcpu, 0);\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_inject_gp",
          "args": [
            "vcpu",
            "0"
          ],
          "line": 897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__kvm_set_dr",
          "args": [
            "vcpu",
            "dr",
            "val"
          ],
          "line": 896
        },
        "resolved": true,
        "details": {
          "function_name": "__kvm_set_dr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "865-892",
          "snippet": "static int __kvm_set_dr(struct kvm_vcpu *vcpu, int dr, unsigned long val)\n{\n\tswitch (dr) {\n\tcase 0 ... 3:\n\t\tvcpu->arch.db[dr] = val;\n\t\tif (!(vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP))\n\t\t\tvcpu->arch.eff_db[dr] = val;\n\t\tbreak;\n\tcase 4:\n\t\t/* fall through */\n\tcase 6:\n\t\tif (val & 0xffffffff00000000ULL)\n\t\t\treturn -1; /* #GP */\n\t\tvcpu->arch.dr6 = (val & DR6_VOLATILE) | kvm_dr6_fixed(vcpu);\n\t\tkvm_update_dr6(vcpu);\n\t\tbreak;\n\tcase 5:\n\t\t/* fall through */\n\tdefault: /* 7 */\n\t\tif (val & 0xffffffff00000000ULL)\n\t\t\treturn -1; /* #GP */\n\t\tvcpu->arch.dr7 = (val & DR7_VOLATILE) | DR7_FIXED_1;\n\t\tkvm_update_dr7(vcpu);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic int __kvm_set_dr(struct kvm_vcpu *vcpu, int dr, unsigned long val)\n{\n\tswitch (dr) {\n\tcase 0 ... 3:\n\t\tvcpu->arch.db[dr] = val;\n\t\tif (!(vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP))\n\t\t\tvcpu->arch.eff_db[dr] = val;\n\t\tbreak;\n\tcase 4:\n\t\t/* fall through */\n\tcase 6:\n\t\tif (val & 0xffffffff00000000ULL)\n\t\t\treturn -1; /* #GP */\n\t\tvcpu->arch.dr6 = (val & DR6_VOLATILE) | kvm_dr6_fixed(vcpu);\n\t\tkvm_update_dr6(vcpu);\n\t\tbreak;\n\tcase 5:\n\t\t/* fall through */\n\tdefault: /* 7 */\n\t\tif (val & 0xffffffff00000000ULL)\n\t\t\treturn -1; /* #GP */\n\t\tvcpu->arch.dr7 = (val & DR7_VOLATILE) | DR7_FIXED_1;\n\t\tkvm_update_dr7(vcpu);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nint kvm_set_dr(struct kvm_vcpu *vcpu, int dr, unsigned long val)\n{\n\tif (__kvm_set_dr(vcpu, dr, val)) {\n\t\tkvm_inject_gp(vcpu, 0);\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "__kvm_set_dr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "865-892",
    "snippet": "static int __kvm_set_dr(struct kvm_vcpu *vcpu, int dr, unsigned long val)\n{\n\tswitch (dr) {\n\tcase 0 ... 3:\n\t\tvcpu->arch.db[dr] = val;\n\t\tif (!(vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP))\n\t\t\tvcpu->arch.eff_db[dr] = val;\n\t\tbreak;\n\tcase 4:\n\t\t/* fall through */\n\tcase 6:\n\t\tif (val & 0xffffffff00000000ULL)\n\t\t\treturn -1; /* #GP */\n\t\tvcpu->arch.dr6 = (val & DR6_VOLATILE) | kvm_dr6_fixed(vcpu);\n\t\tkvm_update_dr6(vcpu);\n\t\tbreak;\n\tcase 5:\n\t\t/* fall through */\n\tdefault: /* 7 */\n\t\tif (val & 0xffffffff00000000ULL)\n\t\t\treturn -1; /* #GP */\n\t\tvcpu->arch.dr7 = (val & DR7_VOLATILE) | DR7_FIXED_1;\n\t\tkvm_update_dr7(vcpu);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_update_dr7",
          "args": [
            "vcpu"
          ],
          "line": 887
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_update_dr7",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "842-854",
          "snippet": "static void kvm_update_dr7(struct kvm_vcpu *vcpu)\n{\n\tunsigned long dr7;\n\n\tif (vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP)\n\t\tdr7 = vcpu->arch.guest_debug_dr7;\n\telse\n\t\tdr7 = vcpu->arch.dr7;\n\tkvm_x86_ops->set_dr7(vcpu, dr7);\n\tvcpu->arch.switch_db_regs &= ~KVM_DEBUGREG_BP_ENABLED;\n\tif (dr7 & DR7_BP_EN_MASK)\n\t\tvcpu->arch.switch_db_regs |= KVM_DEBUGREG_BP_ENABLED;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "struct kvm_x86_ops *kvm_x86_ops"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nstatic void kvm_update_dr7(struct kvm_vcpu *vcpu)\n{\n\tunsigned long dr7;\n\n\tif (vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP)\n\t\tdr7 = vcpu->arch.guest_debug_dr7;\n\telse\n\t\tdr7 = vcpu->arch.dr7;\n\tkvm_x86_ops->set_dr7(vcpu, dr7);\n\tvcpu->arch.switch_db_regs &= ~KVM_DEBUGREG_BP_ENABLED;\n\tif (dr7 & DR7_BP_EN_MASK)\n\t\tvcpu->arch.switch_db_regs |= KVM_DEBUGREG_BP_ENABLED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_update_dr6",
          "args": [
            "vcpu"
          ],
          "line": 879
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_update_dr6",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "836-840",
          "snippet": "static void kvm_update_dr6(struct kvm_vcpu *vcpu)\n{\n\tif (!(vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP))\n\t\tkvm_x86_ops->set_dr6(vcpu, vcpu->arch.dr6);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "struct kvm_x86_ops *kvm_x86_ops"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nstatic void kvm_update_dr6(struct kvm_vcpu *vcpu)\n{\n\tif (!(vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP))\n\t\tkvm_x86_ops->set_dr6(vcpu, vcpu->arch.dr6);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_dr6_fixed",
          "args": [
            "vcpu"
          ],
          "line": 878
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_dr6_fixed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "856-863",
          "snippet": "static u64 kvm_dr6_fixed(struct kvm_vcpu *vcpu)\n{\n\tu64 fixed = DR6_FIXED_1;\n\n\tif (!guest_cpuid_has_rtm(vcpu))\n\t\tfixed |= DR6_RTM;\n\treturn fixed;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic u64 kvm_dr6_fixed(struct kvm_vcpu *vcpu)\n{\n\tu64 fixed = DR6_FIXED_1;\n\n\tif (!guest_cpuid_has_rtm(vcpu))\n\t\tfixed |= DR6_RTM;\n\treturn fixed;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic int __kvm_set_dr(struct kvm_vcpu *vcpu, int dr, unsigned long val)\n{\n\tswitch (dr) {\n\tcase 0 ... 3:\n\t\tvcpu->arch.db[dr] = val;\n\t\tif (!(vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP))\n\t\t\tvcpu->arch.eff_db[dr] = val;\n\t\tbreak;\n\tcase 4:\n\t\t/* fall through */\n\tcase 6:\n\t\tif (val & 0xffffffff00000000ULL)\n\t\t\treturn -1; /* #GP */\n\t\tvcpu->arch.dr6 = (val & DR6_VOLATILE) | kvm_dr6_fixed(vcpu);\n\t\tkvm_update_dr6(vcpu);\n\t\tbreak;\n\tcase 5:\n\t\t/* fall through */\n\tdefault: /* 7 */\n\t\tif (val & 0xffffffff00000000ULL)\n\t\t\treturn -1; /* #GP */\n\t\tvcpu->arch.dr7 = (val & DR7_VOLATILE) | DR7_FIXED_1;\n\t\tkvm_update_dr7(vcpu);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "kvm_dr6_fixed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "856-863",
    "snippet": "static u64 kvm_dr6_fixed(struct kvm_vcpu *vcpu)\n{\n\tu64 fixed = DR6_FIXED_1;\n\n\tif (!guest_cpuid_has_rtm(vcpu))\n\t\tfixed |= DR6_RTM;\n\treturn fixed;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "guest_cpuid_has_rtm",
          "args": [
            "vcpu"
          ],
          "line": 860
        },
        "resolved": true,
        "details": {
          "function_name": "guest_cpuid_has_rtm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/cpuid.h",
          "lines": "139-145",
          "snippet": "static inline bool guest_cpuid_has_rtm(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_cpuid_entry2 *best;\n\n\tbest = kvm_find_cpuid_entry(vcpu, 7, 0);\n\treturn best && (best->ebx & bit(X86_FEATURE_RTM));\n}",
          "includes": [
            "#include <asm/cpu.h>",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpu.h>\n#include \"x86.h\"\n\nstatic inline bool guest_cpuid_has_rtm(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_cpuid_entry2 *best;\n\n\tbest = kvm_find_cpuid_entry(vcpu, 7, 0);\n\treturn best && (best->ebx & bit(X86_FEATURE_RTM));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic u64 kvm_dr6_fixed(struct kvm_vcpu *vcpu)\n{\n\tu64 fixed = DR6_FIXED_1;\n\n\tif (!guest_cpuid_has_rtm(vcpu))\n\t\tfixed |= DR6_RTM;\n\treturn fixed;\n}"
  },
  {
    "function_name": "kvm_update_dr7",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "842-854",
    "snippet": "static void kvm_update_dr7(struct kvm_vcpu *vcpu)\n{\n\tunsigned long dr7;\n\n\tif (vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP)\n\t\tdr7 = vcpu->arch.guest_debug_dr7;\n\telse\n\t\tdr7 = vcpu->arch.dr7;\n\tkvm_x86_ops->set_dr7(vcpu, dr7);\n\tvcpu->arch.switch_db_regs &= ~KVM_DEBUGREG_BP_ENABLED;\n\tif (dr7 & DR7_BP_EN_MASK)\n\t\tvcpu->arch.switch_db_regs |= KVM_DEBUGREG_BP_ENABLED;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);",
      "struct kvm_x86_ops *kvm_x86_ops"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_x86_ops->set_dr7",
          "args": [
            "vcpu",
            "dr7"
          ],
          "line": 850
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nstatic void kvm_update_dr7(struct kvm_vcpu *vcpu)\n{\n\tunsigned long dr7;\n\n\tif (vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP)\n\t\tdr7 = vcpu->arch.guest_debug_dr7;\n\telse\n\t\tdr7 = vcpu->arch.dr7;\n\tkvm_x86_ops->set_dr7(vcpu, dr7);\n\tvcpu->arch.switch_db_regs &= ~KVM_DEBUGREG_BP_ENABLED;\n\tif (dr7 & DR7_BP_EN_MASK)\n\t\tvcpu->arch.switch_db_regs |= KVM_DEBUGREG_BP_ENABLED;\n}"
  },
  {
    "function_name": "kvm_update_dr6",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "836-840",
    "snippet": "static void kvm_update_dr6(struct kvm_vcpu *vcpu)\n{\n\tif (!(vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP))\n\t\tkvm_x86_ops->set_dr6(vcpu, vcpu->arch.dr6);\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);",
      "struct kvm_x86_ops *kvm_x86_ops"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_x86_ops->set_dr6",
          "args": [
            "vcpu",
            "vcpu->arch.dr6"
          ],
          "line": 839
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nstatic void kvm_update_dr6(struct kvm_vcpu *vcpu)\n{\n\tif (!(vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP))\n\t\tkvm_x86_ops->set_dr6(vcpu, vcpu->arch.dr6);\n}"
  },
  {
    "function_name": "kvm_update_dr0123",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "825-834",
    "snippet": "static void kvm_update_dr0123(struct kvm_vcpu *vcpu)\n{\n\tint i;\n\n\tif (!(vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP)) {\n\t\tfor (i = 0; i < KVM_NR_DB_REGS; i++)\n\t\t\tvcpu->arch.eff_db[i] = vcpu->arch.db[i];\n\t\tvcpu->arch.switch_db_regs |= KVM_DEBUGREG_RELOAD;\n\t}\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic void kvm_update_dr0123(struct kvm_vcpu *vcpu)\n{\n\tint i;\n\n\tif (!(vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP)) {\n\t\tfor (i = 0; i < KVM_NR_DB_REGS; i++)\n\t\t\tvcpu->arch.eff_db[i] = vcpu->arch.db[i];\n\t\tvcpu->arch.switch_db_regs |= KVM_DEBUGREG_RELOAD;\n\t}\n}"
  },
  {
    "function_name": "kvm_get_cr8",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "816-822",
    "snippet": "unsigned long kvm_get_cr8(struct kvm_vcpu *vcpu)\n{\n\tif (lapic_in_kernel(vcpu))\n\t\treturn kvm_lapic_get_cr8(vcpu);\n\telse\n\t\treturn vcpu->arch.cr8;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_lapic_get_cr8",
          "args": [
            "vcpu"
          ],
          "line": 819
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_get_cr8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "1652-1659",
          "snippet": "u64 kvm_lapic_get_cr8(struct kvm_vcpu *vcpu)\n{\n\tu64 tpr;\n\n\ttpr = (u64) kvm_lapic_get_reg(vcpu->arch.apic, APIC_TASKPRI);\n\n\treturn (tpr & 0xf0) >> 4;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nu64 kvm_lapic_get_cr8(struct kvm_vcpu *vcpu)\n{\n\tu64 tpr;\n\n\ttpr = (u64) kvm_lapic_get_reg(vcpu->arch.apic, APIC_TASKPRI);\n\n\treturn (tpr & 0xf0) >> 4;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lapic_in_kernel",
          "args": [
            "vcpu"
          ],
          "line": 818
        },
        "resolved": true,
        "details": {
          "function_name": "lapic_in_kernel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.h",
          "lines": "141-146",
          "snippet": "static inline bool lapic_in_kernel(struct kvm_vcpu *vcpu)\n{\n\tif (static_key_false(&kvm_no_apic_vcpu))\n\t\treturn vcpu->arch.apic;\n\treturn true;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline bool lapic_in_kernel(struct kvm_vcpu *vcpu)\n{\n\tif (static_key_false(&kvm_no_apic_vcpu))\n\t\treturn vcpu->arch.apic;\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nunsigned long kvm_get_cr8(struct kvm_vcpu *vcpu)\n{\n\tif (lapic_in_kernel(vcpu))\n\t\treturn kvm_lapic_get_cr8(vcpu);\n\telse\n\t\treturn vcpu->arch.cr8;\n}"
  },
  {
    "function_name": "kvm_set_cr8",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "804-813",
    "snippet": "int kvm_set_cr8(struct kvm_vcpu *vcpu, unsigned long cr8)\n{\n\tif (cr8 & CR8_RESERVED_BITS)\n\t\treturn 1;\n\tif (lapic_in_kernel(vcpu))\n\t\tkvm_lapic_set_tpr(vcpu, cr8);\n\telse\n\t\tvcpu->arch.cr8 = cr8;\n\treturn 0;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_lapic_set_tpr",
          "args": [
            "vcpu",
            "cr8"
          ],
          "line": 809
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_set_tpr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "1644-1650",
          "snippet": "void kvm_lapic_set_tpr(struct kvm_vcpu *vcpu, unsigned long cr8)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tapic_set_tpr(apic, ((cr8 & 0x0f) << 4)\n\t\t     | (kvm_lapic_get_reg(apic, APIC_TASKPRI) & 4));\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nvoid kvm_lapic_set_tpr(struct kvm_vcpu *vcpu, unsigned long cr8)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tapic_set_tpr(apic, ((cr8 & 0x0f) << 4)\n\t\t     | (kvm_lapic_get_reg(apic, APIC_TASKPRI) & 4));\n}"
        }
      },
      {
        "call_info": {
          "callee": "lapic_in_kernel",
          "args": [
            "vcpu"
          ],
          "line": 808
        },
        "resolved": true,
        "details": {
          "function_name": "lapic_in_kernel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.h",
          "lines": "141-146",
          "snippet": "static inline bool lapic_in_kernel(struct kvm_vcpu *vcpu)\n{\n\tif (static_key_false(&kvm_no_apic_vcpu))\n\t\treturn vcpu->arch.apic;\n\treturn true;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline bool lapic_in_kernel(struct kvm_vcpu *vcpu)\n{\n\tif (static_key_false(&kvm_no_apic_vcpu))\n\t\treturn vcpu->arch.apic;\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nint kvm_set_cr8(struct kvm_vcpu *vcpu, unsigned long cr8)\n{\n\tif (cr8 & CR8_RESERVED_BITS)\n\t\treturn 1;\n\tif (lapic_in_kernel(vcpu))\n\t\tkvm_lapic_set_tpr(vcpu, cr8);\n\telse\n\t\tvcpu->arch.cr8 = cr8;\n\treturn 0;\n}"
  },
  {
    "function_name": "kvm_set_cr3",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "778-801",
    "snippet": "int kvm_set_cr3(struct kvm_vcpu *vcpu, unsigned long cr3)\n{\n#ifdef CONFIG_X86_64\n\tcr3 &= ~CR3_PCID_INVD;\n#endif\n\n\tif (cr3 == kvm_read_cr3(vcpu) && !pdptrs_changed(vcpu)) {\n\t\tkvm_mmu_sync_roots(vcpu);\n\t\tkvm_make_request(KVM_REQ_TLB_FLUSH, vcpu);\n\t\treturn 0;\n\t}\n\n\tif (is_long_mode(vcpu)) {\n\t\tif (cr3 & CR3_L_MODE_RESERVED_BITS)\n\t\t\treturn 1;\n\t} else if (is_pae(vcpu) && is_paging(vcpu) &&\n\t\t   !load_pdptrs(vcpu, vcpu->arch.walk_mmu, cr3))\n\t\treturn 1;\n\n\tvcpu->arch.cr3 = cr3;\n\t__set_bit(VCPU_EXREG_CR3, (ulong *)&vcpu->arch.regs_avail);\n\tkvm_mmu_new_cr3(vcpu);\n\treturn 0;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_mmu_new_cr3",
          "args": [
            "vcpu"
          ],
          "line": 799
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_new_cr3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "3604-3607",
          "snippet": "void kvm_mmu_new_cr3(struct kvm_vcpu *vcpu)\n{\n\tmmu_free_roots(vcpu);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nvoid kvm_mmu_new_cr3(struct kvm_vcpu *vcpu)\n{\n\tmmu_free_roots(vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__set_bit",
          "args": [
            "VCPU_EXREG_CR3",
            "(ulong *)&vcpu->arch.regs_avail"
          ],
          "line": 798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "load_pdptrs",
          "args": [
            "vcpu",
            "vcpu->arch.walk_mmu",
            "cr3"
          ],
          "line": 794
        },
        "resolved": true,
        "details": {
          "function_name": "load_pdptrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "524-557",
          "snippet": "int load_pdptrs(struct kvm_vcpu *vcpu, struct kvm_mmu *mmu, unsigned long cr3)\n{\n\tgfn_t pdpt_gfn = cr3 >> PAGE_SHIFT;\n\tunsigned offset = ((cr3 & (PAGE_SIZE-1)) >> 5) << 2;\n\tint i;\n\tint ret;\n\tu64 pdpte[ARRAY_SIZE(mmu->pdptrs)];\n\n\tret = kvm_read_guest_page_mmu(vcpu, mmu, pdpt_gfn, pdpte,\n\t\t\t\t      offset * sizeof(u64), sizeof(pdpte),\n\t\t\t\t      PFERR_USER_MASK|PFERR_WRITE_MASK);\n\tif (ret < 0) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\tfor (i = 0; i < ARRAY_SIZE(pdpte); ++i) {\n\t\tif (is_present_gpte(pdpte[i]) &&\n\t\t    (pdpte[i] &\n\t\t     vcpu->arch.mmu.guest_rsvd_check.rsvd_bits_mask[0][2])) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tret = 1;\n\n\tmemcpy(mmu->pdptrs, pdpte, sizeof(mmu->pdptrs));\n\t__set_bit(VCPU_EXREG_PDPTR,\n\t\t  (unsigned long *)&vcpu->arch.regs_avail);\n\t__set_bit(VCPU_EXREG_PDPTR,\n\t\t  (unsigned long *)&vcpu->arch.regs_dirty);\nout:\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nint load_pdptrs(struct kvm_vcpu *vcpu, struct kvm_mmu *mmu, unsigned long cr3)\n{\n\tgfn_t pdpt_gfn = cr3 >> PAGE_SHIFT;\n\tunsigned offset = ((cr3 & (PAGE_SIZE-1)) >> 5) << 2;\n\tint i;\n\tint ret;\n\tu64 pdpte[ARRAY_SIZE(mmu->pdptrs)];\n\n\tret = kvm_read_guest_page_mmu(vcpu, mmu, pdpt_gfn, pdpte,\n\t\t\t\t      offset * sizeof(u64), sizeof(pdpte),\n\t\t\t\t      PFERR_USER_MASK|PFERR_WRITE_MASK);\n\tif (ret < 0) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\tfor (i = 0; i < ARRAY_SIZE(pdpte); ++i) {\n\t\tif (is_present_gpte(pdpte[i]) &&\n\t\t    (pdpte[i] &\n\t\t     vcpu->arch.mmu.guest_rsvd_check.rsvd_bits_mask[0][2])) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tret = 1;\n\n\tmemcpy(mmu->pdptrs, pdpte, sizeof(mmu->pdptrs));\n\t__set_bit(VCPU_EXREG_PDPTR,\n\t\t  (unsigned long *)&vcpu->arch.regs_avail);\n\t__set_bit(VCPU_EXREG_PDPTR,\n\t\t  (unsigned long *)&vcpu->arch.regs_dirty);\nout:\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_paging",
          "args": [
            "vcpu"
          ],
          "line": 793
        },
        "resolved": true,
        "details": {
          "function_name": "is_paging",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.h",
          "lines": "77-80",
          "snippet": "static inline int is_paging(struct kvm_vcpu *vcpu)\n{\n\treturn likely(kvm_read_cr0_bits(vcpu, X86_CR0_PG));\n}",
          "includes": [
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline int is_paging(struct kvm_vcpu *vcpu)\n{\n\treturn likely(kvm_read_cr0_bits(vcpu, X86_CR0_PG));\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_pae",
          "args": [
            "vcpu"
          ],
          "line": 793
        },
        "resolved": true,
        "details": {
          "function_name": "is_pae",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.h",
          "lines": "67-70",
          "snippet": "static inline int is_pae(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_read_cr4_bits(vcpu, X86_CR4_PAE);\n}",
          "includes": [
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline int is_pae(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_read_cr4_bits(vcpu, X86_CR4_PAE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_long_mode",
          "args": [
            "vcpu"
          ],
          "line": 790
        },
        "resolved": true,
        "details": {
          "function_name": "is_long_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.h",
          "lines": "43-50",
          "snippet": "static inline int is_long_mode(struct kvm_vcpu *vcpu)\n{\n#ifdef CONFIG_X86_64\n\treturn vcpu->arch.efer & EFER_LMA;\n#else\n\treturn 0;\n#endif\n}",
          "includes": [
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline int is_long_mode(struct kvm_vcpu *vcpu)\n{\n#ifdef CONFIG_X86_64\n\treturn vcpu->arch.efer & EFER_LMA;\n#else\n\treturn 0;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_make_request",
          "args": [
            "KVM_REQ_TLB_FLUSH",
            "vcpu"
          ],
          "line": 786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_mmu_sync_roots",
          "args": [
            "vcpu"
          ],
          "line": 785
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_sync_roots",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "3280-3285",
          "snippet": "void kvm_mmu_sync_roots(struct kvm_vcpu *vcpu)\n{\n\tspin_lock(&vcpu->kvm->mmu_lock);\n\tmmu_sync_roots(vcpu);\n\tspin_unlock(&vcpu->kvm->mmu_lock);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nvoid kvm_mmu_sync_roots(struct kvm_vcpu *vcpu)\n{\n\tspin_lock(&vcpu->kvm->mmu_lock);\n\tmmu_sync_roots(vcpu);\n\tspin_unlock(&vcpu->kvm->mmu_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pdptrs_changed",
          "args": [
            "vcpu"
          ],
          "line": 784
        },
        "resolved": true,
        "details": {
          "function_name": "pdptrs_changed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "560-585",
          "snippet": "static bool pdptrs_changed(struct kvm_vcpu *vcpu)\n{\n\tu64 pdpte[ARRAY_SIZE(vcpu->arch.walk_mmu->pdptrs)];\n\tbool changed = true;\n\tint offset;\n\tgfn_t gfn;\n\tint r;\n\n\tif (is_long_mode(vcpu) || !is_pae(vcpu))\n\t\treturn false;\n\n\tif (!test_bit(VCPU_EXREG_PDPTR,\n\t\t      (unsigned long *)&vcpu->arch.regs_avail))\n\t\treturn true;\n\n\tgfn = (kvm_read_cr3(vcpu) & ~31u) >> PAGE_SHIFT;\n\toffset = (kvm_read_cr3(vcpu) & ~31u) & (PAGE_SIZE - 1);\n\tr = kvm_read_nested_guest_page(vcpu, gfn, pdpte, offset, sizeof(pdpte),\n\t\t\t\t       PFERR_USER_MASK | PFERR_WRITE_MASK);\n\tif (r < 0)\n\t\tgoto out;\n\tchanged = memcmp(pdpte, vcpu->arch.walk_mmu->pdptrs, sizeof(pdpte)) != 0;\nout:\n\n\treturn changed;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic bool pdptrs_changed(struct kvm_vcpu *vcpu)\n{\n\tu64 pdpte[ARRAY_SIZE(vcpu->arch.walk_mmu->pdptrs)];\n\tbool changed = true;\n\tint offset;\n\tgfn_t gfn;\n\tint r;\n\n\tif (is_long_mode(vcpu) || !is_pae(vcpu))\n\t\treturn false;\n\n\tif (!test_bit(VCPU_EXREG_PDPTR,\n\t\t      (unsigned long *)&vcpu->arch.regs_avail))\n\t\treturn true;\n\n\tgfn = (kvm_read_cr3(vcpu) & ~31u) >> PAGE_SHIFT;\n\toffset = (kvm_read_cr3(vcpu) & ~31u) & (PAGE_SIZE - 1);\n\tr = kvm_read_nested_guest_page(vcpu, gfn, pdpte, offset, sizeof(pdpte),\n\t\t\t\t       PFERR_USER_MASK | PFERR_WRITE_MASK);\n\tif (r < 0)\n\t\tgoto out;\n\tchanged = memcmp(pdpte, vcpu->arch.walk_mmu->pdptrs, sizeof(pdpte)) != 0;\nout:\n\n\treturn changed;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_read_cr3",
          "args": [
            "vcpu"
          ],
          "line": 784
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_read_cr3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "69-74",
          "snippet": "static inline ulong kvm_read_cr3(struct kvm_vcpu *vcpu)\n{\n\tif (!test_bit(VCPU_EXREG_CR3, (ulong *)&vcpu->arch.regs_avail))\n\t\tkvm_x86_ops->decache_cr3(vcpu);\n\treturn vcpu->arch.cr3;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline ulong kvm_read_cr3(struct kvm_vcpu *vcpu)\n{\n\tif (!test_bit(VCPU_EXREG_CR3, (ulong *)&vcpu->arch.regs_avail))\n\t\tkvm_x86_ops->decache_cr3(vcpu);\n\treturn vcpu->arch.cr3;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nint kvm_set_cr3(struct kvm_vcpu *vcpu, unsigned long cr3)\n{\n#ifdef CONFIG_X86_64\n\tcr3 &= ~CR3_PCID_INVD;\n#endif\n\n\tif (cr3 == kvm_read_cr3(vcpu) && !pdptrs_changed(vcpu)) {\n\t\tkvm_mmu_sync_roots(vcpu);\n\t\tkvm_make_request(KVM_REQ_TLB_FLUSH, vcpu);\n\t\treturn 0;\n\t}\n\n\tif (is_long_mode(vcpu)) {\n\t\tif (cr3 & CR3_L_MODE_RESERVED_BITS)\n\t\t\treturn 1;\n\t} else if (is_pae(vcpu) && is_paging(vcpu) &&\n\t\t   !load_pdptrs(vcpu, vcpu->arch.walk_mmu, cr3))\n\t\treturn 1;\n\n\tvcpu->arch.cr3 = cr3;\n\t__set_bit(VCPU_EXREG_CR3, (ulong *)&vcpu->arch.regs_avail);\n\tkvm_mmu_new_cr3(vcpu);\n\treturn 0;\n}"
  },
  {
    "function_name": "kvm_set_cr4",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "722-775",
    "snippet": "int kvm_set_cr4(struct kvm_vcpu *vcpu, unsigned long cr4)\n{\n\tunsigned long old_cr4 = kvm_read_cr4(vcpu);\n\tunsigned long pdptr_bits = X86_CR4_PGE | X86_CR4_PSE | X86_CR4_PAE |\n\t\t\t\t   X86_CR4_SMEP | X86_CR4_SMAP | X86_CR4_PKE;\n\n\tif (cr4 & CR4_RESERVED_BITS)\n\t\treturn 1;\n\n\tif (!guest_cpuid_has_xsave(vcpu) && (cr4 & X86_CR4_OSXSAVE))\n\t\treturn 1;\n\n\tif (!guest_cpuid_has_smep(vcpu) && (cr4 & X86_CR4_SMEP))\n\t\treturn 1;\n\n\tif (!guest_cpuid_has_smap(vcpu) && (cr4 & X86_CR4_SMAP))\n\t\treturn 1;\n\n\tif (!guest_cpuid_has_fsgsbase(vcpu) && (cr4 & X86_CR4_FSGSBASE))\n\t\treturn 1;\n\n\tif (!guest_cpuid_has_pku(vcpu) && (cr4 & X86_CR4_PKE))\n\t\treturn 1;\n\n\tif (is_long_mode(vcpu)) {\n\t\tif (!(cr4 & X86_CR4_PAE))\n\t\t\treturn 1;\n\t} else if (is_paging(vcpu) && (cr4 & X86_CR4_PAE)\n\t\t   && ((cr4 ^ old_cr4) & pdptr_bits)\n\t\t   && !load_pdptrs(vcpu, vcpu->arch.walk_mmu,\n\t\t\t\t   kvm_read_cr3(vcpu)))\n\t\treturn 1;\n\n\tif ((cr4 & X86_CR4_PCIDE) && !(old_cr4 & X86_CR4_PCIDE)) {\n\t\tif (!guest_cpuid_has_pcid(vcpu))\n\t\t\treturn 1;\n\n\t\t/* PCID can not be enabled when cr3[11:0]!=000H or EFER.LMA=0 */\n\t\tif ((kvm_read_cr3(vcpu) & X86_CR3_PCID_MASK) || !is_long_mode(vcpu))\n\t\t\treturn 1;\n\t}\n\n\tif (kvm_x86_ops->set_cr4(vcpu, cr4))\n\t\treturn 1;\n\n\tif (((cr4 ^ old_cr4) & pdptr_bits) ||\n\t    (!(cr4 & X86_CR4_PCIDE) && (old_cr4 & X86_CR4_PCIDE)))\n\t\tkvm_mmu_reset_context(vcpu);\n\n\tif ((cr4 ^ old_cr4) & (X86_CR4_OSXSAVE | X86_CR4_PKE))\n\t\tkvm_update_cpuid(vcpu);\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);",
      "struct kvm_x86_ops *kvm_x86_ops"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_update_cpuid",
          "args": [
            "vcpu"
          ],
          "line": 772
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_update_cpuid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/cpuid.c",
          "lines": "68-134",
          "snippet": "int kvm_update_cpuid(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_cpuid_entry2 *best;\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tbest = kvm_find_cpuid_entry(vcpu, 1, 0);\n\tif (!best)\n\t\treturn 0;\n\n\t/* Update OSXSAVE bit */\n\tif (cpu_has_xsave && best->function == 0x1) {\n\t\tbest->ecx &= ~F(OSXSAVE);\n\t\tif (kvm_read_cr4_bits(vcpu, X86_CR4_OSXSAVE))\n\t\t\tbest->ecx |= F(OSXSAVE);\n\t}\n\n\tif (apic) {\n\t\tif (best->ecx & F(TSC_DEADLINE_TIMER))\n\t\t\tapic->lapic_timer.timer_mode_mask = 3 << 17;\n\t\telse\n\t\t\tapic->lapic_timer.timer_mode_mask = 1 << 17;\n\t}\n\n\tbest = kvm_find_cpuid_entry(vcpu, 7, 0);\n\tif (best) {\n\t\t/* Update OSPKE bit */\n\t\tif (boot_cpu_has(X86_FEATURE_PKU) && best->function == 0x7) {\n\t\t\tbest->ecx &= ~F(OSPKE);\n\t\t\tif (kvm_read_cr4_bits(vcpu, X86_CR4_PKE))\n\t\t\t\tbest->ecx |= F(OSPKE);\n\t\t}\n\t}\n\n\tbest = kvm_find_cpuid_entry(vcpu, 0xD, 0);\n\tif (!best) {\n\t\tvcpu->arch.guest_supported_xcr0 = 0;\n\t\tvcpu->arch.guest_xstate_size = XSAVE_HDR_SIZE + XSAVE_HDR_OFFSET;\n\t} else {\n\t\tvcpu->arch.guest_supported_xcr0 =\n\t\t\t(best->eax | ((u64)best->edx << 32)) &\n\t\t\tkvm_supported_xcr0();\n\t\tvcpu->arch.guest_xstate_size = best->ebx =\n\t\t\txstate_required_size(vcpu->arch.xcr0, false);\n\t}\n\n\tbest = kvm_find_cpuid_entry(vcpu, 0xD, 1);\n\tif (best && (best->eax & (F(XSAVES) | F(XSAVEC))))\n\t\tbest->ebx = xstate_required_size(vcpu->arch.xcr0, true);\n\n\tif (use_eager_fpu())\n\t\tkvm_x86_ops->fpu_activate(vcpu);\n\n\t/*\n\t * The existing code assumes virtual address is 48-bit in the canonical\n\t * address checks; exit if it is ever changed.\n\t */\n\tbest = kvm_find_cpuid_entry(vcpu, 0x80000008, 0);\n\tif (best && ((best->eax & 0xff00) >> 8) != 48 &&\n\t\t((best->eax & 0xff00) >> 8) != 0)\n\t\treturn -EINVAL;\n\n\t/* Update physical-address width */\n\tvcpu->arch.maxphyaddr = cpuid_query_maxphyaddr(vcpu);\n\n\tkvm_pmu_refresh(vcpu);\n\treturn 0;\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"trace.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"cpuid.h\"",
            "#include <asm/fpu/xstate.h>",
            "#include <asm/user.h>",
            "#include <asm/fpu/internal.h> /* For use_eager_fpu.  Ugh! */",
            "#include <linux/uaccess.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"trace.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include <asm/fpu/xstate.h>\n#include <asm/user.h>\n#include <asm/fpu/internal.h> /* For use_eager_fpu.  Ugh! */\n#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n\nint kvm_update_cpuid(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_cpuid_entry2 *best;\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tbest = kvm_find_cpuid_entry(vcpu, 1, 0);\n\tif (!best)\n\t\treturn 0;\n\n\t/* Update OSXSAVE bit */\n\tif (cpu_has_xsave && best->function == 0x1) {\n\t\tbest->ecx &= ~F(OSXSAVE);\n\t\tif (kvm_read_cr4_bits(vcpu, X86_CR4_OSXSAVE))\n\t\t\tbest->ecx |= F(OSXSAVE);\n\t}\n\n\tif (apic) {\n\t\tif (best->ecx & F(TSC_DEADLINE_TIMER))\n\t\t\tapic->lapic_timer.timer_mode_mask = 3 << 17;\n\t\telse\n\t\t\tapic->lapic_timer.timer_mode_mask = 1 << 17;\n\t}\n\n\tbest = kvm_find_cpuid_entry(vcpu, 7, 0);\n\tif (best) {\n\t\t/* Update OSPKE bit */\n\t\tif (boot_cpu_has(X86_FEATURE_PKU) && best->function == 0x7) {\n\t\t\tbest->ecx &= ~F(OSPKE);\n\t\t\tif (kvm_read_cr4_bits(vcpu, X86_CR4_PKE))\n\t\t\t\tbest->ecx |= F(OSPKE);\n\t\t}\n\t}\n\n\tbest = kvm_find_cpuid_entry(vcpu, 0xD, 0);\n\tif (!best) {\n\t\tvcpu->arch.guest_supported_xcr0 = 0;\n\t\tvcpu->arch.guest_xstate_size = XSAVE_HDR_SIZE + XSAVE_HDR_OFFSET;\n\t} else {\n\t\tvcpu->arch.guest_supported_xcr0 =\n\t\t\t(best->eax | ((u64)best->edx << 32)) &\n\t\t\tkvm_supported_xcr0();\n\t\tvcpu->arch.guest_xstate_size = best->ebx =\n\t\t\txstate_required_size(vcpu->arch.xcr0, false);\n\t}\n\n\tbest = kvm_find_cpuid_entry(vcpu, 0xD, 1);\n\tif (best && (best->eax & (F(XSAVES) | F(XSAVEC))))\n\t\tbest->ebx = xstate_required_size(vcpu->arch.xcr0, true);\n\n\tif (use_eager_fpu())\n\t\tkvm_x86_ops->fpu_activate(vcpu);\n\n\t/*\n\t * The existing code assumes virtual address is 48-bit in the canonical\n\t * address checks; exit if it is ever changed.\n\t */\n\tbest = kvm_find_cpuid_entry(vcpu, 0x80000008, 0);\n\tif (best && ((best->eax & 0xff00) >> 8) != 48 &&\n\t\t((best->eax & 0xff00) >> 8) != 0)\n\t\treturn -EINVAL;\n\n\t/* Update physical-address width */\n\tvcpu->arch.maxphyaddr = cpuid_query_maxphyaddr(vcpu);\n\n\tkvm_pmu_refresh(vcpu);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_mmu_reset_context",
          "args": [
            "vcpu"
          ],
          "line": 769
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_reset_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "4230-4234",
          "snippet": "void kvm_mmu_reset_context(struct kvm_vcpu *vcpu)\n{\n\tkvm_mmu_unload(vcpu);\n\tinit_kvm_mmu(vcpu);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nvoid kvm_mmu_reset_context(struct kvm_vcpu *vcpu)\n{\n\tkvm_mmu_unload(vcpu);\n\tinit_kvm_mmu(vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_x86_ops->set_cr4",
          "args": [
            "vcpu",
            "cr4"
          ],
          "line": 764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_long_mode",
          "args": [
            "vcpu"
          ],
          "line": 760
        },
        "resolved": true,
        "details": {
          "function_name": "is_long_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.h",
          "lines": "43-50",
          "snippet": "static inline int is_long_mode(struct kvm_vcpu *vcpu)\n{\n#ifdef CONFIG_X86_64\n\treturn vcpu->arch.efer & EFER_LMA;\n#else\n\treturn 0;\n#endif\n}",
          "includes": [
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline int is_long_mode(struct kvm_vcpu *vcpu)\n{\n#ifdef CONFIG_X86_64\n\treturn vcpu->arch.efer & EFER_LMA;\n#else\n\treturn 0;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_read_cr3",
          "args": [
            "vcpu"
          ],
          "line": 760
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_read_cr3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "69-74",
          "snippet": "static inline ulong kvm_read_cr3(struct kvm_vcpu *vcpu)\n{\n\tif (!test_bit(VCPU_EXREG_CR3, (ulong *)&vcpu->arch.regs_avail))\n\t\tkvm_x86_ops->decache_cr3(vcpu);\n\treturn vcpu->arch.cr3;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline ulong kvm_read_cr3(struct kvm_vcpu *vcpu)\n{\n\tif (!test_bit(VCPU_EXREG_CR3, (ulong *)&vcpu->arch.regs_avail))\n\t\tkvm_x86_ops->decache_cr3(vcpu);\n\treturn vcpu->arch.cr3;\n}"
        }
      },
      {
        "call_info": {
          "callee": "guest_cpuid_has_pcid",
          "args": [
            "vcpu"
          ],
          "line": 756
        },
        "resolved": true,
        "details": {
          "function_name": "guest_cpuid_has_pcid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/cpuid.h",
          "lines": "107-113",
          "snippet": "static inline bool guest_cpuid_has_pcid(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_cpuid_entry2 *best;\n\n\tbest = kvm_find_cpuid_entry(vcpu, 1, 0);\n\treturn best && (best->ecx & bit(X86_FEATURE_PCID));\n}",
          "includes": [
            "#include <asm/cpu.h>",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpu.h>\n#include \"x86.h\"\n\nstatic inline bool guest_cpuid_has_pcid(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_cpuid_entry2 *best;\n\n\tbest = kvm_find_cpuid_entry(vcpu, 1, 0);\n\treturn best && (best->ecx & bit(X86_FEATURE_PCID));\n}"
        }
      },
      {
        "call_info": {
          "callee": "load_pdptrs",
          "args": [
            "vcpu",
            "vcpu->arch.walk_mmu",
            "kvm_read_cr3(vcpu)"
          ],
          "line": 751
        },
        "resolved": true,
        "details": {
          "function_name": "load_pdptrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "524-557",
          "snippet": "int load_pdptrs(struct kvm_vcpu *vcpu, struct kvm_mmu *mmu, unsigned long cr3)\n{\n\tgfn_t pdpt_gfn = cr3 >> PAGE_SHIFT;\n\tunsigned offset = ((cr3 & (PAGE_SIZE-1)) >> 5) << 2;\n\tint i;\n\tint ret;\n\tu64 pdpte[ARRAY_SIZE(mmu->pdptrs)];\n\n\tret = kvm_read_guest_page_mmu(vcpu, mmu, pdpt_gfn, pdpte,\n\t\t\t\t      offset * sizeof(u64), sizeof(pdpte),\n\t\t\t\t      PFERR_USER_MASK|PFERR_WRITE_MASK);\n\tif (ret < 0) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\tfor (i = 0; i < ARRAY_SIZE(pdpte); ++i) {\n\t\tif (is_present_gpte(pdpte[i]) &&\n\t\t    (pdpte[i] &\n\t\t     vcpu->arch.mmu.guest_rsvd_check.rsvd_bits_mask[0][2])) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tret = 1;\n\n\tmemcpy(mmu->pdptrs, pdpte, sizeof(mmu->pdptrs));\n\t__set_bit(VCPU_EXREG_PDPTR,\n\t\t  (unsigned long *)&vcpu->arch.regs_avail);\n\t__set_bit(VCPU_EXREG_PDPTR,\n\t\t  (unsigned long *)&vcpu->arch.regs_dirty);\nout:\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nint load_pdptrs(struct kvm_vcpu *vcpu, struct kvm_mmu *mmu, unsigned long cr3)\n{\n\tgfn_t pdpt_gfn = cr3 >> PAGE_SHIFT;\n\tunsigned offset = ((cr3 & (PAGE_SIZE-1)) >> 5) << 2;\n\tint i;\n\tint ret;\n\tu64 pdpte[ARRAY_SIZE(mmu->pdptrs)];\n\n\tret = kvm_read_guest_page_mmu(vcpu, mmu, pdpt_gfn, pdpte,\n\t\t\t\t      offset * sizeof(u64), sizeof(pdpte),\n\t\t\t\t      PFERR_USER_MASK|PFERR_WRITE_MASK);\n\tif (ret < 0) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\tfor (i = 0; i < ARRAY_SIZE(pdpte); ++i) {\n\t\tif (is_present_gpte(pdpte[i]) &&\n\t\t    (pdpte[i] &\n\t\t     vcpu->arch.mmu.guest_rsvd_check.rsvd_bits_mask[0][2])) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tret = 1;\n\n\tmemcpy(mmu->pdptrs, pdpte, sizeof(mmu->pdptrs));\n\t__set_bit(VCPU_EXREG_PDPTR,\n\t\t  (unsigned long *)&vcpu->arch.regs_avail);\n\t__set_bit(VCPU_EXREG_PDPTR,\n\t\t  (unsigned long *)&vcpu->arch.regs_dirty);\nout:\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_paging",
          "args": [
            "vcpu"
          ],
          "line": 749
        },
        "resolved": true,
        "details": {
          "function_name": "is_paging",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.h",
          "lines": "77-80",
          "snippet": "static inline int is_paging(struct kvm_vcpu *vcpu)\n{\n\treturn likely(kvm_read_cr0_bits(vcpu, X86_CR0_PG));\n}",
          "includes": [
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline int is_paging(struct kvm_vcpu *vcpu)\n{\n\treturn likely(kvm_read_cr0_bits(vcpu, X86_CR0_PG));\n}"
        }
      },
      {
        "call_info": {
          "callee": "guest_cpuid_has_pku",
          "args": [
            "vcpu"
          ],
          "line": 743
        },
        "resolved": true,
        "details": {
          "function_name": "guest_cpuid_has_pku",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/cpuid.h",
          "lines": "83-89",
          "snippet": "static inline bool guest_cpuid_has_pku(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_cpuid_entry2 *best;\n\n\tbest = kvm_find_cpuid_entry(vcpu, 7, 0);\n\treturn best && (best->ecx & bit(X86_FEATURE_PKU));\n}",
          "includes": [
            "#include <asm/cpu.h>",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpu.h>\n#include \"x86.h\"\n\nstatic inline bool guest_cpuid_has_pku(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_cpuid_entry2 *best;\n\n\tbest = kvm_find_cpuid_entry(vcpu, 7, 0);\n\treturn best && (best->ecx & bit(X86_FEATURE_PKU));\n}"
        }
      },
      {
        "call_info": {
          "callee": "guest_cpuid_has_fsgsbase",
          "args": [
            "vcpu"
          ],
          "line": 740
        },
        "resolved": true,
        "details": {
          "function_name": "guest_cpuid_has_fsgsbase",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/cpuid.h",
          "lines": "75-81",
          "snippet": "static inline bool guest_cpuid_has_fsgsbase(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_cpuid_entry2 *best;\n\n\tbest = kvm_find_cpuid_entry(vcpu, 7, 0);\n\treturn best && (best->ebx & bit(X86_FEATURE_FSGSBASE));\n}",
          "includes": [
            "#include <asm/cpu.h>",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpu.h>\n#include \"x86.h\"\n\nstatic inline bool guest_cpuid_has_fsgsbase(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_cpuid_entry2 *best;\n\n\tbest = kvm_find_cpuid_entry(vcpu, 7, 0);\n\treturn best && (best->ebx & bit(X86_FEATURE_FSGSBASE));\n}"
        }
      },
      {
        "call_info": {
          "callee": "guest_cpuid_has_smap",
          "args": [
            "vcpu"
          ],
          "line": 737
        },
        "resolved": true,
        "details": {
          "function_name": "guest_cpuid_has_smap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/cpuid.h",
          "lines": "67-73",
          "snippet": "static inline bool guest_cpuid_has_smap(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_cpuid_entry2 *best;\n\n\tbest = kvm_find_cpuid_entry(vcpu, 7, 0);\n\treturn best && (best->ebx & bit(X86_FEATURE_SMAP));\n}",
          "includes": [
            "#include <asm/cpu.h>",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpu.h>\n#include \"x86.h\"\n\nstatic inline bool guest_cpuid_has_smap(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_cpuid_entry2 *best;\n\n\tbest = kvm_find_cpuid_entry(vcpu, 7, 0);\n\treturn best && (best->ebx & bit(X86_FEATURE_SMAP));\n}"
        }
      },
      {
        "call_info": {
          "callee": "guest_cpuid_has_smep",
          "args": [
            "vcpu"
          ],
          "line": 734
        },
        "resolved": true,
        "details": {
          "function_name": "guest_cpuid_has_smep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/cpuid.h",
          "lines": "59-65",
          "snippet": "static inline bool guest_cpuid_has_smep(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_cpuid_entry2 *best;\n\n\tbest = kvm_find_cpuid_entry(vcpu, 7, 0);\n\treturn best && (best->ebx & bit(X86_FEATURE_SMEP));\n}",
          "includes": [
            "#include <asm/cpu.h>",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpu.h>\n#include \"x86.h\"\n\nstatic inline bool guest_cpuid_has_smep(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_cpuid_entry2 *best;\n\n\tbest = kvm_find_cpuid_entry(vcpu, 7, 0);\n\treturn best && (best->ebx & bit(X86_FEATURE_SMEP));\n}"
        }
      },
      {
        "call_info": {
          "callee": "guest_cpuid_has_xsave",
          "args": [
            "vcpu"
          ],
          "line": 731
        },
        "resolved": true,
        "details": {
          "function_name": "guest_cpuid_has_xsave",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/cpuid.h",
          "lines": "32-41",
          "snippet": "static inline bool guest_cpuid_has_xsave(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_cpuid_entry2 *best;\n\n\tif (!static_cpu_has(X86_FEATURE_XSAVE))\n\t\treturn false;\n\n\tbest = kvm_find_cpuid_entry(vcpu, 1, 0);\n\treturn best && (best->ecx & bit(X86_FEATURE_XSAVE));\n}",
          "includes": [
            "#include <asm/cpu.h>",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpu.h>\n#include \"x86.h\"\n\nstatic inline bool guest_cpuid_has_xsave(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_cpuid_entry2 *best;\n\n\tif (!static_cpu_has(X86_FEATURE_XSAVE))\n\t\treturn false;\n\n\tbest = kvm_find_cpuid_entry(vcpu, 1, 0);\n\treturn best && (best->ecx & bit(X86_FEATURE_XSAVE));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_read_cr4",
          "args": [
            "vcpu"
          ],
          "line": 724
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_read_cr4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "76-79",
          "snippet": "static inline ulong kvm_read_cr4(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_read_cr4_bits(vcpu, ~0UL);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline ulong kvm_read_cr4(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_read_cr4_bits(vcpu, ~0UL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nint kvm_set_cr4(struct kvm_vcpu *vcpu, unsigned long cr4)\n{\n\tunsigned long old_cr4 = kvm_read_cr4(vcpu);\n\tunsigned long pdptr_bits = X86_CR4_PGE | X86_CR4_PSE | X86_CR4_PAE |\n\t\t\t\t   X86_CR4_SMEP | X86_CR4_SMAP | X86_CR4_PKE;\n\n\tif (cr4 & CR4_RESERVED_BITS)\n\t\treturn 1;\n\n\tif (!guest_cpuid_has_xsave(vcpu) && (cr4 & X86_CR4_OSXSAVE))\n\t\treturn 1;\n\n\tif (!guest_cpuid_has_smep(vcpu) && (cr4 & X86_CR4_SMEP))\n\t\treturn 1;\n\n\tif (!guest_cpuid_has_smap(vcpu) && (cr4 & X86_CR4_SMAP))\n\t\treturn 1;\n\n\tif (!guest_cpuid_has_fsgsbase(vcpu) && (cr4 & X86_CR4_FSGSBASE))\n\t\treturn 1;\n\n\tif (!guest_cpuid_has_pku(vcpu) && (cr4 & X86_CR4_PKE))\n\t\treturn 1;\n\n\tif (is_long_mode(vcpu)) {\n\t\tif (!(cr4 & X86_CR4_PAE))\n\t\t\treturn 1;\n\t} else if (is_paging(vcpu) && (cr4 & X86_CR4_PAE)\n\t\t   && ((cr4 ^ old_cr4) & pdptr_bits)\n\t\t   && !load_pdptrs(vcpu, vcpu->arch.walk_mmu,\n\t\t\t\t   kvm_read_cr3(vcpu)))\n\t\treturn 1;\n\n\tif ((cr4 & X86_CR4_PCIDE) && !(old_cr4 & X86_CR4_PCIDE)) {\n\t\tif (!guest_cpuid_has_pcid(vcpu))\n\t\t\treturn 1;\n\n\t\t/* PCID can not be enabled when cr3[11:0]!=000H or EFER.LMA=0 */\n\t\tif ((kvm_read_cr3(vcpu) & X86_CR3_PCID_MASK) || !is_long_mode(vcpu))\n\t\t\treturn 1;\n\t}\n\n\tif (kvm_x86_ops->set_cr4(vcpu, cr4))\n\t\treturn 1;\n\n\tif (((cr4 ^ old_cr4) & pdptr_bits) ||\n\t    (!(cr4 & X86_CR4_PCIDE) && (old_cr4 & X86_CR4_PCIDE)))\n\t\tkvm_mmu_reset_context(vcpu);\n\n\tif ((cr4 ^ old_cr4) & (X86_CR4_OSXSAVE | X86_CR4_PKE))\n\t\tkvm_update_cpuid(vcpu);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "kvm_set_xcr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "711-719",
    "snippet": "int kvm_set_xcr(struct kvm_vcpu *vcpu, u32 index, u64 xcr)\n{\n\tif (kvm_x86_ops->get_cpl(vcpu) != 0 ||\n\t    __kvm_set_xcr(vcpu, index, xcr)) {\n\t\tkvm_inject_gp(vcpu, 0);\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);",
      "struct kvm_x86_ops *kvm_x86_ops"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_inject_gp",
          "args": [
            "vcpu",
            "0"
          ],
          "line": 715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__kvm_set_xcr",
          "args": [
            "vcpu",
            "index",
            "xcr"
          ],
          "line": 714
        },
        "resolved": true,
        "details": {
          "function_name": "__kvm_set_xcr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "671-709",
          "snippet": "static int __kvm_set_xcr(struct kvm_vcpu *vcpu, u32 index, u64 xcr)\n{\n\tu64 xcr0 = xcr;\n\tu64 old_xcr0 = vcpu->arch.xcr0;\n\tu64 valid_bits;\n\n\t/* Only support XCR_XFEATURE_ENABLED_MASK(xcr0) now  */\n\tif (index != XCR_XFEATURE_ENABLED_MASK)\n\t\treturn 1;\n\tif (!(xcr0 & XFEATURE_MASK_FP))\n\t\treturn 1;\n\tif ((xcr0 & XFEATURE_MASK_YMM) && !(xcr0 & XFEATURE_MASK_SSE))\n\t\treturn 1;\n\n\t/*\n\t * Do not allow the guest to set bits that we do not support\n\t * saving.  However, xcr0 bit 0 is always set, even if the\n\t * emulated CPU does not support XSAVE (see fx_init).\n\t */\n\tvalid_bits = vcpu->arch.guest_supported_xcr0 | XFEATURE_MASK_FP;\n\tif (xcr0 & ~valid_bits)\n\t\treturn 1;\n\n\tif ((!(xcr0 & XFEATURE_MASK_BNDREGS)) !=\n\t    (!(xcr0 & XFEATURE_MASK_BNDCSR)))\n\t\treturn 1;\n\n\tif (xcr0 & XFEATURE_MASK_AVX512) {\n\t\tif (!(xcr0 & XFEATURE_MASK_YMM))\n\t\t\treturn 1;\n\t\tif ((xcr0 & XFEATURE_MASK_AVX512) != XFEATURE_MASK_AVX512)\n\t\t\treturn 1;\n\t}\n\tvcpu->arch.xcr0 = xcr0;\n\n\tif ((xcr0 ^ old_xcr0) & XFEATURE_MASK_EXTEND)\n\t\tkvm_update_cpuid(vcpu);\n\treturn 0;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic int __kvm_set_xcr(struct kvm_vcpu *vcpu, u32 index, u64 xcr)\n{\n\tu64 xcr0 = xcr;\n\tu64 old_xcr0 = vcpu->arch.xcr0;\n\tu64 valid_bits;\n\n\t/* Only support XCR_XFEATURE_ENABLED_MASK(xcr0) now  */\n\tif (index != XCR_XFEATURE_ENABLED_MASK)\n\t\treturn 1;\n\tif (!(xcr0 & XFEATURE_MASK_FP))\n\t\treturn 1;\n\tif ((xcr0 & XFEATURE_MASK_YMM) && !(xcr0 & XFEATURE_MASK_SSE))\n\t\treturn 1;\n\n\t/*\n\t * Do not allow the guest to set bits that we do not support\n\t * saving.  However, xcr0 bit 0 is always set, even if the\n\t * emulated CPU does not support XSAVE (see fx_init).\n\t */\n\tvalid_bits = vcpu->arch.guest_supported_xcr0 | XFEATURE_MASK_FP;\n\tif (xcr0 & ~valid_bits)\n\t\treturn 1;\n\n\tif ((!(xcr0 & XFEATURE_MASK_BNDREGS)) !=\n\t    (!(xcr0 & XFEATURE_MASK_BNDCSR)))\n\t\treturn 1;\n\n\tif (xcr0 & XFEATURE_MASK_AVX512) {\n\t\tif (!(xcr0 & XFEATURE_MASK_YMM))\n\t\t\treturn 1;\n\t\tif ((xcr0 & XFEATURE_MASK_AVX512) != XFEATURE_MASK_AVX512)\n\t\t\treturn 1;\n\t}\n\tvcpu->arch.xcr0 = xcr0;\n\n\tif ((xcr0 ^ old_xcr0) & XFEATURE_MASK_EXTEND)\n\t\tkvm_update_cpuid(vcpu);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_x86_ops->get_cpl",
          "args": [
            "vcpu"
          ],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nint kvm_set_xcr(struct kvm_vcpu *vcpu, u32 index, u64 xcr)\n{\n\tif (kvm_x86_ops->get_cpl(vcpu) != 0 ||\n\t    __kvm_set_xcr(vcpu, index, xcr)) {\n\t\tkvm_inject_gp(vcpu, 0);\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "__kvm_set_xcr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "671-709",
    "snippet": "static int __kvm_set_xcr(struct kvm_vcpu *vcpu, u32 index, u64 xcr)\n{\n\tu64 xcr0 = xcr;\n\tu64 old_xcr0 = vcpu->arch.xcr0;\n\tu64 valid_bits;\n\n\t/* Only support XCR_XFEATURE_ENABLED_MASK(xcr0) now  */\n\tif (index != XCR_XFEATURE_ENABLED_MASK)\n\t\treturn 1;\n\tif (!(xcr0 & XFEATURE_MASK_FP))\n\t\treturn 1;\n\tif ((xcr0 & XFEATURE_MASK_YMM) && !(xcr0 & XFEATURE_MASK_SSE))\n\t\treturn 1;\n\n\t/*\n\t * Do not allow the guest to set bits that we do not support\n\t * saving.  However, xcr0 bit 0 is always set, even if the\n\t * emulated CPU does not support XSAVE (see fx_init).\n\t */\n\tvalid_bits = vcpu->arch.guest_supported_xcr0 | XFEATURE_MASK_FP;\n\tif (xcr0 & ~valid_bits)\n\t\treturn 1;\n\n\tif ((!(xcr0 & XFEATURE_MASK_BNDREGS)) !=\n\t    (!(xcr0 & XFEATURE_MASK_BNDCSR)))\n\t\treturn 1;\n\n\tif (xcr0 & XFEATURE_MASK_AVX512) {\n\t\tif (!(xcr0 & XFEATURE_MASK_YMM))\n\t\t\treturn 1;\n\t\tif ((xcr0 & XFEATURE_MASK_AVX512) != XFEATURE_MASK_AVX512)\n\t\t\treturn 1;\n\t}\n\tvcpu->arch.xcr0 = xcr0;\n\n\tif ((xcr0 ^ old_xcr0) & XFEATURE_MASK_EXTEND)\n\t\tkvm_update_cpuid(vcpu);\n\treturn 0;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_update_cpuid",
          "args": [
            "vcpu"
          ],
          "line": 707
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_update_cpuid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/cpuid.c",
          "lines": "68-134",
          "snippet": "int kvm_update_cpuid(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_cpuid_entry2 *best;\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tbest = kvm_find_cpuid_entry(vcpu, 1, 0);\n\tif (!best)\n\t\treturn 0;\n\n\t/* Update OSXSAVE bit */\n\tif (cpu_has_xsave && best->function == 0x1) {\n\t\tbest->ecx &= ~F(OSXSAVE);\n\t\tif (kvm_read_cr4_bits(vcpu, X86_CR4_OSXSAVE))\n\t\t\tbest->ecx |= F(OSXSAVE);\n\t}\n\n\tif (apic) {\n\t\tif (best->ecx & F(TSC_DEADLINE_TIMER))\n\t\t\tapic->lapic_timer.timer_mode_mask = 3 << 17;\n\t\telse\n\t\t\tapic->lapic_timer.timer_mode_mask = 1 << 17;\n\t}\n\n\tbest = kvm_find_cpuid_entry(vcpu, 7, 0);\n\tif (best) {\n\t\t/* Update OSPKE bit */\n\t\tif (boot_cpu_has(X86_FEATURE_PKU) && best->function == 0x7) {\n\t\t\tbest->ecx &= ~F(OSPKE);\n\t\t\tif (kvm_read_cr4_bits(vcpu, X86_CR4_PKE))\n\t\t\t\tbest->ecx |= F(OSPKE);\n\t\t}\n\t}\n\n\tbest = kvm_find_cpuid_entry(vcpu, 0xD, 0);\n\tif (!best) {\n\t\tvcpu->arch.guest_supported_xcr0 = 0;\n\t\tvcpu->arch.guest_xstate_size = XSAVE_HDR_SIZE + XSAVE_HDR_OFFSET;\n\t} else {\n\t\tvcpu->arch.guest_supported_xcr0 =\n\t\t\t(best->eax | ((u64)best->edx << 32)) &\n\t\t\tkvm_supported_xcr0();\n\t\tvcpu->arch.guest_xstate_size = best->ebx =\n\t\t\txstate_required_size(vcpu->arch.xcr0, false);\n\t}\n\n\tbest = kvm_find_cpuid_entry(vcpu, 0xD, 1);\n\tif (best && (best->eax & (F(XSAVES) | F(XSAVEC))))\n\t\tbest->ebx = xstate_required_size(vcpu->arch.xcr0, true);\n\n\tif (use_eager_fpu())\n\t\tkvm_x86_ops->fpu_activate(vcpu);\n\n\t/*\n\t * The existing code assumes virtual address is 48-bit in the canonical\n\t * address checks; exit if it is ever changed.\n\t */\n\tbest = kvm_find_cpuid_entry(vcpu, 0x80000008, 0);\n\tif (best && ((best->eax & 0xff00) >> 8) != 48 &&\n\t\t((best->eax & 0xff00) >> 8) != 0)\n\t\treturn -EINVAL;\n\n\t/* Update physical-address width */\n\tvcpu->arch.maxphyaddr = cpuid_query_maxphyaddr(vcpu);\n\n\tkvm_pmu_refresh(vcpu);\n\treturn 0;\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"trace.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"cpuid.h\"",
            "#include <asm/fpu/xstate.h>",
            "#include <asm/user.h>",
            "#include <asm/fpu/internal.h> /* For use_eager_fpu.  Ugh! */",
            "#include <linux/uaccess.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"trace.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include <asm/fpu/xstate.h>\n#include <asm/user.h>\n#include <asm/fpu/internal.h> /* For use_eager_fpu.  Ugh! */\n#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n\nint kvm_update_cpuid(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_cpuid_entry2 *best;\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tbest = kvm_find_cpuid_entry(vcpu, 1, 0);\n\tif (!best)\n\t\treturn 0;\n\n\t/* Update OSXSAVE bit */\n\tif (cpu_has_xsave && best->function == 0x1) {\n\t\tbest->ecx &= ~F(OSXSAVE);\n\t\tif (kvm_read_cr4_bits(vcpu, X86_CR4_OSXSAVE))\n\t\t\tbest->ecx |= F(OSXSAVE);\n\t}\n\n\tif (apic) {\n\t\tif (best->ecx & F(TSC_DEADLINE_TIMER))\n\t\t\tapic->lapic_timer.timer_mode_mask = 3 << 17;\n\t\telse\n\t\t\tapic->lapic_timer.timer_mode_mask = 1 << 17;\n\t}\n\n\tbest = kvm_find_cpuid_entry(vcpu, 7, 0);\n\tif (best) {\n\t\t/* Update OSPKE bit */\n\t\tif (boot_cpu_has(X86_FEATURE_PKU) && best->function == 0x7) {\n\t\t\tbest->ecx &= ~F(OSPKE);\n\t\t\tif (kvm_read_cr4_bits(vcpu, X86_CR4_PKE))\n\t\t\t\tbest->ecx |= F(OSPKE);\n\t\t}\n\t}\n\n\tbest = kvm_find_cpuid_entry(vcpu, 0xD, 0);\n\tif (!best) {\n\t\tvcpu->arch.guest_supported_xcr0 = 0;\n\t\tvcpu->arch.guest_xstate_size = XSAVE_HDR_SIZE + XSAVE_HDR_OFFSET;\n\t} else {\n\t\tvcpu->arch.guest_supported_xcr0 =\n\t\t\t(best->eax | ((u64)best->edx << 32)) &\n\t\t\tkvm_supported_xcr0();\n\t\tvcpu->arch.guest_xstate_size = best->ebx =\n\t\t\txstate_required_size(vcpu->arch.xcr0, false);\n\t}\n\n\tbest = kvm_find_cpuid_entry(vcpu, 0xD, 1);\n\tif (best && (best->eax & (F(XSAVES) | F(XSAVEC))))\n\t\tbest->ebx = xstate_required_size(vcpu->arch.xcr0, true);\n\n\tif (use_eager_fpu())\n\t\tkvm_x86_ops->fpu_activate(vcpu);\n\n\t/*\n\t * The existing code assumes virtual address is 48-bit in the canonical\n\t * address checks; exit if it is ever changed.\n\t */\n\tbest = kvm_find_cpuid_entry(vcpu, 0x80000008, 0);\n\tif (best && ((best->eax & 0xff00) >> 8) != 48 &&\n\t\t((best->eax & 0xff00) >> 8) != 0)\n\t\treturn -EINVAL;\n\n\t/* Update physical-address width */\n\tvcpu->arch.maxphyaddr = cpuid_query_maxphyaddr(vcpu);\n\n\tkvm_pmu_refresh(vcpu);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic int __kvm_set_xcr(struct kvm_vcpu *vcpu, u32 index, u64 xcr)\n{\n\tu64 xcr0 = xcr;\n\tu64 old_xcr0 = vcpu->arch.xcr0;\n\tu64 valid_bits;\n\n\t/* Only support XCR_XFEATURE_ENABLED_MASK(xcr0) now  */\n\tif (index != XCR_XFEATURE_ENABLED_MASK)\n\t\treturn 1;\n\tif (!(xcr0 & XFEATURE_MASK_FP))\n\t\treturn 1;\n\tif ((xcr0 & XFEATURE_MASK_YMM) && !(xcr0 & XFEATURE_MASK_SSE))\n\t\treturn 1;\n\n\t/*\n\t * Do not allow the guest to set bits that we do not support\n\t * saving.  However, xcr0 bit 0 is always set, even if the\n\t * emulated CPU does not support XSAVE (see fx_init).\n\t */\n\tvalid_bits = vcpu->arch.guest_supported_xcr0 | XFEATURE_MASK_FP;\n\tif (xcr0 & ~valid_bits)\n\t\treturn 1;\n\n\tif ((!(xcr0 & XFEATURE_MASK_BNDREGS)) !=\n\t    (!(xcr0 & XFEATURE_MASK_BNDCSR)))\n\t\treturn 1;\n\n\tif (xcr0 & XFEATURE_MASK_AVX512) {\n\t\tif (!(xcr0 & XFEATURE_MASK_YMM))\n\t\t\treturn 1;\n\t\tif ((xcr0 & XFEATURE_MASK_AVX512) != XFEATURE_MASK_AVX512)\n\t\t\treturn 1;\n\t}\n\tvcpu->arch.xcr0 = xcr0;\n\n\tif ((xcr0 ^ old_xcr0) & XFEATURE_MASK_EXTEND)\n\t\tkvm_update_cpuid(vcpu);\n\treturn 0;\n}"
  },
  {
    "function_name": "kvm_put_guest_xcr0",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "662-669",
    "snippet": "static void kvm_put_guest_xcr0(struct kvm_vcpu *vcpu)\n{\n\tif (vcpu->guest_xcr0_loaded) {\n\t\tif (vcpu->arch.xcr0 != host_xcr0)\n\t\t\txsetbv(XCR_XFEATURE_ENABLED_MASK, host_xcr0);\n\t\tvcpu->guest_xcr0_loaded = 0;\n\t}\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);",
      "u64 __read_mostly host_xcr0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xsetbv",
          "args": [
            "XCR_XFEATURE_ENABLED_MASK",
            "host_xcr0"
          ],
          "line": 666
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nu64 __read_mostly host_xcr0;\n\nstatic void kvm_put_guest_xcr0(struct kvm_vcpu *vcpu)\n{\n\tif (vcpu->guest_xcr0_loaded) {\n\t\tif (vcpu->arch.xcr0 != host_xcr0)\n\t\t\txsetbv(XCR_XFEATURE_ENABLED_MASK, host_xcr0);\n\t\tvcpu->guest_xcr0_loaded = 0;\n\t}\n}"
  },
  {
    "function_name": "kvm_load_guest_xcr0",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "652-660",
    "snippet": "static void kvm_load_guest_xcr0(struct kvm_vcpu *vcpu)\n{\n\tif (kvm_read_cr4_bits(vcpu, X86_CR4_OSXSAVE) &&\n\t\t\t!vcpu->guest_xcr0_loaded) {\n\t\t/* kvm_set_xcr() also depends on this */\n\t\txsetbv(XCR_XFEATURE_ENABLED_MASK, vcpu->arch.xcr0);\n\t\tvcpu->guest_xcr0_loaded = 1;\n\t}\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xsetbv",
          "args": [
            "XCR_XFEATURE_ENABLED_MASK",
            "vcpu->arch.xcr0"
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_read_cr4_bits",
          "args": [
            "vcpu",
            "X86_CR4_OSXSAVE"
          ],
          "line": 654
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_read_cr4_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "61-67",
          "snippet": "static inline ulong kvm_read_cr4_bits(struct kvm_vcpu *vcpu, ulong mask)\n{\n\tulong tmask = mask & KVM_POSSIBLE_CR4_GUEST_BITS;\n\tif (tmask & vcpu->arch.cr4_guest_owned_bits)\n\t\tkvm_x86_ops->decache_cr4_guest_bits(vcpu);\n\treturn vcpu->arch.cr4 & mask;\n}",
          "includes": [],
          "macros_used": [
            "#define KVM_POSSIBLE_CR4_GUEST_BITS\t\t\t\t  \\\n\t(X86_CR4_PVI | X86_CR4_DE | X86_CR4_PCE | X86_CR4_OSFXSR  \\\n\t | X86_CR4_OSXMMEXCPT | X86_CR4_PGE)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define KVM_POSSIBLE_CR4_GUEST_BITS\t\t\t\t  \\\n\t(X86_CR4_PVI | X86_CR4_DE | X86_CR4_PCE | X86_CR4_OSFXSR  \\\n\t | X86_CR4_OSXMMEXCPT | X86_CR4_PGE)\n\nstatic inline ulong kvm_read_cr4_bits(struct kvm_vcpu *vcpu, ulong mask)\n{\n\tulong tmask = mask & KVM_POSSIBLE_CR4_GUEST_BITS;\n\tif (tmask & vcpu->arch.cr4_guest_owned_bits)\n\t\tkvm_x86_ops->decache_cr4_guest_bits(vcpu);\n\treturn vcpu->arch.cr4 & mask;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic void kvm_load_guest_xcr0(struct kvm_vcpu *vcpu)\n{\n\tif (kvm_read_cr4_bits(vcpu, X86_CR4_OSXSAVE) &&\n\t\t\t!vcpu->guest_xcr0_loaded) {\n\t\t/* kvm_set_xcr() also depends on this */\n\t\txsetbv(XCR_XFEATURE_ENABLED_MASK, vcpu->arch.xcr0);\n\t\tvcpu->guest_xcr0_loaded = 1;\n\t}\n}"
  },
  {
    "function_name": "kvm_lmsw",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "646-649",
    "snippet": "void kvm_lmsw(struct kvm_vcpu *vcpu, unsigned long msw)\n{\n\t(void)kvm_set_cr0(vcpu, kvm_read_cr0_bits(vcpu, ~0x0eul) | (msw & 0x0f));\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_set_cr0",
          "args": [
            "vcpu",
            "kvm_read_cr0_bits(vcpu, ~0x0eul) | (msw & 0x0f)"
          ],
          "line": 648
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_set_cr0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "587-643",
          "snippet": "int kvm_set_cr0(struct kvm_vcpu *vcpu, unsigned long cr0)\n{\n\tunsigned long old_cr0 = kvm_read_cr0(vcpu);\n\tunsigned long update_bits = X86_CR0_PG | X86_CR0_WP;\n\n\tcr0 |= X86_CR0_ET;\n\n#ifdef CONFIG_X86_64\n\tif (cr0 & 0xffffffff00000000UL)\n\t\treturn 1;\n#endif\n\n\tcr0 &= ~CR0_RESERVED_BITS;\n\n\tif ((cr0 & X86_CR0_NW) && !(cr0 & X86_CR0_CD))\n\t\treturn 1;\n\n\tif ((cr0 & X86_CR0_PG) && !(cr0 & X86_CR0_PE))\n\t\treturn 1;\n\n\tif (!is_paging(vcpu) && (cr0 & X86_CR0_PG)) {\n#ifdef CONFIG_X86_64\n\t\tif ((vcpu->arch.efer & EFER_LME)) {\n\t\t\tint cs_db, cs_l;\n\n\t\t\tif (!is_pae(vcpu))\n\t\t\t\treturn 1;\n\t\t\tkvm_x86_ops->get_cs_db_l_bits(vcpu, &cs_db, &cs_l);\n\t\t\tif (cs_l)\n\t\t\t\treturn 1;\n\t\t} else\n#endif\n\t\tif (is_pae(vcpu) && !load_pdptrs(vcpu, vcpu->arch.walk_mmu,\n\t\t\t\t\t\t kvm_read_cr3(vcpu)))\n\t\t\treturn 1;\n\t}\n\n\tif (!(cr0 & X86_CR0_PG) && kvm_read_cr4_bits(vcpu, X86_CR4_PCIDE))\n\t\treturn 1;\n\n\tkvm_x86_ops->set_cr0(vcpu, cr0);\n\n\tif ((cr0 ^ old_cr0) & X86_CR0_PG) {\n\t\tkvm_clear_async_pf_completion_queue(vcpu);\n\t\tkvm_async_pf_hash_reset(vcpu);\n\t}\n\n\tif ((cr0 ^ old_cr0) & update_bits)\n\t\tkvm_mmu_reset_context(vcpu);\n\n\tif (((cr0 ^ old_cr0) & X86_CR0_CD) &&\n\t    kvm_arch_has_noncoherent_dma(vcpu->kvm) &&\n\t    !kvm_check_has_quirk(vcpu->kvm, KVM_X86_QUIRK_CD_NW_CLEARED))\n\t\tkvm_zap_gfn_range(vcpu->kvm, 0, ~0ULL);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "struct kvm_x86_ops *kvm_x86_ops"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nint kvm_set_cr0(struct kvm_vcpu *vcpu, unsigned long cr0)\n{\n\tunsigned long old_cr0 = kvm_read_cr0(vcpu);\n\tunsigned long update_bits = X86_CR0_PG | X86_CR0_WP;\n\n\tcr0 |= X86_CR0_ET;\n\n#ifdef CONFIG_X86_64\n\tif (cr0 & 0xffffffff00000000UL)\n\t\treturn 1;\n#endif\n\n\tcr0 &= ~CR0_RESERVED_BITS;\n\n\tif ((cr0 & X86_CR0_NW) && !(cr0 & X86_CR0_CD))\n\t\treturn 1;\n\n\tif ((cr0 & X86_CR0_PG) && !(cr0 & X86_CR0_PE))\n\t\treturn 1;\n\n\tif (!is_paging(vcpu) && (cr0 & X86_CR0_PG)) {\n#ifdef CONFIG_X86_64\n\t\tif ((vcpu->arch.efer & EFER_LME)) {\n\t\t\tint cs_db, cs_l;\n\n\t\t\tif (!is_pae(vcpu))\n\t\t\t\treturn 1;\n\t\t\tkvm_x86_ops->get_cs_db_l_bits(vcpu, &cs_db, &cs_l);\n\t\t\tif (cs_l)\n\t\t\t\treturn 1;\n\t\t} else\n#endif\n\t\tif (is_pae(vcpu) && !load_pdptrs(vcpu, vcpu->arch.walk_mmu,\n\t\t\t\t\t\t kvm_read_cr3(vcpu)))\n\t\t\treturn 1;\n\t}\n\n\tif (!(cr0 & X86_CR0_PG) && kvm_read_cr4_bits(vcpu, X86_CR4_PCIDE))\n\t\treturn 1;\n\n\tkvm_x86_ops->set_cr0(vcpu, cr0);\n\n\tif ((cr0 ^ old_cr0) & X86_CR0_PG) {\n\t\tkvm_clear_async_pf_completion_queue(vcpu);\n\t\tkvm_async_pf_hash_reset(vcpu);\n\t}\n\n\tif ((cr0 ^ old_cr0) & update_bits)\n\t\tkvm_mmu_reset_context(vcpu);\n\n\tif (((cr0 ^ old_cr0) & X86_CR0_CD) &&\n\t    kvm_arch_has_noncoherent_dma(vcpu->kvm) &&\n\t    !kvm_check_has_quirk(vcpu->kvm, KVM_X86_QUIRK_CD_NW_CLEARED))\n\t\tkvm_zap_gfn_range(vcpu->kvm, 0, ~0ULL);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_read_cr0_bits",
          "args": [
            "vcpu",
            "~0x0eul"
          ],
          "line": 648
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_read_cr0_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "48-54",
          "snippet": "static inline ulong kvm_read_cr0_bits(struct kvm_vcpu *vcpu, ulong mask)\n{\n\tulong tmask = mask & KVM_POSSIBLE_CR0_GUEST_BITS;\n\tif (tmask & vcpu->arch.cr0_guest_owned_bits)\n\t\tkvm_x86_ops->decache_cr0_guest_bits(vcpu);\n\treturn vcpu->arch.cr0 & mask;\n}",
          "includes": [],
          "macros_used": [
            "#define KVM_POSSIBLE_CR0_GUEST_BITS X86_CR0_TS"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define KVM_POSSIBLE_CR0_GUEST_BITS X86_CR0_TS\n\nstatic inline ulong kvm_read_cr0_bits(struct kvm_vcpu *vcpu, ulong mask)\n{\n\tulong tmask = mask & KVM_POSSIBLE_CR0_GUEST_BITS;\n\tif (tmask & vcpu->arch.cr0_guest_owned_bits)\n\t\tkvm_x86_ops->decache_cr0_guest_bits(vcpu);\n\treturn vcpu->arch.cr0 & mask;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nvoid kvm_lmsw(struct kvm_vcpu *vcpu, unsigned long msw)\n{\n\t(void)kvm_set_cr0(vcpu, kvm_read_cr0_bits(vcpu, ~0x0eul) | (msw & 0x0f));\n}"
  },
  {
    "function_name": "kvm_set_cr0",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "587-643",
    "snippet": "int kvm_set_cr0(struct kvm_vcpu *vcpu, unsigned long cr0)\n{\n\tunsigned long old_cr0 = kvm_read_cr0(vcpu);\n\tunsigned long update_bits = X86_CR0_PG | X86_CR0_WP;\n\n\tcr0 |= X86_CR0_ET;\n\n#ifdef CONFIG_X86_64\n\tif (cr0 & 0xffffffff00000000UL)\n\t\treturn 1;\n#endif\n\n\tcr0 &= ~CR0_RESERVED_BITS;\n\n\tif ((cr0 & X86_CR0_NW) && !(cr0 & X86_CR0_CD))\n\t\treturn 1;\n\n\tif ((cr0 & X86_CR0_PG) && !(cr0 & X86_CR0_PE))\n\t\treturn 1;\n\n\tif (!is_paging(vcpu) && (cr0 & X86_CR0_PG)) {\n#ifdef CONFIG_X86_64\n\t\tif ((vcpu->arch.efer & EFER_LME)) {\n\t\t\tint cs_db, cs_l;\n\n\t\t\tif (!is_pae(vcpu))\n\t\t\t\treturn 1;\n\t\t\tkvm_x86_ops->get_cs_db_l_bits(vcpu, &cs_db, &cs_l);\n\t\t\tif (cs_l)\n\t\t\t\treturn 1;\n\t\t} else\n#endif\n\t\tif (is_pae(vcpu) && !load_pdptrs(vcpu, vcpu->arch.walk_mmu,\n\t\t\t\t\t\t kvm_read_cr3(vcpu)))\n\t\t\treturn 1;\n\t}\n\n\tif (!(cr0 & X86_CR0_PG) && kvm_read_cr4_bits(vcpu, X86_CR4_PCIDE))\n\t\treturn 1;\n\n\tkvm_x86_ops->set_cr0(vcpu, cr0);\n\n\tif ((cr0 ^ old_cr0) & X86_CR0_PG) {\n\t\tkvm_clear_async_pf_completion_queue(vcpu);\n\t\tkvm_async_pf_hash_reset(vcpu);\n\t}\n\n\tif ((cr0 ^ old_cr0) & update_bits)\n\t\tkvm_mmu_reset_context(vcpu);\n\n\tif (((cr0 ^ old_cr0) & X86_CR0_CD) &&\n\t    kvm_arch_has_noncoherent_dma(vcpu->kvm) &&\n\t    !kvm_check_has_quirk(vcpu->kvm, KVM_X86_QUIRK_CD_NW_CLEARED))\n\t\tkvm_zap_gfn_range(vcpu->kvm, 0, ~0ULL);\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);",
      "struct kvm_x86_ops *kvm_x86_ops"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_zap_gfn_range",
          "args": [
            "vcpu->kvm",
            "0",
            "~0ULL"
          ],
          "line": 640
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_zap_gfn_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "4697-4721",
          "snippet": "void kvm_zap_gfn_range(struct kvm *kvm, gfn_t gfn_start, gfn_t gfn_end)\n{\n\tstruct kvm_memslots *slots;\n\tstruct kvm_memory_slot *memslot;\n\tint i;\n\n\tspin_lock(&kvm->mmu_lock);\n\tfor (i = 0; i < KVM_ADDRESS_SPACE_NUM; i++) {\n\t\tslots = __kvm_memslots(kvm, i);\n\t\tkvm_for_each_memslot(memslot, slots) {\n\t\t\tgfn_t start, end;\n\n\t\t\tstart = max(gfn_start, memslot->base_gfn);\n\t\t\tend = min(gfn_end, memslot->base_gfn + memslot->npages);\n\t\t\tif (start >= end)\n\t\t\t\tcontinue;\n\n\t\t\tslot_handle_level_range(kvm, memslot, kvm_zap_rmapp,\n\t\t\t\t\t\tPT_PAGE_TABLE_LEVEL, PT_MAX_HUGEPAGE_LEVEL,\n\t\t\t\t\t\tstart, end - 1, true);\n\t\t}\n\t}\n\n\tspin_unlock(&kvm->mmu_lock);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nvoid kvm_zap_gfn_range(struct kvm *kvm, gfn_t gfn_start, gfn_t gfn_end)\n{\n\tstruct kvm_memslots *slots;\n\tstruct kvm_memory_slot *memslot;\n\tint i;\n\n\tspin_lock(&kvm->mmu_lock);\n\tfor (i = 0; i < KVM_ADDRESS_SPACE_NUM; i++) {\n\t\tslots = __kvm_memslots(kvm, i);\n\t\tkvm_for_each_memslot(memslot, slots) {\n\t\t\tgfn_t start, end;\n\n\t\t\tstart = max(gfn_start, memslot->base_gfn);\n\t\t\tend = min(gfn_end, memslot->base_gfn + memslot->npages);\n\t\t\tif (start >= end)\n\t\t\t\tcontinue;\n\n\t\t\tslot_handle_level_range(kvm, memslot, kvm_zap_rmapp,\n\t\t\t\t\t\tPT_PAGE_TABLE_LEVEL, PT_MAX_HUGEPAGE_LEVEL,\n\t\t\t\t\t\tstart, end - 1, true);\n\t\t}\n\t}\n\n\tspin_unlock(&kvm->mmu_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_check_has_quirk",
          "args": [
            "vcpu->kvm",
            "KVM_X86_QUIRK_CD_NW_CLEARED"
          ],
          "line": 639
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_check_has_quirk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.h",
          "lines": "155-158",
          "snippet": "static inline bool kvm_check_has_quirk(struct kvm *kvm, u64 quirk)\n{\n\treturn !(kvm->arch.disabled_quirks & quirk);\n}",
          "includes": [
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline bool kvm_check_has_quirk(struct kvm *kvm, u64 quirk)\n{\n\treturn !(kvm->arch.disabled_quirks & quirk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_arch_has_noncoherent_dma",
          "args": [
            "vcpu->kvm"
          ],
          "line": 638
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_arch_has_noncoherent_dma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "8361-8364",
          "snippet": "bool kvm_arch_has_noncoherent_dma(struct kvm *kvm)\n{\n\treturn atomic_read(&kvm->arch.noncoherent_dma_count);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nbool kvm_arch_has_noncoherent_dma(struct kvm *kvm)\n{\n\treturn atomic_read(&kvm->arch.noncoherent_dma_count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_mmu_reset_context",
          "args": [
            "vcpu"
          ],
          "line": 635
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_reset_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "4230-4234",
          "snippet": "void kvm_mmu_reset_context(struct kvm_vcpu *vcpu)\n{\n\tkvm_mmu_unload(vcpu);\n\tinit_kvm_mmu(vcpu);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nvoid kvm_mmu_reset_context(struct kvm_vcpu *vcpu)\n{\n\tkvm_mmu_unload(vcpu);\n\tinit_kvm_mmu(vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_async_pf_hash_reset",
          "args": [
            "vcpu"
          ],
          "line": 631
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_async_pf_hash_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "193-198",
          "snippet": "static inline void kvm_async_pf_hash_reset(struct kvm_vcpu *vcpu)\n{\n\tint i;\n\tfor (i = 0; i < roundup_pow_of_two(ASYNC_PF_PER_VCPU); i++)\n\t\tvcpu->arch.apf.gfns[i] = ~0;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic inline void kvm_async_pf_hash_reset(struct kvm_vcpu *vcpu)\n{\n\tint i;\n\tfor (i = 0; i < roundup_pow_of_two(ASYNC_PF_PER_VCPU); i++)\n\t\tvcpu->arch.apf.gfns[i] = ~0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_clear_async_pf_completion_queue",
          "args": [
            "vcpu"
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_x86_ops->set_cr0",
          "args": [
            "vcpu",
            "cr0"
          ],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_read_cr4_bits",
          "args": [
            "vcpu",
            "X86_CR4_PCIDE"
          ],
          "line": 624
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_read_cr4_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "61-67",
          "snippet": "static inline ulong kvm_read_cr4_bits(struct kvm_vcpu *vcpu, ulong mask)\n{\n\tulong tmask = mask & KVM_POSSIBLE_CR4_GUEST_BITS;\n\tif (tmask & vcpu->arch.cr4_guest_owned_bits)\n\t\tkvm_x86_ops->decache_cr4_guest_bits(vcpu);\n\treturn vcpu->arch.cr4 & mask;\n}",
          "includes": [],
          "macros_used": [
            "#define KVM_POSSIBLE_CR4_GUEST_BITS\t\t\t\t  \\\n\t(X86_CR4_PVI | X86_CR4_DE | X86_CR4_PCE | X86_CR4_OSFXSR  \\\n\t | X86_CR4_OSXMMEXCPT | X86_CR4_PGE)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define KVM_POSSIBLE_CR4_GUEST_BITS\t\t\t\t  \\\n\t(X86_CR4_PVI | X86_CR4_DE | X86_CR4_PCE | X86_CR4_OSFXSR  \\\n\t | X86_CR4_OSXMMEXCPT | X86_CR4_PGE)\n\nstatic inline ulong kvm_read_cr4_bits(struct kvm_vcpu *vcpu, ulong mask)\n{\n\tulong tmask = mask & KVM_POSSIBLE_CR4_GUEST_BITS;\n\tif (tmask & vcpu->arch.cr4_guest_owned_bits)\n\t\tkvm_x86_ops->decache_cr4_guest_bits(vcpu);\n\treturn vcpu->arch.cr4 & mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "load_pdptrs",
          "args": [
            "vcpu",
            "vcpu->arch.walk_mmu",
            "kvm_read_cr3(vcpu)"
          ],
          "line": 619
        },
        "resolved": true,
        "details": {
          "function_name": "load_pdptrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "524-557",
          "snippet": "int load_pdptrs(struct kvm_vcpu *vcpu, struct kvm_mmu *mmu, unsigned long cr3)\n{\n\tgfn_t pdpt_gfn = cr3 >> PAGE_SHIFT;\n\tunsigned offset = ((cr3 & (PAGE_SIZE-1)) >> 5) << 2;\n\tint i;\n\tint ret;\n\tu64 pdpte[ARRAY_SIZE(mmu->pdptrs)];\n\n\tret = kvm_read_guest_page_mmu(vcpu, mmu, pdpt_gfn, pdpte,\n\t\t\t\t      offset * sizeof(u64), sizeof(pdpte),\n\t\t\t\t      PFERR_USER_MASK|PFERR_WRITE_MASK);\n\tif (ret < 0) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\tfor (i = 0; i < ARRAY_SIZE(pdpte); ++i) {\n\t\tif (is_present_gpte(pdpte[i]) &&\n\t\t    (pdpte[i] &\n\t\t     vcpu->arch.mmu.guest_rsvd_check.rsvd_bits_mask[0][2])) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tret = 1;\n\n\tmemcpy(mmu->pdptrs, pdpte, sizeof(mmu->pdptrs));\n\t__set_bit(VCPU_EXREG_PDPTR,\n\t\t  (unsigned long *)&vcpu->arch.regs_avail);\n\t__set_bit(VCPU_EXREG_PDPTR,\n\t\t  (unsigned long *)&vcpu->arch.regs_dirty);\nout:\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nint load_pdptrs(struct kvm_vcpu *vcpu, struct kvm_mmu *mmu, unsigned long cr3)\n{\n\tgfn_t pdpt_gfn = cr3 >> PAGE_SHIFT;\n\tunsigned offset = ((cr3 & (PAGE_SIZE-1)) >> 5) << 2;\n\tint i;\n\tint ret;\n\tu64 pdpte[ARRAY_SIZE(mmu->pdptrs)];\n\n\tret = kvm_read_guest_page_mmu(vcpu, mmu, pdpt_gfn, pdpte,\n\t\t\t\t      offset * sizeof(u64), sizeof(pdpte),\n\t\t\t\t      PFERR_USER_MASK|PFERR_WRITE_MASK);\n\tif (ret < 0) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\tfor (i = 0; i < ARRAY_SIZE(pdpte); ++i) {\n\t\tif (is_present_gpte(pdpte[i]) &&\n\t\t    (pdpte[i] &\n\t\t     vcpu->arch.mmu.guest_rsvd_check.rsvd_bits_mask[0][2])) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tret = 1;\n\n\tmemcpy(mmu->pdptrs, pdpte, sizeof(mmu->pdptrs));\n\t__set_bit(VCPU_EXREG_PDPTR,\n\t\t  (unsigned long *)&vcpu->arch.regs_avail);\n\t__set_bit(VCPU_EXREG_PDPTR,\n\t\t  (unsigned long *)&vcpu->arch.regs_dirty);\nout:\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_read_cr3",
          "args": [
            "vcpu"
          ],
          "line": 620
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_read_cr3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "69-74",
          "snippet": "static inline ulong kvm_read_cr3(struct kvm_vcpu *vcpu)\n{\n\tif (!test_bit(VCPU_EXREG_CR3, (ulong *)&vcpu->arch.regs_avail))\n\t\tkvm_x86_ops->decache_cr3(vcpu);\n\treturn vcpu->arch.cr3;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline ulong kvm_read_cr3(struct kvm_vcpu *vcpu)\n{\n\tif (!test_bit(VCPU_EXREG_CR3, (ulong *)&vcpu->arch.regs_avail))\n\t\tkvm_x86_ops->decache_cr3(vcpu);\n\treturn vcpu->arch.cr3;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_pae",
          "args": [
            "vcpu"
          ],
          "line": 619
        },
        "resolved": true,
        "details": {
          "function_name": "is_pae",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.h",
          "lines": "67-70",
          "snippet": "static inline int is_pae(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_read_cr4_bits(vcpu, X86_CR4_PAE);\n}",
          "includes": [
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline int is_pae(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_read_cr4_bits(vcpu, X86_CR4_PAE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_x86_ops->get_cs_db_l_bits",
          "args": [
            "vcpu",
            "&cs_db",
            "&cs_l"
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_paging",
          "args": [
            "vcpu"
          ],
          "line": 607
        },
        "resolved": true,
        "details": {
          "function_name": "is_paging",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.h",
          "lines": "77-80",
          "snippet": "static inline int is_paging(struct kvm_vcpu *vcpu)\n{\n\treturn likely(kvm_read_cr0_bits(vcpu, X86_CR0_PG));\n}",
          "includes": [
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline int is_paging(struct kvm_vcpu *vcpu)\n{\n\treturn likely(kvm_read_cr0_bits(vcpu, X86_CR0_PG));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_read_cr0",
          "args": [
            "vcpu"
          ],
          "line": 589
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_read_cr0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "56-59",
          "snippet": "static inline ulong kvm_read_cr0(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_read_cr0_bits(vcpu, ~0UL);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline ulong kvm_read_cr0(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_read_cr0_bits(vcpu, ~0UL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nint kvm_set_cr0(struct kvm_vcpu *vcpu, unsigned long cr0)\n{\n\tunsigned long old_cr0 = kvm_read_cr0(vcpu);\n\tunsigned long update_bits = X86_CR0_PG | X86_CR0_WP;\n\n\tcr0 |= X86_CR0_ET;\n\n#ifdef CONFIG_X86_64\n\tif (cr0 & 0xffffffff00000000UL)\n\t\treturn 1;\n#endif\n\n\tcr0 &= ~CR0_RESERVED_BITS;\n\n\tif ((cr0 & X86_CR0_NW) && !(cr0 & X86_CR0_CD))\n\t\treturn 1;\n\n\tif ((cr0 & X86_CR0_PG) && !(cr0 & X86_CR0_PE))\n\t\treturn 1;\n\n\tif (!is_paging(vcpu) && (cr0 & X86_CR0_PG)) {\n#ifdef CONFIG_X86_64\n\t\tif ((vcpu->arch.efer & EFER_LME)) {\n\t\t\tint cs_db, cs_l;\n\n\t\t\tif (!is_pae(vcpu))\n\t\t\t\treturn 1;\n\t\t\tkvm_x86_ops->get_cs_db_l_bits(vcpu, &cs_db, &cs_l);\n\t\t\tif (cs_l)\n\t\t\t\treturn 1;\n\t\t} else\n#endif\n\t\tif (is_pae(vcpu) && !load_pdptrs(vcpu, vcpu->arch.walk_mmu,\n\t\t\t\t\t\t kvm_read_cr3(vcpu)))\n\t\t\treturn 1;\n\t}\n\n\tif (!(cr0 & X86_CR0_PG) && kvm_read_cr4_bits(vcpu, X86_CR4_PCIDE))\n\t\treturn 1;\n\n\tkvm_x86_ops->set_cr0(vcpu, cr0);\n\n\tif ((cr0 ^ old_cr0) & X86_CR0_PG) {\n\t\tkvm_clear_async_pf_completion_queue(vcpu);\n\t\tkvm_async_pf_hash_reset(vcpu);\n\t}\n\n\tif ((cr0 ^ old_cr0) & update_bits)\n\t\tkvm_mmu_reset_context(vcpu);\n\n\tif (((cr0 ^ old_cr0) & X86_CR0_CD) &&\n\t    kvm_arch_has_noncoherent_dma(vcpu->kvm) &&\n\t    !kvm_check_has_quirk(vcpu->kvm, KVM_X86_QUIRK_CD_NW_CLEARED))\n\t\tkvm_zap_gfn_range(vcpu->kvm, 0, ~0ULL);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "pdptrs_changed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "560-585",
    "snippet": "static bool pdptrs_changed(struct kvm_vcpu *vcpu)\n{\n\tu64 pdpte[ARRAY_SIZE(vcpu->arch.walk_mmu->pdptrs)];\n\tbool changed = true;\n\tint offset;\n\tgfn_t gfn;\n\tint r;\n\n\tif (is_long_mode(vcpu) || !is_pae(vcpu))\n\t\treturn false;\n\n\tif (!test_bit(VCPU_EXREG_PDPTR,\n\t\t      (unsigned long *)&vcpu->arch.regs_avail))\n\t\treturn true;\n\n\tgfn = (kvm_read_cr3(vcpu) & ~31u) >> PAGE_SHIFT;\n\toffset = (kvm_read_cr3(vcpu) & ~31u) & (PAGE_SIZE - 1);\n\tr = kvm_read_nested_guest_page(vcpu, gfn, pdpte, offset, sizeof(pdpte),\n\t\t\t\t       PFERR_USER_MASK | PFERR_WRITE_MASK);\n\tif (r < 0)\n\t\tgoto out;\n\tchanged = memcmp(pdpte, vcpu->arch.walk_mmu->pdptrs, sizeof(pdpte)) != 0;\nout:\n\n\treturn changed;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "pdpte",
            "vcpu->arch.walk_mmu->pdptrs",
            "sizeof(pdpte)"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_read_nested_guest_page",
          "args": [
            "vcpu",
            "gfn",
            "pdpte",
            "offset",
            "sizeof(pdpte)",
            "PFERR_USER_MASK | PFERR_WRITE_MASK"
          ],
          "line": 577
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_read_nested_guest_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "514-519",
          "snippet": "static int kvm_read_nested_guest_page(struct kvm_vcpu *vcpu, gfn_t gfn,\n\t\t\t       void *data, int offset, int len, u32 access)\n{\n\treturn kvm_read_guest_page_mmu(vcpu, vcpu->arch.walk_mmu, gfn,\n\t\t\t\t       data, offset, len, access);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic int kvm_read_nested_guest_page(struct kvm_vcpu *vcpu, gfn_t gfn,\n\t\t\t       void *data, int offset, int len, u32 access)\n{\n\treturn kvm_read_guest_page_mmu(vcpu, vcpu->arch.walk_mmu, gfn,\n\t\t\t\t       data, offset, len, access);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_read_cr3",
          "args": [
            "vcpu"
          ],
          "line": 576
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_read_cr3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "69-74",
          "snippet": "static inline ulong kvm_read_cr3(struct kvm_vcpu *vcpu)\n{\n\tif (!test_bit(VCPU_EXREG_CR3, (ulong *)&vcpu->arch.regs_avail))\n\t\tkvm_x86_ops->decache_cr3(vcpu);\n\treturn vcpu->arch.cr3;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline ulong kvm_read_cr3(struct kvm_vcpu *vcpu)\n{\n\tif (!test_bit(VCPU_EXREG_CR3, (ulong *)&vcpu->arch.regs_avail))\n\t\tkvm_x86_ops->decache_cr3(vcpu);\n\treturn vcpu->arch.cr3;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "VCPU_EXREG_PDPTR",
            "(unsigned long *)&vcpu->arch.regs_avail"
          ],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_pae",
          "args": [
            "vcpu"
          ],
          "line": 568
        },
        "resolved": true,
        "details": {
          "function_name": "is_pae",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.h",
          "lines": "67-70",
          "snippet": "static inline int is_pae(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_read_cr4_bits(vcpu, X86_CR4_PAE);\n}",
          "includes": [
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline int is_pae(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_read_cr4_bits(vcpu, X86_CR4_PAE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_long_mode",
          "args": [
            "vcpu"
          ],
          "line": 568
        },
        "resolved": true,
        "details": {
          "function_name": "is_long_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.h",
          "lines": "43-50",
          "snippet": "static inline int is_long_mode(struct kvm_vcpu *vcpu)\n{\n#ifdef CONFIG_X86_64\n\treturn vcpu->arch.efer & EFER_LMA;\n#else\n\treturn 0;\n#endif\n}",
          "includes": [
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline int is_long_mode(struct kvm_vcpu *vcpu)\n{\n#ifdef CONFIG_X86_64\n\treturn vcpu->arch.efer & EFER_LMA;\n#else\n\treturn 0;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "vcpu->arch.walk_mmu->pdptrs"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic bool pdptrs_changed(struct kvm_vcpu *vcpu)\n{\n\tu64 pdpte[ARRAY_SIZE(vcpu->arch.walk_mmu->pdptrs)];\n\tbool changed = true;\n\tint offset;\n\tgfn_t gfn;\n\tint r;\n\n\tif (is_long_mode(vcpu) || !is_pae(vcpu))\n\t\treturn false;\n\n\tif (!test_bit(VCPU_EXREG_PDPTR,\n\t\t      (unsigned long *)&vcpu->arch.regs_avail))\n\t\treturn true;\n\n\tgfn = (kvm_read_cr3(vcpu) & ~31u) >> PAGE_SHIFT;\n\toffset = (kvm_read_cr3(vcpu) & ~31u) & (PAGE_SIZE - 1);\n\tr = kvm_read_nested_guest_page(vcpu, gfn, pdpte, offset, sizeof(pdpte),\n\t\t\t\t       PFERR_USER_MASK | PFERR_WRITE_MASK);\n\tif (r < 0)\n\t\tgoto out;\n\tchanged = memcmp(pdpte, vcpu->arch.walk_mmu->pdptrs, sizeof(pdpte)) != 0;\nout:\n\n\treturn changed;\n}"
  },
  {
    "function_name": "load_pdptrs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "524-557",
    "snippet": "int load_pdptrs(struct kvm_vcpu *vcpu, struct kvm_mmu *mmu, unsigned long cr3)\n{\n\tgfn_t pdpt_gfn = cr3 >> PAGE_SHIFT;\n\tunsigned offset = ((cr3 & (PAGE_SIZE-1)) >> 5) << 2;\n\tint i;\n\tint ret;\n\tu64 pdpte[ARRAY_SIZE(mmu->pdptrs)];\n\n\tret = kvm_read_guest_page_mmu(vcpu, mmu, pdpt_gfn, pdpte,\n\t\t\t\t      offset * sizeof(u64), sizeof(pdpte),\n\t\t\t\t      PFERR_USER_MASK|PFERR_WRITE_MASK);\n\tif (ret < 0) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\tfor (i = 0; i < ARRAY_SIZE(pdpte); ++i) {\n\t\tif (is_present_gpte(pdpte[i]) &&\n\t\t    (pdpte[i] &\n\t\t     vcpu->arch.mmu.guest_rsvd_check.rsvd_bits_mask[0][2])) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tret = 1;\n\n\tmemcpy(mmu->pdptrs, pdpte, sizeof(mmu->pdptrs));\n\t__set_bit(VCPU_EXREG_PDPTR,\n\t\t  (unsigned long *)&vcpu->arch.regs_avail);\n\t__set_bit(VCPU_EXREG_PDPTR,\n\t\t  (unsigned long *)&vcpu->arch.regs_dirty);\nout:\n\n\treturn ret;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__set_bit",
          "args": [
            "VCPU_EXREG_PDPTR",
            "(unsigned long *)&vcpu->arch.regs_dirty"
          ],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__set_bit",
          "args": [
            "VCPU_EXREG_PDPTR",
            "(unsigned long *)&vcpu->arch.regs_avail"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "mmu->pdptrs",
            "pdpte",
            "sizeof(mmu->pdptrs)"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_present_gpte",
          "args": [
            "pdpte[i]"
          ],
          "line": 540
        },
        "resolved": true,
        "details": {
          "function_name": "is_present_gpte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.h",
          "lines": "96-99",
          "snippet": "static inline int is_present_gpte(unsigned long pte)\n{\n\treturn pte & PT_PRESENT_MASK;\n}",
          "includes": [
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define PT_PRESENT_MASK (1ULL << 0)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\n#define PT_PRESENT_MASK (1ULL << 0)\n\nstatic inline int is_present_gpte(unsigned long pte)\n{\n\treturn pte & PT_PRESENT_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "pdpte"
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_read_guest_page_mmu",
          "args": [
            "vcpu",
            "mmu",
            "pdpt_gfn",
            "pdpte",
            "offset * sizeof(u64)",
            "sizeof(pdpte)",
            "PFERR_USER_MASK|PFERR_WRITE_MASK"
          ],
          "line": 532
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_read_guest_page_mmu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "495-511",
          "snippet": "int kvm_read_guest_page_mmu(struct kvm_vcpu *vcpu, struct kvm_mmu *mmu,\n\t\t\t    gfn_t ngfn, void *data, int offset, int len,\n\t\t\t    u32 access)\n{\n\tstruct x86_exception exception;\n\tgfn_t real_gfn;\n\tgpa_t ngpa;\n\n\tngpa     = gfn_to_gpa(ngfn);\n\treal_gfn = mmu->translate_gpa(vcpu, ngpa, access, &exception);\n\tif (real_gfn == UNMAPPED_GVA)\n\t\treturn -EFAULT;\n\n\treal_gfn = gpa_to_gfn(real_gfn);\n\n\treturn kvm_vcpu_read_guest_page(vcpu, real_gfn, data, offset, len);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nint kvm_read_guest_page_mmu(struct kvm_vcpu *vcpu, struct kvm_mmu *mmu,\n\t\t\t    gfn_t ngfn, void *data, int offset, int len,\n\t\t\t    u32 access)\n{\n\tstruct x86_exception exception;\n\tgfn_t real_gfn;\n\tgpa_t ngpa;\n\n\tngpa     = gfn_to_gpa(ngfn);\n\treal_gfn = mmu->translate_gpa(vcpu, ngpa, access, &exception);\n\tif (real_gfn == UNMAPPED_GVA)\n\t\treturn -EFAULT;\n\n\treal_gfn = gpa_to_gfn(real_gfn);\n\n\treturn kvm_vcpu_read_guest_page(vcpu, real_gfn, data, offset, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "mmu->pdptrs"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nint load_pdptrs(struct kvm_vcpu *vcpu, struct kvm_mmu *mmu, unsigned long cr3)\n{\n\tgfn_t pdpt_gfn = cr3 >> PAGE_SHIFT;\n\tunsigned offset = ((cr3 & (PAGE_SIZE-1)) >> 5) << 2;\n\tint i;\n\tint ret;\n\tu64 pdpte[ARRAY_SIZE(mmu->pdptrs)];\n\n\tret = kvm_read_guest_page_mmu(vcpu, mmu, pdpt_gfn, pdpte,\n\t\t\t\t      offset * sizeof(u64), sizeof(pdpte),\n\t\t\t\t      PFERR_USER_MASK|PFERR_WRITE_MASK);\n\tif (ret < 0) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\tfor (i = 0; i < ARRAY_SIZE(pdpte); ++i) {\n\t\tif (is_present_gpte(pdpte[i]) &&\n\t\t    (pdpte[i] &\n\t\t     vcpu->arch.mmu.guest_rsvd_check.rsvd_bits_mask[0][2])) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tret = 1;\n\n\tmemcpy(mmu->pdptrs, pdpte, sizeof(mmu->pdptrs));\n\t__set_bit(VCPU_EXREG_PDPTR,\n\t\t  (unsigned long *)&vcpu->arch.regs_avail);\n\t__set_bit(VCPU_EXREG_PDPTR,\n\t\t  (unsigned long *)&vcpu->arch.regs_dirty);\nout:\n\n\treturn ret;\n}"
  },
  {
    "function_name": "kvm_read_nested_guest_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "514-519",
    "snippet": "static int kvm_read_nested_guest_page(struct kvm_vcpu *vcpu, gfn_t gfn,\n\t\t\t       void *data, int offset, int len, u32 access)\n{\n\treturn kvm_read_guest_page_mmu(vcpu, vcpu->arch.walk_mmu, gfn,\n\t\t\t\t       data, offset, len, access);\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_read_guest_page_mmu",
          "args": [
            "vcpu",
            "vcpu->arch.walk_mmu",
            "gfn",
            "data",
            "offset",
            "len",
            "access"
          ],
          "line": 517
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_read_guest_page_mmu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "495-511",
          "snippet": "int kvm_read_guest_page_mmu(struct kvm_vcpu *vcpu, struct kvm_mmu *mmu,\n\t\t\t    gfn_t ngfn, void *data, int offset, int len,\n\t\t\t    u32 access)\n{\n\tstruct x86_exception exception;\n\tgfn_t real_gfn;\n\tgpa_t ngpa;\n\n\tngpa     = gfn_to_gpa(ngfn);\n\treal_gfn = mmu->translate_gpa(vcpu, ngpa, access, &exception);\n\tif (real_gfn == UNMAPPED_GVA)\n\t\treturn -EFAULT;\n\n\treal_gfn = gpa_to_gfn(real_gfn);\n\n\treturn kvm_vcpu_read_guest_page(vcpu, real_gfn, data, offset, len);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nint kvm_read_guest_page_mmu(struct kvm_vcpu *vcpu, struct kvm_mmu *mmu,\n\t\t\t    gfn_t ngfn, void *data, int offset, int len,\n\t\t\t    u32 access)\n{\n\tstruct x86_exception exception;\n\tgfn_t real_gfn;\n\tgpa_t ngpa;\n\n\tngpa     = gfn_to_gpa(ngfn);\n\treal_gfn = mmu->translate_gpa(vcpu, ngpa, access, &exception);\n\tif (real_gfn == UNMAPPED_GVA)\n\t\treturn -EFAULT;\n\n\treal_gfn = gpa_to_gfn(real_gfn);\n\n\treturn kvm_vcpu_read_guest_page(vcpu, real_gfn, data, offset, len);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic int kvm_read_nested_guest_page(struct kvm_vcpu *vcpu, gfn_t gfn,\n\t\t\t       void *data, int offset, int len, u32 access)\n{\n\treturn kvm_read_guest_page_mmu(vcpu, vcpu->arch.walk_mmu, gfn,\n\t\t\t\t       data, offset, len, access);\n}"
  },
  {
    "function_name": "kvm_read_guest_page_mmu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "495-511",
    "snippet": "int kvm_read_guest_page_mmu(struct kvm_vcpu *vcpu, struct kvm_mmu *mmu,\n\t\t\t    gfn_t ngfn, void *data, int offset, int len,\n\t\t\t    u32 access)\n{\n\tstruct x86_exception exception;\n\tgfn_t real_gfn;\n\tgpa_t ngpa;\n\n\tngpa     = gfn_to_gpa(ngfn);\n\treal_gfn = mmu->translate_gpa(vcpu, ngpa, access, &exception);\n\tif (real_gfn == UNMAPPED_GVA)\n\t\treturn -EFAULT;\n\n\treal_gfn = gpa_to_gfn(real_gfn);\n\n\treturn kvm_vcpu_read_guest_page(vcpu, real_gfn, data, offset, len);\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_vcpu_read_guest_page",
          "args": [
            "vcpu",
            "real_gfn",
            "data",
            "offset",
            "len"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gpa_to_gfn",
          "args": [
            "real_gfn"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmu->translate_gpa",
          "args": [
            "vcpu",
            "ngpa",
            "access",
            "&exception"
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfn_to_gpa",
          "args": [
            "ngfn"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nint kvm_read_guest_page_mmu(struct kvm_vcpu *vcpu, struct kvm_mmu *mmu,\n\t\t\t    gfn_t ngfn, void *data, int offset, int len,\n\t\t\t    u32 access)\n{\n\tstruct x86_exception exception;\n\tgfn_t real_gfn;\n\tgpa_t ngpa;\n\n\tngpa     = gfn_to_gpa(ngfn);\n\treal_gfn = mmu->translate_gpa(vcpu, ngpa, access, &exception);\n\tif (real_gfn == UNMAPPED_GVA)\n\t\treturn -EFAULT;\n\n\treal_gfn = gpa_to_gfn(real_gfn);\n\n\treturn kvm_vcpu_read_guest_page(vcpu, real_gfn, data, offset, len);\n}"
  },
  {
    "function_name": "kvm_require_dr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "480-487",
    "snippet": "bool kvm_require_dr(struct kvm_vcpu *vcpu, int dr)\n{\n\tif ((dr != 4 && dr != 5) || !kvm_read_cr4_bits(vcpu, X86_CR4_DE))\n\t\treturn true;\n\n\tkvm_queue_exception(vcpu, UD_VECTOR);\n\treturn false;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_queue_exception",
          "args": [
            "vcpu",
            "UD_VECTOR"
          ],
          "line": 485
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_queue_exception",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "409-412",
          "snippet": "void kvm_queue_exception(struct kvm_vcpu *vcpu, unsigned nr)\n{\n\tkvm_multiple_exception(vcpu, nr, false, 0, false);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nvoid kvm_queue_exception(struct kvm_vcpu *vcpu, unsigned nr)\n{\n\tkvm_multiple_exception(vcpu, nr, false, 0, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_read_cr4_bits",
          "args": [
            "vcpu",
            "X86_CR4_DE"
          ],
          "line": 482
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_read_cr4_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "61-67",
          "snippet": "static inline ulong kvm_read_cr4_bits(struct kvm_vcpu *vcpu, ulong mask)\n{\n\tulong tmask = mask & KVM_POSSIBLE_CR4_GUEST_BITS;\n\tif (tmask & vcpu->arch.cr4_guest_owned_bits)\n\t\tkvm_x86_ops->decache_cr4_guest_bits(vcpu);\n\treturn vcpu->arch.cr4 & mask;\n}",
          "includes": [],
          "macros_used": [
            "#define KVM_POSSIBLE_CR4_GUEST_BITS\t\t\t\t  \\\n\t(X86_CR4_PVI | X86_CR4_DE | X86_CR4_PCE | X86_CR4_OSFXSR  \\\n\t | X86_CR4_OSXMMEXCPT | X86_CR4_PGE)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define KVM_POSSIBLE_CR4_GUEST_BITS\t\t\t\t  \\\n\t(X86_CR4_PVI | X86_CR4_DE | X86_CR4_PCE | X86_CR4_OSFXSR  \\\n\t | X86_CR4_OSXMMEXCPT | X86_CR4_PGE)\n\nstatic inline ulong kvm_read_cr4_bits(struct kvm_vcpu *vcpu, ulong mask)\n{\n\tulong tmask = mask & KVM_POSSIBLE_CR4_GUEST_BITS;\n\tif (tmask & vcpu->arch.cr4_guest_owned_bits)\n\t\tkvm_x86_ops->decache_cr4_guest_bits(vcpu);\n\treturn vcpu->arch.cr4 & mask;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nbool kvm_require_dr(struct kvm_vcpu *vcpu, int dr)\n{\n\tif ((dr != 4 && dr != 5) || !kvm_read_cr4_bits(vcpu, X86_CR4_DE))\n\t\treturn true;\n\n\tkvm_queue_exception(vcpu, UD_VECTOR);\n\treturn false;\n}"
  },
  {
    "function_name": "kvm_require_cpl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "471-477",
    "snippet": "bool kvm_require_cpl(struct kvm_vcpu *vcpu, int required_cpl)\n{\n\tif (kvm_x86_ops->get_cpl(vcpu) <= required_cpl)\n\t\treturn true;\n\tkvm_queue_exception_e(vcpu, GP_VECTOR, 0);\n\treturn false;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);",
      "struct kvm_x86_ops *kvm_x86_ops"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_queue_exception_e",
          "args": [
            "vcpu",
            "GP_VECTOR",
            "0"
          ],
          "line": 475
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_queue_exception_e",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "455-458",
          "snippet": "void kvm_queue_exception_e(struct kvm_vcpu *vcpu, unsigned nr, u32 error_code)\n{\n\tkvm_multiple_exception(vcpu, nr, true, error_code, false);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nvoid kvm_queue_exception_e(struct kvm_vcpu *vcpu, unsigned nr, u32 error_code)\n{\n\tkvm_multiple_exception(vcpu, nr, true, error_code, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_x86_ops->get_cpl",
          "args": [
            "vcpu"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nbool kvm_require_cpl(struct kvm_vcpu *vcpu, int required_cpl)\n{\n\tif (kvm_x86_ops->get_cpl(vcpu) <= required_cpl)\n\t\treturn true;\n\tkvm_queue_exception_e(vcpu, GP_VECTOR, 0);\n\treturn false;\n}"
  },
  {
    "function_name": "kvm_requeue_exception_e",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "461-464",
    "snippet": "void kvm_requeue_exception_e(struct kvm_vcpu *vcpu, unsigned nr, u32 error_code)\n{\n\tkvm_multiple_exception(vcpu, nr, true, error_code, true);\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_multiple_exception",
          "args": [
            "vcpu",
            "nr",
            "true",
            "error_code",
            "true"
          ],
          "line": 463
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_multiple_exception",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "365-407",
          "snippet": "static void kvm_multiple_exception(struct kvm_vcpu *vcpu,\n\t\tunsigned nr, bool has_error, u32 error_code,\n\t\tbool reinject)\n{\n\tu32 prev_nr;\n\tint class1, class2;\n\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\n\tif (!vcpu->arch.exception.pending) {\n\tqueue:\n\t\tif (has_error && !is_protmode(vcpu))\n\t\t\thas_error = false;\n\t\tvcpu->arch.exception.pending = true;\n\t\tvcpu->arch.exception.has_error_code = has_error;\n\t\tvcpu->arch.exception.nr = nr;\n\t\tvcpu->arch.exception.error_code = error_code;\n\t\tvcpu->arch.exception.reinject = reinject;\n\t\treturn;\n\t}\n\n\t/* to check exception */\n\tprev_nr = vcpu->arch.exception.nr;\n\tif (prev_nr == DF_VECTOR) {\n\t\t/* triple fault -> shutdown */\n\t\tkvm_make_request(KVM_REQ_TRIPLE_FAULT, vcpu);\n\t\treturn;\n\t}\n\tclass1 = exception_class(prev_nr);\n\tclass2 = exception_class(nr);\n\tif ((class1 == EXCPT_CONTRIBUTORY && class2 == EXCPT_CONTRIBUTORY)\n\t\t|| (class1 == EXCPT_PF && class2 != EXCPT_BENIGN)) {\n\t\t/* generate double fault per SDM Table 5-5 */\n\t\tvcpu->arch.exception.pending = true;\n\t\tvcpu->arch.exception.has_error_code = true;\n\t\tvcpu->arch.exception.nr = DF_VECTOR;\n\t\tvcpu->arch.exception.error_code = 0;\n\t} else\n\t\t/* replace previous exception with a new one in a hope\n\t\t   that instruction re-execution will regenerate lost\n\t\t   exception */\n\t\tgoto queue;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define EXCPT_PF\t\t2",
            "#define EXCPT_CONTRIBUTORY\t1",
            "#define EXCPT_BENIGN\t\t0"
          ],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define EXCPT_PF\t\t2\n#define EXCPT_CONTRIBUTORY\t1\n#define EXCPT_BENIGN\t\t0\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic void kvm_multiple_exception(struct kvm_vcpu *vcpu,\n\t\tunsigned nr, bool has_error, u32 error_code,\n\t\tbool reinject)\n{\n\tu32 prev_nr;\n\tint class1, class2;\n\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\n\tif (!vcpu->arch.exception.pending) {\n\tqueue:\n\t\tif (has_error && !is_protmode(vcpu))\n\t\t\thas_error = false;\n\t\tvcpu->arch.exception.pending = true;\n\t\tvcpu->arch.exception.has_error_code = has_error;\n\t\tvcpu->arch.exception.nr = nr;\n\t\tvcpu->arch.exception.error_code = error_code;\n\t\tvcpu->arch.exception.reinject = reinject;\n\t\treturn;\n\t}\n\n\t/* to check exception */\n\tprev_nr = vcpu->arch.exception.nr;\n\tif (prev_nr == DF_VECTOR) {\n\t\t/* triple fault -> shutdown */\n\t\tkvm_make_request(KVM_REQ_TRIPLE_FAULT, vcpu);\n\t\treturn;\n\t}\n\tclass1 = exception_class(prev_nr);\n\tclass2 = exception_class(nr);\n\tif ((class1 == EXCPT_CONTRIBUTORY && class2 == EXCPT_CONTRIBUTORY)\n\t\t|| (class1 == EXCPT_PF && class2 != EXCPT_BENIGN)) {\n\t\t/* generate double fault per SDM Table 5-5 */\n\t\tvcpu->arch.exception.pending = true;\n\t\tvcpu->arch.exception.has_error_code = true;\n\t\tvcpu->arch.exception.nr = DF_VECTOR;\n\t\tvcpu->arch.exception.error_code = 0;\n\t} else\n\t\t/* replace previous exception with a new one in a hope\n\t\t   that instruction re-execution will regenerate lost\n\t\t   exception */\n\t\tgoto queue;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nvoid kvm_requeue_exception_e(struct kvm_vcpu *vcpu, unsigned nr, u32 error_code)\n{\n\tkvm_multiple_exception(vcpu, nr, true, error_code, true);\n}"
  },
  {
    "function_name": "kvm_queue_exception_e",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "455-458",
    "snippet": "void kvm_queue_exception_e(struct kvm_vcpu *vcpu, unsigned nr, u32 error_code)\n{\n\tkvm_multiple_exception(vcpu, nr, true, error_code, false);\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_multiple_exception",
          "args": [
            "vcpu",
            "nr",
            "true",
            "error_code",
            "false"
          ],
          "line": 457
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_multiple_exception",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "365-407",
          "snippet": "static void kvm_multiple_exception(struct kvm_vcpu *vcpu,\n\t\tunsigned nr, bool has_error, u32 error_code,\n\t\tbool reinject)\n{\n\tu32 prev_nr;\n\tint class1, class2;\n\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\n\tif (!vcpu->arch.exception.pending) {\n\tqueue:\n\t\tif (has_error && !is_protmode(vcpu))\n\t\t\thas_error = false;\n\t\tvcpu->arch.exception.pending = true;\n\t\tvcpu->arch.exception.has_error_code = has_error;\n\t\tvcpu->arch.exception.nr = nr;\n\t\tvcpu->arch.exception.error_code = error_code;\n\t\tvcpu->arch.exception.reinject = reinject;\n\t\treturn;\n\t}\n\n\t/* to check exception */\n\tprev_nr = vcpu->arch.exception.nr;\n\tif (prev_nr == DF_VECTOR) {\n\t\t/* triple fault -> shutdown */\n\t\tkvm_make_request(KVM_REQ_TRIPLE_FAULT, vcpu);\n\t\treturn;\n\t}\n\tclass1 = exception_class(prev_nr);\n\tclass2 = exception_class(nr);\n\tif ((class1 == EXCPT_CONTRIBUTORY && class2 == EXCPT_CONTRIBUTORY)\n\t\t|| (class1 == EXCPT_PF && class2 != EXCPT_BENIGN)) {\n\t\t/* generate double fault per SDM Table 5-5 */\n\t\tvcpu->arch.exception.pending = true;\n\t\tvcpu->arch.exception.has_error_code = true;\n\t\tvcpu->arch.exception.nr = DF_VECTOR;\n\t\tvcpu->arch.exception.error_code = 0;\n\t} else\n\t\t/* replace previous exception with a new one in a hope\n\t\t   that instruction re-execution will regenerate lost\n\t\t   exception */\n\t\tgoto queue;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define EXCPT_PF\t\t2",
            "#define EXCPT_CONTRIBUTORY\t1",
            "#define EXCPT_BENIGN\t\t0"
          ],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define EXCPT_PF\t\t2\n#define EXCPT_CONTRIBUTORY\t1\n#define EXCPT_BENIGN\t\t0\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic void kvm_multiple_exception(struct kvm_vcpu *vcpu,\n\t\tunsigned nr, bool has_error, u32 error_code,\n\t\tbool reinject)\n{\n\tu32 prev_nr;\n\tint class1, class2;\n\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\n\tif (!vcpu->arch.exception.pending) {\n\tqueue:\n\t\tif (has_error && !is_protmode(vcpu))\n\t\t\thas_error = false;\n\t\tvcpu->arch.exception.pending = true;\n\t\tvcpu->arch.exception.has_error_code = has_error;\n\t\tvcpu->arch.exception.nr = nr;\n\t\tvcpu->arch.exception.error_code = error_code;\n\t\tvcpu->arch.exception.reinject = reinject;\n\t\treturn;\n\t}\n\n\t/* to check exception */\n\tprev_nr = vcpu->arch.exception.nr;\n\tif (prev_nr == DF_VECTOR) {\n\t\t/* triple fault -> shutdown */\n\t\tkvm_make_request(KVM_REQ_TRIPLE_FAULT, vcpu);\n\t\treturn;\n\t}\n\tclass1 = exception_class(prev_nr);\n\tclass2 = exception_class(nr);\n\tif ((class1 == EXCPT_CONTRIBUTORY && class2 == EXCPT_CONTRIBUTORY)\n\t\t|| (class1 == EXCPT_PF && class2 != EXCPT_BENIGN)) {\n\t\t/* generate double fault per SDM Table 5-5 */\n\t\tvcpu->arch.exception.pending = true;\n\t\tvcpu->arch.exception.has_error_code = true;\n\t\tvcpu->arch.exception.nr = DF_VECTOR;\n\t\tvcpu->arch.exception.error_code = 0;\n\t} else\n\t\t/* replace previous exception with a new one in a hope\n\t\t   that instruction re-execution will regenerate lost\n\t\t   exception */\n\t\tgoto queue;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nvoid kvm_queue_exception_e(struct kvm_vcpu *vcpu, unsigned nr, u32 error_code)\n{\n\tkvm_multiple_exception(vcpu, nr, true, error_code, false);\n}"
  },
  {
    "function_name": "kvm_inject_nmi",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "448-452",
    "snippet": "void kvm_inject_nmi(struct kvm_vcpu *vcpu)\n{\n\tatomic_inc(&vcpu->arch.nmi_queued);\n\tkvm_make_request(KVM_REQ_NMI, vcpu);\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_make_request",
          "args": [
            "KVM_REQ_NMI",
            "vcpu"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&vcpu->arch.nmi_queued"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nvoid kvm_inject_nmi(struct kvm_vcpu *vcpu)\n{\n\tatomic_inc(&vcpu->arch.nmi_queued);\n\tkvm_make_request(KVM_REQ_NMI, vcpu);\n}"
  },
  {
    "function_name": "kvm_propagate_fault",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "438-446",
    "snippet": "static bool kvm_propagate_fault(struct kvm_vcpu *vcpu, struct x86_exception *fault)\n{\n\tif (mmu_is_nested(vcpu) && !fault->nested_page_fault)\n\t\tvcpu->arch.nested_mmu.inject_page_fault(vcpu, fault);\n\telse\n\t\tvcpu->arch.mmu.inject_page_fault(vcpu, fault);\n\n\treturn fault->nested_page_fault;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vcpu->arch.mmu.inject_page_fault",
          "args": [
            "vcpu",
            "fault"
          ],
          "line": 443
        },
        "resolved": true,
        "details": {
          "function_name": "inject_page_fault",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "3614-3618",
          "snippet": "static void inject_page_fault(struct kvm_vcpu *vcpu,\n\t\t\t      struct x86_exception *fault)\n{\n\tvcpu->arch.mmu.inject_page_fault(vcpu, fault);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic void inject_page_fault(struct kvm_vcpu *vcpu,\n\t\t\t      struct x86_exception *fault)\n{\n\tvcpu->arch.mmu.inject_page_fault(vcpu, fault);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mmu_is_nested",
          "args": [
            "vcpu"
          ],
          "line": 440
        },
        "resolved": true,
        "details": {
          "function_name": "mmu_is_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.h",
          "lines": "62-65",
          "snippet": "static inline bool mmu_is_nested(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.walk_mmu == &vcpu->arch.nested_mmu;\n}",
          "includes": [
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline bool mmu_is_nested(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.walk_mmu == &vcpu->arch.nested_mmu;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic bool kvm_propagate_fault(struct kvm_vcpu *vcpu, struct x86_exception *fault)\n{\n\tif (mmu_is_nested(vcpu) && !fault->nested_page_fault)\n\t\tvcpu->arch.nested_mmu.inject_page_fault(vcpu, fault);\n\telse\n\t\tvcpu->arch.mmu.inject_page_fault(vcpu, fault);\n\n\treturn fault->nested_page_fault;\n}"
  },
  {
    "function_name": "kvm_inject_page_fault",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "430-435",
    "snippet": "void kvm_inject_page_fault(struct kvm_vcpu *vcpu, struct x86_exception *fault)\n{\n\t++vcpu->stat.pf_guest;\n\tvcpu->arch.cr2 = fault->address;\n\tkvm_queue_exception_e(vcpu, PF_VECTOR, fault->error_code);\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_queue_exception_e",
          "args": [
            "vcpu",
            "PF_VECTOR",
            "fault->error_code"
          ],
          "line": 434
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_queue_exception_e",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "455-458",
          "snippet": "void kvm_queue_exception_e(struct kvm_vcpu *vcpu, unsigned nr, u32 error_code)\n{\n\tkvm_multiple_exception(vcpu, nr, true, error_code, false);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nvoid kvm_queue_exception_e(struct kvm_vcpu *vcpu, unsigned nr, u32 error_code)\n{\n\tkvm_multiple_exception(vcpu, nr, true, error_code, false);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nvoid kvm_inject_page_fault(struct kvm_vcpu *vcpu, struct x86_exception *fault)\n{\n\t++vcpu->stat.pf_guest;\n\tvcpu->arch.cr2 = fault->address;\n\tkvm_queue_exception_e(vcpu, PF_VECTOR, fault->error_code);\n}"
  },
  {
    "function_name": "kvm_complete_insn_gp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "421-427",
    "snippet": "void kvm_complete_insn_gp(struct kvm_vcpu *vcpu, int err)\n{\n\tif (err)\n\t\tkvm_inject_gp(vcpu, 0);\n\telse\n\t\tkvm_x86_ops->skip_emulated_instruction(vcpu);\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);",
      "struct kvm_x86_ops *kvm_x86_ops"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_x86_ops->skip_emulated_instruction",
          "args": [
            "vcpu"
          ],
          "line": 426
        },
        "resolved": true,
        "details": {
          "function_name": "skip_emulated_instruction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/vmx.c",
          "lines": "2329-2339",
          "snippet": "static void skip_emulated_instruction(struct kvm_vcpu *vcpu)\n{\n\tunsigned long rip;\n\n\trip = kvm_rip_read(vcpu);\n\trip += vmcs_read32(VM_EXIT_INSTRUCTION_LEN);\n\tkvm_rip_write(vcpu, rip);\n\n\t/* skipping an emulated instruction also counts */\n\tvmx_set_interrupt_shadow(vcpu, 0);\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"trace.h\"",
            "#include <asm/irq_remapping.h>",
            "#include <asm/apic.h>",
            "#include <asm/kexec.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/mce.h>",
            "#include <asm/virtext.h>",
            "#include <asm/vmx.h>",
            "#include <asm/desc.h>",
            "#include <asm/io.h>",
            "#include <asm/cpu.h>",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/hrtimer.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include \"lapic.h\"",
            "#include \"cpuid.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long nested_ept_get_cr3(struct kvm_vcpu *vcpu);",
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);",
            "static void ept_save_pdptrs(struct kvm_vcpu *vcpu);",
            "static void vmx_decache_cr0_guest_bits(struct kvm_vcpu *vcpu);",
            "static void vmx_leave_nested(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"trace.h\"\n#include <asm/irq_remapping.h>\n#include <asm/apic.h>\n#include <asm/kexec.h>\n#include <asm/debugreg.h>\n#include <asm/perf_event.h>\n#include <asm/fpu/internal.h>\n#include <asm/mce.h>\n#include <asm/virtext.h>\n#include <asm/vmx.h>\n#include <asm/desc.h>\n#include <asm/io.h>\n#include <asm/cpu.h>\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/hrtimer.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic unsigned long nested_ept_get_cr3(struct kvm_vcpu *vcpu);\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\nstatic void ept_save_pdptrs(struct kvm_vcpu *vcpu);\nstatic void vmx_decache_cr0_guest_bits(struct kvm_vcpu *vcpu);\nstatic void vmx_leave_nested(struct kvm_vcpu *vcpu);\n\nstatic void skip_emulated_instruction(struct kvm_vcpu *vcpu)\n{\n\tunsigned long rip;\n\n\trip = kvm_rip_read(vcpu);\n\trip += vmcs_read32(VM_EXIT_INSTRUCTION_LEN);\n\tkvm_rip_write(vcpu, rip);\n\n\t/* skipping an emulated instruction also counts */\n\tvmx_set_interrupt_shadow(vcpu, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_inject_gp",
          "args": [
            "vcpu",
            "0"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nvoid kvm_complete_insn_gp(struct kvm_vcpu *vcpu, int err)\n{\n\tif (err)\n\t\tkvm_inject_gp(vcpu, 0);\n\telse\n\t\tkvm_x86_ops->skip_emulated_instruction(vcpu);\n}"
  },
  {
    "function_name": "kvm_requeue_exception",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "415-418",
    "snippet": "void kvm_requeue_exception(struct kvm_vcpu *vcpu, unsigned nr)\n{\n\tkvm_multiple_exception(vcpu, nr, false, 0, true);\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_multiple_exception",
          "args": [
            "vcpu",
            "nr",
            "false",
            "0",
            "true"
          ],
          "line": 417
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_multiple_exception",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "365-407",
          "snippet": "static void kvm_multiple_exception(struct kvm_vcpu *vcpu,\n\t\tunsigned nr, bool has_error, u32 error_code,\n\t\tbool reinject)\n{\n\tu32 prev_nr;\n\tint class1, class2;\n\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\n\tif (!vcpu->arch.exception.pending) {\n\tqueue:\n\t\tif (has_error && !is_protmode(vcpu))\n\t\t\thas_error = false;\n\t\tvcpu->arch.exception.pending = true;\n\t\tvcpu->arch.exception.has_error_code = has_error;\n\t\tvcpu->arch.exception.nr = nr;\n\t\tvcpu->arch.exception.error_code = error_code;\n\t\tvcpu->arch.exception.reinject = reinject;\n\t\treturn;\n\t}\n\n\t/* to check exception */\n\tprev_nr = vcpu->arch.exception.nr;\n\tif (prev_nr == DF_VECTOR) {\n\t\t/* triple fault -> shutdown */\n\t\tkvm_make_request(KVM_REQ_TRIPLE_FAULT, vcpu);\n\t\treturn;\n\t}\n\tclass1 = exception_class(prev_nr);\n\tclass2 = exception_class(nr);\n\tif ((class1 == EXCPT_CONTRIBUTORY && class2 == EXCPT_CONTRIBUTORY)\n\t\t|| (class1 == EXCPT_PF && class2 != EXCPT_BENIGN)) {\n\t\t/* generate double fault per SDM Table 5-5 */\n\t\tvcpu->arch.exception.pending = true;\n\t\tvcpu->arch.exception.has_error_code = true;\n\t\tvcpu->arch.exception.nr = DF_VECTOR;\n\t\tvcpu->arch.exception.error_code = 0;\n\t} else\n\t\t/* replace previous exception with a new one in a hope\n\t\t   that instruction re-execution will regenerate lost\n\t\t   exception */\n\t\tgoto queue;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define EXCPT_PF\t\t2",
            "#define EXCPT_CONTRIBUTORY\t1",
            "#define EXCPT_BENIGN\t\t0"
          ],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define EXCPT_PF\t\t2\n#define EXCPT_CONTRIBUTORY\t1\n#define EXCPT_BENIGN\t\t0\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic void kvm_multiple_exception(struct kvm_vcpu *vcpu,\n\t\tunsigned nr, bool has_error, u32 error_code,\n\t\tbool reinject)\n{\n\tu32 prev_nr;\n\tint class1, class2;\n\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\n\tif (!vcpu->arch.exception.pending) {\n\tqueue:\n\t\tif (has_error && !is_protmode(vcpu))\n\t\t\thas_error = false;\n\t\tvcpu->arch.exception.pending = true;\n\t\tvcpu->arch.exception.has_error_code = has_error;\n\t\tvcpu->arch.exception.nr = nr;\n\t\tvcpu->arch.exception.error_code = error_code;\n\t\tvcpu->arch.exception.reinject = reinject;\n\t\treturn;\n\t}\n\n\t/* to check exception */\n\tprev_nr = vcpu->arch.exception.nr;\n\tif (prev_nr == DF_VECTOR) {\n\t\t/* triple fault -> shutdown */\n\t\tkvm_make_request(KVM_REQ_TRIPLE_FAULT, vcpu);\n\t\treturn;\n\t}\n\tclass1 = exception_class(prev_nr);\n\tclass2 = exception_class(nr);\n\tif ((class1 == EXCPT_CONTRIBUTORY && class2 == EXCPT_CONTRIBUTORY)\n\t\t|| (class1 == EXCPT_PF && class2 != EXCPT_BENIGN)) {\n\t\t/* generate double fault per SDM Table 5-5 */\n\t\tvcpu->arch.exception.pending = true;\n\t\tvcpu->arch.exception.has_error_code = true;\n\t\tvcpu->arch.exception.nr = DF_VECTOR;\n\t\tvcpu->arch.exception.error_code = 0;\n\t} else\n\t\t/* replace previous exception with a new one in a hope\n\t\t   that instruction re-execution will regenerate lost\n\t\t   exception */\n\t\tgoto queue;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nvoid kvm_requeue_exception(struct kvm_vcpu *vcpu, unsigned nr)\n{\n\tkvm_multiple_exception(vcpu, nr, false, 0, true);\n}"
  },
  {
    "function_name": "kvm_queue_exception",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "409-412",
    "snippet": "void kvm_queue_exception(struct kvm_vcpu *vcpu, unsigned nr)\n{\n\tkvm_multiple_exception(vcpu, nr, false, 0, false);\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_multiple_exception",
          "args": [
            "vcpu",
            "nr",
            "false",
            "0",
            "false"
          ],
          "line": 411
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_multiple_exception",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "365-407",
          "snippet": "static void kvm_multiple_exception(struct kvm_vcpu *vcpu,\n\t\tunsigned nr, bool has_error, u32 error_code,\n\t\tbool reinject)\n{\n\tu32 prev_nr;\n\tint class1, class2;\n\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\n\tif (!vcpu->arch.exception.pending) {\n\tqueue:\n\t\tif (has_error && !is_protmode(vcpu))\n\t\t\thas_error = false;\n\t\tvcpu->arch.exception.pending = true;\n\t\tvcpu->arch.exception.has_error_code = has_error;\n\t\tvcpu->arch.exception.nr = nr;\n\t\tvcpu->arch.exception.error_code = error_code;\n\t\tvcpu->arch.exception.reinject = reinject;\n\t\treturn;\n\t}\n\n\t/* to check exception */\n\tprev_nr = vcpu->arch.exception.nr;\n\tif (prev_nr == DF_VECTOR) {\n\t\t/* triple fault -> shutdown */\n\t\tkvm_make_request(KVM_REQ_TRIPLE_FAULT, vcpu);\n\t\treturn;\n\t}\n\tclass1 = exception_class(prev_nr);\n\tclass2 = exception_class(nr);\n\tif ((class1 == EXCPT_CONTRIBUTORY && class2 == EXCPT_CONTRIBUTORY)\n\t\t|| (class1 == EXCPT_PF && class2 != EXCPT_BENIGN)) {\n\t\t/* generate double fault per SDM Table 5-5 */\n\t\tvcpu->arch.exception.pending = true;\n\t\tvcpu->arch.exception.has_error_code = true;\n\t\tvcpu->arch.exception.nr = DF_VECTOR;\n\t\tvcpu->arch.exception.error_code = 0;\n\t} else\n\t\t/* replace previous exception with a new one in a hope\n\t\t   that instruction re-execution will regenerate lost\n\t\t   exception */\n\t\tgoto queue;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define EXCPT_PF\t\t2",
            "#define EXCPT_CONTRIBUTORY\t1",
            "#define EXCPT_BENIGN\t\t0"
          ],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define EXCPT_PF\t\t2\n#define EXCPT_CONTRIBUTORY\t1\n#define EXCPT_BENIGN\t\t0\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic void kvm_multiple_exception(struct kvm_vcpu *vcpu,\n\t\tunsigned nr, bool has_error, u32 error_code,\n\t\tbool reinject)\n{\n\tu32 prev_nr;\n\tint class1, class2;\n\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\n\tif (!vcpu->arch.exception.pending) {\n\tqueue:\n\t\tif (has_error && !is_protmode(vcpu))\n\t\t\thas_error = false;\n\t\tvcpu->arch.exception.pending = true;\n\t\tvcpu->arch.exception.has_error_code = has_error;\n\t\tvcpu->arch.exception.nr = nr;\n\t\tvcpu->arch.exception.error_code = error_code;\n\t\tvcpu->arch.exception.reinject = reinject;\n\t\treturn;\n\t}\n\n\t/* to check exception */\n\tprev_nr = vcpu->arch.exception.nr;\n\tif (prev_nr == DF_VECTOR) {\n\t\t/* triple fault -> shutdown */\n\t\tkvm_make_request(KVM_REQ_TRIPLE_FAULT, vcpu);\n\t\treturn;\n\t}\n\tclass1 = exception_class(prev_nr);\n\tclass2 = exception_class(nr);\n\tif ((class1 == EXCPT_CONTRIBUTORY && class2 == EXCPT_CONTRIBUTORY)\n\t\t|| (class1 == EXCPT_PF && class2 != EXCPT_BENIGN)) {\n\t\t/* generate double fault per SDM Table 5-5 */\n\t\tvcpu->arch.exception.pending = true;\n\t\tvcpu->arch.exception.has_error_code = true;\n\t\tvcpu->arch.exception.nr = DF_VECTOR;\n\t\tvcpu->arch.exception.error_code = 0;\n\t} else\n\t\t/* replace previous exception with a new one in a hope\n\t\t   that instruction re-execution will regenerate lost\n\t\t   exception */\n\t\tgoto queue;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nvoid kvm_queue_exception(struct kvm_vcpu *vcpu, unsigned nr)\n{\n\tkvm_multiple_exception(vcpu, nr, false, 0, false);\n}"
  },
  {
    "function_name": "kvm_multiple_exception",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "365-407",
    "snippet": "static void kvm_multiple_exception(struct kvm_vcpu *vcpu,\n\t\tunsigned nr, bool has_error, u32 error_code,\n\t\tbool reinject)\n{\n\tu32 prev_nr;\n\tint class1, class2;\n\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\n\tif (!vcpu->arch.exception.pending) {\n\tqueue:\n\t\tif (has_error && !is_protmode(vcpu))\n\t\t\thas_error = false;\n\t\tvcpu->arch.exception.pending = true;\n\t\tvcpu->arch.exception.has_error_code = has_error;\n\t\tvcpu->arch.exception.nr = nr;\n\t\tvcpu->arch.exception.error_code = error_code;\n\t\tvcpu->arch.exception.reinject = reinject;\n\t\treturn;\n\t}\n\n\t/* to check exception */\n\tprev_nr = vcpu->arch.exception.nr;\n\tif (prev_nr == DF_VECTOR) {\n\t\t/* triple fault -> shutdown */\n\t\tkvm_make_request(KVM_REQ_TRIPLE_FAULT, vcpu);\n\t\treturn;\n\t}\n\tclass1 = exception_class(prev_nr);\n\tclass2 = exception_class(nr);\n\tif ((class1 == EXCPT_CONTRIBUTORY && class2 == EXCPT_CONTRIBUTORY)\n\t\t|| (class1 == EXCPT_PF && class2 != EXCPT_BENIGN)) {\n\t\t/* generate double fault per SDM Table 5-5 */\n\t\tvcpu->arch.exception.pending = true;\n\t\tvcpu->arch.exception.has_error_code = true;\n\t\tvcpu->arch.exception.nr = DF_VECTOR;\n\t\tvcpu->arch.exception.error_code = 0;\n\t} else\n\t\t/* replace previous exception with a new one in a hope\n\t\t   that instruction re-execution will regenerate lost\n\t\t   exception */\n\t\tgoto queue;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define EXCPT_PF\t\t2",
      "#define EXCPT_CONTRIBUTORY\t1",
      "#define EXCPT_BENIGN\t\t0"
    ],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "exception_class",
          "args": [
            "nr"
          ],
          "line": 394
        },
        "resolved": true,
        "details": {
          "function_name": "exception_class",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "323-338",
          "snippet": "static int exception_class(int vector)\n{\n\tswitch (vector) {\n\tcase PF_VECTOR:\n\t\treturn EXCPT_PF;\n\tcase DE_VECTOR:\n\tcase TS_VECTOR:\n\tcase NP_VECTOR:\n\tcase SS_VECTOR:\n\tcase GP_VECTOR:\n\t\treturn EXCPT_CONTRIBUTORY;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn EXCPT_BENIGN;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define EXCPT_PF\t\t2",
            "#define EXCPT_CONTRIBUTORY\t1",
            "#define EXCPT_BENIGN\t\t0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define EXCPT_PF\t\t2\n#define EXCPT_CONTRIBUTORY\t1\n#define EXCPT_BENIGN\t\t0\n\nstatic int exception_class(int vector)\n{\n\tswitch (vector) {\n\tcase PF_VECTOR:\n\t\treturn EXCPT_PF;\n\tcase DE_VECTOR:\n\tcase TS_VECTOR:\n\tcase NP_VECTOR:\n\tcase SS_VECTOR:\n\tcase GP_VECTOR:\n\t\treturn EXCPT_CONTRIBUTORY;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn EXCPT_BENIGN;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_make_request",
          "args": [
            "KVM_REQ_TRIPLE_FAULT",
            "vcpu"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_protmode",
          "args": [
            "vcpu"
          ],
          "line": 376
        },
        "resolved": true,
        "details": {
          "function_name": "is_protmode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.h",
          "lines": "38-41",
          "snippet": "static inline bool is_protmode(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_read_cr0_bits(vcpu, X86_CR0_PE);\n}",
          "includes": [
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline bool is_protmode(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_read_cr0_bits(vcpu, X86_CR0_PE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_make_request",
          "args": [
            "KVM_REQ_EVENT",
            "vcpu"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define EXCPT_PF\t\t2\n#define EXCPT_CONTRIBUTORY\t1\n#define EXCPT_BENIGN\t\t0\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic void kvm_multiple_exception(struct kvm_vcpu *vcpu,\n\t\tunsigned nr, bool has_error, u32 error_code,\n\t\tbool reinject)\n{\n\tu32 prev_nr;\n\tint class1, class2;\n\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\n\tif (!vcpu->arch.exception.pending) {\n\tqueue:\n\t\tif (has_error && !is_protmode(vcpu))\n\t\t\thas_error = false;\n\t\tvcpu->arch.exception.pending = true;\n\t\tvcpu->arch.exception.has_error_code = has_error;\n\t\tvcpu->arch.exception.nr = nr;\n\t\tvcpu->arch.exception.error_code = error_code;\n\t\tvcpu->arch.exception.reinject = reinject;\n\t\treturn;\n\t}\n\n\t/* to check exception */\n\tprev_nr = vcpu->arch.exception.nr;\n\tif (prev_nr == DF_VECTOR) {\n\t\t/* triple fault -> shutdown */\n\t\tkvm_make_request(KVM_REQ_TRIPLE_FAULT, vcpu);\n\t\treturn;\n\t}\n\tclass1 = exception_class(prev_nr);\n\tclass2 = exception_class(nr);\n\tif ((class1 == EXCPT_CONTRIBUTORY && class2 == EXCPT_CONTRIBUTORY)\n\t\t|| (class1 == EXCPT_PF && class2 != EXCPT_BENIGN)) {\n\t\t/* generate double fault per SDM Table 5-5 */\n\t\tvcpu->arch.exception.pending = true;\n\t\tvcpu->arch.exception.has_error_code = true;\n\t\tvcpu->arch.exception.nr = DF_VECTOR;\n\t\tvcpu->arch.exception.error_code = 0;\n\t} else\n\t\t/* replace previous exception with a new one in a hope\n\t\t   that instruction re-execution will regenerate lost\n\t\t   exception */\n\t\tgoto queue;\n}"
  },
  {
    "function_name": "exception_type",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "345-363",
    "snippet": "static int exception_type(int vector)\n{\n\tunsigned int mask;\n\n\tif (WARN_ON(vector > 31 || vector == NMI_VECTOR))\n\t\treturn EXCPT_INTERRUPT;\n\n\tmask = 1 << vector;\n\n\t/* #DB is trap, as instruction watchpoints are handled elsewhere */\n\tif (mask & ((1 << DB_VECTOR) | (1 << BP_VECTOR) | (1 << OF_VECTOR)))\n\t\treturn EXCPT_TRAP;\n\n\tif (mask & ((1 << DF_VECTOR) | (1 << MC_VECTOR)))\n\t\treturn EXCPT_ABORT;\n\n\t/* Reserved exceptions will result in fault */\n\treturn EXCPT_FAULT;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define EXCPT_INTERRUPT\t\t3",
      "#define EXCPT_ABORT\t\t2",
      "#define EXCPT_TRAP\t\t1",
      "#define EXCPT_FAULT\t\t0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "vector > 31 || vector == NMI_VECTOR"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define EXCPT_INTERRUPT\t\t3\n#define EXCPT_ABORT\t\t2\n#define EXCPT_TRAP\t\t1\n#define EXCPT_FAULT\t\t0\n\nstatic int exception_type(int vector)\n{\n\tunsigned int mask;\n\n\tif (WARN_ON(vector > 31 || vector == NMI_VECTOR))\n\t\treturn EXCPT_INTERRUPT;\n\n\tmask = 1 << vector;\n\n\t/* #DB is trap, as instruction watchpoints are handled elsewhere */\n\tif (mask & ((1 << DB_VECTOR) | (1 << BP_VECTOR) | (1 << OF_VECTOR)))\n\t\treturn EXCPT_TRAP;\n\n\tif (mask & ((1 << DF_VECTOR) | (1 << MC_VECTOR)))\n\t\treturn EXCPT_ABORT;\n\n\t/* Reserved exceptions will result in fault */\n\treturn EXCPT_FAULT;\n}"
  },
  {
    "function_name": "exception_class",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "323-338",
    "snippet": "static int exception_class(int vector)\n{\n\tswitch (vector) {\n\tcase PF_VECTOR:\n\t\treturn EXCPT_PF;\n\tcase DE_VECTOR:\n\tcase TS_VECTOR:\n\tcase NP_VECTOR:\n\tcase SS_VECTOR:\n\tcase GP_VECTOR:\n\t\treturn EXCPT_CONTRIBUTORY;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn EXCPT_BENIGN;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define EXCPT_PF\t\t2",
      "#define EXCPT_CONTRIBUTORY\t1",
      "#define EXCPT_BENIGN\t\t0"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define EXCPT_PF\t\t2\n#define EXCPT_CONTRIBUTORY\t1\n#define EXCPT_BENIGN\t\t0\n\nstatic int exception_class(int vector)\n{\n\tswitch (vector) {\n\tcase PF_VECTOR:\n\t\treturn EXCPT_PF;\n\tcase DE_VECTOR:\n\tcase TS_VECTOR:\n\tcase NP_VECTOR:\n\tcase SS_VECTOR:\n\tcase GP_VECTOR:\n\t\treturn EXCPT_CONTRIBUTORY;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn EXCPT_BENIGN;\n}"
  },
  {
    "function_name": "kvm_spurious_fault",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "312-316",
    "snippet": "void kvm_spurious_fault(void)\n{\n\t/* Fault while not rebooting.  We want the trace. */\n\tBUG();\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nvoid kvm_spurious_fault(void)\n{\n\t/* Fault while not rebooting.  We want the trace. */\n\tBUG();\n}"
  },
  {
    "function_name": "kvm_set_apic_base",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "289-309",
    "snippet": "int kvm_set_apic_base(struct kvm_vcpu *vcpu, struct msr_data *msr_info)\n{\n\tu64 old_state = vcpu->arch.apic_base &\n\t\t(MSR_IA32_APICBASE_ENABLE | X2APIC_ENABLE);\n\tu64 new_state = msr_info->data &\n\t\t(MSR_IA32_APICBASE_ENABLE | X2APIC_ENABLE);\n\tu64 reserved_bits = ((~0ULL) << cpuid_maxphyaddr(vcpu)) |\n\t\t0x2ff | (guest_cpuid_has_x2apic(vcpu) ? 0 : X2APIC_ENABLE);\n\n\tif (!msr_info->host_initiated &&\n\t    ((msr_info->data & reserved_bits) != 0 ||\n\t     new_state == X2APIC_ENABLE ||\n\t     (new_state == MSR_IA32_APICBASE_ENABLE &&\n\t      old_state == (MSR_IA32_APICBASE_ENABLE | X2APIC_ENABLE)) ||\n\t     (new_state == (MSR_IA32_APICBASE_ENABLE | X2APIC_ENABLE) &&\n\t      old_state == 0)))\n\t\treturn 1;\n\n\tkvm_lapic_set_base(vcpu, msr_info->data);\n\treturn 0;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_lapic_set_base",
          "args": [
            "vcpu",
            "msr_info->data"
          ],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_set_base",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "1661-1702",
          "snippet": "void kvm_lapic_set_base(struct kvm_vcpu *vcpu, u64 value)\n{\n\tu64 old_value = vcpu->arch.apic_base;\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tif (!apic) {\n\t\tvalue |= MSR_IA32_APICBASE_BSP;\n\t\tvcpu->arch.apic_base = value;\n\t\treturn;\n\t}\n\n\tvcpu->arch.apic_base = value;\n\n\t/* update jump label if enable bit changes */\n\tif ((old_value ^ value) & MSR_IA32_APICBASE_ENABLE) {\n\t\tif (value & MSR_IA32_APICBASE_ENABLE)\n\t\t\tstatic_key_slow_dec_deferred(&apic_hw_disabled);\n\t\telse\n\t\t\tstatic_key_slow_inc(&apic_hw_disabled.key);\n\t\trecalculate_apic_map(vcpu->kvm);\n\t}\n\n\tif ((old_value ^ value) & X2APIC_ENABLE) {\n\t\tif (value & X2APIC_ENABLE) {\n\t\t\tkvm_apic_set_x2apic_id(apic, vcpu->vcpu_id);\n\t\t\tkvm_x86_ops->set_virtual_x2apic_mode(vcpu, true);\n\t\t} else\n\t\t\tkvm_x86_ops->set_virtual_x2apic_mode(vcpu, false);\n\t}\n\n\tapic->base_address = apic->vcpu->arch.apic_base &\n\t\t\t     MSR_IA32_APICBASE_BASE;\n\n\tif ((value & MSR_IA32_APICBASE_ENABLE) &&\n\t     apic->base_address != APIC_DEFAULT_PHYS_BASE)\n\t\tpr_warn_once(\"APIC base relocation is unsupported by KVM\");\n\n\t/* with FSB delivery interrupt, we can restart APIC functionality */\n\tapic_debug(\"apic base msr is 0x%016\" PRIx64 \", and base address is \"\n\t\t   \"0x%lx.\\n\", apic->vcpu->arch.apic_base, apic->base_address);\n\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define PRIx64 \"llx\""
          ],
          "globals_used": [
            "struct static_key_deferred apic_hw_disabled"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\n#define PRIx64 \"llx\"\n\nstruct static_key_deferred apic_hw_disabled;\n\nvoid kvm_lapic_set_base(struct kvm_vcpu *vcpu, u64 value)\n{\n\tu64 old_value = vcpu->arch.apic_base;\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tif (!apic) {\n\t\tvalue |= MSR_IA32_APICBASE_BSP;\n\t\tvcpu->arch.apic_base = value;\n\t\treturn;\n\t}\n\n\tvcpu->arch.apic_base = value;\n\n\t/* update jump label if enable bit changes */\n\tif ((old_value ^ value) & MSR_IA32_APICBASE_ENABLE) {\n\t\tif (value & MSR_IA32_APICBASE_ENABLE)\n\t\t\tstatic_key_slow_dec_deferred(&apic_hw_disabled);\n\t\telse\n\t\t\tstatic_key_slow_inc(&apic_hw_disabled.key);\n\t\trecalculate_apic_map(vcpu->kvm);\n\t}\n\n\tif ((old_value ^ value) & X2APIC_ENABLE) {\n\t\tif (value & X2APIC_ENABLE) {\n\t\t\tkvm_apic_set_x2apic_id(apic, vcpu->vcpu_id);\n\t\t\tkvm_x86_ops->set_virtual_x2apic_mode(vcpu, true);\n\t\t} else\n\t\t\tkvm_x86_ops->set_virtual_x2apic_mode(vcpu, false);\n\t}\n\n\tapic->base_address = apic->vcpu->arch.apic_base &\n\t\t\t     MSR_IA32_APICBASE_BASE;\n\n\tif ((value & MSR_IA32_APICBASE_ENABLE) &&\n\t     apic->base_address != APIC_DEFAULT_PHYS_BASE)\n\t\tpr_warn_once(\"APIC base relocation is unsupported by KVM\");\n\n\t/* with FSB delivery interrupt, we can restart APIC functionality */\n\tapic_debug(\"apic base msr is 0x%016\" PRIx64 \", and base address is \"\n\t\t   \"0x%lx.\\n\", apic->vcpu->arch.apic_base, apic->base_address);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "guest_cpuid_has_x2apic",
          "args": [
            "vcpu"
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "guest_cpuid_has_x2apic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/cpuid.h",
          "lines": "115-121",
          "snippet": "static inline bool guest_cpuid_has_x2apic(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_cpuid_entry2 *best;\n\n\tbest = kvm_find_cpuid_entry(vcpu, 1, 0);\n\treturn best && (best->ecx & bit(X86_FEATURE_X2APIC));\n}",
          "includes": [
            "#include <asm/cpu.h>",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpu.h>\n#include \"x86.h\"\n\nstatic inline bool guest_cpuid_has_x2apic(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_cpuid_entry2 *best;\n\n\tbest = kvm_find_cpuid_entry(vcpu, 1, 0);\n\treturn best && (best->ecx & bit(X86_FEATURE_X2APIC));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuid_maxphyaddr",
          "args": [
            "vcpu"
          ],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "cpuid_maxphyaddr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/cpuid.h",
          "lines": "27-30",
          "snippet": "static inline int cpuid_maxphyaddr(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.maxphyaddr;\n}",
          "includes": [
            "#include <asm/cpu.h>",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpu.h>\n#include \"x86.h\"\n\nstatic inline int cpuid_maxphyaddr(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.maxphyaddr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nint kvm_set_apic_base(struct kvm_vcpu *vcpu, struct msr_data *msr_info)\n{\n\tu64 old_state = vcpu->arch.apic_base &\n\t\t(MSR_IA32_APICBASE_ENABLE | X2APIC_ENABLE);\n\tu64 new_state = msr_info->data &\n\t\t(MSR_IA32_APICBASE_ENABLE | X2APIC_ENABLE);\n\tu64 reserved_bits = ((~0ULL) << cpuid_maxphyaddr(vcpu)) |\n\t\t0x2ff | (guest_cpuid_has_x2apic(vcpu) ? 0 : X2APIC_ENABLE);\n\n\tif (!msr_info->host_initiated &&\n\t    ((msr_info->data & reserved_bits) != 0 ||\n\t     new_state == X2APIC_ENABLE ||\n\t     (new_state == MSR_IA32_APICBASE_ENABLE &&\n\t      old_state == (MSR_IA32_APICBASE_ENABLE | X2APIC_ENABLE)) ||\n\t     (new_state == (MSR_IA32_APICBASE_ENABLE | X2APIC_ENABLE) &&\n\t      old_state == 0)))\n\t\treturn 1;\n\n\tkvm_lapic_set_base(vcpu, msr_info->data);\n\treturn 0;\n}"
  },
  {
    "function_name": "kvm_get_apic_base",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "283-286",
    "snippet": "u64 kvm_get_apic_base(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.apic_base;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nu64 kvm_get_apic_base(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.apic_base;\n}"
  },
  {
    "function_name": "drop_user_return_notifiers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "274-281",
    "snippet": "static void drop_user_return_notifiers(void)\n{\n\tunsigned int cpu = smp_processor_id();\n\tstruct kvm_shared_msrs *smsr = per_cpu_ptr(shared_msrs, cpu);\n\n\tif (smsr->registered)\n\t\tkvm_on_user_return(&smsr->urn);\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kvm_shared_msrs __percpu *shared_msrs;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_on_user_return",
          "args": [
            "&smsr->urn"
          ],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_on_user_return",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "200-216",
          "snippet": "static void kvm_on_user_return(struct user_return_notifier *urn)\n{\n\tunsigned slot;\n\tstruct kvm_shared_msrs *locals\n\t\t= container_of(urn, struct kvm_shared_msrs, urn);\n\tstruct kvm_shared_msr_values *values;\n\n\tfor (slot = 0; slot < shared_msrs_global.nr; ++slot) {\n\t\tvalues = &locals->values[slot];\n\t\tif (values->host != values->curr) {\n\t\t\twrmsrl(shared_msrs_global.msrs[slot], values->host);\n\t\t\tvalues->curr = values->host;\n\t\t}\n\t}\n\tlocals->registered = false;\n\tuser_return_notifier_unregister(urn);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void kvm_on_user_return(struct user_return_notifier *urn)\n{\n\tunsigned slot;\n\tstruct kvm_shared_msrs *locals\n\t\t= container_of(urn, struct kvm_shared_msrs, urn);\n\tstruct kvm_shared_msr_values *values;\n\n\tfor (slot = 0; slot < shared_msrs_global.nr; ++slot) {\n\t\tvalues = &locals->values[slot];\n\t\tif (values->host != values->curr) {\n\t\t\twrmsrl(shared_msrs_global.msrs[slot], values->host);\n\t\t\tvalues->curr = values->host;\n\t\t}\n\t}\n\tlocals->registered = false;\n\tuser_return_notifier_unregister(urn);\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "shared_msrs",
            "cpu"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic struct kvm_shared_msrs __percpu *shared_msrs;\n\nstatic void drop_user_return_notifiers(void)\n{\n\tunsigned int cpu = smp_processor_id();\n\tstruct kvm_shared_msrs *smsr = per_cpu_ptr(shared_msrs, cpu);\n\n\tif (smsr->registered)\n\t\tkvm_on_user_return(&smsr->urn);\n}"
  },
  {
    "function_name": "kvm_set_shared_msr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "252-271",
    "snippet": "int kvm_set_shared_msr(unsigned slot, u64 value, u64 mask)\n{\n\tunsigned int cpu = smp_processor_id();\n\tstruct kvm_shared_msrs *smsr = per_cpu_ptr(shared_msrs, cpu);\n\tint err;\n\n\tif (((value ^ smsr->values[slot].curr) & mask) == 0)\n\t\treturn 0;\n\tsmsr->values[slot].curr = value;\n\terr = wrmsrl_safe(shared_msrs_global.msrs[slot], value);\n\tif (err)\n\t\treturn 1;\n\n\tif (!smsr->registered) {\n\t\tsmsr->urn.on_user_return = kvm_on_user_return;\n\t\tuser_return_notifier_register(&smsr->urn);\n\t\tsmsr->registered = true;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kvm_shared_msrs __percpu *shared_msrs;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "user_return_notifier_register",
          "args": [
            "&smsr->urn"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wrmsrl_safe",
          "args": [
            "shared_msrs_global.msrs[slot]",
            "value"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "shared_msrs",
            "cpu"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic struct kvm_shared_msrs __percpu *shared_msrs;\n\nint kvm_set_shared_msr(unsigned slot, u64 value, u64 mask)\n{\n\tunsigned int cpu = smp_processor_id();\n\tstruct kvm_shared_msrs *smsr = per_cpu_ptr(shared_msrs, cpu);\n\tint err;\n\n\tif (((value ^ smsr->values[slot].curr) & mask) == 0)\n\t\treturn 0;\n\tsmsr->values[slot].curr = value;\n\terr = wrmsrl_safe(shared_msrs_global.msrs[slot], value);\n\tif (err)\n\t\treturn 1;\n\n\tif (!smsr->registered) {\n\t\tsmsr->urn.on_user_return = kvm_on_user_return;\n\t\tuser_return_notifier_register(&smsr->urn);\n\t\tsmsr->registered = true;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "kvm_shared_msr_cpu_online",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "244-250",
    "snippet": "static void kvm_shared_msr_cpu_online(void)\n{\n\tunsigned i;\n\n\tfor (i = 0; i < shared_msrs_global.nr; ++i)\n\t\tshared_msr_update(i, shared_msrs_global.msrs[i]);\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "shared_msr_update",
          "args": [
            "i",
            "shared_msrs_global.msrs[i]"
          ],
          "line": 249
        },
        "resolved": true,
        "details": {
          "function_name": "shared_msr_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "218-233",
          "snippet": "static void shared_msr_update(unsigned slot, u32 msr)\n{\n\tu64 value;\n\tunsigned int cpu = smp_processor_id();\n\tstruct kvm_shared_msrs *smsr = per_cpu_ptr(shared_msrs, cpu);\n\n\t/* only read, and nobody should modify it at this time,\n\t * so don't need lock */\n\tif (slot >= shared_msrs_global.nr) {\n\t\tprintk(KERN_ERR \"kvm: invalid MSR slot!\");\n\t\treturn;\n\t}\n\trdmsrl_safe(msr, &value);\n\tsmsr->values[slot].host = value;\n\tsmsr->values[slot].curr = value;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kvm_shared_msrs __percpu *shared_msrs;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic struct kvm_shared_msrs __percpu *shared_msrs;\n\nstatic void shared_msr_update(unsigned slot, u32 msr)\n{\n\tu64 value;\n\tunsigned int cpu = smp_processor_id();\n\tstruct kvm_shared_msrs *smsr = per_cpu_ptr(shared_msrs, cpu);\n\n\t/* only read, and nobody should modify it at this time,\n\t * so don't need lock */\n\tif (slot >= shared_msrs_global.nr) {\n\t\tprintk(KERN_ERR \"kvm: invalid MSR slot!\");\n\t\treturn;\n\t}\n\trdmsrl_safe(msr, &value);\n\tsmsr->values[slot].host = value;\n\tsmsr->values[slot].curr = value;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void kvm_shared_msr_cpu_online(void)\n{\n\tunsigned i;\n\n\tfor (i = 0; i < shared_msrs_global.nr; ++i)\n\t\tshared_msr_update(i, shared_msrs_global.msrs[i]);\n}"
  },
  {
    "function_name": "kvm_define_shared_msr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "235-241",
    "snippet": "void kvm_define_shared_msr(unsigned slot, u32 msr)\n{\n\tBUG_ON(slot >= KVM_NR_SHARED_MSRS);\n\tshared_msrs_global.msrs[slot] = msr;\n\tif (slot >= shared_msrs_global.nr)\n\t\tshared_msrs_global.nr = slot + 1;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define KVM_NR_SHARED_MSRS 16"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "slot >= KVM_NR_SHARED_MSRS"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define KVM_NR_SHARED_MSRS 16\n\nvoid kvm_define_shared_msr(unsigned slot, u32 msr)\n{\n\tBUG_ON(slot >= KVM_NR_SHARED_MSRS);\n\tshared_msrs_global.msrs[slot] = msr;\n\tif (slot >= shared_msrs_global.nr)\n\t\tshared_msrs_global.nr = slot + 1;\n}"
  },
  {
    "function_name": "shared_msr_update",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "218-233",
    "snippet": "static void shared_msr_update(unsigned slot, u32 msr)\n{\n\tu64 value;\n\tunsigned int cpu = smp_processor_id();\n\tstruct kvm_shared_msrs *smsr = per_cpu_ptr(shared_msrs, cpu);\n\n\t/* only read, and nobody should modify it at this time,\n\t * so don't need lock */\n\tif (slot >= shared_msrs_global.nr) {\n\t\tprintk(KERN_ERR \"kvm: invalid MSR slot!\");\n\t\treturn;\n\t}\n\trdmsrl_safe(msr, &value);\n\tsmsr->values[slot].host = value;\n\tsmsr->values[slot].curr = value;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kvm_shared_msrs __percpu *shared_msrs;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rdmsrl_safe",
          "args": [
            "msr",
            "&value"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"kvm: invalid MSR slot!\""
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "shared_msrs",
            "cpu"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic struct kvm_shared_msrs __percpu *shared_msrs;\n\nstatic void shared_msr_update(unsigned slot, u32 msr)\n{\n\tu64 value;\n\tunsigned int cpu = smp_processor_id();\n\tstruct kvm_shared_msrs *smsr = per_cpu_ptr(shared_msrs, cpu);\n\n\t/* only read, and nobody should modify it at this time,\n\t * so don't need lock */\n\tif (slot >= shared_msrs_global.nr) {\n\t\tprintk(KERN_ERR \"kvm: invalid MSR slot!\");\n\t\treturn;\n\t}\n\trdmsrl_safe(msr, &value);\n\tsmsr->values[slot].host = value;\n\tsmsr->values[slot].curr = value;\n}"
  },
  {
    "function_name": "kvm_on_user_return",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "200-216",
    "snippet": "static void kvm_on_user_return(struct user_return_notifier *urn)\n{\n\tunsigned slot;\n\tstruct kvm_shared_msrs *locals\n\t\t= container_of(urn, struct kvm_shared_msrs, urn);\n\tstruct kvm_shared_msr_values *values;\n\n\tfor (slot = 0; slot < shared_msrs_global.nr; ++slot) {\n\t\tvalues = &locals->values[slot];\n\t\tif (values->host != values->curr) {\n\t\t\twrmsrl(shared_msrs_global.msrs[slot], values->host);\n\t\t\tvalues->curr = values->host;\n\t\t}\n\t}\n\tlocals->registered = false;\n\tuser_return_notifier_unregister(urn);\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "user_return_notifier_unregister",
          "args": [
            "urn"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wrmsrl",
          "args": [
            "shared_msrs_global.msrs[slot]",
            "values->host"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "urn",
            "structkvm_shared_msrs",
            "urn"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void kvm_on_user_return(struct user_return_notifier *urn)\n{\n\tunsigned slot;\n\tstruct kvm_shared_msrs *locals\n\t\t= container_of(urn, struct kvm_shared_msrs, urn);\n\tstruct kvm_shared_msr_values *values;\n\n\tfor (slot = 0; slot < shared_msrs_global.nr; ++slot) {\n\t\tvalues = &locals->values[slot];\n\t\tif (values->host != values->curr) {\n\t\t\twrmsrl(shared_msrs_global.msrs[slot], values->host);\n\t\t\tvalues->curr = values->host;\n\t\t}\n\t}\n\tlocals->registered = false;\n\tuser_return_notifier_unregister(urn);\n}"
  },
  {
    "function_name": "kvm_async_pf_hash_reset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
    "lines": "193-198",
    "snippet": "static inline void kvm_async_pf_hash_reset(struct kvm_vcpu *vcpu)\n{\n\tint i;\n\tfor (i = 0; i < roundup_pow_of_two(ASYNC_PF_PER_VCPU); i++)\n\t\tvcpu->arch.apf.gfns[i] = ~0;\n}",
    "includes": [
      "#include <asm/irq_remapping.h>",
      "#include <asm/div64.h>",
      "#include <asm/pvclock.h>",
      "#include <asm/fpu/internal.h> /* Ugh! */",
      "#include <linux/kernel_stat.h>",
      "#include <asm/mce.h>",
      "#include <asm/desc.h>",
      "#include <asm/msr.h>",
      "#include <asm/debugreg.h>",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <linux/irqbypass.h>",
      "#include <linux/kvm_irqfd.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/pci.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/user-return-notifier.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/intel-iommu.h>",
      "#include <linux/iommu.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mman.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>",
      "#include <linux/kvm.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/clocksource.h>",
      "#include \"hyperv.h\"",
      "#include \"pmu.h\"",
      "#include \"assigned-dev.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"tss.h\"",
      "#include \"i8254.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
      "static void process_nmi(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "roundup_pow_of_two",
          "args": [
            "ASYNC_PF_PER_VCPU"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic inline void kvm_async_pf_hash_reset(struct kvm_vcpu *vcpu)\n{\n\tint i;\n\tfor (i = 0; i < roundup_pow_of_two(ASYNC_PF_PER_VCPU); i++)\n\t\tvcpu->arch.apf.gfns[i] = ~0;\n}"
  }
]