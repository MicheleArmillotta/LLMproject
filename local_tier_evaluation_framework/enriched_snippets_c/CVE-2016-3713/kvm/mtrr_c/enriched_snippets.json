[
  {
    "function_name": "kvm_mtrr_check_gfn_range_consistency",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mtrr.c",
    "lines": "702-732",
    "snippet": "bool kvm_mtrr_check_gfn_range_consistency(struct kvm_vcpu *vcpu, gfn_t gfn,\n\t\t\t\t\t  int page_num)\n{\n\tstruct kvm_mtrr *mtrr_state = &vcpu->arch.mtrr_state;\n\tstruct mtrr_iter iter;\n\tu64 start, end;\n\tint type = -1;\n\n\tstart = gfn_to_gpa(gfn);\n\tend = gfn_to_gpa(gfn + page_num);\n\tmtrr_for_each_mem_type(&iter, mtrr_state, start, end) {\n\t\tif (type == -1) {\n\t\t\ttype = iter.mem_type;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (type != iter.mem_type)\n\t\t\treturn false;\n\t}\n\n\tif (iter.mtrr_disabled)\n\t\treturn true;\n\n\tif (!iter.partial_map)\n\t\treturn true;\n\n\tif (type == -1)\n\t\treturn true;\n\n\treturn type == mtrr_default_type(mtrr_state);\n}",
    "includes": [
      "#include \"mmu.h\"",
      "#include \"cpuid.h\"",
      "#include <asm/mtrr.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mtrr_default_type",
          "args": [
            "mtrr_state"
          ],
          "line": 731
        },
        "resolved": true,
        "details": {
          "function_name": "mtrr_default_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mtrr.c",
          "lines": "118-121",
          "snippet": "static u8 mtrr_default_type(struct kvm_mtrr *mtrr_state)\n{\n\treturn mtrr_state->deftype & IA32_MTRR_DEF_TYPE_TYPE_MASK;\n}",
          "includes": [
            "#include \"mmu.h\"",
            "#include \"cpuid.h\"",
            "#include <asm/mtrr.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define IA32_MTRR_DEF_TYPE_TYPE_MASK\t(0xff)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mmu.h\"\n#include \"cpuid.h\"\n#include <asm/mtrr.h>\n#include <linux/kvm_host.h>\n\n#define IA32_MTRR_DEF_TYPE_TYPE_MASK\t(0xff)\n\nstatic u8 mtrr_default_type(struct kvm_mtrr *mtrr_state)\n{\n\treturn mtrr_state->deftype & IA32_MTRR_DEF_TYPE_TYPE_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mtrr_for_each_mem_type",
          "args": [
            "&iter",
            "mtrr_state",
            "start",
            "end"
          ],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfn_to_gpa",
          "args": [
            "gfn + page_num"
          ],
          "line": 711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfn_to_gpa",
          "args": [
            "gfn"
          ],
          "line": 710
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"mmu.h\"\n#include \"cpuid.h\"\n#include <asm/mtrr.h>\n#include <linux/kvm_host.h>\n\nbool kvm_mtrr_check_gfn_range_consistency(struct kvm_vcpu *vcpu, gfn_t gfn,\n\t\t\t\t\t  int page_num)\n{\n\tstruct kvm_mtrr *mtrr_state = &vcpu->arch.mtrr_state;\n\tstruct mtrr_iter iter;\n\tu64 start, end;\n\tint type = -1;\n\n\tstart = gfn_to_gpa(gfn);\n\tend = gfn_to_gpa(gfn + page_num);\n\tmtrr_for_each_mem_type(&iter, mtrr_state, start, end) {\n\t\tif (type == -1) {\n\t\t\ttype = iter.mem_type;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (type != iter.mem_type)\n\t\t\treturn false;\n\t}\n\n\tif (iter.mtrr_disabled)\n\t\treturn true;\n\n\tif (!iter.partial_map)\n\t\treturn true;\n\n\tif (type == -1)\n\t\treturn true;\n\n\treturn type == mtrr_default_type(mtrr_state);\n}"
  },
  {
    "function_name": "kvm_mtrr_get_guest_memory_type",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mtrr.c",
    "lines": "626-699",
    "snippet": "u8 kvm_mtrr_get_guest_memory_type(struct kvm_vcpu *vcpu, gfn_t gfn)\n{\n\tstruct kvm_mtrr *mtrr_state = &vcpu->arch.mtrr_state;\n\tstruct mtrr_iter iter;\n\tu64 start, end;\n\tint type = -1;\n\tconst int wt_wb_mask = (1 << MTRR_TYPE_WRBACK)\n\t\t\t       | (1 << MTRR_TYPE_WRTHROUGH);\n\n\tstart = gfn_to_gpa(gfn);\n\tend = start + PAGE_SIZE;\n\n\tmtrr_for_each_mem_type(&iter, mtrr_state, start, end) {\n\t\tint curr_type = iter.mem_type;\n\n\t\t/*\n\t\t * Please refer to Intel SDM Volume 3: 11.11.4.1 MTRR\n\t\t * Precedences.\n\t\t */\n\n\t\tif (type == -1) {\n\t\t\ttype = curr_type;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * If two or more variable memory ranges match and the\n\t\t * memory types are identical, then that memory type is\n\t\t * used.\n\t\t */\n\t\tif (type == curr_type)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * If two or more variable memory ranges match and one of\n\t\t * the memory types is UC, the UC memory type used.\n\t\t */\n\t\tif (curr_type == MTRR_TYPE_UNCACHABLE)\n\t\t\treturn MTRR_TYPE_UNCACHABLE;\n\n\t\t/*\n\t\t * If two or more variable memory ranges match and the\n\t\t * memory types are WT and WB, the WT memory type is used.\n\t\t */\n\t\tif (((1 << type) & wt_wb_mask) &&\n\t\t      ((1 << curr_type) & wt_wb_mask)) {\n\t\t\ttype = MTRR_TYPE_WRTHROUGH;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * For overlaps not defined by the above rules, processor\n\t\t * behavior is undefined.\n\t\t */\n\n\t\t/* We use WB for this undefined behavior. :( */\n\t\treturn MTRR_TYPE_WRBACK;\n\t}\n\n\tif (iter.mtrr_disabled)\n\t\treturn mtrr_disabled_type(vcpu);\n\n\t/* not contained in any MTRRs. */\n\tif (type == -1)\n\t\treturn mtrr_default_type(mtrr_state);\n\n\t/*\n\t * We just check one page, partially covered by MTRRs is\n\t * impossible.\n\t */\n\tWARN_ON(iter.partial_map);\n\n\treturn type;\n}",
    "includes": [
      "#include \"mmu.h\"",
      "#include \"cpuid.h\"",
      "#include <asm/mtrr.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "iter.partial_map"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtrr_default_type",
          "args": [
            "mtrr_state"
          ],
          "line": 690
        },
        "resolved": true,
        "details": {
          "function_name": "mtrr_default_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mtrr.c",
          "lines": "118-121",
          "snippet": "static u8 mtrr_default_type(struct kvm_mtrr *mtrr_state)\n{\n\treturn mtrr_state->deftype & IA32_MTRR_DEF_TYPE_TYPE_MASK;\n}",
          "includes": [
            "#include \"mmu.h\"",
            "#include \"cpuid.h\"",
            "#include <asm/mtrr.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define IA32_MTRR_DEF_TYPE_TYPE_MASK\t(0xff)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mmu.h\"\n#include \"cpuid.h\"\n#include <asm/mtrr.h>\n#include <linux/kvm_host.h>\n\n#define IA32_MTRR_DEF_TYPE_TYPE_MASK\t(0xff)\n\nstatic u8 mtrr_default_type(struct kvm_mtrr *mtrr_state)\n{\n\treturn mtrr_state->deftype & IA32_MTRR_DEF_TYPE_TYPE_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mtrr_disabled_type",
          "args": [
            "vcpu"
          ],
          "line": 686
        },
        "resolved": true,
        "details": {
          "function_name": "mtrr_disabled_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mtrr.c",
          "lines": "123-139",
          "snippet": "static u8 mtrr_disabled_type(struct kvm_vcpu *vcpu)\n{\n\t/*\n\t * Intel SDM 11.11.2.2: all MTRRs are disabled when\n\t * IA32_MTRR_DEF_TYPE.E bit is cleared, and the UC\n\t * memory type is applied to all of physical memory.\n\t *\n\t * However, virtual machines can be run with CPUID such that\n\t * there are no MTRRs.  In that case, the firmware will never\n\t * enable MTRRs and it is obviously undesirable to run the\n\t * guest entirely with UC memory and we use WB.\n\t */\n\tif (guest_cpuid_has_mtrr(vcpu))\n\t\treturn MTRR_TYPE_UNCACHABLE;\n\telse\n\t\treturn MTRR_TYPE_WRBACK;\n}",
          "includes": [
            "#include \"mmu.h\"",
            "#include \"cpuid.h\"",
            "#include <asm/mtrr.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mmu.h\"\n#include \"cpuid.h\"\n#include <asm/mtrr.h>\n#include <linux/kvm_host.h>\n\nstatic u8 mtrr_disabled_type(struct kvm_vcpu *vcpu)\n{\n\t/*\n\t * Intel SDM 11.11.2.2: all MTRRs are disabled when\n\t * IA32_MTRR_DEF_TYPE.E bit is cleared, and the UC\n\t * memory type is applied to all of physical memory.\n\t *\n\t * However, virtual machines can be run with CPUID such that\n\t * there are no MTRRs.  In that case, the firmware will never\n\t * enable MTRRs and it is obviously undesirable to run the\n\t * guest entirely with UC memory and we use WB.\n\t */\n\tif (guest_cpuid_has_mtrr(vcpu))\n\t\treturn MTRR_TYPE_UNCACHABLE;\n\telse\n\t\treturn MTRR_TYPE_WRBACK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mtrr_for_each_mem_type",
          "args": [
            "&iter",
            "mtrr_state",
            "start",
            "end"
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfn_to_gpa",
          "args": [
            "gfn"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"mmu.h\"\n#include \"cpuid.h\"\n#include <asm/mtrr.h>\n#include <linux/kvm_host.h>\n\nu8 kvm_mtrr_get_guest_memory_type(struct kvm_vcpu *vcpu, gfn_t gfn)\n{\n\tstruct kvm_mtrr *mtrr_state = &vcpu->arch.mtrr_state;\n\tstruct mtrr_iter iter;\n\tu64 start, end;\n\tint type = -1;\n\tconst int wt_wb_mask = (1 << MTRR_TYPE_WRBACK)\n\t\t\t       | (1 << MTRR_TYPE_WRTHROUGH);\n\n\tstart = gfn_to_gpa(gfn);\n\tend = start + PAGE_SIZE;\n\n\tmtrr_for_each_mem_type(&iter, mtrr_state, start, end) {\n\t\tint curr_type = iter.mem_type;\n\n\t\t/*\n\t\t * Please refer to Intel SDM Volume 3: 11.11.4.1 MTRR\n\t\t * Precedences.\n\t\t */\n\n\t\tif (type == -1) {\n\t\t\ttype = curr_type;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * If two or more variable memory ranges match and the\n\t\t * memory types are identical, then that memory type is\n\t\t * used.\n\t\t */\n\t\tif (type == curr_type)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * If two or more variable memory ranges match and one of\n\t\t * the memory types is UC, the UC memory type used.\n\t\t */\n\t\tif (curr_type == MTRR_TYPE_UNCACHABLE)\n\t\t\treturn MTRR_TYPE_UNCACHABLE;\n\n\t\t/*\n\t\t * If two or more variable memory ranges match and the\n\t\t * memory types are WT and WB, the WT memory type is used.\n\t\t */\n\t\tif (((1 << type) & wt_wb_mask) &&\n\t\t      ((1 << curr_type) & wt_wb_mask)) {\n\t\t\ttype = MTRR_TYPE_WRTHROUGH;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * For overlaps not defined by the above rules, processor\n\t\t * behavior is undefined.\n\t\t */\n\n\t\t/* We use WB for this undefined behavior. :( */\n\t\treturn MTRR_TYPE_WRBACK;\n\t}\n\n\tif (iter.mtrr_disabled)\n\t\treturn mtrr_disabled_type(vcpu);\n\n\t/* not contained in any MTRRs. */\n\tif (type == -1)\n\t\treturn mtrr_default_type(mtrr_state);\n\n\t/*\n\t * We just check one page, partially covered by MTRRs is\n\t * impossible.\n\t */\n\tWARN_ON(iter.partial_map);\n\n\treturn type;\n}"
  },
  {
    "function_name": "mtrr_lookup_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mtrr.c",
    "lines": "614-620",
    "snippet": "static void mtrr_lookup_next(struct mtrr_iter *iter)\n{\n\tif (iter->fixed)\n\t\tmtrr_lookup_fixed_next(iter);\n\telse\n\t\tmtrr_lookup_var_next(iter);\n}",
    "includes": [
      "#include \"mmu.h\"",
      "#include \"cpuid.h\"",
      "#include <asm/mtrr.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mtrr_lookup_var_next",
          "args": [
            "iter"
          ],
          "line": 619
        },
        "resolved": true,
        "details": {
          "function_name": "mtrr_lookup_var_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mtrr.c",
          "lines": "569-572",
          "snippet": "static void mtrr_lookup_var_next(struct mtrr_iter *iter)\n{\n\t__mtrr_lookup_var_next(iter);\n}",
          "includes": [
            "#include \"mmu.h\"",
            "#include \"cpuid.h\"",
            "#include <asm/mtrr.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mmu.h\"\n#include \"cpuid.h\"\n#include <asm/mtrr.h>\n#include <linux/kvm_host.h>\n\nstatic void mtrr_lookup_var_next(struct mtrr_iter *iter)\n{\n\t__mtrr_lookup_var_next(iter);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mtrr_lookup_fixed_next",
          "args": [
            "iter"
          ],
          "line": 617
        },
        "resolved": true,
        "details": {
          "function_name": "mtrr_lookup_fixed_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mtrr.c",
          "lines": "549-567",
          "snippet": "static void mtrr_lookup_fixed_next(struct mtrr_iter *iter)\n{\n\t/* terminate the lookup. */\n\tif (fixed_mtrr_range_end_addr(iter->seg, iter->index) >= iter->end) {\n\t\titer->fixed = false;\n\t\titer->range = NULL;\n\t\treturn;\n\t}\n\n\titer->index++;\n\n\t/* have looked up for all fixed MTRRs. */\n\tif (iter->index >= ARRAY_SIZE(iter->mtrr_state->fixed_ranges))\n\t\treturn mtrr_lookup_var_start(iter);\n\n\t/* switch to next segment. */\n\tif (iter->index > fixed_mtrr_seg_end_range_index(iter->seg))\n\t\titer->seg++;\n}",
          "includes": [
            "#include \"mmu.h\"",
            "#include \"cpuid.h\"",
            "#include <asm/mtrr.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mmu.h\"\n#include \"cpuid.h\"\n#include <asm/mtrr.h>\n#include <linux/kvm_host.h>\n\nstatic void mtrr_lookup_fixed_next(struct mtrr_iter *iter)\n{\n\t/* terminate the lookup. */\n\tif (fixed_mtrr_range_end_addr(iter->seg, iter->index) >= iter->end) {\n\t\titer->fixed = false;\n\t\titer->range = NULL;\n\t\treturn;\n\t}\n\n\titer->index++;\n\n\t/* have looked up for all fixed MTRRs. */\n\tif (iter->index >= ARRAY_SIZE(iter->mtrr_state->fixed_ranges))\n\t\treturn mtrr_lookup_var_start(iter);\n\n\t/* switch to next segment. */\n\tif (iter->index > fixed_mtrr_seg_end_range_index(iter->seg))\n\t\titer->seg++;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"mmu.h\"\n#include \"cpuid.h\"\n#include <asm/mtrr.h>\n#include <linux/kvm_host.h>\n\nstatic void mtrr_lookup_next(struct mtrr_iter *iter)\n{\n\tif (iter->fixed)\n\t\tmtrr_lookup_fixed_next(iter);\n\telse\n\t\tmtrr_lookup_var_next(iter);\n}"
  },
  {
    "function_name": "mtrr_lookup_okay",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mtrr.c",
    "lines": "599-612",
    "snippet": "static bool mtrr_lookup_okay(struct mtrr_iter *iter)\n{\n\tif (iter->fixed) {\n\t\titer->mem_type = iter->mtrr_state->fixed_ranges[iter->index];\n\t\treturn true;\n\t}\n\n\tif (iter->range) {\n\t\titer->mem_type = iter->range->base & 0xff;\n\t\treturn true;\n\t}\n\n\treturn false;\n}",
    "includes": [
      "#include \"mmu.h\"",
      "#include \"cpuid.h\"",
      "#include <asm/mtrr.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"mmu.h\"\n#include \"cpuid.h\"\n#include <asm/mtrr.h>\n#include <linux/kvm_host.h>\n\nstatic bool mtrr_lookup_okay(struct mtrr_iter *iter)\n{\n\tif (iter->fixed) {\n\t\titer->mem_type = iter->mtrr_state->fixed_ranges[iter->index];\n\t\treturn true;\n\t}\n\n\tif (iter->range) {\n\t\titer->mem_type = iter->range->base & 0xff;\n\t\treturn true;\n\t}\n\n\treturn false;\n}"
  },
  {
    "function_name": "mtrr_lookup_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mtrr.c",
    "lines": "585-597",
    "snippet": "static void mtrr_lookup_init(struct mtrr_iter *iter,\n\t\t\t     struct kvm_mtrr *mtrr_state, u64 start, u64 end)\n{\n\titer->mtrr_state = mtrr_state;\n\titer->start = start;\n\titer->end = end;\n\titer->mtrr_disabled = false;\n\titer->partial_map = false;\n\titer->fixed = false;\n\titer->range = NULL;\n\n\tmtrr_lookup_start(iter);\n}",
    "includes": [
      "#include \"mmu.h\"",
      "#include \"cpuid.h\"",
      "#include <asm/mtrr.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mtrr_lookup_start",
          "args": [
            "iter"
          ],
          "line": 596
        },
        "resolved": true,
        "details": {
          "function_name": "mtrr_lookup_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mtrr.c",
          "lines": "574-583",
          "snippet": "static void mtrr_lookup_start(struct mtrr_iter *iter)\n{\n\tif (!mtrr_is_enabled(iter->mtrr_state)) {\n\t\titer->mtrr_disabled = true;\n\t\treturn;\n\t}\n\n\tif (!mtrr_lookup_fixed_start(iter))\n\t\tmtrr_lookup_var_start(iter);\n}",
          "includes": [
            "#include \"mmu.h\"",
            "#include \"cpuid.h\"",
            "#include <asm/mtrr.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mmu.h\"\n#include \"cpuid.h\"\n#include <asm/mtrr.h>\n#include <linux/kvm_host.h>\n\nstatic void mtrr_lookup_start(struct mtrr_iter *iter)\n{\n\tif (!mtrr_is_enabled(iter->mtrr_state)) {\n\t\titer->mtrr_disabled = true;\n\t\treturn;\n\t}\n\n\tif (!mtrr_lookup_fixed_start(iter))\n\t\tmtrr_lookup_var_start(iter);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"mmu.h\"\n#include \"cpuid.h\"\n#include <asm/mtrr.h>\n#include <linux/kvm_host.h>\n\nstatic void mtrr_lookup_init(struct mtrr_iter *iter,\n\t\t\t     struct kvm_mtrr *mtrr_state, u64 start, u64 end)\n{\n\titer->mtrr_state = mtrr_state;\n\titer->start = start;\n\titer->end = end;\n\titer->mtrr_disabled = false;\n\titer->partial_map = false;\n\titer->fixed = false;\n\titer->range = NULL;\n\n\tmtrr_lookup_start(iter);\n}"
  },
  {
    "function_name": "mtrr_lookup_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mtrr.c",
    "lines": "574-583",
    "snippet": "static void mtrr_lookup_start(struct mtrr_iter *iter)\n{\n\tif (!mtrr_is_enabled(iter->mtrr_state)) {\n\t\titer->mtrr_disabled = true;\n\t\treturn;\n\t}\n\n\tif (!mtrr_lookup_fixed_start(iter))\n\t\tmtrr_lookup_var_start(iter);\n}",
    "includes": [
      "#include \"mmu.h\"",
      "#include \"cpuid.h\"",
      "#include <asm/mtrr.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mtrr_lookup_var_start",
          "args": [
            "iter"
          ],
          "line": 582
        },
        "resolved": true,
        "details": {
          "function_name": "mtrr_lookup_var_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mtrr.c",
          "lines": "538-547",
          "snippet": "static void mtrr_lookup_var_start(struct mtrr_iter *iter)\n{\n\tstruct kvm_mtrr *mtrr_state = iter->mtrr_state;\n\n\titer->fixed = false;\n\titer->start_max = iter->start;\n\titer->range = list_prepare_entry(iter->range, &mtrr_state->head, node);\n\n\t__mtrr_lookup_var_next(iter);\n}",
          "includes": [
            "#include \"mmu.h\"",
            "#include \"cpuid.h\"",
            "#include <asm/mtrr.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mmu.h\"\n#include \"cpuid.h\"\n#include <asm/mtrr.h>\n#include <linux/kvm_host.h>\n\nstatic void mtrr_lookup_var_start(struct mtrr_iter *iter)\n{\n\tstruct kvm_mtrr *mtrr_state = iter->mtrr_state;\n\n\titer->fixed = false;\n\titer->start_max = iter->start;\n\titer->range = list_prepare_entry(iter->range, &mtrr_state->head, node);\n\n\t__mtrr_lookup_var_next(iter);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mtrr_lookup_fixed_start",
          "args": [
            "iter"
          ],
          "line": 581
        },
        "resolved": true,
        "details": {
          "function_name": "mtrr_lookup_fixed_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mtrr.c",
          "lines": "484-500",
          "snippet": "static bool mtrr_lookup_fixed_start(struct mtrr_iter *iter)\n{\n\tint seg, index;\n\n\tif (!fixed_mtrr_is_enabled(iter->mtrr_state))\n\t\treturn false;\n\n\tseg = fixed_mtrr_addr_to_seg(iter->start);\n\tif (seg < 0)\n\t\treturn false;\n\n\titer->fixed = true;\n\tindex = fixed_mtrr_addr_seg_to_range_index(iter->start, seg);\n\titer->index = index;\n\titer->seg = seg;\n\treturn true;\n}",
          "includes": [
            "#include \"mmu.h\"",
            "#include \"cpuid.h\"",
            "#include <asm/mtrr.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mmu.h\"\n#include \"cpuid.h\"\n#include <asm/mtrr.h>\n#include <linux/kvm_host.h>\n\nstatic bool mtrr_lookup_fixed_start(struct mtrr_iter *iter)\n{\n\tint seg, index;\n\n\tif (!fixed_mtrr_is_enabled(iter->mtrr_state))\n\t\treturn false;\n\n\tseg = fixed_mtrr_addr_to_seg(iter->start);\n\tif (seg < 0)\n\t\treturn false;\n\n\titer->fixed = true;\n\tindex = fixed_mtrr_addr_seg_to_range_index(iter->start, seg);\n\titer->index = index;\n\titer->seg = seg;\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mtrr_is_enabled",
          "args": [
            "iter->mtrr_state"
          ],
          "line": 576
        },
        "resolved": true,
        "details": {
          "function_name": "fixed_mtrr_is_enabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mtrr.c",
          "lines": "113-116",
          "snippet": "static bool fixed_mtrr_is_enabled(struct kvm_mtrr *mtrr_state)\n{\n\treturn !!(mtrr_state->deftype & IA32_MTRR_DEF_TYPE_FE);\n}",
          "includes": [
            "#include \"mmu.h\"",
            "#include \"cpuid.h\"",
            "#include <asm/mtrr.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define IA32_MTRR_DEF_TYPE_FE\t\t(1ULL << 10)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mmu.h\"\n#include \"cpuid.h\"\n#include <asm/mtrr.h>\n#include <linux/kvm_host.h>\n\n#define IA32_MTRR_DEF_TYPE_FE\t\t(1ULL << 10)\n\nstatic bool fixed_mtrr_is_enabled(struct kvm_mtrr *mtrr_state)\n{\n\treturn !!(mtrr_state->deftype & IA32_MTRR_DEF_TYPE_FE);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"mmu.h\"\n#include \"cpuid.h\"\n#include <asm/mtrr.h>\n#include <linux/kvm_host.h>\n\nstatic void mtrr_lookup_start(struct mtrr_iter *iter)\n{\n\tif (!mtrr_is_enabled(iter->mtrr_state)) {\n\t\titer->mtrr_disabled = true;\n\t\treturn;\n\t}\n\n\tif (!mtrr_lookup_fixed_start(iter))\n\t\tmtrr_lookup_var_start(iter);\n}"
  },
  {
    "function_name": "mtrr_lookup_var_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mtrr.c",
    "lines": "569-572",
    "snippet": "static void mtrr_lookup_var_next(struct mtrr_iter *iter)\n{\n\t__mtrr_lookup_var_next(iter);\n}",
    "includes": [
      "#include \"mmu.h\"",
      "#include \"cpuid.h\"",
      "#include <asm/mtrr.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__mtrr_lookup_var_next",
          "args": [
            "iter"
          ],
          "line": 571
        },
        "resolved": true,
        "details": {
          "function_name": "__mtrr_lookup_var_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mtrr.c",
          "lines": "526-536",
          "snippet": "static void __mtrr_lookup_var_next(struct mtrr_iter *iter)\n{\n\tstruct kvm_mtrr *mtrr_state = iter->mtrr_state;\n\n\tlist_for_each_entry_continue(iter->range, &mtrr_state->head, node)\n\t\tif (match_var_range(iter, iter->range))\n\t\t\treturn;\n\n\titer->range = NULL;\n\titer->partial_map |= iter->start_max < iter->end;\n}",
          "includes": [
            "#include \"mmu.h\"",
            "#include \"cpuid.h\"",
            "#include <asm/mtrr.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mmu.h\"\n#include \"cpuid.h\"\n#include <asm/mtrr.h>\n#include <linux/kvm_host.h>\n\nstatic void __mtrr_lookup_var_next(struct mtrr_iter *iter)\n{\n\tstruct kvm_mtrr *mtrr_state = iter->mtrr_state;\n\n\tlist_for_each_entry_continue(iter->range, &mtrr_state->head, node)\n\t\tif (match_var_range(iter, iter->range))\n\t\t\treturn;\n\n\titer->range = NULL;\n\titer->partial_map |= iter->start_max < iter->end;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"mmu.h\"\n#include \"cpuid.h\"\n#include <asm/mtrr.h>\n#include <linux/kvm_host.h>\n\nstatic void mtrr_lookup_var_next(struct mtrr_iter *iter)\n{\n\t__mtrr_lookup_var_next(iter);\n}"
  },
  {
    "function_name": "mtrr_lookup_fixed_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mtrr.c",
    "lines": "549-567",
    "snippet": "static void mtrr_lookup_fixed_next(struct mtrr_iter *iter)\n{\n\t/* terminate the lookup. */\n\tif (fixed_mtrr_range_end_addr(iter->seg, iter->index) >= iter->end) {\n\t\titer->fixed = false;\n\t\titer->range = NULL;\n\t\treturn;\n\t}\n\n\titer->index++;\n\n\t/* have looked up for all fixed MTRRs. */\n\tif (iter->index >= ARRAY_SIZE(iter->mtrr_state->fixed_ranges))\n\t\treturn mtrr_lookup_var_start(iter);\n\n\t/* switch to next segment. */\n\tif (iter->index > fixed_mtrr_seg_end_range_index(iter->seg))\n\t\titer->seg++;\n}",
    "includes": [
      "#include \"mmu.h\"",
      "#include \"cpuid.h\"",
      "#include <asm/mtrr.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fixed_mtrr_seg_end_range_index",
          "args": [
            "iter->seg"
          ],
          "line": 565
        },
        "resolved": true,
        "details": {
          "function_name": "fixed_mtrr_seg_end_range_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mtrr.c",
          "lines": "241-248",
          "snippet": "static int fixed_mtrr_seg_end_range_index(int seg)\n{\n\tstruct fixed_mtrr_segment *mtrr_seg = &fixed_seg_table[seg];\n\tint n;\n\n\tn = (mtrr_seg->end - mtrr_seg->start) >> mtrr_seg->range_shift;\n\treturn mtrr_seg->range_start + n - 1;\n}",
          "includes": [
            "#include \"mmu.h\"",
            "#include \"cpuid.h\"",
            "#include <asm/mtrr.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct fixed_mtrr_segment fixed_seg_table[] = {\n\t/* MSR_MTRRfix64K_00000, 1 unit. 64K fixed mtrr. */\n\t{\n\t\t.start = 0x0,\n\t\t.end = 0x80000,\n\t\t.range_shift = 16, /* 64K */\n\t\t.range_start = 0,\n\t},\n\n\t/*\n\t * MSR_MTRRfix16K_80000 ... MSR_MTRRfix16K_A0000, 2 units,\n\t * 16K fixed mtrr.\n\t */\n\t{\n\t\t.start = 0x80000,\n\t\t.end = 0xc0000,\n\t\t.range_shift = 14, /* 16K */\n\t\t.range_start = 8,\n\t},\n\n\t/*\n\t * MSR_MTRRfix4K_C0000 ... MSR_MTRRfix4K_F8000, 8 units,\n\t * 4K fixed mtrr.\n\t */\n\t{\n\t\t.start = 0xc0000,\n\t\t.end = 0x100000,\n\t\t.range_shift = 12, /* 12K */\n\t\t.range_start = 24,\n\t}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"mmu.h\"\n#include \"cpuid.h\"\n#include <asm/mtrr.h>\n#include <linux/kvm_host.h>\n\nstatic struct fixed_mtrr_segment fixed_seg_table[] = {\n\t/* MSR_MTRRfix64K_00000, 1 unit. 64K fixed mtrr. */\n\t{\n\t\t.start = 0x0,\n\t\t.end = 0x80000,\n\t\t.range_shift = 16, /* 64K */\n\t\t.range_start = 0,\n\t},\n\n\t/*\n\t * MSR_MTRRfix16K_80000 ... MSR_MTRRfix16K_A0000, 2 units,\n\t * 16K fixed mtrr.\n\t */\n\t{\n\t\t.start = 0x80000,\n\t\t.end = 0xc0000,\n\t\t.range_shift = 14, /* 16K */\n\t\t.range_start = 8,\n\t},\n\n\t/*\n\t * MSR_MTRRfix4K_C0000 ... MSR_MTRRfix4K_F8000, 8 units,\n\t * 4K fixed mtrr.\n\t */\n\t{\n\t\t.start = 0xc0000,\n\t\t.end = 0x100000,\n\t\t.range_shift = 12, /* 12K */\n\t\t.range_start = 24,\n\t}\n};\n\nstatic int fixed_mtrr_seg_end_range_index(int seg)\n{\n\tstruct fixed_mtrr_segment *mtrr_seg = &fixed_seg_table[seg];\n\tint n;\n\n\tn = (mtrr_seg->end - mtrr_seg->start) >> mtrr_seg->range_shift;\n\treturn mtrr_seg->range_start + n - 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mtrr_lookup_var_start",
          "args": [
            "iter"
          ],
          "line": 562
        },
        "resolved": true,
        "details": {
          "function_name": "mtrr_lookup_var_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mtrr.c",
          "lines": "538-547",
          "snippet": "static void mtrr_lookup_var_start(struct mtrr_iter *iter)\n{\n\tstruct kvm_mtrr *mtrr_state = iter->mtrr_state;\n\n\titer->fixed = false;\n\titer->start_max = iter->start;\n\titer->range = list_prepare_entry(iter->range, &mtrr_state->head, node);\n\n\t__mtrr_lookup_var_next(iter);\n}",
          "includes": [
            "#include \"mmu.h\"",
            "#include \"cpuid.h\"",
            "#include <asm/mtrr.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mmu.h\"\n#include \"cpuid.h\"\n#include <asm/mtrr.h>\n#include <linux/kvm_host.h>\n\nstatic void mtrr_lookup_var_start(struct mtrr_iter *iter)\n{\n\tstruct kvm_mtrr *mtrr_state = iter->mtrr_state;\n\n\titer->fixed = false;\n\titer->start_max = iter->start;\n\titer->range = list_prepare_entry(iter->range, &mtrr_state->head, node);\n\n\t__mtrr_lookup_var_next(iter);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "iter->mtrr_state->fixed_ranges"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fixed_mtrr_range_end_addr",
          "args": [
            "iter->seg",
            "iter->index"
          ],
          "line": 552
        },
        "resolved": true,
        "details": {
          "function_name": "fixed_mtrr_range_end_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mtrr.c",
          "lines": "296-302",
          "snippet": "static u64 fixed_mtrr_range_end_addr(int seg, int index)\n{\n\tstruct fixed_mtrr_segment *mtrr_seg = &fixed_seg_table[seg];\n\tint pos = index - mtrr_seg->range_start;\n\n\treturn mtrr_seg->start + ((pos + 1) << mtrr_seg->range_shift);\n}",
          "includes": [
            "#include \"mmu.h\"",
            "#include \"cpuid.h\"",
            "#include <asm/mtrr.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct fixed_mtrr_segment fixed_seg_table[] = {\n\t/* MSR_MTRRfix64K_00000, 1 unit. 64K fixed mtrr. */\n\t{\n\t\t.start = 0x0,\n\t\t.end = 0x80000,\n\t\t.range_shift = 16, /* 64K */\n\t\t.range_start = 0,\n\t},\n\n\t/*\n\t * MSR_MTRRfix16K_80000 ... MSR_MTRRfix16K_A0000, 2 units,\n\t * 16K fixed mtrr.\n\t */\n\t{\n\t\t.start = 0x80000,\n\t\t.end = 0xc0000,\n\t\t.range_shift = 14, /* 16K */\n\t\t.range_start = 8,\n\t},\n\n\t/*\n\t * MSR_MTRRfix4K_C0000 ... MSR_MTRRfix4K_F8000, 8 units,\n\t * 4K fixed mtrr.\n\t */\n\t{\n\t\t.start = 0xc0000,\n\t\t.end = 0x100000,\n\t\t.range_shift = 12, /* 12K */\n\t\t.range_start = 24,\n\t}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"mmu.h\"\n#include \"cpuid.h\"\n#include <asm/mtrr.h>\n#include <linux/kvm_host.h>\n\nstatic struct fixed_mtrr_segment fixed_seg_table[] = {\n\t/* MSR_MTRRfix64K_00000, 1 unit. 64K fixed mtrr. */\n\t{\n\t\t.start = 0x0,\n\t\t.end = 0x80000,\n\t\t.range_shift = 16, /* 64K */\n\t\t.range_start = 0,\n\t},\n\n\t/*\n\t * MSR_MTRRfix16K_80000 ... MSR_MTRRfix16K_A0000, 2 units,\n\t * 16K fixed mtrr.\n\t */\n\t{\n\t\t.start = 0x80000,\n\t\t.end = 0xc0000,\n\t\t.range_shift = 14, /* 16K */\n\t\t.range_start = 8,\n\t},\n\n\t/*\n\t * MSR_MTRRfix4K_C0000 ... MSR_MTRRfix4K_F8000, 8 units,\n\t * 4K fixed mtrr.\n\t */\n\t{\n\t\t.start = 0xc0000,\n\t\t.end = 0x100000,\n\t\t.range_shift = 12, /* 12K */\n\t\t.range_start = 24,\n\t}\n};\n\nstatic u64 fixed_mtrr_range_end_addr(int seg, int index)\n{\n\tstruct fixed_mtrr_segment *mtrr_seg = &fixed_seg_table[seg];\n\tint pos = index - mtrr_seg->range_start;\n\n\treturn mtrr_seg->start + ((pos + 1) << mtrr_seg->range_shift);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"mmu.h\"\n#include \"cpuid.h\"\n#include <asm/mtrr.h>\n#include <linux/kvm_host.h>\n\nstatic void mtrr_lookup_fixed_next(struct mtrr_iter *iter)\n{\n\t/* terminate the lookup. */\n\tif (fixed_mtrr_range_end_addr(iter->seg, iter->index) >= iter->end) {\n\t\titer->fixed = false;\n\t\titer->range = NULL;\n\t\treturn;\n\t}\n\n\titer->index++;\n\n\t/* have looked up for all fixed MTRRs. */\n\tif (iter->index >= ARRAY_SIZE(iter->mtrr_state->fixed_ranges))\n\t\treturn mtrr_lookup_var_start(iter);\n\n\t/* switch to next segment. */\n\tif (iter->index > fixed_mtrr_seg_end_range_index(iter->seg))\n\t\titer->seg++;\n}"
  },
  {
    "function_name": "mtrr_lookup_var_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mtrr.c",
    "lines": "538-547",
    "snippet": "static void mtrr_lookup_var_start(struct mtrr_iter *iter)\n{\n\tstruct kvm_mtrr *mtrr_state = iter->mtrr_state;\n\n\titer->fixed = false;\n\titer->start_max = iter->start;\n\titer->range = list_prepare_entry(iter->range, &mtrr_state->head, node);\n\n\t__mtrr_lookup_var_next(iter);\n}",
    "includes": [
      "#include \"mmu.h\"",
      "#include \"cpuid.h\"",
      "#include <asm/mtrr.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__mtrr_lookup_var_next",
          "args": [
            "iter"
          ],
          "line": 546
        },
        "resolved": true,
        "details": {
          "function_name": "__mtrr_lookup_var_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mtrr.c",
          "lines": "526-536",
          "snippet": "static void __mtrr_lookup_var_next(struct mtrr_iter *iter)\n{\n\tstruct kvm_mtrr *mtrr_state = iter->mtrr_state;\n\n\tlist_for_each_entry_continue(iter->range, &mtrr_state->head, node)\n\t\tif (match_var_range(iter, iter->range))\n\t\t\treturn;\n\n\titer->range = NULL;\n\titer->partial_map |= iter->start_max < iter->end;\n}",
          "includes": [
            "#include \"mmu.h\"",
            "#include \"cpuid.h\"",
            "#include <asm/mtrr.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mmu.h\"\n#include \"cpuid.h\"\n#include <asm/mtrr.h>\n#include <linux/kvm_host.h>\n\nstatic void __mtrr_lookup_var_next(struct mtrr_iter *iter)\n{\n\tstruct kvm_mtrr *mtrr_state = iter->mtrr_state;\n\n\tlist_for_each_entry_continue(iter->range, &mtrr_state->head, node)\n\t\tif (match_var_range(iter, iter->range))\n\t\t\treturn;\n\n\titer->range = NULL;\n\titer->partial_map |= iter->start_max < iter->end;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_prepare_entry",
          "args": [
            "iter->range",
            "&mtrr_state->head",
            "node"
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"mmu.h\"\n#include \"cpuid.h\"\n#include <asm/mtrr.h>\n#include <linux/kvm_host.h>\n\nstatic void mtrr_lookup_var_start(struct mtrr_iter *iter)\n{\n\tstruct kvm_mtrr *mtrr_state = iter->mtrr_state;\n\n\titer->fixed = false;\n\titer->start_max = iter->start;\n\titer->range = list_prepare_entry(iter->range, &mtrr_state->head, node);\n\n\t__mtrr_lookup_var_next(iter);\n}"
  },
  {
    "function_name": "__mtrr_lookup_var_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mtrr.c",
    "lines": "526-536",
    "snippet": "static void __mtrr_lookup_var_next(struct mtrr_iter *iter)\n{\n\tstruct kvm_mtrr *mtrr_state = iter->mtrr_state;\n\n\tlist_for_each_entry_continue(iter->range, &mtrr_state->head, node)\n\t\tif (match_var_range(iter, iter->range))\n\t\t\treturn;\n\n\titer->range = NULL;\n\titer->partial_map |= iter->start_max < iter->end;\n}",
    "includes": [
      "#include \"mmu.h\"",
      "#include \"cpuid.h\"",
      "#include <asm/mtrr.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "match_var_range",
          "args": [
            "iter",
            "iter->range"
          ],
          "line": 531
        },
        "resolved": true,
        "details": {
          "function_name": "match_var_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mtrr.c",
          "lines": "502-524",
          "snippet": "static bool match_var_range(struct mtrr_iter *iter,\n\t\t\t    struct kvm_mtrr_range *range)\n{\n\tu64 start, end;\n\n\tvar_mtrr_range(range, &start, &end);\n\tif (!(start >= iter->end || end <= iter->start)) {\n\t\titer->range = range;\n\n\t\t/*\n\t\t * the function is called when we do kvm_mtrr.head walking.\n\t\t * Range has the minimum base address which interleaves\n\t\t * [looker->start_max, looker->end).\n\t\t */\n\t\titer->partial_map |= iter->start_max < start;\n\n\t\t/* update the max address has been covered. */\n\t\titer->start_max = max(iter->start_max, end);\n\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"mmu.h\"",
            "#include \"cpuid.h\"",
            "#include <asm/mtrr.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mmu.h\"\n#include \"cpuid.h\"\n#include <asm/mtrr.h>\n#include <linux/kvm_host.h>\n\nstatic bool match_var_range(struct mtrr_iter *iter,\n\t\t\t    struct kvm_mtrr_range *range)\n{\n\tu64 start, end;\n\n\tvar_mtrr_range(range, &start, &end);\n\tif (!(start >= iter->end || end <= iter->start)) {\n\t\titer->range = range;\n\n\t\t/*\n\t\t * the function is called when we do kvm_mtrr.head walking.\n\t\t * Range has the minimum base address which interleaves\n\t\t * [looker->start_max, looker->end).\n\t\t */\n\t\titer->partial_map |= iter->start_max < start;\n\n\t\t/* update the max address has been covered. */\n\t\titer->start_max = max(iter->start_max, end);\n\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_continue",
          "args": [
            "iter->range",
            "&mtrr_state->head",
            "node"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"mmu.h\"\n#include \"cpuid.h\"\n#include <asm/mtrr.h>\n#include <linux/kvm_host.h>\n\nstatic void __mtrr_lookup_var_next(struct mtrr_iter *iter)\n{\n\tstruct kvm_mtrr *mtrr_state = iter->mtrr_state;\n\n\tlist_for_each_entry_continue(iter->range, &mtrr_state->head, node)\n\t\tif (match_var_range(iter, iter->range))\n\t\t\treturn;\n\n\titer->range = NULL;\n\titer->partial_map |= iter->start_max < iter->end;\n}"
  },
  {
    "function_name": "match_var_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mtrr.c",
    "lines": "502-524",
    "snippet": "static bool match_var_range(struct mtrr_iter *iter,\n\t\t\t    struct kvm_mtrr_range *range)\n{\n\tu64 start, end;\n\n\tvar_mtrr_range(range, &start, &end);\n\tif (!(start >= iter->end || end <= iter->start)) {\n\t\titer->range = range;\n\n\t\t/*\n\t\t * the function is called when we do kvm_mtrr.head walking.\n\t\t * Range has the minimum base address which interleaves\n\t\t * [looker->start_max, looker->end).\n\t\t */\n\t\titer->partial_map |= iter->start_max < start;\n\n\t\t/* update the max address has been covered. */\n\t\titer->start_max = max(iter->start_max, end);\n\t\treturn true;\n\t}\n\n\treturn false;\n}",
    "includes": [
      "#include \"mmu.h\"",
      "#include \"cpuid.h\"",
      "#include <asm/mtrr.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "max",
          "args": [
            "iter->start_max",
            "end"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "var_mtrr_range",
          "args": [
            "range",
            "&start",
            "&end"
          ],
          "line": 507
        },
        "resolved": true,
        "details": {
          "function_name": "var_mtrr_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mtrr.c",
          "lines": "304-316",
          "snippet": "static void var_mtrr_range(struct kvm_mtrr_range *range, u64 *start, u64 *end)\n{\n\tu64 mask;\n\n\t*start = range->base & PAGE_MASK;\n\n\tmask = range->mask & PAGE_MASK;\n\n\t/* This cannot overflow because writing to the reserved bits of\n\t * variable MTRRs causes a #GP.\n\t */\n\t*end = (*start | ~mask) + 1;\n}",
          "includes": [
            "#include \"mmu.h\"",
            "#include \"cpuid.h\"",
            "#include <asm/mtrr.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mmu.h\"\n#include \"cpuid.h\"\n#include <asm/mtrr.h>\n#include <linux/kvm_host.h>\n\nstatic void var_mtrr_range(struct kvm_mtrr_range *range, u64 *start, u64 *end)\n{\n\tu64 mask;\n\n\t*start = range->base & PAGE_MASK;\n\n\tmask = range->mask & PAGE_MASK;\n\n\t/* This cannot overflow because writing to the reserved bits of\n\t * variable MTRRs causes a #GP.\n\t */\n\t*end = (*start | ~mask) + 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"mmu.h\"\n#include \"cpuid.h\"\n#include <asm/mtrr.h>\n#include <linux/kvm_host.h>\n\nstatic bool match_var_range(struct mtrr_iter *iter,\n\t\t\t    struct kvm_mtrr_range *range)\n{\n\tu64 start, end;\n\n\tvar_mtrr_range(range, &start, &end);\n\tif (!(start >= iter->end || end <= iter->start)) {\n\t\titer->range = range;\n\n\t\t/*\n\t\t * the function is called when we do kvm_mtrr.head walking.\n\t\t * Range has the minimum base address which interleaves\n\t\t * [looker->start_max, looker->end).\n\t\t */\n\t\titer->partial_map |= iter->start_max < start;\n\n\t\t/* update the max address has been covered. */\n\t\titer->start_max = max(iter->start_max, end);\n\t\treturn true;\n\t}\n\n\treturn false;\n}"
  },
  {
    "function_name": "mtrr_lookup_fixed_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mtrr.c",
    "lines": "484-500",
    "snippet": "static bool mtrr_lookup_fixed_start(struct mtrr_iter *iter)\n{\n\tint seg, index;\n\n\tif (!fixed_mtrr_is_enabled(iter->mtrr_state))\n\t\treturn false;\n\n\tseg = fixed_mtrr_addr_to_seg(iter->start);\n\tif (seg < 0)\n\t\treturn false;\n\n\titer->fixed = true;\n\tindex = fixed_mtrr_addr_seg_to_range_index(iter->start, seg);\n\titer->index = index;\n\titer->seg = seg;\n\treturn true;\n}",
    "includes": [
      "#include \"mmu.h\"",
      "#include \"cpuid.h\"",
      "#include <asm/mtrr.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fixed_mtrr_addr_seg_to_range_index",
          "args": [
            "iter->start",
            "seg"
          ],
          "line": 496
        },
        "resolved": true,
        "details": {
          "function_name": "fixed_mtrr_addr_seg_to_range_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mtrr.c",
          "lines": "285-294",
          "snippet": "static int fixed_mtrr_addr_seg_to_range_index(u64 addr, int seg)\n{\n\tstruct fixed_mtrr_segment *mtrr_seg;\n\tint index;\n\n\tmtrr_seg = &fixed_seg_table[seg];\n\tindex = mtrr_seg->range_start;\n\tindex += (addr - mtrr_seg->start) >> mtrr_seg->range_shift;\n\treturn index;\n}",
          "includes": [
            "#include \"mmu.h\"",
            "#include \"cpuid.h\"",
            "#include <asm/mtrr.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct fixed_mtrr_segment fixed_seg_table[] = {\n\t/* MSR_MTRRfix64K_00000, 1 unit. 64K fixed mtrr. */\n\t{\n\t\t.start = 0x0,\n\t\t.end = 0x80000,\n\t\t.range_shift = 16, /* 64K */\n\t\t.range_start = 0,\n\t},\n\n\t/*\n\t * MSR_MTRRfix16K_80000 ... MSR_MTRRfix16K_A0000, 2 units,\n\t * 16K fixed mtrr.\n\t */\n\t{\n\t\t.start = 0x80000,\n\t\t.end = 0xc0000,\n\t\t.range_shift = 14, /* 16K */\n\t\t.range_start = 8,\n\t},\n\n\t/*\n\t * MSR_MTRRfix4K_C0000 ... MSR_MTRRfix4K_F8000, 8 units,\n\t * 4K fixed mtrr.\n\t */\n\t{\n\t\t.start = 0xc0000,\n\t\t.end = 0x100000,\n\t\t.range_shift = 12, /* 12K */\n\t\t.range_start = 24,\n\t}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"mmu.h\"\n#include \"cpuid.h\"\n#include <asm/mtrr.h>\n#include <linux/kvm_host.h>\n\nstatic struct fixed_mtrr_segment fixed_seg_table[] = {\n\t/* MSR_MTRRfix64K_00000, 1 unit. 64K fixed mtrr. */\n\t{\n\t\t.start = 0x0,\n\t\t.end = 0x80000,\n\t\t.range_shift = 16, /* 64K */\n\t\t.range_start = 0,\n\t},\n\n\t/*\n\t * MSR_MTRRfix16K_80000 ... MSR_MTRRfix16K_A0000, 2 units,\n\t * 16K fixed mtrr.\n\t */\n\t{\n\t\t.start = 0x80000,\n\t\t.end = 0xc0000,\n\t\t.range_shift = 14, /* 16K */\n\t\t.range_start = 8,\n\t},\n\n\t/*\n\t * MSR_MTRRfix4K_C0000 ... MSR_MTRRfix4K_F8000, 8 units,\n\t * 4K fixed mtrr.\n\t */\n\t{\n\t\t.start = 0xc0000,\n\t\t.end = 0x100000,\n\t\t.range_shift = 12, /* 12K */\n\t\t.range_start = 24,\n\t}\n};\n\nstatic int fixed_mtrr_addr_seg_to_range_index(u64 addr, int seg)\n{\n\tstruct fixed_mtrr_segment *mtrr_seg;\n\tint index;\n\n\tmtrr_seg = &fixed_seg_table[seg];\n\tindex = mtrr_seg->range_start;\n\tindex += (addr - mtrr_seg->start) >> mtrr_seg->range_shift;\n\treturn index;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fixed_mtrr_addr_to_seg",
          "args": [
            "iter->start"
          ],
          "line": 491
        },
        "resolved": true,
        "details": {
          "function_name": "fixed_mtrr_addr_to_seg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mtrr.c",
          "lines": "271-283",
          "snippet": "static int fixed_mtrr_addr_to_seg(u64 addr)\n{\n\tstruct fixed_mtrr_segment *mtrr_seg;\n\tint seg, seg_num = ARRAY_SIZE(fixed_seg_table);\n\n\tfor (seg = 0; seg < seg_num; seg++) {\n\t\tmtrr_seg = &fixed_seg_table[seg];\n\t\tif (mtrr_seg->start <= addr && addr < mtrr_seg->end)\n\t\t\treturn seg;\n\t}\n\n\treturn -1;\n}",
          "includes": [
            "#include \"mmu.h\"",
            "#include \"cpuid.h\"",
            "#include <asm/mtrr.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct fixed_mtrr_segment fixed_seg_table[] = {\n\t/* MSR_MTRRfix64K_00000, 1 unit. 64K fixed mtrr. */\n\t{\n\t\t.start = 0x0,\n\t\t.end = 0x80000,\n\t\t.range_shift = 16, /* 64K */\n\t\t.range_start = 0,\n\t},\n\n\t/*\n\t * MSR_MTRRfix16K_80000 ... MSR_MTRRfix16K_A0000, 2 units,\n\t * 16K fixed mtrr.\n\t */\n\t{\n\t\t.start = 0x80000,\n\t\t.end = 0xc0000,\n\t\t.range_shift = 14, /* 16K */\n\t\t.range_start = 8,\n\t},\n\n\t/*\n\t * MSR_MTRRfix4K_C0000 ... MSR_MTRRfix4K_F8000, 8 units,\n\t * 4K fixed mtrr.\n\t */\n\t{\n\t\t.start = 0xc0000,\n\t\t.end = 0x100000,\n\t\t.range_shift = 12, /* 12K */\n\t\t.range_start = 24,\n\t}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"mmu.h\"\n#include \"cpuid.h\"\n#include <asm/mtrr.h>\n#include <linux/kvm_host.h>\n\nstatic struct fixed_mtrr_segment fixed_seg_table[] = {\n\t/* MSR_MTRRfix64K_00000, 1 unit. 64K fixed mtrr. */\n\t{\n\t\t.start = 0x0,\n\t\t.end = 0x80000,\n\t\t.range_shift = 16, /* 64K */\n\t\t.range_start = 0,\n\t},\n\n\t/*\n\t * MSR_MTRRfix16K_80000 ... MSR_MTRRfix16K_A0000, 2 units,\n\t * 16K fixed mtrr.\n\t */\n\t{\n\t\t.start = 0x80000,\n\t\t.end = 0xc0000,\n\t\t.range_shift = 14, /* 16K */\n\t\t.range_start = 8,\n\t},\n\n\t/*\n\t * MSR_MTRRfix4K_C0000 ... MSR_MTRRfix4K_F8000, 8 units,\n\t * 4K fixed mtrr.\n\t */\n\t{\n\t\t.start = 0xc0000,\n\t\t.end = 0x100000,\n\t\t.range_shift = 12, /* 12K */\n\t\t.range_start = 24,\n\t}\n};\n\nstatic int fixed_mtrr_addr_to_seg(u64 addr)\n{\n\tstruct fixed_mtrr_segment *mtrr_seg;\n\tint seg, seg_num = ARRAY_SIZE(fixed_seg_table);\n\n\tfor (seg = 0; seg < seg_num; seg++) {\n\t\tmtrr_seg = &fixed_seg_table[seg];\n\t\tif (mtrr_seg->start <= addr && addr < mtrr_seg->end)\n\t\t\treturn seg;\n\t}\n\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fixed_mtrr_is_enabled",
          "args": [
            "iter->mtrr_state"
          ],
          "line": 488
        },
        "resolved": true,
        "details": {
          "function_name": "fixed_mtrr_is_enabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mtrr.c",
          "lines": "113-116",
          "snippet": "static bool fixed_mtrr_is_enabled(struct kvm_mtrr *mtrr_state)\n{\n\treturn !!(mtrr_state->deftype & IA32_MTRR_DEF_TYPE_FE);\n}",
          "includes": [
            "#include \"mmu.h\"",
            "#include \"cpuid.h\"",
            "#include <asm/mtrr.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define IA32_MTRR_DEF_TYPE_FE\t\t(1ULL << 10)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mmu.h\"\n#include \"cpuid.h\"\n#include <asm/mtrr.h>\n#include <linux/kvm_host.h>\n\n#define IA32_MTRR_DEF_TYPE_FE\t\t(1ULL << 10)\n\nstatic bool fixed_mtrr_is_enabled(struct kvm_mtrr *mtrr_state)\n{\n\treturn !!(mtrr_state->deftype & IA32_MTRR_DEF_TYPE_FE);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"mmu.h\"\n#include \"cpuid.h\"\n#include <asm/mtrr.h>\n#include <linux/kvm_host.h>\n\nstatic bool mtrr_lookup_fixed_start(struct mtrr_iter *iter)\n{\n\tint seg, index;\n\n\tif (!fixed_mtrr_is_enabled(iter->mtrr_state))\n\t\treturn false;\n\n\tseg = fixed_mtrr_addr_to_seg(iter->start);\n\tif (seg < 0)\n\t\treturn false;\n\n\titer->fixed = true;\n\tindex = fixed_mtrr_addr_seg_to_range_index(iter->start, seg);\n\titer->index = index;\n\titer->seg = seg;\n\treturn true;\n}"
  },
  {
    "function_name": "kvm_vcpu_mtrr_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mtrr.c",
    "lines": "447-450",
    "snippet": "void kvm_vcpu_mtrr_init(struct kvm_vcpu *vcpu)\n{\n\tINIT_LIST_HEAD(&vcpu->arch.mtrr_state.head);\n}",
    "includes": [
      "#include \"mmu.h\"",
      "#include \"cpuid.h\"",
      "#include <asm/mtrr.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&vcpu->arch.mtrr_state.head"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"mmu.h\"\n#include \"cpuid.h\"\n#include <asm/mtrr.h>\n#include <linux/kvm_host.h>\n\nvoid kvm_vcpu_mtrr_init(struct kvm_vcpu *vcpu)\n{\n\tINIT_LIST_HEAD(&vcpu->arch.mtrr_state.head);\n}"
  },
  {
    "function_name": "kvm_mtrr_get_msr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mtrr.c",
    "lines": "405-445",
    "snippet": "int kvm_mtrr_get_msr(struct kvm_vcpu *vcpu, u32 msr, u64 *pdata)\n{\n\tint index;\n\n\t/* MSR_MTRRcap is a readonly MSR. */\n\tif (msr == MSR_MTRRcap) {\n\t\t/*\n\t\t * SMRR = 0\n\t\t * WC = 1\n\t\t * FIX = 1\n\t\t * VCNT = KVM_NR_VAR_MTRR\n\t\t */\n\t\t*pdata = 0x500 | KVM_NR_VAR_MTRR;\n\t\treturn 0;\n\t}\n\n\tif (!msr_mtrr_valid(msr))\n\t\treturn 1;\n\n\tindex = fixed_msr_to_range_index(msr);\n\tif (index >= 0)\n\t\t*pdata = *(u64 *)&vcpu->arch.mtrr_state.fixed_ranges[index];\n\telse if (msr == MSR_MTRRdefType)\n\t\t*pdata = vcpu->arch.mtrr_state.deftype;\n\telse if (msr == MSR_IA32_CR_PAT)\n\t\t*pdata = vcpu->arch.pat;\n\telse {\t/* Variable MTRRs */\n\t\tint is_mtrr_mask;\n\n\t\tindex = (msr - 0x200) / 2;\n\t\tis_mtrr_mask = msr - 0x200 - 2 * index;\n\t\tif (!is_mtrr_mask)\n\t\t\t*pdata = vcpu->arch.mtrr_state.var_ranges[index].base;\n\t\telse\n\t\t\t*pdata = vcpu->arch.mtrr_state.var_ranges[index].mask;\n\n\t\t*pdata &= (1ULL << cpuid_maxphyaddr(vcpu)) - 1;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"mmu.h\"",
      "#include \"cpuid.h\"",
      "#include <asm/mtrr.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpuid_maxphyaddr",
          "args": [
            "vcpu"
          ],
          "line": 441
        },
        "resolved": true,
        "details": {
          "function_name": "cpuid_maxphyaddr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/cpuid.h",
          "lines": "27-30",
          "snippet": "static inline int cpuid_maxphyaddr(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.maxphyaddr;\n}",
          "includes": [
            "#include <asm/cpu.h>",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpu.h>\n#include \"x86.h\"\n\nstatic inline int cpuid_maxphyaddr(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.maxphyaddr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fixed_msr_to_range_index",
          "args": [
            "msr"
          ],
          "line": 424
        },
        "resolved": true,
        "details": {
          "function_name": "fixed_msr_to_range_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mtrr.c",
          "lines": "261-269",
          "snippet": "static int fixed_msr_to_range_index(u32 msr)\n{\n\tint seg, unit;\n\n\tif (!fixed_msr_to_seg_unit(msr, &seg, &unit))\n\t\treturn -1;\n\n\treturn fixed_mtrr_seg_unit_range_index(seg, unit);\n}",
          "includes": [
            "#include \"mmu.h\"",
            "#include \"cpuid.h\"",
            "#include <asm/mtrr.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mmu.h\"\n#include \"cpuid.h\"\n#include <asm/mtrr.h>\n#include <linux/kvm_host.h>\n\nstatic int fixed_msr_to_range_index(u32 msr)\n{\n\tint seg, unit;\n\n\tif (!fixed_msr_to_seg_unit(msr, &seg, &unit))\n\t\treturn -1;\n\n\treturn fixed_mtrr_seg_unit_range_index(seg, unit);\n}"
        }
      },
      {
        "call_info": {
          "callee": "msr_mtrr_valid",
          "args": [
            "msr"
          ],
          "line": 421
        },
        "resolved": true,
        "details": {
          "function_name": "msr_mtrr_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mtrr.c",
          "lines": "29-51",
          "snippet": "static bool msr_mtrr_valid(unsigned msr)\n{\n\tswitch (msr) {\n\tcase 0x200 ... 0x200 + 2 * KVM_NR_VAR_MTRR - 1:\n\tcase MSR_MTRRfix64K_00000:\n\tcase MSR_MTRRfix16K_80000:\n\tcase MSR_MTRRfix16K_A0000:\n\tcase MSR_MTRRfix4K_C0000:\n\tcase MSR_MTRRfix4K_C8000:\n\tcase MSR_MTRRfix4K_D0000:\n\tcase MSR_MTRRfix4K_D8000:\n\tcase MSR_MTRRfix4K_E0000:\n\tcase MSR_MTRRfix4K_E8000:\n\tcase MSR_MTRRfix4K_F0000:\n\tcase MSR_MTRRfix4K_F8000:\n\tcase MSR_MTRRdefType:\n\tcase MSR_IA32_CR_PAT:\n\t\treturn true;\n\tcase 0x2f8:\n\t\treturn true;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include \"mmu.h\"",
            "#include \"cpuid.h\"",
            "#include <asm/mtrr.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mmu.h\"\n#include \"cpuid.h\"\n#include <asm/mtrr.h>\n#include <linux/kvm_host.h>\n\nstatic bool msr_mtrr_valid(unsigned msr)\n{\n\tswitch (msr) {\n\tcase 0x200 ... 0x200 + 2 * KVM_NR_VAR_MTRR - 1:\n\tcase MSR_MTRRfix64K_00000:\n\tcase MSR_MTRRfix16K_80000:\n\tcase MSR_MTRRfix16K_A0000:\n\tcase MSR_MTRRfix4K_C0000:\n\tcase MSR_MTRRfix4K_C8000:\n\tcase MSR_MTRRfix4K_D0000:\n\tcase MSR_MTRRfix4K_D8000:\n\tcase MSR_MTRRfix4K_E0000:\n\tcase MSR_MTRRfix4K_E8000:\n\tcase MSR_MTRRfix4K_F0000:\n\tcase MSR_MTRRfix4K_F8000:\n\tcase MSR_MTRRdefType:\n\tcase MSR_IA32_CR_PAT:\n\t\treturn true;\n\tcase 0x2f8:\n\t\treturn true;\n\t}\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"mmu.h\"\n#include \"cpuid.h\"\n#include <asm/mtrr.h>\n#include <linux/kvm_host.h>\n\nint kvm_mtrr_get_msr(struct kvm_vcpu *vcpu, u32 msr, u64 *pdata)\n{\n\tint index;\n\n\t/* MSR_MTRRcap is a readonly MSR. */\n\tif (msr == MSR_MTRRcap) {\n\t\t/*\n\t\t * SMRR = 0\n\t\t * WC = 1\n\t\t * FIX = 1\n\t\t * VCNT = KVM_NR_VAR_MTRR\n\t\t */\n\t\t*pdata = 0x500 | KVM_NR_VAR_MTRR;\n\t\treturn 0;\n\t}\n\n\tif (!msr_mtrr_valid(msr))\n\t\treturn 1;\n\n\tindex = fixed_msr_to_range_index(msr);\n\tif (index >= 0)\n\t\t*pdata = *(u64 *)&vcpu->arch.mtrr_state.fixed_ranges[index];\n\telse if (msr == MSR_MTRRdefType)\n\t\t*pdata = vcpu->arch.mtrr_state.deftype;\n\telse if (msr == MSR_IA32_CR_PAT)\n\t\t*pdata = vcpu->arch.pat;\n\telse {\t/* Variable MTRRs */\n\t\tint is_mtrr_mask;\n\n\t\tindex = (msr - 0x200) / 2;\n\t\tis_mtrr_mask = msr - 0x200 - 2 * index;\n\t\tif (!is_mtrr_mask)\n\t\t\t*pdata = vcpu->arch.mtrr_state.var_ranges[index].base;\n\t\telse\n\t\t\t*pdata = vcpu->arch.mtrr_state.var_ranges[index].mask;\n\n\t\t*pdata &= (1ULL << cpuid_maxphyaddr(vcpu)) - 1;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "kvm_mtrr_set_msr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mtrr.c",
    "lines": "384-403",
    "snippet": "int kvm_mtrr_set_msr(struct kvm_vcpu *vcpu, u32 msr, u64 data)\n{\n\tint index;\n\n\tif (!kvm_mtrr_valid(vcpu, msr, data))\n\t\treturn 1;\n\n\tindex = fixed_msr_to_range_index(msr);\n\tif (index >= 0)\n\t\t*(u64 *)&vcpu->arch.mtrr_state.fixed_ranges[index] = data;\n\telse if (msr == MSR_MTRRdefType)\n\t\tvcpu->arch.mtrr_state.deftype = data;\n\telse if (msr == MSR_IA32_CR_PAT)\n\t\tvcpu->arch.pat = data;\n\telse\n\t\tset_var_mtrr_msr(vcpu, msr, data);\n\n\tupdate_mtrr(vcpu, msr);\n\treturn 0;\n}",
    "includes": [
      "#include \"mmu.h\"",
      "#include \"cpuid.h\"",
      "#include <asm/mtrr.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "update_mtrr",
          "args": [
            "vcpu",
            "msr"
          ],
          "line": 401
        },
        "resolved": true,
        "details": {
          "function_name": "update_mtrr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mtrr.c",
          "lines": "318-345",
          "snippet": "static void update_mtrr(struct kvm_vcpu *vcpu, u32 msr)\n{\n\tstruct kvm_mtrr *mtrr_state = &vcpu->arch.mtrr_state;\n\tgfn_t start, end;\n\tint index;\n\n\tif (msr == MSR_IA32_CR_PAT || !tdp_enabled ||\n\t      !kvm_arch_has_noncoherent_dma(vcpu->kvm))\n\t\treturn;\n\n\tif (!mtrr_is_enabled(mtrr_state) && msr != MSR_MTRRdefType)\n\t\treturn;\n\n\t/* fixed MTRRs. */\n\tif (fixed_msr_to_range(msr, &start, &end)) {\n\t\tif (!fixed_mtrr_is_enabled(mtrr_state))\n\t\t\treturn;\n\t} else if (msr == MSR_MTRRdefType) {\n\t\tstart = 0x0;\n\t\tend = ~0ULL;\n\t} else {\n\t\t/* variable range MTRRs. */\n\t\tindex = (msr - 0x200) / 2;\n\t\tvar_mtrr_range(&mtrr_state->var_ranges[index], &start, &end);\n\t}\n\n\tkvm_zap_gfn_range(vcpu->kvm, gpa_to_gfn(start), gpa_to_gfn(end));\n}",
          "includes": [
            "#include \"mmu.h\"",
            "#include \"cpuid.h\"",
            "#include <asm/mtrr.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mmu.h\"\n#include \"cpuid.h\"\n#include <asm/mtrr.h>\n#include <linux/kvm_host.h>\n\nstatic void update_mtrr(struct kvm_vcpu *vcpu, u32 msr)\n{\n\tstruct kvm_mtrr *mtrr_state = &vcpu->arch.mtrr_state;\n\tgfn_t start, end;\n\tint index;\n\n\tif (msr == MSR_IA32_CR_PAT || !tdp_enabled ||\n\t      !kvm_arch_has_noncoherent_dma(vcpu->kvm))\n\t\treturn;\n\n\tif (!mtrr_is_enabled(mtrr_state) && msr != MSR_MTRRdefType)\n\t\treturn;\n\n\t/* fixed MTRRs. */\n\tif (fixed_msr_to_range(msr, &start, &end)) {\n\t\tif (!fixed_mtrr_is_enabled(mtrr_state))\n\t\t\treturn;\n\t} else if (msr == MSR_MTRRdefType) {\n\t\tstart = 0x0;\n\t\tend = ~0ULL;\n\t} else {\n\t\t/* variable range MTRRs. */\n\t\tindex = (msr - 0x200) / 2;\n\t\tvar_mtrr_range(&mtrr_state->var_ranges[index], &start, &end);\n\t}\n\n\tkvm_zap_gfn_range(vcpu->kvm, gpa_to_gfn(start), gpa_to_gfn(end));\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_var_mtrr_msr",
          "args": [
            "vcpu",
            "msr",
            "data"
          ],
          "line": 399
        },
        "resolved": true,
        "details": {
          "function_name": "set_var_mtrr_msr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mtrr.c",
          "lines": "352-382",
          "snippet": "static void set_var_mtrr_msr(struct kvm_vcpu *vcpu, u32 msr, u64 data)\n{\n\tstruct kvm_mtrr *mtrr_state = &vcpu->arch.mtrr_state;\n\tstruct kvm_mtrr_range *tmp, *cur;\n\tint index, is_mtrr_mask;\n\n\tindex = (msr - 0x200) / 2;\n\tis_mtrr_mask = msr - 0x200 - 2 * index;\n\tcur = &mtrr_state->var_ranges[index];\n\n\t/* remove the entry if it's in the list. */\n\tif (var_mtrr_range_is_valid(cur))\n\t\tlist_del(&mtrr_state->var_ranges[index].node);\n\n\t/* Extend the mask with all 1 bits to the left, since those\n\t * bits must implicitly be 0.  The bits are then cleared\n\t * when reading them.\n\t */\n\tif (!is_mtrr_mask)\n\t\tcur->base = data;\n\telse\n\t\tcur->mask = data | (-1LL << cpuid_maxphyaddr(vcpu));\n\n\t/* add it to the list if it's enabled. */\n\tif (var_mtrr_range_is_valid(cur)) {\n\t\tlist_for_each_entry(tmp, &mtrr_state->head, node)\n\t\t\tif (cur->base >= tmp->base)\n\t\t\t\tbreak;\n\t\tlist_add_tail(&cur->node, &tmp->node);\n\t}\n}",
          "includes": [
            "#include \"mmu.h\"",
            "#include \"cpuid.h\"",
            "#include <asm/mtrr.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mmu.h\"\n#include \"cpuid.h\"\n#include <asm/mtrr.h>\n#include <linux/kvm_host.h>\n\nstatic void set_var_mtrr_msr(struct kvm_vcpu *vcpu, u32 msr, u64 data)\n{\n\tstruct kvm_mtrr *mtrr_state = &vcpu->arch.mtrr_state;\n\tstruct kvm_mtrr_range *tmp, *cur;\n\tint index, is_mtrr_mask;\n\n\tindex = (msr - 0x200) / 2;\n\tis_mtrr_mask = msr - 0x200 - 2 * index;\n\tcur = &mtrr_state->var_ranges[index];\n\n\t/* remove the entry if it's in the list. */\n\tif (var_mtrr_range_is_valid(cur))\n\t\tlist_del(&mtrr_state->var_ranges[index].node);\n\n\t/* Extend the mask with all 1 bits to the left, since those\n\t * bits must implicitly be 0.  The bits are then cleared\n\t * when reading them.\n\t */\n\tif (!is_mtrr_mask)\n\t\tcur->base = data;\n\telse\n\t\tcur->mask = data | (-1LL << cpuid_maxphyaddr(vcpu));\n\n\t/* add it to the list if it's enabled. */\n\tif (var_mtrr_range_is_valid(cur)) {\n\t\tlist_for_each_entry(tmp, &mtrr_state->head, node)\n\t\t\tif (cur->base >= tmp->base)\n\t\t\t\tbreak;\n\t\tlist_add_tail(&cur->node, &tmp->node);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fixed_msr_to_range_index",
          "args": [
            "msr"
          ],
          "line": 391
        },
        "resolved": true,
        "details": {
          "function_name": "fixed_msr_to_range_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mtrr.c",
          "lines": "261-269",
          "snippet": "static int fixed_msr_to_range_index(u32 msr)\n{\n\tint seg, unit;\n\n\tif (!fixed_msr_to_seg_unit(msr, &seg, &unit))\n\t\treturn -1;\n\n\treturn fixed_mtrr_seg_unit_range_index(seg, unit);\n}",
          "includes": [
            "#include \"mmu.h\"",
            "#include \"cpuid.h\"",
            "#include <asm/mtrr.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mmu.h\"\n#include \"cpuid.h\"\n#include <asm/mtrr.h>\n#include <linux/kvm_host.h>\n\nstatic int fixed_msr_to_range_index(u32 msr)\n{\n\tint seg, unit;\n\n\tif (!fixed_msr_to_seg_unit(msr, &seg, &unit))\n\t\treturn -1;\n\n\treturn fixed_mtrr_seg_unit_range_index(seg, unit);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_mtrr_valid",
          "args": [
            "vcpu",
            "msr",
            "data"
          ],
          "line": 388
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mtrr_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mtrr.c",
          "lines": "63-105",
          "snippet": "bool kvm_mtrr_valid(struct kvm_vcpu *vcpu, u32 msr, u64 data)\n{\n\tint i;\n\tu64 mask;\n\n\tif (!msr_mtrr_valid(msr))\n\t\treturn false;\n\n\tif (msr == MSR_IA32_CR_PAT) {\n\t\tfor (i = 0; i < 8; i++)\n\t\t\tif (!valid_pat_type((data >> (i * 8)) & 0xff))\n\t\t\t\treturn false;\n\t\treturn true;\n\t} else if (msr == MSR_MTRRdefType) {\n\t\tif (data & ~0xcff)\n\t\t\treturn false;\n\t\treturn valid_mtrr_type(data & 0xff);\n\t} else if (msr >= MSR_MTRRfix64K_00000 && msr <= MSR_MTRRfix4K_F8000) {\n\t\tfor (i = 0; i < 8 ; i++)\n\t\t\tif (!valid_mtrr_type((data >> (i * 8)) & 0xff))\n\t\t\t\treturn false;\n\t\treturn true;\n\t}\n\n\t/* variable MTRRs */\n\tWARN_ON(!(msr >= 0x200 && msr < 0x200 + 2 * KVM_NR_VAR_MTRR));\n\n\tmask = (~0ULL) << cpuid_maxphyaddr(vcpu);\n\tif ((msr & 1) == 0) {\n\t\t/* MTRR base */\n\t\tif (!valid_mtrr_type(data & 0xff))\n\t\t\treturn false;\n\t\tmask |= 0xf00;\n\t} else\n\t\t/* MTRR mask */\n\t\tmask |= 0x7ff;\n\tif (data & mask) {\n\t\tkvm_inject_gp(vcpu, 0);\n\t\treturn false;\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include \"mmu.h\"",
            "#include \"cpuid.h\"",
            "#include <asm/mtrr.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mmu.h\"\n#include \"cpuid.h\"\n#include <asm/mtrr.h>\n#include <linux/kvm_host.h>\n\nbool kvm_mtrr_valid(struct kvm_vcpu *vcpu, u32 msr, u64 data)\n{\n\tint i;\n\tu64 mask;\n\n\tif (!msr_mtrr_valid(msr))\n\t\treturn false;\n\n\tif (msr == MSR_IA32_CR_PAT) {\n\t\tfor (i = 0; i < 8; i++)\n\t\t\tif (!valid_pat_type((data >> (i * 8)) & 0xff))\n\t\t\t\treturn false;\n\t\treturn true;\n\t} else if (msr == MSR_MTRRdefType) {\n\t\tif (data & ~0xcff)\n\t\t\treturn false;\n\t\treturn valid_mtrr_type(data & 0xff);\n\t} else if (msr >= MSR_MTRRfix64K_00000 && msr <= MSR_MTRRfix4K_F8000) {\n\t\tfor (i = 0; i < 8 ; i++)\n\t\t\tif (!valid_mtrr_type((data >> (i * 8)) & 0xff))\n\t\t\t\treturn false;\n\t\treturn true;\n\t}\n\n\t/* variable MTRRs */\n\tWARN_ON(!(msr >= 0x200 && msr < 0x200 + 2 * KVM_NR_VAR_MTRR));\n\n\tmask = (~0ULL) << cpuid_maxphyaddr(vcpu);\n\tif ((msr & 1) == 0) {\n\t\t/* MTRR base */\n\t\tif (!valid_mtrr_type(data & 0xff))\n\t\t\treturn false;\n\t\tmask |= 0xf00;\n\t} else\n\t\t/* MTRR mask */\n\t\tmask |= 0x7ff;\n\tif (data & mask) {\n\t\tkvm_inject_gp(vcpu, 0);\n\t\treturn false;\n\t}\n\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"mmu.h\"\n#include \"cpuid.h\"\n#include <asm/mtrr.h>\n#include <linux/kvm_host.h>\n\nint kvm_mtrr_set_msr(struct kvm_vcpu *vcpu, u32 msr, u64 data)\n{\n\tint index;\n\n\tif (!kvm_mtrr_valid(vcpu, msr, data))\n\t\treturn 1;\n\n\tindex = fixed_msr_to_range_index(msr);\n\tif (index >= 0)\n\t\t*(u64 *)&vcpu->arch.mtrr_state.fixed_ranges[index] = data;\n\telse if (msr == MSR_MTRRdefType)\n\t\tvcpu->arch.mtrr_state.deftype = data;\n\telse if (msr == MSR_IA32_CR_PAT)\n\t\tvcpu->arch.pat = data;\n\telse\n\t\tset_var_mtrr_msr(vcpu, msr, data);\n\n\tupdate_mtrr(vcpu, msr);\n\treturn 0;\n}"
  },
  {
    "function_name": "set_var_mtrr_msr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mtrr.c",
    "lines": "352-382",
    "snippet": "static void set_var_mtrr_msr(struct kvm_vcpu *vcpu, u32 msr, u64 data)\n{\n\tstruct kvm_mtrr *mtrr_state = &vcpu->arch.mtrr_state;\n\tstruct kvm_mtrr_range *tmp, *cur;\n\tint index, is_mtrr_mask;\n\n\tindex = (msr - 0x200) / 2;\n\tis_mtrr_mask = msr - 0x200 - 2 * index;\n\tcur = &mtrr_state->var_ranges[index];\n\n\t/* remove the entry if it's in the list. */\n\tif (var_mtrr_range_is_valid(cur))\n\t\tlist_del(&mtrr_state->var_ranges[index].node);\n\n\t/* Extend the mask with all 1 bits to the left, since those\n\t * bits must implicitly be 0.  The bits are then cleared\n\t * when reading them.\n\t */\n\tif (!is_mtrr_mask)\n\t\tcur->base = data;\n\telse\n\t\tcur->mask = data | (-1LL << cpuid_maxphyaddr(vcpu));\n\n\t/* add it to the list if it's enabled. */\n\tif (var_mtrr_range_is_valid(cur)) {\n\t\tlist_for_each_entry(tmp, &mtrr_state->head, node)\n\t\t\tif (cur->base >= tmp->base)\n\t\t\t\tbreak;\n\t\tlist_add_tail(&cur->node, &tmp->node);\n\t}\n}",
    "includes": [
      "#include \"mmu.h\"",
      "#include \"cpuid.h\"",
      "#include <asm/mtrr.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&cur->node",
            "&tmp->node"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "tmp",
            "&mtrr_state->head",
            "node"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "var_mtrr_range_is_valid",
          "args": [
            "cur"
          ],
          "line": 376
        },
        "resolved": true,
        "details": {
          "function_name": "var_mtrr_range_is_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mtrr.c",
          "lines": "347-350",
          "snippet": "static bool var_mtrr_range_is_valid(struct kvm_mtrr_range *range)\n{\n\treturn (range->mask & (1 << 11)) != 0;\n}",
          "includes": [
            "#include \"mmu.h\"",
            "#include \"cpuid.h\"",
            "#include <asm/mtrr.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mmu.h\"\n#include \"cpuid.h\"\n#include <asm/mtrr.h>\n#include <linux/kvm_host.h>\n\nstatic bool var_mtrr_range_is_valid(struct kvm_mtrr_range *range)\n{\n\treturn (range->mask & (1 << 11)) != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuid_maxphyaddr",
          "args": [
            "vcpu"
          ],
          "line": 373
        },
        "resolved": true,
        "details": {
          "function_name": "cpuid_maxphyaddr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/cpuid.h",
          "lines": "27-30",
          "snippet": "static inline int cpuid_maxphyaddr(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.maxphyaddr;\n}",
          "includes": [
            "#include <asm/cpu.h>",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpu.h>\n#include \"x86.h\"\n\nstatic inline int cpuid_maxphyaddr(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.maxphyaddr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&mtrr_state->var_ranges[index].node"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"mmu.h\"\n#include \"cpuid.h\"\n#include <asm/mtrr.h>\n#include <linux/kvm_host.h>\n\nstatic void set_var_mtrr_msr(struct kvm_vcpu *vcpu, u32 msr, u64 data)\n{\n\tstruct kvm_mtrr *mtrr_state = &vcpu->arch.mtrr_state;\n\tstruct kvm_mtrr_range *tmp, *cur;\n\tint index, is_mtrr_mask;\n\n\tindex = (msr - 0x200) / 2;\n\tis_mtrr_mask = msr - 0x200 - 2 * index;\n\tcur = &mtrr_state->var_ranges[index];\n\n\t/* remove the entry if it's in the list. */\n\tif (var_mtrr_range_is_valid(cur))\n\t\tlist_del(&mtrr_state->var_ranges[index].node);\n\n\t/* Extend the mask with all 1 bits to the left, since those\n\t * bits must implicitly be 0.  The bits are then cleared\n\t * when reading them.\n\t */\n\tif (!is_mtrr_mask)\n\t\tcur->base = data;\n\telse\n\t\tcur->mask = data | (-1LL << cpuid_maxphyaddr(vcpu));\n\n\t/* add it to the list if it's enabled. */\n\tif (var_mtrr_range_is_valid(cur)) {\n\t\tlist_for_each_entry(tmp, &mtrr_state->head, node)\n\t\t\tif (cur->base >= tmp->base)\n\t\t\t\tbreak;\n\t\tlist_add_tail(&cur->node, &tmp->node);\n\t}\n}"
  },
  {
    "function_name": "var_mtrr_range_is_valid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mtrr.c",
    "lines": "347-350",
    "snippet": "static bool var_mtrr_range_is_valid(struct kvm_mtrr_range *range)\n{\n\treturn (range->mask & (1 << 11)) != 0;\n}",
    "includes": [
      "#include \"mmu.h\"",
      "#include \"cpuid.h\"",
      "#include <asm/mtrr.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"mmu.h\"\n#include \"cpuid.h\"\n#include <asm/mtrr.h>\n#include <linux/kvm_host.h>\n\nstatic bool var_mtrr_range_is_valid(struct kvm_mtrr_range *range)\n{\n\treturn (range->mask & (1 << 11)) != 0;\n}"
  },
  {
    "function_name": "update_mtrr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mtrr.c",
    "lines": "318-345",
    "snippet": "static void update_mtrr(struct kvm_vcpu *vcpu, u32 msr)\n{\n\tstruct kvm_mtrr *mtrr_state = &vcpu->arch.mtrr_state;\n\tgfn_t start, end;\n\tint index;\n\n\tif (msr == MSR_IA32_CR_PAT || !tdp_enabled ||\n\t      !kvm_arch_has_noncoherent_dma(vcpu->kvm))\n\t\treturn;\n\n\tif (!mtrr_is_enabled(mtrr_state) && msr != MSR_MTRRdefType)\n\t\treturn;\n\n\t/* fixed MTRRs. */\n\tif (fixed_msr_to_range(msr, &start, &end)) {\n\t\tif (!fixed_mtrr_is_enabled(mtrr_state))\n\t\t\treturn;\n\t} else if (msr == MSR_MTRRdefType) {\n\t\tstart = 0x0;\n\t\tend = ~0ULL;\n\t} else {\n\t\t/* variable range MTRRs. */\n\t\tindex = (msr - 0x200) / 2;\n\t\tvar_mtrr_range(&mtrr_state->var_ranges[index], &start, &end);\n\t}\n\n\tkvm_zap_gfn_range(vcpu->kvm, gpa_to_gfn(start), gpa_to_gfn(end));\n}",
    "includes": [
      "#include \"mmu.h\"",
      "#include \"cpuid.h\"",
      "#include <asm/mtrr.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_zap_gfn_range",
          "args": [
            "vcpu->kvm",
            "gpa_to_gfn(start)",
            "gpa_to_gfn(end)"
          ],
          "line": 344
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_zap_gfn_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "4697-4721",
          "snippet": "void kvm_zap_gfn_range(struct kvm *kvm, gfn_t gfn_start, gfn_t gfn_end)\n{\n\tstruct kvm_memslots *slots;\n\tstruct kvm_memory_slot *memslot;\n\tint i;\n\n\tspin_lock(&kvm->mmu_lock);\n\tfor (i = 0; i < KVM_ADDRESS_SPACE_NUM; i++) {\n\t\tslots = __kvm_memslots(kvm, i);\n\t\tkvm_for_each_memslot(memslot, slots) {\n\t\t\tgfn_t start, end;\n\n\t\t\tstart = max(gfn_start, memslot->base_gfn);\n\t\t\tend = min(gfn_end, memslot->base_gfn + memslot->npages);\n\t\t\tif (start >= end)\n\t\t\t\tcontinue;\n\n\t\t\tslot_handle_level_range(kvm, memslot, kvm_zap_rmapp,\n\t\t\t\t\t\tPT_PAGE_TABLE_LEVEL, PT_MAX_HUGEPAGE_LEVEL,\n\t\t\t\t\t\tstart, end - 1, true);\n\t\t}\n\t}\n\n\tspin_unlock(&kvm->mmu_lock);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nvoid kvm_zap_gfn_range(struct kvm *kvm, gfn_t gfn_start, gfn_t gfn_end)\n{\n\tstruct kvm_memslots *slots;\n\tstruct kvm_memory_slot *memslot;\n\tint i;\n\n\tspin_lock(&kvm->mmu_lock);\n\tfor (i = 0; i < KVM_ADDRESS_SPACE_NUM; i++) {\n\t\tslots = __kvm_memslots(kvm, i);\n\t\tkvm_for_each_memslot(memslot, slots) {\n\t\t\tgfn_t start, end;\n\n\t\t\tstart = max(gfn_start, memslot->base_gfn);\n\t\t\tend = min(gfn_end, memslot->base_gfn + memslot->npages);\n\t\t\tif (start >= end)\n\t\t\t\tcontinue;\n\n\t\t\tslot_handle_level_range(kvm, memslot, kvm_zap_rmapp,\n\t\t\t\t\t\tPT_PAGE_TABLE_LEVEL, PT_MAX_HUGEPAGE_LEVEL,\n\t\t\t\t\t\tstart, end - 1, true);\n\t\t}\n\t}\n\n\tspin_unlock(&kvm->mmu_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gpa_to_gfn",
          "args": [
            "end"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gpa_to_gfn",
          "args": [
            "start"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "var_mtrr_range",
          "args": [
            "&mtrr_state->var_ranges[index]",
            "&start",
            "&end"
          ],
          "line": 341
        },
        "resolved": true,
        "details": {
          "function_name": "var_mtrr_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mtrr.c",
          "lines": "304-316",
          "snippet": "static void var_mtrr_range(struct kvm_mtrr_range *range, u64 *start, u64 *end)\n{\n\tu64 mask;\n\n\t*start = range->base & PAGE_MASK;\n\n\tmask = range->mask & PAGE_MASK;\n\n\t/* This cannot overflow because writing to the reserved bits of\n\t * variable MTRRs causes a #GP.\n\t */\n\t*end = (*start | ~mask) + 1;\n}",
          "includes": [
            "#include \"mmu.h\"",
            "#include \"cpuid.h\"",
            "#include <asm/mtrr.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mmu.h\"\n#include \"cpuid.h\"\n#include <asm/mtrr.h>\n#include <linux/kvm_host.h>\n\nstatic void var_mtrr_range(struct kvm_mtrr_range *range, u64 *start, u64 *end)\n{\n\tu64 mask;\n\n\t*start = range->base & PAGE_MASK;\n\n\tmask = range->mask & PAGE_MASK;\n\n\t/* This cannot overflow because writing to the reserved bits of\n\t * variable MTRRs causes a #GP.\n\t */\n\t*end = (*start | ~mask) + 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fixed_mtrr_is_enabled",
          "args": [
            "mtrr_state"
          ],
          "line": 333
        },
        "resolved": true,
        "details": {
          "function_name": "fixed_mtrr_is_enabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mtrr.c",
          "lines": "113-116",
          "snippet": "static bool fixed_mtrr_is_enabled(struct kvm_mtrr *mtrr_state)\n{\n\treturn !!(mtrr_state->deftype & IA32_MTRR_DEF_TYPE_FE);\n}",
          "includes": [
            "#include \"mmu.h\"",
            "#include \"cpuid.h\"",
            "#include <asm/mtrr.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define IA32_MTRR_DEF_TYPE_FE\t\t(1ULL << 10)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mmu.h\"\n#include \"cpuid.h\"\n#include <asm/mtrr.h>\n#include <linux/kvm_host.h>\n\n#define IA32_MTRR_DEF_TYPE_FE\t\t(1ULL << 10)\n\nstatic bool fixed_mtrr_is_enabled(struct kvm_mtrr *mtrr_state)\n{\n\treturn !!(mtrr_state->deftype & IA32_MTRR_DEF_TYPE_FE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fixed_msr_to_range",
          "args": [
            "msr",
            "&start",
            "&end"
          ],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "fixed_msr_to_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mtrr.c",
          "lines": "250-259",
          "snippet": "static bool fixed_msr_to_range(u32 msr, u64 *start, u64 *end)\n{\n\tint seg, unit;\n\n\tif (!fixed_msr_to_seg_unit(msr, &seg, &unit))\n\t\treturn false;\n\n\tfixed_mtrr_seg_unit_range(seg, unit, start, end);\n\treturn true;\n}",
          "includes": [
            "#include \"mmu.h\"",
            "#include \"cpuid.h\"",
            "#include <asm/mtrr.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mmu.h\"\n#include \"cpuid.h\"\n#include <asm/mtrr.h>\n#include <linux/kvm_host.h>\n\nstatic bool fixed_msr_to_range(u32 msr, u64 *start, u64 *end)\n{\n\tint seg, unit;\n\n\tif (!fixed_msr_to_seg_unit(msr, &seg, &unit))\n\t\treturn false;\n\n\tfixed_mtrr_seg_unit_range(seg, unit, start, end);\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_arch_has_noncoherent_dma",
          "args": [
            "vcpu->kvm"
          ],
          "line": 325
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_arch_has_noncoherent_dma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "8361-8364",
          "snippet": "bool kvm_arch_has_noncoherent_dma(struct kvm *kvm)\n{\n\treturn atomic_read(&kvm->arch.noncoherent_dma_count);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nbool kvm_arch_has_noncoherent_dma(struct kvm *kvm)\n{\n\treturn atomic_read(&kvm->arch.noncoherent_dma_count);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"mmu.h\"\n#include \"cpuid.h\"\n#include <asm/mtrr.h>\n#include <linux/kvm_host.h>\n\nstatic void update_mtrr(struct kvm_vcpu *vcpu, u32 msr)\n{\n\tstruct kvm_mtrr *mtrr_state = &vcpu->arch.mtrr_state;\n\tgfn_t start, end;\n\tint index;\n\n\tif (msr == MSR_IA32_CR_PAT || !tdp_enabled ||\n\t      !kvm_arch_has_noncoherent_dma(vcpu->kvm))\n\t\treturn;\n\n\tif (!mtrr_is_enabled(mtrr_state) && msr != MSR_MTRRdefType)\n\t\treturn;\n\n\t/* fixed MTRRs. */\n\tif (fixed_msr_to_range(msr, &start, &end)) {\n\t\tif (!fixed_mtrr_is_enabled(mtrr_state))\n\t\t\treturn;\n\t} else if (msr == MSR_MTRRdefType) {\n\t\tstart = 0x0;\n\t\tend = ~0ULL;\n\t} else {\n\t\t/* variable range MTRRs. */\n\t\tindex = (msr - 0x200) / 2;\n\t\tvar_mtrr_range(&mtrr_state->var_ranges[index], &start, &end);\n\t}\n\n\tkvm_zap_gfn_range(vcpu->kvm, gpa_to_gfn(start), gpa_to_gfn(end));\n}"
  },
  {
    "function_name": "var_mtrr_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mtrr.c",
    "lines": "304-316",
    "snippet": "static void var_mtrr_range(struct kvm_mtrr_range *range, u64 *start, u64 *end)\n{\n\tu64 mask;\n\n\t*start = range->base & PAGE_MASK;\n\n\tmask = range->mask & PAGE_MASK;\n\n\t/* This cannot overflow because writing to the reserved bits of\n\t * variable MTRRs causes a #GP.\n\t */\n\t*end = (*start | ~mask) + 1;\n}",
    "includes": [
      "#include \"mmu.h\"",
      "#include \"cpuid.h\"",
      "#include <asm/mtrr.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"mmu.h\"\n#include \"cpuid.h\"\n#include <asm/mtrr.h>\n#include <linux/kvm_host.h>\n\nstatic void var_mtrr_range(struct kvm_mtrr_range *range, u64 *start, u64 *end)\n{\n\tu64 mask;\n\n\t*start = range->base & PAGE_MASK;\n\n\tmask = range->mask & PAGE_MASK;\n\n\t/* This cannot overflow because writing to the reserved bits of\n\t * variable MTRRs causes a #GP.\n\t */\n\t*end = (*start | ~mask) + 1;\n}"
  },
  {
    "function_name": "fixed_mtrr_range_end_addr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mtrr.c",
    "lines": "296-302",
    "snippet": "static u64 fixed_mtrr_range_end_addr(int seg, int index)\n{\n\tstruct fixed_mtrr_segment *mtrr_seg = &fixed_seg_table[seg];\n\tint pos = index - mtrr_seg->range_start;\n\n\treturn mtrr_seg->start + ((pos + 1) << mtrr_seg->range_shift);\n}",
    "includes": [
      "#include \"mmu.h\"",
      "#include \"cpuid.h\"",
      "#include <asm/mtrr.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct fixed_mtrr_segment fixed_seg_table[] = {\n\t/* MSR_MTRRfix64K_00000, 1 unit. 64K fixed mtrr. */\n\t{\n\t\t.start = 0x0,\n\t\t.end = 0x80000,\n\t\t.range_shift = 16, /* 64K */\n\t\t.range_start = 0,\n\t},\n\n\t/*\n\t * MSR_MTRRfix16K_80000 ... MSR_MTRRfix16K_A0000, 2 units,\n\t * 16K fixed mtrr.\n\t */\n\t{\n\t\t.start = 0x80000,\n\t\t.end = 0xc0000,\n\t\t.range_shift = 14, /* 16K */\n\t\t.range_start = 8,\n\t},\n\n\t/*\n\t * MSR_MTRRfix4K_C0000 ... MSR_MTRRfix4K_F8000, 8 units,\n\t * 4K fixed mtrr.\n\t */\n\t{\n\t\t.start = 0xc0000,\n\t\t.end = 0x100000,\n\t\t.range_shift = 12, /* 12K */\n\t\t.range_start = 24,\n\t}\n};"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"mmu.h\"\n#include \"cpuid.h\"\n#include <asm/mtrr.h>\n#include <linux/kvm_host.h>\n\nstatic struct fixed_mtrr_segment fixed_seg_table[] = {\n\t/* MSR_MTRRfix64K_00000, 1 unit. 64K fixed mtrr. */\n\t{\n\t\t.start = 0x0,\n\t\t.end = 0x80000,\n\t\t.range_shift = 16, /* 64K */\n\t\t.range_start = 0,\n\t},\n\n\t/*\n\t * MSR_MTRRfix16K_80000 ... MSR_MTRRfix16K_A0000, 2 units,\n\t * 16K fixed mtrr.\n\t */\n\t{\n\t\t.start = 0x80000,\n\t\t.end = 0xc0000,\n\t\t.range_shift = 14, /* 16K */\n\t\t.range_start = 8,\n\t},\n\n\t/*\n\t * MSR_MTRRfix4K_C0000 ... MSR_MTRRfix4K_F8000, 8 units,\n\t * 4K fixed mtrr.\n\t */\n\t{\n\t\t.start = 0xc0000,\n\t\t.end = 0x100000,\n\t\t.range_shift = 12, /* 12K */\n\t\t.range_start = 24,\n\t}\n};\n\nstatic u64 fixed_mtrr_range_end_addr(int seg, int index)\n{\n\tstruct fixed_mtrr_segment *mtrr_seg = &fixed_seg_table[seg];\n\tint pos = index - mtrr_seg->range_start;\n\n\treturn mtrr_seg->start + ((pos + 1) << mtrr_seg->range_shift);\n}"
  },
  {
    "function_name": "fixed_mtrr_addr_seg_to_range_index",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mtrr.c",
    "lines": "285-294",
    "snippet": "static int fixed_mtrr_addr_seg_to_range_index(u64 addr, int seg)\n{\n\tstruct fixed_mtrr_segment *mtrr_seg;\n\tint index;\n\n\tmtrr_seg = &fixed_seg_table[seg];\n\tindex = mtrr_seg->range_start;\n\tindex += (addr - mtrr_seg->start) >> mtrr_seg->range_shift;\n\treturn index;\n}",
    "includes": [
      "#include \"mmu.h\"",
      "#include \"cpuid.h\"",
      "#include <asm/mtrr.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct fixed_mtrr_segment fixed_seg_table[] = {\n\t/* MSR_MTRRfix64K_00000, 1 unit. 64K fixed mtrr. */\n\t{\n\t\t.start = 0x0,\n\t\t.end = 0x80000,\n\t\t.range_shift = 16, /* 64K */\n\t\t.range_start = 0,\n\t},\n\n\t/*\n\t * MSR_MTRRfix16K_80000 ... MSR_MTRRfix16K_A0000, 2 units,\n\t * 16K fixed mtrr.\n\t */\n\t{\n\t\t.start = 0x80000,\n\t\t.end = 0xc0000,\n\t\t.range_shift = 14, /* 16K */\n\t\t.range_start = 8,\n\t},\n\n\t/*\n\t * MSR_MTRRfix4K_C0000 ... MSR_MTRRfix4K_F8000, 8 units,\n\t * 4K fixed mtrr.\n\t */\n\t{\n\t\t.start = 0xc0000,\n\t\t.end = 0x100000,\n\t\t.range_shift = 12, /* 12K */\n\t\t.range_start = 24,\n\t}\n};"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"mmu.h\"\n#include \"cpuid.h\"\n#include <asm/mtrr.h>\n#include <linux/kvm_host.h>\n\nstatic struct fixed_mtrr_segment fixed_seg_table[] = {\n\t/* MSR_MTRRfix64K_00000, 1 unit. 64K fixed mtrr. */\n\t{\n\t\t.start = 0x0,\n\t\t.end = 0x80000,\n\t\t.range_shift = 16, /* 64K */\n\t\t.range_start = 0,\n\t},\n\n\t/*\n\t * MSR_MTRRfix16K_80000 ... MSR_MTRRfix16K_A0000, 2 units,\n\t * 16K fixed mtrr.\n\t */\n\t{\n\t\t.start = 0x80000,\n\t\t.end = 0xc0000,\n\t\t.range_shift = 14, /* 16K */\n\t\t.range_start = 8,\n\t},\n\n\t/*\n\t * MSR_MTRRfix4K_C0000 ... MSR_MTRRfix4K_F8000, 8 units,\n\t * 4K fixed mtrr.\n\t */\n\t{\n\t\t.start = 0xc0000,\n\t\t.end = 0x100000,\n\t\t.range_shift = 12, /* 12K */\n\t\t.range_start = 24,\n\t}\n};\n\nstatic int fixed_mtrr_addr_seg_to_range_index(u64 addr, int seg)\n{\n\tstruct fixed_mtrr_segment *mtrr_seg;\n\tint index;\n\n\tmtrr_seg = &fixed_seg_table[seg];\n\tindex = mtrr_seg->range_start;\n\tindex += (addr - mtrr_seg->start) >> mtrr_seg->range_shift;\n\treturn index;\n}"
  },
  {
    "function_name": "fixed_mtrr_addr_to_seg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mtrr.c",
    "lines": "271-283",
    "snippet": "static int fixed_mtrr_addr_to_seg(u64 addr)\n{\n\tstruct fixed_mtrr_segment *mtrr_seg;\n\tint seg, seg_num = ARRAY_SIZE(fixed_seg_table);\n\n\tfor (seg = 0; seg < seg_num; seg++) {\n\t\tmtrr_seg = &fixed_seg_table[seg];\n\t\tif (mtrr_seg->start <= addr && addr < mtrr_seg->end)\n\t\t\treturn seg;\n\t}\n\n\treturn -1;\n}",
    "includes": [
      "#include \"mmu.h\"",
      "#include \"cpuid.h\"",
      "#include <asm/mtrr.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct fixed_mtrr_segment fixed_seg_table[] = {\n\t/* MSR_MTRRfix64K_00000, 1 unit. 64K fixed mtrr. */\n\t{\n\t\t.start = 0x0,\n\t\t.end = 0x80000,\n\t\t.range_shift = 16, /* 64K */\n\t\t.range_start = 0,\n\t},\n\n\t/*\n\t * MSR_MTRRfix16K_80000 ... MSR_MTRRfix16K_A0000, 2 units,\n\t * 16K fixed mtrr.\n\t */\n\t{\n\t\t.start = 0x80000,\n\t\t.end = 0xc0000,\n\t\t.range_shift = 14, /* 16K */\n\t\t.range_start = 8,\n\t},\n\n\t/*\n\t * MSR_MTRRfix4K_C0000 ... MSR_MTRRfix4K_F8000, 8 units,\n\t * 4K fixed mtrr.\n\t */\n\t{\n\t\t.start = 0xc0000,\n\t\t.end = 0x100000,\n\t\t.range_shift = 12, /* 12K */\n\t\t.range_start = 24,\n\t}\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "fixed_seg_table"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"mmu.h\"\n#include \"cpuid.h\"\n#include <asm/mtrr.h>\n#include <linux/kvm_host.h>\n\nstatic struct fixed_mtrr_segment fixed_seg_table[] = {\n\t/* MSR_MTRRfix64K_00000, 1 unit. 64K fixed mtrr. */\n\t{\n\t\t.start = 0x0,\n\t\t.end = 0x80000,\n\t\t.range_shift = 16, /* 64K */\n\t\t.range_start = 0,\n\t},\n\n\t/*\n\t * MSR_MTRRfix16K_80000 ... MSR_MTRRfix16K_A0000, 2 units,\n\t * 16K fixed mtrr.\n\t */\n\t{\n\t\t.start = 0x80000,\n\t\t.end = 0xc0000,\n\t\t.range_shift = 14, /* 16K */\n\t\t.range_start = 8,\n\t},\n\n\t/*\n\t * MSR_MTRRfix4K_C0000 ... MSR_MTRRfix4K_F8000, 8 units,\n\t * 4K fixed mtrr.\n\t */\n\t{\n\t\t.start = 0xc0000,\n\t\t.end = 0x100000,\n\t\t.range_shift = 12, /* 12K */\n\t\t.range_start = 24,\n\t}\n};\n\nstatic int fixed_mtrr_addr_to_seg(u64 addr)\n{\n\tstruct fixed_mtrr_segment *mtrr_seg;\n\tint seg, seg_num = ARRAY_SIZE(fixed_seg_table);\n\n\tfor (seg = 0; seg < seg_num; seg++) {\n\t\tmtrr_seg = &fixed_seg_table[seg];\n\t\tif (mtrr_seg->start <= addr && addr < mtrr_seg->end)\n\t\t\treturn seg;\n\t}\n\n\treturn -1;\n}"
  },
  {
    "function_name": "fixed_msr_to_range_index",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mtrr.c",
    "lines": "261-269",
    "snippet": "static int fixed_msr_to_range_index(u32 msr)\n{\n\tint seg, unit;\n\n\tif (!fixed_msr_to_seg_unit(msr, &seg, &unit))\n\t\treturn -1;\n\n\treturn fixed_mtrr_seg_unit_range_index(seg, unit);\n}",
    "includes": [
      "#include \"mmu.h\"",
      "#include \"cpuid.h\"",
      "#include <asm/mtrr.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fixed_mtrr_seg_unit_range_index",
          "args": [
            "seg",
            "unit"
          ],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "fixed_mtrr_seg_unit_range_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mtrr.c",
          "lines": "230-239",
          "snippet": "static int fixed_mtrr_seg_unit_range_index(int seg, int unit)\n{\n\tstruct fixed_mtrr_segment *mtrr_seg = &fixed_seg_table[seg];\n\n\tWARN_ON(mtrr_seg->start + unit * fixed_mtrr_seg_unit_size(seg)\n\t\t> mtrr_seg->end);\n\n\t/* each unit has 8 ranges. */\n\treturn mtrr_seg->range_start + 8 * unit;\n}",
          "includes": [
            "#include \"mmu.h\"",
            "#include \"cpuid.h\"",
            "#include <asm/mtrr.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct fixed_mtrr_segment fixed_seg_table[] = {\n\t/* MSR_MTRRfix64K_00000, 1 unit. 64K fixed mtrr. */\n\t{\n\t\t.start = 0x0,\n\t\t.end = 0x80000,\n\t\t.range_shift = 16, /* 64K */\n\t\t.range_start = 0,\n\t},\n\n\t/*\n\t * MSR_MTRRfix16K_80000 ... MSR_MTRRfix16K_A0000, 2 units,\n\t * 16K fixed mtrr.\n\t */\n\t{\n\t\t.start = 0x80000,\n\t\t.end = 0xc0000,\n\t\t.range_shift = 14, /* 16K */\n\t\t.range_start = 8,\n\t},\n\n\t/*\n\t * MSR_MTRRfix4K_C0000 ... MSR_MTRRfix4K_F8000, 8 units,\n\t * 4K fixed mtrr.\n\t */\n\t{\n\t\t.start = 0xc0000,\n\t\t.end = 0x100000,\n\t\t.range_shift = 12, /* 12K */\n\t\t.range_start = 24,\n\t}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"mmu.h\"\n#include \"cpuid.h\"\n#include <asm/mtrr.h>\n#include <linux/kvm_host.h>\n\nstatic struct fixed_mtrr_segment fixed_seg_table[] = {\n\t/* MSR_MTRRfix64K_00000, 1 unit. 64K fixed mtrr. */\n\t{\n\t\t.start = 0x0,\n\t\t.end = 0x80000,\n\t\t.range_shift = 16, /* 64K */\n\t\t.range_start = 0,\n\t},\n\n\t/*\n\t * MSR_MTRRfix16K_80000 ... MSR_MTRRfix16K_A0000, 2 units,\n\t * 16K fixed mtrr.\n\t */\n\t{\n\t\t.start = 0x80000,\n\t\t.end = 0xc0000,\n\t\t.range_shift = 14, /* 16K */\n\t\t.range_start = 8,\n\t},\n\n\t/*\n\t * MSR_MTRRfix4K_C0000 ... MSR_MTRRfix4K_F8000, 8 units,\n\t * 4K fixed mtrr.\n\t */\n\t{\n\t\t.start = 0xc0000,\n\t\t.end = 0x100000,\n\t\t.range_shift = 12, /* 12K */\n\t\t.range_start = 24,\n\t}\n};\n\nstatic int fixed_mtrr_seg_unit_range_index(int seg, int unit)\n{\n\tstruct fixed_mtrr_segment *mtrr_seg = &fixed_seg_table[seg];\n\n\tWARN_ON(mtrr_seg->start + unit * fixed_mtrr_seg_unit_size(seg)\n\t\t> mtrr_seg->end);\n\n\t/* each unit has 8 ranges. */\n\treturn mtrr_seg->range_start + 8 * unit;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fixed_msr_to_seg_unit",
          "args": [
            "msr",
            "&seg",
            "&unit"
          ],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "fixed_msr_to_seg_unit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mtrr.c",
          "lines": "198-218",
          "snippet": "static bool fixed_msr_to_seg_unit(u32 msr, int *seg, int *unit)\n{\n\tswitch (msr) {\n\tcase MSR_MTRRfix64K_00000:\n\t\t*seg = 0;\n\t\t*unit = 0;\n\t\tbreak;\n\tcase MSR_MTRRfix16K_80000 ... MSR_MTRRfix16K_A0000:\n\t\t*seg = 1;\n\t\t*unit = msr - MSR_MTRRfix16K_80000;\n\t\tbreak;\n\tcase MSR_MTRRfix4K_C0000 ... MSR_MTRRfix4K_F8000:\n\t\t*seg = 2;\n\t\t*unit = msr - MSR_MTRRfix4K_C0000;\n\t\tbreak;\n\tdefault:\n\t\treturn false;\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include \"mmu.h\"",
            "#include \"cpuid.h\"",
            "#include <asm/mtrr.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mmu.h\"\n#include \"cpuid.h\"\n#include <asm/mtrr.h>\n#include <linux/kvm_host.h>\n\nstatic bool fixed_msr_to_seg_unit(u32 msr, int *seg, int *unit)\n{\n\tswitch (msr) {\n\tcase MSR_MTRRfix64K_00000:\n\t\t*seg = 0;\n\t\t*unit = 0;\n\t\tbreak;\n\tcase MSR_MTRRfix16K_80000 ... MSR_MTRRfix16K_A0000:\n\t\t*seg = 1;\n\t\t*unit = msr - MSR_MTRRfix16K_80000;\n\t\tbreak;\n\tcase MSR_MTRRfix4K_C0000 ... MSR_MTRRfix4K_F8000:\n\t\t*seg = 2;\n\t\t*unit = msr - MSR_MTRRfix4K_C0000;\n\t\tbreak;\n\tdefault:\n\t\treturn false;\n\t}\n\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"mmu.h\"\n#include \"cpuid.h\"\n#include <asm/mtrr.h>\n#include <linux/kvm_host.h>\n\nstatic int fixed_msr_to_range_index(u32 msr)\n{\n\tint seg, unit;\n\n\tif (!fixed_msr_to_seg_unit(msr, &seg, &unit))\n\t\treturn -1;\n\n\treturn fixed_mtrr_seg_unit_range_index(seg, unit);\n}"
  },
  {
    "function_name": "fixed_msr_to_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mtrr.c",
    "lines": "250-259",
    "snippet": "static bool fixed_msr_to_range(u32 msr, u64 *start, u64 *end)\n{\n\tint seg, unit;\n\n\tif (!fixed_msr_to_seg_unit(msr, &seg, &unit))\n\t\treturn false;\n\n\tfixed_mtrr_seg_unit_range(seg, unit, start, end);\n\treturn true;\n}",
    "includes": [
      "#include \"mmu.h\"",
      "#include \"cpuid.h\"",
      "#include <asm/mtrr.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fixed_mtrr_seg_unit_range",
          "args": [
            "seg",
            "unit",
            "start",
            "end"
          ],
          "line": 257
        },
        "resolved": true,
        "details": {
          "function_name": "fixed_mtrr_seg_unit_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mtrr.c",
          "lines": "220-228",
          "snippet": "static void fixed_mtrr_seg_unit_range(int seg, int unit, u64 *start, u64 *end)\n{\n\tstruct fixed_mtrr_segment *mtrr_seg = &fixed_seg_table[seg];\n\tu64 unit_size = fixed_mtrr_seg_unit_size(seg);\n\n\t*start = mtrr_seg->start + unit * unit_size;\n\t*end = *start + unit_size;\n\tWARN_ON(*end > mtrr_seg->end);\n}",
          "includes": [
            "#include \"mmu.h\"",
            "#include \"cpuid.h\"",
            "#include <asm/mtrr.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct fixed_mtrr_segment fixed_seg_table[] = {\n\t/* MSR_MTRRfix64K_00000, 1 unit. 64K fixed mtrr. */\n\t{\n\t\t.start = 0x0,\n\t\t.end = 0x80000,\n\t\t.range_shift = 16, /* 64K */\n\t\t.range_start = 0,\n\t},\n\n\t/*\n\t * MSR_MTRRfix16K_80000 ... MSR_MTRRfix16K_A0000, 2 units,\n\t * 16K fixed mtrr.\n\t */\n\t{\n\t\t.start = 0x80000,\n\t\t.end = 0xc0000,\n\t\t.range_shift = 14, /* 16K */\n\t\t.range_start = 8,\n\t},\n\n\t/*\n\t * MSR_MTRRfix4K_C0000 ... MSR_MTRRfix4K_F8000, 8 units,\n\t * 4K fixed mtrr.\n\t */\n\t{\n\t\t.start = 0xc0000,\n\t\t.end = 0x100000,\n\t\t.range_shift = 12, /* 12K */\n\t\t.range_start = 24,\n\t}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"mmu.h\"\n#include \"cpuid.h\"\n#include <asm/mtrr.h>\n#include <linux/kvm_host.h>\n\nstatic struct fixed_mtrr_segment fixed_seg_table[] = {\n\t/* MSR_MTRRfix64K_00000, 1 unit. 64K fixed mtrr. */\n\t{\n\t\t.start = 0x0,\n\t\t.end = 0x80000,\n\t\t.range_shift = 16, /* 64K */\n\t\t.range_start = 0,\n\t},\n\n\t/*\n\t * MSR_MTRRfix16K_80000 ... MSR_MTRRfix16K_A0000, 2 units,\n\t * 16K fixed mtrr.\n\t */\n\t{\n\t\t.start = 0x80000,\n\t\t.end = 0xc0000,\n\t\t.range_shift = 14, /* 16K */\n\t\t.range_start = 8,\n\t},\n\n\t/*\n\t * MSR_MTRRfix4K_C0000 ... MSR_MTRRfix4K_F8000, 8 units,\n\t * 4K fixed mtrr.\n\t */\n\t{\n\t\t.start = 0xc0000,\n\t\t.end = 0x100000,\n\t\t.range_shift = 12, /* 12K */\n\t\t.range_start = 24,\n\t}\n};\n\nstatic void fixed_mtrr_seg_unit_range(int seg, int unit, u64 *start, u64 *end)\n{\n\tstruct fixed_mtrr_segment *mtrr_seg = &fixed_seg_table[seg];\n\tu64 unit_size = fixed_mtrr_seg_unit_size(seg);\n\n\t*start = mtrr_seg->start + unit * unit_size;\n\t*end = *start + unit_size;\n\tWARN_ON(*end > mtrr_seg->end);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fixed_msr_to_seg_unit",
          "args": [
            "msr",
            "&seg",
            "&unit"
          ],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "fixed_msr_to_seg_unit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mtrr.c",
          "lines": "198-218",
          "snippet": "static bool fixed_msr_to_seg_unit(u32 msr, int *seg, int *unit)\n{\n\tswitch (msr) {\n\tcase MSR_MTRRfix64K_00000:\n\t\t*seg = 0;\n\t\t*unit = 0;\n\t\tbreak;\n\tcase MSR_MTRRfix16K_80000 ... MSR_MTRRfix16K_A0000:\n\t\t*seg = 1;\n\t\t*unit = msr - MSR_MTRRfix16K_80000;\n\t\tbreak;\n\tcase MSR_MTRRfix4K_C0000 ... MSR_MTRRfix4K_F8000:\n\t\t*seg = 2;\n\t\t*unit = msr - MSR_MTRRfix4K_C0000;\n\t\tbreak;\n\tdefault:\n\t\treturn false;\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include \"mmu.h\"",
            "#include \"cpuid.h\"",
            "#include <asm/mtrr.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mmu.h\"\n#include \"cpuid.h\"\n#include <asm/mtrr.h>\n#include <linux/kvm_host.h>\n\nstatic bool fixed_msr_to_seg_unit(u32 msr, int *seg, int *unit)\n{\n\tswitch (msr) {\n\tcase MSR_MTRRfix64K_00000:\n\t\t*seg = 0;\n\t\t*unit = 0;\n\t\tbreak;\n\tcase MSR_MTRRfix16K_80000 ... MSR_MTRRfix16K_A0000:\n\t\t*seg = 1;\n\t\t*unit = msr - MSR_MTRRfix16K_80000;\n\t\tbreak;\n\tcase MSR_MTRRfix4K_C0000 ... MSR_MTRRfix4K_F8000:\n\t\t*seg = 2;\n\t\t*unit = msr - MSR_MTRRfix4K_C0000;\n\t\tbreak;\n\tdefault:\n\t\treturn false;\n\t}\n\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"mmu.h\"\n#include \"cpuid.h\"\n#include <asm/mtrr.h>\n#include <linux/kvm_host.h>\n\nstatic bool fixed_msr_to_range(u32 msr, u64 *start, u64 *end)\n{\n\tint seg, unit;\n\n\tif (!fixed_msr_to_seg_unit(msr, &seg, &unit))\n\t\treturn false;\n\n\tfixed_mtrr_seg_unit_range(seg, unit, start, end);\n\treturn true;\n}"
  },
  {
    "function_name": "fixed_mtrr_seg_end_range_index",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mtrr.c",
    "lines": "241-248",
    "snippet": "static int fixed_mtrr_seg_end_range_index(int seg)\n{\n\tstruct fixed_mtrr_segment *mtrr_seg = &fixed_seg_table[seg];\n\tint n;\n\n\tn = (mtrr_seg->end - mtrr_seg->start) >> mtrr_seg->range_shift;\n\treturn mtrr_seg->range_start + n - 1;\n}",
    "includes": [
      "#include \"mmu.h\"",
      "#include \"cpuid.h\"",
      "#include <asm/mtrr.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct fixed_mtrr_segment fixed_seg_table[] = {\n\t/* MSR_MTRRfix64K_00000, 1 unit. 64K fixed mtrr. */\n\t{\n\t\t.start = 0x0,\n\t\t.end = 0x80000,\n\t\t.range_shift = 16, /* 64K */\n\t\t.range_start = 0,\n\t},\n\n\t/*\n\t * MSR_MTRRfix16K_80000 ... MSR_MTRRfix16K_A0000, 2 units,\n\t * 16K fixed mtrr.\n\t */\n\t{\n\t\t.start = 0x80000,\n\t\t.end = 0xc0000,\n\t\t.range_shift = 14, /* 16K */\n\t\t.range_start = 8,\n\t},\n\n\t/*\n\t * MSR_MTRRfix4K_C0000 ... MSR_MTRRfix4K_F8000, 8 units,\n\t * 4K fixed mtrr.\n\t */\n\t{\n\t\t.start = 0xc0000,\n\t\t.end = 0x100000,\n\t\t.range_shift = 12, /* 12K */\n\t\t.range_start = 24,\n\t}\n};"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"mmu.h\"\n#include \"cpuid.h\"\n#include <asm/mtrr.h>\n#include <linux/kvm_host.h>\n\nstatic struct fixed_mtrr_segment fixed_seg_table[] = {\n\t/* MSR_MTRRfix64K_00000, 1 unit. 64K fixed mtrr. */\n\t{\n\t\t.start = 0x0,\n\t\t.end = 0x80000,\n\t\t.range_shift = 16, /* 64K */\n\t\t.range_start = 0,\n\t},\n\n\t/*\n\t * MSR_MTRRfix16K_80000 ... MSR_MTRRfix16K_A0000, 2 units,\n\t * 16K fixed mtrr.\n\t */\n\t{\n\t\t.start = 0x80000,\n\t\t.end = 0xc0000,\n\t\t.range_shift = 14, /* 16K */\n\t\t.range_start = 8,\n\t},\n\n\t/*\n\t * MSR_MTRRfix4K_C0000 ... MSR_MTRRfix4K_F8000, 8 units,\n\t * 4K fixed mtrr.\n\t */\n\t{\n\t\t.start = 0xc0000,\n\t\t.end = 0x100000,\n\t\t.range_shift = 12, /* 12K */\n\t\t.range_start = 24,\n\t}\n};\n\nstatic int fixed_mtrr_seg_end_range_index(int seg)\n{\n\tstruct fixed_mtrr_segment *mtrr_seg = &fixed_seg_table[seg];\n\tint n;\n\n\tn = (mtrr_seg->end - mtrr_seg->start) >> mtrr_seg->range_shift;\n\treturn mtrr_seg->range_start + n - 1;\n}"
  },
  {
    "function_name": "fixed_mtrr_seg_unit_range_index",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mtrr.c",
    "lines": "230-239",
    "snippet": "static int fixed_mtrr_seg_unit_range_index(int seg, int unit)\n{\n\tstruct fixed_mtrr_segment *mtrr_seg = &fixed_seg_table[seg];\n\n\tWARN_ON(mtrr_seg->start + unit * fixed_mtrr_seg_unit_size(seg)\n\t\t> mtrr_seg->end);\n\n\t/* each unit has 8 ranges. */\n\treturn mtrr_seg->range_start + 8 * unit;\n}",
    "includes": [
      "#include \"mmu.h\"",
      "#include \"cpuid.h\"",
      "#include <asm/mtrr.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct fixed_mtrr_segment fixed_seg_table[] = {\n\t/* MSR_MTRRfix64K_00000, 1 unit. 64K fixed mtrr. */\n\t{\n\t\t.start = 0x0,\n\t\t.end = 0x80000,\n\t\t.range_shift = 16, /* 64K */\n\t\t.range_start = 0,\n\t},\n\n\t/*\n\t * MSR_MTRRfix16K_80000 ... MSR_MTRRfix16K_A0000, 2 units,\n\t * 16K fixed mtrr.\n\t */\n\t{\n\t\t.start = 0x80000,\n\t\t.end = 0xc0000,\n\t\t.range_shift = 14, /* 16K */\n\t\t.range_start = 8,\n\t},\n\n\t/*\n\t * MSR_MTRRfix4K_C0000 ... MSR_MTRRfix4K_F8000, 8 units,\n\t * 4K fixed mtrr.\n\t */\n\t{\n\t\t.start = 0xc0000,\n\t\t.end = 0x100000,\n\t\t.range_shift = 12, /* 12K */\n\t\t.range_start = 24,\n\t}\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "mtrr_seg->start + unit * fixed_mtrr_seg_unit_size(seg)\n\t\t> mtrr_seg->end"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fixed_mtrr_seg_unit_size",
          "args": [
            "seg"
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "fixed_mtrr_seg_unit_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mtrr.c",
          "lines": "193-196",
          "snippet": "static u64 fixed_mtrr_seg_unit_size(int seg)\n{\n\treturn 8 << fixed_seg_table[seg].range_shift;\n}",
          "includes": [
            "#include \"mmu.h\"",
            "#include \"cpuid.h\"",
            "#include <asm/mtrr.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct fixed_mtrr_segment fixed_seg_table[] = {\n\t/* MSR_MTRRfix64K_00000, 1 unit. 64K fixed mtrr. */\n\t{\n\t\t.start = 0x0,\n\t\t.end = 0x80000,\n\t\t.range_shift = 16, /* 64K */\n\t\t.range_start = 0,\n\t},\n\n\t/*\n\t * MSR_MTRRfix16K_80000 ... MSR_MTRRfix16K_A0000, 2 units,\n\t * 16K fixed mtrr.\n\t */\n\t{\n\t\t.start = 0x80000,\n\t\t.end = 0xc0000,\n\t\t.range_shift = 14, /* 16K */\n\t\t.range_start = 8,\n\t},\n\n\t/*\n\t * MSR_MTRRfix4K_C0000 ... MSR_MTRRfix4K_F8000, 8 units,\n\t * 4K fixed mtrr.\n\t */\n\t{\n\t\t.start = 0xc0000,\n\t\t.end = 0x100000,\n\t\t.range_shift = 12, /* 12K */\n\t\t.range_start = 24,\n\t}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"mmu.h\"\n#include \"cpuid.h\"\n#include <asm/mtrr.h>\n#include <linux/kvm_host.h>\n\nstatic struct fixed_mtrr_segment fixed_seg_table[] = {\n\t/* MSR_MTRRfix64K_00000, 1 unit. 64K fixed mtrr. */\n\t{\n\t\t.start = 0x0,\n\t\t.end = 0x80000,\n\t\t.range_shift = 16, /* 64K */\n\t\t.range_start = 0,\n\t},\n\n\t/*\n\t * MSR_MTRRfix16K_80000 ... MSR_MTRRfix16K_A0000, 2 units,\n\t * 16K fixed mtrr.\n\t */\n\t{\n\t\t.start = 0x80000,\n\t\t.end = 0xc0000,\n\t\t.range_shift = 14, /* 16K */\n\t\t.range_start = 8,\n\t},\n\n\t/*\n\t * MSR_MTRRfix4K_C0000 ... MSR_MTRRfix4K_F8000, 8 units,\n\t * 4K fixed mtrr.\n\t */\n\t{\n\t\t.start = 0xc0000,\n\t\t.end = 0x100000,\n\t\t.range_shift = 12, /* 12K */\n\t\t.range_start = 24,\n\t}\n};\n\nstatic u64 fixed_mtrr_seg_unit_size(int seg)\n{\n\treturn 8 << fixed_seg_table[seg].range_shift;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"mmu.h\"\n#include \"cpuid.h\"\n#include <asm/mtrr.h>\n#include <linux/kvm_host.h>\n\nstatic struct fixed_mtrr_segment fixed_seg_table[] = {\n\t/* MSR_MTRRfix64K_00000, 1 unit. 64K fixed mtrr. */\n\t{\n\t\t.start = 0x0,\n\t\t.end = 0x80000,\n\t\t.range_shift = 16, /* 64K */\n\t\t.range_start = 0,\n\t},\n\n\t/*\n\t * MSR_MTRRfix16K_80000 ... MSR_MTRRfix16K_A0000, 2 units,\n\t * 16K fixed mtrr.\n\t */\n\t{\n\t\t.start = 0x80000,\n\t\t.end = 0xc0000,\n\t\t.range_shift = 14, /* 16K */\n\t\t.range_start = 8,\n\t},\n\n\t/*\n\t * MSR_MTRRfix4K_C0000 ... MSR_MTRRfix4K_F8000, 8 units,\n\t * 4K fixed mtrr.\n\t */\n\t{\n\t\t.start = 0xc0000,\n\t\t.end = 0x100000,\n\t\t.range_shift = 12, /* 12K */\n\t\t.range_start = 24,\n\t}\n};\n\nstatic int fixed_mtrr_seg_unit_range_index(int seg, int unit)\n{\n\tstruct fixed_mtrr_segment *mtrr_seg = &fixed_seg_table[seg];\n\n\tWARN_ON(mtrr_seg->start + unit * fixed_mtrr_seg_unit_size(seg)\n\t\t> mtrr_seg->end);\n\n\t/* each unit has 8 ranges. */\n\treturn mtrr_seg->range_start + 8 * unit;\n}"
  },
  {
    "function_name": "fixed_mtrr_seg_unit_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mtrr.c",
    "lines": "220-228",
    "snippet": "static void fixed_mtrr_seg_unit_range(int seg, int unit, u64 *start, u64 *end)\n{\n\tstruct fixed_mtrr_segment *mtrr_seg = &fixed_seg_table[seg];\n\tu64 unit_size = fixed_mtrr_seg_unit_size(seg);\n\n\t*start = mtrr_seg->start + unit * unit_size;\n\t*end = *start + unit_size;\n\tWARN_ON(*end > mtrr_seg->end);\n}",
    "includes": [
      "#include \"mmu.h\"",
      "#include \"cpuid.h\"",
      "#include <asm/mtrr.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct fixed_mtrr_segment fixed_seg_table[] = {\n\t/* MSR_MTRRfix64K_00000, 1 unit. 64K fixed mtrr. */\n\t{\n\t\t.start = 0x0,\n\t\t.end = 0x80000,\n\t\t.range_shift = 16, /* 64K */\n\t\t.range_start = 0,\n\t},\n\n\t/*\n\t * MSR_MTRRfix16K_80000 ... MSR_MTRRfix16K_A0000, 2 units,\n\t * 16K fixed mtrr.\n\t */\n\t{\n\t\t.start = 0x80000,\n\t\t.end = 0xc0000,\n\t\t.range_shift = 14, /* 16K */\n\t\t.range_start = 8,\n\t},\n\n\t/*\n\t * MSR_MTRRfix4K_C0000 ... MSR_MTRRfix4K_F8000, 8 units,\n\t * 4K fixed mtrr.\n\t */\n\t{\n\t\t.start = 0xc0000,\n\t\t.end = 0x100000,\n\t\t.range_shift = 12, /* 12K */\n\t\t.range_start = 24,\n\t}\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "*end > mtrr_seg->end"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fixed_mtrr_seg_unit_size",
          "args": [
            "seg"
          ],
          "line": 223
        },
        "resolved": true,
        "details": {
          "function_name": "fixed_mtrr_seg_unit_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mtrr.c",
          "lines": "193-196",
          "snippet": "static u64 fixed_mtrr_seg_unit_size(int seg)\n{\n\treturn 8 << fixed_seg_table[seg].range_shift;\n}",
          "includes": [
            "#include \"mmu.h\"",
            "#include \"cpuid.h\"",
            "#include <asm/mtrr.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct fixed_mtrr_segment fixed_seg_table[] = {\n\t/* MSR_MTRRfix64K_00000, 1 unit. 64K fixed mtrr. */\n\t{\n\t\t.start = 0x0,\n\t\t.end = 0x80000,\n\t\t.range_shift = 16, /* 64K */\n\t\t.range_start = 0,\n\t},\n\n\t/*\n\t * MSR_MTRRfix16K_80000 ... MSR_MTRRfix16K_A0000, 2 units,\n\t * 16K fixed mtrr.\n\t */\n\t{\n\t\t.start = 0x80000,\n\t\t.end = 0xc0000,\n\t\t.range_shift = 14, /* 16K */\n\t\t.range_start = 8,\n\t},\n\n\t/*\n\t * MSR_MTRRfix4K_C0000 ... MSR_MTRRfix4K_F8000, 8 units,\n\t * 4K fixed mtrr.\n\t */\n\t{\n\t\t.start = 0xc0000,\n\t\t.end = 0x100000,\n\t\t.range_shift = 12, /* 12K */\n\t\t.range_start = 24,\n\t}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"mmu.h\"\n#include \"cpuid.h\"\n#include <asm/mtrr.h>\n#include <linux/kvm_host.h>\n\nstatic struct fixed_mtrr_segment fixed_seg_table[] = {\n\t/* MSR_MTRRfix64K_00000, 1 unit. 64K fixed mtrr. */\n\t{\n\t\t.start = 0x0,\n\t\t.end = 0x80000,\n\t\t.range_shift = 16, /* 64K */\n\t\t.range_start = 0,\n\t},\n\n\t/*\n\t * MSR_MTRRfix16K_80000 ... MSR_MTRRfix16K_A0000, 2 units,\n\t * 16K fixed mtrr.\n\t */\n\t{\n\t\t.start = 0x80000,\n\t\t.end = 0xc0000,\n\t\t.range_shift = 14, /* 16K */\n\t\t.range_start = 8,\n\t},\n\n\t/*\n\t * MSR_MTRRfix4K_C0000 ... MSR_MTRRfix4K_F8000, 8 units,\n\t * 4K fixed mtrr.\n\t */\n\t{\n\t\t.start = 0xc0000,\n\t\t.end = 0x100000,\n\t\t.range_shift = 12, /* 12K */\n\t\t.range_start = 24,\n\t}\n};\n\nstatic u64 fixed_mtrr_seg_unit_size(int seg)\n{\n\treturn 8 << fixed_seg_table[seg].range_shift;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"mmu.h\"\n#include \"cpuid.h\"\n#include <asm/mtrr.h>\n#include <linux/kvm_host.h>\n\nstatic struct fixed_mtrr_segment fixed_seg_table[] = {\n\t/* MSR_MTRRfix64K_00000, 1 unit. 64K fixed mtrr. */\n\t{\n\t\t.start = 0x0,\n\t\t.end = 0x80000,\n\t\t.range_shift = 16, /* 64K */\n\t\t.range_start = 0,\n\t},\n\n\t/*\n\t * MSR_MTRRfix16K_80000 ... MSR_MTRRfix16K_A0000, 2 units,\n\t * 16K fixed mtrr.\n\t */\n\t{\n\t\t.start = 0x80000,\n\t\t.end = 0xc0000,\n\t\t.range_shift = 14, /* 16K */\n\t\t.range_start = 8,\n\t},\n\n\t/*\n\t * MSR_MTRRfix4K_C0000 ... MSR_MTRRfix4K_F8000, 8 units,\n\t * 4K fixed mtrr.\n\t */\n\t{\n\t\t.start = 0xc0000,\n\t\t.end = 0x100000,\n\t\t.range_shift = 12, /* 12K */\n\t\t.range_start = 24,\n\t}\n};\n\nstatic void fixed_mtrr_seg_unit_range(int seg, int unit, u64 *start, u64 *end)\n{\n\tstruct fixed_mtrr_segment *mtrr_seg = &fixed_seg_table[seg];\n\tu64 unit_size = fixed_mtrr_seg_unit_size(seg);\n\n\t*start = mtrr_seg->start + unit * unit_size;\n\t*end = *start + unit_size;\n\tWARN_ON(*end > mtrr_seg->end);\n}"
  },
  {
    "function_name": "fixed_msr_to_seg_unit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mtrr.c",
    "lines": "198-218",
    "snippet": "static bool fixed_msr_to_seg_unit(u32 msr, int *seg, int *unit)\n{\n\tswitch (msr) {\n\tcase MSR_MTRRfix64K_00000:\n\t\t*seg = 0;\n\t\t*unit = 0;\n\t\tbreak;\n\tcase MSR_MTRRfix16K_80000 ... MSR_MTRRfix16K_A0000:\n\t\t*seg = 1;\n\t\t*unit = msr - MSR_MTRRfix16K_80000;\n\t\tbreak;\n\tcase MSR_MTRRfix4K_C0000 ... MSR_MTRRfix4K_F8000:\n\t\t*seg = 2;\n\t\t*unit = msr - MSR_MTRRfix4K_C0000;\n\t\tbreak;\n\tdefault:\n\t\treturn false;\n\t}\n\n\treturn true;\n}",
    "includes": [
      "#include \"mmu.h\"",
      "#include \"cpuid.h\"",
      "#include <asm/mtrr.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"mmu.h\"\n#include \"cpuid.h\"\n#include <asm/mtrr.h>\n#include <linux/kvm_host.h>\n\nstatic bool fixed_msr_to_seg_unit(u32 msr, int *seg, int *unit)\n{\n\tswitch (msr) {\n\tcase MSR_MTRRfix64K_00000:\n\t\t*seg = 0;\n\t\t*unit = 0;\n\t\tbreak;\n\tcase MSR_MTRRfix16K_80000 ... MSR_MTRRfix16K_A0000:\n\t\t*seg = 1;\n\t\t*unit = msr - MSR_MTRRfix16K_80000;\n\t\tbreak;\n\tcase MSR_MTRRfix4K_C0000 ... MSR_MTRRfix4K_F8000:\n\t\t*seg = 2;\n\t\t*unit = msr - MSR_MTRRfix4K_C0000;\n\t\tbreak;\n\tdefault:\n\t\treturn false;\n\t}\n\n\treturn true;\n}"
  },
  {
    "function_name": "fixed_mtrr_seg_unit_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mtrr.c",
    "lines": "193-196",
    "snippet": "static u64 fixed_mtrr_seg_unit_size(int seg)\n{\n\treturn 8 << fixed_seg_table[seg].range_shift;\n}",
    "includes": [
      "#include \"mmu.h\"",
      "#include \"cpuid.h\"",
      "#include <asm/mtrr.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct fixed_mtrr_segment fixed_seg_table[] = {\n\t/* MSR_MTRRfix64K_00000, 1 unit. 64K fixed mtrr. */\n\t{\n\t\t.start = 0x0,\n\t\t.end = 0x80000,\n\t\t.range_shift = 16, /* 64K */\n\t\t.range_start = 0,\n\t},\n\n\t/*\n\t * MSR_MTRRfix16K_80000 ... MSR_MTRRfix16K_A0000, 2 units,\n\t * 16K fixed mtrr.\n\t */\n\t{\n\t\t.start = 0x80000,\n\t\t.end = 0xc0000,\n\t\t.range_shift = 14, /* 16K */\n\t\t.range_start = 8,\n\t},\n\n\t/*\n\t * MSR_MTRRfix4K_C0000 ... MSR_MTRRfix4K_F8000, 8 units,\n\t * 4K fixed mtrr.\n\t */\n\t{\n\t\t.start = 0xc0000,\n\t\t.end = 0x100000,\n\t\t.range_shift = 12, /* 12K */\n\t\t.range_start = 24,\n\t}\n};"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"mmu.h\"\n#include \"cpuid.h\"\n#include <asm/mtrr.h>\n#include <linux/kvm_host.h>\n\nstatic struct fixed_mtrr_segment fixed_seg_table[] = {\n\t/* MSR_MTRRfix64K_00000, 1 unit. 64K fixed mtrr. */\n\t{\n\t\t.start = 0x0,\n\t\t.end = 0x80000,\n\t\t.range_shift = 16, /* 64K */\n\t\t.range_start = 0,\n\t},\n\n\t/*\n\t * MSR_MTRRfix16K_80000 ... MSR_MTRRfix16K_A0000, 2 units,\n\t * 16K fixed mtrr.\n\t */\n\t{\n\t\t.start = 0x80000,\n\t\t.end = 0xc0000,\n\t\t.range_shift = 14, /* 16K */\n\t\t.range_start = 8,\n\t},\n\n\t/*\n\t * MSR_MTRRfix4K_C0000 ... MSR_MTRRfix4K_F8000, 8 units,\n\t * 4K fixed mtrr.\n\t */\n\t{\n\t\t.start = 0xc0000,\n\t\t.end = 0x100000,\n\t\t.range_shift = 12, /* 12K */\n\t\t.range_start = 24,\n\t}\n};\n\nstatic u64 fixed_mtrr_seg_unit_size(int seg)\n{\n\treturn 8 << fixed_seg_table[seg].range_shift;\n}"
  },
  {
    "function_name": "mtrr_disabled_type",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mtrr.c",
    "lines": "123-139",
    "snippet": "static u8 mtrr_disabled_type(struct kvm_vcpu *vcpu)\n{\n\t/*\n\t * Intel SDM 11.11.2.2: all MTRRs are disabled when\n\t * IA32_MTRR_DEF_TYPE.E bit is cleared, and the UC\n\t * memory type is applied to all of physical memory.\n\t *\n\t * However, virtual machines can be run with CPUID such that\n\t * there are no MTRRs.  In that case, the firmware will never\n\t * enable MTRRs and it is obviously undesirable to run the\n\t * guest entirely with UC memory and we use WB.\n\t */\n\tif (guest_cpuid_has_mtrr(vcpu))\n\t\treturn MTRR_TYPE_UNCACHABLE;\n\telse\n\t\treturn MTRR_TYPE_WRBACK;\n}",
    "includes": [
      "#include \"mmu.h\"",
      "#include \"cpuid.h\"",
      "#include <asm/mtrr.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "guest_cpuid_has_mtrr",
          "args": [
            "vcpu"
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "guest_cpuid_has_mtrr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/cpuid.h",
          "lines": "43-49",
          "snippet": "static inline bool guest_cpuid_has_mtrr(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_cpuid_entry2 *best;\n\n\tbest = kvm_find_cpuid_entry(vcpu, 1, 0);\n\treturn best && (best->edx & bit(X86_FEATURE_MTRR));\n}",
          "includes": [
            "#include <asm/cpu.h>",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpu.h>\n#include \"x86.h\"\n\nstatic inline bool guest_cpuid_has_mtrr(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_cpuid_entry2 *best;\n\n\tbest = kvm_find_cpuid_entry(vcpu, 1, 0);\n\treturn best && (best->edx & bit(X86_FEATURE_MTRR));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"mmu.h\"\n#include \"cpuid.h\"\n#include <asm/mtrr.h>\n#include <linux/kvm_host.h>\n\nstatic u8 mtrr_disabled_type(struct kvm_vcpu *vcpu)\n{\n\t/*\n\t * Intel SDM 11.11.2.2: all MTRRs are disabled when\n\t * IA32_MTRR_DEF_TYPE.E bit is cleared, and the UC\n\t * memory type is applied to all of physical memory.\n\t *\n\t * However, virtual machines can be run with CPUID such that\n\t * there are no MTRRs.  In that case, the firmware will never\n\t * enable MTRRs and it is obviously undesirable to run the\n\t * guest entirely with UC memory and we use WB.\n\t */\n\tif (guest_cpuid_has_mtrr(vcpu))\n\t\treturn MTRR_TYPE_UNCACHABLE;\n\telse\n\t\treturn MTRR_TYPE_WRBACK;\n}"
  },
  {
    "function_name": "mtrr_default_type",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mtrr.c",
    "lines": "118-121",
    "snippet": "static u8 mtrr_default_type(struct kvm_mtrr *mtrr_state)\n{\n\treturn mtrr_state->deftype & IA32_MTRR_DEF_TYPE_TYPE_MASK;\n}",
    "includes": [
      "#include \"mmu.h\"",
      "#include \"cpuid.h\"",
      "#include <asm/mtrr.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define IA32_MTRR_DEF_TYPE_TYPE_MASK\t(0xff)"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"mmu.h\"\n#include \"cpuid.h\"\n#include <asm/mtrr.h>\n#include <linux/kvm_host.h>\n\n#define IA32_MTRR_DEF_TYPE_TYPE_MASK\t(0xff)\n\nstatic u8 mtrr_default_type(struct kvm_mtrr *mtrr_state)\n{\n\treturn mtrr_state->deftype & IA32_MTRR_DEF_TYPE_TYPE_MASK;\n}"
  },
  {
    "function_name": "fixed_mtrr_is_enabled",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mtrr.c",
    "lines": "113-116",
    "snippet": "static bool fixed_mtrr_is_enabled(struct kvm_mtrr *mtrr_state)\n{\n\treturn !!(mtrr_state->deftype & IA32_MTRR_DEF_TYPE_FE);\n}",
    "includes": [
      "#include \"mmu.h\"",
      "#include \"cpuid.h\"",
      "#include <asm/mtrr.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define IA32_MTRR_DEF_TYPE_FE\t\t(1ULL << 10)"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"mmu.h\"\n#include \"cpuid.h\"\n#include <asm/mtrr.h>\n#include <linux/kvm_host.h>\n\n#define IA32_MTRR_DEF_TYPE_FE\t\t(1ULL << 10)\n\nstatic bool fixed_mtrr_is_enabled(struct kvm_mtrr *mtrr_state)\n{\n\treturn !!(mtrr_state->deftype & IA32_MTRR_DEF_TYPE_FE);\n}"
  },
  {
    "function_name": "mtrr_is_enabled",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mtrr.c",
    "lines": "108-111",
    "snippet": "static bool mtrr_is_enabled(struct kvm_mtrr *mtrr_state)\n{\n\treturn !!(mtrr_state->deftype & IA32_MTRR_DEF_TYPE_E);\n}",
    "includes": [
      "#include \"mmu.h\"",
      "#include \"cpuid.h\"",
      "#include <asm/mtrr.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define IA32_MTRR_DEF_TYPE_E\t\t(1ULL << 11)"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"mmu.h\"\n#include \"cpuid.h\"\n#include <asm/mtrr.h>\n#include <linux/kvm_host.h>\n\n#define IA32_MTRR_DEF_TYPE_E\t\t(1ULL << 11)\n\nstatic bool mtrr_is_enabled(struct kvm_mtrr *mtrr_state)\n{\n\treturn !!(mtrr_state->deftype & IA32_MTRR_DEF_TYPE_E);\n}"
  },
  {
    "function_name": "kvm_mtrr_valid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mtrr.c",
    "lines": "63-105",
    "snippet": "bool kvm_mtrr_valid(struct kvm_vcpu *vcpu, u32 msr, u64 data)\n{\n\tint i;\n\tu64 mask;\n\n\tif (!msr_mtrr_valid(msr))\n\t\treturn false;\n\n\tif (msr == MSR_IA32_CR_PAT) {\n\t\tfor (i = 0; i < 8; i++)\n\t\t\tif (!valid_pat_type((data >> (i * 8)) & 0xff))\n\t\t\t\treturn false;\n\t\treturn true;\n\t} else if (msr == MSR_MTRRdefType) {\n\t\tif (data & ~0xcff)\n\t\t\treturn false;\n\t\treturn valid_mtrr_type(data & 0xff);\n\t} else if (msr >= MSR_MTRRfix64K_00000 && msr <= MSR_MTRRfix4K_F8000) {\n\t\tfor (i = 0; i < 8 ; i++)\n\t\t\tif (!valid_mtrr_type((data >> (i * 8)) & 0xff))\n\t\t\t\treturn false;\n\t\treturn true;\n\t}\n\n\t/* variable MTRRs */\n\tWARN_ON(!(msr >= 0x200 && msr < 0x200 + 2 * KVM_NR_VAR_MTRR));\n\n\tmask = (~0ULL) << cpuid_maxphyaddr(vcpu);\n\tif ((msr & 1) == 0) {\n\t\t/* MTRR base */\n\t\tif (!valid_mtrr_type(data & 0xff))\n\t\t\treturn false;\n\t\tmask |= 0xf00;\n\t} else\n\t\t/* MTRR mask */\n\t\tmask |= 0x7ff;\n\tif (data & mask) {\n\t\tkvm_inject_gp(vcpu, 0);\n\t\treturn false;\n\t}\n\n\treturn true;\n}",
    "includes": [
      "#include \"mmu.h\"",
      "#include \"cpuid.h\"",
      "#include <asm/mtrr.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_inject_gp",
          "args": [
            "vcpu",
            "0"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "valid_mtrr_type",
          "args": [
            "data & 0xff"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "valid_mtrr_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mtrr.c",
          "lines": "58-61",
          "snippet": "static bool valid_mtrr_type(unsigned t)\n{\n\treturn t < 8 && (1 << t) & 0x73; /* 0, 1, 4, 5, 6 */\n}",
          "includes": [
            "#include \"mmu.h\"",
            "#include \"cpuid.h\"",
            "#include <asm/mtrr.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mmu.h\"\n#include \"cpuid.h\"\n#include <asm/mtrr.h>\n#include <linux/kvm_host.h>\n\nstatic bool valid_mtrr_type(unsigned t)\n{\n\treturn t < 8 && (1 << t) & 0x73; /* 0, 1, 4, 5, 6 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuid_maxphyaddr",
          "args": [
            "vcpu"
          ],
          "line": 90
        },
        "resolved": true,
        "details": {
          "function_name": "cpuid_maxphyaddr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/cpuid.h",
          "lines": "27-30",
          "snippet": "static inline int cpuid_maxphyaddr(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.maxphyaddr;\n}",
          "includes": [
            "#include <asm/cpu.h>",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpu.h>\n#include \"x86.h\"\n\nstatic inline int cpuid_maxphyaddr(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.maxphyaddr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!(msr >= 0x200 && msr < 0x200 + 2 * KVM_NR_VAR_MTRR)"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "valid_pat_type",
          "args": [
            "(data >> (i * 8)) & 0xff"
          ],
          "line": 73
        },
        "resolved": true,
        "details": {
          "function_name": "valid_pat_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mtrr.c",
          "lines": "53-56",
          "snippet": "static bool valid_pat_type(unsigned t)\n{\n\treturn t < 8 && (1 << t) & 0xf3; /* 0, 1, 4, 5, 6, 7 */\n}",
          "includes": [
            "#include \"mmu.h\"",
            "#include \"cpuid.h\"",
            "#include <asm/mtrr.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mmu.h\"\n#include \"cpuid.h\"\n#include <asm/mtrr.h>\n#include <linux/kvm_host.h>\n\nstatic bool valid_pat_type(unsigned t)\n{\n\treturn t < 8 && (1 << t) & 0xf3; /* 0, 1, 4, 5, 6, 7 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "msr_mtrr_valid",
          "args": [
            "msr"
          ],
          "line": 68
        },
        "resolved": true,
        "details": {
          "function_name": "msr_mtrr_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mtrr.c",
          "lines": "29-51",
          "snippet": "static bool msr_mtrr_valid(unsigned msr)\n{\n\tswitch (msr) {\n\tcase 0x200 ... 0x200 + 2 * KVM_NR_VAR_MTRR - 1:\n\tcase MSR_MTRRfix64K_00000:\n\tcase MSR_MTRRfix16K_80000:\n\tcase MSR_MTRRfix16K_A0000:\n\tcase MSR_MTRRfix4K_C0000:\n\tcase MSR_MTRRfix4K_C8000:\n\tcase MSR_MTRRfix4K_D0000:\n\tcase MSR_MTRRfix4K_D8000:\n\tcase MSR_MTRRfix4K_E0000:\n\tcase MSR_MTRRfix4K_E8000:\n\tcase MSR_MTRRfix4K_F0000:\n\tcase MSR_MTRRfix4K_F8000:\n\tcase MSR_MTRRdefType:\n\tcase MSR_IA32_CR_PAT:\n\t\treturn true;\n\tcase 0x2f8:\n\t\treturn true;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include \"mmu.h\"",
            "#include \"cpuid.h\"",
            "#include <asm/mtrr.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mmu.h\"\n#include \"cpuid.h\"\n#include <asm/mtrr.h>\n#include <linux/kvm_host.h>\n\nstatic bool msr_mtrr_valid(unsigned msr)\n{\n\tswitch (msr) {\n\tcase 0x200 ... 0x200 + 2 * KVM_NR_VAR_MTRR - 1:\n\tcase MSR_MTRRfix64K_00000:\n\tcase MSR_MTRRfix16K_80000:\n\tcase MSR_MTRRfix16K_A0000:\n\tcase MSR_MTRRfix4K_C0000:\n\tcase MSR_MTRRfix4K_C8000:\n\tcase MSR_MTRRfix4K_D0000:\n\tcase MSR_MTRRfix4K_D8000:\n\tcase MSR_MTRRfix4K_E0000:\n\tcase MSR_MTRRfix4K_E8000:\n\tcase MSR_MTRRfix4K_F0000:\n\tcase MSR_MTRRfix4K_F8000:\n\tcase MSR_MTRRdefType:\n\tcase MSR_IA32_CR_PAT:\n\t\treturn true;\n\tcase 0x2f8:\n\t\treturn true;\n\t}\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"mmu.h\"\n#include \"cpuid.h\"\n#include <asm/mtrr.h>\n#include <linux/kvm_host.h>\n\nbool kvm_mtrr_valid(struct kvm_vcpu *vcpu, u32 msr, u64 data)\n{\n\tint i;\n\tu64 mask;\n\n\tif (!msr_mtrr_valid(msr))\n\t\treturn false;\n\n\tif (msr == MSR_IA32_CR_PAT) {\n\t\tfor (i = 0; i < 8; i++)\n\t\t\tif (!valid_pat_type((data >> (i * 8)) & 0xff))\n\t\t\t\treturn false;\n\t\treturn true;\n\t} else if (msr == MSR_MTRRdefType) {\n\t\tif (data & ~0xcff)\n\t\t\treturn false;\n\t\treturn valid_mtrr_type(data & 0xff);\n\t} else if (msr >= MSR_MTRRfix64K_00000 && msr <= MSR_MTRRfix4K_F8000) {\n\t\tfor (i = 0; i < 8 ; i++)\n\t\t\tif (!valid_mtrr_type((data >> (i * 8)) & 0xff))\n\t\t\t\treturn false;\n\t\treturn true;\n\t}\n\n\t/* variable MTRRs */\n\tWARN_ON(!(msr >= 0x200 && msr < 0x200 + 2 * KVM_NR_VAR_MTRR));\n\n\tmask = (~0ULL) << cpuid_maxphyaddr(vcpu);\n\tif ((msr & 1) == 0) {\n\t\t/* MTRR base */\n\t\tif (!valid_mtrr_type(data & 0xff))\n\t\t\treturn false;\n\t\tmask |= 0xf00;\n\t} else\n\t\t/* MTRR mask */\n\t\tmask |= 0x7ff;\n\tif (data & mask) {\n\t\tkvm_inject_gp(vcpu, 0);\n\t\treturn false;\n\t}\n\n\treturn true;\n}"
  },
  {
    "function_name": "valid_mtrr_type",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mtrr.c",
    "lines": "58-61",
    "snippet": "static bool valid_mtrr_type(unsigned t)\n{\n\treturn t < 8 && (1 << t) & 0x73; /* 0, 1, 4, 5, 6 */\n}",
    "includes": [
      "#include \"mmu.h\"",
      "#include \"cpuid.h\"",
      "#include <asm/mtrr.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"mmu.h\"\n#include \"cpuid.h\"\n#include <asm/mtrr.h>\n#include <linux/kvm_host.h>\n\nstatic bool valid_mtrr_type(unsigned t)\n{\n\treturn t < 8 && (1 << t) & 0x73; /* 0, 1, 4, 5, 6 */\n}"
  },
  {
    "function_name": "valid_pat_type",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mtrr.c",
    "lines": "53-56",
    "snippet": "static bool valid_pat_type(unsigned t)\n{\n\treturn t < 8 && (1 << t) & 0xf3; /* 0, 1, 4, 5, 6, 7 */\n}",
    "includes": [
      "#include \"mmu.h\"",
      "#include \"cpuid.h\"",
      "#include <asm/mtrr.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"mmu.h\"\n#include \"cpuid.h\"\n#include <asm/mtrr.h>\n#include <linux/kvm_host.h>\n\nstatic bool valid_pat_type(unsigned t)\n{\n\treturn t < 8 && (1 << t) & 0xf3; /* 0, 1, 4, 5, 6, 7 */\n}"
  },
  {
    "function_name": "msr_mtrr_valid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mtrr.c",
    "lines": "29-51",
    "snippet": "static bool msr_mtrr_valid(unsigned msr)\n{\n\tswitch (msr) {\n\tcase 0x200 ... 0x200 + 2 * KVM_NR_VAR_MTRR - 1:\n\tcase MSR_MTRRfix64K_00000:\n\tcase MSR_MTRRfix16K_80000:\n\tcase MSR_MTRRfix16K_A0000:\n\tcase MSR_MTRRfix4K_C0000:\n\tcase MSR_MTRRfix4K_C8000:\n\tcase MSR_MTRRfix4K_D0000:\n\tcase MSR_MTRRfix4K_D8000:\n\tcase MSR_MTRRfix4K_E0000:\n\tcase MSR_MTRRfix4K_E8000:\n\tcase MSR_MTRRfix4K_F0000:\n\tcase MSR_MTRRfix4K_F8000:\n\tcase MSR_MTRRdefType:\n\tcase MSR_IA32_CR_PAT:\n\t\treturn true;\n\tcase 0x2f8:\n\t\treturn true;\n\t}\n\treturn false;\n}",
    "includes": [
      "#include \"mmu.h\"",
      "#include \"cpuid.h\"",
      "#include <asm/mtrr.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"mmu.h\"\n#include \"cpuid.h\"\n#include <asm/mtrr.h>\n#include <linux/kvm_host.h>\n\nstatic bool msr_mtrr_valid(unsigned msr)\n{\n\tswitch (msr) {\n\tcase 0x200 ... 0x200 + 2 * KVM_NR_VAR_MTRR - 1:\n\tcase MSR_MTRRfix64K_00000:\n\tcase MSR_MTRRfix16K_80000:\n\tcase MSR_MTRRfix16K_A0000:\n\tcase MSR_MTRRfix4K_C0000:\n\tcase MSR_MTRRfix4K_C8000:\n\tcase MSR_MTRRfix4K_D0000:\n\tcase MSR_MTRRfix4K_D8000:\n\tcase MSR_MTRRfix4K_E0000:\n\tcase MSR_MTRRfix4K_E8000:\n\tcase MSR_MTRRfix4K_F0000:\n\tcase MSR_MTRRfix4K_F8000:\n\tcase MSR_MTRRdefType:\n\tcase MSR_IA32_CR_PAT:\n\t\treturn true;\n\tcase 0x2f8:\n\t\treturn true;\n\t}\n\treturn false;\n}"
  }
]