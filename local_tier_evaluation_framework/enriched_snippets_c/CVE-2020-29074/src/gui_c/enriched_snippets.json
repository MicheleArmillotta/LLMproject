[
  {
    "function_name": "do_gui",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/gui.c",
    "lines": "562-935",
    "snippet": "void do_gui(char *opts, int sleep) {\n\tchar *s, *p;\n\tchar *old_xauth = NULL;\n\tchar *gui_xdisplay = NULL;\n\tint got_gui_xdisplay = 0;\n\tint start_x11vnc = 1;\n\tint connect_to_x11vnc = 0;\n\tint simple_gui = 0, none_gui = 0;\n\tint portprompt = 0;\n\tDisplay *test_dpy;\n\n\tif (opts) {\n\t\ts = strdup(opts);\n\t} else {\n\t\ts = strdup(\"\");\n\t}\n\n\tif (use_dpy) {\n\t\t/* worst case */\n\t\tgui_xdisplay = strdup(use_dpy);\n\t\t\n\t}\n\tif (getenv(\"DISPLAY\") != NULL) {\n\t\t/* better */\n\t\tgui_xdisplay = strdup(getenv(\"DISPLAY\"));\n\t}\n\n\tp = strtok(s, \",\");\n\n\twhile(p) {\n\t\tif (*p == '\\0') {\n\t\t\t;\n\t\t} else if (strchr(p, ':') != NULL) {\n\t\t\t/* best */\n\t\t\tif (gui_xdisplay) {\n\t\t\t\tfree(gui_xdisplay);\n\t\t\t}\n\t\t\tgui_xdisplay = strdup(p);\n\t\t\tgot_gui_xdisplay = 1;\n\t\t} else if (!strcmp(p, \"wait\")) {\n\t\t\tstart_x11vnc = 0;\n\t\t\tconnect_to_x11vnc = 0;\n\t\t} else if (!strcmp(p, \"none\")) {\n\t\t\tnone_gui = 1;\n\t\t} else if (!strcmp(p, \"portprompt\")) {\n\t\t\tstart_x11vnc = 0;\n\t\t\tconnect_to_x11vnc = 0;\n\t\t\tportprompt = 1;\n\t\t} else if (!strcmp(p, \"conn\") || !strcmp(p, \"connect\")) {\n\t\t\tstart_x11vnc = 0;\n\t\t\tconnect_to_x11vnc = 1;\n\t\t} else if (!strcmp(p, \"ez\") || !strcmp(p, \"simple\")) {\n\t\t\tsimple_gui = 1;\n\t\t} else if (strstr(p, \"iconfont\") == p) {\n\t\t\tchar *q;\n\t\t\tif ((q = strchr(p, '=')) != NULL) {\n\t\t\t\ticon_mode_font = strdup(q+1);\n\t\t\t}\n\t\t} else if (strstr(p, \"full\") == p) {\n\t\t\tif (strstr(p, \"setp\") && 0) {\n\t\t\t\tset_env(\"X11VNC_ICON_MODE\", \"2\");\n\t\t\t\tset_env(\"X11VNC_ICON_SETPASS\", \"2\");\n\t\t\t}\n\t\t} else if (strstr(p, \"tray\") == p || strstr(p, \"icon\") == p) {\n\t\t\tchar *q;\n\t\t\ticon_mode = 1;\n\t\t\tif ((q = strchr(p, '=')) != NULL) {\n\t\t\t\ticon_mode_params = strdup(q+1);\n\t\t\t\tif (strstr(icon_mode_params, \"setp\")) {\n\t\t\t\t\tdeny_all = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (strstr(p, \"tray\") == p) {\n\t\t\t\ticon_in_tray = 1;\n\t\t\t}\n\t\t} else if (strstr(p, \"geom\") == p) {\n\t\t\tchar *q;\n\t\t\tif ((q = strchr(p, '=')) != NULL) {\n\t\t\t\tgui_geometry = strdup(q+1);\n\t\t\t}\n\t\t} else {\n\t\t\tfprintf(stderr, \"unrecognized gui opt: %s\\n\", p);\n\t\t}\n\t\t\n\t\tp = strtok(NULL, \",\");\n\t}\n\tfree(s);\n\n\tif (none_gui) {\n\t\tif (!start_x11vnc) {\n\t\t\texit(0);\n\t\t}\n\t\treturn;\n\t}\n\tif (start_x11vnc) {\n\t\tconnect_to_x11vnc = 1;\n\t}\n\n\n#ifdef MACOSX\n\tgoto startit;\n#endif\n\n\tif (icon_mode && !got_gui_xdisplay) {\n\t\t/* for tray mode, prefer the polled DISPLAY */\n\t\tif (use_dpy) {\n\t\t\tif (gui_xdisplay) {\n\t\t\t\tfree(gui_xdisplay);\n\t\t\t}\n\t\t\tgui_xdisplay = strdup(use_dpy);\n\t\t}\n\t}\n\n\tif (! gui_xdisplay) {\n\t\tfprintf(stderr, \"error: cannot determine X DISPLAY for gui\"\n\t\t    \" to display on.\\n\");\n\t\texit(1);\n\t}\n\tif (!quiet && !portprompt) {\n\t\tfprintf(stderr, \"starting gui, trying display: %s\\n\",\n\t\t    gui_xdisplay);\n\t}\n\ttest_dpy = XOpenDisplay_wr(gui_xdisplay);\n\tif (! test_dpy && auth_file) {\n\t\tif (getenv(\"XAUTHORITY\") != NULL) {\n\t\t\told_xauth = strdup(getenv(\"XAUTHORITY\"));\n\t\t}\n\t\tset_env(\"XAUTHORITY\", auth_file);\n\t\ttest_dpy = XOpenDisplay_wr(gui_xdisplay);\n\t}\n\tif (! test_dpy) {\n\t\tif (! old_xauth && getenv(\"XAUTHORITY\") != NULL) {\n\t\t\told_xauth = strdup(getenv(\"XAUTHORITY\"));\n\t\t}\n\t\tset_env(\"XAUTHORITY\", \"\");\n\t\ttest_dpy = XOpenDisplay_wr(gui_xdisplay);\n\t}\n\tif (! test_dpy) {\n\t\tfprintf(stderr, \"error: cannot connect to gui X DISPLAY: %s\\n\",\n\t\t    gui_xdisplay);\n\t\texit(1);\n\t}\n\tif (icon_mode && icon_in_tray) {\n\t\tif (tray_manager_running(test_dpy, NULL)) {\n\t\t\ttray_manager_ok = 1;\n\t\t} else {\n\t\t\ttray_manager_ok = 0;\n\t\t}\n\t}\n\tXCloseDisplay_wr(test_dpy);\n\n#ifdef MACOSX\n\tstartit:\n#endif\n\tif (portprompt) {\n\t\tchar *cmd, *p, *p2, *p1, *p0 = getenv(\"PATH\");\n\t\tchar tf1[] = \"/tmp/x11vnc_port_prompt.2XXXXXX\";\n\t\tchar tf2[] = \"/tmp/x11vnc_port_prompt.1XXXXXX\";\n\t\tint fd;\n\t\tchar *dstr = \"\", *wish = NULL;\n\t\tchar line[128];\n\t\tFILE *fp;\n\n\t\tif (no_external_cmds || !cmd_ok(\"gui\")) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (gui_xdisplay) {\n\t\t\tdstr = gui_xdisplay;\n\t\t\tif (strchr(gui_xdisplay, '\\'')) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (!p0) {\n\t\t\tp0 = \"\";\n\t\t}\n\t\tif (strchr(p0, '\\'')) {\n\t\t\treturn;\n\t\t}\n\n\t\tfd = mkstemp(tf2);\n\t\tif (fd < 0) {\n\t\t\treturn;\n\t\t}\n\t\tclose(fd);\n\n\t\tfd = mkstemp(tf1);\n\t\tif (fd < 0) {\n\t\t\tunlink(tf2);\n\t\t\treturn;\n\t\t}\n\n\t\twrite(fd, gui_code, strlen(gui_code));\n\t\tclose(fd);\n\n\t\tp1 = (char *) malloc(10 + strlen(p0) + strlen(extra_path));\n\t\tsprintf(p1, \"%s:%s\", p0, extra_path);\n\t\tp2 = strdup(p1);\n\t\tp = strtok(p2, \":\");\n\n\t\twhile (p) {\n\t\t\tchar *try;\n\t\t\tstruct stat sbuf;\n\t\t\tint i;\n\n\t\t\ttry = (char *) malloc(strlen(p) + 1 + strlen(\"wish8.4\") + 1);\n\t\t\ti = 0;\n\t\t\twhile (wishes[i] != NULL) {\n\t\t\t\tsprintf(try, \"%s/%s\", p, wishes[i]);\n\t\t\t\tif (stat(try, &sbuf) == 0) {\n\t\t\t\t\t/* assume executable, should check mode */\n\t\t\t\t\twish = wishes[i];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tfree(try);\n\t\t\tif (wish) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tp = strtok(NULL, \":\");\n\t\t}\n\t\tfree(p2);\n\n\t\tif (!wish) {\n\t\t\twish = \"wish\";\n\t\t}\n\n\t\tcmd = (char *) malloc(200 + strlen(dstr) + strlen(p1));\n\n\t\tif (!strcmp(dstr, \"\")) {\n\t\t\tsprintf(cmd, \"env PATH='%s' %s %s -name x11vnc_port_prompt -portprompt > %s\", p1, wish, tf1, tf2);\n\t\t} else {\n\t\t\tsprintf(cmd, \"env PATH='%s' DISPLAY='%s' %s %s -name x11vnc_port_prompt -portprompt > %s\", p1, dstr, wish, tf1, tf2);\n\t\t}\n\t\tif (getenv(\"X11VNC_DEBUG_PORTPROMPT\")) {\n\t\t\tfprintf(stderr, \"cmd=%s\\n\", cmd);\n\t\t}\n\t\tif (use_openssl) {\n\t\t\tset_env(\"X11VNC_SSL_ENABLED\", \"1\");\n\t\t}\n\t\tif (allow_list && !strcmp(allow_list, \"127.0.0.1\")) {\n\t\t\tset_env(\"X11VNC_LOCALHOST_ENABLED\", \"1\");\n\t\t}\n\t\tif (got_ultrafilexfer) {\n\t\t\tset_env(\"X11VNC_FILETRANSFER_ENABLED\", \"ultra\");\n\t\t} else if (tightfilexfer) {\n\t\t\tset_env(\"X11VNC_FILETRANSFER_ENABLED\", \"tight\");\n\t\t}\n\t\tsystem(cmd);\n\t\tfree(cmd);\n\t\tfree(p1);\n\n\t\tfp = fopen(tf2, \"r\");\n\t\tmemset(line, 0, sizeof(line));\n\t\tif (fp) {\n\t\t\tfgets(line, 128, fp);\n\t\t\tfclose(fp);\n\t\t\tif (line[0] != '\\0') {\n\t\t\t\tint readport = atoi(line);\n\t\t\t\tif (readport > 0) {\n\t\t\t\t\tgot_rfbport_val = readport;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (strstr(line, \"ssl0\")) {\n\t\t\tif (use_openssl) use_openssl = 0;\n\t\t} else if (strstr(line, \"ssl1\")) {\n\t\t\tif (!use_openssl) {\n\t\t\t\tuse_openssl = 1;\n\t\t\t\topenssl_pem = strdup(\"SAVE_NOPROMPT\");\n\t\t\t\tset_env(\"X11VNC_GOT_SSL\", \"1\");\n\t\t\t}\n\t\t}\n\n\t\tif (strstr(line, \"localhost0\")) {\n\t\t\tif (allow_list && !strcmp(allow_list, \"127.0.0.1\")) {\n\t\t\t\tallow_list = NULL;\n\t\t\t}\n\t\t} else if (strstr(line, \"localhost1\")) {\n\t\t\tallow_list = strdup(\"127.0.0.1\");\n\t\t}\n\n\t\tif (strstr(line, \"ft_ultra\")) {\n\t\t\tgot_ultrafilexfer = 1;\n\t\t\ttightfilexfer = 0;\n\t\t} else if (strstr(line, \"ft_tight\")) {\n\t\t\tgot_ultrafilexfer = 0;\n\t\t\ttightfilexfer = 1;\n\t\t} else if (strstr(line, \"ft_none\")) {\n\t\t\tgot_ultrafilexfer = 0;\n\t\t\ttightfilexfer = 0;\n\t\t}\n\n\t\tunlink(tf1);\n\t\tunlink(tf2);\n\n\t\tif (old_xauth) {\n\t\t\tset_env(\"XAUTHORITY\", old_xauth);\n\t\t}\n\n\t\treturn;\n\t}\n\n\tif (start_x11vnc) {\n\n#if LIBVNCSERVER_HAVE_FORK\n\t\t/* fork into the background now */\n\t\tint p;\n\t\tpid_t parent = getpid();\n\n\t\tif (icon_mode) {\n\t\t\tchar tf[] = \"/tmp/x11vnc.tray.XXXXXX\"; \n\t\t\tint fd;\n\n\t\t\tfd = mkstemp(tf);\n\t\t\tif (fd < 0) {\n\t\t\t\ticon_mode = 0;\n\t\t\t} else {\n\t\t\t\tclose(fd);\n\t\t\t\ticon_mode_fh = fopen(tf, \"w\");\n\t\t\t\tif (! icon_mode_fh) {\n\t\t\t\t\ticon_mode = 0;\n\t\t\t\t} else {\n\t\t\t\t\tchmod(tf, 0400);\n\t\t\t\t\ticon_mode_file = strdup(tf);\n\t\t\t\t\trfbLog(\"icon_mode_file=%s\\n\", icon_mode_file);\n\t\t\t\t\tfprintf(icon_mode_fh, \"none\\n\");\n\t\t\t\t\tfprintf(icon_mode_fh, \"none\\n\");\n\t\t\t\t\tfflush(icon_mode_fh);\n\t\t\t\t\tif (! got_connect_once) {\n\t\t\t\t\t\tif (!client_connect && !connect_or_exit) {\n\t\t\t\t\t\t\t/* want -forever for tray? */\n\t\t\t\t\t\t\tconnect_once = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ((p = fork()) > 0)  {\n\t\t\t;\t/* parent */\n\t\t} else if (p == -1) {\n\t\t\tfprintf(stderr, \"could not fork\\n\");\n\t\t\tperror(\"fork\");\n\t\t\tclean_up_exit(1);\n\t\t} else {\n\t\t\tif (sleep > 0) {\n\t\t\t\tusleep(sleep * 1000 * 1000);\n\t\t\t}\n\t\t\trun_gui(gui_xdisplay, connect_to_x11vnc, start_x11vnc,\n\t\t\t    simple_gui, parent, opts);\n\t\t\texit(1);\n\t\t}\n\t\tif (connect_to_x11vnc) {\n\t\t\trun_gui_pid = p;\n\t\t\tgui_pid = p;\n\t\t}\n#else\n\t\tfprintf(stderr, \"system does not support fork: start \"\n\t\t    \"x11vnc in the gui.\\n\");\n\t\tstart_x11vnc = 0;\n#endif\n\t}\n\tif (!start_x11vnc) {\n\t\trun_gui(gui_xdisplay, connect_to_x11vnc, start_x11vnc,\n\t\t    simple_gui, 0, opts);\n\t\texit(1);\n\t}\n\tif (old_xauth) {\n\t\tset_env(\"XAUTHORITY\", old_xauth);\n\t}\n}",
    "includes": [
      "#include \"tkx11vnc.h\"",
      "#include \"connections.h\"",
      "#include \"xwrappers.h\"",
      "#include \"cleanup.h\"",
      "#include \"remote.h\"",
      "#include \"win_utils.h\"",
      "#include \"xevents.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int icon_mode = 0;",
      "char *icon_mode_file = NULL;",
      "FILE *icon_mode_fh = NULL;",
      "int tray_manager_ok = 0;",
      "pid_t run_gui_pid = 0;",
      "pid_t gui_pid = 0;",
      "void do_gui(char *opts, int sleep);",
      "static char *gui_geometry = NULL;",
      "static int icon_in_tray = 0;",
      "static char *icon_mode_font = NULL;",
      "static char *icon_mode_params = NULL;",
      "static char *extra_path = \":/usr/local/bin:/usr/bin/X11:/usr/sfw/bin\"\n\t    \":/usr/X11R6/bin:/usr/openwin/bin:/usr/dt/bin:/opt/sfw/bin\";",
      "static char *wishes[] = {\"wish8.4\", \"wish\", \"wish8.3\", \"wish8.5\", \"wish8.6\", \"wish8.7\", \"wishx\", \"wish8.0\", NULL};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_env",
          "args": [
            "\"XAUTHORITY\"",
            "old_xauth"
          ],
          "line": 933
        },
        "resolved": true,
        "details": {
          "function_name": "set_env",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "239-249",
          "snippet": "void set_env(char *name, char *value) {\n\tchar *str;\n\tif (! name) {\n\t\treturn;\n\t}\n\tif (! value) {\n\t\tvalue = \"\";\n\t}\n\n\tsetenv(name, value, 1);\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void lowercase(char *str);",
            "void uppercase(char *str);",
            "char *lblanks(char *str);",
            "void strzero(char *str);",
            "void set_env(char *name, char *value);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nvoid lowercase(char *str);\nvoid uppercase(char *str);\nchar *lblanks(char *str);\nvoid strzero(char *str);\nvoid set_env(char *name, char *value);\n\nvoid set_env(char *name, char *value) {\n\tchar *str;\n\tif (! name) {\n\t\treturn;\n\t}\n\tif (! value) {\n\t\tvalue = \"\";\n\t}\n\n\tsetenv(name, value, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 930
        },
        "resolved": true,
        "details": {
          "function_name": "clean_up_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
          "lines": "151-266",
          "snippet": "void clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"uinput.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"screen.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"connections.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void clean_up_exit(int ret);",
            "int known_sigpipe_mode(char *s);",
            "static int exit_flag = 0;",
            "static void clean_icon_mode(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid clean_up_exit(int ret);\nint known_sigpipe_mode(char *s);\nstatic int exit_flag = 0;\nstatic void clean_icon_mode(void);\n\nvoid clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "run_gui",
          "args": [
            "gui_xdisplay",
            "connect_to_x11vnc",
            "start_x11vnc",
            "simple_gui",
            "0",
            "opts"
          ],
          "line": 928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"system does not support fork: start \"\n\t\t    \"x11vnc in the gui.\\n\""
          ],
          "line": 922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "run_gui",
          "args": [
            "gui_xdisplay",
            "connect_to_x11vnc",
            "start_x11vnc",
            "simple_gui",
            "parent",
            "opts"
          ],
          "line": 913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "sleep * 1000 * 1000"
          ],
          "line": 911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"fork\""
          ],
          "line": 907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"could not fork\\n\""
          ],
          "line": 906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fflush",
          "args": [
            "icon_mode_fh"
          ],
          "line": 892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "icon_mode_fh",
            "\"none\\n\""
          ],
          "line": 891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "icon_mode_fh",
            "\"none\\n\""
          ],
          "line": 890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"icon_mode_file=%s\\n\"",
            "icon_mode_file"
          ],
          "line": 889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "tf"
          ],
          "line": 888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chmod",
          "args": [
            "tf",
            "0400"
          ],
          "line": 887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "tf",
            "\"w\""
          ],
          "line": 883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 882
        },
        "resolved": true,
        "details": {
          "function_name": "close_alarm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
          "lines": "666-672",
          "snippet": "static void close_alarm (int sig) {\n\tif (slave_fd >= 0) {\n\t\tclose(slave_fd);\n\t}\n\talarm_fired = 1;\n\tif (0) sig = 0;\t/* compiler warning */\n}",
          "includes": [
            "#include <sys/stropts.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <shadow.h>",
            "#include \"default8x16.h\"",
            "#include \"rates.h\"",
            "#include \"cursor.h\"",
            "#include \"sslhelper.h\"",
            "#include \"connections.h\"",
            "#include \"user.h\"",
            "#include \"connections.h\"",
            "#include \"xinerama.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int slave_fd = -1, alarm_fired = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nstatic int slave_fd = -1, alarm_fired = 0;\n\nstatic void close_alarm (int sig) {\n\tif (slave_fd >= 0) {\n\t\tclose(slave_fd);\n\t}\n\talarm_fired = 1;\n\tif (0) sig = 0;\t/* compiler warning */\n}"
        }
      },
      {
        "call_info": {
          "callee": "mkstemp",
          "args": [
            "tf"
          ],
          "line": 878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "tf2"
          ],
          "line": 858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "tf1"
          ],
          "line": 857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "line",
            "\"ft_none\""
          ],
          "line": 852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "line",
            "\"ft_tight\""
          ],
          "line": 849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "line",
            "\"ft_ultra\""
          ],
          "line": 846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"127.0.0.1\""
          ],
          "line": 843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "line",
            "\"localhost1\""
          ],
          "line": 842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "allow_list",
            "\"127.0.0.1\""
          ],
          "line": 839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "line",
            "\"localhost0\""
          ],
          "line": 838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"SAVE_NOPROMPT\""
          ],
          "line": 833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "line",
            "\"ssl1\""
          ],
          "line": 830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "line",
            "\"ssl0\""
          ],
          "line": 828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "line"
          ],
          "line": 821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fp"
          ],
          "line": 819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "line",
            "128",
            "fp"
          ],
          "line": 818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "line",
            "0",
            "sizeof(line)"
          ],
          "line": 816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "tf2",
            "\"r\""
          ],
          "line": 815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "p1"
          ],
          "line": 813
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "system",
          "args": [
            "cmd"
          ],
          "line": 811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "allow_list",
            "\"127.0.0.1\""
          ],
          "line": 803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"cmd=%s\\n\"",
            "cmd"
          ],
          "line": 798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"X11VNC_DEBUG_PORTPROMPT\""
          ],
          "line": 797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "cmd",
            "\"env PATH='%s' DISPLAY='%s' %s %s -name x11vnc_port_prompt -portprompt > %s\"",
            "p1",
            "dstr",
            "wish",
            "tf1",
            "tf2"
          ],
          "line": 795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "cmd",
            "\"env PATH='%s' %s %s -name x11vnc_port_prompt -portprompt > %s\"",
            "p1",
            "wish",
            "tf1",
            "tf2"
          ],
          "line": 793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "dstr",
            "\"\""
          ],
          "line": 792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "200 + strlen(dstr) + strlen(p1)"
          ],
          "line": 790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "p1"
          ],
          "line": 790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "dstr"
          ],
          "line": 790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "NULL",
            "\":\""
          ],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "try",
            "&sbuf"
          ],
          "line": 771
        },
        "resolved": true,
        "details": {
          "function_name": "grab_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "3178-3224",
          "snippet": "void grab_state(int *ptr_grabbed, int *kbd_grabbed) {\n\tint rcp, rck;\n\tdouble t0, t1;\n\tdouble ta, tb, tc;\n\t*ptr_grabbed = -1;\n\t*kbd_grabbed = -1;\n\n\tif (!dpy) {\n\t\treturn;\n\t}\n\t*ptr_grabbed = 0;\n\t*kbd_grabbed = 0;\n\n#if !NO_X11\n\tX_LOCK;\n\n\tXSync(dpy, False);\n\n\tta = t0 = dnow();\n\n\trcp = XGrabPointer(dpy, window, False, 0, GrabModeAsync, GrabModeAsync, None, None, CurrentTime);\n\tXUngrabPointer(dpy, CurrentTime);\n\n\ttb = dnow();\n\t\n\trck = XGrabKeyboard(dpy, window, False, GrabModeAsync, GrabModeAsync, CurrentTime);\n\tXUngrabKeyboard(dpy, CurrentTime);\n\n\ttc = dnow();\n\n\tXSync(dpy, False);\n\n\tt1 = dnow();\n\n\tX_UNLOCK;\n\tif (rcp == AlreadyGrabbed || rcp == GrabFrozen) {\n\t\t*ptr_grabbed = 1;\n\t}\n\tif (rck == AlreadyGrabbed || rck == GrabFrozen) {\n\t\t*kbd_grabbed = 1;\n\t}\n\tif (rc_npieces < 10) {\n\t\trfbLog(\"grab_state: checked %d,%d in %.6f sec (%.6f %.6f)\\n\",\n\t\t    *ptr_grabbed, *kbd_grabbed, t1-t0, tb-ta, tc-tb);\n\t}\n#endif\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void grab_state(int *ptr_grabbed, int *kbd_grabbed);",
            "extern int rc_npieces;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid grab_state(int *ptr_grabbed, int *kbd_grabbed);\nextern int rc_npieces;\n\nvoid grab_state(int *ptr_grabbed, int *kbd_grabbed) {\n\tint rcp, rck;\n\tdouble t0, t1;\n\tdouble ta, tb, tc;\n\t*ptr_grabbed = -1;\n\t*kbd_grabbed = -1;\n\n\tif (!dpy) {\n\t\treturn;\n\t}\n\t*ptr_grabbed = 0;\n\t*kbd_grabbed = 0;\n\n#if !NO_X11\n\tX_LOCK;\n\n\tXSync(dpy, False);\n\n\tta = t0 = dnow();\n\n\trcp = XGrabPointer(dpy, window, False, 0, GrabModeAsync, GrabModeAsync, None, None, CurrentTime);\n\tXUngrabPointer(dpy, CurrentTime);\n\n\ttb = dnow();\n\t\n\trck = XGrabKeyboard(dpy, window, False, GrabModeAsync, GrabModeAsync, CurrentTime);\n\tXUngrabKeyboard(dpy, CurrentTime);\n\n\ttc = dnow();\n\n\tXSync(dpy, False);\n\n\tt1 = dnow();\n\n\tX_UNLOCK;\n\tif (rcp == AlreadyGrabbed || rcp == GrabFrozen) {\n\t\t*ptr_grabbed = 1;\n\t}\n\tif (rck == AlreadyGrabbed || rck == GrabFrozen) {\n\t\t*kbd_grabbed = 1;\n\t}\n\tif (rc_npieces < 10) {\n\t\trfbLog(\"grab_state: checked %d,%d in %.6f sec (%.6f %.6f)\\n\",\n\t\t    *ptr_grabbed, *kbd_grabbed, t1-t0, tb-ta, tc-tb);\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "try",
            "\"%s/%s\"",
            "p",
            "wishes[i]"
          ],
          "line": 770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "strlen(p) + 1 + strlen(\"wish8.4\") + 1"
          ],
          "line": 767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"wish8.4\""
          ],
          "line": 767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "p"
          ],
          "line": 767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "p2",
            "\":\""
          ],
          "line": 760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "p1"
          ],
          "line": 759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "p1",
            "\"%s:%s\"",
            "p0",
            "extra_path"
          ],
          "line": 758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "10 + strlen(p0) + strlen(extra_path)"
          ],
          "line": 757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "extra_path"
          ],
          "line": 757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "p0"
          ],
          "line": 757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write",
          "args": [
            "fd",
            "gui_code",
            "strlen(gui_code)"
          ],
          "line": 754
        },
        "resolved": true,
        "details": {
          "function_name": "write_exact",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "1319-1344",
          "snippet": "static int write_exact(int sock, char *buf, int len) {\n\tint n, fail = 0;\n\tif (sock < 0) {\n\t\treturn 0;\n\t}\n\twhile (len > 0) {\n\t\tn = write(sock, buf, len);\n\t\tif (n > 0) {\n\t\t\tbuf += n;\n\t\t\tlen -= n;\n\t\t} else if (n == 0) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t} else if (n < 0 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n\t\t\tusleep(10*1000);\n\t\t} else if (n < 0 && errno != EINTR) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fail) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void ssl_helper_pid(pid_t pid, int sock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid ssl_helper_pid(pid_t pid, int sock);\n\nstatic int write_exact(int sock, char *buf, int len) {\n\tint n, fail = 0;\n\tif (sock < 0) {\n\t\treturn 0;\n\t}\n\twhile (len > 0) {\n\t\tn = write(sock, buf, len);\n\t\tif (n > 0) {\n\t\t\tbuf += n;\n\t\t\tlen -= n;\n\t\t} else if (n == 0) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t} else if (n < 0 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n\t\t\tusleep(10*1000);\n\t\t} else if (n < 0 && errno != EINTR) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fail) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "gui_code"
          ],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "tf2"
          ],
          "line": 750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mkstemp",
          "args": [
            "tf1"
          ],
          "line": 748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mkstemp",
          "args": [
            "tf2"
          ],
          "line": 742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "p0",
            "'\\''"
          ],
          "line": 738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "gui_xdisplay",
            "'\\''"
          ],
          "line": 731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cmd_ok",
          "args": [
            "\"gui\""
          ],
          "line": 725
        },
        "resolved": true,
        "details": {
          "function_name": "cmd_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "436-460",
          "snippet": "int cmd_ok(char *cmd) {\n\tchar *p, *str;\n\tif (no_external_cmds) {\n\t\treturn 0;\n\t}\n\tif (! cmd || cmd[0] == '\\0') {\n\t\treturn 0;\n\t}\n\tif (! allowed_external_cmds) {\n\t\t/* default, allow any (overridden by -nocmds) */\n\t\treturn 1;\n\t}\n\n\tstr = strdup(allowed_external_cmds);\n\tp = strtok(str, \",\");\n\twhile (p) {\n\t\tif (!strcmp(p, cmd)) {\n\t\t\tfree(str);\n\t\t\treturn 1;\n\t\t}\n\t\tp = strtok(NULL, \",\");\n\t}\n\tfree(str);\n\treturn 0;\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void close_clients(char *str);",
            "void set_client_input(char *str);",
            "int cmd_ok(char *cmd);",
            "void reverse_connect(char *str);",
            "void set_vnc_connect_prop(char *str);",
            "void set_x11vnc_remote_prop(char *str);",
            "void send_client_info(char *str);",
            "static rfbClientPtr *client_match(char *str);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid close_clients(char *str);\nvoid set_client_input(char *str);\nint cmd_ok(char *cmd);\nvoid reverse_connect(char *str);\nvoid set_vnc_connect_prop(char *str);\nvoid set_x11vnc_remote_prop(char *str);\nvoid send_client_info(char *str);\nstatic rfbClientPtr *client_match(char *str);\n\nint cmd_ok(char *cmd) {\n\tchar *p, *str;\n\tif (no_external_cmds) {\n\t\treturn 0;\n\t}\n\tif (! cmd || cmd[0] == '\\0') {\n\t\treturn 0;\n\t}\n\tif (! allowed_external_cmds) {\n\t\t/* default, allow any (overridden by -nocmds) */\n\t\treturn 1;\n\t}\n\n\tstr = strdup(allowed_external_cmds);\n\tp = strtok(str, \",\");\n\twhile (p) {\n\t\tif (!strcmp(p, cmd)) {\n\t\t\tfree(str);\n\t\t\treturn 1;\n\t\t}\n\t\tp = strtok(NULL, \",\");\n\t}\n\tfree(str);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"PATH\""
          ],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XCloseDisplay_wr",
          "args": [
            "test_dpy"
          ],
          "line": 711
        },
        "resolved": true,
        "details": {
          "function_name": "XCloseDisplay_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "1504-1512",
          "snippet": "int XCloseDisplay_wr(Display *display) {\n\tint db = 0;\n\tif (db) fprintf(stderr, \"XCloseDisplay_wr: %p\\n\", (void *)display);\n#if NO_X11\n\treturn 0;\n#else\n\treturn XCloseDisplay(display);\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int XCloseDisplay_wr(Display *display);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nint XCloseDisplay_wr(Display *display);\n\nint XCloseDisplay_wr(Display *display) {\n\tint db = 0;\n\tif (db) fprintf(stderr, \"XCloseDisplay_wr: %p\\n\", (void *)display);\n#if NO_X11\n\treturn 0;\n#else\n\treturn XCloseDisplay(display);\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "tray_manager_running",
          "args": [
            "test_dpy",
            "NULL"
          ],
          "line": 705
        },
        "resolved": true,
        "details": {
          "function_name": "tray_manager_running",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/gui.c",
          "lines": "216-249",
          "snippet": "static int tray_manager_running(Display *d, Window *manager) {\n#if NO_X11\n\tRAWFB_RET(0)\n\tif (!d || !manager) {}\n\treturn 0;\n#else\n\tchar tray_string[100];\n\tAtom tray_manager;\n\tWindow tray_win;\n\n\tRAWFB_RET(0)\n\n\tif (manager) {\n\t\t*manager = None;\n\t}\n\tsprintf(tray_string, \"_NET_SYSTEM_TRAY_S%d\", scr);\n\n\ttray_manager = XInternAtom(d, tray_string, True);\n\tif (tray_manager == None) {\n\t\treturn 0;\n\t}\n\n\ttray_win = XGetSelectionOwner(d, tray_manager);\n\tif (manager) {\n\t\t*manager = tray_win;\n\t}\n\n\tif (tray_win == None) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"tkx11vnc.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"cleanup.h\"",
            "#include \"remote.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int tray_manager_running(Display *d, Window *manager);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tkx11vnc.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"cleanup.h\"\n#include \"remote.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"x11vnc.h\"\n\nstatic int tray_manager_running(Display *d, Window *manager);\n\nstatic int tray_manager_running(Display *d, Window *manager) {\n#if NO_X11\n\tRAWFB_RET(0)\n\tif (!d || !manager) {}\n\treturn 0;\n#else\n\tchar tray_string[100];\n\tAtom tray_manager;\n\tWindow tray_win;\n\n\tRAWFB_RET(0)\n\n\tif (manager) {\n\t\t*manager = None;\n\t}\n\tsprintf(tray_string, \"_NET_SYSTEM_TRAY_S%d\", scr);\n\n\ttray_manager = XInternAtom(d, tray_string, True);\n\tif (tray_manager == None) {\n\t\treturn 0;\n\t}\n\n\ttray_win = XGetSelectionOwner(d, tray_manager);\n\tif (manager) {\n\t\t*manager = tray_win;\n\t}\n\n\tif (tray_win == None) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"error: cannot connect to gui X DISPLAY: %s\\n\"",
            "gui_xdisplay"
          ],
          "line": 700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XOpenDisplay_wr",
          "args": [
            "gui_xdisplay"
          ],
          "line": 697
        },
        "resolved": true,
        "details": {
          "function_name": "XOpenDisplay_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "1461-1502",
          "snippet": "Display *XOpenDisplay_wr(char *display_name) {\n\tDisplay *d = NULL;\n\tint db = 0;\n\n\tif (! xauth_raw(1)) {\n\t\treturn NULL;\n\t}\n#if NO_X11\n\trfbLog(\"This x11vnc was built without X11 support (-rawfb only).\\n\");\n\tif (!display_name || !d || !db) {}\n\treturn NULL;\n#else\n\n\td = XOpenDisplay(display_name);\n\tif (db) fprintf(stderr, \"XOpenDisplay_wr: %s  %p\\n\", display_name, (void *)d);\n\n\tif (d == NULL && !getenv(\"NO_XAUTHLOCALHOSTNAME\")) {\n\t\tchar *xalhn = getenv(\"XAUTHLOCALHOSTNAME\");\n\t\tif (1 || !xalhn) {\n\t\t\trfbLog(\"XOpenDisplay(\\\"%s\\\") failed.\\n\",\n\t\t\t    display_name ? display_name : \"\");\n\t\t\trfbLog(\"Trying again with XAUTHLOCALHOSTNAME=localhost ...\\n\");\n\t\t\tset_env(\"XAUTHLOCALHOSTNAME\", \"localhost\");\n\t\t\td = XOpenDisplay(display_name);\n\t\t\tif (d == NULL && xalhn) {\n\t\t\t\tchar *ptr = getenv(\"XAUTHLOCALHOSTNAME\");\n\t\t\t\tif (ptr) {\n\t\t\t\t\t*(ptr-2) = '_';\t/* yow */\n\t\t\t\t\trfbLog(\"XOpenDisplay(\\\"%s\\\") failed.\\n\",\n\t\t\t\t\t    display_name ? display_name : \"\");\n\t\t\t\t\trfbLog(\"Trying again with unset XAUTHLOCALHOSTNAME ...\\n\");\n\t\t\t\t\td = XOpenDisplay(display_name);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\txauth_raw(0);\n\n\treturn d;\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Display *XOpenDisplay_wr(char *display_name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nDisplay *XOpenDisplay_wr(char *display_name);\n\nDisplay *XOpenDisplay_wr(char *display_name) {\n\tDisplay *d = NULL;\n\tint db = 0;\n\n\tif (! xauth_raw(1)) {\n\t\treturn NULL;\n\t}\n#if NO_X11\n\trfbLog(\"This x11vnc was built without X11 support (-rawfb only).\\n\");\n\tif (!display_name || !d || !db) {}\n\treturn NULL;\n#else\n\n\td = XOpenDisplay(display_name);\n\tif (db) fprintf(stderr, \"XOpenDisplay_wr: %s  %p\\n\", display_name, (void *)d);\n\n\tif (d == NULL && !getenv(\"NO_XAUTHLOCALHOSTNAME\")) {\n\t\tchar *xalhn = getenv(\"XAUTHLOCALHOSTNAME\");\n\t\tif (1 || !xalhn) {\n\t\t\trfbLog(\"XOpenDisplay(\\\"%s\\\") failed.\\n\",\n\t\t\t    display_name ? display_name : \"\");\n\t\t\trfbLog(\"Trying again with XAUTHLOCALHOSTNAME=localhost ...\\n\");\n\t\t\tset_env(\"XAUTHLOCALHOSTNAME\", \"localhost\");\n\t\t\td = XOpenDisplay(display_name);\n\t\t\tif (d == NULL && xalhn) {\n\t\t\t\tchar *ptr = getenv(\"XAUTHLOCALHOSTNAME\");\n\t\t\t\tif (ptr) {\n\t\t\t\t\t*(ptr-2) = '_';\t/* yow */\n\t\t\t\t\trfbLog(\"XOpenDisplay(\\\"%s\\\") failed.\\n\",\n\t\t\t\t\t    display_name ? display_name : \"\");\n\t\t\t\t\trfbLog(\"Trying again with unset XAUTHLOCALHOSTNAME ...\\n\");\n\t\t\t\t\td = XOpenDisplay(display_name);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\txauth_raw(0);\n\n\treturn d;\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "getenv(\"XAUTHORITY\")"
          ],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"XAUTHORITY\""
          ],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"XAUTHORITY\""
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "getenv(\"XAUTHORITY\")"
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"XAUTHORITY\""
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"XAUTHORITY\""
          ],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"starting gui, trying display: %s\\n\"",
            "gui_xdisplay"
          ],
          "line": 681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"error: cannot determine X DISPLAY for gui\"\n\t\t    \" to display on.\\n\""
          ],
          "line": 676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "use_dpy"
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "NULL",
            "\",\""
          ],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"unrecognized gui opt: %s\\n\"",
            "p"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "q+1"
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "p",
            "'='"
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"geom\""
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"tray\""
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "icon_mode_params",
            "\"setp\""
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "q+1"
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "p",
            "'='"
          ],
          "line": 628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"icon\""
          ],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"tray\""
          ],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"setp\""
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"full\""
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "q+1"
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "p",
            "'='"
          ],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"iconfont\""
          ],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"simple\""
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"ez\""
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"connect\""
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"conn\""
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"portprompt\""
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"none\""
          ],
          "line": 604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"wait\""
          ],
          "line": 601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "p"
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "p",
            "':'"
          ],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "s",
            "\",\""
          ],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "getenv(\"DISPLAY\")"
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"DISPLAY\""
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"DISPLAY\""
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "use_dpy"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"\""
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "opts"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tkx11vnc.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"cleanup.h\"\n#include \"remote.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"x11vnc.h\"\n\nint icon_mode = 0;\nchar *icon_mode_file = NULL;\nFILE *icon_mode_fh = NULL;\nint tray_manager_ok = 0;\npid_t run_gui_pid = 0;\npid_t gui_pid = 0;\nvoid do_gui(char *opts, int sleep);\nstatic char *gui_geometry = NULL;\nstatic int icon_in_tray = 0;\nstatic char *icon_mode_font = NULL;\nstatic char *icon_mode_params = NULL;\nstatic char *extra_path = \":/usr/local/bin:/usr/bin/X11:/usr/sfw/bin\"\n\t    \":/usr/X11R6/bin:/usr/openwin/bin:/usr/dt/bin:/opt/sfw/bin\";\nstatic char *wishes[] = {\"wish8.4\", \"wish\", \"wish8.3\", \"wish8.5\", \"wish8.6\", \"wish8.7\", \"wishx\", \"wish8.0\", NULL};\n\nvoid do_gui(char *opts, int sleep) {\n\tchar *s, *p;\n\tchar *old_xauth = NULL;\n\tchar *gui_xdisplay = NULL;\n\tint got_gui_xdisplay = 0;\n\tint start_x11vnc = 1;\n\tint connect_to_x11vnc = 0;\n\tint simple_gui = 0, none_gui = 0;\n\tint portprompt = 0;\n\tDisplay *test_dpy;\n\n\tif (opts) {\n\t\ts = strdup(opts);\n\t} else {\n\t\ts = strdup(\"\");\n\t}\n\n\tif (use_dpy) {\n\t\t/* worst case */\n\t\tgui_xdisplay = strdup(use_dpy);\n\t\t\n\t}\n\tif (getenv(\"DISPLAY\") != NULL) {\n\t\t/* better */\n\t\tgui_xdisplay = strdup(getenv(\"DISPLAY\"));\n\t}\n\n\tp = strtok(s, \",\");\n\n\twhile(p) {\n\t\tif (*p == '\\0') {\n\t\t\t;\n\t\t} else if (strchr(p, ':') != NULL) {\n\t\t\t/* best */\n\t\t\tif (gui_xdisplay) {\n\t\t\t\tfree(gui_xdisplay);\n\t\t\t}\n\t\t\tgui_xdisplay = strdup(p);\n\t\t\tgot_gui_xdisplay = 1;\n\t\t} else if (!strcmp(p, \"wait\")) {\n\t\t\tstart_x11vnc = 0;\n\t\t\tconnect_to_x11vnc = 0;\n\t\t} else if (!strcmp(p, \"none\")) {\n\t\t\tnone_gui = 1;\n\t\t} else if (!strcmp(p, \"portprompt\")) {\n\t\t\tstart_x11vnc = 0;\n\t\t\tconnect_to_x11vnc = 0;\n\t\t\tportprompt = 1;\n\t\t} else if (!strcmp(p, \"conn\") || !strcmp(p, \"connect\")) {\n\t\t\tstart_x11vnc = 0;\n\t\t\tconnect_to_x11vnc = 1;\n\t\t} else if (!strcmp(p, \"ez\") || !strcmp(p, \"simple\")) {\n\t\t\tsimple_gui = 1;\n\t\t} else if (strstr(p, \"iconfont\") == p) {\n\t\t\tchar *q;\n\t\t\tif ((q = strchr(p, '=')) != NULL) {\n\t\t\t\ticon_mode_font = strdup(q+1);\n\t\t\t}\n\t\t} else if (strstr(p, \"full\") == p) {\n\t\t\tif (strstr(p, \"setp\") && 0) {\n\t\t\t\tset_env(\"X11VNC_ICON_MODE\", \"2\");\n\t\t\t\tset_env(\"X11VNC_ICON_SETPASS\", \"2\");\n\t\t\t}\n\t\t} else if (strstr(p, \"tray\") == p || strstr(p, \"icon\") == p) {\n\t\t\tchar *q;\n\t\t\ticon_mode = 1;\n\t\t\tif ((q = strchr(p, '=')) != NULL) {\n\t\t\t\ticon_mode_params = strdup(q+1);\n\t\t\t\tif (strstr(icon_mode_params, \"setp\")) {\n\t\t\t\t\tdeny_all = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (strstr(p, \"tray\") == p) {\n\t\t\t\ticon_in_tray = 1;\n\t\t\t}\n\t\t} else if (strstr(p, \"geom\") == p) {\n\t\t\tchar *q;\n\t\t\tif ((q = strchr(p, '=')) != NULL) {\n\t\t\t\tgui_geometry = strdup(q+1);\n\t\t\t}\n\t\t} else {\n\t\t\tfprintf(stderr, \"unrecognized gui opt: %s\\n\", p);\n\t\t}\n\t\t\n\t\tp = strtok(NULL, \",\");\n\t}\n\tfree(s);\n\n\tif (none_gui) {\n\t\tif (!start_x11vnc) {\n\t\t\texit(0);\n\t\t}\n\t\treturn;\n\t}\n\tif (start_x11vnc) {\n\t\tconnect_to_x11vnc = 1;\n\t}\n\n\n#ifdef MACOSX\n\tgoto startit;\n#endif\n\n\tif (icon_mode && !got_gui_xdisplay) {\n\t\t/* for tray mode, prefer the polled DISPLAY */\n\t\tif (use_dpy) {\n\t\t\tif (gui_xdisplay) {\n\t\t\t\tfree(gui_xdisplay);\n\t\t\t}\n\t\t\tgui_xdisplay = strdup(use_dpy);\n\t\t}\n\t}\n\n\tif (! gui_xdisplay) {\n\t\tfprintf(stderr, \"error: cannot determine X DISPLAY for gui\"\n\t\t    \" to display on.\\n\");\n\t\texit(1);\n\t}\n\tif (!quiet && !portprompt) {\n\t\tfprintf(stderr, \"starting gui, trying display: %s\\n\",\n\t\t    gui_xdisplay);\n\t}\n\ttest_dpy = XOpenDisplay_wr(gui_xdisplay);\n\tif (! test_dpy && auth_file) {\n\t\tif (getenv(\"XAUTHORITY\") != NULL) {\n\t\t\told_xauth = strdup(getenv(\"XAUTHORITY\"));\n\t\t}\n\t\tset_env(\"XAUTHORITY\", auth_file);\n\t\ttest_dpy = XOpenDisplay_wr(gui_xdisplay);\n\t}\n\tif (! test_dpy) {\n\t\tif (! old_xauth && getenv(\"XAUTHORITY\") != NULL) {\n\t\t\told_xauth = strdup(getenv(\"XAUTHORITY\"));\n\t\t}\n\t\tset_env(\"XAUTHORITY\", \"\");\n\t\ttest_dpy = XOpenDisplay_wr(gui_xdisplay);\n\t}\n\tif (! test_dpy) {\n\t\tfprintf(stderr, \"error: cannot connect to gui X DISPLAY: %s\\n\",\n\t\t    gui_xdisplay);\n\t\texit(1);\n\t}\n\tif (icon_mode && icon_in_tray) {\n\t\tif (tray_manager_running(test_dpy, NULL)) {\n\t\t\ttray_manager_ok = 1;\n\t\t} else {\n\t\t\ttray_manager_ok = 0;\n\t\t}\n\t}\n\tXCloseDisplay_wr(test_dpy);\n\n#ifdef MACOSX\n\tstartit:\n#endif\n\tif (portprompt) {\n\t\tchar *cmd, *p, *p2, *p1, *p0 = getenv(\"PATH\");\n\t\tchar tf1[] = \"/tmp/x11vnc_port_prompt.2XXXXXX\";\n\t\tchar tf2[] = \"/tmp/x11vnc_port_prompt.1XXXXXX\";\n\t\tint fd;\n\t\tchar *dstr = \"\", *wish = NULL;\n\t\tchar line[128];\n\t\tFILE *fp;\n\n\t\tif (no_external_cmds || !cmd_ok(\"gui\")) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (gui_xdisplay) {\n\t\t\tdstr = gui_xdisplay;\n\t\t\tif (strchr(gui_xdisplay, '\\'')) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (!p0) {\n\t\t\tp0 = \"\";\n\t\t}\n\t\tif (strchr(p0, '\\'')) {\n\t\t\treturn;\n\t\t}\n\n\t\tfd = mkstemp(tf2);\n\t\tif (fd < 0) {\n\t\t\treturn;\n\t\t}\n\t\tclose(fd);\n\n\t\tfd = mkstemp(tf1);\n\t\tif (fd < 0) {\n\t\t\tunlink(tf2);\n\t\t\treturn;\n\t\t}\n\n\t\twrite(fd, gui_code, strlen(gui_code));\n\t\tclose(fd);\n\n\t\tp1 = (char *) malloc(10 + strlen(p0) + strlen(extra_path));\n\t\tsprintf(p1, \"%s:%s\", p0, extra_path);\n\t\tp2 = strdup(p1);\n\t\tp = strtok(p2, \":\");\n\n\t\twhile (p) {\n\t\t\tchar *try;\n\t\t\tstruct stat sbuf;\n\t\t\tint i;\n\n\t\t\ttry = (char *) malloc(strlen(p) + 1 + strlen(\"wish8.4\") + 1);\n\t\t\ti = 0;\n\t\t\twhile (wishes[i] != NULL) {\n\t\t\t\tsprintf(try, \"%s/%s\", p, wishes[i]);\n\t\t\t\tif (stat(try, &sbuf) == 0) {\n\t\t\t\t\t/* assume executable, should check mode */\n\t\t\t\t\twish = wishes[i];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tfree(try);\n\t\t\tif (wish) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tp = strtok(NULL, \":\");\n\t\t}\n\t\tfree(p2);\n\n\t\tif (!wish) {\n\t\t\twish = \"wish\";\n\t\t}\n\n\t\tcmd = (char *) malloc(200 + strlen(dstr) + strlen(p1));\n\n\t\tif (!strcmp(dstr, \"\")) {\n\t\t\tsprintf(cmd, \"env PATH='%s' %s %s -name x11vnc_port_prompt -portprompt > %s\", p1, wish, tf1, tf2);\n\t\t} else {\n\t\t\tsprintf(cmd, \"env PATH='%s' DISPLAY='%s' %s %s -name x11vnc_port_prompt -portprompt > %s\", p1, dstr, wish, tf1, tf2);\n\t\t}\n\t\tif (getenv(\"X11VNC_DEBUG_PORTPROMPT\")) {\n\t\t\tfprintf(stderr, \"cmd=%s\\n\", cmd);\n\t\t}\n\t\tif (use_openssl) {\n\t\t\tset_env(\"X11VNC_SSL_ENABLED\", \"1\");\n\t\t}\n\t\tif (allow_list && !strcmp(allow_list, \"127.0.0.1\")) {\n\t\t\tset_env(\"X11VNC_LOCALHOST_ENABLED\", \"1\");\n\t\t}\n\t\tif (got_ultrafilexfer) {\n\t\t\tset_env(\"X11VNC_FILETRANSFER_ENABLED\", \"ultra\");\n\t\t} else if (tightfilexfer) {\n\t\t\tset_env(\"X11VNC_FILETRANSFER_ENABLED\", \"tight\");\n\t\t}\n\t\tsystem(cmd);\n\t\tfree(cmd);\n\t\tfree(p1);\n\n\t\tfp = fopen(tf2, \"r\");\n\t\tmemset(line, 0, sizeof(line));\n\t\tif (fp) {\n\t\t\tfgets(line, 128, fp);\n\t\t\tfclose(fp);\n\t\t\tif (line[0] != '\\0') {\n\t\t\t\tint readport = atoi(line);\n\t\t\t\tif (readport > 0) {\n\t\t\t\t\tgot_rfbport_val = readport;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (strstr(line, \"ssl0\")) {\n\t\t\tif (use_openssl) use_openssl = 0;\n\t\t} else if (strstr(line, \"ssl1\")) {\n\t\t\tif (!use_openssl) {\n\t\t\t\tuse_openssl = 1;\n\t\t\t\topenssl_pem = strdup(\"SAVE_NOPROMPT\");\n\t\t\t\tset_env(\"X11VNC_GOT_SSL\", \"1\");\n\t\t\t}\n\t\t}\n\n\t\tif (strstr(line, \"localhost0\")) {\n\t\t\tif (allow_list && !strcmp(allow_list, \"127.0.0.1\")) {\n\t\t\t\tallow_list = NULL;\n\t\t\t}\n\t\t} else if (strstr(line, \"localhost1\")) {\n\t\t\tallow_list = strdup(\"127.0.0.1\");\n\t\t}\n\n\t\tif (strstr(line, \"ft_ultra\")) {\n\t\t\tgot_ultrafilexfer = 1;\n\t\t\ttightfilexfer = 0;\n\t\t} else if (strstr(line, \"ft_tight\")) {\n\t\t\tgot_ultrafilexfer = 0;\n\t\t\ttightfilexfer = 1;\n\t\t} else if (strstr(line, \"ft_none\")) {\n\t\t\tgot_ultrafilexfer = 0;\n\t\t\ttightfilexfer = 0;\n\t\t}\n\n\t\tunlink(tf1);\n\t\tunlink(tf2);\n\n\t\tif (old_xauth) {\n\t\t\tset_env(\"XAUTHORITY\", old_xauth);\n\t\t}\n\n\t\treturn;\n\t}\n\n\tif (start_x11vnc) {\n\n#if LIBVNCSERVER_HAVE_FORK\n\t\t/* fork into the background now */\n\t\tint p;\n\t\tpid_t parent = getpid();\n\n\t\tif (icon_mode) {\n\t\t\tchar tf[] = \"/tmp/x11vnc.tray.XXXXXX\"; \n\t\t\tint fd;\n\n\t\t\tfd = mkstemp(tf);\n\t\t\tif (fd < 0) {\n\t\t\t\ticon_mode = 0;\n\t\t\t} else {\n\t\t\t\tclose(fd);\n\t\t\t\ticon_mode_fh = fopen(tf, \"w\");\n\t\t\t\tif (! icon_mode_fh) {\n\t\t\t\t\ticon_mode = 0;\n\t\t\t\t} else {\n\t\t\t\t\tchmod(tf, 0400);\n\t\t\t\t\ticon_mode_file = strdup(tf);\n\t\t\t\t\trfbLog(\"icon_mode_file=%s\\n\", icon_mode_file);\n\t\t\t\t\tfprintf(icon_mode_fh, \"none\\n\");\n\t\t\t\t\tfprintf(icon_mode_fh, \"none\\n\");\n\t\t\t\t\tfflush(icon_mode_fh);\n\t\t\t\t\tif (! got_connect_once) {\n\t\t\t\t\t\tif (!client_connect && !connect_or_exit) {\n\t\t\t\t\t\t\t/* want -forever for tray? */\n\t\t\t\t\t\t\tconnect_once = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ((p = fork()) > 0)  {\n\t\t\t;\t/* parent */\n\t\t} else if (p == -1) {\n\t\t\tfprintf(stderr, \"could not fork\\n\");\n\t\t\tperror(\"fork\");\n\t\t\tclean_up_exit(1);\n\t\t} else {\n\t\t\tif (sleep > 0) {\n\t\t\t\tusleep(sleep * 1000 * 1000);\n\t\t\t}\n\t\t\trun_gui(gui_xdisplay, connect_to_x11vnc, start_x11vnc,\n\t\t\t    simple_gui, parent, opts);\n\t\t\texit(1);\n\t\t}\n\t\tif (connect_to_x11vnc) {\n\t\t\trun_gui_pid = p;\n\t\t\tgui_pid = p;\n\t\t}\n#else\n\t\tfprintf(stderr, \"system does not support fork: start \"\n\t\t    \"x11vnc in the gui.\\n\");\n\t\tstart_x11vnc = 0;\n#endif\n\t}\n\tif (!start_x11vnc) {\n\t\trun_gui(gui_xdisplay, connect_to_x11vnc, start_x11vnc,\n\t\t    simple_gui, 0, opts);\n\t\texit(1);\n\t}\n\tif (old_xauth) {\n\t\tset_env(\"XAUTHORITY\", old_xauth);\n\t}\n}"
  },
  {
    "function_name": "sigusr1",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/gui.c",
    "lines": "259-262",
    "snippet": "static void sigusr1 (int sig) {\n\tgot_sigusr1 = 1;\n\tif (0) sig = 0;\n}",
    "includes": [
      "#include \"tkx11vnc.h\"",
      "#include \"connections.h\"",
      "#include \"xwrappers.h\"",
      "#include \"cleanup.h\"",
      "#include \"remote.h\"",
      "#include \"win_utils.h\"",
      "#include \"xevents.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int got_sigusr1 = 0;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"tkx11vnc.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"cleanup.h\"\n#include \"remote.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"x11vnc.h\"\n\nstatic int got_sigusr1 = 0;\n\nstatic void sigusr1 (int sig) {\n\tgot_sigusr1 = 1;\n\tif (0) sig = 0;\n}"
  },
  {
    "function_name": "tray_manager_running",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/gui.c",
    "lines": "216-249",
    "snippet": "static int tray_manager_running(Display *d, Window *manager) {\n#if NO_X11\n\tRAWFB_RET(0)\n\tif (!d || !manager) {}\n\treturn 0;\n#else\n\tchar tray_string[100];\n\tAtom tray_manager;\n\tWindow tray_win;\n\n\tRAWFB_RET(0)\n\n\tif (manager) {\n\t\t*manager = None;\n\t}\n\tsprintf(tray_string, \"_NET_SYSTEM_TRAY_S%d\", scr);\n\n\ttray_manager = XInternAtom(d, tray_string, True);\n\tif (tray_manager == None) {\n\t\treturn 0;\n\t}\n\n\ttray_win = XGetSelectionOwner(d, tray_manager);\n\tif (manager) {\n\t\t*manager = tray_win;\n\t}\n\n\tif (tray_win == None) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n#endif\t/* NO_X11 */\n}",
    "includes": [
      "#include \"tkx11vnc.h\"",
      "#include \"connections.h\"",
      "#include \"xwrappers.h\"",
      "#include \"cleanup.h\"",
      "#include \"remote.h\"",
      "#include \"win_utils.h\"",
      "#include \"xevents.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int tray_manager_running(Display *d, Window *manager);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "XGetSelectionOwner",
          "args": [
            "d",
            "tray_manager"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XInternAtom",
          "args": [
            "d",
            "tray_string",
            "True"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "tray_string",
            "\"_NET_SYSTEM_TRAY_S%d\"",
            "scr"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RAWFB_RET",
          "args": [
            "0"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RAWFB_RET",
          "args": [
            "0"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tkx11vnc.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"cleanup.h\"\n#include \"remote.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"x11vnc.h\"\n\nstatic int tray_manager_running(Display *d, Window *manager);\n\nstatic int tray_manager_running(Display *d, Window *manager) {\n#if NO_X11\n\tRAWFB_RET(0)\n\tif (!d || !manager) {}\n\treturn 0;\n#else\n\tchar tray_string[100];\n\tAtom tray_manager;\n\tWindow tray_win;\n\n\tRAWFB_RET(0)\n\n\tif (manager) {\n\t\t*manager = None;\n\t}\n\tsprintf(tray_string, \"_NET_SYSTEM_TRAY_S%d\", scr);\n\n\ttray_manager = XInternAtom(d, tray_string, True);\n\tif (tray_manager == None) {\n\t\treturn 0;\n\t}\n\n\ttray_win = XGetSelectionOwner(d, tray_manager);\n\tif (manager) {\n\t\t*manager = tray_win;\n\t}\n\n\tif (tray_win == None) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n#endif\t/* NO_X11 */\n}"
  },
  {
    "function_name": "tray_embed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/gui.c",
    "lines": "107-214",
    "snippet": "int tray_embed(Window iconwin, int remove) {\n#if NO_X11\n\tRAWFB_RET(0)\n\tif (!iconwin || !remove) {}\n\treturn 0;\n#else\n\tXEvent ev;\n\tXErrorHandler old_handler;\n\tWindow manager;\n\tAtom xembed_info;\n\tAtom tatom;\n\tXWindowAttributes attr;\n\tlong info[2] = {XEMBED_VERSION, XEMBED_MAPPED};\n\tlong data = 0;\n\n\tRAWFB_RET(0)\n\n\tif (remove) {\n\t\tif (!valid_window(iconwin, &attr, 1)) {\n\t\t\treturn 0;\n\t\t}\n\t\ticonwin = tweak_tk_window_id(iconwin);\n\t\ttrapped_xerror = 0;\n\t\told_handler = XSetErrorHandler(trap_xerror);\n\n\t\t/*\n\t\t * unfortunately no desktops seem to obey this\n\t\t * part of the XEMBED spec yet...\n\t\t */\n\t\tXReparentWindow(dpy, iconwin, rootwin, 0, 0);\n\n\t\tXSetErrorHandler(old_handler);\n\t\tif (trapped_xerror) {\n\t\t\ttrapped_xerror = 0;\n\t\t\treturn 0;\n\t\t}\n\t\ttrapped_xerror = 0;\n\t\treturn 1;\n\t}\n\n\txembed_info = XInternAtom(dpy, \"_XEMBED_INFO\", False);\n\tif (xembed_info == None) {\n\t\treturn 0;\n\t}\n\n\tif (!tray_manager_running(dpy, &manager)) {\n\t\treturn 0;\n\t}\n\n\tmemset(&ev, 0, sizeof(ev));\n\tev.xclient.type = ClientMessage;\n\tev.xclient.window = manager;\n\tev.xclient.message_type = XInternAtom(dpy, \"_NET_SYSTEM_TRAY_OPCODE\",\n\t    False);\n\tev.xclient.format = 32;\n\tev.xclient.data.l[0] = CurrentTime;\n\tev.xclient.data.l[1] = SYSTEM_TRAY_REQUEST_DOCK;\n\tev.xclient.data.l[2] = iconwin;\n\tev.xclient.data.l[3] = 0;\n\tev.xclient.data.l[4] = 0;\n\n\tif (!valid_window(iconwin, &attr, 1)) {\n\t\treturn 0;\n\t}\n\n\ticonwin = tweak_tk_window_id(iconwin);\n\tev.xclient.data.l[2] = iconwin;\n\n\tXUnmapWindow(dpy, iconwin);\n\n\ttrapped_xerror = 0;\n\told_handler = XSetErrorHandler(trap_xerror);\n\n\tXSendEvent(dpy, manager, False, NoEventMask, &ev);\n\tXSync(dpy, False);\n\n\tif (trapped_xerror) {\n\t\tXSetErrorHandler(old_handler);\n\t\ttrapped_xerror = 0;\n\t\treturn 0;\n\t}\n\n\tXChangeProperty(dpy, iconwin, xembed_info, xembed_info, 32,\n\t    PropModeReplace, (unsigned char *)&info, 2);\n\n#if 0\n{\nXSizeHints *xszh = XAllocSizeHints();\nxszh->flags = PMinSize;\nxszh->min_width = 24;\nxszh->min_height = 24;\nXSetWMNormalHints(dpy, iconwin, xszh);\n}\n#endif\n\n\t/* kludge for KDE evidently needed... */\n\ttatom = XInternAtom(dpy, \"KWM_DOCKWINDOW\", False);\n\tXChangeProperty(dpy, iconwin, tatom, tatom, 32, PropModeReplace,\n\t    (unsigned char *)&data, 1);\n\ttatom = XInternAtom(dpy, \"_KDE_NET_WM_SYSTEM_TRAY_WINDOW_FOR\", False);\n\tXChangeProperty(dpy, iconwin, tatom, XA_WINDOW, 32, PropModeReplace,\n\t    (unsigned char *)&data, 1);\n\n\tXSetErrorHandler(old_handler);\n\ttrapped_xerror = 0;\n\treturn 1;\n#endif\t/* NO_X11 */\n}",
    "includes": [
      "#include \"tkx11vnc.h\"",
      "#include \"connections.h\"",
      "#include \"xwrappers.h\"",
      "#include \"cleanup.h\"",
      "#include \"remote.h\"",
      "#include \"win_utils.h\"",
      "#include \"xevents.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [
      "#define XEMBED_MAPPED  (1 << 0)",
      "#define XEMBED_VERSION 0",
      "#define SYSTEM_TRAY_REQUEST_DOCK    0"
    ],
    "globals_used": [
      "int tray_embed(Window iconwin, int remove);",
      "static int tray_manager_running(Display *d, Window *manager);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "XSetErrorHandler",
          "args": [
            "old_handler"
          ],
          "line": 210
        },
        "resolved": true,
        "details": {
          "function_name": "XSetErrorHandler",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/nox11_funcs.h",
          "lines": "2819-2821",
          "snippet": "XErrorHandler XSetErrorHandler (XErrorHandler h) {\n\treturn h;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "XErrorHandler XSetErrorHandler (XErrorHandler h) {\n\treturn h;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XChangeProperty",
          "args": [
            "dpy",
            "iconwin",
            "tatom",
            "XA_WINDOW",
            "32",
            "PropModeReplace",
            "(unsigned char *)&data",
            "1"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XInternAtom",
          "args": [
            "dpy",
            "\"_KDE_NET_WM_SYSTEM_TRAY_WINDOW_FOR\"",
            "False"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XChangeProperty",
          "args": [
            "dpy",
            "iconwin",
            "tatom",
            "tatom",
            "32",
            "PropModeReplace",
            "(unsigned char *)&data",
            "1"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XInternAtom",
          "args": [
            "dpy",
            "\"KWM_DOCKWINDOW\"",
            "False"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XSetWMNormalHints",
          "args": [
            "dpy",
            "iconwin",
            "xszh"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XAllocSizeHints",
          "args": [],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XChangeProperty",
          "args": [
            "dpy",
            "iconwin",
            "xembed_info",
            "xembed_info",
            "32",
            "PropModeReplace",
            "(unsigned char *)&info",
            "2"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XSync",
          "args": [
            "dpy",
            "False"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XSendEvent",
          "args": [
            "dpy",
            "manager",
            "False",
            "NoEventMask",
            "&ev"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XUnmapWindow",
          "args": [
            "dpy",
            "iconwin"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tweak_tk_window_id",
          "args": [
            "iconwin"
          ],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "tweak_tk_window_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/gui.c",
          "lines": "78-105",
          "snippet": "static Window tweak_tk_window_id(Window win) {\n#if NO_X11\n\tif (!win) {}\n\treturn None;\n#else\n\tchar *name = NULL;\n\tWindow parent, new_win;\n\n\tif (getenv(\"NO_TWEAK_TK_WINDOW_ID\")) {\n\t\treturn win;\n\t}\n\n\t/* hack for tk, does not report outermost window */\n\tnew_win = win;\n\tparent = parent_window(win, &name);\n\tif (parent && name != NULL) {\n\t\tlowercase(name);\n\t\tif (strstr(name, \"wish\") || strstr(name, \"x11vnc\")) {\n\t\t\tnew_win = parent;\n\t\t\trfbLog(\"tray_embed: using parent: %s\\n\", name);\n\t\t}\n\t}\n\tif (name != NULL) {\n\t\tXFree_wr(name);\n\t}\n\treturn new_win;\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"tkx11vnc.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"cleanup.h\"",
            "#include \"remote.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Window tweak_tk_window_id(Window win);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tkx11vnc.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"cleanup.h\"\n#include \"remote.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"x11vnc.h\"\n\nstatic Window tweak_tk_window_id(Window win);\n\nstatic Window tweak_tk_window_id(Window win) {\n#if NO_X11\n\tif (!win) {}\n\treturn None;\n#else\n\tchar *name = NULL;\n\tWindow parent, new_win;\n\n\tif (getenv(\"NO_TWEAK_TK_WINDOW_ID\")) {\n\t\treturn win;\n\t}\n\n\t/* hack for tk, does not report outermost window */\n\tnew_win = win;\n\tparent = parent_window(win, &name);\n\tif (parent && name != NULL) {\n\t\tlowercase(name);\n\t\tif (strstr(name, \"wish\") || strstr(name, \"x11vnc\")) {\n\t\t\tnew_win = parent;\n\t\t\trfbLog(\"tray_embed: using parent: %s\\n\", name);\n\t\t}\n\t}\n\tif (name != NULL) {\n\t\tXFree_wr(name);\n\t}\n\treturn new_win;\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "valid_window",
          "args": [
            "iconwin",
            "&attr",
            "1"
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "valid_window",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/win_utils.c",
          "lines": "92-140",
          "snippet": "int valid_window(Window win, XWindowAttributes *attr_ret, int bequiet) {\n\tXWindowAttributes attr, *pattr;\n#if !NO_X11\n\tXErrorHandler old_handler;\n\tint ok = 0;\n#endif\n\n\tif (attr_ret == NULL) {\n\t\tpattr = &attr;\n\t} else {\n\t\tpattr = attr_ret;\n\t}\n\n\tif (win == None) {\n\t\treturn 0;\n\t}\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\treturn macosx_valid_window(win, attr_ret);\n\t}\n#endif\n\n\tRAWFB_RET(0)\n\n#if NO_X11\n\tnox11_exit(1);\n\tif (!win || !attr_ret || !bequiet) {}\n\treturn 0;\n#else\n\n\told_handler = XSetErrorHandler(trap_xerror);\n\ttrapped_xerror = 0;\n\tif (XGetWindowAttributes(dpy, win, pattr)) {\n\t\tok = 1;\n\t}\n\tif (trapped_xerror && trapped_xerror_event) {\n\t\tif (! quiet && ! bequiet) {\n\t\t\trfbLog(\"valid_window: trapped XError: %s (0x%lx)\\n\",\n\t\t\t    xerror_string(trapped_xerror_event), win);\n\t\t}\n\t\tok = 0;\n\t}\n\tXSetErrorHandler(old_handler);\n\ttrapped_xerror = 0;\n\t\n\treturn ok;\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"win_utils.h\"",
            "#include \"macosx.h\"",
            "#include \"xrandr.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"cleanup.h\"",
            "#include \"winattr_t.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win_utils.h\"\n#include \"macosx.h\"\n#include \"xrandr.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"cleanup.h\"\n#include \"winattr_t.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nint valid_window(Window win, XWindowAttributes *attr_ret, int bequiet) {\n\tXWindowAttributes attr, *pattr;\n#if !NO_X11\n\tXErrorHandler old_handler;\n\tint ok = 0;\n#endif\n\n\tif (attr_ret == NULL) {\n\t\tpattr = &attr;\n\t} else {\n\t\tpattr = attr_ret;\n\t}\n\n\tif (win == None) {\n\t\treturn 0;\n\t}\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\treturn macosx_valid_window(win, attr_ret);\n\t}\n#endif\n\n\tRAWFB_RET(0)\n\n#if NO_X11\n\tnox11_exit(1);\n\tif (!win || !attr_ret || !bequiet) {}\n\treturn 0;\n#else\n\n\told_handler = XSetErrorHandler(trap_xerror);\n\ttrapped_xerror = 0;\n\tif (XGetWindowAttributes(dpy, win, pattr)) {\n\t\tok = 1;\n\t}\n\tif (trapped_xerror && trapped_xerror_event) {\n\t\tif (! quiet && ! bequiet) {\n\t\t\trfbLog(\"valid_window: trapped XError: %s (0x%lx)\\n\",\n\t\t\t    xerror_string(trapped_xerror_event), win);\n\t\t}\n\t\tok = 0;\n\t}\n\tXSetErrorHandler(old_handler);\n\ttrapped_xerror = 0;\n\t\n\treturn ok;\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "XInternAtom",
          "args": [
            "dpy",
            "\"_NET_SYSTEM_TRAY_OPCODE\"",
            "False"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&ev",
            "0",
            "sizeof(ev)"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tray_manager_running",
          "args": [
            "dpy",
            "&manager"
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "tray_manager_running",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/gui.c",
          "lines": "216-249",
          "snippet": "static int tray_manager_running(Display *d, Window *manager) {\n#if NO_X11\n\tRAWFB_RET(0)\n\tif (!d || !manager) {}\n\treturn 0;\n#else\n\tchar tray_string[100];\n\tAtom tray_manager;\n\tWindow tray_win;\n\n\tRAWFB_RET(0)\n\n\tif (manager) {\n\t\t*manager = None;\n\t}\n\tsprintf(tray_string, \"_NET_SYSTEM_TRAY_S%d\", scr);\n\n\ttray_manager = XInternAtom(d, tray_string, True);\n\tif (tray_manager == None) {\n\t\treturn 0;\n\t}\n\n\ttray_win = XGetSelectionOwner(d, tray_manager);\n\tif (manager) {\n\t\t*manager = tray_win;\n\t}\n\n\tif (tray_win == None) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"tkx11vnc.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"cleanup.h\"",
            "#include \"remote.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int tray_manager_running(Display *d, Window *manager);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tkx11vnc.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"cleanup.h\"\n#include \"remote.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"x11vnc.h\"\n\nstatic int tray_manager_running(Display *d, Window *manager);\n\nstatic int tray_manager_running(Display *d, Window *manager) {\n#if NO_X11\n\tRAWFB_RET(0)\n\tif (!d || !manager) {}\n\treturn 0;\n#else\n\tchar tray_string[100];\n\tAtom tray_manager;\n\tWindow tray_win;\n\n\tRAWFB_RET(0)\n\n\tif (manager) {\n\t\t*manager = None;\n\t}\n\tsprintf(tray_string, \"_NET_SYSTEM_TRAY_S%d\", scr);\n\n\ttray_manager = XInternAtom(d, tray_string, True);\n\tif (tray_manager == None) {\n\t\treturn 0;\n\t}\n\n\ttray_win = XGetSelectionOwner(d, tray_manager);\n\tif (manager) {\n\t\t*manager = tray_win;\n\t}\n\n\tif (tray_win == None) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "XInternAtom",
          "args": [
            "dpy",
            "\"_XEMBED_INFO\"",
            "False"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XReparentWindow",
          "args": [
            "dpy",
            "iconwin",
            "rootwin",
            "0",
            "0"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RAWFB_RET",
          "args": [
            "0"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RAWFB_RET",
          "args": [
            "0"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tkx11vnc.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"cleanup.h\"\n#include \"remote.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"x11vnc.h\"\n\n#define XEMBED_MAPPED  (1 << 0)\n#define XEMBED_VERSION 0\n#define SYSTEM_TRAY_REQUEST_DOCK    0\n\nint tray_embed(Window iconwin, int remove);\nstatic int tray_manager_running(Display *d, Window *manager);\n\nint tray_embed(Window iconwin, int remove) {\n#if NO_X11\n\tRAWFB_RET(0)\n\tif (!iconwin || !remove) {}\n\treturn 0;\n#else\n\tXEvent ev;\n\tXErrorHandler old_handler;\n\tWindow manager;\n\tAtom xembed_info;\n\tAtom tatom;\n\tXWindowAttributes attr;\n\tlong info[2] = {XEMBED_VERSION, XEMBED_MAPPED};\n\tlong data = 0;\n\n\tRAWFB_RET(0)\n\n\tif (remove) {\n\t\tif (!valid_window(iconwin, &attr, 1)) {\n\t\t\treturn 0;\n\t\t}\n\t\ticonwin = tweak_tk_window_id(iconwin);\n\t\ttrapped_xerror = 0;\n\t\told_handler = XSetErrorHandler(trap_xerror);\n\n\t\t/*\n\t\t * unfortunately no desktops seem to obey this\n\t\t * part of the XEMBED spec yet...\n\t\t */\n\t\tXReparentWindow(dpy, iconwin, rootwin, 0, 0);\n\n\t\tXSetErrorHandler(old_handler);\n\t\tif (trapped_xerror) {\n\t\t\ttrapped_xerror = 0;\n\t\t\treturn 0;\n\t\t}\n\t\ttrapped_xerror = 0;\n\t\treturn 1;\n\t}\n\n\txembed_info = XInternAtom(dpy, \"_XEMBED_INFO\", False);\n\tif (xembed_info == None) {\n\t\treturn 0;\n\t}\n\n\tif (!tray_manager_running(dpy, &manager)) {\n\t\treturn 0;\n\t}\n\n\tmemset(&ev, 0, sizeof(ev));\n\tev.xclient.type = ClientMessage;\n\tev.xclient.window = manager;\n\tev.xclient.message_type = XInternAtom(dpy, \"_NET_SYSTEM_TRAY_OPCODE\",\n\t    False);\n\tev.xclient.format = 32;\n\tev.xclient.data.l[0] = CurrentTime;\n\tev.xclient.data.l[1] = SYSTEM_TRAY_REQUEST_DOCK;\n\tev.xclient.data.l[2] = iconwin;\n\tev.xclient.data.l[3] = 0;\n\tev.xclient.data.l[4] = 0;\n\n\tif (!valid_window(iconwin, &attr, 1)) {\n\t\treturn 0;\n\t}\n\n\ticonwin = tweak_tk_window_id(iconwin);\n\tev.xclient.data.l[2] = iconwin;\n\n\tXUnmapWindow(dpy, iconwin);\n\n\ttrapped_xerror = 0;\n\told_handler = XSetErrorHandler(trap_xerror);\n\n\tXSendEvent(dpy, manager, False, NoEventMask, &ev);\n\tXSync(dpy, False);\n\n\tif (trapped_xerror) {\n\t\tXSetErrorHandler(old_handler);\n\t\ttrapped_xerror = 0;\n\t\treturn 0;\n\t}\n\n\tXChangeProperty(dpy, iconwin, xembed_info, xembed_info, 32,\n\t    PropModeReplace, (unsigned char *)&info, 2);\n\n#if 0\n{\nXSizeHints *xszh = XAllocSizeHints();\nxszh->flags = PMinSize;\nxszh->min_width = 24;\nxszh->min_height = 24;\nXSetWMNormalHints(dpy, iconwin, xszh);\n}\n#endif\n\n\t/* kludge for KDE evidently needed... */\n\ttatom = XInternAtom(dpy, \"KWM_DOCKWINDOW\", False);\n\tXChangeProperty(dpy, iconwin, tatom, tatom, 32, PropModeReplace,\n\t    (unsigned char *)&data, 1);\n\ttatom = XInternAtom(dpy, \"_KDE_NET_WM_SYSTEM_TRAY_WINDOW_FOR\", False);\n\tXChangeProperty(dpy, iconwin, tatom, XA_WINDOW, 32, PropModeReplace,\n\t    (unsigned char *)&data, 1);\n\n\tXSetErrorHandler(old_handler);\n\ttrapped_xerror = 0;\n\treturn 1;\n#endif\t/* NO_X11 */\n}"
  },
  {
    "function_name": "tweak_tk_window_id",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/gui.c",
    "lines": "78-105",
    "snippet": "static Window tweak_tk_window_id(Window win) {\n#if NO_X11\n\tif (!win) {}\n\treturn None;\n#else\n\tchar *name = NULL;\n\tWindow parent, new_win;\n\n\tif (getenv(\"NO_TWEAK_TK_WINDOW_ID\")) {\n\t\treturn win;\n\t}\n\n\t/* hack for tk, does not report outermost window */\n\tnew_win = win;\n\tparent = parent_window(win, &name);\n\tif (parent && name != NULL) {\n\t\tlowercase(name);\n\t\tif (strstr(name, \"wish\") || strstr(name, \"x11vnc\")) {\n\t\t\tnew_win = parent;\n\t\t\trfbLog(\"tray_embed: using parent: %s\\n\", name);\n\t\t}\n\t}\n\tif (name != NULL) {\n\t\tXFree_wr(name);\n\t}\n\treturn new_win;\n#endif\t/* NO_X11 */\n}",
    "includes": [
      "#include \"tkx11vnc.h\"",
      "#include \"connections.h\"",
      "#include \"xwrappers.h\"",
      "#include \"cleanup.h\"",
      "#include \"remote.h\"",
      "#include \"win_utils.h\"",
      "#include \"xevents.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Window tweak_tk_window_id(Window win);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "XFree_wr",
          "args": [
            "name"
          ],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "XFree_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "1664-1676",
          "snippet": "int XFree_wr(void *data) {\n\tif (data == NULL) {\n\t\treturn 1;\n\t}\n\tif (! dpy) {\n\t\treturn 1;\n\t}\n#if NO_X11\n\treturn 1;\n#else\n\treturn XFree(data);\n#endif\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void XTestDiscard_wr(Display *dpy);",
            "int XFree_wr(void *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nvoid XTestDiscard_wr(Display *dpy);\nint XFree_wr(void *data);\n\nint XFree_wr(void *data) {\n\tif (data == NULL) {\n\t\treturn 1;\n\t}\n\tif (! dpy) {\n\t\treturn 1;\n\t}\n#if NO_X11\n\treturn 1;\n#else\n\treturn XFree(data);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"tray_embed: using parent: %s\\n\"",
            "name"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "name",
            "\"x11vnc\""
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "name",
            "\"wish\""
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lowercase",
          "args": [
            "name"
          ],
          "line": 94
        },
        "resolved": true,
        "details": {
          "function_name": "lowercase",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "136-146",
          "snippet": "void lowercase(char *str) {\n\tchar *p;\n\tif (str == NULL) {\n\t\treturn;\n\t}\n\tp = str;\n\twhile (*p != '\\0') {\n\t\t*p = tolower((unsigned char) (*p));\n\t\tp++;\n\t}\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void lowercase(char *str);",
            "void uppercase(char *str);",
            "char *lblanks(char *str);",
            "void strzero(char *str);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nvoid lowercase(char *str);\nvoid uppercase(char *str);\nchar *lblanks(char *str);\nvoid strzero(char *str);\n\nvoid lowercase(char *str) {\n\tchar *p;\n\tif (str == NULL) {\n\t\treturn;\n\t}\n\tp = str;\n\twhile (*p != '\\0') {\n\t\t*p = tolower((unsigned char) (*p));\n\t\tp++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "parent_window",
          "args": [
            "win",
            "&name"
          ],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "parent_window",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/win_utils.c",
          "lines": "51-89",
          "snippet": "Window parent_window(Window win, char **name) {\n#if !NO_X11\n\tWindow r, parent;\n\tWindow *list;\n\tXErrorHandler old_handler;\n\tunsigned int nchild;\n\tint rc;\n#endif\n\n\tif (name != NULL) {\n\t\t*name = NULL;\n\t}\n\tRAWFB_RET(None)\n#if NO_X11\n\tnox11_exit(1);\n\tif (!name || !win) {}\n\treturn None;\n#else\n\n\told_handler = XSetErrorHandler(trap_xerror);\n\ttrapped_xerror = 0;\n\trc = XQueryTree_wr(dpy, win, &r, &parent, &list, &nchild);\n\tXSetErrorHandler(old_handler);\n\n\tif (! rc || trapped_xerror) {\n\t\ttrapped_xerror = 0;\n\t\treturn None;\n\t}\n\ttrapped_xerror = 0;\n\n\tif (list) {\n\t\tXFree_wr(list);\n\t}\n\tif (parent && name) {\n\t\tXFetchName(dpy, parent, name);\n\t}\n\treturn parent;\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"win_utils.h\"",
            "#include \"macosx.h\"",
            "#include \"xrandr.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"cleanup.h\"",
            "#include \"winattr_t.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win_utils.h\"\n#include \"macosx.h\"\n#include \"xrandr.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"cleanup.h\"\n#include \"winattr_t.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nWindow parent_window(Window win, char **name) {\n#if !NO_X11\n\tWindow r, parent;\n\tWindow *list;\n\tXErrorHandler old_handler;\n\tunsigned int nchild;\n\tint rc;\n#endif\n\n\tif (name != NULL) {\n\t\t*name = NULL;\n\t}\n\tRAWFB_RET(None)\n#if NO_X11\n\tnox11_exit(1);\n\tif (!name || !win) {}\n\treturn None;\n#else\n\n\told_handler = XSetErrorHandler(trap_xerror);\n\ttrapped_xerror = 0;\n\trc = XQueryTree_wr(dpy, win, &r, &parent, &list, &nchild);\n\tXSetErrorHandler(old_handler);\n\n\tif (! rc || trapped_xerror) {\n\t\ttrapped_xerror = 0;\n\t\treturn None;\n\t}\n\ttrapped_xerror = 0;\n\n\tif (list) {\n\t\tXFree_wr(list);\n\t}\n\tif (parent && name) {\n\t\tXFetchName(dpy, parent, name);\n\t}\n\treturn parent;\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"NO_TWEAK_TK_WINDOW_ID\""
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tkx11vnc.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"cleanup.h\"\n#include \"remote.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"x11vnc.h\"\n\nstatic Window tweak_tk_window_id(Window win);\n\nstatic Window tweak_tk_window_id(Window win) {\n#if NO_X11\n\tif (!win) {}\n\treturn None;\n#else\n\tchar *name = NULL;\n\tWindow parent, new_win;\n\n\tif (getenv(\"NO_TWEAK_TK_WINDOW_ID\")) {\n\t\treturn win;\n\t}\n\n\t/* hack for tk, does not report outermost window */\n\tnew_win = win;\n\tparent = parent_window(win, &name);\n\tif (parent && name != NULL) {\n\t\tlowercase(name);\n\t\tif (strstr(name, \"wish\") || strstr(name, \"x11vnc\")) {\n\t\t\tnew_win = parent;\n\t\t\trfbLog(\"tray_embed: using parent: %s\\n\", name);\n\t\t}\n\t}\n\tif (name != NULL) {\n\t\tXFree_wr(name);\n\t}\n\treturn new_win;\n#endif\t/* NO_X11 */\n}"
  },
  {
    "function_name": "get_gui_code",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/gui.c",
    "lines": "74-76",
    "snippet": "char *get_gui_code(void) {\n\treturn gui_code;\n}",
    "includes": [
      "#include \"tkx11vnc.h\"",
      "#include \"connections.h\"",
      "#include \"xwrappers.h\"",
      "#include \"cleanup.h\"",
      "#include \"remote.h\"",
      "#include \"win_utils.h\"",
      "#include \"xevents.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "char *get_gui_code(void);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"tkx11vnc.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"cleanup.h\"\n#include \"remote.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"x11vnc.h\"\n\nchar *get_gui_code(void);\n\nchar *get_gui_code(void) {\n\treturn gui_code;\n}"
  }
]