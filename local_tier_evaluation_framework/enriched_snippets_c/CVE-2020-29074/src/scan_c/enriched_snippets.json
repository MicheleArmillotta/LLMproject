[
  {
    "function_name": "scan_for_updates",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/scan.c",
    "lines": "3356-3674",
    "snippet": "int scan_for_updates(int count_only) {\n\tint i, tile_count, tile_diffs;\n\tint old_copy_tile;\n\tdouble frac1 = 0.1;   /* tweak parameter to try a 2nd scan_display() */\n\tdouble frac2 = 0.35;  /* or 3rd */\n\tdouble frac3 = 0.02;  /* do scan_display() again after copy_tiles() */\n\tstatic double last_poll = 0.0;\n\n\tif (unixpw_in_progress) return 0;\n \n\tif (slow_fb > 0.0) {\n\t\tdouble now = dnow();\n\t\tif (now < last_poll + slow_fb) {\n\t\t\treturn 0;\n\t\t}\n\t\tlast_poll = now;\n\t}\n\n\tfor (i=0; i < ntiles; i++) {\n\t\ttile_has_diff[i] = 0;\n\t\ttile_has_xdamage_diff[i] = 0;\n\t\ttile_tried[i] = 0;\n\t\ttile_copied[i] = 0;\n\t}\n\tfor (i=0; i < ntiles_y; i++) {\n\t\t/* could be useful, currently not used */\n\t\ttile_row_has_xdamage_diff[i] = 0;\n\t}\n\txdamage_tile_count = 0;\n\n\t/*\n\t * n.b. this program has only been tested so far with\n\t * tile_x = tile_y = NSCAN = 32!\n\t */\n\n\tif (!count_only) {\n\t\tscan_count++;\n\t\tscan_count %= NSCAN;\n\n\t\t/* some periodic maintenance */\n\t\tif (subwin && scan_count % 4 == 0) {\n\t\t\tset_offset();\t/* follow the subwindow */\n\t\t}\n\t\tif (indexed_color && scan_count % 4 == 0) {\n\t\t\t/* check for changed colormap */\n\t\t\tset_colormap(0);\n\t\t}\n\t\tif (cmap8to24 && scan_count % 1 == 0) {\n\t\t\tcheck_for_multivis();\n\t\t}\n#ifdef MACOSX\n\t\tif (macosx_console) {\n\t\t\tmacosx_event_loop();\n\t\t}\n#endif\n\t\tif (use_xdamage) {\n\t\t\t/* first pass collecting DAMAGE events: */\n#ifdef MACOSX\n\t\t\tif (macosx_console) {\n\t\t\t\tcollect_non_X_xdamage(-1, -1, -1, -1, 0);\n\t\t\t} else \n#endif\n\t\t\t{\n\t\t\t\tif (rawfb_vnc_reflect) {\n\t\t\t\t\tcollect_non_X_xdamage(-1, -1, -1, -1, 0);\n\t\t\t\t} else {\n\t\t\t\t\tcollect_xdamage(scan_count, 0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n#define SCAN_FATAL(x) \\\n\tif (x < 0) { \\\n\t\tscan_in_progress = 0; \\\n\t\tfb_copy_in_progress = 0; \\\n\t\treturn 0; \\\n\t}\n\n\t/* scan with the initial y to the jitter value from scanlines: */\n\tscan_in_progress = 1;\n\ttile_count = scan_display(scanlines[scan_count], 0);\n\tSCAN_FATAL(tile_count);\n\n\t/*\n\t * we do the XDAMAGE here too since after scan_display()\n\t * there is a better chance we have received the events from\n\t * the X server (otherwise the DAMAGE events will be processed\n\t * in the *next* call, usually too late and wasteful since\n\t * the unchanged tiles are read in again).\n\t */\n\tif (use_xdamage) {\n#ifdef MACOSX\n\t\tif (macosx_console) {\n\t\t\t;\n\t\t} else \n#endif\n\t\t{\n\t\t\tif (rawfb_vnc_reflect) {\n\t\t\t\t;\n\t\t\t} else {\n\t\t\t\tcollect_xdamage(scan_count, 1);\n\t\t\t}\n\t\t}\n\t}\n\tif (count_only) {\n\t\tscan_in_progress = 0;\n\t\tfb_copy_in_progress = 0;\n\t\treturn tile_count;\n\t}\n\n\tif (xdamage_tile_count) {\n\t\t/* pick up \"known\" damaged tiles we missed in scan_display() */\n\t\tfor (i=0; i < ntiles; i++) {\n\t\t\tif (tile_has_diff[i]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (tile_has_xdamage_diff[i]) {\n\t\t\t\ttile_has_diff[i] = 1;\n\t\t\t\tif (tile_has_xdamage_diff[i] == 1) {\n\t\t\t\t\ttile_has_xdamage_diff[i] = 2;\n\t\t\t\t\ttile_count++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (dpy && use_xdamage == 1) {\n\t\tstatic time_t last_xd_check = 0;\n\t\tif (time(NULL) > last_xd_check + 2) {\n\t\t\tint cp = (scan_count + 3) % NSCAN;\n\t\t\txd_do_check = 1;\n\t\t\ttile_count = scan_display(scanlines[cp], 0);\n\t\t\txd_do_check = 0;\n\t\t\tSCAN_FATAL(tile_count);\n\t\t\tlast_xd_check = time(NULL);\n\t\t\tif (xd_samples > 200) {\n\t\t\t\tstatic int bad = 0;\n\t\t\t\tif (xd_misses > (20 * xd_samples) / 100) {\n\t\t\t\t\trfbLog(\"XDAMAGE is not working well... misses: %d/%d\\n\", xd_misses, xd_samples);\n\t\t\t\t\trfbLog(\"Maybe an OpenGL app like Beryl or Compiz is the problem?\\n\");\n\t\t\t\t\trfbLog(\"Use x11vnc -noxdamage or disable the Beryl/Compiz app.\\n\");\n\t\t\t\t\trfbLog(\"To disable this check and warning specify -xdamage twice.\\n\");\n\t\t\t\t\tif (++bad >= 10) {\n\t\t\t\t\t\trfbLog(\"XDAMAGE appears broken (OpenGL app?), turning it off.\\n\");\n\t\t\t\t\t\tuse_xdamage = 0;\n\t\t\t\t\t\tinitialize_xdamage();\n\t\t\t\t\t\tdestroy_xdamage_if_needed();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\txd_samples = 0;\n\t\t\t\txd_misses = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tnap_set(tile_count);\n\n\tif (fs_factor && frac1 >= fs_frac) {\n\t\t/* make frac1 < fs_frac if fullscreen updates are enabled */\n\t\tfrac1 = fs_frac/2.0;\n\t}\n\n\tif (tile_count > frac1 * ntiles) {\n\t\t/*\n\t\t * many tiles have changed, so try a rescan (since it should\n\t\t * be short compared to the many upcoming copy_tiles() calls)\n\t\t */\n\n\t\t/* this check is done to skip the extra scan_display() call */\n\t\tif (! fs_factor || tile_count <= fs_frac * ntiles) {\n\t\t\tint cp, tile_count_old = tile_count;\n\t\t\t\n\t\t\t/* choose a different y shift for the 2nd scan: */\n\t\t\tcp = (NSCAN - scan_count) % NSCAN;\n\n\t\t\ttile_count = scan_display(scanlines[cp], 1);\n\t\t\tSCAN_FATAL(tile_count);\n\n\t\t\tif (tile_count >= (1 + frac2) * tile_count_old) {\n\t\t\t\t/* on a roll... do a 3rd scan */\n\t\t\t\tcp = (NSCAN - scan_count + 7) % NSCAN;\n\t\t\t\ttile_count = scan_display(scanlines[cp], 1);\n\t\t\t\tSCAN_FATAL(tile_count);\n\t\t\t}\n\t\t}\n\t\tscan_in_progress = 0;\n\n\t\t/*\n\t\t * At some number of changed tiles it is better to just\n\t\t * copy the full screen at once.  I.e. time = c1 + m * r1\n\t\t * where m is number of tiles, r1 is the copy_tiles()\n\t\t * time, and c1 is the scan_display() time: for some m\n\t\t * it crosses the full screen update time.\n\t\t *\n\t\t * We try to predict that crossover with the fs_frac\n\t\t * fudge factor... seems to be about 1/2 the total number\n\t\t * of tiles.  n.b. this ignores network bandwidth,\n\t\t * compression time etc...\n\t\t *\n\t\t * Use -fs 1.0 to disable on slow links.\n\t\t */\n\t\tif (fs_factor && tile_count > fs_frac * ntiles) {\n\t\t\tint cs;\n\t\t\tfb_copy_in_progress = 1;\n\t\t\tcs = copy_screen();\n\t\t\tfb_copy_in_progress = 0;\n\t\t\tSCAN_FATAL(cs);\n\t\t\tif (use_threads && pointer_mode != 1) {\n\t\t\t\tpointer_event(-1, 0, 0, NULL);\n\t\t\t}\n\t\t\tnap_check(tile_count);\n\t\t\treturn tile_count;\n\t\t}\n\t}\n\tscan_in_progress = 0;\n\n\t/* copy all tiles with differences from display to rfb framebuffer: */\n\tfb_copy_in_progress = 1;\n\n\tif (single_copytile || tile_shm_count < ntiles_x) {\n\t\t/*\n\t\t * Old way, copy I/O one tile at a time.\n\t\t */\n\t\told_copy_tile = 1;\n\t} else {\n\t\t/* \n\t\t * New way, does runs of horizontal tiles at once.\n\t\t * Note that below, for simplicity, the extra tile finding\n\t\t * (e.g. copy_tiles_backward_pass) is done the old way.\n\t\t */\n\t\told_copy_tile = 0;\n\t}\n\n\tif (unixpw_in_progress) return 0;\n\n\tif (old_copy_tile) {\n\t\ttile_diffs = copy_all_tiles();\n\t} else {\n\t\ttile_diffs = copy_all_tile_runs();\n\t}\n\tSCAN_FATAL(tile_diffs);\n\n\t/*\n\t * This backward pass for upward and left tiles complements what\n\t * was done in copy_all_tiles() for downward and right tiles.\n\t */\n\ttile_diffs = copy_tiles_backward_pass();\n\tSCAN_FATAL(tile_diffs);\n\n\tif (tile_diffs > frac3 * ntiles) {\n\t\t/*\n\t\t * we spent a lot of time in those copy_tiles, run\n\t\t * another scan, maybe more of the screen changed.\n\t\t */\n\t\tint cp = (NSCAN - scan_count + 13) % NSCAN;\n\n\t\tscan_in_progress = 1;\n\t\ttile_count = scan_display(scanlines[cp], 1);\n\t\tSCAN_FATAL(tile_count);\n\t\tscan_in_progress = 0;\n\n\t\ttile_diffs = copy_tiles_additional_pass();\n\t\tSCAN_FATAL(tile_diffs);\n\t}\n\n\t/* Given enough tile diffs, try the islands: */\n\tif (grow_fill && tile_diffs > 4) {\n\t\ttile_diffs = grow_islands();\n\t}\n\tSCAN_FATAL(tile_diffs);\n\n\t/* Given enough tile diffs, try the gaps: */\n\tif (gaps_fill && tile_diffs > 4) {\n\t\ttile_diffs = fill_tile_gaps();\n\t}\n\tSCAN_FATAL(tile_diffs);\n\n\tfb_copy_in_progress = 0;\n\tif (use_threads && pointer_mode != 1) {\n\t\t/*\n\t\t * tell the pointer handler it can process any queued\n\t\t * pointer events:\n\t\t */\n\t\tpointer_event(-1, 0, 0, NULL);\n\t}\n\n\tif (blackouts) {\n\t\t/* ignore any diffs in completely covered tiles */\n\t\tint x, y, n;\n\t\tfor (y=0; y < ntiles_y; y++) {\n\t\t\tfor (x=0; x < ntiles_x; x++) {\n\t\t\t\tn = x + y * ntiles_x;\n\t\t\t\tif (tile_blackout[n].cover == 2) {\n\t\t\t\t\ttile_has_diff[n] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\thint_updates();\t/* use x0rfbserver hints algorithm */\n\n\t/* Work around threaded rfbProcessClientMessage() calls timeouts */\n\tif (use_threads) {\n\t\tping_clients(tile_diffs);\n\t} else if (saw_ultra_chat || saw_ultra_file) {\n\t\tping_clients(-1);\n\t} else if (use_openssl && !tile_diffs) {\n\t\tping_clients(0);\n\t}\n\t/* -ping option: */\n\tif (ping_interval) {\n\t\tint td = ping_interval > 0 ? ping_interval : -ping_interval;\n\t\tping_clients(-td);\n\t}\n\n\n\tnap_check(tile_diffs);\n\treturn tile_diffs;\n}",
    "includes": [
      "#include <default8x16.h>",
      "#include \"userinput.h\"",
      "#include \"macosx.h\"",
      "#include \"screen.h\"",
      "#include \"unixpw.h\"",
      "#include \"cleanup.h\"",
      "#include \"pointer.h\"",
      "#include \"screen.h\"",
      "#include \"8to24.h\"",
      "#include \"win_utils.h\"",
      "#include \"xrandr.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"xinerama.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int copy_screen(void);",
      "void set_offset(void);",
      "int scan_for_updates(int count_only);",
      "static void hint_updates(void);",
      "static int copy_all_tiles(void);",
      "static int copy_all_tile_runs(void);",
      "static int copy_tiles_backward_pass(void);",
      "static int copy_tiles_additional_pass(void);",
      "static int fill_tile_gaps(void);",
      "static int island_try(int x, int y, int u, int v, int *run);",
      "static int grow_islands(void);",
      "static int blackout_line_skip(int n, int x, int y, int rescan,\n    int *tile_count);",
      "static int scan_display(int ystart, int rescan);",
      "static int scan_count = 0;",
      "static int scan_in_progress = 0;",
      "static int fs_factor = 0;",
      "static int xd_samples = 0, xd_misses = 0, xd_do_check = 0;",
      "int scanlines[NSCAN] = {\n\t 0, 16,  8, 24,  4, 20, 12, 28,\n\t10, 26, 18,  2, 22,  6, 30, 14,\n\t 1, 17,  9, 25,  7, 23, 15, 31,\n\t19,  3, 27, 11, 29, 13,  5, 21\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nap_check",
          "args": [
            "tile_diffs"
          ],
          "line": 3672
        },
        "resolved": true,
        "details": {
          "function_name": "nap_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/scan.c",
          "lines": "2954-3011",
          "snippet": "static void nap_check(int tile_cnt) {\n\ttime_t now;\n\n\tnap_diff_count += tile_cnt;\n\n\tif (! take_naps) {\n\t\treturn;\n\t}\n\n\tnow = time(NULL);\n\n\tif (screen_blank > 0) {\n\t\tint dt_ev, dt_fbu;\n\t\tstatic int ms = 0;\n\t\tif (ms == 0) {\n\t\t\tms = 2000;\n\t\t\tif (getenv(\"X11VNC_SB_FACTOR\")) {\n\t\t\t\tms = ms * atof(getenv(\"X11VNC_SB_FACTOR\"));\n\t\t\t}\n\t\t\tif (ms <= 0) {\n\t\t\t\tms = 2000;\n\t\t\t}\n\t\t}\n\n\t\t/* if no activity, pause here for a second or so. */\n\t\tdt_ev  = (int) (now - last_event);\n\t\tdt_fbu = (int) (now - last_fb_bytes_sent);\n\t\tif (dt_fbu > screen_blank) {\n\t\t\t/* sleep longer for no fb requests */\n\t\t\tif (debug_tiles > 1) {\n\t\t\t\tfprintf(stderr, \"screen blank sleep1: %d ms / 16, load: %s\\n\", 2 * ms, get_load());\n\t\t\t}\n\t\t\tnap_sleep(2 * ms, 16);\n\t\t\treturn;\n\t\t}\n\t\tif (dt_ev > screen_blank) {\n\t\t\tif (debug_tiles > 1) {\n\t\t\t\tfprintf(stderr, \"screen blank sleep2: %d ms / 8, load: %s\\n\", ms, get_load());\n\t\t\t}\n\t\t\tnap_sleep(ms, 8);\n\t\t\treturn;\n\t\t}\n\t}\n\tif (naptile && nap_ok && tile_cnt < naptile) {\n\t\tint ms = napfac * waitms;\n\t\tms = ms > napmax ? napmax : ms;\n\t\tif (now - last_input <= 3) {\n\t\t\tnap_ok = 0;\n\t\t} else if (now - last_local_input <= 3) {\n\t\t\tnap_ok = 0;\n\t\t} else {\n\t\t\tif (debug_tiles > 1) {\n\t\t\t\tfprintf(stderr, \"nap_check sleep: %d ms / 1, load: %s\\n\", ms, get_load());\n\t\t\t}\n\t\t\tnap_sleep(ms, 1);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <default8x16.h>",
            "#include \"userinput.h\"",
            "#include \"macosx.h\"",
            "#include \"screen.h\"",
            "#include \"unixpw.h\"",
            "#include \"cleanup.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"8to24.h\"",
            "#include \"win_utils.h\"",
            "#include \"xrandr.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void nap_set(int tile_cnt);",
            "static void nap_check(int tile_cnt);",
            "static void ping_clients(int tile_cnt);",
            "int nap_ok = 0;",
            "static int nap_diff_count = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <default8x16.h>\n#include \"userinput.h\"\n#include \"macosx.h\"\n#include \"screen.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"8to24.h\"\n#include \"win_utils.h\"\n#include \"xrandr.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nstatic void nap_set(int tile_cnt);\nstatic void nap_check(int tile_cnt);\nstatic void ping_clients(int tile_cnt);\nint nap_ok = 0;\nstatic int nap_diff_count = 0;\n\nstatic void nap_check(int tile_cnt) {\n\ttime_t now;\n\n\tnap_diff_count += tile_cnt;\n\n\tif (! take_naps) {\n\t\treturn;\n\t}\n\n\tnow = time(NULL);\n\n\tif (screen_blank > 0) {\n\t\tint dt_ev, dt_fbu;\n\t\tstatic int ms = 0;\n\t\tif (ms == 0) {\n\t\t\tms = 2000;\n\t\t\tif (getenv(\"X11VNC_SB_FACTOR\")) {\n\t\t\t\tms = ms * atof(getenv(\"X11VNC_SB_FACTOR\"));\n\t\t\t}\n\t\t\tif (ms <= 0) {\n\t\t\t\tms = 2000;\n\t\t\t}\n\t\t}\n\n\t\t/* if no activity, pause here for a second or so. */\n\t\tdt_ev  = (int) (now - last_event);\n\t\tdt_fbu = (int) (now - last_fb_bytes_sent);\n\t\tif (dt_fbu > screen_blank) {\n\t\t\t/* sleep longer for no fb requests */\n\t\t\tif (debug_tiles > 1) {\n\t\t\t\tfprintf(stderr, \"screen blank sleep1: %d ms / 16, load: %s\\n\", 2 * ms, get_load());\n\t\t\t}\n\t\t\tnap_sleep(2 * ms, 16);\n\t\t\treturn;\n\t\t}\n\t\tif (dt_ev > screen_blank) {\n\t\t\tif (debug_tiles > 1) {\n\t\t\t\tfprintf(stderr, \"screen blank sleep2: %d ms / 8, load: %s\\n\", ms, get_load());\n\t\t\t}\n\t\t\tnap_sleep(ms, 8);\n\t\t\treturn;\n\t\t}\n\t}\n\tif (naptile && nap_ok && tile_cnt < naptile) {\n\t\tint ms = napfac * waitms;\n\t\tms = ms > napmax ? napmax : ms;\n\t\tif (now - last_input <= 3) {\n\t\t\tnap_ok = 0;\n\t\t} else if (now - last_local_input <= 3) {\n\t\t\tnap_ok = 0;\n\t\t} else {\n\t\t\tif (debug_tiles > 1) {\n\t\t\t\tfprintf(stderr, \"nap_check sleep: %d ms / 1, load: %s\\n\", ms, get_load());\n\t\t\t}\n\t\t\tnap_sleep(ms, 1);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ping_clients",
          "args": [
            "-td"
          ],
          "line": 3668
        },
        "resolved": true,
        "details": {
          "function_name": "ping_clients",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/scan.c",
          "lines": "3017-3039",
          "snippet": "static void ping_clients(int tile_cnt) {\n\tstatic time_t last_send = 0;\n\ttime_t now = time(NULL);\n\n\tif (rfbMaxClientWait < 20000) {\n\t\trfbMaxClientWait = 20000;\n\t\trfbLog(\"reset rfbMaxClientWait to %d msec.\\n\",\n\t\t    rfbMaxClientWait);\n\t}\n\tif (tile_cnt > 0) {\n\t\tlast_send = now;\n\t} else if (tile_cnt < 0) {\n\t\t/* negative tile_cnt is -ping case */\n\t\tif (now >= last_send - tile_cnt) {\n\t\t\tmark_rect_as_modified(0, 0, 1, 1, 1);\n\t\t\tlast_send = now;\n\t\t}\n\t} else if (now - last_send > 5) {\n\t\t/* Send small heartbeat to client */\n\t\tmark_rect_as_modified(0, 0, 1, 1, 1);\n\t\tlast_send = now;\n\t}\n}",
          "includes": [
            "#include <default8x16.h>",
            "#include \"userinput.h\"",
            "#include \"macosx.h\"",
            "#include \"screen.h\"",
            "#include \"unixpw.h\"",
            "#include \"cleanup.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"8to24.h\"",
            "#include \"win_utils.h\"",
            "#include \"xrandr.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void nap_set(int tile_cnt);",
            "static void nap_check(int tile_cnt);",
            "static void ping_clients(int tile_cnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <default8x16.h>\n#include \"userinput.h\"\n#include \"macosx.h\"\n#include \"screen.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"8to24.h\"\n#include \"win_utils.h\"\n#include \"xrandr.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nstatic void nap_set(int tile_cnt);\nstatic void nap_check(int tile_cnt);\nstatic void ping_clients(int tile_cnt);\n\nstatic void ping_clients(int tile_cnt) {\n\tstatic time_t last_send = 0;\n\ttime_t now = time(NULL);\n\n\tif (rfbMaxClientWait < 20000) {\n\t\trfbMaxClientWait = 20000;\n\t\trfbLog(\"reset rfbMaxClientWait to %d msec.\\n\",\n\t\t    rfbMaxClientWait);\n\t}\n\tif (tile_cnt > 0) {\n\t\tlast_send = now;\n\t} else if (tile_cnt < 0) {\n\t\t/* negative tile_cnt is -ping case */\n\t\tif (now >= last_send - tile_cnt) {\n\t\t\tmark_rect_as_modified(0, 0, 1, 1, 1);\n\t\t\tlast_send = now;\n\t\t}\n\t} else if (now - last_send > 5) {\n\t\t/* Send small heartbeat to client */\n\t\tmark_rect_as_modified(0, 0, 1, 1, 1);\n\t\tlast_send = now;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hint_updates",
          "args": [],
          "line": 3655
        },
        "resolved": true,
        "details": {
          "function_name": "hint_updates",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/scan.c",
          "lines": "584-632",
          "snippet": "static void hint_updates(void) {\n\thint_t hint;\n\tint x, y, i, n, ty, th, tx, tw;\n\tint hint_count = 0, in_run = 0;\n\n\thint.x = hint.y = hint.w = hint.h = 0;\n\n\tfor (y=0; y < ntiles_y; y++) {\n\t\tfor (x=0; x < ntiles_x; x++) {\n\t\t\tn = x + y * ntiles_x;\n\n\t\t\tif (tile_has_diff[n]) {\n\t\t\t\tty = tile_region[n].first_line;\n\t\t\t\tth = tile_region[n].last_line - ty + 1;\n\n\t\t\t\ttx = tile_region[n].first_x;\n\t\t\t\ttw = tile_region[n].last_x - tx + 1;\n\t\t\t\tif (tx < 0) {\n\t\t\t\t\ttx = 0;\n\t\t\t\t\ttw = tile_x;\n\t\t\t\t}\n\n\t\t\t\tif (! in_run) {\n\t\t\t\t\tcreate_tile_hint( x * tile_x + tx,\n\t\t\t\t\t    y * tile_y + ty, tw, th, &hint);\n\t\t\t\t\tin_run = 1;\n\t\t\t\t} else {\n\t\t\t\t\textend_tile_hint( x * tile_x + tx,\n\t\t\t\t\t    y * tile_y + ty, tw, th, &hint);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (in_run) {\n\t\t\t\t\t/* end of a row run of altered tiles: */\n\t\t\t\t\tsave_hint(hint, hint_count++);\n\t\t\t\t\tin_run = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (in_run) {\t/* save the last row run */\n\t\t\tsave_hint(hint, hint_count++);\n\t\t\tin_run = 0;\n\t\t}\n\t}\n\n\tfor (i=0; i < hint_count; i++) {\n\t\t/* pass update info to vnc: */\n\t\tmark_hint(hint_list[i]);\n\t}\n}",
          "includes": [
            "#include <default8x16.h>",
            "#include \"userinput.h\"",
            "#include \"macosx.h\"",
            "#include \"screen.h\"",
            "#include \"unixpw.h\"",
            "#include \"cleanup.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"8to24.h\"",
            "#include \"win_utils.h\"",
            "#include \"xrandr.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void create_tile_hint(int x, int y, int tw, int th, hint_t *hint);",
            "static void extend_tile_hint(int x, int y, int tw, int th, hint_t *hint);",
            "static void hint_updates(void);",
            "static void mark_hint(hint_t hint);",
            "static int island_try(int x, int y, int u, int v, int *run);",
            "static hint_t *hint_list;",
            "static region_t *tile_region;",
            "static int *first_line = NULL, *last_line = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <default8x16.h>\n#include \"userinput.h\"\n#include \"macosx.h\"\n#include \"screen.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"8to24.h\"\n#include \"win_utils.h\"\n#include \"xrandr.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nstatic void create_tile_hint(int x, int y, int tw, int th, hint_t *hint);\nstatic void extend_tile_hint(int x, int y, int tw, int th, hint_t *hint);\nstatic void hint_updates(void);\nstatic void mark_hint(hint_t hint);\nstatic int island_try(int x, int y, int u, int v, int *run);\nstatic hint_t *hint_list;\nstatic region_t *tile_region;\nstatic int *first_line = NULL, *last_line = NULL;\n\nstatic void hint_updates(void) {\n\thint_t hint;\n\tint x, y, i, n, ty, th, tx, tw;\n\tint hint_count = 0, in_run = 0;\n\n\thint.x = hint.y = hint.w = hint.h = 0;\n\n\tfor (y=0; y < ntiles_y; y++) {\n\t\tfor (x=0; x < ntiles_x; x++) {\n\t\t\tn = x + y * ntiles_x;\n\n\t\t\tif (tile_has_diff[n]) {\n\t\t\t\tty = tile_region[n].first_line;\n\t\t\t\tth = tile_region[n].last_line - ty + 1;\n\n\t\t\t\ttx = tile_region[n].first_x;\n\t\t\t\ttw = tile_region[n].last_x - tx + 1;\n\t\t\t\tif (tx < 0) {\n\t\t\t\t\ttx = 0;\n\t\t\t\t\ttw = tile_x;\n\t\t\t\t}\n\n\t\t\t\tif (! in_run) {\n\t\t\t\t\tcreate_tile_hint( x * tile_x + tx,\n\t\t\t\t\t    y * tile_y + ty, tw, th, &hint);\n\t\t\t\t\tin_run = 1;\n\t\t\t\t} else {\n\t\t\t\t\textend_tile_hint( x * tile_x + tx,\n\t\t\t\t\t    y * tile_y + ty, tw, th, &hint);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (in_run) {\n\t\t\t\t\t/* end of a row run of altered tiles: */\n\t\t\t\t\tsave_hint(hint, hint_count++);\n\t\t\t\t\tin_run = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (in_run) {\t/* save the last row run */\n\t\t\tsave_hint(hint, hint_count++);\n\t\t\tin_run = 0;\n\t\t}\n\t}\n\n\tfor (i=0; i < hint_count; i++) {\n\t\t/* pass update info to vnc: */\n\t\tmark_hint(hint_list[i]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pointer_event",
          "args": [
            "-1",
            "0",
            "0",
            "NULL"
          ],
          "line": 3639
        },
        "resolved": true,
        "details": {
          "function_name": "pointer_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/pointer.c",
          "lines": "700-1005",
          "snippet": "void pointer_event(int mask, int x, int y, rfbClientPtr client) {\n\tallowed_input_t input;\n\tint sent = 0, buffer_it = 0;\n\tdouble now;\n\tClientData *cd = NULL;\n        \n\tif(client && client->clientData)\n\t  cd = (ClientData *) client->clientData;\n\t\n\t/* needed to allow multiple dragging actions at once */\n        if(client && use_multipointer) \n          client->screen->pointerClient = NULL;\n\n\tif (threads_drop_input) {\n\t\treturn;\n\t}\n\n\tif (mask >= 0) {\n\t\tgot_pointer_calls++;\n\t}\n\n\tif (debug_pointer && mask >= 0) {\n\t\tstatic int show_motion = -1;\n\t\tstatic double last_pointer = 0.0;\n\t\tdouble tnow, dt;\n\t\tstatic int last_x, last_y;\n\t\tif (show_motion == -1) {\n\t\t\tif (getenv(\"X11VNC_DB_NOMOTION\")) {\n\t\t\t\tshow_motion = 0;\n\t\t\t} else {\n\t\t\t\tshow_motion = 1;\n\t\t\t}\n\t\t}\n\t\tdtime0(&tnow);\n\t\ttnow -= x11vnc_start;\n\t\tdt = tnow - last_pointer;\n\t\tlast_pointer = tnow;\n\t\tif (show_motion) {\n\t\t\trfbLog(\"# pointer(mask: 0x%x, x:%4d, y:%4d) \"\n\t\t\t    \"dx: %3d dy: %3d dt: %.4f t: %.4f\\n\", mask, x, y,\n\t\t\t    x - last_x, y - last_y, dt, tnow);\n\t\t}\n\t\tlast_x = x;\n\t\tlast_y = y;\n\t}\n\n\tif (unixpw_in_progress) {\n\t\treturn;\n\t}\n\n\tget_allowed_input(client, &input);\n\n\tif (rotating) {\n\t\trotate_coords_inverse(x, y, &x, &y, -1, -1);\n\t}\n\n\tif (scaling) {\n\t\t/* map from rfb size to X11 size: */\n\t\tx = ((double) x / scaled_x) * dpy_x;\n\t\tx = nfix(x, dpy_x);\n\t\ty = ((double) y / scaled_y) * dpy_y;\n\t\ty = nfix(y, dpy_y);\n\t}\n\n\tINPUT_LOCK;\n\n\tif ((pipeinput_fh != NULL || pipeinput_int) && mask >= 0) {\n\t\tpipe_pointer(mask, x, y, client);\t/* MACOSX here. */\n\t\tif (! pipeinput_tee) {\n\t\t\tif (! view_only || raw_fb) {\t/* raw_fb hack */\n\t\t\t\tgot_user_input++;\n\t\t\t\tgot_pointer_input++;\n\t\t\t\tlast_pointer_client = client;\n\t\t\t\tlast_pointer_time = dnow();\n\t\t\t\tlast_event = last_input = last_pointer_input = time(NULL);\n\t\t\t}\n\t\t\tif (input.motion) {\n\t\t\t\t/* raw_fb hack track button state */\n\t\t\t\tbutton_mask_prev = button_mask;\n\t\t\t\tbutton_mask = mask;\n\t\t\t\tif(cd)\n\t\t\t\t  cd->ptr_buttonmask = mask;\n\t\t\t}\n\t\t\tif (!view_only && (input.motion || input.button)) {\n\t\t\t\tlast_rfb_ptr_injected = dnow();\n\t\t\t}\n\t\t\tINPUT_UNLOCK;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (view_only) {\n\t\tINPUT_UNLOCK;\n\t\treturn;\n\t}\n\n\tnow = dnow();\n\n\tif (mask >= 0) {\n\t\t/*\n\t\t * mask = -1 is a special case call from scan_for_updates()\n\t\t * to flush the event queue; there is no real pointer event.\n\t\t */\n\t\tif (! input.motion && ! input.button) {\n\t\t\tINPUT_UNLOCK;\n\t\t\treturn;\n\t\t}\n\n\t\tgot_user_input++;\n\t\tgot_pointer_input++;\n\t\tlast_pointer_client = client;\n\n\t\tlast_pointer_time = now;\n\t\tlast_rfb_ptr_injected = dnow();\n\n\t\tif (blackout_ptr && blackouts) {\n\t\t\tint b, ok = 1;\n\t\t\t/* see if it goes into the blacked out region */\n\t\t\tfor (b=0; b < blackouts; b++) {\n\t\t\t\tif (x < blackr[b].x1 || x > blackr[b].x2) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (y < blackr[b].y1 || y > blackr[b].y2) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t/* x1 <= x <= x2 and y1 <= y <= y2 */\n\t\t\t\tok = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (! ok) {\n\t\t\t\tif (debug_pointer) {\n\t\t\t\t    rfbLog(\"pointer(): blackout_ptr skipping \"\n\t\t\t\t\t\"x=%d y=%d in rectangle %d,%d %d,%d\\n\", x, y,\n\t\t\t\t\tblackr[b].x1, blackr[b].y1,\n\t\t\t\t\tblackr[b].x2, blackr[b].y2);\n\t\t\t\t}\n\t\t\t\tINPUT_UNLOCK;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * The following is hopefully an improvement wrt response during\n\t * pointer user input (window drags) for the threaded case.\n\t * See check_user_input() for the more complicated things we do\n\t * in the non-threaded case.\n\t */\n\tif ((use_threads && pointer_mode != 1) || pointer_flush_delay > 0.0) {\n#\t\tdefine NEV 32\n\t\t/* storage for the event queue */\n\t\tstatic int nevents = 0;\n\t\tstatic int ev[NEV][3];\n\t\tstatic rfbClientPtr ev_cl[NEV];\n\t\tint i;\n\t\t/* timer things */\n\t\tstatic double dt = 0.0, tmr = 0.0, maxwait = 0.4;\n\n\t\tif (pointer_flush_delay > 0.0) {\n\t\t\tmaxwait = pointer_flush_delay;\n\t\t}\n\t\tif (mask >= 0) {\n\t\t\tif (fb_copy_in_progress || pointer_flush_delay > 0.0) {\n\t\t\t\tbuffer_it = 1;\n\t\t\t}\n\t\t}\n\n\t\tPOINTER_LOCK;\n\n\t\t/* \n\t\t * If the framebuffer is being copied in another thread\n\t\t * (scan_for_updates()), we will queue up to 32 pointer\n\t\t * events for later.  The idea is by delaying these input\n\t\t * events, the screen is less likely to change during the\n\t\t * copying period, and so will give rise to less window\n\t\t * \"tearing\".\n\t\t *\n\t\t * Tearing is not completely eliminated because we do\n\t\t * not suspend work in the other libvncserver threads.\n\t\t * Maybe that is a possibility with a mutex...\n\t\t */\n\t\tif (buffer_it) {\n\t\t\t/* \n\t\t\t * mask = -1 is an all-clear signal from\n\t\t\t * scan_for_updates().\n\t\t\t *\n\t\t\t * dt is a timer in seconds; we only queue for so long.\n\t\t\t */\n\t\t\tdt += dtime(&tmr);\n\n\t\t\tif (nevents < NEV && dt < maxwait) {\n\t\t\t\ti = nevents++;\n\t\t\t\tev[i][0] = mask;\n\t\t\t\tev[i][1] = x;\n\t\t\t\tev[i][2] = y;\n\t\t\t\tev_cl[i] = client;\n\t\t\t\tif (! input.button) {\n\t\t\t\t\tev[i][0] = -1;\n\t\t\t\t}\n\t\t\t\tif (! input.motion) {\n\t\t\t\t\tev[i][1] = -1;\n\t\t\t\t\tev[i][2] = -1;\n\t\t\t\t}\n\t\t\t\tif (debug_pointer) {\n\t\t\t\t\trfbLog(\"pointer(): deferring event %d\"\n\t\t\t\t\t    \" %.4f\\n\", i, tmr - x11vnc_start);\n\t\t\t\t}\n\t\t\t\tPOINTER_UNLOCK;\n\t\t\t\tINPUT_UNLOCK;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t/* time to send the queue */\n\t\tfor (i=0; i<nevents; i++) {\n\t\t\tint sent = 0;\n\t\t\tif (mask < 0 && client != NULL) {\n\t\t\t\t/* hack to only push the latest event */\n\t\t\t\tif (i < nevents - 1) {\n\t\t\t\t\tif (debug_pointer) {\n\t\t\t\t\t\trfbLog(\"- skip deferred event:\"\n\t\t\t\t\t\t    \" %d\\n\", i);\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (debug_pointer) {\n\t\t\t\trfbLog(\"pointer(): sending event %d %.4f\\n\",\n\t\t\t\t    i+1, dnowx());\n\t\t\t}\n\t\t\tif (ev[i][1] >= 0) {\n\t\t\t\tupdate_x11_pointer_position(ev[i][1], ev[i][2], ev_cl[i]);\n\t\t\t\tsent = 1;\n\t\t\t}\n\t\t\tif (ev[i][0] >= 0) {\n\t\t\t        update_x11_pointer_mask(ev[i][0], ev_cl[i]);\n\t\t\t\tsent = 1;\n\t\t\t}\n\n\t\t\tif (sent) {\n\t\t\t\tpointer_queued_sent++;\n\t\t\t}\n\t\t}\n\t\tif (nevents && dt > maxwait) {\n\t\t    if (dpy) {\t/* raw_fb hack */\n\t\t\tif (mask < 0) {\n\t\t\t\tif (debug_pointer) {\n\t\t\t\t\trfbLog(\"pointer(): calling XFlush \"\n\t\t\t\t\t    \"%.4f\\n\", dnowx());\n\t\t\t\t}\n\t\t\t\tX_LOCK;\n\t\t\t\tXFlush_wr(dpy);\t\n\t\t\t\tX_UNLOCK;\n\t\t\t}\n\t\t    }\n\t\t}\n\t\tnevents = 0;\t/* reset everything */\n\t\tdt = 0.0;\n\t\tdtime0(&tmr);\n\n\t\tPOINTER_UNLOCK;\n\t}\n\tif (mask < 0) {\t\t/* -1 just means flush the event queue */\n\t\tif (debug_pointer) {\n\t\t\trfbLog(\"pointer(): flush only.  %.4f\\n\",\n\t\t\t    dnowx());\n\t\t}\n\t\tINPUT_UNLOCK;\n\t\treturn;\n\t}\n\n\t/* update the X display with the event: */\n\tif (input.motion) {\n\t        update_x11_pointer_position(x, y, client);\n\t\tsent = 1;\n\t}\n\tif (input.button) {\n\t\tif (mask != button_mask) {   /*FIXME multipointer?*/\n\t\t\tbutton_change_x = cursor_x;\n\t\t\tbutton_change_y = cursor_y;\n\t\t}\n \t        update_x11_pointer_mask(mask, client);\n\t\tsent = 1;\n\t}\n\n\tif (! dpy) {\n\t\t;\n\t} else if (nofb && sent) {\n\t\t/* \n\t\t * nofb is for, e.g. Win2VNC, where fastest pointer\n\t\t * updates are desired.\n\t\t */\n\t\tX_LOCK;\n\t\tXFlush_wr(dpy);\n\t\tX_UNLOCK;\n\t} else if (buffer_it) {\n\t\tif (debug_pointer) {\n\t\t\trfbLog(\"pointer(): calling XFlush+\"\n\t\t\t    \"%.4f\\n\", dnowx());\n\t\t}\n\t\tX_LOCK;\n\t\tXFlush_wr(dpy);\t\n\t\tX_UNLOCK;\n\t}\n\tINPUT_UNLOCK;\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"screen.h\"",
            "#include \"macosx.h\"",
            "#include \"scan.h\"",
            "#include \"uinput.h\"",
            "#include \"linuxfb.h\"",
            "#include \"v4l.h\"",
            "#include \"unixpw.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"userinput.h\"",
            "#include \"cursor.h\"",
            "#include \"win_utils.h\"",
            "#include \"xrecord.h\"",
            "#include \"xinerama.h\"",
            "#include \"keyboard.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int pointer_queued_sent = 0;",
            "void do_button_mask_change(int mask, int button, rfbClientPtr client);",
            "void pointer_event(int mask, int x, int y, rfbClientPtr client);",
            "void update_x11_pointer_position(int x, int y, rfbClientPtr client);",
            "static void update_x11_pointer_mask(int mask, rfbClientPtr client);",
            "static void pipe_pointer(int mask, int x, int y, rfbClientPtr client);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"screen.h\"\n#include \"macosx.h\"\n#include \"scan.h\"\n#include \"uinput.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"userinput.h\"\n#include \"cursor.h\"\n#include \"win_utils.h\"\n#include \"xrecord.h\"\n#include \"xinerama.h\"\n#include \"keyboard.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint pointer_queued_sent = 0;\nvoid do_button_mask_change(int mask, int button, rfbClientPtr client);\nvoid pointer_event(int mask, int x, int y, rfbClientPtr client);\nvoid update_x11_pointer_position(int x, int y, rfbClientPtr client);\nstatic void update_x11_pointer_mask(int mask, rfbClientPtr client);\nstatic void pipe_pointer(int mask, int x, int y, rfbClientPtr client);\n\nvoid pointer_event(int mask, int x, int y, rfbClientPtr client) {\n\tallowed_input_t input;\n\tint sent = 0, buffer_it = 0;\n\tdouble now;\n\tClientData *cd = NULL;\n        \n\tif(client && client->clientData)\n\t  cd = (ClientData *) client->clientData;\n\t\n\t/* needed to allow multiple dragging actions at once */\n        if(client && use_multipointer) \n          client->screen->pointerClient = NULL;\n\n\tif (threads_drop_input) {\n\t\treturn;\n\t}\n\n\tif (mask >= 0) {\n\t\tgot_pointer_calls++;\n\t}\n\n\tif (debug_pointer && mask >= 0) {\n\t\tstatic int show_motion = -1;\n\t\tstatic double last_pointer = 0.0;\n\t\tdouble tnow, dt;\n\t\tstatic int last_x, last_y;\n\t\tif (show_motion == -1) {\n\t\t\tif (getenv(\"X11VNC_DB_NOMOTION\")) {\n\t\t\t\tshow_motion = 0;\n\t\t\t} else {\n\t\t\t\tshow_motion = 1;\n\t\t\t}\n\t\t}\n\t\tdtime0(&tnow);\n\t\ttnow -= x11vnc_start;\n\t\tdt = tnow - last_pointer;\n\t\tlast_pointer = tnow;\n\t\tif (show_motion) {\n\t\t\trfbLog(\"# pointer(mask: 0x%x, x:%4d, y:%4d) \"\n\t\t\t    \"dx: %3d dy: %3d dt: %.4f t: %.4f\\n\", mask, x, y,\n\t\t\t    x - last_x, y - last_y, dt, tnow);\n\t\t}\n\t\tlast_x = x;\n\t\tlast_y = y;\n\t}\n\n\tif (unixpw_in_progress) {\n\t\treturn;\n\t}\n\n\tget_allowed_input(client, &input);\n\n\tif (rotating) {\n\t\trotate_coords_inverse(x, y, &x, &y, -1, -1);\n\t}\n\n\tif (scaling) {\n\t\t/* map from rfb size to X11 size: */\n\t\tx = ((double) x / scaled_x) * dpy_x;\n\t\tx = nfix(x, dpy_x);\n\t\ty = ((double) y / scaled_y) * dpy_y;\n\t\ty = nfix(y, dpy_y);\n\t}\n\n\tINPUT_LOCK;\n\n\tif ((pipeinput_fh != NULL || pipeinput_int) && mask >= 0) {\n\t\tpipe_pointer(mask, x, y, client);\t/* MACOSX here. */\n\t\tif (! pipeinput_tee) {\n\t\t\tif (! view_only || raw_fb) {\t/* raw_fb hack */\n\t\t\t\tgot_user_input++;\n\t\t\t\tgot_pointer_input++;\n\t\t\t\tlast_pointer_client = client;\n\t\t\t\tlast_pointer_time = dnow();\n\t\t\t\tlast_event = last_input = last_pointer_input = time(NULL);\n\t\t\t}\n\t\t\tif (input.motion) {\n\t\t\t\t/* raw_fb hack track button state */\n\t\t\t\tbutton_mask_prev = button_mask;\n\t\t\t\tbutton_mask = mask;\n\t\t\t\tif(cd)\n\t\t\t\t  cd->ptr_buttonmask = mask;\n\t\t\t}\n\t\t\tif (!view_only && (input.motion || input.button)) {\n\t\t\t\tlast_rfb_ptr_injected = dnow();\n\t\t\t}\n\t\t\tINPUT_UNLOCK;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (view_only) {\n\t\tINPUT_UNLOCK;\n\t\treturn;\n\t}\n\n\tnow = dnow();\n\n\tif (mask >= 0) {\n\t\t/*\n\t\t * mask = -1 is a special case call from scan_for_updates()\n\t\t * to flush the event queue; there is no real pointer event.\n\t\t */\n\t\tif (! input.motion && ! input.button) {\n\t\t\tINPUT_UNLOCK;\n\t\t\treturn;\n\t\t}\n\n\t\tgot_user_input++;\n\t\tgot_pointer_input++;\n\t\tlast_pointer_client = client;\n\n\t\tlast_pointer_time = now;\n\t\tlast_rfb_ptr_injected = dnow();\n\n\t\tif (blackout_ptr && blackouts) {\n\t\t\tint b, ok = 1;\n\t\t\t/* see if it goes into the blacked out region */\n\t\t\tfor (b=0; b < blackouts; b++) {\n\t\t\t\tif (x < blackr[b].x1 || x > blackr[b].x2) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (y < blackr[b].y1 || y > blackr[b].y2) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t/* x1 <= x <= x2 and y1 <= y <= y2 */\n\t\t\t\tok = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (! ok) {\n\t\t\t\tif (debug_pointer) {\n\t\t\t\t    rfbLog(\"pointer(): blackout_ptr skipping \"\n\t\t\t\t\t\"x=%d y=%d in rectangle %d,%d %d,%d\\n\", x, y,\n\t\t\t\t\tblackr[b].x1, blackr[b].y1,\n\t\t\t\t\tblackr[b].x2, blackr[b].y2);\n\t\t\t\t}\n\t\t\t\tINPUT_UNLOCK;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * The following is hopefully an improvement wrt response during\n\t * pointer user input (window drags) for the threaded case.\n\t * See check_user_input() for the more complicated things we do\n\t * in the non-threaded case.\n\t */\n\tif ((use_threads && pointer_mode != 1) || pointer_flush_delay > 0.0) {\n#\t\tdefine NEV 32\n\t\t/* storage for the event queue */\n\t\tstatic int nevents = 0;\n\t\tstatic int ev[NEV][3];\n\t\tstatic rfbClientPtr ev_cl[NEV];\n\t\tint i;\n\t\t/* timer things */\n\t\tstatic double dt = 0.0, tmr = 0.0, maxwait = 0.4;\n\n\t\tif (pointer_flush_delay > 0.0) {\n\t\t\tmaxwait = pointer_flush_delay;\n\t\t}\n\t\tif (mask >= 0) {\n\t\t\tif (fb_copy_in_progress || pointer_flush_delay > 0.0) {\n\t\t\t\tbuffer_it = 1;\n\t\t\t}\n\t\t}\n\n\t\tPOINTER_LOCK;\n\n\t\t/* \n\t\t * If the framebuffer is being copied in another thread\n\t\t * (scan_for_updates()), we will queue up to 32 pointer\n\t\t * events for later.  The idea is by delaying these input\n\t\t * events, the screen is less likely to change during the\n\t\t * copying period, and so will give rise to less window\n\t\t * \"tearing\".\n\t\t *\n\t\t * Tearing is not completely eliminated because we do\n\t\t * not suspend work in the other libvncserver threads.\n\t\t * Maybe that is a possibility with a mutex...\n\t\t */\n\t\tif (buffer_it) {\n\t\t\t/* \n\t\t\t * mask = -1 is an all-clear signal from\n\t\t\t * scan_for_updates().\n\t\t\t *\n\t\t\t * dt is a timer in seconds; we only queue for so long.\n\t\t\t */\n\t\t\tdt += dtime(&tmr);\n\n\t\t\tif (nevents < NEV && dt < maxwait) {\n\t\t\t\ti = nevents++;\n\t\t\t\tev[i][0] = mask;\n\t\t\t\tev[i][1] = x;\n\t\t\t\tev[i][2] = y;\n\t\t\t\tev_cl[i] = client;\n\t\t\t\tif (! input.button) {\n\t\t\t\t\tev[i][0] = -1;\n\t\t\t\t}\n\t\t\t\tif (! input.motion) {\n\t\t\t\t\tev[i][1] = -1;\n\t\t\t\t\tev[i][2] = -1;\n\t\t\t\t}\n\t\t\t\tif (debug_pointer) {\n\t\t\t\t\trfbLog(\"pointer(): deferring event %d\"\n\t\t\t\t\t    \" %.4f\\n\", i, tmr - x11vnc_start);\n\t\t\t\t}\n\t\t\t\tPOINTER_UNLOCK;\n\t\t\t\tINPUT_UNLOCK;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t/* time to send the queue */\n\t\tfor (i=0; i<nevents; i++) {\n\t\t\tint sent = 0;\n\t\t\tif (mask < 0 && client != NULL) {\n\t\t\t\t/* hack to only push the latest event */\n\t\t\t\tif (i < nevents - 1) {\n\t\t\t\t\tif (debug_pointer) {\n\t\t\t\t\t\trfbLog(\"- skip deferred event:\"\n\t\t\t\t\t\t    \" %d\\n\", i);\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (debug_pointer) {\n\t\t\t\trfbLog(\"pointer(): sending event %d %.4f\\n\",\n\t\t\t\t    i+1, dnowx());\n\t\t\t}\n\t\t\tif (ev[i][1] >= 0) {\n\t\t\t\tupdate_x11_pointer_position(ev[i][1], ev[i][2], ev_cl[i]);\n\t\t\t\tsent = 1;\n\t\t\t}\n\t\t\tif (ev[i][0] >= 0) {\n\t\t\t        update_x11_pointer_mask(ev[i][0], ev_cl[i]);\n\t\t\t\tsent = 1;\n\t\t\t}\n\n\t\t\tif (sent) {\n\t\t\t\tpointer_queued_sent++;\n\t\t\t}\n\t\t}\n\t\tif (nevents && dt > maxwait) {\n\t\t    if (dpy) {\t/* raw_fb hack */\n\t\t\tif (mask < 0) {\n\t\t\t\tif (debug_pointer) {\n\t\t\t\t\trfbLog(\"pointer(): calling XFlush \"\n\t\t\t\t\t    \"%.4f\\n\", dnowx());\n\t\t\t\t}\n\t\t\t\tX_LOCK;\n\t\t\t\tXFlush_wr(dpy);\t\n\t\t\t\tX_UNLOCK;\n\t\t\t}\n\t\t    }\n\t\t}\n\t\tnevents = 0;\t/* reset everything */\n\t\tdt = 0.0;\n\t\tdtime0(&tmr);\n\n\t\tPOINTER_UNLOCK;\n\t}\n\tif (mask < 0) {\t\t/* -1 just means flush the event queue */\n\t\tif (debug_pointer) {\n\t\t\trfbLog(\"pointer(): flush only.  %.4f\\n\",\n\t\t\t    dnowx());\n\t\t}\n\t\tINPUT_UNLOCK;\n\t\treturn;\n\t}\n\n\t/* update the X display with the event: */\n\tif (input.motion) {\n\t        update_x11_pointer_position(x, y, client);\n\t\tsent = 1;\n\t}\n\tif (input.button) {\n\t\tif (mask != button_mask) {   /*FIXME multipointer?*/\n\t\t\tbutton_change_x = cursor_x;\n\t\t\tbutton_change_y = cursor_y;\n\t\t}\n \t        update_x11_pointer_mask(mask, client);\n\t\tsent = 1;\n\t}\n\n\tif (! dpy) {\n\t\t;\n\t} else if (nofb && sent) {\n\t\t/* \n\t\t * nofb is for, e.g. Win2VNC, where fastest pointer\n\t\t * updates are desired.\n\t\t */\n\t\tX_LOCK;\n\t\tXFlush_wr(dpy);\n\t\tX_UNLOCK;\n\t} else if (buffer_it) {\n\t\tif (debug_pointer) {\n\t\t\trfbLog(\"pointer(): calling XFlush+\"\n\t\t\t    \"%.4f\\n\", dnowx());\n\t\t}\n\t\tX_LOCK;\n\t\tXFlush_wr(dpy);\t\n\t\tX_UNLOCK;\n\t}\n\tINPUT_UNLOCK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SCAN_FATAL",
          "args": [
            "tile_diffs"
          ],
          "line": 3631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fill_tile_gaps",
          "args": [],
          "line": 3629
        },
        "resolved": true,
        "details": {
          "function_name": "fill_tile_gaps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/scan.c",
          "lines": "2299-2329",
          "snippet": "static int fill_tile_gaps(void) {\n\tint x, y, run, saw;\n\tint n, diffs = 0, ct;\n\n\t/* horizontal: */\n\tfor (y=0; y < ntiles_y; y++) {\n\t\trun = 0;\n\t\tsaw = 0;\n\t\tfor (x=0; x < ntiles_x; x++) {\n\t\t\tct = gap_try(x, y, &run, &saw, 1);\n\t\t\tif (ct < 0) return ct;\t/* fatal */\n\t\t}\n\t}\n\n\t/* vertical: */\n\tfor (x=0; x < ntiles_x; x++) {\n\t\trun = 0;\n\t\tsaw = 0;\n\t\tfor (y=0; y < ntiles_y; y++) {\n\t\t\tct = gap_try(x, y, &run, &saw, 0);\n\t\t\tif (ct < 0) return ct;\t/* fatal */\n\t\t}\n\t}\n\n\tfor (n=0; n < ntiles; n++) {\n\t\tif (tile_has_diff[n]) {\n\t\t\tdiffs++;\n\t\t}\n\t}\n\treturn diffs;\n}",
          "includes": [
            "#include <default8x16.h>",
            "#include \"userinput.h\"",
            "#include \"macosx.h\"",
            "#include \"screen.h\"",
            "#include \"unixpw.h\"",
            "#include \"cleanup.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"8to24.h\"",
            "#include \"win_utils.h\"",
            "#include \"xrandr.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int fill_tile_gaps(void);",
            "static int island_try(int x, int y, int u, int v, int *run);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <default8x16.h>\n#include \"userinput.h\"\n#include \"macosx.h\"\n#include \"screen.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"8to24.h\"\n#include \"win_utils.h\"\n#include \"xrandr.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nstatic int fill_tile_gaps(void);\nstatic int island_try(int x, int y, int u, int v, int *run);\n\nstatic int fill_tile_gaps(void) {\n\tint x, y, run, saw;\n\tint n, diffs = 0, ct;\n\n\t/* horizontal: */\n\tfor (y=0; y < ntiles_y; y++) {\n\t\trun = 0;\n\t\tsaw = 0;\n\t\tfor (x=0; x < ntiles_x; x++) {\n\t\t\tct = gap_try(x, y, &run, &saw, 1);\n\t\t\tif (ct < 0) return ct;\t/* fatal */\n\t\t}\n\t}\n\n\t/* vertical: */\n\tfor (x=0; x < ntiles_x; x++) {\n\t\trun = 0;\n\t\tsaw = 0;\n\t\tfor (y=0; y < ntiles_y; y++) {\n\t\t\tct = gap_try(x, y, &run, &saw, 0);\n\t\t\tif (ct < 0) return ct;\t/* fatal */\n\t\t}\n\t}\n\n\tfor (n=0; n < ntiles; n++) {\n\t\tif (tile_has_diff[n]) {\n\t\t\tdiffs++;\n\t\t}\n\t}\n\treturn diffs;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SCAN_FATAL",
          "args": [
            "tile_diffs"
          ],
          "line": 3625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "grow_islands",
          "args": [],
          "line": 3623
        },
        "resolved": true,
        "details": {
          "function_name": "grow_islands",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/scan.c",
          "lines": "2363-2394",
          "snippet": "static int grow_islands(void) {\n\tint x, y, n, run;\n\tint diffs = 0, ct;\n\n\t/*\n\t * n.b. the way we scan here should keep an extension going,\n\t * and so also fill in gaps effectively...\n\t */\n\n\t/* left to right: */\n\tfor (y=0; y < ntiles_y; y++) {\n\t\trun = 0;\n\t\tfor (x=0; x <= ntiles_x - 2; x++) {\n\t\t\tct = island_try(x, y, x+1, y, &run);\n\t\t\tif (ct < 0) return ct;\t/* fatal */\n\t\t}\n\t}\n\t/* right to left: */\n\tfor (y=0; y < ntiles_y; y++) {\n\t\trun = 0;\n\t\tfor (x = ntiles_x - 1; x >= 1; x--) {\n\t\t\tct = island_try(x, y, x-1, y, &run);\n\t\t\tif (ct < 0) return ct;\t/* fatal */\n\t\t}\n\t}\n\tfor (n=0; n < ntiles; n++) {\n\t\tif (tile_has_diff[n]) {\n\t\t\tdiffs++;\n\t\t}\n\t}\n\treturn diffs;\n}",
          "includes": [
            "#include <default8x16.h>",
            "#include \"userinput.h\"",
            "#include \"macosx.h\"",
            "#include \"screen.h\"",
            "#include \"unixpw.h\"",
            "#include \"cleanup.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"8to24.h\"",
            "#include \"win_utils.h\"",
            "#include \"xrandr.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int island_try(int x, int y, int u, int v, int *run);",
            "static int grow_islands(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <default8x16.h>\n#include \"userinput.h\"\n#include \"macosx.h\"\n#include \"screen.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"8to24.h\"\n#include \"win_utils.h\"\n#include \"xrandr.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nstatic int island_try(int x, int y, int u, int v, int *run);\nstatic int grow_islands(void);\n\nstatic int grow_islands(void) {\n\tint x, y, n, run;\n\tint diffs = 0, ct;\n\n\t/*\n\t * n.b. the way we scan here should keep an extension going,\n\t * and so also fill in gaps effectively...\n\t */\n\n\t/* left to right: */\n\tfor (y=0; y < ntiles_y; y++) {\n\t\trun = 0;\n\t\tfor (x=0; x <= ntiles_x - 2; x++) {\n\t\t\tct = island_try(x, y, x+1, y, &run);\n\t\t\tif (ct < 0) return ct;\t/* fatal */\n\t\t}\n\t}\n\t/* right to left: */\n\tfor (y=0; y < ntiles_y; y++) {\n\t\trun = 0;\n\t\tfor (x = ntiles_x - 1; x >= 1; x--) {\n\t\t\tct = island_try(x, y, x-1, y, &run);\n\t\t\tif (ct < 0) return ct;\t/* fatal */\n\t\t}\n\t}\n\tfor (n=0; n < ntiles; n++) {\n\t\tif (tile_has_diff[n]) {\n\t\t\tdiffs++;\n\t\t}\n\t}\n\treturn diffs;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SCAN_FATAL",
          "args": [
            "tile_diffs"
          ],
          "line": 3618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_tiles_additional_pass",
          "args": [],
          "line": 3617
        },
        "resolved": true,
        "details": {
          "function_name": "copy_tiles_additional_pass",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/scan.c",
          "lines": "2223-2250",
          "snippet": "static int copy_tiles_additional_pass(void) {\n\tint x, y, n;\n\tint diffs = 0, ct;\n\n\tif (unixpw_in_progress) return 0;\n\n\tfor (y=0; y < ntiles_y; y++) {\n\t\tfor (x=0; x < ntiles_x; x++) {\n\t\t\tn = x + y * ntiles_x;\t\t/* number of this tile */\n\n\t\t\tif (! tile_has_diff[n]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (tile_copied[n]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tct = copy_tiles(x, y, 1);\n\t\t\tif (ct < 0) return ct;\t/* fatal */\n\t\t}\n\t}\n\tfor (n=0; n < ntiles; n++) {\n\t\tif (tile_has_diff[n]) {\n\t\t\tdiffs++;\n\t\t}\n\t}\n\treturn diffs;\n}",
          "includes": [
            "#include <default8x16.h>",
            "#include \"userinput.h\"",
            "#include \"macosx.h\"",
            "#include \"screen.h\"",
            "#include \"unixpw.h\"",
            "#include \"cleanup.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"8to24.h\"",
            "#include \"win_utils.h\"",
            "#include \"xrandr.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int copy_tiles_additional_pass(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <default8x16.h>\n#include \"userinput.h\"\n#include \"macosx.h\"\n#include \"screen.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"8to24.h\"\n#include \"win_utils.h\"\n#include \"xrandr.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nstatic int copy_tiles_additional_pass(void);\n\nstatic int copy_tiles_additional_pass(void) {\n\tint x, y, n;\n\tint diffs = 0, ct;\n\n\tif (unixpw_in_progress) return 0;\n\n\tfor (y=0; y < ntiles_y; y++) {\n\t\tfor (x=0; x < ntiles_x; x++) {\n\t\t\tn = x + y * ntiles_x;\t\t/* number of this tile */\n\n\t\t\tif (! tile_has_diff[n]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (tile_copied[n]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tct = copy_tiles(x, y, 1);\n\t\t\tif (ct < 0) return ct;\t/* fatal */\n\t\t}\n\t}\n\tfor (n=0; n < ntiles; n++) {\n\t\tif (tile_has_diff[n]) {\n\t\t\tdiffs++;\n\t\t}\n\t}\n\treturn diffs;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SCAN_FATAL",
          "args": [
            "tile_count"
          ],
          "line": 3614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scan_display",
          "args": [
            "scanlines[cp]",
            "1"
          ],
          "line": 3613
        },
        "resolved": true,
        "details": {
          "function_name": "scan_display",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/scan.c",
          "lines": "3168-3342",
          "snippet": "static int scan_display(int ystart, int rescan) {\n\tchar *src, *dst;\n\tint pixelsize = bpp/8;\n\tint x, y, w, n;\n\tint tile_count = 0;\n\tint nodiffs = 0, diff_hint;\n\tint xd_check = 0, xd_freq = 1;\n\tstatic int xd_tck = 0;\n\n\ty = ystart;\n\n\tg_now = dnow();\n\n\tif (! main_fb) {\n\t\trfbLog(\"scan_display: no main_fb!\\n\");\n\t\treturn 0;\n\t}\n\n\tX_LOCK;\n\n\twhile (y < dpy_y) {\n\n\t\tif (use_xdamage) {\n\t\t\tXD_tot++;\n\t\t\txd_check = 0;\n\t\t\tif (xdamage_hint_skip(y)) {\n\t\t\t\tif (xd_do_check && dpy && use_xdamage == 1) {\n\t\t\t\t\txd_tck++;\n\t\t\t\t\txd_tck = xd_tck % xd_freq;\n\t\t\t\t\tif (xd_tck == 0) {\n\t\t\t\t\t\txd_check = 1;\n\t\t\t\t\t\txd_samples++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!xd_check) {\n\t\t\t\t\tXD_skip++;\n\t\t\t\t\ty += NSCAN;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (xd_do_check && 0) {\n\t\t\t\t\tfprintf(stderr, \"ns y=%d\\n\", y);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* grab the horizontal scanline from the display: */\n\n#ifndef NO_NCACHE\n/* XXX Y test */\nif (ncache > 0) {\n\tint gotone = 0;\n\tif (macosx_console) {\n\t\tif (macosx_checkevent(NULL)) {\n\t\t\tgotone = 1;\n\t\t}\n\t} else {\n#if !NO_X11\n\t\tXEvent ev;\n\t\tif (raw_fb_str) {\n\t\t\t;\n\t\t} else if (XEventsQueued(dpy, QueuedAlready) == 0) {\n\t\t\t;\t/* XXX Y resp */\n\t\t} else if (XCheckTypedEvent(dpy, MapNotify, &ev)) {\n\t\t\tgotone = 1;\n\t\t} else if (XCheckTypedEvent(dpy, UnmapNotify, &ev)) {\n\t\t\tgotone = 2;\n\t\t} else if (XCheckTypedEvent(dpy, CreateNotify, &ev)) {\n\t\t\tgotone = 3;\n\t\t} else if (XCheckTypedEvent(dpy, ConfigureNotify, &ev)) {\n\t\t\tgotone = 4;\n\t\t} else if (XCheckTypedEvent(dpy, VisibilityNotify, &ev)) {\n\t\t\tgotone = 5;\n\t\t}\n\t\tif (gotone) {\n\t\t\tXPutBackEvent(dpy, &ev);\n\t\t}\n#endif\n\t}\n\tif (gotone) {\n\t\tstatic int nomsg = 1;\n\t\tif (nomsg) {\n\t\t\tif (dnowx() > 20) {\n\t\t\t\tnomsg = 0;\n\t\t\t}\n\t\t} else {\nif (ncdb) fprintf(stderr, \"\\n*** SCAN_DISPLAY CHECK_NCACHE/%d *** %d rescan=%d\\n\", gotone, y, rescan);\n\t\t}\n\t\tX_UNLOCK;\n\t\tcheck_ncache(0, 1);\n\t\tX_LOCK;\n\t}\n}\n#endif\n\n\t\tXRANDR_SET_TRAP_RET(-1, \"scan_display-set\");\n\t\tcopy_image(scanline, 0, y, 0, 0);\n\t\tXRANDR_CHK_TRAP_RET(-1, \"scan_display-chk\");\n\n\t\t/* for better memory i/o try the whole line at once */\n\t\tsrc = scanline->data;\n\t\tdst = main_fb + y * main_bytes_per_line;\n\n\t\tif (! memcmp(dst, src, main_bytes_per_line)) {\n\t\t\t/* no changes anywhere in scan line */\n\t\t\tnodiffs = 1;\n\t\t\tif (! rescan) {\n\t\t\t\ty += NSCAN;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (xd_check) {\n\t\t\txd_misses++;\n\t\t}\n\n\t\tx = 0;\n\t\twhile (x < dpy_x) {\n\t\t\tn = (x/tile_x) + (y/tile_y) * ntiles_x;\n\t\t\tdiff_hint = 0;\n\n\t\t\tif (blackouts) {\n\t\t\t\tif (blackout_line_skip(n, x, y, rescan,\n\t\t\t\t    &tile_count)) {\n\t\t\t\t\tx += NSCAN;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (rescan) {\n\t\t\t\tif (nodiffs || tile_has_diff[n]) {\n\t\t\t\t\ttile_count += tile_has_diff[n];\n\t\t\t\t\tx += NSCAN;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else if (xdamage_tile_count &&\n\t\t\t    tile_has_xdamage_diff[n]) {\n\t\t\t\ttile_has_xdamage_diff[n] = 2;\n\t\t\t\tdiff_hint = 1;\n\t\t\t}\n\n\t\t\t/* set ptrs to correspond to the x offset: */\n\t\t\tsrc = scanline->data + x * pixelsize;\n\t\t\tdst = main_fb + y * main_bytes_per_line + x * pixelsize;\n\n\t\t\t/* compute the width of data to be compared: */\n\t\t\tif (x + NSCAN > dpy_x) {\n\t\t\t\tw = dpy_x - x;\n\t\t\t} else {\n\t\t\t\tw = NSCAN;\n\t\t\t}\n\n\t\t\tif (diff_hint || memcmp(dst, src, w * pixelsize)) {\n\t\t\t\t/* found a difference, record it: */\n\t\t\t\tif (! blackouts) {\n\t\t\t\t\ttile_has_diff[n] = 1;\n\t\t\t\t\ttile_count++;\t\t\n\t\t\t\t} else {\n\t\t\t\t\tif (blackout_line_cmpskip(n, x, y,\n\t\t\t\t\t    dst, src, w, pixelsize)) {\n\t\t\t\t\t\ttile_has_diff[n] = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttile_has_diff[n] = 1;\n\t\t\t\t\t\ttile_count++;\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tx += NSCAN;\n\t\t}\n\t\ty += NSCAN;\n\t}\n\n\tX_UNLOCK;\n\n\treturn tile_count;\n}",
          "includes": [
            "#include <default8x16.h>",
            "#include \"userinput.h\"",
            "#include \"macosx.h\"",
            "#include \"screen.h\"",
            "#include \"unixpw.h\"",
            "#include \"cleanup.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"8to24.h\"",
            "#include \"win_utils.h\"",
            "#include \"xrandr.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int blackout_line_skip(int n, int x, int y, int rescan,\n    int *tile_count);",
            "static int blackout_line_cmpskip(int n, int x, int y, char *dst, char *src,\n    int w, int pixelsize);",
            "static int scan_display(int ystart, int rescan);",
            "static int xd_samples = 0, xd_misses = 0, xd_do_check = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <default8x16.h>\n#include \"userinput.h\"\n#include \"macosx.h\"\n#include \"screen.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"8to24.h\"\n#include \"win_utils.h\"\n#include \"xrandr.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nstatic int blackout_line_skip(int n, int x, int y, int rescan,\n    int *tile_count);\nstatic int blackout_line_cmpskip(int n, int x, int y, char *dst, char *src,\n    int w, int pixelsize);\nstatic int scan_display(int ystart, int rescan);\nstatic int xd_samples = 0, xd_misses = 0, xd_do_check = 0;\n\nstatic int scan_display(int ystart, int rescan) {\n\tchar *src, *dst;\n\tint pixelsize = bpp/8;\n\tint x, y, w, n;\n\tint tile_count = 0;\n\tint nodiffs = 0, diff_hint;\n\tint xd_check = 0, xd_freq = 1;\n\tstatic int xd_tck = 0;\n\n\ty = ystart;\n\n\tg_now = dnow();\n\n\tif (! main_fb) {\n\t\trfbLog(\"scan_display: no main_fb!\\n\");\n\t\treturn 0;\n\t}\n\n\tX_LOCK;\n\n\twhile (y < dpy_y) {\n\n\t\tif (use_xdamage) {\n\t\t\tXD_tot++;\n\t\t\txd_check = 0;\n\t\t\tif (xdamage_hint_skip(y)) {\n\t\t\t\tif (xd_do_check && dpy && use_xdamage == 1) {\n\t\t\t\t\txd_tck++;\n\t\t\t\t\txd_tck = xd_tck % xd_freq;\n\t\t\t\t\tif (xd_tck == 0) {\n\t\t\t\t\t\txd_check = 1;\n\t\t\t\t\t\txd_samples++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!xd_check) {\n\t\t\t\t\tXD_skip++;\n\t\t\t\t\ty += NSCAN;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (xd_do_check && 0) {\n\t\t\t\t\tfprintf(stderr, \"ns y=%d\\n\", y);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* grab the horizontal scanline from the display: */\n\n#ifndef NO_NCACHE\n/* XXX Y test */\nif (ncache > 0) {\n\tint gotone = 0;\n\tif (macosx_console) {\n\t\tif (macosx_checkevent(NULL)) {\n\t\t\tgotone = 1;\n\t\t}\n\t} else {\n#if !NO_X11\n\t\tXEvent ev;\n\t\tif (raw_fb_str) {\n\t\t\t;\n\t\t} else if (XEventsQueued(dpy, QueuedAlready) == 0) {\n\t\t\t;\t/* XXX Y resp */\n\t\t} else if (XCheckTypedEvent(dpy, MapNotify, &ev)) {\n\t\t\tgotone = 1;\n\t\t} else if (XCheckTypedEvent(dpy, UnmapNotify, &ev)) {\n\t\t\tgotone = 2;\n\t\t} else if (XCheckTypedEvent(dpy, CreateNotify, &ev)) {\n\t\t\tgotone = 3;\n\t\t} else if (XCheckTypedEvent(dpy, ConfigureNotify, &ev)) {\n\t\t\tgotone = 4;\n\t\t} else if (XCheckTypedEvent(dpy, VisibilityNotify, &ev)) {\n\t\t\tgotone = 5;\n\t\t}\n\t\tif (gotone) {\n\t\t\tXPutBackEvent(dpy, &ev);\n\t\t}\n#endif\n\t}\n\tif (gotone) {\n\t\tstatic int nomsg = 1;\n\t\tif (nomsg) {\n\t\t\tif (dnowx() > 20) {\n\t\t\t\tnomsg = 0;\n\t\t\t}\n\t\t} else {\nif (ncdb) fprintf(stderr, \"\\n*** SCAN_DISPLAY CHECK_NCACHE/%d *** %d rescan=%d\\n\", gotone, y, rescan);\n\t\t}\n\t\tX_UNLOCK;\n\t\tcheck_ncache(0, 1);\n\t\tX_LOCK;\n\t}\n}\n#endif\n\n\t\tXRANDR_SET_TRAP_RET(-1, \"scan_display-set\");\n\t\tcopy_image(scanline, 0, y, 0, 0);\n\t\tXRANDR_CHK_TRAP_RET(-1, \"scan_display-chk\");\n\n\t\t/* for better memory i/o try the whole line at once */\n\t\tsrc = scanline->data;\n\t\tdst = main_fb + y * main_bytes_per_line;\n\n\t\tif (! memcmp(dst, src, main_bytes_per_line)) {\n\t\t\t/* no changes anywhere in scan line */\n\t\t\tnodiffs = 1;\n\t\t\tif (! rescan) {\n\t\t\t\ty += NSCAN;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (xd_check) {\n\t\t\txd_misses++;\n\t\t}\n\n\t\tx = 0;\n\t\twhile (x < dpy_x) {\n\t\t\tn = (x/tile_x) + (y/tile_y) * ntiles_x;\n\t\t\tdiff_hint = 0;\n\n\t\t\tif (blackouts) {\n\t\t\t\tif (blackout_line_skip(n, x, y, rescan,\n\t\t\t\t    &tile_count)) {\n\t\t\t\t\tx += NSCAN;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (rescan) {\n\t\t\t\tif (nodiffs || tile_has_diff[n]) {\n\t\t\t\t\ttile_count += tile_has_diff[n];\n\t\t\t\t\tx += NSCAN;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else if (xdamage_tile_count &&\n\t\t\t    tile_has_xdamage_diff[n]) {\n\t\t\t\ttile_has_xdamage_diff[n] = 2;\n\t\t\t\tdiff_hint = 1;\n\t\t\t}\n\n\t\t\t/* set ptrs to correspond to the x offset: */\n\t\t\tsrc = scanline->data + x * pixelsize;\n\t\t\tdst = main_fb + y * main_bytes_per_line + x * pixelsize;\n\n\t\t\t/* compute the width of data to be compared: */\n\t\t\tif (x + NSCAN > dpy_x) {\n\t\t\t\tw = dpy_x - x;\n\t\t\t} else {\n\t\t\t\tw = NSCAN;\n\t\t\t}\n\n\t\t\tif (diff_hint || memcmp(dst, src, w * pixelsize)) {\n\t\t\t\t/* found a difference, record it: */\n\t\t\t\tif (! blackouts) {\n\t\t\t\t\ttile_has_diff[n] = 1;\n\t\t\t\t\ttile_count++;\t\t\n\t\t\t\t} else {\n\t\t\t\t\tif (blackout_line_cmpskip(n, x, y,\n\t\t\t\t\t    dst, src, w, pixelsize)) {\n\t\t\t\t\t\ttile_has_diff[n] = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttile_has_diff[n] = 1;\n\t\t\t\t\t\ttile_count++;\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tx += NSCAN;\n\t\t}\n\t\ty += NSCAN;\n\t}\n\n\tX_UNLOCK;\n\n\treturn tile_count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SCAN_FATAL",
          "args": [
            "tile_diffs"
          ],
          "line": 3603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_tiles_backward_pass",
          "args": [],
          "line": 3602
        },
        "resolved": true,
        "details": {
          "function_name": "copy_tiles_backward_pass",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/scan.c",
          "lines": "2180-2221",
          "snippet": "static int copy_tiles_backward_pass(void) {\n\tint x, y, n, m;\n\tint diffs = 0, ct;\n\n\tif (unixpw_in_progress) return 0;\n\n\tfor (y = ntiles_y - 1; y >= 0; y--) {\n\t    for (x = ntiles_x - 1; x >= 0; x--) {\n\t\tn = x + y * ntiles_x;\t\t/* number of this tile */\n\n\t\tif (! tile_has_diff[n]) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tm = x + (y-1) * ntiles_x;\t/* neighboring tile upward */\n\n\t\tif (y >= 1 && ! tile_has_diff[m] && tile_region[n].top_diff) {\n\t\t\tif (! tile_tried[m]) {\n\t\t\t\ttile_has_diff[m] = 2;\n\t\t\t\tct = copy_tiles(x, y-1, 1);\n\t\t\t\tif (ct < 0) return ct;\t/* fatal */\n\t\t\t}\n\t\t}\n\n\t\tm = (x-1) + y * ntiles_x;\t/* neighboring tile to left */\n\n\t\tif (x >= 1 && ! tile_has_diff[m] && tile_region[n].left_diff) {\n\t\t\tif (! tile_tried[m]) {\n\t\t\t\ttile_has_diff[m] = 2;\n\t\t\t\tct = copy_tiles(x-1, y, 1);\n\t\t\t\tif (ct < 0) return ct;\t/* fatal */\n\t\t\t}\n\t\t}\n\t    }\n\t}\n\tfor (n=0; n < ntiles; n++) {\n\t\tif (tile_has_diff[n]) {\n\t\t\tdiffs++;\n\t\t}\n\t}\n\treturn diffs;\n}",
          "includes": [
            "#include <default8x16.h>",
            "#include \"userinput.h\"",
            "#include \"macosx.h\"",
            "#include \"screen.h\"",
            "#include \"unixpw.h\"",
            "#include \"cleanup.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"8to24.h\"",
            "#include \"win_utils.h\"",
            "#include \"xrandr.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int copy_tiles_backward_pass(void);",
            "static region_t *tile_region;",
            "static unsigned short *left_diff = NULL, *right_diff = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <default8x16.h>\n#include \"userinput.h\"\n#include \"macosx.h\"\n#include \"screen.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"8to24.h\"\n#include \"win_utils.h\"\n#include \"xrandr.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nstatic int copy_tiles_backward_pass(void);\nstatic region_t *tile_region;\nstatic unsigned short *left_diff = NULL, *right_diff = NULL;\n\nstatic int copy_tiles_backward_pass(void) {\n\tint x, y, n, m;\n\tint diffs = 0, ct;\n\n\tif (unixpw_in_progress) return 0;\n\n\tfor (y = ntiles_y - 1; y >= 0; y--) {\n\t    for (x = ntiles_x - 1; x >= 0; x--) {\n\t\tn = x + y * ntiles_x;\t\t/* number of this tile */\n\n\t\tif (! tile_has_diff[n]) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tm = x + (y-1) * ntiles_x;\t/* neighboring tile upward */\n\n\t\tif (y >= 1 && ! tile_has_diff[m] && tile_region[n].top_diff) {\n\t\t\tif (! tile_tried[m]) {\n\t\t\t\ttile_has_diff[m] = 2;\n\t\t\t\tct = copy_tiles(x, y-1, 1);\n\t\t\t\tif (ct < 0) return ct;\t/* fatal */\n\t\t\t}\n\t\t}\n\n\t\tm = (x-1) + y * ntiles_x;\t/* neighboring tile to left */\n\n\t\tif (x >= 1 && ! tile_has_diff[m] && tile_region[n].left_diff) {\n\t\t\tif (! tile_tried[m]) {\n\t\t\t\ttile_has_diff[m] = 2;\n\t\t\t\tct = copy_tiles(x-1, y, 1);\n\t\t\t\tif (ct < 0) return ct;\t/* fatal */\n\t\t\t}\n\t\t}\n\t    }\n\t}\n\tfor (n=0; n < ntiles; n++) {\n\t\tif (tile_has_diff[n]) {\n\t\t\tdiffs++;\n\t\t}\n\t}\n\treturn diffs;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SCAN_FATAL",
          "args": [
            "tile_diffs"
          ],
          "line": 3596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_all_tile_runs",
          "args": [],
          "line": 3594
        },
        "resolved": true,
        "details": {
          "function_name": "copy_all_tile_runs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/scan.c",
          "lines": "2106-2168",
          "snippet": "static int copy_all_tile_runs(void) {\n\tint x, y, n, m, i;\n\tint diffs = 0, ct;\n\tint in_run = 0, run = 0;\n\tint ntave = 0, ntcnt = 0;\n\n\tif (unixpw_in_progress) return 0;\n\n\tfor (y=0; y < ntiles_y; y++) {\n\t\tfor (x=0; x < ntiles_x + 1; x++) {\n\t\t\tn = x + y * ntiles_x;\n\n\t\t\tif (x != ntiles_x && tile_has_diff[n]) {\n\t\t\t\tin_run = 1;\n\t\t\t\trun++;\n\t\t\t} else {\n\t\t\t\tif (! in_run) {\n\t\t\t\t\tin_run = 0;\n\t\t\t\t\trun = 0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tct = copy_tiles(x - run, y, run);\n\t\t\t\tif (ct < 0) return ct;\t/* fatal */\n\n\t\t\t\tntcnt++;\n\t\t\t\tntave += run;\n\t\t\t\tdiffs += run;\n\n\t\t\t\t/* neighboring tile downward: */\n\t\t\t\tfor (i=1; i <= run; i++) {\n\t\t\t\t\tif ((y+1) < ntiles_y\n\t\t\t\t\t    && tile_region[n-i].bot_diff) {\n\t\t\t\t\t\tm = (x-i) + (y+1) * ntiles_x;\n\t\t\t\t\t\tif (! tile_has_diff[m]) {\n\t\t\t\t\t\t\ttile_has_diff[m] = 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/* neighboring tile to right: */\n\t\t\t\tif (((x-1)+1) < ntiles_x\n\t\t\t\t    && tile_region[n-1].right_diff) {\n\t\t\t\t\tm = ((x-1)+1) + y * ntiles_x;\n\t\t\t\t\tif (! tile_has_diff[m]) {\n\t\t\t\t\t\ttile_has_diff[m] = 2;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t/* note that this starts a new run */\n\t\t\t\t\tin_run = 1;\n\t\t\t\t\trun = 1;\n\t\t\t\t} else {\n\t\t\t\t\tin_run = 0;\n\t\t\t\t\trun = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * Could some activity go here, to emulate threaded\n\t\t * behavior by servicing some libvncserver tasks?\n\t\t */\n\t}\n\treturn diffs;\n}",
          "includes": [
            "#include <default8x16.h>",
            "#include \"userinput.h\"",
            "#include \"macosx.h\"",
            "#include \"screen.h\"",
            "#include \"unixpw.h\"",
            "#include \"cleanup.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"8to24.h\"",
            "#include \"win_utils.h\"",
            "#include \"xrandr.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int copy_all_tile_runs(void);",
            "static int island_try(int x, int y, int u, int v, int *run);",
            "static region_t *tile_region;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <default8x16.h>\n#include \"userinput.h\"\n#include \"macosx.h\"\n#include \"screen.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"8to24.h\"\n#include \"win_utils.h\"\n#include \"xrandr.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nstatic int copy_all_tile_runs(void);\nstatic int island_try(int x, int y, int u, int v, int *run);\nstatic region_t *tile_region;\n\nstatic int copy_all_tile_runs(void) {\n\tint x, y, n, m, i;\n\tint diffs = 0, ct;\n\tint in_run = 0, run = 0;\n\tint ntave = 0, ntcnt = 0;\n\n\tif (unixpw_in_progress) return 0;\n\n\tfor (y=0; y < ntiles_y; y++) {\n\t\tfor (x=0; x < ntiles_x + 1; x++) {\n\t\t\tn = x + y * ntiles_x;\n\n\t\t\tif (x != ntiles_x && tile_has_diff[n]) {\n\t\t\t\tin_run = 1;\n\t\t\t\trun++;\n\t\t\t} else {\n\t\t\t\tif (! in_run) {\n\t\t\t\t\tin_run = 0;\n\t\t\t\t\trun = 0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tct = copy_tiles(x - run, y, run);\n\t\t\t\tif (ct < 0) return ct;\t/* fatal */\n\n\t\t\t\tntcnt++;\n\t\t\t\tntave += run;\n\t\t\t\tdiffs += run;\n\n\t\t\t\t/* neighboring tile downward: */\n\t\t\t\tfor (i=1; i <= run; i++) {\n\t\t\t\t\tif ((y+1) < ntiles_y\n\t\t\t\t\t    && tile_region[n-i].bot_diff) {\n\t\t\t\t\t\tm = (x-i) + (y+1) * ntiles_x;\n\t\t\t\t\t\tif (! tile_has_diff[m]) {\n\t\t\t\t\t\t\ttile_has_diff[m] = 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/* neighboring tile to right: */\n\t\t\t\tif (((x-1)+1) < ntiles_x\n\t\t\t\t    && tile_region[n-1].right_diff) {\n\t\t\t\t\tm = ((x-1)+1) + y * ntiles_x;\n\t\t\t\t\tif (! tile_has_diff[m]) {\n\t\t\t\t\t\ttile_has_diff[m] = 2;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t/* note that this starts a new run */\n\t\t\t\t\tin_run = 1;\n\t\t\t\t\trun = 1;\n\t\t\t\t} else {\n\t\t\t\t\tin_run = 0;\n\t\t\t\t\trun = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * Could some activity go here, to emulate threaded\n\t\t * behavior by servicing some libvncserver tasks?\n\t\t */\n\t}\n\treturn diffs;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_all_tiles",
          "args": [],
          "line": 3592
        },
        "resolved": true,
        "details": {
          "function_name": "copy_all_tiles",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/scan.c",
          "lines": "2060-2100",
          "snippet": "static int copy_all_tiles(void) {\n\tint x, y, n, m;\n\tint diffs = 0, ct;\n\n\tif (unixpw_in_progress) return 0;\n\n\tfor (y=0; y < ntiles_y; y++) {\n\t\tfor (x=0; x < ntiles_x; x++) {\n\t\t\tn = x + y * ntiles_x;\n\n\t\t\tif (tile_has_diff[n]) {\n\t\t\t\tct = copy_tiles(x, y, 1);\n\t\t\t\tif (ct < 0) return ct;\t/* fatal */\n\t\t\t}\n\t\t\tif (! tile_has_diff[n]) {\n\t\t\t\t/*\n\t\t\t\t * n.b. copy_tiles() may have detected\n\t\t\t\t * no change and reset tile_has_diff to 0.\n\t\t\t\t */\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdiffs++;\n\n\t\t\t/* neighboring tile downward: */\n\t\t\tif ( (y+1) < ntiles_y && tile_region[n].bot_diff) {\n\t\t\t\tm = x + (y+1) * ntiles_x;\n\t\t\t\tif (! tile_has_diff[m]) {\n\t\t\t\t\ttile_has_diff[m] = 2;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* neighboring tile to right: */\n\t\t\tif ( (x+1) < ntiles_x && tile_region[n].right_diff) {\n\t\t\t\tm = (x+1) + y * ntiles_x;\n\t\t\t\tif (! tile_has_diff[m]) {\n\t\t\t\t\ttile_has_diff[m] = 2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn diffs;\n}",
          "includes": [
            "#include <default8x16.h>",
            "#include \"userinput.h\"",
            "#include \"macosx.h\"",
            "#include \"screen.h\"",
            "#include \"unixpw.h\"",
            "#include \"cleanup.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"8to24.h\"",
            "#include \"win_utils.h\"",
            "#include \"xrandr.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int copy_all_tiles(void);",
            "static region_t *tile_region;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <default8x16.h>\n#include \"userinput.h\"\n#include \"macosx.h\"\n#include \"screen.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"8to24.h\"\n#include \"win_utils.h\"\n#include \"xrandr.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nstatic int copy_all_tiles(void);\nstatic region_t *tile_region;\n\nstatic int copy_all_tiles(void) {\n\tint x, y, n, m;\n\tint diffs = 0, ct;\n\n\tif (unixpw_in_progress) return 0;\n\n\tfor (y=0; y < ntiles_y; y++) {\n\t\tfor (x=0; x < ntiles_x; x++) {\n\t\t\tn = x + y * ntiles_x;\n\n\t\t\tif (tile_has_diff[n]) {\n\t\t\t\tct = copy_tiles(x, y, 1);\n\t\t\t\tif (ct < 0) return ct;\t/* fatal */\n\t\t\t}\n\t\t\tif (! tile_has_diff[n]) {\n\t\t\t\t/*\n\t\t\t\t * n.b. copy_tiles() may have detected\n\t\t\t\t * no change and reset tile_has_diff to 0.\n\t\t\t\t */\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdiffs++;\n\n\t\t\t/* neighboring tile downward: */\n\t\t\tif ( (y+1) < ntiles_y && tile_region[n].bot_diff) {\n\t\t\t\tm = x + (y+1) * ntiles_x;\n\t\t\t\tif (! tile_has_diff[m]) {\n\t\t\t\t\ttile_has_diff[m] = 2;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* neighboring tile to right: */\n\t\t\tif ( (x+1) < ntiles_x && tile_region[n].right_diff) {\n\t\t\t\tm = (x+1) + y * ntiles_x;\n\t\t\t\tif (! tile_has_diff[m]) {\n\t\t\t\t\ttile_has_diff[m] = 2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn diffs;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SCAN_FATAL",
          "args": [
            "cs"
          ],
          "line": 3562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_screen",
          "args": [],
          "line": 3560
        },
        "resolved": true,
        "details": {
          "function_name": "copy_screen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/scan.c",
          "lines": "2412-2455",
          "snippet": "int copy_screen(void) {\n\tchar *fbp;\n\tint i, y, block_size;\n\n\tif (! fs_factor) {\n\t\treturn 0;\n\t}\n\tif (debug_tiles) fprintf(stderr, \"copy_screen\\n\");\n\n\tif (unixpw_in_progress) return 0;\n\n\n\tif (! main_fb) {\n\t\treturn 0;\n\t}\n\n\tblock_size = ((dpy_y/fs_factor) * main_bytes_per_line);\n\n\tfbp = main_fb;\n\ty = 0;\n\n\tX_LOCK;\n\n\t/* screen may be too big for 1 shm area, so broken into fs_factor */\n\tfor (i=0; i < fs_factor; i++) {\n\t\tXRANDR_SET_TRAP_RET(-1, \"copy_screen-set\");\n\t\tcopy_image(fullscreen, 0, y, 0, 0);\n\t\tXRANDR_CHK_TRAP_RET(-1, \"copy_screen-chk\");\n\n\t\tmemcpy(fbp, fullscreen->data, (size_t) block_size);\n\n\t\ty += dpy_y / fs_factor;\n\t\tfbp += block_size;\n\t}\n\n\tX_UNLOCK;\n\n\tif (blackouts) {\n\t\tblackout_regions();\n\t}\n\n\tmark_rect_as_modified(0, 0, dpy_x, dpy_y, 0);\n\treturn 0;\n}",
          "includes": [
            "#include <default8x16.h>",
            "#include \"userinput.h\"",
            "#include \"macosx.h\"",
            "#include \"screen.h\"",
            "#include \"unixpw.h\"",
            "#include \"cleanup.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"8to24.h\"",
            "#include \"win_utils.h\"",
            "#include \"xrandr.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void shm_delete(XShmSegmentInfo *shm);",
            "int copy_screen(void);",
            "static void blackout_regions(void);",
            "static int fs_factor = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <default8x16.h>\n#include \"userinput.h\"\n#include \"macosx.h\"\n#include \"screen.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"8to24.h\"\n#include \"win_utils.h\"\n#include \"xrandr.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nvoid shm_delete(XShmSegmentInfo *shm);\nint copy_screen(void);\nstatic void blackout_regions(void);\nstatic int fs_factor = 0;\n\nint copy_screen(void) {\n\tchar *fbp;\n\tint i, y, block_size;\n\n\tif (! fs_factor) {\n\t\treturn 0;\n\t}\n\tif (debug_tiles) fprintf(stderr, \"copy_screen\\n\");\n\n\tif (unixpw_in_progress) return 0;\n\n\n\tif (! main_fb) {\n\t\treturn 0;\n\t}\n\n\tblock_size = ((dpy_y/fs_factor) * main_bytes_per_line);\n\n\tfbp = main_fb;\n\ty = 0;\n\n\tX_LOCK;\n\n\t/* screen may be too big for 1 shm area, so broken into fs_factor */\n\tfor (i=0; i < fs_factor; i++) {\n\t\tXRANDR_SET_TRAP_RET(-1, \"copy_screen-set\");\n\t\tcopy_image(fullscreen, 0, y, 0, 0);\n\t\tXRANDR_CHK_TRAP_RET(-1, \"copy_screen-chk\");\n\n\t\tmemcpy(fbp, fullscreen->data, (size_t) block_size);\n\n\t\ty += dpy_y / fs_factor;\n\t\tfbp += block_size;\n\t}\n\n\tX_UNLOCK;\n\n\tif (blackouts) {\n\t\tblackout_regions();\n\t}\n\n\tmark_rect_as_modified(0, 0, dpy_x, dpy_y, 0);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SCAN_FATAL",
          "args": [
            "tile_count"
          ],
          "line": 3538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCAN_FATAL",
          "args": [
            "tile_count"
          ],
          "line": 3532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nap_set",
          "args": [
            "tile_count"
          ],
          "line": 3511
        },
        "resolved": true,
        "details": {
          "function_name": "nap_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/scan.c",
          "lines": "2870-2907",
          "snippet": "static void nap_set(int tile_cnt) {\n\tint nap_in = nap_ok;\n\ttime_t now = time(NULL);\n\n\tif (scan_count == 0) {\n\t\t/* roll up check for all NSCAN scans */\n\t\tnap_ok = 0;\n\t\tif (naptile && nap_diff_count < 2 * NSCAN * naptile) {\n\t\t\t/* \"2\" is a fudge to permit a bit of bg drawing */\n\t\t\tnap_ok = 1;\n\t\t}\n\t\tnap_diff_count = 0;\n\t}\n\tif (nap_ok && ! nap_in && use_xdamage) {\n\t\tif (XD_skip > 0.8 * XD_tot) \t{\n\t\t\t/* X DAMAGE is keeping load low, so skip nap */\n\t\t\tnap_ok = 0;\n\t\t}\n\t}\n\tif (! nap_ok && client_count) {\n\t\tif(now > last_fb_bytes_sent + no_fbu_blank) {\n\t\t\tif (debug_tiles > 1) {\n\t\t\t\tfprintf(stderr, \"nap_set: nap_ok=1: now: %d last: %d\\n\",\n\t\t\t\t    (int) now, (int) last_fb_bytes_sent);\n\t\t\t}\n\t\t\tnap_ok = 1;\n\t\t}\n\t}\n\n\tif (show_cursor) {\n\t\t/* kludge for the up to 4 tiles the mouse patch could occupy */\n\t\tif ( tile_cnt > 4) {\n\t\t\tlast_event = now;\n\t\t}\n\t} else if (tile_cnt != 0) {\n\t\tlast_event = now;\n\t}\n}",
          "includes": [
            "#include <default8x16.h>",
            "#include \"userinput.h\"",
            "#include \"macosx.h\"",
            "#include \"screen.h\"",
            "#include \"unixpw.h\"",
            "#include \"cleanup.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"8to24.h\"",
            "#include \"win_utils.h\"",
            "#include \"xrandr.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void nap_set(int tile_cnt);",
            "static void nap_check(int tile_cnt);",
            "static void ping_clients(int tile_cnt);",
            "int nap_ok = 0;",
            "static int nap_diff_count = 0;",
            "static int scan_count = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <default8x16.h>\n#include \"userinput.h\"\n#include \"macosx.h\"\n#include \"screen.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"8to24.h\"\n#include \"win_utils.h\"\n#include \"xrandr.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nstatic void nap_set(int tile_cnt);\nstatic void nap_check(int tile_cnt);\nstatic void ping_clients(int tile_cnt);\nint nap_ok = 0;\nstatic int nap_diff_count = 0;\nstatic int scan_count = 0;\n\nstatic void nap_set(int tile_cnt) {\n\tint nap_in = nap_ok;\n\ttime_t now = time(NULL);\n\n\tif (scan_count == 0) {\n\t\t/* roll up check for all NSCAN scans */\n\t\tnap_ok = 0;\n\t\tif (naptile && nap_diff_count < 2 * NSCAN * naptile) {\n\t\t\t/* \"2\" is a fudge to permit a bit of bg drawing */\n\t\t\tnap_ok = 1;\n\t\t}\n\t\tnap_diff_count = 0;\n\t}\n\tif (nap_ok && ! nap_in && use_xdamage) {\n\t\tif (XD_skip > 0.8 * XD_tot) \t{\n\t\t\t/* X DAMAGE is keeping load low, so skip nap */\n\t\t\tnap_ok = 0;\n\t\t}\n\t}\n\tif (! nap_ok && client_count) {\n\t\tif(now > last_fb_bytes_sent + no_fbu_blank) {\n\t\t\tif (debug_tiles > 1) {\n\t\t\t\tfprintf(stderr, \"nap_set: nap_ok=1: now: %d last: %d\\n\",\n\t\t\t\t    (int) now, (int) last_fb_bytes_sent);\n\t\t\t}\n\t\t\tnap_ok = 1;\n\t\t}\n\t}\n\n\tif (show_cursor) {\n\t\t/* kludge for the up to 4 tiles the mouse patch could occupy */\n\t\tif ( tile_cnt > 4) {\n\t\t\tlast_event = now;\n\t\t}\n\t} else if (tile_cnt != 0) {\n\t\tlast_event = now;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "destroy_xdamage_if_needed",
          "args": [],
          "line": 3502
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_xdamage_if_needed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xdamage.c",
          "lines": "787-808",
          "snippet": "void destroy_xdamage_if_needed(void) {\n\n\tRAWFB_RET_VOID\n\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXEvent ev;\n\t\tX_LOCK;\n\t\tXDamageDestroy(dpy, xdamage);\n\t\tXFlush_wr(dpy);\n\t\tif (xdamage_base_event_type) {\n\t\t\twhile (XCheckTypedEvent(dpy,\n\t\t\t    xdamage_base_event_type+XDamageNotify, &ev)) {\n\t\t\t\t;\n\t\t\t}\n\t\t}\n\t\tX_UNLOCK;\n\t\trfbLog(\"destroyed xdamage object: 0x%lx\\n\", xdamage);\n\t\txdamage = 0;\n\t}\n#endif\n}",
          "includes": [
            "#include \"unixpw.h\"",
            "#include \"userinput.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void destroy_xdamage_if_needed(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"unixpw.h\"\n#include \"userinput.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid destroy_xdamage_if_needed(void);\n\nvoid destroy_xdamage_if_needed(void) {\n\n\tRAWFB_RET_VOID\n\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXEvent ev;\n\t\tX_LOCK;\n\t\tXDamageDestroy(dpy, xdamage);\n\t\tXFlush_wr(dpy);\n\t\tif (xdamage_base_event_type) {\n\t\t\twhile (XCheckTypedEvent(dpy,\n\t\t\t    xdamage_base_event_type+XDamageNotify, &ev)) {\n\t\t\t\t;\n\t\t\t}\n\t\t}\n\t\tX_UNLOCK;\n\t\trfbLog(\"destroyed xdamage object: 0x%lx\\n\", xdamage);\n\t\txdamage = 0;\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "initialize_xdamage",
          "args": [],
          "line": 3501
        },
        "resolved": true,
        "details": {
          "function_name": "initialize_xdamage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xdamage.c",
          "lines": "736-768",
          "snippet": "void initialize_xdamage(void) {\n\tsraRegionPtr *ptr;\n\tint i, nreg;\n\n\tif (! xdamage_present) {\n\t\tuse_xdamage = 0;\n\t}\n\tif (xdamage_regions)  {\n\t\tptr = xdamage_regions;\n\t\twhile (*ptr != NULL) {\n\t\t\tsraRgnDestroy(*ptr);\n\t\t\tptr++;\n\t\t}\n\t\tfree(xdamage_regions);\n\t\txdamage_regions = NULL;\n\t}\n\tif (use_xdamage) {\n\t\tnreg = (xdamage_memory * NSCAN) + 2;\n\t\txdamage_regions = (sraRegionPtr *)\n\t\t    malloc(nreg * sizeof(sraRegionPtr));\n\t\tfor (i = 0; i < nreg; i++) {\n\t\t\tptr = xdamage_regions+i;\n\t\t\tif (i == nreg - 1) {\n\t\t\t\t*ptr = NULL;\n\t\t\t} else {\n\t\t\t\t*ptr = sraRgnCreate();\n\t\t\t\tsraRgnMakeEmpty(*ptr);\n\t\t\t}\n\t\t}\n\t\t/* set so will be 0 in first collect_xdamage call */\n\t\txdamage_ticker = -1;\n\t}\n}",
          "includes": [
            "#include \"unixpw.h\"",
            "#include \"userinput.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int use_xdamage = XDAMAGE;",
            "int xdamage_present = 0;",
            "double xdamage_memory = 1.0;",
            "sraRegionPtr *xdamage_regions = NULL;",
            "int xdamage_ticker = 0;",
            "int collect_non_X_xdamage(int x_in, int y_in, int w_in, int h_in, int call);",
            "int collect_xdamage(int scancnt, int call);",
            "void initialize_xdamage(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"unixpw.h\"\n#include \"userinput.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint use_xdamage = XDAMAGE;\nint xdamage_present = 0;\ndouble xdamage_memory = 1.0;\nsraRegionPtr *xdamage_regions = NULL;\nint xdamage_ticker = 0;\nint collect_non_X_xdamage(int x_in, int y_in, int w_in, int h_in, int call);\nint collect_xdamage(int scancnt, int call);\nvoid initialize_xdamage(void);\n\nvoid initialize_xdamage(void) {\n\tsraRegionPtr *ptr;\n\tint i, nreg;\n\n\tif (! xdamage_present) {\n\t\tuse_xdamage = 0;\n\t}\n\tif (xdamage_regions)  {\n\t\tptr = xdamage_regions;\n\t\twhile (*ptr != NULL) {\n\t\t\tsraRgnDestroy(*ptr);\n\t\t\tptr++;\n\t\t}\n\t\tfree(xdamage_regions);\n\t\txdamage_regions = NULL;\n\t}\n\tif (use_xdamage) {\n\t\tnreg = (xdamage_memory * NSCAN) + 2;\n\t\txdamage_regions = (sraRegionPtr *)\n\t\t    malloc(nreg * sizeof(sraRegionPtr));\n\t\tfor (i = 0; i < nreg; i++) {\n\t\t\tptr = xdamage_regions+i;\n\t\t\tif (i == nreg - 1) {\n\t\t\t\t*ptr = NULL;\n\t\t\t} else {\n\t\t\t\t*ptr = sraRgnCreate();\n\t\t\t\tsraRgnMakeEmpty(*ptr);\n\t\t\t}\n\t\t}\n\t\t/* set so will be 0 in first collect_xdamage call */\n\t\txdamage_ticker = -1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"XDAMAGE appears broken (OpenGL app?), turning it off.\\n\""
          ],
          "line": 3499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"To disable this check and warning specify -xdamage twice.\\n\""
          ],
          "line": 3497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"Use x11vnc -noxdamage or disable the Beryl/Compiz app.\\n\""
          ],
          "line": 3496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"Maybe an OpenGL app like Beryl or Compiz is the problem?\\n\""
          ],
          "line": 3495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"XDAMAGE is not working well... misses: %d/%d\\n\"",
            "xd_misses",
            "xd_samples"
          ],
          "line": 3494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time",
          "args": [
            "NULL"
          ],
          "line": 3490
        },
        "resolved": true,
        "details": {
          "function_name": "csock_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "3270-3276",
          "snippet": "static void csock_timeout (int sig) {\n\trfbLog(\"sig: %d, csock_timeout.\\n\", sig);\n\tif (csock_timeout_sock >= 0) {\n\t\tclose(csock_timeout_sock);\n\t\tcsock_timeout_sock = -1;\n\t}\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int csock_timeout_sock = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nstatic int csock_timeout_sock = -1;\n\nstatic void csock_timeout (int sig) {\n\trfbLog(\"sig: %d, csock_timeout.\\n\", sig);\n\tif (csock_timeout_sock >= 0) {\n\t\tclose(csock_timeout_sock);\n\t\tcsock_timeout_sock = -1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "SCAN_FATAL",
          "args": [
            "tile_count"
          ],
          "line": 3489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "collect_xdamage",
          "args": [
            "scan_count",
            "1"
          ],
          "line": 3457
        },
        "resolved": true,
        "details": {
          "function_name": "collect_xdamage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xdamage.c",
          "lines": "390-636",
          "snippet": "int collect_xdamage(int scancnt, int call) {\n#if HAVE_LIBXDAMAGE\n\tXDamageNotifyEvent *dev;\n\tXEvent ev;\n\tsraRegionPtr tmpregion;\n\tsraRegionPtr reg;\n\tstatic int rect_count = 0;\n\tint nreg, ccount = 0, dcount = 0, ecount = 0;\n\tstatic time_t last_rpt = 0;\n\ttime_t now;\n\tint x, y, w, h, x2, y2;\n\tint i, dup, next = 0, dup_max = 0;\n#define DUPSZ 32\n\tint dup_x[DUPSZ], dup_y[DUPSZ], dup_w[DUPSZ], dup_h[DUPSZ];\n\tdouble tm, dt;\n\tint mark_all = 0, retries = 0, too_many = 1000, tot_ev = 0;\n\n\tRAWFB_RET(0)\n\n\tif (scancnt) {} /* unused vars warning: */\n\n\tif (! xdamage_present || ! use_xdamage) {\n\t\treturn 0;\n\t}\n\tif (! xdamage) {\n\t\treturn 0;\n\t}\n\tif (! xdamage_base_event_type) {\n\t\treturn 0;\n\t}\n\tif (! xdamage_regions) {\n\t\treturn 0;\n\t}\n\n\tdtime0(&tm);\n\n\tnreg = (xdamage_memory * NSCAN) + 1;\n\n\tif (call == 0) {\n\t\txdamage_ticker = (xdamage_ticker+1) % nreg;\n\t\txdamage_direct_count = 0;\n\t\treg = xdamage_regions[xdamage_ticker];  \n\t\tif (reg != NULL) {\n\t\t\tsraRgnMakeEmpty(reg);\n\t\t}\n\t} else {\n\t\tif (xdamage_ticker < 0) {\n\t\t\txdamage_ticker = 0;\n\t\t}\n\t\treg = xdamage_regions[xdamage_ticker];  \n\t}\n\tif (reg == NULL) {\n\t\treturn 0;\n\t}\n\n\n\tX_LOCK;\nif (0)\tXFlush_wr(dpy);\nif (0)\tXEventsQueued(dpy, QueuedAfterFlush);\n\n\tcome_back_for_more:\n\n\twhile (XCheckTypedEvent(dpy, xdamage_base_event_type+XDamageNotify, &ev)) {\n\t\t/*\n\t\t * TODO max cut off time in this loop?\n\t\t * Could check QLength and if huge just mark the whole\n\t\t * screen.\n\t\t */\n\t\tecount++;\n\t\ttot_ev++;\n\n\t\tif (mark_all) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (ecount == too_many) {\n\t\t\tint nqa = XEventsQueued(dpy, QueuedAlready);\n\t\t\tif (nqa >= too_many) {\n\t\t\t\tstatic double last_msg = 0.0;\n\t\t\t\ttmpregion = sraRgnCreateRect(0, 0, dpy_x, dpy_y);\n\t\t\t\tsraRgnOr(reg, tmpregion);\n\t\t\t\tsraRgnDestroy(tmpregion);\n\t\t\t\tif (dnow() > last_msg + xdamage_crazy_delay) {\n\t\t\t\t\trfbLog(\"collect_xdamage: too many xdamage events %d+%d\\n\", ecount, nqa);\n\t\t\t\t\tlast_msg = dnow();\n\t\t\t\t}\n\t\t\t\tmark_all = 1;\n\t\t\t}\n\t\t}\n\n\t\tif (ev.type != xdamage_base_event_type + XDamageNotify) {\n\t\t\tbreak;\n\t\t}\n\t\tdev = (XDamageNotifyEvent *) &ev;\n\t\tif (dev->damage != xdamage) {\n\t\t\tcontinue;\t/* not ours! */\n\t\t}\n\n\t\tx = dev->area.x;\n\t\ty = dev->area.y;\n\t\tw = dev->area.width;\n\t\th = dev->area.height;\n\n\t\t/*\n\t\t * we try to manually remove some duplicates because\n\t\t * certain activities can lead to many 10's of dups\n\t\t * in a row.  The region work can be costly and reg is\n\t\t * later used in xdamage_hint_skip loops, so it is good\n\t\t * to skip them if possible.\n\t\t */\n\t\tdup = 0;\n\t\tfor (i=0; i < dup_max; i++) {\n\t\t\tif (dup_x[i] == x && dup_y[i] == y && dup_w[i] == w &&\n\t\t\t    dup_h[i] == h) {\n\t\t\t\tdup = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (dup) {\n\t\t\tdcount++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (dup_max < DUPSZ) {\n\t\t\tnext = dup_max;\n\t\t\tdup_max++;\n\t\t} else {\n\t\t\tnext = (next+1) % DUPSZ;\n\t\t}\n\t\tdup_x[next] = x;\n\t\tdup_y[next] = y;\n\t\tdup_w[next] = w;\n\t\tdup_h[next] = h;\n\n\t\t/* translate if needed */\n\t\tif (clipshift) {\n\t\t\t/* set coords relative to fb origin */\n\t\t\tif (0 && rootshift) {\n\t\t\t\t/*\n\t\t\t\t * Note: not needed because damage is\n\t\t\t\t * relative to subwin, not rootwin.\n\t\t\t\t */\n\t\t\t\tx = x - off_x;\n\t\t\t\ty = y - off_y;\n\t\t\t}\n\t\t\tif (clipshift) {\n\t\t\t\tx = x - coff_x;\n\t\t\t\ty = y - coff_y;\n\t\t\t}\n\n\t\t\tx2 = x + w;\t\t/* upper point */\n\t\t\tx  = nfix(x,  dpy_x);\t/* place both in fb area */\n\t\t\tx2 = nfix(x2, dpy_x+1);\n\t\t\tw = x2 - x;\t\t/* recompute w */\n\t\t\t\n\t\t\ty2 = y + h;\n\t\t\ty  = nfix(y,  dpy_y);\n\t\t\ty2 = nfix(y2, dpy_y+1);\n\t\t\th = y2 - y;\n\n\t\t\tif (w <= 0 || h <= 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (debug_xdamage > 2) {\n\t\t\tfprintf(stderr, \"xdamage: -> event %dx%d+%d+%d area:\"\n\t\t\t    \" %d  dups: %d  %s\\n\", w, h, x, y, w*h, dcount,\n\t\t\t    (w*h > xdamage_max_area) ? \"TOO_BIG\" : \"\");\n\t\t}\n\n\t\trecord_desired_xdamage_rect(x, y, w, h);\n\n\t\ttmpregion = sraRgnCreateRect(x, y, x + w, y + h); \n\t\tsraRgnOr(reg, tmpregion);\n\t\tsraRgnDestroy(tmpregion);\n\t\trect_count++;\n\t\tccount++;\n\t}\n\n\tif (mark_all) {\n\t\tif (ecount + XEventsQueued(dpy, QueuedAlready) >= 3 * too_many && retries < 3) {\n\t\t\tretries++;\n\t\t\tXFlush_wr(dpy);\n\t\t\tusleep(20 * 1000);\n\t\t\tXFlush_wr(dpy);\n\t\t\tecount = 0;\n\t\t\tgoto come_back_for_more;\n\t\t}\n\t}\n\n\t/* clear the whole damage region for next time. XXX check */\n\tif (call == 1) {\n\t\tXDamageSubtract(dpy, xdamage, None, None);\n\t}\n\tX_UNLOCK;\n\n\tif (tot_ev > 20 * too_many) {\n\t\trfbLog(\"collect_xdamage: xdamage has gone crazy (screensaver or game?) ev: %d ret: %d\\n\", tot_ev, retries);\n\t\trfbLog(\"collect_xdamage: disabling xdamage for %d seconds.\\n\", (int) xdamage_crazy_delay);\n\t\tdestroy_xdamage_if_needed();\n\t\tX_LOCK;\n\t\tXSync(dpy, False);\n\t\twhile (XCheckTypedEvent(dpy, xdamage_base_event_type+XDamageNotify, &ev)) {\n\t\t\t;\n\t\t}\n\t\tX_UNLOCK;\n\t\txdamage_crazy_time = dnow();\n\t}\n\n\tif (0 && xdamage_direct_count) {\n\t\tfb_push();\n\t}\n\n\tdt = dtime(&tm);\n\tif ((debug_tiles > 1 && ecount) || (debug_tiles && ecount > 200)\n\t    || debug_xdamage > 1) {\n\t\tfprintf(stderr, \"collect_xdamage(%d): %.4f t: %.4f ev/dup/accept\"\n\t\t    \"/direct %d/%d/%d/%d\\n\", call, dt, tm - x11vnc_start, ecount,\n\t\t    dcount, ccount, xdamage_direct_count); \n\t}\n\tnow = time(NULL);\n\tif (! last_rpt) {\n\t\tlast_rpt = now;\n\t}\n\tif (now > last_rpt + 15) {\n\t\tdouble rat = -1.0;\n\n\t\tif (XD_tot) {\n\t\t\trat = ((double) XD_skip)/XD_tot;\n\t\t}\n\t\tif (debug_tiles || debug_xdamage) {\n\t\t\tfprintf(stderr, \"xdamage: == scanline skip/tot: \"\n\t\t\t    \"%04d/%04d =%.3f  rects: %d  desired: %d\\n\",\n\t\t\t    XD_skip, XD_tot, rat, rect_count, XD_des);\n\t\t}\n\t\t\t\n\t\tXD_skip = 0;\n\t\tXD_tot  = 0;\n\t\tXD_des  = 0;\n\t\trect_count = 0;\n\t\tlast_rpt = now;\n\t}\n#else\n\tif (0) scancnt++;\t/* compiler warnings */\n\tif (0) call++;\n\tif (0) record_desired_xdamage_rect(0, 0, 0, 0);\n#endif\n\treturn 0;\n}",
          "includes": [
            "#include \"unixpw.h\"",
            "#include \"userinput.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define DUPSZ 32"
          ],
          "globals_used": [
            "int use_xdamage = XDAMAGE;",
            "int xdamage_present = 0;",
            "double xdamage_memory = 1.0;",
            "double xdamage_crazy_time = 0.0;",
            "double xdamage_crazy_delay = 300.0;",
            "sraRegionPtr *xdamage_regions = NULL;",
            "int xdamage_ticker = 0;",
            "int XD_skip = 0, XD_tot = 0, XD_des = 0;",
            "int collect_non_X_xdamage(int x_in, int y_in, int w_in, int h_in, int call);",
            "int collect_xdamage(int scancnt, int call);",
            "int xdamage_hint_skip(int y);",
            "void destroy_xdamage_if_needed(void);",
            "static void record_desired_xdamage_rect(int x, int y, int w, int h);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"unixpw.h\"\n#include \"userinput.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\n#define DUPSZ 32\n\nint use_xdamage = XDAMAGE;\nint xdamage_present = 0;\ndouble xdamage_memory = 1.0;\ndouble xdamage_crazy_time = 0.0;\ndouble xdamage_crazy_delay = 300.0;\nsraRegionPtr *xdamage_regions = NULL;\nint xdamage_ticker = 0;\nint XD_skip = 0, XD_tot = 0, XD_des = 0;\nint collect_non_X_xdamage(int x_in, int y_in, int w_in, int h_in, int call);\nint collect_xdamage(int scancnt, int call);\nint xdamage_hint_skip(int y);\nvoid destroy_xdamage_if_needed(void);\nstatic void record_desired_xdamage_rect(int x, int y, int w, int h);\n\nint collect_xdamage(int scancnt, int call) {\n#if HAVE_LIBXDAMAGE\n\tXDamageNotifyEvent *dev;\n\tXEvent ev;\n\tsraRegionPtr tmpregion;\n\tsraRegionPtr reg;\n\tstatic int rect_count = 0;\n\tint nreg, ccount = 0, dcount = 0, ecount = 0;\n\tstatic time_t last_rpt = 0;\n\ttime_t now;\n\tint x, y, w, h, x2, y2;\n\tint i, dup, next = 0, dup_max = 0;\n#define DUPSZ 32\n\tint dup_x[DUPSZ], dup_y[DUPSZ], dup_w[DUPSZ], dup_h[DUPSZ];\n\tdouble tm, dt;\n\tint mark_all = 0, retries = 0, too_many = 1000, tot_ev = 0;\n\n\tRAWFB_RET(0)\n\n\tif (scancnt) {} /* unused vars warning: */\n\n\tif (! xdamage_present || ! use_xdamage) {\n\t\treturn 0;\n\t}\n\tif (! xdamage) {\n\t\treturn 0;\n\t}\n\tif (! xdamage_base_event_type) {\n\t\treturn 0;\n\t}\n\tif (! xdamage_regions) {\n\t\treturn 0;\n\t}\n\n\tdtime0(&tm);\n\n\tnreg = (xdamage_memory * NSCAN) + 1;\n\n\tif (call == 0) {\n\t\txdamage_ticker = (xdamage_ticker+1) % nreg;\n\t\txdamage_direct_count = 0;\n\t\treg = xdamage_regions[xdamage_ticker];  \n\t\tif (reg != NULL) {\n\t\t\tsraRgnMakeEmpty(reg);\n\t\t}\n\t} else {\n\t\tif (xdamage_ticker < 0) {\n\t\t\txdamage_ticker = 0;\n\t\t}\n\t\treg = xdamage_regions[xdamage_ticker];  \n\t}\n\tif (reg == NULL) {\n\t\treturn 0;\n\t}\n\n\n\tX_LOCK;\nif (0)\tXFlush_wr(dpy);\nif (0)\tXEventsQueued(dpy, QueuedAfterFlush);\n\n\tcome_back_for_more:\n\n\twhile (XCheckTypedEvent(dpy, xdamage_base_event_type+XDamageNotify, &ev)) {\n\t\t/*\n\t\t * TODO max cut off time in this loop?\n\t\t * Could check QLength and if huge just mark the whole\n\t\t * screen.\n\t\t */\n\t\tecount++;\n\t\ttot_ev++;\n\n\t\tif (mark_all) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (ecount == too_many) {\n\t\t\tint nqa = XEventsQueued(dpy, QueuedAlready);\n\t\t\tif (nqa >= too_many) {\n\t\t\t\tstatic double last_msg = 0.0;\n\t\t\t\ttmpregion = sraRgnCreateRect(0, 0, dpy_x, dpy_y);\n\t\t\t\tsraRgnOr(reg, tmpregion);\n\t\t\t\tsraRgnDestroy(tmpregion);\n\t\t\t\tif (dnow() > last_msg + xdamage_crazy_delay) {\n\t\t\t\t\trfbLog(\"collect_xdamage: too many xdamage events %d+%d\\n\", ecount, nqa);\n\t\t\t\t\tlast_msg = dnow();\n\t\t\t\t}\n\t\t\t\tmark_all = 1;\n\t\t\t}\n\t\t}\n\n\t\tif (ev.type != xdamage_base_event_type + XDamageNotify) {\n\t\t\tbreak;\n\t\t}\n\t\tdev = (XDamageNotifyEvent *) &ev;\n\t\tif (dev->damage != xdamage) {\n\t\t\tcontinue;\t/* not ours! */\n\t\t}\n\n\t\tx = dev->area.x;\n\t\ty = dev->area.y;\n\t\tw = dev->area.width;\n\t\th = dev->area.height;\n\n\t\t/*\n\t\t * we try to manually remove some duplicates because\n\t\t * certain activities can lead to many 10's of dups\n\t\t * in a row.  The region work can be costly and reg is\n\t\t * later used in xdamage_hint_skip loops, so it is good\n\t\t * to skip them if possible.\n\t\t */\n\t\tdup = 0;\n\t\tfor (i=0; i < dup_max; i++) {\n\t\t\tif (dup_x[i] == x && dup_y[i] == y && dup_w[i] == w &&\n\t\t\t    dup_h[i] == h) {\n\t\t\t\tdup = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (dup) {\n\t\t\tdcount++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (dup_max < DUPSZ) {\n\t\t\tnext = dup_max;\n\t\t\tdup_max++;\n\t\t} else {\n\t\t\tnext = (next+1) % DUPSZ;\n\t\t}\n\t\tdup_x[next] = x;\n\t\tdup_y[next] = y;\n\t\tdup_w[next] = w;\n\t\tdup_h[next] = h;\n\n\t\t/* translate if needed */\n\t\tif (clipshift) {\n\t\t\t/* set coords relative to fb origin */\n\t\t\tif (0 && rootshift) {\n\t\t\t\t/*\n\t\t\t\t * Note: not needed because damage is\n\t\t\t\t * relative to subwin, not rootwin.\n\t\t\t\t */\n\t\t\t\tx = x - off_x;\n\t\t\t\ty = y - off_y;\n\t\t\t}\n\t\t\tif (clipshift) {\n\t\t\t\tx = x - coff_x;\n\t\t\t\ty = y - coff_y;\n\t\t\t}\n\n\t\t\tx2 = x + w;\t\t/* upper point */\n\t\t\tx  = nfix(x,  dpy_x);\t/* place both in fb area */\n\t\t\tx2 = nfix(x2, dpy_x+1);\n\t\t\tw = x2 - x;\t\t/* recompute w */\n\t\t\t\n\t\t\ty2 = y + h;\n\t\t\ty  = nfix(y,  dpy_y);\n\t\t\ty2 = nfix(y2, dpy_y+1);\n\t\t\th = y2 - y;\n\n\t\t\tif (w <= 0 || h <= 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (debug_xdamage > 2) {\n\t\t\tfprintf(stderr, \"xdamage: -> event %dx%d+%d+%d area:\"\n\t\t\t    \" %d  dups: %d  %s\\n\", w, h, x, y, w*h, dcount,\n\t\t\t    (w*h > xdamage_max_area) ? \"TOO_BIG\" : \"\");\n\t\t}\n\n\t\trecord_desired_xdamage_rect(x, y, w, h);\n\n\t\ttmpregion = sraRgnCreateRect(x, y, x + w, y + h); \n\t\tsraRgnOr(reg, tmpregion);\n\t\tsraRgnDestroy(tmpregion);\n\t\trect_count++;\n\t\tccount++;\n\t}\n\n\tif (mark_all) {\n\t\tif (ecount + XEventsQueued(dpy, QueuedAlready) >= 3 * too_many && retries < 3) {\n\t\t\tretries++;\n\t\t\tXFlush_wr(dpy);\n\t\t\tusleep(20 * 1000);\n\t\t\tXFlush_wr(dpy);\n\t\t\tecount = 0;\n\t\t\tgoto come_back_for_more;\n\t\t}\n\t}\n\n\t/* clear the whole damage region for next time. XXX check */\n\tif (call == 1) {\n\t\tXDamageSubtract(dpy, xdamage, None, None);\n\t}\n\tX_UNLOCK;\n\n\tif (tot_ev > 20 * too_many) {\n\t\trfbLog(\"collect_xdamage: xdamage has gone crazy (screensaver or game?) ev: %d ret: %d\\n\", tot_ev, retries);\n\t\trfbLog(\"collect_xdamage: disabling xdamage for %d seconds.\\n\", (int) xdamage_crazy_delay);\n\t\tdestroy_xdamage_if_needed();\n\t\tX_LOCK;\n\t\tXSync(dpy, False);\n\t\twhile (XCheckTypedEvent(dpy, xdamage_base_event_type+XDamageNotify, &ev)) {\n\t\t\t;\n\t\t}\n\t\tX_UNLOCK;\n\t\txdamage_crazy_time = dnow();\n\t}\n\n\tif (0 && xdamage_direct_count) {\n\t\tfb_push();\n\t}\n\n\tdt = dtime(&tm);\n\tif ((debug_tiles > 1 && ecount) || (debug_tiles && ecount > 200)\n\t    || debug_xdamage > 1) {\n\t\tfprintf(stderr, \"collect_xdamage(%d): %.4f t: %.4f ev/dup/accept\"\n\t\t    \"/direct %d/%d/%d/%d\\n\", call, dt, tm - x11vnc_start, ecount,\n\t\t    dcount, ccount, xdamage_direct_count); \n\t}\n\tnow = time(NULL);\n\tif (! last_rpt) {\n\t\tlast_rpt = now;\n\t}\n\tif (now > last_rpt + 15) {\n\t\tdouble rat = -1.0;\n\n\t\tif (XD_tot) {\n\t\t\trat = ((double) XD_skip)/XD_tot;\n\t\t}\n\t\tif (debug_tiles || debug_xdamage) {\n\t\t\tfprintf(stderr, \"xdamage: == scanline skip/tot: \"\n\t\t\t    \"%04d/%04d =%.3f  rects: %d  desired: %d\\n\",\n\t\t\t    XD_skip, XD_tot, rat, rect_count, XD_des);\n\t\t}\n\t\t\t\n\t\tXD_skip = 0;\n\t\tXD_tot  = 0;\n\t\tXD_des  = 0;\n\t\trect_count = 0;\n\t\tlast_rpt = now;\n\t}\n#else\n\tif (0) scancnt++;\t/* compiler warnings */\n\tif (0) call++;\n\tif (0) record_desired_xdamage_rect(0, 0, 0, 0);\n#endif\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SCAN_FATAL",
          "args": [
            "tile_count"
          ],
          "line": 3438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "collect_non_X_xdamage",
          "args": [
            "-1",
            "-1",
            "-1",
            "-1",
            "0"
          ],
          "line": 3420
        },
        "resolved": true,
        "details": {
          "function_name": "collect_non_X_xdamage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xdamage.c",
          "lines": "260-388",
          "snippet": "int collect_non_X_xdamage(int x_in, int y_in, int w_in, int h_in, int call) {\n\tsraRegionPtr tmpregion;\n\tsraRegionPtr reg;\n\tstatic int rect_count = 0;\n\tint nreg, ccount = 0, dcount = 0, ecount = 0;\n\tstatic time_t last_rpt = 0;\n\ttime_t now;\n\tdouble tm, dt;\n\tint x, y, w, h, x2, y2;\n\nif (call && debug_xdamage > 1) fprintf(stderr, \"collect_non_X_xdamage: %d %d %d %d - %d / %d\\n\", x_in, y_in, w_in, h_in, call, use_xdamage);\n\n\tif (! use_xdamage) {\n\t\treturn 0;\n\t}\n\tif (! xdamage_regions) {\n\t\treturn 0;\n\t}\n\n\tdtime0(&tm);\n\n\tnreg = (xdamage_memory * NSCAN) + 1;\n\n\tif (call == 0) {\n\t\txdamage_ticker = (xdamage_ticker+1) % nreg;\n\t\txdamage_direct_count = 0;\n\t\treg = xdamage_regions[xdamage_ticker];  \n\t\tif (reg != NULL) {\n\t\t\tsraRgnMakeEmpty(reg);\n\t\t}\n\t} else {\n\t\tif (xdamage_ticker < 0) {\n\t\t\txdamage_ticker = 0;\n\t\t}\n\t\treg = xdamage_regions[xdamage_ticker];  \n\t}\n\tif (reg == NULL) {\n\t\treturn 0;\n\t}\n\n\tif (x_in < 0) {\n\t\treturn 0;\n\t}\n\n\n\tx = x_in;\n\ty = y_in;\n\tw = w_in;\n\th = h_in;\n\n\t/* translate if needed */\n\tif (clipshift) {\n\t\t/* set coords relative to fb origin */\n\t\tif (0 && rootshift) {\n\t\t\t/*\n\t\t\t * Note: not needed because damage is\n\t\t\t * relative to subwin, not rootwin.\n\t\t\t */\n\t\t\tx = x - off_x;\n\t\t\ty = y - off_y;\n\t\t}\n\t\tif (clipshift) {\n\t\t\tx = x - coff_x;\n\t\t\ty = y - coff_y;\n\t\t}\n\n\t\tx2 = x + w;\t\t/* upper point */\n\t\tx  = nfix(x,  dpy_x);\t/* place both in fb area */\n\t\tx2 = nfix(x2, dpy_x+1);\n\t\tw = x2 - x;\t\t/* recompute w */\n\t\t\n\t\ty2 = y + h;\n\t\ty  = nfix(y,  dpy_y);\n\t\ty2 = nfix(y2, dpy_y+1);\n\t\th = y2 - y;\n\n\t\tif (w <= 0 || h <= 0) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (debug_xdamage > 2) {\n\t\tfprintf(stderr, \"xdamage: -> event %dx%d+%d+%d area:\"\n\t\t    \" %d  dups: %d  %s reg: %p\\n\", w, h, x, y, w*h, dcount,\n\t\t    (w*h > xdamage_max_area) ? \"TOO_BIG\" : \"\", (void *)reg);\n\t}\n\n\trecord_desired_xdamage_rect(x, y, w, h);\n\n\ttmpregion = sraRgnCreateRect(x, y, x + w, y + h); \n\tsraRgnOr(reg, tmpregion);\n\tsraRgnDestroy(tmpregion);\n\trect_count++;\n\tccount++;\n\n\tif (0 && xdamage_direct_count) {\n\t\tfb_push();\n\t}\n\n\tdt = dtime(&tm);\n\tif ((debug_tiles > 1 && ecount) || (debug_tiles && ecount > 200)\n\t    || debug_xdamage > 1) {\n\t\tfprintf(stderr, \"collect_non_X_xdamage(%d): %.4f t: %.4f ev/dup/accept\"\n\t\t    \"/direct %d/%d/%d/%d\\n\", call, dt, tm - x11vnc_start, ecount,\n\t\t    dcount, ccount, xdamage_direct_count); \n\t}\n\tnow = time(NULL);\n\tif (! last_rpt) {\n\t\tlast_rpt = now;\n\t}\n\tif (now > last_rpt + 15) {\n\t\tdouble rat = -1.0;\n\n\t\tif (XD_tot) {\n\t\t\trat = ((double) XD_skip)/XD_tot;\n\t\t}\n\t\tif (debug_tiles || debug_xdamage) {\n\t\t\tfprintf(stderr, \"xdamage: == scanline skip/tot: \"\n\t\t\t    \"%04d/%04d =%.3f  rects: %d  desired: %d\\n\",\n\t\t\t    XD_skip, XD_tot, rat, rect_count, XD_des);\n\t\t}\n\t\t\t\n\t\tXD_skip = 0;\n\t\tXD_tot  = 0;\n\t\tXD_des  = 0;\n\t\trect_count = 0;\n\t\tlast_rpt = now;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"unixpw.h\"",
            "#include \"userinput.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int use_xdamage = XDAMAGE;",
            "double xdamage_memory = 1.0;",
            "sraRegionPtr *xdamage_regions = NULL;",
            "int xdamage_ticker = 0;",
            "int XD_skip = 0, XD_tot = 0, XD_des = 0;",
            "int collect_non_X_xdamage(int x_in, int y_in, int w_in, int h_in, int call);",
            "int collect_xdamage(int scancnt, int call);",
            "int xdamage_hint_skip(int y);",
            "static void record_desired_xdamage_rect(int x, int y, int w, int h);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"unixpw.h\"\n#include \"userinput.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint use_xdamage = XDAMAGE;\ndouble xdamage_memory = 1.0;\nsraRegionPtr *xdamage_regions = NULL;\nint xdamage_ticker = 0;\nint XD_skip = 0, XD_tot = 0, XD_des = 0;\nint collect_non_X_xdamage(int x_in, int y_in, int w_in, int h_in, int call);\nint collect_xdamage(int scancnt, int call);\nint xdamage_hint_skip(int y);\nstatic void record_desired_xdamage_rect(int x, int y, int w, int h);\n\nint collect_non_X_xdamage(int x_in, int y_in, int w_in, int h_in, int call) {\n\tsraRegionPtr tmpregion;\n\tsraRegionPtr reg;\n\tstatic int rect_count = 0;\n\tint nreg, ccount = 0, dcount = 0, ecount = 0;\n\tstatic time_t last_rpt = 0;\n\ttime_t now;\n\tdouble tm, dt;\n\tint x, y, w, h, x2, y2;\n\nif (call && debug_xdamage > 1) fprintf(stderr, \"collect_non_X_xdamage: %d %d %d %d - %d / %d\\n\", x_in, y_in, w_in, h_in, call, use_xdamage);\n\n\tif (! use_xdamage) {\n\t\treturn 0;\n\t}\n\tif (! xdamage_regions) {\n\t\treturn 0;\n\t}\n\n\tdtime0(&tm);\n\n\tnreg = (xdamage_memory * NSCAN) + 1;\n\n\tif (call == 0) {\n\t\txdamage_ticker = (xdamage_ticker+1) % nreg;\n\t\txdamage_direct_count = 0;\n\t\treg = xdamage_regions[xdamage_ticker];  \n\t\tif (reg != NULL) {\n\t\t\tsraRgnMakeEmpty(reg);\n\t\t}\n\t} else {\n\t\tif (xdamage_ticker < 0) {\n\t\t\txdamage_ticker = 0;\n\t\t}\n\t\treg = xdamage_regions[xdamage_ticker];  \n\t}\n\tif (reg == NULL) {\n\t\treturn 0;\n\t}\n\n\tif (x_in < 0) {\n\t\treturn 0;\n\t}\n\n\n\tx = x_in;\n\ty = y_in;\n\tw = w_in;\n\th = h_in;\n\n\t/* translate if needed */\n\tif (clipshift) {\n\t\t/* set coords relative to fb origin */\n\t\tif (0 && rootshift) {\n\t\t\t/*\n\t\t\t * Note: not needed because damage is\n\t\t\t * relative to subwin, not rootwin.\n\t\t\t */\n\t\t\tx = x - off_x;\n\t\t\ty = y - off_y;\n\t\t}\n\t\tif (clipshift) {\n\t\t\tx = x - coff_x;\n\t\t\ty = y - coff_y;\n\t\t}\n\n\t\tx2 = x + w;\t\t/* upper point */\n\t\tx  = nfix(x,  dpy_x);\t/* place both in fb area */\n\t\tx2 = nfix(x2, dpy_x+1);\n\t\tw = x2 - x;\t\t/* recompute w */\n\t\t\n\t\ty2 = y + h;\n\t\ty  = nfix(y,  dpy_y);\n\t\ty2 = nfix(y2, dpy_y+1);\n\t\th = y2 - y;\n\n\t\tif (w <= 0 || h <= 0) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (debug_xdamage > 2) {\n\t\tfprintf(stderr, \"xdamage: -> event %dx%d+%d+%d area:\"\n\t\t    \" %d  dups: %d  %s reg: %p\\n\", w, h, x, y, w*h, dcount,\n\t\t    (w*h > xdamage_max_area) ? \"TOO_BIG\" : \"\", (void *)reg);\n\t}\n\n\trecord_desired_xdamage_rect(x, y, w, h);\n\n\ttmpregion = sraRgnCreateRect(x, y, x + w, y + h); \n\tsraRgnOr(reg, tmpregion);\n\tsraRgnDestroy(tmpregion);\n\trect_count++;\n\tccount++;\n\n\tif (0 && xdamage_direct_count) {\n\t\tfb_push();\n\t}\n\n\tdt = dtime(&tm);\n\tif ((debug_tiles > 1 && ecount) || (debug_tiles && ecount > 200)\n\t    || debug_xdamage > 1) {\n\t\tfprintf(stderr, \"collect_non_X_xdamage(%d): %.4f t: %.4f ev/dup/accept\"\n\t\t    \"/direct %d/%d/%d/%d\\n\", call, dt, tm - x11vnc_start, ecount,\n\t\t    dcount, ccount, xdamage_direct_count); \n\t}\n\tnow = time(NULL);\n\tif (! last_rpt) {\n\t\tlast_rpt = now;\n\t}\n\tif (now > last_rpt + 15) {\n\t\tdouble rat = -1.0;\n\n\t\tif (XD_tot) {\n\t\t\trat = ((double) XD_skip)/XD_tot;\n\t\t}\n\t\tif (debug_tiles || debug_xdamage) {\n\t\t\tfprintf(stderr, \"xdamage: == scanline skip/tot: \"\n\t\t\t    \"%04d/%04d =%.3f  rects: %d  desired: %d\\n\",\n\t\t\t    XD_skip, XD_tot, rat, rect_count, XD_des);\n\t\t}\n\t\t\t\n\t\tXD_skip = 0;\n\t\tXD_tot  = 0;\n\t\tXD_des  = 0;\n\t\trect_count = 0;\n\t\tlast_rpt = now;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "macosx_event_loop",
          "args": [],
          "line": 3408
        },
        "resolved": true,
        "details": {
          "function_name": "macosx_event_loop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosx.c",
          "lines": "154-156",
          "snippet": "void macosx_event_loop(void) {\n\tmacosxCG_event_loop();\n}",
          "includes": [
            "#include \"macosxCGS.h\"",
            "#include \"macosxCGP.h\"",
            "#include \"macosxCG.h\"",
            "#include \"connections.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"allowed_input_t.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"macosxCGS.h\"\n#include \"macosxCGP.h\"\n#include \"macosxCG.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"allowed_input_t.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include \"config.h\"\n\nvoid macosx_event_loop(void) {\n\tmacosxCG_event_loop();\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_for_multivis",
          "args": [],
          "line": 3404
        },
        "resolved": true,
        "details": {
          "function_name": "check_for_multivis",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/8to24.c",
          "lines": "304-600",
          "snippet": "void check_for_multivis(void) {\n#if NO_X11\n\tRAWFB_RET_VOID\n\treturn;\n#else\n\tXWindowAttributes attr;\n\tint doall = 0;\n\tint k, i, cnt, diff;\n\tstatic int first = 1;\n\tstatic Window *stack_old = NULL;\n\tstatic int stack_old_len = 0;\n\tstatic double last_parse = 0.0;\n\tstatic double last_update = 0.0;\n\tstatic double last_clear = 0.0;\n\tstatic double last_poll = 0.0;\n\tstatic double last_fixup = 0.0;\n\tstatic double last_call = 0.0;\n\tstatic double last_query = 0.0;\n\tdouble now = dnow();\n\tdouble delay;\n\n\tRAWFB_RET_VOID\n\n\tif (now > last_parse + 1.0) {\n\t\tlast_parse = now;\n\t\tparse_cmap8to24();\n\t}\nif (db24 > 2) fprintf(stderr, \" check_for_multivis: %.4f\\n\", now - last_call);\n\tlast_call = now;\n\n\tif (first) {\n\t\tint i;\n\t\t/* initialize 8bpp window table: */\n\t\tfor (i=0; i < MAX_8BPP_WINDOWS; i++) \t{\n\t\t\twindows_8bpp[i].win = None;\n\t\t\twindows_8bpp[i].top = None;\n\t\t\twindows_8bpp[i].map_state = IsUnmapped;\n\t\t\twindows_8bpp[i].cmap = (Colormap) 0;\n\t\t\twindows_8bpp[i].fetched = 0;\n\t\t\twindows_8bpp[i].last_fetched = -1.0;\n\t\t\twindows_8bpp[i].clip_region = NULL;\n\t\t}\n\t\tset_poll_fb();\n\n\t\tfirst = 0;\n\t\tdoall = 1;\t/* fetch everything first time */\n\t}\n\n\tif (wireframe_in_progress) {\n\t\treturn;\n\t}\n\n\tset_root_cmap();\n\n\t/*\n\t * allocate an \"old stack\" list of all toplevels.  we compare\n\t * this to the current stack to guess stacking order changes.\n\t */\n\tif (!stack_old || stack_old_len < stack_list_len) {\n\t\tint n = stack_list_len;\n\t\tif (n < 256) {\n\t\t\tn = 256;\n\t\t}\n\t\tif (stack_old) {\n\t\t\tfree(stack_old);\n\t\t}\n\t\tstack_old = (Window *) calloc(n*sizeof(Window), 1);\n\t\tstack_old_len = n;\n\t}\n\n\t/* fill the old stack with visible windows: */\n\tcnt = 0;\n\tfor (k=0; k < stack_list_num; k++) {\n\t\tif (stack_list[k].valid &&\n\t\t    stack_list[k].map_state == IsViewable) {\n\t\t\tstack_old[cnt++] = stack_list[k].win;\n\t\t}\n\t}\n\n\t/* snapshot + update the current stacking order: */\n\t/* TUNABLE */\n\tif (poll_8to24_delay >= POLL_8TO24_DELAY) {\n\t\tdelay = 3.0 * poll_8to24_delay;\n\t} else {\n\t\tdelay = 3.0 * POLL_8TO24_DELAY;\t/* 0.15 */\n\t}\n\tif (doall || now > last_update + delay) {\n\t\tsnapshot_stack_list(0, 0.0);\n\t\tupdate_stack_list();\n\t\tlast_update = now;\n\t}\n\n\t/* look for differences in the visible toplevels: */\n\tdiff = 0;\n\tcnt = 0;\n\tfor (k=0; k < stack_list_num; k++) {\n\t\tif (stack_list[k].valid && stack_list[k].map_state ==\n\t\t    IsViewable) {\n\t\t\tif (stack_old[cnt] != stack_list[k].win) {\n\t\t\t\tdiff = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcnt++;\n\t\t}\n\t}\n\n\tmultivis_count = 0;\n\tmultivis_24count = 0;\n\n\t/*\n\t * every 10 seconds we try to clean out and also refresh the window\n\t * info in the 8bpp window table:\n\t */\n\tif (now > last_clear + 10) {\n\t\tlast_clear = now;\n\t\tX_LOCK;\n\t\tfor (i=0; i < MAX_8BPP_WINDOWS; i++) {\n\t\t\tWindow w = windows_8bpp[i].win;\n\t\t\tif (! valid_window(w, &attr, 1)) {\n\t\t\t\t/* catch windows that went away: */\n\t\t\t\twindows_8bpp[i].win = None;\n\t\t\t\twindows_8bpp[i].top = None;\n\t\t\t\twindows_8bpp[i].map_state = IsUnmapped;\n\t\t\t\twindows_8bpp[i].cmap = (Colormap) 0;\n\t\t\t\twindows_8bpp[i].fetched = 0;\n\t\t\t\twindows_8bpp[i].last_fetched = -1.0;\n\t\t\t}\n\t\t}\n\t\tX_UNLOCK;\n\t}\n\n\tMV_count = 0;\n\tMV_hit = 0;\n\tMV_start = dnow();\n\n\tset_root_cmap();\n\n\t/* loop over all toplevels, both 8 and 24 depths: */\n\n\tX_LOCK;\t/* a giant lock around the whole activity */\n\n\tfor (k=0; k < stack_list_num; k++) {\n\t\tWindow r, parent;\n\t\tWindow *list0;\n\t\tStatus rc;\n\t\tunsigned int nc0;\n\t\tint i1;\n\t\tXErrorHandler old_handler;\n\t\tdouble delay;\n\n\t\tWindow win = stack_list[k].win;\n\n\t\t/* TUNABLE */\n\t\tif (poll_8to24_delay >= POLL_8TO24_DELAY) {\n\t\t\tdelay = 1.5 * poll_8to24_delay;\n\t\t} else {\n\t\t\tdelay = 1.5 * POLL_8TO24_DELAY;\t/* 0.075 */\n\t\t}\n\n\t\tif (now < last_query + delay) {\n\t\t\tbreak;\n\t\t}\n\n\t\tif (win == None) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (stack_list[k].map_state != IsViewable) {\n\t\t\tint i;\n\t\t\t/*\n\t\t\t * if the toplevel became unmapped, mark it\n\t\t\t * for the children as well...\n\t\t\t */\n\t\t\tfor (i=0; i < MAX_8BPP_WINDOWS; i++) {\n\t\t\t\tif (windows_8bpp[i].top == win) {\n\t\t\t\t\twindows_8bpp[i].map_state =\n\t\t\t\t\t    stack_list[k].map_state;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (check_depth(win, win, doall)) {\n\t\t\t/*\n\t\t\t * returns 1 if no need to recurse down e.g. It\n\t\t\t * is 8bpp and we assume all lower ones are too.\n\t\t\t */\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* we recurse up to two levels down from stack_list windows */\n\n\t\told_handler = XSetErrorHandler(trap_xerror);\n\t\ttrapped_xerror = 0;\n\t\trc = XQueryTree_wr(dpy, win, &r, &parent, &list0, &nc0);\n\t\tXSetErrorHandler(old_handler);\n\n\t\tif (! rc || trapped_xerror) {\n\t\t\ttrapped_xerror = 0;\n\t\t\tcontinue;\n\t\t}\n\t\ttrapped_xerror = 0;\n\n\t\t/* loop over grandchildren of rootwin: */\n\t\tfor (i1=0; i1 < (int) nc0; i1++) {\n\t\t\tWindow win1 = list0[i1];\n\t\t\tWindow *list1;\n\t\t\tunsigned int nc1;\n\t\t\tint i2;\n\n\t\t\tif (check_depth(win1, win, doall)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (level2_8to24) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\told_handler = XSetErrorHandler(trap_xerror);\n\t\t\ttrapped_xerror = 0;\n\t\t\trc = XQueryTree_wr(dpy, win1, &r, &parent, &list1, &nc1);\n\t\t\tXSetErrorHandler(old_handler);\n\n\t\t\tif (! rc || trapped_xerror) {\n\t\t\t\ttrapped_xerror = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttrapped_xerror = 0;\n\n\t\t\t/* loop over great-grandchildren of rootwin: */\n\t\t\tfor (i2=0; i2< (int) nc1; i2++) {\n\t\t\t\tWindow win2 = list1[i2];\n\n\t\t\t\tif (check_depth(win2, win, doall)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t/* more? Which wm does this? */\n\t\t\t}\n\t\t\tif (nc1) {\n\t\t\t\tXFree_wr(list1);\n\t\t\t}\n\t\t}\n\t\tif (nc0) {\n\t\t\tXFree_wr(list0);\n\t\t}\n\t}\n\tX_UNLOCK;\n\n\tlast_query = dnow();\n\nMV_glob += MV_count;\nif (0) fprintf(stderr, \"MV_count: %d hit: %d %.4f  %10.2f\\n\", MV_count, MV_hit, last_query - MV_start, MV_glob / (last_query - x11vnc_start));\n\n\tif (screen_fixup_8 > 0.0 && now > last_fixup + screen_fixup_8) {\n\t\tlast_fixup = now;\n\t\tmark_8bpp(MARK_8BPP_ALL);\n\t\tlast_poll = now;\n\n\t} else if (poll_8to24_delay > 0.0) {\n\t\tint area = -1;\n\t\tint validate = 0;\n\n\t\tif (diff && multivis_count) {\n\t\t\tvalidate = 1;\n\t\t}\n\t\tif (now > last_poll + poll_8to24_delay) {\n\t\t\tsraRegionPtr mod;\n\n\t\t\tlast_poll = now;\n\t\t\tmod = sraRgnCreate();\n\t\t\tarea = poll_8bpp(mod, validate);\n\t\t\tif (depth == 24) {\n\t\t\t\tpoll_8bpp_complement(mod);\n\t\t\t}\n\t\t\tmark_rgn_rects(mod);\n\t\t\tsraRgnDestroy(mod);\n\t\t}\n\t\tif (0 && area < dpy_x * dpy_y / 2 && diff && multivis_count) {\n\t\t\tmark_8bpp(MARK_8BPP_POINTER);\n\t\t\tlast_poll = now;\n\t\t}\n\n\t} else if (diff && multivis_count) {\n\t\tmark_8bpp(MARK_8BPP_ALL);\n\t\tlast_poll = now;\n\n\t} else if (depth <= 16 && multivis_24count) {\n\t\tstatic double last_check = 0.0;\n\t\tif (now > last_check + 0.4) {\n\t\t\tlast_check = now;\n\t\t\tif (check_pointer_in_depth24()) {\n\t\t\t\tlast_poll = now;\n\t\t\t}\n\t\t}\n\t}\nif (0) fprintf(stderr, \"done: %.4f\\n\", dnow() - last_query);\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"xwrappers.h\"",
            "#include \"win_utils.h\"",
            "#include \"util.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define MAX_8BPP_WINDOWS 64"
          ],
          "globals_used": [
            "int multivis_count = 0;",
            "int multivis_24count = 0;",
            "void check_for_multivis(void);",
            "void mark_8bpp(int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xwrappers.h\"\n#include \"win_utils.h\"\n#include \"util.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\n#define MAX_8BPP_WINDOWS 64\n\nint multivis_count = 0;\nint multivis_24count = 0;\nvoid check_for_multivis(void);\nvoid mark_8bpp(int);\n\nvoid check_for_multivis(void) {\n#if NO_X11\n\tRAWFB_RET_VOID\n\treturn;\n#else\n\tXWindowAttributes attr;\n\tint doall = 0;\n\tint k, i, cnt, diff;\n\tstatic int first = 1;\n\tstatic Window *stack_old = NULL;\n\tstatic int stack_old_len = 0;\n\tstatic double last_parse = 0.0;\n\tstatic double last_update = 0.0;\n\tstatic double last_clear = 0.0;\n\tstatic double last_poll = 0.0;\n\tstatic double last_fixup = 0.0;\n\tstatic double last_call = 0.0;\n\tstatic double last_query = 0.0;\n\tdouble now = dnow();\n\tdouble delay;\n\n\tRAWFB_RET_VOID\n\n\tif (now > last_parse + 1.0) {\n\t\tlast_parse = now;\n\t\tparse_cmap8to24();\n\t}\nif (db24 > 2) fprintf(stderr, \" check_for_multivis: %.4f\\n\", now - last_call);\n\tlast_call = now;\n\n\tif (first) {\n\t\tint i;\n\t\t/* initialize 8bpp window table: */\n\t\tfor (i=0; i < MAX_8BPP_WINDOWS; i++) \t{\n\t\t\twindows_8bpp[i].win = None;\n\t\t\twindows_8bpp[i].top = None;\n\t\t\twindows_8bpp[i].map_state = IsUnmapped;\n\t\t\twindows_8bpp[i].cmap = (Colormap) 0;\n\t\t\twindows_8bpp[i].fetched = 0;\n\t\t\twindows_8bpp[i].last_fetched = -1.0;\n\t\t\twindows_8bpp[i].clip_region = NULL;\n\t\t}\n\t\tset_poll_fb();\n\n\t\tfirst = 0;\n\t\tdoall = 1;\t/* fetch everything first time */\n\t}\n\n\tif (wireframe_in_progress) {\n\t\treturn;\n\t}\n\n\tset_root_cmap();\n\n\t/*\n\t * allocate an \"old stack\" list of all toplevels.  we compare\n\t * this to the current stack to guess stacking order changes.\n\t */\n\tif (!stack_old || stack_old_len < stack_list_len) {\n\t\tint n = stack_list_len;\n\t\tif (n < 256) {\n\t\t\tn = 256;\n\t\t}\n\t\tif (stack_old) {\n\t\t\tfree(stack_old);\n\t\t}\n\t\tstack_old = (Window *) calloc(n*sizeof(Window), 1);\n\t\tstack_old_len = n;\n\t}\n\n\t/* fill the old stack with visible windows: */\n\tcnt = 0;\n\tfor (k=0; k < stack_list_num; k++) {\n\t\tif (stack_list[k].valid &&\n\t\t    stack_list[k].map_state == IsViewable) {\n\t\t\tstack_old[cnt++] = stack_list[k].win;\n\t\t}\n\t}\n\n\t/* snapshot + update the current stacking order: */\n\t/* TUNABLE */\n\tif (poll_8to24_delay >= POLL_8TO24_DELAY) {\n\t\tdelay = 3.0 * poll_8to24_delay;\n\t} else {\n\t\tdelay = 3.0 * POLL_8TO24_DELAY;\t/* 0.15 */\n\t}\n\tif (doall || now > last_update + delay) {\n\t\tsnapshot_stack_list(0, 0.0);\n\t\tupdate_stack_list();\n\t\tlast_update = now;\n\t}\n\n\t/* look for differences in the visible toplevels: */\n\tdiff = 0;\n\tcnt = 0;\n\tfor (k=0; k < stack_list_num; k++) {\n\t\tif (stack_list[k].valid && stack_list[k].map_state ==\n\t\t    IsViewable) {\n\t\t\tif (stack_old[cnt] != stack_list[k].win) {\n\t\t\t\tdiff = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcnt++;\n\t\t}\n\t}\n\n\tmultivis_count = 0;\n\tmultivis_24count = 0;\n\n\t/*\n\t * every 10 seconds we try to clean out and also refresh the window\n\t * info in the 8bpp window table:\n\t */\n\tif (now > last_clear + 10) {\n\t\tlast_clear = now;\n\t\tX_LOCK;\n\t\tfor (i=0; i < MAX_8BPP_WINDOWS; i++) {\n\t\t\tWindow w = windows_8bpp[i].win;\n\t\t\tif (! valid_window(w, &attr, 1)) {\n\t\t\t\t/* catch windows that went away: */\n\t\t\t\twindows_8bpp[i].win = None;\n\t\t\t\twindows_8bpp[i].top = None;\n\t\t\t\twindows_8bpp[i].map_state = IsUnmapped;\n\t\t\t\twindows_8bpp[i].cmap = (Colormap) 0;\n\t\t\t\twindows_8bpp[i].fetched = 0;\n\t\t\t\twindows_8bpp[i].last_fetched = -1.0;\n\t\t\t}\n\t\t}\n\t\tX_UNLOCK;\n\t}\n\n\tMV_count = 0;\n\tMV_hit = 0;\n\tMV_start = dnow();\n\n\tset_root_cmap();\n\n\t/* loop over all toplevels, both 8 and 24 depths: */\n\n\tX_LOCK;\t/* a giant lock around the whole activity */\n\n\tfor (k=0; k < stack_list_num; k++) {\n\t\tWindow r, parent;\n\t\tWindow *list0;\n\t\tStatus rc;\n\t\tunsigned int nc0;\n\t\tint i1;\n\t\tXErrorHandler old_handler;\n\t\tdouble delay;\n\n\t\tWindow win = stack_list[k].win;\n\n\t\t/* TUNABLE */\n\t\tif (poll_8to24_delay >= POLL_8TO24_DELAY) {\n\t\t\tdelay = 1.5 * poll_8to24_delay;\n\t\t} else {\n\t\t\tdelay = 1.5 * POLL_8TO24_DELAY;\t/* 0.075 */\n\t\t}\n\n\t\tif (now < last_query + delay) {\n\t\t\tbreak;\n\t\t}\n\n\t\tif (win == None) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (stack_list[k].map_state != IsViewable) {\n\t\t\tint i;\n\t\t\t/*\n\t\t\t * if the toplevel became unmapped, mark it\n\t\t\t * for the children as well...\n\t\t\t */\n\t\t\tfor (i=0; i < MAX_8BPP_WINDOWS; i++) {\n\t\t\t\tif (windows_8bpp[i].top == win) {\n\t\t\t\t\twindows_8bpp[i].map_state =\n\t\t\t\t\t    stack_list[k].map_state;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (check_depth(win, win, doall)) {\n\t\t\t/*\n\t\t\t * returns 1 if no need to recurse down e.g. It\n\t\t\t * is 8bpp and we assume all lower ones are too.\n\t\t\t */\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* we recurse up to two levels down from stack_list windows */\n\n\t\told_handler = XSetErrorHandler(trap_xerror);\n\t\ttrapped_xerror = 0;\n\t\trc = XQueryTree_wr(dpy, win, &r, &parent, &list0, &nc0);\n\t\tXSetErrorHandler(old_handler);\n\n\t\tif (! rc || trapped_xerror) {\n\t\t\ttrapped_xerror = 0;\n\t\t\tcontinue;\n\t\t}\n\t\ttrapped_xerror = 0;\n\n\t\t/* loop over grandchildren of rootwin: */\n\t\tfor (i1=0; i1 < (int) nc0; i1++) {\n\t\t\tWindow win1 = list0[i1];\n\t\t\tWindow *list1;\n\t\t\tunsigned int nc1;\n\t\t\tint i2;\n\n\t\t\tif (check_depth(win1, win, doall)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (level2_8to24) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\told_handler = XSetErrorHandler(trap_xerror);\n\t\t\ttrapped_xerror = 0;\n\t\t\trc = XQueryTree_wr(dpy, win1, &r, &parent, &list1, &nc1);\n\t\t\tXSetErrorHandler(old_handler);\n\n\t\t\tif (! rc || trapped_xerror) {\n\t\t\t\ttrapped_xerror = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttrapped_xerror = 0;\n\n\t\t\t/* loop over great-grandchildren of rootwin: */\n\t\t\tfor (i2=0; i2< (int) nc1; i2++) {\n\t\t\t\tWindow win2 = list1[i2];\n\n\t\t\t\tif (check_depth(win2, win, doall)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t/* more? Which wm does this? */\n\t\t\t}\n\t\t\tif (nc1) {\n\t\t\t\tXFree_wr(list1);\n\t\t\t}\n\t\t}\n\t\tif (nc0) {\n\t\t\tXFree_wr(list0);\n\t\t}\n\t}\n\tX_UNLOCK;\n\n\tlast_query = dnow();\n\nMV_glob += MV_count;\nif (0) fprintf(stderr, \"MV_count: %d hit: %d %.4f  %10.2f\\n\", MV_count, MV_hit, last_query - MV_start, MV_glob / (last_query - x11vnc_start));\n\n\tif (screen_fixup_8 > 0.0 && now > last_fixup + screen_fixup_8) {\n\t\tlast_fixup = now;\n\t\tmark_8bpp(MARK_8BPP_ALL);\n\t\tlast_poll = now;\n\n\t} else if (poll_8to24_delay > 0.0) {\n\t\tint area = -1;\n\t\tint validate = 0;\n\n\t\tif (diff && multivis_count) {\n\t\t\tvalidate = 1;\n\t\t}\n\t\tif (now > last_poll + poll_8to24_delay) {\n\t\t\tsraRegionPtr mod;\n\n\t\t\tlast_poll = now;\n\t\t\tmod = sraRgnCreate();\n\t\t\tarea = poll_8bpp(mod, validate);\n\t\t\tif (depth == 24) {\n\t\t\t\tpoll_8bpp_complement(mod);\n\t\t\t}\n\t\t\tmark_rgn_rects(mod);\n\t\t\tsraRgnDestroy(mod);\n\t\t}\n\t\tif (0 && area < dpy_x * dpy_y / 2 && diff && multivis_count) {\n\t\t\tmark_8bpp(MARK_8BPP_POINTER);\n\t\t\tlast_poll = now;\n\t\t}\n\n\t} else if (diff && multivis_count) {\n\t\tmark_8bpp(MARK_8BPP_ALL);\n\t\tlast_poll = now;\n\n\t} else if (depth <= 16 && multivis_24count) {\n\t\tstatic double last_check = 0.0;\n\t\tif (now > last_check + 0.4) {\n\t\t\tlast_check = now;\n\t\t\tif (check_pointer_in_depth24()) {\n\t\t\t\tlast_poll = now;\n\t\t\t}\n\t\t}\n\t}\nif (0) fprintf(stderr, \"done: %.4f\\n\", dnow() - last_query);\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_colormap",
          "args": [
            "0"
          ],
          "line": 3401
        },
        "resolved": true,
        "details": {
          "function_name": "set_colormap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/screen.c",
          "lines": "202-367",
          "snippet": "void set_colormap(int reset) {\n\n#if NO_X11\n\tif (!reset) {}\n\treturn;\n#else\n\tstatic int init = 1;\n\tstatic XColor *color = NULL, *prev = NULL;\n\tstatic int ncolor = 0;\n\tColormap cmap;\n\tVisual *vis;\n\tint i, ncells, diffs = 0;\n\n\tif (reset) {\n\t\tinit = 1;\n\t\tncolor = 0;\n\t\t/* mutex */\n\t\tif (screen->colourMap.data.shorts) {\n\t\t\tfree(screen->colourMap.data.shorts);\n\t\t\tscreen->colourMap.data.shorts = NULL;\n\t\t}\n\t\tif (color) {\n\t\t\tfree(color);\n\t\t\tcolor = NULL;\n\t\t}\n\t\tif (prev) {\n\t\t\tfree(prev);\n\t\t\tprev = NULL;\n\t\t}\n\t}\n\n\tif (init) {\n\t\tif (depth > 16) {\n\t\t\tncolor = NCOLOR;\n\t\t} else if (depth > 8) {\n\t\t\tncolor = 1 << depth;\n\t\t} else {\n\t\t\tncolor = NCOLOR;\n\t\t}\n\t\t/* mutex */\n\t\tscreen->colourMap.count = ncolor;\n\t\tscreen->serverFormat.trueColour = FALSE;\n\t\tscreen->colourMap.is16 = TRUE;\n\t\tscreen->colourMap.data.shorts = (unsigned short *)\n\t\t\tmalloc(3*sizeof(unsigned short) * ncolor);\n\t}\n\tif (color == NULL) {\n\t\tcolor = (XColor *) calloc(ncolor * sizeof(XColor), 1);\n\t\tprev  = (XColor *) calloc(ncolor * sizeof(XColor), 1);\n\t}\n\n\tfor (i=0; i < ncolor; i++) {\n\t\tprev[i].red   = color[i].red;\n\t\tprev[i].green = color[i].green;\n\t\tprev[i].blue  = color[i].blue;\n\t}\n\n\tRAWFB_RET_VOID\n\n\tX_LOCK;\n\n\tcmap = DefaultColormap(dpy, scr);\n\tncells = CellsOfScreen(ScreenOfDisplay(dpy, scr));\n\tvis = default_visual;\n\n\tif (subwin) {\n\t\tXWindowAttributes attr;\n\n\t\tif (XGetWindowAttributes(dpy, window, &attr)) {\n\t\t\tcmap = attr.colormap;\n\t\t\tvis = attr.visual;\n\t\t\tncells = vis->map_entries;\n\t\t}\n\t}\n\n\tif (ncells != ncolor) {\n\t\tif (! shift_cmap) {\n\t\t\tscreen->colourMap.count = ncells;\n\t\t}\n\t}\n\tif (init && ! quiet) {\n\t\trfbLog(\"set_colormap: number of cells: %d, \"\n\t\t    \"ncolor(%d) is %d.\\n\", ncells, depth, ncolor);\n\t}\n\n\tif (flash_cmap && ! init) {\n\t\tXWindowAttributes attr;\n\t\tWindow c;\n\t\tint tries = 0;\n\n\t\tc = window;\n\t\twhile (c && tries++ < 16) {\n\t\t\tc = query_pointer(c);\n\t\t\tif (valid_window(c, &attr, 0)) {\n\t\t\t\tif (attr.colormap && attr.map_installed) {\n\t\t\t\t\tcmap = attr.colormap;\n\t\t\t\t\tvis = attr.visual;\n\t\t\t\t\tncells = vis->map_entries;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (ncells > ncolor && ! quiet) {\n\t\trfbLog(\"set_colormap: big problem: ncells=%d > %d\\n\",\n\t\t    ncells, ncolor);\n\t}\n\n\tif (vis->class == TrueColor || vis->class == DirectColor) {\n\t\t/*\n\t\t * Kludge to make 8bpp TrueColor & DirectColor be like\n\t\t * the StaticColor map.  The ncells = 8 is \"8 per subfield\"\n\t\t * mentioned in xdpyinfo.  Looks OK... perhaps fortuitously.\n\t\t */\n\t\tif (ncells == 8 && ! shift_cmap) {\n\t\t\tncells = ncolor;\n\t\t}\n\t}\n\n\tfor (i=0; i < ncells; i++) {\n\t\tcolor[i].pixel = i;\n\t\tcolor[i].pad = 0;\n\t}\n\n\tXQueryColors(dpy, cmap, color, ncells);\n\n\tX_UNLOCK;\n\n\tfor(i = ncells - 1; i >= 0; i--) {\n\t\tint k = i + shift_cmap;\n\n\t\tscreen->colourMap.data.shorts[i*3+0] = color[i].red;\n\t\tscreen->colourMap.data.shorts[i*3+1] = color[i].green;\n\t\tscreen->colourMap.data.shorts[i*3+2] = color[i].blue;\n\n\t\tif (prev[i].red   != color[i].red ||\n\t\t    prev[i].green != color[i].green || \n\t\t    prev[i].blue  != color[i].blue ) {\n\t\t\tdiffs++;\n\t\t}\n\n\t\tif (shift_cmap && k >= 0 && k < ncolor) {\n\t\t\t/* kludge to copy the colors to higher pixel values */\n\t\t\tscreen->colourMap.data.shorts[k*3+0] = color[i].red;\n\t\t\tscreen->colourMap.data.shorts[k*3+1] = color[i].green;\n\t\t\tscreen->colourMap.data.shorts[k*3+2] = color[i].blue;\n\t\t}\n\t}\n\n\tif (diffs && ! init) {\n\t\tif (! all_clients_initialized()) {\n\t\t\trfbLog(\"set_colormap: warning: sending cmap \"\n\t\t\t    \"with uninitialized clients.\\n\");\n\t\t}\n\t\tif (shift_cmap) {\n\t\t\trfbSetClientColourMaps(screen, 0, ncolor);\n\t\t} else {\n\t\t\trfbSetClientColourMaps(screen, 0, ncells);\n\t\t}\n\t}\n\n\tinit = 0;\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include <rfb/rfbclient.h>",
            "#include \"xi2_devices.h\"",
            "#include \"pm.h\"",
            "#include \"xrecord.h\"",
            "#include \"xrandr.h\"",
            "#include \"inet.h\"",
            "#include \"solid.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"linuxfb.h\"",
            "#include \"v4l.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"remote.h\"",
            "#include \"connections.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"pointer.h\"",
            "#include \"rates.h\"",
            "#include \"user.h\"",
            "#include \"scan.h\"",
            "#include \"userinput.h\"",
            "#include \"cleanup.h\"",
            "#include \"win_utils.h\"",
            "#include \"xdamage.h\"",
            "#include \"xinerama.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xevents.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define NCOLOR 256"
          ],
          "globals_used": [
            "void set_colormap(int reset);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <rfb/rfbclient.h>\n#include \"xi2_devices.h\"\n#include \"pm.h\"\n#include \"xrecord.h\"\n#include \"xrandr.h\"\n#include \"inet.h\"\n#include \"solid.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"remote.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"scan.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xdamage.h\"\n#include \"xinerama.h\"\n#include \"xwrappers.h\"\n#include \"xevents.h\"\n#include \"x11vnc.h\"\n\n#define NCOLOR 256\n\nvoid set_colormap(int reset);\n\nvoid set_colormap(int reset) {\n\n#if NO_X11\n\tif (!reset) {}\n\treturn;\n#else\n\tstatic int init = 1;\n\tstatic XColor *color = NULL, *prev = NULL;\n\tstatic int ncolor = 0;\n\tColormap cmap;\n\tVisual *vis;\n\tint i, ncells, diffs = 0;\n\n\tif (reset) {\n\t\tinit = 1;\n\t\tncolor = 0;\n\t\t/* mutex */\n\t\tif (screen->colourMap.data.shorts) {\n\t\t\tfree(screen->colourMap.data.shorts);\n\t\t\tscreen->colourMap.data.shorts = NULL;\n\t\t}\n\t\tif (color) {\n\t\t\tfree(color);\n\t\t\tcolor = NULL;\n\t\t}\n\t\tif (prev) {\n\t\t\tfree(prev);\n\t\t\tprev = NULL;\n\t\t}\n\t}\n\n\tif (init) {\n\t\tif (depth > 16) {\n\t\t\tncolor = NCOLOR;\n\t\t} else if (depth > 8) {\n\t\t\tncolor = 1 << depth;\n\t\t} else {\n\t\t\tncolor = NCOLOR;\n\t\t}\n\t\t/* mutex */\n\t\tscreen->colourMap.count = ncolor;\n\t\tscreen->serverFormat.trueColour = FALSE;\n\t\tscreen->colourMap.is16 = TRUE;\n\t\tscreen->colourMap.data.shorts = (unsigned short *)\n\t\t\tmalloc(3*sizeof(unsigned short) * ncolor);\n\t}\n\tif (color == NULL) {\n\t\tcolor = (XColor *) calloc(ncolor * sizeof(XColor), 1);\n\t\tprev  = (XColor *) calloc(ncolor * sizeof(XColor), 1);\n\t}\n\n\tfor (i=0; i < ncolor; i++) {\n\t\tprev[i].red   = color[i].red;\n\t\tprev[i].green = color[i].green;\n\t\tprev[i].blue  = color[i].blue;\n\t}\n\n\tRAWFB_RET_VOID\n\n\tX_LOCK;\n\n\tcmap = DefaultColormap(dpy, scr);\n\tncells = CellsOfScreen(ScreenOfDisplay(dpy, scr));\n\tvis = default_visual;\n\n\tif (subwin) {\n\t\tXWindowAttributes attr;\n\n\t\tif (XGetWindowAttributes(dpy, window, &attr)) {\n\t\t\tcmap = attr.colormap;\n\t\t\tvis = attr.visual;\n\t\t\tncells = vis->map_entries;\n\t\t}\n\t}\n\n\tif (ncells != ncolor) {\n\t\tif (! shift_cmap) {\n\t\t\tscreen->colourMap.count = ncells;\n\t\t}\n\t}\n\tif (init && ! quiet) {\n\t\trfbLog(\"set_colormap: number of cells: %d, \"\n\t\t    \"ncolor(%d) is %d.\\n\", ncells, depth, ncolor);\n\t}\n\n\tif (flash_cmap && ! init) {\n\t\tXWindowAttributes attr;\n\t\tWindow c;\n\t\tint tries = 0;\n\n\t\tc = window;\n\t\twhile (c && tries++ < 16) {\n\t\t\tc = query_pointer(c);\n\t\t\tif (valid_window(c, &attr, 0)) {\n\t\t\t\tif (attr.colormap && attr.map_installed) {\n\t\t\t\t\tcmap = attr.colormap;\n\t\t\t\t\tvis = attr.visual;\n\t\t\t\t\tncells = vis->map_entries;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (ncells > ncolor && ! quiet) {\n\t\trfbLog(\"set_colormap: big problem: ncells=%d > %d\\n\",\n\t\t    ncells, ncolor);\n\t}\n\n\tif (vis->class == TrueColor || vis->class == DirectColor) {\n\t\t/*\n\t\t * Kludge to make 8bpp TrueColor & DirectColor be like\n\t\t * the StaticColor map.  The ncells = 8 is \"8 per subfield\"\n\t\t * mentioned in xdpyinfo.  Looks OK... perhaps fortuitously.\n\t\t */\n\t\tif (ncells == 8 && ! shift_cmap) {\n\t\t\tncells = ncolor;\n\t\t}\n\t}\n\n\tfor (i=0; i < ncells; i++) {\n\t\tcolor[i].pixel = i;\n\t\tcolor[i].pad = 0;\n\t}\n\n\tXQueryColors(dpy, cmap, color, ncells);\n\n\tX_UNLOCK;\n\n\tfor(i = ncells - 1; i >= 0; i--) {\n\t\tint k = i + shift_cmap;\n\n\t\tscreen->colourMap.data.shorts[i*3+0] = color[i].red;\n\t\tscreen->colourMap.data.shorts[i*3+1] = color[i].green;\n\t\tscreen->colourMap.data.shorts[i*3+2] = color[i].blue;\n\n\t\tif (prev[i].red   != color[i].red ||\n\t\t    prev[i].green != color[i].green || \n\t\t    prev[i].blue  != color[i].blue ) {\n\t\t\tdiffs++;\n\t\t}\n\n\t\tif (shift_cmap && k >= 0 && k < ncolor) {\n\t\t\t/* kludge to copy the colors to higher pixel values */\n\t\t\tscreen->colourMap.data.shorts[k*3+0] = color[i].red;\n\t\t\tscreen->colourMap.data.shorts[k*3+1] = color[i].green;\n\t\t\tscreen->colourMap.data.shorts[k*3+2] = color[i].blue;\n\t\t}\n\t}\n\n\tif (diffs && ! init) {\n\t\tif (! all_clients_initialized()) {\n\t\t\trfbLog(\"set_colormap: warning: sending cmap \"\n\t\t\t    \"with uninitialized clients.\\n\");\n\t\t}\n\t\tif (shift_cmap) {\n\t\t\trfbSetClientColourMaps(screen, 0, ncolor);\n\t\t} else {\n\t\t\trfbSetClientColourMaps(screen, 0, ncells);\n\t\t}\n\t}\n\n\tinit = 0;\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_offset",
          "args": [],
          "line": 3397
        },
        "resolved": true,
        "details": {
          "function_name": "set_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/scan.c",
          "lines": "3149-3157",
          "snippet": "void set_offset(void) {\n\tWindow w;\n\tif (! subwin) {\n\t\treturn;\n\t}\n\tX_LOCK;\n\txtranslate(window, rootwin, 0, 0, &off_x, &off_y, &w, 0);\n\tX_UNLOCK;\n}",
          "includes": [
            "#include <default8x16.h>",
            "#include \"userinput.h\"",
            "#include \"macosx.h\"",
            "#include \"screen.h\"",
            "#include \"unixpw.h\"",
            "#include \"cleanup.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"8to24.h\"",
            "#include \"win_utils.h\"",
            "#include \"xrandr.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void set_offset(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <default8x16.h>\n#include \"userinput.h\"\n#include \"macosx.h\"\n#include \"screen.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"8to24.h\"\n#include \"win_utils.h\"\n#include \"xrandr.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nvoid set_offset(void);\n\nvoid set_offset(void) {\n\tWindow w;\n\tif (! subwin) {\n\t\treturn;\n\t}\n\tX_LOCK;\n\txtranslate(window, rootwin, 0, 0, &off_x, &off_y, &w, 0);\n\tX_UNLOCK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dnow",
          "args": [],
          "line": 3367
        },
        "resolved": true,
        "details": {
          "function_name": "dnowx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "439-441",
          "snippet": "double dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double dnow(void);",
            "double dnowx(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dnow(void);\ndouble dnowx(void);\n\ndouble dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <default8x16.h>\n#include \"userinput.h\"\n#include \"macosx.h\"\n#include \"screen.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"8to24.h\"\n#include \"win_utils.h\"\n#include \"xrandr.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nint copy_screen(void);\nvoid set_offset(void);\nint scan_for_updates(int count_only);\nstatic void hint_updates(void);\nstatic int copy_all_tiles(void);\nstatic int copy_all_tile_runs(void);\nstatic int copy_tiles_backward_pass(void);\nstatic int copy_tiles_additional_pass(void);\nstatic int fill_tile_gaps(void);\nstatic int island_try(int x, int y, int u, int v, int *run);\nstatic int grow_islands(void);\nstatic int blackout_line_skip(int n, int x, int y, int rescan,\n    int *tile_count);\nstatic int scan_display(int ystart, int rescan);\nstatic int scan_count = 0;\nstatic int scan_in_progress = 0;\nstatic int fs_factor = 0;\nstatic int xd_samples = 0, xd_misses = 0, xd_do_check = 0;\nint scanlines[NSCAN] = {\n\t 0, 16,  8, 24,  4, 20, 12, 28,\n\t10, 26, 18,  2, 22,  6, 30, 14,\n\t 1, 17,  9, 25,  7, 23, 15, 31,\n\t19,  3, 27, 11, 29, 13,  5, 21\n};\n\nint scan_for_updates(int count_only) {\n\tint i, tile_count, tile_diffs;\n\tint old_copy_tile;\n\tdouble frac1 = 0.1;   /* tweak parameter to try a 2nd scan_display() */\n\tdouble frac2 = 0.35;  /* or 3rd */\n\tdouble frac3 = 0.02;  /* do scan_display() again after copy_tiles() */\n\tstatic double last_poll = 0.0;\n\n\tif (unixpw_in_progress) return 0;\n \n\tif (slow_fb > 0.0) {\n\t\tdouble now = dnow();\n\t\tif (now < last_poll + slow_fb) {\n\t\t\treturn 0;\n\t\t}\n\t\tlast_poll = now;\n\t}\n\n\tfor (i=0; i < ntiles; i++) {\n\t\ttile_has_diff[i] = 0;\n\t\ttile_has_xdamage_diff[i] = 0;\n\t\ttile_tried[i] = 0;\n\t\ttile_copied[i] = 0;\n\t}\n\tfor (i=0; i < ntiles_y; i++) {\n\t\t/* could be useful, currently not used */\n\t\ttile_row_has_xdamage_diff[i] = 0;\n\t}\n\txdamage_tile_count = 0;\n\n\t/*\n\t * n.b. this program has only been tested so far with\n\t * tile_x = tile_y = NSCAN = 32!\n\t */\n\n\tif (!count_only) {\n\t\tscan_count++;\n\t\tscan_count %= NSCAN;\n\n\t\t/* some periodic maintenance */\n\t\tif (subwin && scan_count % 4 == 0) {\n\t\t\tset_offset();\t/* follow the subwindow */\n\t\t}\n\t\tif (indexed_color && scan_count % 4 == 0) {\n\t\t\t/* check for changed colormap */\n\t\t\tset_colormap(0);\n\t\t}\n\t\tif (cmap8to24 && scan_count % 1 == 0) {\n\t\t\tcheck_for_multivis();\n\t\t}\n#ifdef MACOSX\n\t\tif (macosx_console) {\n\t\t\tmacosx_event_loop();\n\t\t}\n#endif\n\t\tif (use_xdamage) {\n\t\t\t/* first pass collecting DAMAGE events: */\n#ifdef MACOSX\n\t\t\tif (macosx_console) {\n\t\t\t\tcollect_non_X_xdamage(-1, -1, -1, -1, 0);\n\t\t\t} else \n#endif\n\t\t\t{\n\t\t\t\tif (rawfb_vnc_reflect) {\n\t\t\t\t\tcollect_non_X_xdamage(-1, -1, -1, -1, 0);\n\t\t\t\t} else {\n\t\t\t\t\tcollect_xdamage(scan_count, 0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n#define SCAN_FATAL(x) \\\n\tif (x < 0) { \\\n\t\tscan_in_progress = 0; \\\n\t\tfb_copy_in_progress = 0; \\\n\t\treturn 0; \\\n\t}\n\n\t/* scan with the initial y to the jitter value from scanlines: */\n\tscan_in_progress = 1;\n\ttile_count = scan_display(scanlines[scan_count], 0);\n\tSCAN_FATAL(tile_count);\n\n\t/*\n\t * we do the XDAMAGE here too since after scan_display()\n\t * there is a better chance we have received the events from\n\t * the X server (otherwise the DAMAGE events will be processed\n\t * in the *next* call, usually too late and wasteful since\n\t * the unchanged tiles are read in again).\n\t */\n\tif (use_xdamage) {\n#ifdef MACOSX\n\t\tif (macosx_console) {\n\t\t\t;\n\t\t} else \n#endif\n\t\t{\n\t\t\tif (rawfb_vnc_reflect) {\n\t\t\t\t;\n\t\t\t} else {\n\t\t\t\tcollect_xdamage(scan_count, 1);\n\t\t\t}\n\t\t}\n\t}\n\tif (count_only) {\n\t\tscan_in_progress = 0;\n\t\tfb_copy_in_progress = 0;\n\t\treturn tile_count;\n\t}\n\n\tif (xdamage_tile_count) {\n\t\t/* pick up \"known\" damaged tiles we missed in scan_display() */\n\t\tfor (i=0; i < ntiles; i++) {\n\t\t\tif (tile_has_diff[i]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (tile_has_xdamage_diff[i]) {\n\t\t\t\ttile_has_diff[i] = 1;\n\t\t\t\tif (tile_has_xdamage_diff[i] == 1) {\n\t\t\t\t\ttile_has_xdamage_diff[i] = 2;\n\t\t\t\t\ttile_count++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (dpy && use_xdamage == 1) {\n\t\tstatic time_t last_xd_check = 0;\n\t\tif (time(NULL) > last_xd_check + 2) {\n\t\t\tint cp = (scan_count + 3) % NSCAN;\n\t\t\txd_do_check = 1;\n\t\t\ttile_count = scan_display(scanlines[cp], 0);\n\t\t\txd_do_check = 0;\n\t\t\tSCAN_FATAL(tile_count);\n\t\t\tlast_xd_check = time(NULL);\n\t\t\tif (xd_samples > 200) {\n\t\t\t\tstatic int bad = 0;\n\t\t\t\tif (xd_misses > (20 * xd_samples) / 100) {\n\t\t\t\t\trfbLog(\"XDAMAGE is not working well... misses: %d/%d\\n\", xd_misses, xd_samples);\n\t\t\t\t\trfbLog(\"Maybe an OpenGL app like Beryl or Compiz is the problem?\\n\");\n\t\t\t\t\trfbLog(\"Use x11vnc -noxdamage or disable the Beryl/Compiz app.\\n\");\n\t\t\t\t\trfbLog(\"To disable this check and warning specify -xdamage twice.\\n\");\n\t\t\t\t\tif (++bad >= 10) {\n\t\t\t\t\t\trfbLog(\"XDAMAGE appears broken (OpenGL app?), turning it off.\\n\");\n\t\t\t\t\t\tuse_xdamage = 0;\n\t\t\t\t\t\tinitialize_xdamage();\n\t\t\t\t\t\tdestroy_xdamage_if_needed();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\txd_samples = 0;\n\t\t\t\txd_misses = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tnap_set(tile_count);\n\n\tif (fs_factor && frac1 >= fs_frac) {\n\t\t/* make frac1 < fs_frac if fullscreen updates are enabled */\n\t\tfrac1 = fs_frac/2.0;\n\t}\n\n\tif (tile_count > frac1 * ntiles) {\n\t\t/*\n\t\t * many tiles have changed, so try a rescan (since it should\n\t\t * be short compared to the many upcoming copy_tiles() calls)\n\t\t */\n\n\t\t/* this check is done to skip the extra scan_display() call */\n\t\tif (! fs_factor || tile_count <= fs_frac * ntiles) {\n\t\t\tint cp, tile_count_old = tile_count;\n\t\t\t\n\t\t\t/* choose a different y shift for the 2nd scan: */\n\t\t\tcp = (NSCAN - scan_count) % NSCAN;\n\n\t\t\ttile_count = scan_display(scanlines[cp], 1);\n\t\t\tSCAN_FATAL(tile_count);\n\n\t\t\tif (tile_count >= (1 + frac2) * tile_count_old) {\n\t\t\t\t/* on a roll... do a 3rd scan */\n\t\t\t\tcp = (NSCAN - scan_count + 7) % NSCAN;\n\t\t\t\ttile_count = scan_display(scanlines[cp], 1);\n\t\t\t\tSCAN_FATAL(tile_count);\n\t\t\t}\n\t\t}\n\t\tscan_in_progress = 0;\n\n\t\t/*\n\t\t * At some number of changed tiles it is better to just\n\t\t * copy the full screen at once.  I.e. time = c1 + m * r1\n\t\t * where m is number of tiles, r1 is the copy_tiles()\n\t\t * time, and c1 is the scan_display() time: for some m\n\t\t * it crosses the full screen update time.\n\t\t *\n\t\t * We try to predict that crossover with the fs_frac\n\t\t * fudge factor... seems to be about 1/2 the total number\n\t\t * of tiles.  n.b. this ignores network bandwidth,\n\t\t * compression time etc...\n\t\t *\n\t\t * Use -fs 1.0 to disable on slow links.\n\t\t */\n\t\tif (fs_factor && tile_count > fs_frac * ntiles) {\n\t\t\tint cs;\n\t\t\tfb_copy_in_progress = 1;\n\t\t\tcs = copy_screen();\n\t\t\tfb_copy_in_progress = 0;\n\t\t\tSCAN_FATAL(cs);\n\t\t\tif (use_threads && pointer_mode != 1) {\n\t\t\t\tpointer_event(-1, 0, 0, NULL);\n\t\t\t}\n\t\t\tnap_check(tile_count);\n\t\t\treturn tile_count;\n\t\t}\n\t}\n\tscan_in_progress = 0;\n\n\t/* copy all tiles with differences from display to rfb framebuffer: */\n\tfb_copy_in_progress = 1;\n\n\tif (single_copytile || tile_shm_count < ntiles_x) {\n\t\t/*\n\t\t * Old way, copy I/O one tile at a time.\n\t\t */\n\t\told_copy_tile = 1;\n\t} else {\n\t\t/* \n\t\t * New way, does runs of horizontal tiles at once.\n\t\t * Note that below, for simplicity, the extra tile finding\n\t\t * (e.g. copy_tiles_backward_pass) is done the old way.\n\t\t */\n\t\told_copy_tile = 0;\n\t}\n\n\tif (unixpw_in_progress) return 0;\n\n\tif (old_copy_tile) {\n\t\ttile_diffs = copy_all_tiles();\n\t} else {\n\t\ttile_diffs = copy_all_tile_runs();\n\t}\n\tSCAN_FATAL(tile_diffs);\n\n\t/*\n\t * This backward pass for upward and left tiles complements what\n\t * was done in copy_all_tiles() for downward and right tiles.\n\t */\n\ttile_diffs = copy_tiles_backward_pass();\n\tSCAN_FATAL(tile_diffs);\n\n\tif (tile_diffs > frac3 * ntiles) {\n\t\t/*\n\t\t * we spent a lot of time in those copy_tiles, run\n\t\t * another scan, maybe more of the screen changed.\n\t\t */\n\t\tint cp = (NSCAN - scan_count + 13) % NSCAN;\n\n\t\tscan_in_progress = 1;\n\t\ttile_count = scan_display(scanlines[cp], 1);\n\t\tSCAN_FATAL(tile_count);\n\t\tscan_in_progress = 0;\n\n\t\ttile_diffs = copy_tiles_additional_pass();\n\t\tSCAN_FATAL(tile_diffs);\n\t}\n\n\t/* Given enough tile diffs, try the islands: */\n\tif (grow_fill && tile_diffs > 4) {\n\t\ttile_diffs = grow_islands();\n\t}\n\tSCAN_FATAL(tile_diffs);\n\n\t/* Given enough tile diffs, try the gaps: */\n\tif (gaps_fill && tile_diffs > 4) {\n\t\ttile_diffs = fill_tile_gaps();\n\t}\n\tSCAN_FATAL(tile_diffs);\n\n\tfb_copy_in_progress = 0;\n\tif (use_threads && pointer_mode != 1) {\n\t\t/*\n\t\t * tell the pointer handler it can process any queued\n\t\t * pointer events:\n\t\t */\n\t\tpointer_event(-1, 0, 0, NULL);\n\t}\n\n\tif (blackouts) {\n\t\t/* ignore any diffs in completely covered tiles */\n\t\tint x, y, n;\n\t\tfor (y=0; y < ntiles_y; y++) {\n\t\t\tfor (x=0; x < ntiles_x; x++) {\n\t\t\t\tn = x + y * ntiles_x;\n\t\t\t\tif (tile_blackout[n].cover == 2) {\n\t\t\t\t\ttile_has_diff[n] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\thint_updates();\t/* use x0rfbserver hints algorithm */\n\n\t/* Work around threaded rfbProcessClientMessage() calls timeouts */\n\tif (use_threads) {\n\t\tping_clients(tile_diffs);\n\t} else if (saw_ultra_chat || saw_ultra_file) {\n\t\tping_clients(-1);\n\t} else if (use_openssl && !tile_diffs) {\n\t\tping_clients(0);\n\t}\n\t/* -ping option: */\n\tif (ping_interval) {\n\t\tint td = ping_interval > 0 ? ping_interval : -ping_interval;\n\t\tping_clients(-td);\n\t}\n\n\n\tnap_check(tile_diffs);\n\treturn tile_diffs;\n}"
  },
  {
    "function_name": "scan_display",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/scan.c",
    "lines": "3168-3342",
    "snippet": "static int scan_display(int ystart, int rescan) {\n\tchar *src, *dst;\n\tint pixelsize = bpp/8;\n\tint x, y, w, n;\n\tint tile_count = 0;\n\tint nodiffs = 0, diff_hint;\n\tint xd_check = 0, xd_freq = 1;\n\tstatic int xd_tck = 0;\n\n\ty = ystart;\n\n\tg_now = dnow();\n\n\tif (! main_fb) {\n\t\trfbLog(\"scan_display: no main_fb!\\n\");\n\t\treturn 0;\n\t}\n\n\tX_LOCK;\n\n\twhile (y < dpy_y) {\n\n\t\tif (use_xdamage) {\n\t\t\tXD_tot++;\n\t\t\txd_check = 0;\n\t\t\tif (xdamage_hint_skip(y)) {\n\t\t\t\tif (xd_do_check && dpy && use_xdamage == 1) {\n\t\t\t\t\txd_tck++;\n\t\t\t\t\txd_tck = xd_tck % xd_freq;\n\t\t\t\t\tif (xd_tck == 0) {\n\t\t\t\t\t\txd_check = 1;\n\t\t\t\t\t\txd_samples++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!xd_check) {\n\t\t\t\t\tXD_skip++;\n\t\t\t\t\ty += NSCAN;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (xd_do_check && 0) {\n\t\t\t\t\tfprintf(stderr, \"ns y=%d\\n\", y);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* grab the horizontal scanline from the display: */\n\n#ifndef NO_NCACHE\n/* XXX Y test */\nif (ncache > 0) {\n\tint gotone = 0;\n\tif (macosx_console) {\n\t\tif (macosx_checkevent(NULL)) {\n\t\t\tgotone = 1;\n\t\t}\n\t} else {\n#if !NO_X11\n\t\tXEvent ev;\n\t\tif (raw_fb_str) {\n\t\t\t;\n\t\t} else if (XEventsQueued(dpy, QueuedAlready) == 0) {\n\t\t\t;\t/* XXX Y resp */\n\t\t} else if (XCheckTypedEvent(dpy, MapNotify, &ev)) {\n\t\t\tgotone = 1;\n\t\t} else if (XCheckTypedEvent(dpy, UnmapNotify, &ev)) {\n\t\t\tgotone = 2;\n\t\t} else if (XCheckTypedEvent(dpy, CreateNotify, &ev)) {\n\t\t\tgotone = 3;\n\t\t} else if (XCheckTypedEvent(dpy, ConfigureNotify, &ev)) {\n\t\t\tgotone = 4;\n\t\t} else if (XCheckTypedEvent(dpy, VisibilityNotify, &ev)) {\n\t\t\tgotone = 5;\n\t\t}\n\t\tif (gotone) {\n\t\t\tXPutBackEvent(dpy, &ev);\n\t\t}\n#endif\n\t}\n\tif (gotone) {\n\t\tstatic int nomsg = 1;\n\t\tif (nomsg) {\n\t\t\tif (dnowx() > 20) {\n\t\t\t\tnomsg = 0;\n\t\t\t}\n\t\t} else {\nif (ncdb) fprintf(stderr, \"\\n*** SCAN_DISPLAY CHECK_NCACHE/%d *** %d rescan=%d\\n\", gotone, y, rescan);\n\t\t}\n\t\tX_UNLOCK;\n\t\tcheck_ncache(0, 1);\n\t\tX_LOCK;\n\t}\n}\n#endif\n\n\t\tXRANDR_SET_TRAP_RET(-1, \"scan_display-set\");\n\t\tcopy_image(scanline, 0, y, 0, 0);\n\t\tXRANDR_CHK_TRAP_RET(-1, \"scan_display-chk\");\n\n\t\t/* for better memory i/o try the whole line at once */\n\t\tsrc = scanline->data;\n\t\tdst = main_fb + y * main_bytes_per_line;\n\n\t\tif (! memcmp(dst, src, main_bytes_per_line)) {\n\t\t\t/* no changes anywhere in scan line */\n\t\t\tnodiffs = 1;\n\t\t\tif (! rescan) {\n\t\t\t\ty += NSCAN;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (xd_check) {\n\t\t\txd_misses++;\n\t\t}\n\n\t\tx = 0;\n\t\twhile (x < dpy_x) {\n\t\t\tn = (x/tile_x) + (y/tile_y) * ntiles_x;\n\t\t\tdiff_hint = 0;\n\n\t\t\tif (blackouts) {\n\t\t\t\tif (blackout_line_skip(n, x, y, rescan,\n\t\t\t\t    &tile_count)) {\n\t\t\t\t\tx += NSCAN;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (rescan) {\n\t\t\t\tif (nodiffs || tile_has_diff[n]) {\n\t\t\t\t\ttile_count += tile_has_diff[n];\n\t\t\t\t\tx += NSCAN;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else if (xdamage_tile_count &&\n\t\t\t    tile_has_xdamage_diff[n]) {\n\t\t\t\ttile_has_xdamage_diff[n] = 2;\n\t\t\t\tdiff_hint = 1;\n\t\t\t}\n\n\t\t\t/* set ptrs to correspond to the x offset: */\n\t\t\tsrc = scanline->data + x * pixelsize;\n\t\t\tdst = main_fb + y * main_bytes_per_line + x * pixelsize;\n\n\t\t\t/* compute the width of data to be compared: */\n\t\t\tif (x + NSCAN > dpy_x) {\n\t\t\t\tw = dpy_x - x;\n\t\t\t} else {\n\t\t\t\tw = NSCAN;\n\t\t\t}\n\n\t\t\tif (diff_hint || memcmp(dst, src, w * pixelsize)) {\n\t\t\t\t/* found a difference, record it: */\n\t\t\t\tif (! blackouts) {\n\t\t\t\t\ttile_has_diff[n] = 1;\n\t\t\t\t\ttile_count++;\t\t\n\t\t\t\t} else {\n\t\t\t\t\tif (blackout_line_cmpskip(n, x, y,\n\t\t\t\t\t    dst, src, w, pixelsize)) {\n\t\t\t\t\t\ttile_has_diff[n] = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttile_has_diff[n] = 1;\n\t\t\t\t\t\ttile_count++;\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tx += NSCAN;\n\t\t}\n\t\ty += NSCAN;\n\t}\n\n\tX_UNLOCK;\n\n\treturn tile_count;\n}",
    "includes": [
      "#include <default8x16.h>",
      "#include \"userinput.h\"",
      "#include \"macosx.h\"",
      "#include \"screen.h\"",
      "#include \"unixpw.h\"",
      "#include \"cleanup.h\"",
      "#include \"pointer.h\"",
      "#include \"screen.h\"",
      "#include \"8to24.h\"",
      "#include \"win_utils.h\"",
      "#include \"xrandr.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"xinerama.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int blackout_line_skip(int n, int x, int y, int rescan,\n    int *tile_count);",
      "static int blackout_line_cmpskip(int n, int x, int y, char *dst, char *src,\n    int w, int pixelsize);",
      "static int scan_display(int ystart, int rescan);",
      "static int xd_samples = 0, xd_misses = 0, xd_do_check = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "blackout_line_cmpskip",
          "args": [
            "n",
            "x",
            "y",
            "dst",
            "src",
            "w",
            "pixelsize"
          ],
          "line": 3325
        },
        "resolved": true,
        "details": {
          "function_name": "blackout_line_cmpskip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/scan.c",
          "lines": "3089-3144",
          "snippet": "static int blackout_line_cmpskip(int n, int x, int y, char *dst, char *src,\n    int w, int pixelsize) {\n\n\tint i, x1, y1, x2, y2, b, hit = 0;\n\tint beg = -1, end = -1; \n\n\tif (tile_blackout[n].cover == 0) {\n\t\treturn 0;\t/* 0 means do not skip it. */\n\t} else if (tile_blackout[n].cover == 2) {\n\t\treturn 1;\t/* 1 means skip it. */\n\t}\n\n\t/* tile has partial coverage: */\n\n\tfor (i=0; i < w * pixelsize; i++)  {\n\t\tif (*(dst+i) != *(src+i)) {\n\t\t\tbeg = i/pixelsize;\t/* beginning difference */\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (i = w * pixelsize - 1; i >= 0; i--)  {\n\t\tif (*(dst+i) != *(src+i)) {\n\t\t\tend = i/pixelsize;\t/* ending difference */\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (beg < 0 || end < 0) {\n\t\t/* problem finding range... */\n\t\treturn 0;\n\t}\n\n\t/* loop over blackout rectangles: */\n\tfor (b=0; b < tile_blackout[n].count; b++) {\n\t\t\n\t\t/* y in full display space: */\n\t\ty1 = tile_blackout[n].bo[b].y1;\n\t\ty2 = tile_blackout[n].bo[b].y2;\n\n\t\t/* x relative to tile origin: */\n\t\tx1 = tile_blackout[n].bo[b].x1 - x;\n\t\tx2 = tile_blackout[n].bo[b].x2 - x;\n\n\t\tif (y1 > y || y >= y2) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (x1 <= beg && end <= x2) {\n\t\t\thit = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (hit) {\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include <default8x16.h>",
            "#include \"userinput.h\"",
            "#include \"macosx.h\"",
            "#include \"screen.h\"",
            "#include \"unixpw.h\"",
            "#include \"cleanup.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"8to24.h\"",
            "#include \"win_utils.h\"",
            "#include \"xrandr.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int blackout_line_cmpskip(int n, int x, int y, char *dst, char *src,\n    int w, int pixelsize);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <default8x16.h>\n#include \"userinput.h\"\n#include \"macosx.h\"\n#include \"screen.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"8to24.h\"\n#include \"win_utils.h\"\n#include \"xrandr.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nstatic int blackout_line_cmpskip(int n, int x, int y, char *dst, char *src,\n    int w, int pixelsize);\n\nstatic int blackout_line_cmpskip(int n, int x, int y, char *dst, char *src,\n    int w, int pixelsize) {\n\n\tint i, x1, y1, x2, y2, b, hit = 0;\n\tint beg = -1, end = -1; \n\n\tif (tile_blackout[n].cover == 0) {\n\t\treturn 0;\t/* 0 means do not skip it. */\n\t} else if (tile_blackout[n].cover == 2) {\n\t\treturn 1;\t/* 1 means skip it. */\n\t}\n\n\t/* tile has partial coverage: */\n\n\tfor (i=0; i < w * pixelsize; i++)  {\n\t\tif (*(dst+i) != *(src+i)) {\n\t\t\tbeg = i/pixelsize;\t/* beginning difference */\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (i = w * pixelsize - 1; i >= 0; i--)  {\n\t\tif (*(dst+i) != *(src+i)) {\n\t\t\tend = i/pixelsize;\t/* ending difference */\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (beg < 0 || end < 0) {\n\t\t/* problem finding range... */\n\t\treturn 0;\n\t}\n\n\t/* loop over blackout rectangles: */\n\tfor (b=0; b < tile_blackout[n].count; b++) {\n\t\t\n\t\t/* y in full display space: */\n\t\ty1 = tile_blackout[n].bo[b].y1;\n\t\ty2 = tile_blackout[n].bo[b].y2;\n\n\t\t/* x relative to tile origin: */\n\t\tx1 = tile_blackout[n].bo[b].x1 - x;\n\t\tx2 = tile_blackout[n].bo[b].x2 - x;\n\n\t\tif (y1 > y || y >= y2) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (x1 <= beg && end <= x2) {\n\t\t\thit = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (hit) {\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "dst",
            "src",
            "w * pixelsize"
          ],
          "line": 3319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blackout_line_skip",
          "args": [
            "n",
            "x",
            "y",
            "rescan",
            "&tile_count"
          ],
          "line": 3289
        },
        "resolved": true,
        "details": {
          "function_name": "blackout_line_skip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/scan.c",
          "lines": "3045-3087",
          "snippet": "static int blackout_line_skip(int n, int x, int y, int rescan,\n    int *tile_count) {\n\t\n\tif (tile_blackout[n].cover == 2) {\n\t\ttile_has_diff[n] = 0;\n\t\treturn 1;\t/* skip it */\n\n\t} else if (tile_blackout[n].cover == 1) {\n\t\tint w, x1, y1, x2, y2, b, hit = 0;\n\t\tif (x + NSCAN > dpy_x) {\n\t\t\tw = dpy_x - x;\n\t\t} else {\n\t\t\tw = NSCAN;\n\t\t}\n\n\t\tfor (b=0; b < tile_blackout[n].count; b++) {\n\t\t\t\n\t\t\t/* n.b. these coords are in full display space: */\n\t\t\tx1 = tile_blackout[n].bo[b].x1;\n\t\t\tx2 = tile_blackout[n].bo[b].x2;\n\t\t\ty1 = tile_blackout[n].bo[b].y1;\n\t\t\ty2 = tile_blackout[n].bo[b].y2;\n\n\t\t\tif (x2 - x1 < w) {\n\t\t\t\t/* need to cover full width */\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (y1 <= y && y < y2) {\n\t\t\t\thit = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (hit) {\n\t\t\tif (! rescan) {\n\t\t\t\ttile_has_diff[n] = 0;\n\t\t\t} else {\n\t\t\t\t*tile_count += tile_has_diff[n];\n\t\t\t}\n\t\t\treturn 1;\t/* skip */\n\t\t}\n\t}\n\treturn 0;\t/* do not skip */\n}",
          "includes": [
            "#include <default8x16.h>",
            "#include \"userinput.h\"",
            "#include \"macosx.h\"",
            "#include \"screen.h\"",
            "#include \"unixpw.h\"",
            "#include \"cleanup.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"8to24.h\"",
            "#include \"win_utils.h\"",
            "#include \"xrandr.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int blackout_line_skip(int n, int x, int y, int rescan,\n    int *tile_count);",
            "static int scan_display(int ystart, int rescan);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <default8x16.h>\n#include \"userinput.h\"\n#include \"macosx.h\"\n#include \"screen.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"8to24.h\"\n#include \"win_utils.h\"\n#include \"xrandr.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nstatic int blackout_line_skip(int n, int x, int y, int rescan,\n    int *tile_count);\nstatic int scan_display(int ystart, int rescan);\n\nstatic int blackout_line_skip(int n, int x, int y, int rescan,\n    int *tile_count) {\n\t\n\tif (tile_blackout[n].cover == 2) {\n\t\ttile_has_diff[n] = 0;\n\t\treturn 1;\t/* skip it */\n\n\t} else if (tile_blackout[n].cover == 1) {\n\t\tint w, x1, y1, x2, y2, b, hit = 0;\n\t\tif (x + NSCAN > dpy_x) {\n\t\t\tw = dpy_x - x;\n\t\t} else {\n\t\t\tw = NSCAN;\n\t\t}\n\n\t\tfor (b=0; b < tile_blackout[n].count; b++) {\n\t\t\t\n\t\t\t/* n.b. these coords are in full display space: */\n\t\t\tx1 = tile_blackout[n].bo[b].x1;\n\t\t\tx2 = tile_blackout[n].bo[b].x2;\n\t\t\ty1 = tile_blackout[n].bo[b].y1;\n\t\t\ty2 = tile_blackout[n].bo[b].y2;\n\n\t\t\tif (x2 - x1 < w) {\n\t\t\t\t/* need to cover full width */\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (y1 <= y && y < y2) {\n\t\t\t\thit = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (hit) {\n\t\t\tif (! rescan) {\n\t\t\t\ttile_has_diff[n] = 0;\n\t\t\t} else {\n\t\t\t\t*tile_count += tile_has_diff[n];\n\t\t\t}\n\t\t\treturn 1;\t/* skip */\n\t\t}\n\t}\n\treturn 0;\t/* do not skip */\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "dst",
            "src",
            "main_bytes_per_line"
          ],
          "line": 3271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XRANDR_CHK_TRAP_RET",
          "args": [
            "-1",
            "\"scan_display-chk\""
          ],
          "line": 3265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_image",
          "args": [
            "scanline",
            "0",
            "y",
            "0",
            "0"
          ],
          "line": 3264
        },
        "resolved": true,
        "details": {
          "function_name": "copy_image",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "832-868",
          "snippet": "void copy_image(XImage *dest, int x, int y, unsigned int w, unsigned int h) {\n\t/* default (w=0, h=0) is the fill the entire XImage */\n\tif (dest == NULL) {\n\t\treturn;\n\t}\n\tif (w < 1)  {\n\t\tw = dest->width;\n\t}\n\tif (h < 1)  {\n\t\th = dest->height;\n\t}\n\n\tif (raw_fb) {\n\t\tcopy_raw_fb(dest, x, y, w, h);\n\n\t} else if (use_snapfb && snap_fb && dest != snaprect) {\n\t\tchar *src, *dst;\n\t\tunsigned int line;\n\t\tint pixelsize = bpp/8;\n\n\t\tsrc = snap->data + snap->bytes_per_line*y + pixelsize*x;\n\t\tdst = dest->data;\n\t\tfor (line = 0; line < h; line++) {\n\t\t\tmemcpy(dst, src, w * pixelsize);\n\t\t\tsrc += snap->bytes_per_line;\n\t\t\tdst += dest->bytes_per_line;\n\t\t}\n\n\t} else if ((using_shm && ! xform24to32) && (int) w == dest->width &&\n\t    (int) h == dest->height) {\n\t\tXShmGetImage_wr(dpy, window, dest, x, y, AllPlanes);\n\n\t} else {\n\t\tXGetSubImage_wr(dpy, window, x, y, w, h, AllPlanes,\n\t\t    ZPixmap, dest, 0, 0);\n\t}\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "XImage *XShmCreateImage_wr(Display* disp, Visual* vis, unsigned int depth,\n    int format, char* data, XShmSegmentInfo* shminfo, unsigned int width,\n    unsigned int height);",
            "XImage *XCreateImage_wr(Display *disp, Visual *visual, unsigned int depth,\n    int format, int offset, char *data, unsigned int width,\n    unsigned int height, int bitmap_pad, int bytes_per_line);",
            "void copy_image(XImage *dest, int x, int y, unsigned int w, unsigned int h);",
            "Bool XTestCompareCurrentCursorWithWindow_wr(Display* dpy, Window w);",
            "void XTestDiscard_wr(Display *dpy);",
            "int XFree_wr(void *data);",
            "void copy_raw_fb(XImage *dest, int x, int y, unsigned int w, unsigned int h);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nXImage *XShmCreateImage_wr(Display* disp, Visual* vis, unsigned int depth,\n    int format, char* data, XShmSegmentInfo* shminfo, unsigned int width,\n    unsigned int height);\nXImage *XCreateImage_wr(Display *disp, Visual *visual, unsigned int depth,\n    int format, int offset, char *data, unsigned int width,\n    unsigned int height, int bitmap_pad, int bytes_per_line);\nvoid copy_image(XImage *dest, int x, int y, unsigned int w, unsigned int h);\nBool XTestCompareCurrentCursorWithWindow_wr(Display* dpy, Window w);\nvoid XTestDiscard_wr(Display *dpy);\nint XFree_wr(void *data);\nvoid copy_raw_fb(XImage *dest, int x, int y, unsigned int w, unsigned int h);\n\nvoid copy_image(XImage *dest, int x, int y, unsigned int w, unsigned int h) {\n\t/* default (w=0, h=0) is the fill the entire XImage */\n\tif (dest == NULL) {\n\t\treturn;\n\t}\n\tif (w < 1)  {\n\t\tw = dest->width;\n\t}\n\tif (h < 1)  {\n\t\th = dest->height;\n\t}\n\n\tif (raw_fb) {\n\t\tcopy_raw_fb(dest, x, y, w, h);\n\n\t} else if (use_snapfb && snap_fb && dest != snaprect) {\n\t\tchar *src, *dst;\n\t\tunsigned int line;\n\t\tint pixelsize = bpp/8;\n\n\t\tsrc = snap->data + snap->bytes_per_line*y + pixelsize*x;\n\t\tdst = dest->data;\n\t\tfor (line = 0; line < h; line++) {\n\t\t\tmemcpy(dst, src, w * pixelsize);\n\t\t\tsrc += snap->bytes_per_line;\n\t\t\tdst += dest->bytes_per_line;\n\t\t}\n\n\t} else if ((using_shm && ! xform24to32) && (int) w == dest->width &&\n\t    (int) h == dest->height) {\n\t\tXShmGetImage_wr(dpy, window, dest, x, y, AllPlanes);\n\n\t} else {\n\t\tXGetSubImage_wr(dpy, window, x, y, w, h, AllPlanes,\n\t\t    ZPixmap, dest, 0, 0);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "XRANDR_SET_TRAP_RET",
          "args": [
            "-1",
            "\"scan_display-set\""
          ],
          "line": 3263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_ncache",
          "args": [
            "0",
            "1"
          ],
          "line": 3257
        },
        "resolved": true,
        "details": {
          "function_name": "check_ncache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "8880-10195",
          "snippet": "int check_ncache(int reset, int mode) {\n\tstatic int first = 1;\n\tstatic int last_client_count = -1;\n\tint i, k, n; \n\tint did_sched = 0;\n\n\tWindow win, win2;\n\tXWindowAttributes attr;\n\tint valid;\n\tint try_batch = 1; /* XXX Y */\n\tint use_batch = 0;\n\tint nreg = 0, *nbatch;\n\tint create_cnt;\n\tint su_fix_cnt;\n\tint pixels = 0, ttot;\n\tint desktop_change = 0, n1, n2;\n\tint desktop_change_old_wm = 0;\n\tint missed_su_restore = 0;\n\tint missed_bs_restore = 0;\n\tsraRegionPtr r0, r;\n\tsraRegionPtr missed_su_restore_rgn;\n\tsraRegionPtr missed_bs_restore_rgn;\n\tsraRegionPtr unmapped_rgn;\n\n\tint nrects = 0;\n\tint nsave, nxsel;\n\tdouble now;\n\n\tint skipwins_n = 0;\n\tint skipwins_max = 256;\n\tWindow skipwins[256];\n\n\tstatic char *dt_guess = NULL;\n\tstatic double dt_last = 0.0;\n\tint dt_gnome = 0, gnome_animation = 0;\n\tint dt_kde = 0;\n\n\tif (unixpw_in_progress) return -1;\n\n#ifdef MACOSX\n\tif (! macosx_console) {\n\t\tRAWFB_RET(-1)\n\t}\n\tif (! screen) {\n\t\treturn -1;\n\t}\n#else\n\tRAWFB_RET(-1)\n\tif (! screen || ! dpy) {\n\t\treturn -1;\n\t}\n#endif\n\n\tnow = dnow();\n\n#ifdef NO_NCACHE\n\tncache = 0;\n#endif\n\n\tif (reset && (first || cache_list_len == 0)) {\n\t\treturn -1;\n\t}\n\tif (use_threads) {\n\t\ttry_batch = 0;\n\t}\n\n\tif (ncache0) {\n\t\tif (reset) {\n\t\t\t;\n\t\t} else if (!client_count || !ncache || nofb) {\n\t\t\tstatic double last_purge = 0.0;\n\t\t\tdouble delay = client_count ? 0.5 : 2.0;\n\t\t\tif (now > last_purge + delay) {\n\t\t\t\tint c = 0;\n\t\t\t\tXEvent ev;\n\t\t\t\tX_LOCK;\n\t\t\t\twhile (xcheckmaskevent(dpy, all_ev, &ev)) {\n\t\t\t\t\tc++;\n\t\t\t\t}\n\t\t\t\tX_UNLOCK;\n\t\t\t\tlast_purge = dnow();\nif (ncdb && c) fprintf(stderr, \"check_ncache purged %d events\\n\", c); \n\t\t\t}\n\t\t\tif (!client_count && last_client_count >= 0 &&\n\t\t\t    client_count != last_client_count) {\n\t\t\t\t/* this should use less RAM when no clients */\n\t\t\t\tdo_new_fb(1);\n\t\t\t}\n\t\t\tlast_client_count = client_count;\n\t\t\treturn -1;\n\t\t}\n\t}\n\tlast_client_count = client_count;\n\n\tif (ncache && ! ncache0) {\n\t\tncache0 = ncache;\n\t}\n\n\tif (! ncache || ! ncache0) {\n\t\treturn -1;\n\t}\n\tif (subwin) {\n\t\treturn -1;\n\t}\n\tif (nofb) {\n\t\treturn -1;\n\t}\n\tif (now < last_client + 4) {\n\t\treturn -1;\n\t}\n\tif (! all_clients_initialized()) {\n\t\t/* play it safe */\n\t\treturn -1;\n\t}\n\n\n\n\tif (reset) {\n\t\trfbLog(\"check_ncache: resetting cache: %d/%d %d %d\\n\", cache_list_num, cache_list_len, ncache, first);\n\t\tfor (i=0; i < cache_list_num; i++) {\n\t\t\tfree_rect(i);\n\t\t}\n\t\tfor (n = 1; n <= ncache; n++) {\n\t\t\tif (rect_reg[n] != NULL) {\n\t\t\t\tsraRgnDestroy(rect_reg[n]);\n\t\t\t\trect_reg[n] = NULL;\n\t\t\t}\n\t\t}\n\t\tzero_fb(0, dpy_y, dpy_x, (ncache+1)*dpy_y);\n\t\tmark_rect_as_modified(0, dpy_y, dpy_x, (ncache+1)*dpy_y, 0);\n\n\t\tif (ncache_xrootpmap) {\n\t\t\tset_ncache_xrootpmap();\n\t\t}\n\n\t\tsnap_old();\n\t\treturn -1;\n\t}\n\n\tif (first) {\n\t\tint dx = 10, dy = 24, ds = 0;\n\t\tint Dx = dpy_x, Dy = dpy_y;\n\t\tfirst = 0;\n\t\tfor (i=0; i < NRECENT; i++) {\n\t\t\trecent[i] = None;\n\t\t}\n\t\tfor (i=0; i < NSCHED; i++) {\n\t\t\tsched_bs[i] = None;\n\t\t}\n\t\trlast = 0;\n\n\t\tX_LOCK;\n\t\t/* event leak with client_count == 0 */\n\t\txselectinput_rootwin |= SubstructureNotifyMask;\n\t\tXSelectInput_wr(dpy, rootwin, xselectinput_rootwin);\n\t\tX_UNLOCK;\n\n\t\tif (scaling) {\n\t\t\tDx = scaled_x;\n\t\t\tDy = scaled_y;\n\t\t}\n\t\tif (!rotating_same) {\n\t\t\tint t = Dx;\n\t\t\tDx = Dy;\n\t\t\tDy = t;\n\t\t}\n\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\trfbDrawString(screen, &default8x16Font, dx, ds + Dy+1*dy,\n\t\t\t    \"This is the Pixel buffer cache region. Your VNC Viewer is not hiding it from you.\",\n\t\t\t    white_pixel());\n\t\t\trfbDrawString(screen, &default8x16Font, dx, ds + Dy+2*dy,\n\t\t\t    \"Try resizing your VNC Viewer so you don't see it!!\",\n\t\t\t    white_pixel());\n\t\t\trfbDrawString(screen, &default8x16Font, dx, ds + Dy+3*dy,\n\t\t\t    \"Pay no attention to the man behind the curtain...\",\n\t\t\t    white_pixel());\n\t\t\trfbDrawString(screen, &default8x16Font, dx, ds + Dy+4*dy,\n\t\t\t    \"To disable caching run the server with:  x11vnc -noncache ...\",\n\t\t\t    white_pixel());\n\t\t\trfbDrawString(screen, &default8x16Font, dx, ds + Dy+5*dy,\n\t\t\t    \"If there are painting errors press 3 Alt_L's (Left \\\"Alt\\\" key) in a row to repaint the screen.\",\n\t\t\t    white_pixel());\n\t\t\trfbDrawString(screen, &default8x16Font, dx, ds + Dy+6*dy,\n\t\t\t    \"More info:  http://www.karlrunge.com/x11vnc/faq.html#faq-client-caching\",\n\t\t\t    white_pixel());\n\n\t\t\tds += 11 * dy;\n\t\t}\n\n\t\tsnapshot_cache_list(0, 100.0);\n\t\tfor (i=0; i < cache_list_num; i++) {\n\t\t\tCLEAR(i);\n\t\t}\n\t\tfor (n = 1; n <= ncache; n++) {\n\t\t\trect_reg[n] = NULL;\n\t\t}\n\n\t\tif (ncache_xrootpmap) {\n\t\t\tset_ncache_xrootpmap();\n\t\t}\n\n\t\tsnap_old();\n\t}\n\n\tcheck_zero_rects();\n\nif (hack_val == 2) {\n\tblock_stats();\n\thack_val = 1;\n}\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\tstatic double last_all_windows = 0.0;\n\t\tif (! macosx_checkevent(NULL)) {\n\t\t\tif (now > last_all_windows + 0.05) {\n\t\t\t\tmacosxCGS_get_all_windows();\n\t\t\t\tlast_all_windows = dnow();\n\t\t\t}\n\t\t}\n\t\t/* XXX Y */\n\t\trootwin = -1;\n\t}\n#endif\n\n\tn = 0;\n\tttot = 0;\n\n\tif (dt_guess == NULL || now > dt_last + 60) {\n\t\tstatic char *dt_prev = NULL;\n\t\tdt_prev = dt_guess;\n\t\tdt_guess = strdup(guess_desktop());\n\t\tif (ncache_xrootpmap && dt_prev && dt_guess) {\n\t\t\tif (strcmp(dt_prev, dt_guess)) {\n\t\t\t\tset_ncache_xrootpmap();\n\t\t\t}\n\t\t}\n\t\tdt_last = now;\n\t\tif (dt_prev) {\n\t\t\tfree(dt_prev);\n\t\t}\n\t}\n\tif (dt_guess && !strcmp(dt_guess, \"gnome\")) {\n\t\tdt_gnome = 1;\n\t} else if (dt_guess && !strcmp(dt_guess, \"kde\")) {\n\t\tdt_kde = 1;\n\t}\n\tif (dt_kde) {\n\t\tkde_no_animate(0);\n\t}\n\n\tev_store(None, EV_RESET);\n\n\tX_LOCK;\n\tfor (k = 1; k <= 3; k++) {\n\t\tint j, retry = 0;\n\n\t\tif (retry) {}\n\n\t\tnsave = n;\n\n\t\tif (k > 1 && ncdb) fprintf(stderr, \"read_events-%d\\n\", k);\n\t\tread_events(&n);\n\n#if 0\n\t\tif (dt_gnome && (n_MN || n_UN)) {\n\t\t\tretry = 1;\n\t\t} else if (ncache_old_wm && n_ON_po >= 2) {\n\t\t\tretry = 1;\n\t\t} else if (n > nsave) {\n\t\t\t/* XXX Y */\n\t\t\tretry = 1;\n\t\t}\n\n\t\tif (retry) {\n\t\t\tint n0 = n;\n\t\t\tusleep(25 * 1000);\n\t\t\tXFlush_wr(dpy);\n\t\t\tread_events(&n);\n\t\t\tif (ncdb) fprintf(stderr, \"read_events retry: %d -> %d\\n\", n0, n);\n\t\t}\n#endif\n\n\t\tif (n > nsave) {\n\t\t\tint n0 = n;\n\n\t\t\tfor (j=0; j<4; j++) {\n\t\t\t\tif (j < 2) {\n\t\t\t\t\tusleep(30 * 1000);\n\t\t\t\t} else {\n\t\t\t\t\tusleep(10 * 1000);\n\t\t\t\t}\n\t\t\t\tXFlush_wr(dpy);\n\t\t\t\tread_events(&n);\n\t\t\t\tif (ncdb) fprintf(stderr, \"read_events retry: %d -> %d\\n\", n0, n);\n\t\t\t\tif (n == n0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tn0 = n;\n\t\t\t}\n\t\t}\n\t\t\t\n\t\tnxsel = 0;\n\n\t\t/* handle creates and reparenting: */\n\t\tfor (n1 = nsave; n1 < n; n1++) {\n\t\t\tWindow win2;\n\t\t\tint idx;\n\t\t\tXEvent ev = Ev[n1];\n\t\t\twin = Ev_win[n1];\n\t\t\tif (ev.type == CreateNotify) {\n\t\t\t\twin2 = ev.xcreatewindow.window;\n\t\t\t\tif (ev_lookup(win2, EV_REPARENT) || ev_lookup(win2, EV_DESTROY)) {\n\t\t\t\t\tif (skipwins_n < skipwins_max) {\nif (ncdb) fprintf(stderr, \"SKIPWINS: CreateNotify: 0x%lx %d\\n\", win2, n1);\n\t\t\t\t\t\tskipwins[skipwins_n++] = win2;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tidx = lookup_win_index(win);\n\t\t\t\t\tif (idx < 0) {\n\t\t\t\t\t\tidx = lookup_free_index();\n\t\t\t\t\t\tif (idx < 0) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tCLEAR(idx);\n\t\t\t\t\t}\nif (ncdb) fprintf(stderr, \"PRELOOP:  CreateNotify: 0x%lx %d valid_window\\n\", win2, n1);\n\t\t\t\t\tif (valid_window(win2, &attr, 1)) {\n\t\t\t\t\t\tSTORE(idx, win2, attr);\n\t\t\t\t\t\tCLEAR(idx);\n\t\t\t\t\t\tcache_list[idx].selectinput = 1;\n\t\t\t\t\t\tcache_list[idx].create_cnt = 1;\nif (ncdb) fprintf(stderr, \"PRELOOP:  CreateNotify: 0x%lx %d xselectinput\\n\", win2, n1);\n\t\t\t\t\t\txselectinput(win2, win_ev, 1);\n\t\t\t\t\t\tnxsel++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tDELETE(idx);\n\t\t\t\t\t}\n\t\t\t\t\tnxsel++;\n\t\t\t\t}\n\t\t\t} else if (ev.type == ReparentNotify) {\n\t\t\t\tif (ev.xreparent.parent != rootwin) {\n\t\t\t\t\twin2 = ev.xreparent.window;\n\t\t\t\t\tif (win2 != rootwin) {\n\t\t\t\t\t\tidx = lookup_win_index(win2);\nif (ncdb) fprintf(stderr, \"PRELOOP:  RepartNotify: 0x%lx %d idx=%d\\n\", win2, n1, idx);\n\t\t\t\t\t\tif (idx >= 0) {\n\t\t\t\t\t\t\tDELETE(idx);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (! ev_lookup(win2, EV_CREATE)) {\n\t\t\t\t\t\t\txselectinput(win2, 0, 1);\n\t\t\t\t\t\t\tnxsel++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (nxsel == 0) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tX_UNLOCK;\n\n\tif (got_NET_CURRENT_DESKTOP > 0.0) {\n\t\tif (dnow() < got_NET_CURRENT_DESKTOP + 0.25) {\n\t\t\tif (ncdb) fprintf(stderr, \"***got_NET_CURRENT_DESKTOP n=%d\\n\", n);\n\t\t\tdesktop_change = 1;\n\t\t\tn_DC++;\n\t\t} else {\n\t\t\tif (ncdb) fprintf(stderr, \"***got_NET_CURRENT_DESKTOP n=%d STALE\\n\", n);\n\t\t}\n\t\tgot_NET_CURRENT_DESKTOP = 0.0;\n\t}\n\n\tif (n == 0) {\n\t\tcheck_sched(try_batch, &did_sched);\n\t\treturn 0;\n\t}\nif (ncdb) fprintf(stderr, \"\\n\"); if (ncdb) rfbLog(\"IN  check_ncache() %d events.  %.4f\\n\", n, now - x11vnc_start);\n\n\tif (try_batch) {\n\t\tuse_batch = 1;\n\t}\n\n\tif (rotating) {\n\t\tuse_batch = 0;\n\t}\n\tif (cursor_noshape_updates_clients(screen)) {\n\t\tuse_batch = 0;\n\t}\n\n\tif (! use_batch) {\n\t\tnbatch = NULL;\n\t} else {\n\t\tnreg = 0;\n\t\tnbatch = &nreg;\n\t}\n\n\t/* XXX Y */\n\tfor (n1 = 0; n1 < n; n1++) {\n\t\tWindow twin = Ev_map[n1];\n\t\tif (twin == None || twin == rootwin) {\n\t\t\tcontinue;\n\t\t}\n\t\tfor (n2 = 0; n2 < n; n2++) {\n\t\t\tif (Ev_unmap[n2] == twin) {\n\t\t\t\tif (skipwins_n < skipwins_max) {\nif (ncdb) fprintf(stderr, \"SKIPWINS: Ev_unmap/map: 0x%lx %d\\n\", twin, n2);\n\t\t\t\t\tskipwins[skipwins_n++] = twin;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!desktop_change) {\n\t\tif (skipwins_n) {\n\t\t\tif (n_MN + n_UN >= 2 + 2*skipwins_n) {\n\t\t\t\tdesktop_change = 1;\n\t\t\t\tn_DC++;\n\t\t\t}\n\t\t} else {\n\t\t\tif (n_MN + n_UN >= 3) {\n\t\t\t\tdesktop_change = 1;\n\t\t\t\tn_DC++;\n\t\t\t}\n\t\t}\n\t}\n\tif (ncache_old_wm) {\n\t\tint shifts = 0;\n\t\tfor (i=0; i < n; i++) {\n\t\t\tXEvent ev;\n\t\t\tint type, idx = -1;\n\t\t\tint ik = Ev_order[i];\n\t\t\tint x_new, y_new, w_new, h_new;\n\t\t\tint x_old, y_old, w_old, h_old;\n\t\t\tint old_wm = 0;\n\n\t\t\tif (Ev_done[ik]) continue;\n\t\t\twin = Ev_win[ik];\n\n\t\t\tev = Ev[ik];\n\t\t\ttype = ev.type;\n\t\t\tif (type != ConfigureNotify) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (ev_lookup(win, EV_MAP)) {\n\t\t\t\tcontinue;\n\t\t\t} else if (ev_lookup(win, EV_UNMAP)) {\n\t\t\t\tcontinue;\n\t\t\t} else if (ev_lookup(win, EV_DESTROY)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tidx = lookup_win_index(win);\n\t\t\tif (idx < 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tx_new = ev.xconfigure.x; \n\t\t\ty_new = ev.xconfigure.y; \n\t\t\tw_new = ev.xconfigure.width; \n\t\t\th_new = ev.xconfigure.height; \n\n\t\t\tx_old = cache_list[idx].x;\n\t\t\ty_old = cache_list[idx].y;\n\t\t\tw_old = cache_list[idx].width;\n\t\t\th_old = cache_list[idx].height;\n\n\t\t\tif (w_new == w_old && h_new == h_old) {\n\t\t\t\tif (nabs(x_new - x_old) >= dpy_x || nabs(y_new - y_old) >= dpy_y) {\n\t\t\t\t\tsraRegionPtr r_old, r_new, r0;\n\t\t\t\t\tr0 = sraRgnCreateRect(0, 0, dpy_x, dpy_y);\n\t\t\t\t\tr_old = sraRgnCreateRect(x_old, y_old, x_old+w_old, y_old+h_old);\n\t\t\t\t\tsraRgnAnd(r_old, r0);\n\t\t\t\t\tr_new = sraRgnCreateRect(x_new, y_new, x_new+w_new, y_new+h_new);\n\t\t\t\t\tsraRgnAnd(r_new, r0);\n\t\t\t\t\tif (cache_list[idx].map_state != IsViewable) {\n\t\t\t\t\t\tev_store(win, EV_OLD_WM_NOTMAPPED);\n\t\t\t\t\t} else if (sraRgnEmpty(r_old) && !sraRgnEmpty(r_new)) {\n\t\t\t\t\t\told_wm = 1;\n\t\t\t\t\t\tev_store(win, EV_OLD_WM_MAP);\n\t\t\t\t\t\tEv_map[i] = win;\n\t\t\t\t\t} else if (!sraRgnEmpty(r_old) && sraRgnEmpty(r_new)) {\n\t\t\t\t\t\tev_store(win, EV_OLD_WM_UNMAP);\n\t\t\t\t\t\told_wm = -1;\n\t\t\t\t\t\tEv_unmap[i] = win;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tev_store(win, EV_OLD_WM_OFF);\n\t\t\t\t\t}\n\t\t\t\t\tsraRgnDestroy(r_old);\n\t\t\t\t\tsraRgnDestroy(r_new);\n\t\t\t\t\tsraRgnDestroy(r0);\n\t\t\t\t\tshifts++;\nif (ncdb) fprintf(stderr, \"old_wm[%d]  +%04d+%04d  +%04d+%04d  old_wm: %d\\n\", i, x_old, y_old, x_new, y_new, old_wm);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (shifts >= 3) {\nif (ncdb) fprintf(stderr, \"DESKTOP_CHANGE_OLD_WM: %d\\n\", shifts);\n\t\t\tdesktop_change = 1;\n\t\t\tdesktop_change_old_wm = 1;\n\t\t}\n\t}\n\n#define SKIPUMS \\\n\tok = 1; \\\n\tif (twin == None || twin == rootwin) { \\\n\t\tcontinue; \\\n\t} \\\n\tfor (ns = 0; ns < skipwins_n; ns++) { \\\n\t\tif (skipwins[ns] == twin) { \\\n\t\t\tok = 0; \\\n\t\t\tbreak; \\\n\t\t} \\\n\t}\n\n\tif (desktop_change) {\n\t\tWindow twin;\n\t\tint ok, s, k, add, cnt, ns;\n\n\t\tcnt = 0;\n\t\tadd = 0;\n\t\tfor (i=0; i < n; i++) {\n\t\t\ttwin = Ev_unmap[i];\n\t\t\tSKIPUMS\n\t\t\tif (ok) {\nif (ncdb) fprintf(stderr, \"U Ev_tmp[%d] = %d\\n\", cnt, i);\n\t\t\t\tEv_tmp[cnt++] = i;\n\t\t\t}\n\t\t}\n\t\tfor (i=0; i < n; i++) {\n\t\t\ttwin = Ev_map[i];\n\t\t\tSKIPUMS\n\t\t\tif (ok) {\nif (ncdb) fprintf(stderr, \"M Ev_tmp[%d] = %d\\n\", cnt, i);\n\t\t\t\tEv_tmp[cnt++] = i;\n\t\t\t}\n\t\t}\n\t\tfor (k = 0; k < cnt; k++) {\n\t\t\tEv_tmp2[k] = -1;\n\t\t}\n\t\t/* unmap from top to bottom */\n\t\tfor (s = old_stack_n - 1; s >= 0; s--) {\n\t\t\ttwin = old_stack[s];\t\n\t\t\tif (twin == None || twin == rootwin) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (k = 0; k < cnt; k++) {\n\t\t\t\ti = Ev_tmp[k];\n\t\t\t\tif (twin == Ev_unmap[i]) {\nif (ncdb) fprintf(stderr, \"U Ev_tmp2[%d] = %d\\n\", add, i);\n\t\t\t\t\tEv_tmp2[add++] = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/* map from bottom to top */\n\t\tfor (s = 0; s < old_stack_n; s++) {\n\t\t\ttwin = old_stack[s];\t\n\t\t\tif (twin == None || twin == rootwin) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (k = 0; k < cnt; k++) {\n\t\t\t\ti = Ev_tmp[k];\n\t\t\t\tif (twin == Ev_map[i]) {\nif (ncdb) fprintf(stderr, \"M Ev_tmp2[%d] = %d\\n\", add, i);\n\t\t\t\t\tEv_tmp2[add++] = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tk = 0;\n\t\tfor (i=0; i < n; i++) {\n\t\t\tWindow wu, wm;\n\t\t\tint j;\n\t\t\tint oku = 0, okm = 0;\n\t\t\twu = Ev_unmap[i];\n\t\t\twm = Ev_map[i];\n\t\t\tok = 0;\n\t\t\tif (wu != None && wu != rootwin) oku = 1;\n\t\t\tif (wm != None && wm != rootwin) okm = 1;\n\t\t\tif (!oku && !okm) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (oku) {\n\t\t\t\ttwin = wu;\n\t\t\t\tSKIPUMS\n\t\t\t\tif (!ok) {\n\t\t\t\t\toku = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (okm) {\n\t\t\t\ttwin = wm;\n\t\t\t\tSKIPUMS\n\t\t\t\tif (!ok) {\n\t\t\t\t\tokm = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!oku && !okm) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tj = Ev_tmp2[k++];\n\t\t\tif (j >= 0) {\nif (ncdb) fprintf(stderr, \"UM Ev_order[%d] = %d oku=%d okm=%d\\n\", i, j, oku, okm);\n\t\t\t\tEv_order[i] = j;\n\t\t\t}\n\t\t}\n\t}\n\n#if 0\n\tif (desktop_change) {\n\t\tWindow twin;\n\t\tint ok, s, k, add, cnt, ns;\n\n\t\tcnt = 0;\n\t\tadd = 0;\n\t\tfor (i=0; i < n; i++) {\n\t\t\ttwin = Ev_unmap[i];\n\t\t\tSKIPUMS\n\t\t\tif (ok) {\n\t\t\t\tEv_tmp[cnt++] = i;\n\t\t\t}\n\t\t}\n\t\tfor (k = 0; k < cnt; k++) {\n\t\t\tEv_tmp2[k] = -1;\n\t\t}\n\t\t/* unmap from top to bottom */\n\t\tfor (s = old_stack_n - 1; s >= 0; s--) {\n\t\t\ttwin = old_stack[s];\t\n\t\t\tfor (k = 0; k < cnt; k++) {\n\t\t\t\ti = Ev_tmp[k];\n\t\t\t\tif (twin == Ev_unmap[i]) {\n\t\t\t\t\tEv_tmp2[add++] = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tk = 0;\n\t\tfor (i=0; i < n; i++) {\n\t\t\tint j;\n\t\t\ttwin = Ev_unmap[i];\n\t\t\tSKIPUMS\n\t\t\tif (ok) {\n\t\t\t\tj = Ev_tmp2[k++];\n\t\t\t\tif (j >= 0) {\n\t\t\t\t\tEv_order[i] = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcnt = 0;\n\t\tadd = 0;\n\t\tfor (i=0; i < n; i++) {\n\t\t\ttwin = Ev_map[i];\n\t\t\tSKIPUMS\n\t\t\tif (ok) {\n\t\t\t\tEv_tmp[cnt++] = i;\n\t\t\t}\n\t\t}\n\t\tfor (k = 0; k < cnt; k++) {\n\t\t\tEv_tmp2[k] = -1;\n\t\t}\n\t\t/* map from bottom to top */\n\t\tfor (s = 0; s < old_stack_n; s++) {\n\t\t\ttwin = old_stack[s];\t\n\t\t\tfor (k = 0; k < cnt; k++) {\n\t\t\t\ti = Ev_tmp[k];\n\t\t\t\tif (twin == Ev_map[i]) {\n\t\t\t\t\tEv_tmp2[add++] = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tk = 0;\n\t\tfor (i=0; i < n; i++) {\n\t\t\tint j;\n\t\t\ttwin = Ev_map[i];\n\t\t\tSKIPUMS\n\t\t\tif (ok) {\n\t\t\t\tj = Ev_tmp2[k++];\n\t\t\t\tif (j >= 0) {\n\t\t\t\t\tEv_order[i] = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n#endif\n\n\tif (!desktop_change && (n_VN_p && !n_UN && (n_MN || n_ON_st))) {\n\t\tif (now < last_vis_unobs_time + 0.75 || now < last_vis_obs_time + 0.75) {\n\t\t\t;\n\t\t} else if (n_MN <= 2 && n_ON_st <= 1) {\n\t\t\tfor (i=0; i < n; i++) {\n\t\t\t\tXEvent ev;\n\t\t\t\tint type, idx = -1, state, valid;\n\t\t\t\tint ik = Ev_order[i];\n\n\t\t\t\tif (Ev_done[ik]) continue;\n\t\t\t\twin = Ev_win[ik];\n\n\t\t\t\tev = Ev[ik];\n\t\t\t\ttype = ev.type;\n\t\t\t\tif (type != VisibilityNotify) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tstate = ev.xvisibility.state;\n\t\t\t\tif (state == VisibilityUnobscured) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (ev_lookup(win, EV_MAP)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if (ev_lookup(win, EV_UNMAP)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if (ev_lookup(win, EV_DESTROY)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tidx = lookup_win_index(win);\n\n\t\t\t\tif (idx < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (cache_list[idx].vis_state == VisibilityFullyObscured) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (now < cache_list[idx].vis_unobs_time + 3.00 || now < cache_list[idx].vis_obs_time + 3.00) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\nif (ncdb) fprintf(stderr, \"----%02d: VisibilityNotify 0x%lx  %3d  (*PRELOOP*) state: %s U/P %d/%d\\n\", ik, win, idx, VState(state), n_VN_u, n_VN_p);\n\t\t\t\tvalid = 0;\n\t\t\t\tbs_save(idx, nbatch, &attr, 1, 0, &valid, 1);\n\t\t\t\tif (valid) {\n\t\t\t\t\tSTORE(idx, win, attr);\n\t\t\t\t} else {\n\t\t\t\t\tDELETE(idx);\n\t\t\t\t}\n\n\t\t\t\tcache_list[idx].vis_state = state;\n\t\t\t\tcache_list[idx].vis_obs_time = last_vis_obs_time = dnow();\n\t\t\t\tEv_done[ik] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tif (desktop_change) {\n\t\tif (ncache_dt_change) {\n\t\t\tif (ncdb) fprintf(stderr, \"GUESSED DESKTOP CHANGE.\\n\");\n\t\t\tsaw_desktop_change = 1;\n\t\t} else {\n\t\t\tif (ncdb) fprintf(stderr, \"GUESSED DESKTOP CHANGE. Skipping.\\n\");\n\t\t\tdesktop_change = 0;\n\t\t}\n\t}\n\n\n\tcreate_cnt = 0;\n\tmissed_su_restore = 0;\n\tmissed_bs_restore = 0;\n\tmissed_su_restore_rgn = sraRgnCreate();\n\tmissed_bs_restore_rgn = sraRgnCreate();\n\tr0 = sraRgnCreateRect(0, 0, dpy_x, dpy_y);\n\tunmapped_rgn = sraRgnCreate();\n\tsu_fix_cnt = 0;\n\nfor (k = 0; k < skipwins_n; k++) {\n\tif (ncdb) fprintf(stderr, \"skipwins[%d] 0x%lx\\n\", k, skipwins[k]);\n}\n\n\tX_LOCK;\n\tfor (i=0; i < n; i++) {\n\t\tXEvent ev;\n\t\tint ns, skip = 0, type, idx = -1;\n\t\tint ik = Ev_order[i];\n\n\t\tif (Ev_done[ik]) continue;\n\t\twin = Ev_win[ik];\n\n\t\tev = Ev[ik];\n\t\ttype = ev.type;\n\t\tEv_done[ik] = 1;\n\n\t\twin2 = win;\n\t\tif (win == rootwin) {\n\t\t\tif (type == CreateNotify) {\n\t\t\t\twin2 = ev.xcreatewindow.window;\n\t\t\t} else if (type == ReparentNotify) {\n\t\t\t\twin2 = ev.xreparent.window;\n\t\t\t}\n\t\t}\n\t\tfor (ns = 0; ns < skipwins_n; ns++) {\n\t\t\tif (win2 == skipwins[ns]) {\n\t\t\t\tskip = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (skip) {\nif (ncdb) fprintf(stderr, \"skip%02d: ** SpecialSkip   0x%lx/0x%lx type: %s\\n\", ik, win, win2, Etype(type));\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tif (win == rootwin) {\n\t\t\tif (type == CreateNotify) {\n\t\t\t\tint x=0, y=0, w=0, h=0;\n\t\t\t\tvalid = 0;\n\t\t\t\twin2 = ev.xcreatewindow.window;\n\t\t\t\tidx = lookup_win_index(win2);\n\t\t\t\tif (idx < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (cache_list[idx].valid) {\n\t\t\t\t\tvalid = 1;\n\t\t\t\t\tx=cache_list[idx].x;\n\t\t\t\t\ty=cache_list[idx].y;\n\t\t\t\t\tw=cache_list[idx].width;\n\t\t\t\t\th=cache_list[idx].height;\n\t\t\t\t\tif (w*h > 64 * 64 && ev_lookup(win2, EV_MAP)) {\n\t\t\t\t\t\tX_UNLOCK;\n\t\t\t\t\t\tvalid = 1;\n\t\t\t\t\t\tsu_save(idx, nbatch, &attr, 0, &valid, 1);\n\t\t\t\t\t\tSTORE(idx, win2, attr);\n\n\t\t\t\t\t\tX_LOCK;\n\n\t\t\t\t\t\tif (! desktop_change) {\n\t\t\t\t\t\t\tSCHED(win2, 1) \n\t\t\t\t\t\t}\n\t\t\t\t\t\tcreate_cnt++;\n\t\t\t\t\t}\n\t\t\t\t}\nif (ncdb) fprintf(stderr, \"root%02d: ** CreateNotify  0x%lx  %3d  -- %dx%d+%d+%d valid=%d\\n\", ik, win2, idx, w, h, x, y, valid);\n\n\t\t\t} else if (type == ReparentNotify) {\n\t\t\t\tif (ev.xreparent.parent != rootwin) {\n\t\t\t\t\twin2 = ev.xreparent.window;\n\t\t\t\t\tidx = lookup_win_index(win2);\nif (ncdb) fprintf(stderr, \"root%02d: ReparentNotifyRM 0x%lx  %3d\\n\", ik, win2, idx);\n\t\t\t\t}\n\t\t\t} else {\nif (ncdb) fprintf(stderr, \"root%02d: ** IgnoringRoot  0x%lx type: %s\\n\", ik, win, Etype(type));\n\t\t\t}\n\t\t} else {\n\t\t\tif (type == ConfigureNotify) {\n\t\t\t\tint x_new, y_new, w_new, h_new;\n\t\t\t\tint x_old, y_old, w_old, h_old;\n\t\t\t\tint stack_change, old_wm = 0;\n\t\t\t\tWindow oabove = None;\n\n\t\t\t\tidx = lookup_win_index(win);\n\n\t\t\t\tif (idx >= 0) {\n\t\t\t\t\toabove = cache_list[idx].above;\n\t\t\t\t}\n\nif (ncdb) fprintf(stderr, \"----%02d: ConfigureNotify  0x%lx  %3d  -- above: 0x%lx -> 0x%lx  %dx%d+%d+%d\\n\", ik, win, idx,\n    oabove, ev.xconfigure.above, ev.xconfigure.width, ev.xconfigure.height, ev.xconfigure.x, ev.xconfigure.y);\n\n\t\t\t\tif (idx < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tx_new = ev.xconfigure.x; \n\t\t\t\ty_new = ev.xconfigure.y; \n\t\t\t\tw_new = ev.xconfigure.width; \n\t\t\t\th_new = ev.xconfigure.height; \n\n\t\t\t\tx_old = cache_list[idx].x;\n\t\t\t\ty_old = cache_list[idx].y;\n\t\t\t\tw_old = cache_list[idx].width;\n\t\t\t\th_old = cache_list[idx].height;\n\n\t\t\t\tif (desktop_change_old_wm) {\n\t\t\t\t\tif (ev_lookup(win, EV_OLD_WM_MAP)) {\n\t\t\t\t\t\tif (Ev_map[ik] == win) {\n\t\t\t\t\t\t\told_wm = 1;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\told_wm = 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (ev_lookup(win, EV_OLD_WM_UNMAP)) {\n\t\t\t\t\t\tif (Ev_unmap[ik] == win) {\n\t\t\t\t\t\t\told_wm = -1;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\told_wm = 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (ev_lookup(win, EV_OLD_WM_OFF)) {\n\t\t\t\t\t\told_wm = 2;\n\t\t\t\t\t} else if (ev_lookup(win, EV_OLD_WM_NOTMAPPED)) {\n\t\t\t\t\t\told_wm = 3;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!old_wm)  {\n\t\t\t\t\tif (x_old != x_new || y_old != y_new) {\n\t\t\t\t\t\t/* invalidate su */\n\t\t\t\t\t\tcache_list[idx].su_time = 0.0;\nif (ncdb) fprintf(stderr, \"          INVALIDATE su: 0x%lx xy: +%d+%d  +%d+%d \\n\", win, x_old, y_old, x_new, y_new);\n\t\t\t\t\t}\n\t\t\t\t\tif (w_old != w_new || h_old != h_new) {\n\t\t\t\t\t\t/* invalidate bs */\n\t\t\t\t\t\tcache_list[idx].bs_time = 0.0;\nif (ncdb) fprintf(stderr, \"          INVALIDATE bs: 0x%lx wh:  %dx%d   %dx%d \\n\", win, w_old, h_old, w_new, h_new);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tint valid;\n\t\t\t\t\tX_UNLOCK;\n\t\t\t\t\tif (old_wm == 1) {\n\t\t\t\t\t\t/* XXX Y */\nif (ncdb) fprintf(stderr, \"          OLD_WM_MAP:    0x%lx wh:  %dx%d+%d+%d   %dx%d+%d+%d \\n\", win, w_old, h_old, x_old, y_old, w_new, h_new, x_new, y_new);\n\t\t\t\t\t\tvalid = 0;\n\t\t\t\t\t\tbs_restore(idx, nbatch, NULL, &attr, 0, 0, &valid, 1);\n\n\t\t\t\t\t} else if (old_wm == -1) {\nif (ncdb) fprintf(stderr, \"          OLD_WM_UNMAP:  0x%lx wh:  %dx%d+%d+%d   %dx%d+%d+%d \\n\", win, w_old, h_old, x_old, y_old, w_new, h_new, x_new, y_new);\n\t\t\t\t\t\tvalid = 1;\n\t\t\t\t\t\tsu_restore(idx, nbatch, NULL, &attr, 1, 0, &valid, 1);\n\t\t\t\t\t} else {\nif (ncdb) fprintf(stderr, \"          OLD_WM_OFF::   0x%lx wh:  %dx%d+%d+%d   %dx%d+%d+%d  old_wm=%d\\n\", win, w_old, h_old, x_old, y_old, w_new, h_new, x_new, y_new, old_wm);\n\t\t\t\t\t}\n\t\t\t\t\tX_LOCK;\n\t\t\t\t}\n\n\t\t\t\tstack_change = 0;\n\t\t\t\tif (old_wm) {\n\t\t\t\t\t;\n\t\t\t\t} else if (cache_list[idx].above != ev.xconfigure.above) {\n\t\t\t\t\tstack_change = 1;\n\t\t\t\t} else if (x_new == x_old && y_new == y_old && w_new == w_old && h_new == h_old) {\n\t\t\t\t\tstack_change = 1;\n\t\t\t\t}\n\t\t\t\tif (stack_change) {\n\t\t\t\t\tint i2, ok = 1;\n\t\t\t\t\tfor (i2=0; i2 < n; i2++)  {\n\t\t\t\t\t\tif (Ev_map[i2] == win) {\n\t\t\t\t\t\t\tok = 0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (ok) {\n\t\t\t\t\t\tif (n_MN == 0 && n_UN == 0) {\n\t\t\t\t\t\t\tif (su_fix_cnt > 0) {\n\t\t\t\t\t\t\t\tok = 0;\nif (ncdb) fprintf(stderr, \"          CONF_IGNORE: Too many stacking changes: 0x%lx\\n\", win);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\tif (ok) {\n\t\t\t\t\t\tif (ev_lookup(ev.xconfigure.above, EV_UNMAP)) {\n\t\t\t\t\t\t\tif (ncdb) fprintf(stderr, \"        skip try_to_fix_su for GNOME deiconify #1\\n\");\n\t\t\t\t\t\t\tif (dt_gnome) {\n\t\t\t\t\t\t\t\tgnome_animation = 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tok = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (ok && dt_gnome) {\n\t\t\t\t\t\tif (valid_window(ev.xconfigure.above, &attr, 1)) {\n\t\t\t\t\t\t\tif (attr.map_state != IsViewable) {\n\t\t\t\t\t\t\t\tif (ncdb) fprintf(stderr, \"        skip try_to_fix_su for GNOME deiconify #2\\n\");\n\t\t\t\t\t\t\t\tgnome_animation = 1;\n\t\t\t\t\t\t\t\tok = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (ok) {\n\t\t\t\t\t\tint rc = try_to_fix_su(win, idx, ev.xconfigure.above, nbatch, NULL);\t\n\t\t\t\t\t\tif (rc == 0 && su_fix_cnt == 0 && n_MN == 0 && n_UN == 0) {\n\t\t\t\t\t\t\tX_UNLOCK;\n\t\t\t\t\t\t\ttry_to_synthesize_su(1, 1, nbatch);\n\t\t\t\t\t\t\tX_LOCK;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tn_ST++;\n\t\t\t\t\t\tsu_fix_cnt++;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tcache_list[idx].x = x_new;\n\t\t\t\tcache_list[idx].y = y_new;\n\t\t\t\tcache_list[idx].width = w_new;\n\t\t\t\tcache_list[idx].height = h_new;\n\n\t\t\t\tcache_list[idx].above = ev.xconfigure.above;\n\t\t\t\tcache_list[idx].time = dnow();\n\n\t\t\t} else if (type == VisibilityNotify) {\n\t\t\t\tint state = ev.xvisibility.state;\n\t\t\t\tidx = lookup_win_index(win);\nif (ncdb) fprintf(stderr, \"----%02d: VisibilityNotify 0x%lx  %3d  state: %s U/P %d/%d\\n\", ik, win, idx, VState(state), n_VN_u, n_VN_p);\n\n\t\t\t\tif (idx < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (desktop_change) {\n\t\t\t\t\t;\n\t\t\t\t} else if (macosx_console && n_VN_p == 0) {\n\t\t\t\t\t;\t/* XXXX not working well yet with UnmapNotify ... */\n\t\t\t\t} else if (state == VisibilityUnobscured) {\n\t\t\t\t\tint ok = 1;\n\t\t\t\t\tif (ncache <= 2) {\n\t\t\t\t\t\tok = 0;\n\t\t\t\t\t} else if (ev_lookup(win, EV_MAP)) {\n\t\t\t\t\t\tok = 0;\n\t\t\t\t\t} else if (ev_lookup(win, EV_UNMAP)) {\n\t\t\t\t\t\tok = 0;\n\t\t\t\t\t} else if (ev_lookup(win, EV_DESTROY)) {\n\t\t\t\t\t\tok = 0;\n\t\t\t\t\t} else if (gnome_animation) {\n\t\t\t\t\t\tok = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* this is for gnome iconify */\n\t\t\t\t\t\tint i2;\n\t\t\t\t\t\tfor (i2=i+1; i2 < n; i2++) {\n\t\t\t\t\t\t\tint idx2, ik2 = Ev_order[i2];\n\t\t\t\t\t\t\tsraRegionPtr ro1, ro2;\n\t\t\t\t\t\t\tWindow win2 = Ev_unmap[ik2];\n\n\t\t\t\t\t\t\tif (win2 == None) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tidx2 = lookup_win_index(win2);\n\t\t\t\t\t\t\tif (idx2 < 0) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tro1 = idx_create_rgn(r0, idx);\n\t\t\t\t\t\t\tro2 = idx_create_rgn(r0, idx2);\n\n\t\t\t\t\t\t\tif (sraRgnAnd(ro1, ro2)) {\n\t\t\t\t\t\t\t\tif (ncdb) fprintf(stderr, \"        skip VisibilityUnobscured for GNOME iconify.\\n\");\n\t\t\t\t\t\t\t\tok = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsraRgnDestroy(ro1);\n\t\t\t\t\t\t\tsraRgnDestroy(ro2);\n\t\t\t\t\t\t\tif (! ok) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (ok) {\n\t\t\t\t\t\tint x2, y2, w2, h2;\n\t\t\t\t\t\tsraRegionPtr rmask = NULL;\n\t\t\t\t\t\tvalid = 0;\n\t\t\t\t\t\tif (dnow() < cache_list[idx].vis_unobs_time + 3.00 && !sraRgnEmpty(unmapped_rgn)) {\n\t\t\t\t\t\t\tx2 = cache_list[idx].x;\n\t\t\t\t\t\t\ty2 = cache_list[idx].y;\n\t\t\t\t\t\t\tw2 = cache_list[idx].width;\n\t\t\t\t\t\t\th2 = cache_list[idx].height;\n\t\t\t\t\t\t\trmask = sraRgnCreateRect(x2, y2, x2+w2, y2+h2);\n\t\t\t\t\t\t\tsraRgnAnd(rmask, unmapped_rgn);\n\t\t\t\t\t\t\tif (sraRgnEmpty(rmask)) {\n\t\t\t\t\t\t\t\tsraRgnDestroy(rmask);\n\t\t\t\t\t\t\t\trmask = NULL;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (ev_lookup(win, EV_CONFIGURE_SIZE)) {\n\t\t\t\t\t\t\tvalid = valid_window(win, &attr, 1);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tX_UNLOCK;\n\t\t\t\t\t\t\tbs_restore(idx, nbatch, rmask, &attr, 0, 1, &valid, 1);\n\t\t\t\t\t\t\tX_LOCK;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (rmask != NULL) {\n\t\t\t\t\t\t\tsraRgnDestroy(rmask);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (valid) {\n\t\t\t\t\t\t\tSTORE(idx, win, attr);\n\n\t\t\t\t\t\t\tcache_list[idx].time = dnow();\n\t\t\t\t\t\t\tcache_list[idx].vis_cnt++;\n\t\t\t\t\t\t\tEv_map[ik] = win;\n\t\t\t\t\t\t\tEv_rects[nrects].x1 = cache_list[idx].x;\n\t\t\t\t\t\t\tEv_rects[nrects].y1 = cache_list[idx].y;\n\t\t\t\t\t\t\tEv_rects[nrects].x2 = cache_list[idx].width;\n\t\t\t\t\t\t\tEv_rects[nrects].y2 = cache_list[idx].height;\n\t\t\t\t\t\t\tnrects++;\n\t\t\t\t\t\t\tSCHED(win, 1) \n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tDELETE(idx);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (state == VisibilityUnobscured) {\n\t\t\t\t\tcache_list[idx].vis_unobs_time = last_vis_unobs_time = dnow();\n\t\t\t\t} else if (cache_list[idx].vis_state == VisibilityUnobscured) {\n\t\t\t\t\tcache_list[idx].vis_obs_time = last_vis_obs_time = dnow();\n\t\t\t\t}\n\t\t\t\tcache_list[idx].vis_state = state;\n\n\t\t\t} else if (type == MapNotify) {\n\t\t\t\tidx = lookup_win_index(win);\nif (ncdb) fprintf(stderr, \"----%02d: MapNotify        0x%lx  %3d\\n\", ik, win, idx);\n\n\t\t\t\tif (idx < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n#if 0\n/*\n\t\t\t\tif (cache_list[idx].map_state == IsUnmapped || desktop_change || macosx_console)\n */\n#endif\n\t\t\t\tif (1) {\n\t\t\t\t\tX_UNLOCK;\n\t\t\t\t\tif (desktop_change) {\n\t\t\t\t\t\t/* XXX Y */\n\t\t\t\t\t\tint save = 1;\n\t\t\t\t\t\tsraRegionPtr r;\n\t\t\t\t\t\tif (cache_list[idx].su_time != 0.0) {\n\t\t\t\t\t\t\tsave = 0;\n\t\t\t\t\t\t} else if (missed_su_restore) {\n\t\t\t\t\t\t\tr = idx_create_rgn(r0, idx);\n\t\t\t\t\t\t\tif (sraRgnAnd(r, missed_su_restore_rgn)) {\n\t\t\t\t\t\t\t\tsave = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsraRgnDestroy(r);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (missed_bs_restore) {\n\t\t\t\t\t\t\tr = idx_create_rgn(r0, idx);\n\t\t\t\t\t\t\tif (sraRgnAnd(r, missed_bs_restore_rgn)) {\n\t\t\t\t\t\t\t\tsave = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsraRgnDestroy(r);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (save) {\n\t\t\t\t\t\t\tvalid = 0;\n\t\t\t\t\t\t\tsu_save(idx, nbatch, &attr, 1, &valid, 1);\n\t\t\t\t\t\t\tif (valid) {\n\t\t\t\t\t\t\t\tSTORE(idx, win, attr);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvalid = 0;\n\t\t\t\t\t\tsu_save(idx, nbatch, &attr, 0, &valid, 1);\n\t\t\t\t\t\tif (valid) {\n\t\t\t\t\t\t\tSTORE(idx, win, attr);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tvalid = 0;\n\t\t\t\t\tif (ev_lookup(win, EV_CONFIGURE_SIZE)) {\n\t\t\t\t\t\tX_LOCK;\n\t\t\t\t\t\tvalid = valid_window(win, &attr, 1);\n\t\t\t\t\t\tX_UNLOCK;\n\t\t\t\t\t\tidx_add_rgn(missed_bs_restore_rgn, r0, idx);\n\t\t\t\t\t\tmissed_bs_restore++;\n\t\t\t\t\t} else if (bs_restore(idx, nbatch, NULL, &attr, 0, 0, &valid, 1)) { /* XXX clip? */\n\t\t\t\t\t\t;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tidx_add_rgn(missed_bs_restore_rgn, r0, idx);\n\t\t\t\t\t\tmissed_bs_restore++;\n\t\t\t\t\t}\n\t\t\t\t\tif (valid) {\n\t\t\t\t\t\tSTORE(idx, win, attr);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (macosx_console) {\n#ifdef MACOSX\n\t\t\t\t\t\tmacosxCGS_follow_animation_win(win, -1, 1);\n\t\t\t\t\t\tif (valid_window(win, &attr, 1)) {\n\t\t\t\t\t\t\tSTORE(idx, win, attr);\n\t\t\t\t\t\t\tSCHED(win, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/* XXX Y */\n\t\t\t\t\t\tif (cache_list[idx].vis_state == -1)  {\n\t\t\t\t\t\t\tcache_list[idx].vis_state = VisibilityUnobscured;\n\t\t\t\t\t\t}\n#endif\n\t\t\t\t\t}\n\t\t\t\t\tX_LOCK;\n\t\t\t\t\tpixels += cache_list[idx].width * cache_list[idx].height;\n\t\t\t\t\tcache_list[idx].time = dnow();\n\t\t\t\t\tcache_list[idx].map_cnt++;\n\t\t\t\t\tEv_map[ik] = win;\n\t\t\t\t\tEv_rects[nrects].x1 = cache_list[idx].x;\n\t\t\t\t\tEv_rects[nrects].y1 = cache_list[idx].y;\n\t\t\t\t\tEv_rects[nrects].x2 = cache_list[idx].width;\n\t\t\t\t\tEv_rects[nrects].y2 = cache_list[idx].height;\n\t\t\t\t\tnrects++;\n\n\t\t\t\t\tif (! valid) {\n\t\t\t\t\t\tDELETE(idx);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcache_list[idx].map_state = IsViewable;\n\n\t\t\t} else if (type == UnmapNotify) {\n\t\t\t\tint x2, y2, w2, h2;\n\t\t\t\tidx = lookup_win_index(win);\nif (ncdb) fprintf(stderr, \"----%02d: UnmapNotify      0x%lx  %3d\\n\", ik, win, idx);\n\n\t\t\t\tif (idx < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (macosx_console) {\n\t\t\t\t\tif (mode == 2) {\n\t\t\t\t\t\tcache_list[idx].map_state = IsViewable;\n\t\t\t\t\t}\n\t\t\t\t}\n\n#if 0\n/*\n\t\t\t\tif (cache_list[idx].map_state == IsViewable || desktop_change || macosx_console)\n */\n#endif\n\t\t\t\tif (1) {\n\t\t\t\t\tX_UNLOCK;\n\t\t\t\t\tif (desktop_change) {\n\t\t\t\t\t\tint save = 1;\n\t\t\t\t\t\tsraRegionPtr r;\n\t\t\t\t\t\tif (cache_list[idx].bs_time > 0.0) {\n\t\t\t\t\t\t\tsave = 0;\n\t\t\t\t\t\t} else if (missed_su_restore) {\n\t\t\t\t\t\t\tr = idx_create_rgn(r0, idx);\n\t\t\t\t\t\t\tif (sraRgnAnd(r, missed_su_restore_rgn)) {\n\t\t\t\t\t\t\t\tsave = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsraRgnDestroy(r);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (missed_bs_restore) {\n\t\t\t\t\t\t\tr = idx_create_rgn(r0, idx);\n\t\t\t\t\t\t\tif (sraRgnAnd(r, missed_bs_restore_rgn)) {\n\t\t\t\t\t\t\t\tsave = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsraRgnDestroy(r);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (save) {\n\t\t\t\t\t\t\tvalid = 0;\n\t\t\t\t\t\t\tbs_save(idx, nbatch, &attr, 1, 0, &valid, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvalid = 0;\n\t\t\t\t\t\tbs_save(idx, nbatch, &attr, 1, 0, &valid, 1);\n\t\t\t\t\t}\n\t\t\t\t\tvalid = 0;\n\t\t\t\t\tif (su_restore(idx, nbatch, NULL, &attr, 1, 0, &valid, 1)) {\n\t\t\t\t\t\ttry_to_fix_su(win, idx, None, nbatch, \"unmapped\");\t\n\t\t\t\t\t\tif (valid) {\n\t\t\t\t\t\t\tSTORE(idx, win, attr);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tDELETE(idx);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tidx_add_rgn(missed_su_restore_rgn, r0, idx);\n\t\t\t\t\t\tmissed_su_restore++;\n\t\t\t\t\t}\n\t\t\t\t\tX_LOCK;\n\n\t\t\t\t\tpixels += cache_list[idx].width * cache_list[idx].height;\n\t\t\t\t\tcache_list[idx].time = dnow();\n\t\t\t\t\tcache_list[idx].unmap_cnt++;\n\t\t\t\t\tEv_unmap[ik] = win;\n\t\t\t\t\tEv_rects[nrects].x1 = cache_list[idx].x;\n\t\t\t\t\tEv_rects[nrects].y1 = cache_list[idx].y;\n\t\t\t\t\tEv_rects[nrects].x2 = cache_list[idx].width;\n\t\t\t\t\tEv_rects[nrects].y2 = cache_list[idx].height;\n\t\t\t\t\tnrects++;\n\t\t\t\t}\n\n\t\t\t\tx2 = cache_list[idx].x;\n\t\t\t\ty2 = cache_list[idx].y;\n\t\t\t\tw2 = cache_list[idx].width;\n\t\t\t\th2 = cache_list[idx].height;\n\t\t\t\tr = sraRgnCreateRect(x2, y2, x2+w2, y2+h2);\n\t\t\t\tsraRgnAnd(r, r0); \n\t\t\t\tsraRgnOr(unmapped_rgn, r); \n\t\t\t\tsraRgnDestroy(r);\n\n\t\t\t\tcache_list[idx].map_state = IsUnmapped;\n\n\t\t\t} else if (type == ReparentNotify) {\n\t\t\t\tif (ev.xreparent.parent != rootwin) {\n\t\t\t\t\twin2 = ev.xreparent.window;\n\t\t\t\t\tif (win2 != rootwin) {\n\t\t\t\t\t\tidx = lookup_win_index(win2);\nif (ncdb) fprintf(stderr, \"----%02d: ReparentNotifyRM 0x%lx  %3d\\n\", ik, win2, idx);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t} else if (type == DestroyNotify) {\n\t\t\t\twin2 = ev.xdestroywindow.window;\n\t\t\t\tidx = lookup_win_index(win2);\nif (ncdb) fprintf(stderr, \"----%02d: DestroyNotify    0x%lx  %3d\\n\", ik, win2, idx);\n\n\t\t\t\tif (idx >= 0) {\n\t\t\t\t\tDELETE(idx);\n\t\t\t\t}\n\t\t\t} else {\nif (ncdb) fprintf(stderr, \"igno%02d: ** Ignoring      0x%lx type: %s\\n\", ik, win, Etype(type));\n\t\t\t}\n\n\t\t}\n\t}\n\tX_UNLOCK;\n\n\tif (use_batch && nreg) {\n\t\tbatch_push(nreg, -1.0);\n\t}\n\tif (nrects) {\n\t\tif (scaling) {\n\t\t\tpush_borders(Ev_rects, nrects);\n\t\t}\n\t}\n\n\tcheck_sched(try_batch, &did_sched);\n\n\tif (n_CN || n_RN || n_DN || n_MN || n_UN || n_ST || n_DC || did_sched) {\n\t\tsnap_old();\n\t}\n\n\tsraRgnDestroy(r0);\n\tsraRgnDestroy(missed_su_restore_rgn);\n\tsraRgnDestroy(missed_bs_restore_rgn);\n\nif (ncdb) rfbLog(\"OUT check_ncache(): %.4f %.6f events: %d  pixels: %d\\n\", dnowx(), dnow() - now, n, pixels);\nif (ncdb) fprintf(stderr, \"\\n\");\n\treturn pixels;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define SKIPUMS \\\n\tok = 1; \\\n\tif (twin == None || twin == rootwin) { \\\n\t\tcontinue; \\\n\t} \\\n\tfor (ns = 0; ns < skipwins_n; ns++) { \\\n\t\tif (skipwins[ns] == twin) { \\\n\t\t\tok = 0; \\\n\t\t\tbreak; \\\n\t\t} \\\n\t}",
            "#define EV_OLD_WM_NOTMAPPED\t16",
            "#define EV_OLD_WM_OFF\t\t15",
            "#define EV_OLD_WM_UNMAP\t\t14",
            "#define EV_OLD_WM_MAP\t\t13",
            "#define EV_CONFIGURE_SIZE\t7",
            "#define EV_REPARENT\t\t5",
            "#define EV_MAP\t\t\t4",
            "#define EV_UNMAP\t\t3",
            "#define EV_DESTROY\t\t2",
            "#define EV_CREATE\t\t1",
            "#define EV_RESET\t\t0",
            "#define NSCHED 128",
            "#define NRECENT 32"
          ],
          "globals_used": [
            "int get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);",
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void mark_region_for_xdamage(sraRegionPtr region);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int check_user_input(double dt, double dtr, int tile_diffs, int *cnt);",
            "void do_copyregion(sraRegionPtr region, int dx, int dy, int mode);",
            "int check_ncache(int reset, int mode);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "int try_to_fix_su(Window win, int idx, Window above, int *nbatch, char *mode);",
            "int try_to_fix_resize_su(Window orig_frame, int orig_x, int orig_y, int orig_w, int orig_h,\n    int x, int y, int w, int h, int try_batch);",
            "int lookup_win_index(Window);",
            "void set_ncache_xrootpmap(void);",
            "static int try_copyrect(Window orig_frame, Window frame, int x, int y, int w, int h,\n    int dx, int dy, int *obscured, sraRegionPtr extra_clip, double max_wait, int *nbatch);",
            "winattr_t *cache_list;",
            "void batch_push(int ncr, double delay);",
            "int clipped(int idx);",
            "void snap_old(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\n#define SKIPUMS \\\n\tok = 1; \\\n\tif (twin == None || twin == rootwin) { \\\n\t\tcontinue; \\\n\t} \\\n\tfor (ns = 0; ns < skipwins_n; ns++) { \\\n\t\tif (skipwins[ns] == twin) { \\\n\t\t\tok = 0; \\\n\t\t\tbreak; \\\n\t\t} \\\n\t}\n#define EV_OLD_WM_NOTMAPPED\t16\n#define EV_OLD_WM_OFF\t\t15\n#define EV_OLD_WM_UNMAP\t\t14\n#define EV_OLD_WM_MAP\t\t13\n#define EV_CONFIGURE_SIZE\t7\n#define EV_REPARENT\t\t5\n#define EV_MAP\t\t\t4\n#define EV_UNMAP\t\t3\n#define EV_DESTROY\t\t2\n#define EV_CREATE\t\t1\n#define EV_RESET\t\t0\n#define NSCHED 128\n#define NRECENT 32\n\nint get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid mark_region_for_xdamage(sraRegionPtr region);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint check_user_input(double dt, double dtr, int tile_diffs, int *cnt);\nvoid do_copyregion(sraRegionPtr region, int dx, int dy, int mode);\nint check_ncache(int reset, int mode);\nint find_rect(int idx, int x, int y, int w, int h);\nint try_to_fix_su(Window win, int idx, Window above, int *nbatch, char *mode);\nint try_to_fix_resize_su(Window orig_frame, int orig_x, int orig_y, int orig_w, int orig_h,\n    int x, int y, int w, int h, int try_batch);\nint lookup_win_index(Window);\nvoid set_ncache_xrootpmap(void);\nstatic int try_copyrect(Window orig_frame, Window frame, int x, int y, int w, int h,\n    int dx, int dy, int *obscured, sraRegionPtr extra_clip, double max_wait, int *nbatch);\nwinattr_t *cache_list;\nvoid batch_push(int ncr, double delay);\nint clipped(int idx);\nvoid snap_old(void);\n\nint check_ncache(int reset, int mode) {\n\tstatic int first = 1;\n\tstatic int last_client_count = -1;\n\tint i, k, n; \n\tint did_sched = 0;\n\n\tWindow win, win2;\n\tXWindowAttributes attr;\n\tint valid;\n\tint try_batch = 1; /* XXX Y */\n\tint use_batch = 0;\n\tint nreg = 0, *nbatch;\n\tint create_cnt;\n\tint su_fix_cnt;\n\tint pixels = 0, ttot;\n\tint desktop_change = 0, n1, n2;\n\tint desktop_change_old_wm = 0;\n\tint missed_su_restore = 0;\n\tint missed_bs_restore = 0;\n\tsraRegionPtr r0, r;\n\tsraRegionPtr missed_su_restore_rgn;\n\tsraRegionPtr missed_bs_restore_rgn;\n\tsraRegionPtr unmapped_rgn;\n\n\tint nrects = 0;\n\tint nsave, nxsel;\n\tdouble now;\n\n\tint skipwins_n = 0;\n\tint skipwins_max = 256;\n\tWindow skipwins[256];\n\n\tstatic char *dt_guess = NULL;\n\tstatic double dt_last = 0.0;\n\tint dt_gnome = 0, gnome_animation = 0;\n\tint dt_kde = 0;\n\n\tif (unixpw_in_progress) return -1;\n\n#ifdef MACOSX\n\tif (! macosx_console) {\n\t\tRAWFB_RET(-1)\n\t}\n\tif (! screen) {\n\t\treturn -1;\n\t}\n#else\n\tRAWFB_RET(-1)\n\tif (! screen || ! dpy) {\n\t\treturn -1;\n\t}\n#endif\n\n\tnow = dnow();\n\n#ifdef NO_NCACHE\n\tncache = 0;\n#endif\n\n\tif (reset && (first || cache_list_len == 0)) {\n\t\treturn -1;\n\t}\n\tif (use_threads) {\n\t\ttry_batch = 0;\n\t}\n\n\tif (ncache0) {\n\t\tif (reset) {\n\t\t\t;\n\t\t} else if (!client_count || !ncache || nofb) {\n\t\t\tstatic double last_purge = 0.0;\n\t\t\tdouble delay = client_count ? 0.5 : 2.0;\n\t\t\tif (now > last_purge + delay) {\n\t\t\t\tint c = 0;\n\t\t\t\tXEvent ev;\n\t\t\t\tX_LOCK;\n\t\t\t\twhile (xcheckmaskevent(dpy, all_ev, &ev)) {\n\t\t\t\t\tc++;\n\t\t\t\t}\n\t\t\t\tX_UNLOCK;\n\t\t\t\tlast_purge = dnow();\nif (ncdb && c) fprintf(stderr, \"check_ncache purged %d events\\n\", c); \n\t\t\t}\n\t\t\tif (!client_count && last_client_count >= 0 &&\n\t\t\t    client_count != last_client_count) {\n\t\t\t\t/* this should use less RAM when no clients */\n\t\t\t\tdo_new_fb(1);\n\t\t\t}\n\t\t\tlast_client_count = client_count;\n\t\t\treturn -1;\n\t\t}\n\t}\n\tlast_client_count = client_count;\n\n\tif (ncache && ! ncache0) {\n\t\tncache0 = ncache;\n\t}\n\n\tif (! ncache || ! ncache0) {\n\t\treturn -1;\n\t}\n\tif (subwin) {\n\t\treturn -1;\n\t}\n\tif (nofb) {\n\t\treturn -1;\n\t}\n\tif (now < last_client + 4) {\n\t\treturn -1;\n\t}\n\tif (! all_clients_initialized()) {\n\t\t/* play it safe */\n\t\treturn -1;\n\t}\n\n\n\n\tif (reset) {\n\t\trfbLog(\"check_ncache: resetting cache: %d/%d %d %d\\n\", cache_list_num, cache_list_len, ncache, first);\n\t\tfor (i=0; i < cache_list_num; i++) {\n\t\t\tfree_rect(i);\n\t\t}\n\t\tfor (n = 1; n <= ncache; n++) {\n\t\t\tif (rect_reg[n] != NULL) {\n\t\t\t\tsraRgnDestroy(rect_reg[n]);\n\t\t\t\trect_reg[n] = NULL;\n\t\t\t}\n\t\t}\n\t\tzero_fb(0, dpy_y, dpy_x, (ncache+1)*dpy_y);\n\t\tmark_rect_as_modified(0, dpy_y, dpy_x, (ncache+1)*dpy_y, 0);\n\n\t\tif (ncache_xrootpmap) {\n\t\t\tset_ncache_xrootpmap();\n\t\t}\n\n\t\tsnap_old();\n\t\treturn -1;\n\t}\n\n\tif (first) {\n\t\tint dx = 10, dy = 24, ds = 0;\n\t\tint Dx = dpy_x, Dy = dpy_y;\n\t\tfirst = 0;\n\t\tfor (i=0; i < NRECENT; i++) {\n\t\t\trecent[i] = None;\n\t\t}\n\t\tfor (i=0; i < NSCHED; i++) {\n\t\t\tsched_bs[i] = None;\n\t\t}\n\t\trlast = 0;\n\n\t\tX_LOCK;\n\t\t/* event leak with client_count == 0 */\n\t\txselectinput_rootwin |= SubstructureNotifyMask;\n\t\tXSelectInput_wr(dpy, rootwin, xselectinput_rootwin);\n\t\tX_UNLOCK;\n\n\t\tif (scaling) {\n\t\t\tDx = scaled_x;\n\t\t\tDy = scaled_y;\n\t\t}\n\t\tif (!rotating_same) {\n\t\t\tint t = Dx;\n\t\t\tDx = Dy;\n\t\t\tDy = t;\n\t\t}\n\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\trfbDrawString(screen, &default8x16Font, dx, ds + Dy+1*dy,\n\t\t\t    \"This is the Pixel buffer cache region. Your VNC Viewer is not hiding it from you.\",\n\t\t\t    white_pixel());\n\t\t\trfbDrawString(screen, &default8x16Font, dx, ds + Dy+2*dy,\n\t\t\t    \"Try resizing your VNC Viewer so you don't see it!!\",\n\t\t\t    white_pixel());\n\t\t\trfbDrawString(screen, &default8x16Font, dx, ds + Dy+3*dy,\n\t\t\t    \"Pay no attention to the man behind the curtain...\",\n\t\t\t    white_pixel());\n\t\t\trfbDrawString(screen, &default8x16Font, dx, ds + Dy+4*dy,\n\t\t\t    \"To disable caching run the server with:  x11vnc -noncache ...\",\n\t\t\t    white_pixel());\n\t\t\trfbDrawString(screen, &default8x16Font, dx, ds + Dy+5*dy,\n\t\t\t    \"If there are painting errors press 3 Alt_L's (Left \\\"Alt\\\" key) in a row to repaint the screen.\",\n\t\t\t    white_pixel());\n\t\t\trfbDrawString(screen, &default8x16Font, dx, ds + Dy+6*dy,\n\t\t\t    \"More info:  http://www.karlrunge.com/x11vnc/faq.html#faq-client-caching\",\n\t\t\t    white_pixel());\n\n\t\t\tds += 11 * dy;\n\t\t}\n\n\t\tsnapshot_cache_list(0, 100.0);\n\t\tfor (i=0; i < cache_list_num; i++) {\n\t\t\tCLEAR(i);\n\t\t}\n\t\tfor (n = 1; n <= ncache; n++) {\n\t\t\trect_reg[n] = NULL;\n\t\t}\n\n\t\tif (ncache_xrootpmap) {\n\t\t\tset_ncache_xrootpmap();\n\t\t}\n\n\t\tsnap_old();\n\t}\n\n\tcheck_zero_rects();\n\nif (hack_val == 2) {\n\tblock_stats();\n\thack_val = 1;\n}\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\tstatic double last_all_windows = 0.0;\n\t\tif (! macosx_checkevent(NULL)) {\n\t\t\tif (now > last_all_windows + 0.05) {\n\t\t\t\tmacosxCGS_get_all_windows();\n\t\t\t\tlast_all_windows = dnow();\n\t\t\t}\n\t\t}\n\t\t/* XXX Y */\n\t\trootwin = -1;\n\t}\n#endif\n\n\tn = 0;\n\tttot = 0;\n\n\tif (dt_guess == NULL || now > dt_last + 60) {\n\t\tstatic char *dt_prev = NULL;\n\t\tdt_prev = dt_guess;\n\t\tdt_guess = strdup(guess_desktop());\n\t\tif (ncache_xrootpmap && dt_prev && dt_guess) {\n\t\t\tif (strcmp(dt_prev, dt_guess)) {\n\t\t\t\tset_ncache_xrootpmap();\n\t\t\t}\n\t\t}\n\t\tdt_last = now;\n\t\tif (dt_prev) {\n\t\t\tfree(dt_prev);\n\t\t}\n\t}\n\tif (dt_guess && !strcmp(dt_guess, \"gnome\")) {\n\t\tdt_gnome = 1;\n\t} else if (dt_guess && !strcmp(dt_guess, \"kde\")) {\n\t\tdt_kde = 1;\n\t}\n\tif (dt_kde) {\n\t\tkde_no_animate(0);\n\t}\n\n\tev_store(None, EV_RESET);\n\n\tX_LOCK;\n\tfor (k = 1; k <= 3; k++) {\n\t\tint j, retry = 0;\n\n\t\tif (retry) {}\n\n\t\tnsave = n;\n\n\t\tif (k > 1 && ncdb) fprintf(stderr, \"read_events-%d\\n\", k);\n\t\tread_events(&n);\n\n#if 0\n\t\tif (dt_gnome && (n_MN || n_UN)) {\n\t\t\tretry = 1;\n\t\t} else if (ncache_old_wm && n_ON_po >= 2) {\n\t\t\tretry = 1;\n\t\t} else if (n > nsave) {\n\t\t\t/* XXX Y */\n\t\t\tretry = 1;\n\t\t}\n\n\t\tif (retry) {\n\t\t\tint n0 = n;\n\t\t\tusleep(25 * 1000);\n\t\t\tXFlush_wr(dpy);\n\t\t\tread_events(&n);\n\t\t\tif (ncdb) fprintf(stderr, \"read_events retry: %d -> %d\\n\", n0, n);\n\t\t}\n#endif\n\n\t\tif (n > nsave) {\n\t\t\tint n0 = n;\n\n\t\t\tfor (j=0; j<4; j++) {\n\t\t\t\tif (j < 2) {\n\t\t\t\t\tusleep(30 * 1000);\n\t\t\t\t} else {\n\t\t\t\t\tusleep(10 * 1000);\n\t\t\t\t}\n\t\t\t\tXFlush_wr(dpy);\n\t\t\t\tread_events(&n);\n\t\t\t\tif (ncdb) fprintf(stderr, \"read_events retry: %d -> %d\\n\", n0, n);\n\t\t\t\tif (n == n0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tn0 = n;\n\t\t\t}\n\t\t}\n\t\t\t\n\t\tnxsel = 0;\n\n\t\t/* handle creates and reparenting: */\n\t\tfor (n1 = nsave; n1 < n; n1++) {\n\t\t\tWindow win2;\n\t\t\tint idx;\n\t\t\tXEvent ev = Ev[n1];\n\t\t\twin = Ev_win[n1];\n\t\t\tif (ev.type == CreateNotify) {\n\t\t\t\twin2 = ev.xcreatewindow.window;\n\t\t\t\tif (ev_lookup(win2, EV_REPARENT) || ev_lookup(win2, EV_DESTROY)) {\n\t\t\t\t\tif (skipwins_n < skipwins_max) {\nif (ncdb) fprintf(stderr, \"SKIPWINS: CreateNotify: 0x%lx %d\\n\", win2, n1);\n\t\t\t\t\t\tskipwins[skipwins_n++] = win2;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tidx = lookup_win_index(win);\n\t\t\t\t\tif (idx < 0) {\n\t\t\t\t\t\tidx = lookup_free_index();\n\t\t\t\t\t\tif (idx < 0) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tCLEAR(idx);\n\t\t\t\t\t}\nif (ncdb) fprintf(stderr, \"PRELOOP:  CreateNotify: 0x%lx %d valid_window\\n\", win2, n1);\n\t\t\t\t\tif (valid_window(win2, &attr, 1)) {\n\t\t\t\t\t\tSTORE(idx, win2, attr);\n\t\t\t\t\t\tCLEAR(idx);\n\t\t\t\t\t\tcache_list[idx].selectinput = 1;\n\t\t\t\t\t\tcache_list[idx].create_cnt = 1;\nif (ncdb) fprintf(stderr, \"PRELOOP:  CreateNotify: 0x%lx %d xselectinput\\n\", win2, n1);\n\t\t\t\t\t\txselectinput(win2, win_ev, 1);\n\t\t\t\t\t\tnxsel++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tDELETE(idx);\n\t\t\t\t\t}\n\t\t\t\t\tnxsel++;\n\t\t\t\t}\n\t\t\t} else if (ev.type == ReparentNotify) {\n\t\t\t\tif (ev.xreparent.parent != rootwin) {\n\t\t\t\t\twin2 = ev.xreparent.window;\n\t\t\t\t\tif (win2 != rootwin) {\n\t\t\t\t\t\tidx = lookup_win_index(win2);\nif (ncdb) fprintf(stderr, \"PRELOOP:  RepartNotify: 0x%lx %d idx=%d\\n\", win2, n1, idx);\n\t\t\t\t\t\tif (idx >= 0) {\n\t\t\t\t\t\t\tDELETE(idx);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (! ev_lookup(win2, EV_CREATE)) {\n\t\t\t\t\t\t\txselectinput(win2, 0, 1);\n\t\t\t\t\t\t\tnxsel++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (nxsel == 0) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tX_UNLOCK;\n\n\tif (got_NET_CURRENT_DESKTOP > 0.0) {\n\t\tif (dnow() < got_NET_CURRENT_DESKTOP + 0.25) {\n\t\t\tif (ncdb) fprintf(stderr, \"***got_NET_CURRENT_DESKTOP n=%d\\n\", n);\n\t\t\tdesktop_change = 1;\n\t\t\tn_DC++;\n\t\t} else {\n\t\t\tif (ncdb) fprintf(stderr, \"***got_NET_CURRENT_DESKTOP n=%d STALE\\n\", n);\n\t\t}\n\t\tgot_NET_CURRENT_DESKTOP = 0.0;\n\t}\n\n\tif (n == 0) {\n\t\tcheck_sched(try_batch, &did_sched);\n\t\treturn 0;\n\t}\nif (ncdb) fprintf(stderr, \"\\n\"); if (ncdb) rfbLog(\"IN  check_ncache() %d events.  %.4f\\n\", n, now - x11vnc_start);\n\n\tif (try_batch) {\n\t\tuse_batch = 1;\n\t}\n\n\tif (rotating) {\n\t\tuse_batch = 0;\n\t}\n\tif (cursor_noshape_updates_clients(screen)) {\n\t\tuse_batch = 0;\n\t}\n\n\tif (! use_batch) {\n\t\tnbatch = NULL;\n\t} else {\n\t\tnreg = 0;\n\t\tnbatch = &nreg;\n\t}\n\n\t/* XXX Y */\n\tfor (n1 = 0; n1 < n; n1++) {\n\t\tWindow twin = Ev_map[n1];\n\t\tif (twin == None || twin == rootwin) {\n\t\t\tcontinue;\n\t\t}\n\t\tfor (n2 = 0; n2 < n; n2++) {\n\t\t\tif (Ev_unmap[n2] == twin) {\n\t\t\t\tif (skipwins_n < skipwins_max) {\nif (ncdb) fprintf(stderr, \"SKIPWINS: Ev_unmap/map: 0x%lx %d\\n\", twin, n2);\n\t\t\t\t\tskipwins[skipwins_n++] = twin;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!desktop_change) {\n\t\tif (skipwins_n) {\n\t\t\tif (n_MN + n_UN >= 2 + 2*skipwins_n) {\n\t\t\t\tdesktop_change = 1;\n\t\t\t\tn_DC++;\n\t\t\t}\n\t\t} else {\n\t\t\tif (n_MN + n_UN >= 3) {\n\t\t\t\tdesktop_change = 1;\n\t\t\t\tn_DC++;\n\t\t\t}\n\t\t}\n\t}\n\tif (ncache_old_wm) {\n\t\tint shifts = 0;\n\t\tfor (i=0; i < n; i++) {\n\t\t\tXEvent ev;\n\t\t\tint type, idx = -1;\n\t\t\tint ik = Ev_order[i];\n\t\t\tint x_new, y_new, w_new, h_new;\n\t\t\tint x_old, y_old, w_old, h_old;\n\t\t\tint old_wm = 0;\n\n\t\t\tif (Ev_done[ik]) continue;\n\t\t\twin = Ev_win[ik];\n\n\t\t\tev = Ev[ik];\n\t\t\ttype = ev.type;\n\t\t\tif (type != ConfigureNotify) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (ev_lookup(win, EV_MAP)) {\n\t\t\t\tcontinue;\n\t\t\t} else if (ev_lookup(win, EV_UNMAP)) {\n\t\t\t\tcontinue;\n\t\t\t} else if (ev_lookup(win, EV_DESTROY)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tidx = lookup_win_index(win);\n\t\t\tif (idx < 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tx_new = ev.xconfigure.x; \n\t\t\ty_new = ev.xconfigure.y; \n\t\t\tw_new = ev.xconfigure.width; \n\t\t\th_new = ev.xconfigure.height; \n\n\t\t\tx_old = cache_list[idx].x;\n\t\t\ty_old = cache_list[idx].y;\n\t\t\tw_old = cache_list[idx].width;\n\t\t\th_old = cache_list[idx].height;\n\n\t\t\tif (w_new == w_old && h_new == h_old) {\n\t\t\t\tif (nabs(x_new - x_old) >= dpy_x || nabs(y_new - y_old) >= dpy_y) {\n\t\t\t\t\tsraRegionPtr r_old, r_new, r0;\n\t\t\t\t\tr0 = sraRgnCreateRect(0, 0, dpy_x, dpy_y);\n\t\t\t\t\tr_old = sraRgnCreateRect(x_old, y_old, x_old+w_old, y_old+h_old);\n\t\t\t\t\tsraRgnAnd(r_old, r0);\n\t\t\t\t\tr_new = sraRgnCreateRect(x_new, y_new, x_new+w_new, y_new+h_new);\n\t\t\t\t\tsraRgnAnd(r_new, r0);\n\t\t\t\t\tif (cache_list[idx].map_state != IsViewable) {\n\t\t\t\t\t\tev_store(win, EV_OLD_WM_NOTMAPPED);\n\t\t\t\t\t} else if (sraRgnEmpty(r_old) && !sraRgnEmpty(r_new)) {\n\t\t\t\t\t\told_wm = 1;\n\t\t\t\t\t\tev_store(win, EV_OLD_WM_MAP);\n\t\t\t\t\t\tEv_map[i] = win;\n\t\t\t\t\t} else if (!sraRgnEmpty(r_old) && sraRgnEmpty(r_new)) {\n\t\t\t\t\t\tev_store(win, EV_OLD_WM_UNMAP);\n\t\t\t\t\t\told_wm = -1;\n\t\t\t\t\t\tEv_unmap[i] = win;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tev_store(win, EV_OLD_WM_OFF);\n\t\t\t\t\t}\n\t\t\t\t\tsraRgnDestroy(r_old);\n\t\t\t\t\tsraRgnDestroy(r_new);\n\t\t\t\t\tsraRgnDestroy(r0);\n\t\t\t\t\tshifts++;\nif (ncdb) fprintf(stderr, \"old_wm[%d]  +%04d+%04d  +%04d+%04d  old_wm: %d\\n\", i, x_old, y_old, x_new, y_new, old_wm);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (shifts >= 3) {\nif (ncdb) fprintf(stderr, \"DESKTOP_CHANGE_OLD_WM: %d\\n\", shifts);\n\t\t\tdesktop_change = 1;\n\t\t\tdesktop_change_old_wm = 1;\n\t\t}\n\t}\n\n#define SKIPUMS \\\n\tok = 1; \\\n\tif (twin == None || twin == rootwin) { \\\n\t\tcontinue; \\\n\t} \\\n\tfor (ns = 0; ns < skipwins_n; ns++) { \\\n\t\tif (skipwins[ns] == twin) { \\\n\t\t\tok = 0; \\\n\t\t\tbreak; \\\n\t\t} \\\n\t}\n\n\tif (desktop_change) {\n\t\tWindow twin;\n\t\tint ok, s, k, add, cnt, ns;\n\n\t\tcnt = 0;\n\t\tadd = 0;\n\t\tfor (i=0; i < n; i++) {\n\t\t\ttwin = Ev_unmap[i];\n\t\t\tSKIPUMS\n\t\t\tif (ok) {\nif (ncdb) fprintf(stderr, \"U Ev_tmp[%d] = %d\\n\", cnt, i);\n\t\t\t\tEv_tmp[cnt++] = i;\n\t\t\t}\n\t\t}\n\t\tfor (i=0; i < n; i++) {\n\t\t\ttwin = Ev_map[i];\n\t\t\tSKIPUMS\n\t\t\tif (ok) {\nif (ncdb) fprintf(stderr, \"M Ev_tmp[%d] = %d\\n\", cnt, i);\n\t\t\t\tEv_tmp[cnt++] = i;\n\t\t\t}\n\t\t}\n\t\tfor (k = 0; k < cnt; k++) {\n\t\t\tEv_tmp2[k] = -1;\n\t\t}\n\t\t/* unmap from top to bottom */\n\t\tfor (s = old_stack_n - 1; s >= 0; s--) {\n\t\t\ttwin = old_stack[s];\t\n\t\t\tif (twin == None || twin == rootwin) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (k = 0; k < cnt; k++) {\n\t\t\t\ti = Ev_tmp[k];\n\t\t\t\tif (twin == Ev_unmap[i]) {\nif (ncdb) fprintf(stderr, \"U Ev_tmp2[%d] = %d\\n\", add, i);\n\t\t\t\t\tEv_tmp2[add++] = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/* map from bottom to top */\n\t\tfor (s = 0; s < old_stack_n; s++) {\n\t\t\ttwin = old_stack[s];\t\n\t\t\tif (twin == None || twin == rootwin) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (k = 0; k < cnt; k++) {\n\t\t\t\ti = Ev_tmp[k];\n\t\t\t\tif (twin == Ev_map[i]) {\nif (ncdb) fprintf(stderr, \"M Ev_tmp2[%d] = %d\\n\", add, i);\n\t\t\t\t\tEv_tmp2[add++] = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tk = 0;\n\t\tfor (i=0; i < n; i++) {\n\t\t\tWindow wu, wm;\n\t\t\tint j;\n\t\t\tint oku = 0, okm = 0;\n\t\t\twu = Ev_unmap[i];\n\t\t\twm = Ev_map[i];\n\t\t\tok = 0;\n\t\t\tif (wu != None && wu != rootwin) oku = 1;\n\t\t\tif (wm != None && wm != rootwin) okm = 1;\n\t\t\tif (!oku && !okm) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (oku) {\n\t\t\t\ttwin = wu;\n\t\t\t\tSKIPUMS\n\t\t\t\tif (!ok) {\n\t\t\t\t\toku = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (okm) {\n\t\t\t\ttwin = wm;\n\t\t\t\tSKIPUMS\n\t\t\t\tif (!ok) {\n\t\t\t\t\tokm = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!oku && !okm) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tj = Ev_tmp2[k++];\n\t\t\tif (j >= 0) {\nif (ncdb) fprintf(stderr, \"UM Ev_order[%d] = %d oku=%d okm=%d\\n\", i, j, oku, okm);\n\t\t\t\tEv_order[i] = j;\n\t\t\t}\n\t\t}\n\t}\n\n#if 0\n\tif (desktop_change) {\n\t\tWindow twin;\n\t\tint ok, s, k, add, cnt, ns;\n\n\t\tcnt = 0;\n\t\tadd = 0;\n\t\tfor (i=0; i < n; i++) {\n\t\t\ttwin = Ev_unmap[i];\n\t\t\tSKIPUMS\n\t\t\tif (ok) {\n\t\t\t\tEv_tmp[cnt++] = i;\n\t\t\t}\n\t\t}\n\t\tfor (k = 0; k < cnt; k++) {\n\t\t\tEv_tmp2[k] = -1;\n\t\t}\n\t\t/* unmap from top to bottom */\n\t\tfor (s = old_stack_n - 1; s >= 0; s--) {\n\t\t\ttwin = old_stack[s];\t\n\t\t\tfor (k = 0; k < cnt; k++) {\n\t\t\t\ti = Ev_tmp[k];\n\t\t\t\tif (twin == Ev_unmap[i]) {\n\t\t\t\t\tEv_tmp2[add++] = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tk = 0;\n\t\tfor (i=0; i < n; i++) {\n\t\t\tint j;\n\t\t\ttwin = Ev_unmap[i];\n\t\t\tSKIPUMS\n\t\t\tif (ok) {\n\t\t\t\tj = Ev_tmp2[k++];\n\t\t\t\tif (j >= 0) {\n\t\t\t\t\tEv_order[i] = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcnt = 0;\n\t\tadd = 0;\n\t\tfor (i=0; i < n; i++) {\n\t\t\ttwin = Ev_map[i];\n\t\t\tSKIPUMS\n\t\t\tif (ok) {\n\t\t\t\tEv_tmp[cnt++] = i;\n\t\t\t}\n\t\t}\n\t\tfor (k = 0; k < cnt; k++) {\n\t\t\tEv_tmp2[k] = -1;\n\t\t}\n\t\t/* map from bottom to top */\n\t\tfor (s = 0; s < old_stack_n; s++) {\n\t\t\ttwin = old_stack[s];\t\n\t\t\tfor (k = 0; k < cnt; k++) {\n\t\t\t\ti = Ev_tmp[k];\n\t\t\t\tif (twin == Ev_map[i]) {\n\t\t\t\t\tEv_tmp2[add++] = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tk = 0;\n\t\tfor (i=0; i < n; i++) {\n\t\t\tint j;\n\t\t\ttwin = Ev_map[i];\n\t\t\tSKIPUMS\n\t\t\tif (ok) {\n\t\t\t\tj = Ev_tmp2[k++];\n\t\t\t\tif (j >= 0) {\n\t\t\t\t\tEv_order[i] = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n#endif\n\n\tif (!desktop_change && (n_VN_p && !n_UN && (n_MN || n_ON_st))) {\n\t\tif (now < last_vis_unobs_time + 0.75 || now < last_vis_obs_time + 0.75) {\n\t\t\t;\n\t\t} else if (n_MN <= 2 && n_ON_st <= 1) {\n\t\t\tfor (i=0; i < n; i++) {\n\t\t\t\tXEvent ev;\n\t\t\t\tint type, idx = -1, state, valid;\n\t\t\t\tint ik = Ev_order[i];\n\n\t\t\t\tif (Ev_done[ik]) continue;\n\t\t\t\twin = Ev_win[ik];\n\n\t\t\t\tev = Ev[ik];\n\t\t\t\ttype = ev.type;\n\t\t\t\tif (type != VisibilityNotify) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tstate = ev.xvisibility.state;\n\t\t\t\tif (state == VisibilityUnobscured) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (ev_lookup(win, EV_MAP)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if (ev_lookup(win, EV_UNMAP)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if (ev_lookup(win, EV_DESTROY)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tidx = lookup_win_index(win);\n\n\t\t\t\tif (idx < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (cache_list[idx].vis_state == VisibilityFullyObscured) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (now < cache_list[idx].vis_unobs_time + 3.00 || now < cache_list[idx].vis_obs_time + 3.00) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\nif (ncdb) fprintf(stderr, \"----%02d: VisibilityNotify 0x%lx  %3d  (*PRELOOP*) state: %s U/P %d/%d\\n\", ik, win, idx, VState(state), n_VN_u, n_VN_p);\n\t\t\t\tvalid = 0;\n\t\t\t\tbs_save(idx, nbatch, &attr, 1, 0, &valid, 1);\n\t\t\t\tif (valid) {\n\t\t\t\t\tSTORE(idx, win, attr);\n\t\t\t\t} else {\n\t\t\t\t\tDELETE(idx);\n\t\t\t\t}\n\n\t\t\t\tcache_list[idx].vis_state = state;\n\t\t\t\tcache_list[idx].vis_obs_time = last_vis_obs_time = dnow();\n\t\t\t\tEv_done[ik] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tif (desktop_change) {\n\t\tif (ncache_dt_change) {\n\t\t\tif (ncdb) fprintf(stderr, \"GUESSED DESKTOP CHANGE.\\n\");\n\t\t\tsaw_desktop_change = 1;\n\t\t} else {\n\t\t\tif (ncdb) fprintf(stderr, \"GUESSED DESKTOP CHANGE. Skipping.\\n\");\n\t\t\tdesktop_change = 0;\n\t\t}\n\t}\n\n\n\tcreate_cnt = 0;\n\tmissed_su_restore = 0;\n\tmissed_bs_restore = 0;\n\tmissed_su_restore_rgn = sraRgnCreate();\n\tmissed_bs_restore_rgn = sraRgnCreate();\n\tr0 = sraRgnCreateRect(0, 0, dpy_x, dpy_y);\n\tunmapped_rgn = sraRgnCreate();\n\tsu_fix_cnt = 0;\n\nfor (k = 0; k < skipwins_n; k++) {\n\tif (ncdb) fprintf(stderr, \"skipwins[%d] 0x%lx\\n\", k, skipwins[k]);\n}\n\n\tX_LOCK;\n\tfor (i=0; i < n; i++) {\n\t\tXEvent ev;\n\t\tint ns, skip = 0, type, idx = -1;\n\t\tint ik = Ev_order[i];\n\n\t\tif (Ev_done[ik]) continue;\n\t\twin = Ev_win[ik];\n\n\t\tev = Ev[ik];\n\t\ttype = ev.type;\n\t\tEv_done[ik] = 1;\n\n\t\twin2 = win;\n\t\tif (win == rootwin) {\n\t\t\tif (type == CreateNotify) {\n\t\t\t\twin2 = ev.xcreatewindow.window;\n\t\t\t} else if (type == ReparentNotify) {\n\t\t\t\twin2 = ev.xreparent.window;\n\t\t\t}\n\t\t}\n\t\tfor (ns = 0; ns < skipwins_n; ns++) {\n\t\t\tif (win2 == skipwins[ns]) {\n\t\t\t\tskip = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (skip) {\nif (ncdb) fprintf(stderr, \"skip%02d: ** SpecialSkip   0x%lx/0x%lx type: %s\\n\", ik, win, win2, Etype(type));\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tif (win == rootwin) {\n\t\t\tif (type == CreateNotify) {\n\t\t\t\tint x=0, y=0, w=0, h=0;\n\t\t\t\tvalid = 0;\n\t\t\t\twin2 = ev.xcreatewindow.window;\n\t\t\t\tidx = lookup_win_index(win2);\n\t\t\t\tif (idx < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (cache_list[idx].valid) {\n\t\t\t\t\tvalid = 1;\n\t\t\t\t\tx=cache_list[idx].x;\n\t\t\t\t\ty=cache_list[idx].y;\n\t\t\t\t\tw=cache_list[idx].width;\n\t\t\t\t\th=cache_list[idx].height;\n\t\t\t\t\tif (w*h > 64 * 64 && ev_lookup(win2, EV_MAP)) {\n\t\t\t\t\t\tX_UNLOCK;\n\t\t\t\t\t\tvalid = 1;\n\t\t\t\t\t\tsu_save(idx, nbatch, &attr, 0, &valid, 1);\n\t\t\t\t\t\tSTORE(idx, win2, attr);\n\n\t\t\t\t\t\tX_LOCK;\n\n\t\t\t\t\t\tif (! desktop_change) {\n\t\t\t\t\t\t\tSCHED(win2, 1) \n\t\t\t\t\t\t}\n\t\t\t\t\t\tcreate_cnt++;\n\t\t\t\t\t}\n\t\t\t\t}\nif (ncdb) fprintf(stderr, \"root%02d: ** CreateNotify  0x%lx  %3d  -- %dx%d+%d+%d valid=%d\\n\", ik, win2, idx, w, h, x, y, valid);\n\n\t\t\t} else if (type == ReparentNotify) {\n\t\t\t\tif (ev.xreparent.parent != rootwin) {\n\t\t\t\t\twin2 = ev.xreparent.window;\n\t\t\t\t\tidx = lookup_win_index(win2);\nif (ncdb) fprintf(stderr, \"root%02d: ReparentNotifyRM 0x%lx  %3d\\n\", ik, win2, idx);\n\t\t\t\t}\n\t\t\t} else {\nif (ncdb) fprintf(stderr, \"root%02d: ** IgnoringRoot  0x%lx type: %s\\n\", ik, win, Etype(type));\n\t\t\t}\n\t\t} else {\n\t\t\tif (type == ConfigureNotify) {\n\t\t\t\tint x_new, y_new, w_new, h_new;\n\t\t\t\tint x_old, y_old, w_old, h_old;\n\t\t\t\tint stack_change, old_wm = 0;\n\t\t\t\tWindow oabove = None;\n\n\t\t\t\tidx = lookup_win_index(win);\n\n\t\t\t\tif (idx >= 0) {\n\t\t\t\t\toabove = cache_list[idx].above;\n\t\t\t\t}\n\nif (ncdb) fprintf(stderr, \"----%02d: ConfigureNotify  0x%lx  %3d  -- above: 0x%lx -> 0x%lx  %dx%d+%d+%d\\n\", ik, win, idx,\n    oabove, ev.xconfigure.above, ev.xconfigure.width, ev.xconfigure.height, ev.xconfigure.x, ev.xconfigure.y);\n\n\t\t\t\tif (idx < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tx_new = ev.xconfigure.x; \n\t\t\t\ty_new = ev.xconfigure.y; \n\t\t\t\tw_new = ev.xconfigure.width; \n\t\t\t\th_new = ev.xconfigure.height; \n\n\t\t\t\tx_old = cache_list[idx].x;\n\t\t\t\ty_old = cache_list[idx].y;\n\t\t\t\tw_old = cache_list[idx].width;\n\t\t\t\th_old = cache_list[idx].height;\n\n\t\t\t\tif (desktop_change_old_wm) {\n\t\t\t\t\tif (ev_lookup(win, EV_OLD_WM_MAP)) {\n\t\t\t\t\t\tif (Ev_map[ik] == win) {\n\t\t\t\t\t\t\told_wm = 1;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\told_wm = 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (ev_lookup(win, EV_OLD_WM_UNMAP)) {\n\t\t\t\t\t\tif (Ev_unmap[ik] == win) {\n\t\t\t\t\t\t\told_wm = -1;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\told_wm = 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (ev_lookup(win, EV_OLD_WM_OFF)) {\n\t\t\t\t\t\told_wm = 2;\n\t\t\t\t\t} else if (ev_lookup(win, EV_OLD_WM_NOTMAPPED)) {\n\t\t\t\t\t\told_wm = 3;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!old_wm)  {\n\t\t\t\t\tif (x_old != x_new || y_old != y_new) {\n\t\t\t\t\t\t/* invalidate su */\n\t\t\t\t\t\tcache_list[idx].su_time = 0.0;\nif (ncdb) fprintf(stderr, \"          INVALIDATE su: 0x%lx xy: +%d+%d  +%d+%d \\n\", win, x_old, y_old, x_new, y_new);\n\t\t\t\t\t}\n\t\t\t\t\tif (w_old != w_new || h_old != h_new) {\n\t\t\t\t\t\t/* invalidate bs */\n\t\t\t\t\t\tcache_list[idx].bs_time = 0.0;\nif (ncdb) fprintf(stderr, \"          INVALIDATE bs: 0x%lx wh:  %dx%d   %dx%d \\n\", win, w_old, h_old, w_new, h_new);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tint valid;\n\t\t\t\t\tX_UNLOCK;\n\t\t\t\t\tif (old_wm == 1) {\n\t\t\t\t\t\t/* XXX Y */\nif (ncdb) fprintf(stderr, \"          OLD_WM_MAP:    0x%lx wh:  %dx%d+%d+%d   %dx%d+%d+%d \\n\", win, w_old, h_old, x_old, y_old, w_new, h_new, x_new, y_new);\n\t\t\t\t\t\tvalid = 0;\n\t\t\t\t\t\tbs_restore(idx, nbatch, NULL, &attr, 0, 0, &valid, 1);\n\n\t\t\t\t\t} else if (old_wm == -1) {\nif (ncdb) fprintf(stderr, \"          OLD_WM_UNMAP:  0x%lx wh:  %dx%d+%d+%d   %dx%d+%d+%d \\n\", win, w_old, h_old, x_old, y_old, w_new, h_new, x_new, y_new);\n\t\t\t\t\t\tvalid = 1;\n\t\t\t\t\t\tsu_restore(idx, nbatch, NULL, &attr, 1, 0, &valid, 1);\n\t\t\t\t\t} else {\nif (ncdb) fprintf(stderr, \"          OLD_WM_OFF::   0x%lx wh:  %dx%d+%d+%d   %dx%d+%d+%d  old_wm=%d\\n\", win, w_old, h_old, x_old, y_old, w_new, h_new, x_new, y_new, old_wm);\n\t\t\t\t\t}\n\t\t\t\t\tX_LOCK;\n\t\t\t\t}\n\n\t\t\t\tstack_change = 0;\n\t\t\t\tif (old_wm) {\n\t\t\t\t\t;\n\t\t\t\t} else if (cache_list[idx].above != ev.xconfigure.above) {\n\t\t\t\t\tstack_change = 1;\n\t\t\t\t} else if (x_new == x_old && y_new == y_old && w_new == w_old && h_new == h_old) {\n\t\t\t\t\tstack_change = 1;\n\t\t\t\t}\n\t\t\t\tif (stack_change) {\n\t\t\t\t\tint i2, ok = 1;\n\t\t\t\t\tfor (i2=0; i2 < n; i2++)  {\n\t\t\t\t\t\tif (Ev_map[i2] == win) {\n\t\t\t\t\t\t\tok = 0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (ok) {\n\t\t\t\t\t\tif (n_MN == 0 && n_UN == 0) {\n\t\t\t\t\t\t\tif (su_fix_cnt > 0) {\n\t\t\t\t\t\t\t\tok = 0;\nif (ncdb) fprintf(stderr, \"          CONF_IGNORE: Too many stacking changes: 0x%lx\\n\", win);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\tif (ok) {\n\t\t\t\t\t\tif (ev_lookup(ev.xconfigure.above, EV_UNMAP)) {\n\t\t\t\t\t\t\tif (ncdb) fprintf(stderr, \"        skip try_to_fix_su for GNOME deiconify #1\\n\");\n\t\t\t\t\t\t\tif (dt_gnome) {\n\t\t\t\t\t\t\t\tgnome_animation = 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tok = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (ok && dt_gnome) {\n\t\t\t\t\t\tif (valid_window(ev.xconfigure.above, &attr, 1)) {\n\t\t\t\t\t\t\tif (attr.map_state != IsViewable) {\n\t\t\t\t\t\t\t\tif (ncdb) fprintf(stderr, \"        skip try_to_fix_su for GNOME deiconify #2\\n\");\n\t\t\t\t\t\t\t\tgnome_animation = 1;\n\t\t\t\t\t\t\t\tok = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (ok) {\n\t\t\t\t\t\tint rc = try_to_fix_su(win, idx, ev.xconfigure.above, nbatch, NULL);\t\n\t\t\t\t\t\tif (rc == 0 && su_fix_cnt == 0 && n_MN == 0 && n_UN == 0) {\n\t\t\t\t\t\t\tX_UNLOCK;\n\t\t\t\t\t\t\ttry_to_synthesize_su(1, 1, nbatch);\n\t\t\t\t\t\t\tX_LOCK;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tn_ST++;\n\t\t\t\t\t\tsu_fix_cnt++;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tcache_list[idx].x = x_new;\n\t\t\t\tcache_list[idx].y = y_new;\n\t\t\t\tcache_list[idx].width = w_new;\n\t\t\t\tcache_list[idx].height = h_new;\n\n\t\t\t\tcache_list[idx].above = ev.xconfigure.above;\n\t\t\t\tcache_list[idx].time = dnow();\n\n\t\t\t} else if (type == VisibilityNotify) {\n\t\t\t\tint state = ev.xvisibility.state;\n\t\t\t\tidx = lookup_win_index(win);\nif (ncdb) fprintf(stderr, \"----%02d: VisibilityNotify 0x%lx  %3d  state: %s U/P %d/%d\\n\", ik, win, idx, VState(state), n_VN_u, n_VN_p);\n\n\t\t\t\tif (idx < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (desktop_change) {\n\t\t\t\t\t;\n\t\t\t\t} else if (macosx_console && n_VN_p == 0) {\n\t\t\t\t\t;\t/* XXXX not working well yet with UnmapNotify ... */\n\t\t\t\t} else if (state == VisibilityUnobscured) {\n\t\t\t\t\tint ok = 1;\n\t\t\t\t\tif (ncache <= 2) {\n\t\t\t\t\t\tok = 0;\n\t\t\t\t\t} else if (ev_lookup(win, EV_MAP)) {\n\t\t\t\t\t\tok = 0;\n\t\t\t\t\t} else if (ev_lookup(win, EV_UNMAP)) {\n\t\t\t\t\t\tok = 0;\n\t\t\t\t\t} else if (ev_lookup(win, EV_DESTROY)) {\n\t\t\t\t\t\tok = 0;\n\t\t\t\t\t} else if (gnome_animation) {\n\t\t\t\t\t\tok = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* this is for gnome iconify */\n\t\t\t\t\t\tint i2;\n\t\t\t\t\t\tfor (i2=i+1; i2 < n; i2++) {\n\t\t\t\t\t\t\tint idx2, ik2 = Ev_order[i2];\n\t\t\t\t\t\t\tsraRegionPtr ro1, ro2;\n\t\t\t\t\t\t\tWindow win2 = Ev_unmap[ik2];\n\n\t\t\t\t\t\t\tif (win2 == None) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tidx2 = lookup_win_index(win2);\n\t\t\t\t\t\t\tif (idx2 < 0) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tro1 = idx_create_rgn(r0, idx);\n\t\t\t\t\t\t\tro2 = idx_create_rgn(r0, idx2);\n\n\t\t\t\t\t\t\tif (sraRgnAnd(ro1, ro2)) {\n\t\t\t\t\t\t\t\tif (ncdb) fprintf(stderr, \"        skip VisibilityUnobscured for GNOME iconify.\\n\");\n\t\t\t\t\t\t\t\tok = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsraRgnDestroy(ro1);\n\t\t\t\t\t\t\tsraRgnDestroy(ro2);\n\t\t\t\t\t\t\tif (! ok) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (ok) {\n\t\t\t\t\t\tint x2, y2, w2, h2;\n\t\t\t\t\t\tsraRegionPtr rmask = NULL;\n\t\t\t\t\t\tvalid = 0;\n\t\t\t\t\t\tif (dnow() < cache_list[idx].vis_unobs_time + 3.00 && !sraRgnEmpty(unmapped_rgn)) {\n\t\t\t\t\t\t\tx2 = cache_list[idx].x;\n\t\t\t\t\t\t\ty2 = cache_list[idx].y;\n\t\t\t\t\t\t\tw2 = cache_list[idx].width;\n\t\t\t\t\t\t\th2 = cache_list[idx].height;\n\t\t\t\t\t\t\trmask = sraRgnCreateRect(x2, y2, x2+w2, y2+h2);\n\t\t\t\t\t\t\tsraRgnAnd(rmask, unmapped_rgn);\n\t\t\t\t\t\t\tif (sraRgnEmpty(rmask)) {\n\t\t\t\t\t\t\t\tsraRgnDestroy(rmask);\n\t\t\t\t\t\t\t\trmask = NULL;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (ev_lookup(win, EV_CONFIGURE_SIZE)) {\n\t\t\t\t\t\t\tvalid = valid_window(win, &attr, 1);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tX_UNLOCK;\n\t\t\t\t\t\t\tbs_restore(idx, nbatch, rmask, &attr, 0, 1, &valid, 1);\n\t\t\t\t\t\t\tX_LOCK;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (rmask != NULL) {\n\t\t\t\t\t\t\tsraRgnDestroy(rmask);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (valid) {\n\t\t\t\t\t\t\tSTORE(idx, win, attr);\n\n\t\t\t\t\t\t\tcache_list[idx].time = dnow();\n\t\t\t\t\t\t\tcache_list[idx].vis_cnt++;\n\t\t\t\t\t\t\tEv_map[ik] = win;\n\t\t\t\t\t\t\tEv_rects[nrects].x1 = cache_list[idx].x;\n\t\t\t\t\t\t\tEv_rects[nrects].y1 = cache_list[idx].y;\n\t\t\t\t\t\t\tEv_rects[nrects].x2 = cache_list[idx].width;\n\t\t\t\t\t\t\tEv_rects[nrects].y2 = cache_list[idx].height;\n\t\t\t\t\t\t\tnrects++;\n\t\t\t\t\t\t\tSCHED(win, 1) \n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tDELETE(idx);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (state == VisibilityUnobscured) {\n\t\t\t\t\tcache_list[idx].vis_unobs_time = last_vis_unobs_time = dnow();\n\t\t\t\t} else if (cache_list[idx].vis_state == VisibilityUnobscured) {\n\t\t\t\t\tcache_list[idx].vis_obs_time = last_vis_obs_time = dnow();\n\t\t\t\t}\n\t\t\t\tcache_list[idx].vis_state = state;\n\n\t\t\t} else if (type == MapNotify) {\n\t\t\t\tidx = lookup_win_index(win);\nif (ncdb) fprintf(stderr, \"----%02d: MapNotify        0x%lx  %3d\\n\", ik, win, idx);\n\n\t\t\t\tif (idx < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n#if 0\n/*\n\t\t\t\tif (cache_list[idx].map_state == IsUnmapped || desktop_change || macosx_console)\n */\n#endif\n\t\t\t\tif (1) {\n\t\t\t\t\tX_UNLOCK;\n\t\t\t\t\tif (desktop_change) {\n\t\t\t\t\t\t/* XXX Y */\n\t\t\t\t\t\tint save = 1;\n\t\t\t\t\t\tsraRegionPtr r;\n\t\t\t\t\t\tif (cache_list[idx].su_time != 0.0) {\n\t\t\t\t\t\t\tsave = 0;\n\t\t\t\t\t\t} else if (missed_su_restore) {\n\t\t\t\t\t\t\tr = idx_create_rgn(r0, idx);\n\t\t\t\t\t\t\tif (sraRgnAnd(r, missed_su_restore_rgn)) {\n\t\t\t\t\t\t\t\tsave = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsraRgnDestroy(r);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (missed_bs_restore) {\n\t\t\t\t\t\t\tr = idx_create_rgn(r0, idx);\n\t\t\t\t\t\t\tif (sraRgnAnd(r, missed_bs_restore_rgn)) {\n\t\t\t\t\t\t\t\tsave = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsraRgnDestroy(r);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (save) {\n\t\t\t\t\t\t\tvalid = 0;\n\t\t\t\t\t\t\tsu_save(idx, nbatch, &attr, 1, &valid, 1);\n\t\t\t\t\t\t\tif (valid) {\n\t\t\t\t\t\t\t\tSTORE(idx, win, attr);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvalid = 0;\n\t\t\t\t\t\tsu_save(idx, nbatch, &attr, 0, &valid, 1);\n\t\t\t\t\t\tif (valid) {\n\t\t\t\t\t\t\tSTORE(idx, win, attr);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tvalid = 0;\n\t\t\t\t\tif (ev_lookup(win, EV_CONFIGURE_SIZE)) {\n\t\t\t\t\t\tX_LOCK;\n\t\t\t\t\t\tvalid = valid_window(win, &attr, 1);\n\t\t\t\t\t\tX_UNLOCK;\n\t\t\t\t\t\tidx_add_rgn(missed_bs_restore_rgn, r0, idx);\n\t\t\t\t\t\tmissed_bs_restore++;\n\t\t\t\t\t} else if (bs_restore(idx, nbatch, NULL, &attr, 0, 0, &valid, 1)) { /* XXX clip? */\n\t\t\t\t\t\t;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tidx_add_rgn(missed_bs_restore_rgn, r0, idx);\n\t\t\t\t\t\tmissed_bs_restore++;\n\t\t\t\t\t}\n\t\t\t\t\tif (valid) {\n\t\t\t\t\t\tSTORE(idx, win, attr);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (macosx_console) {\n#ifdef MACOSX\n\t\t\t\t\t\tmacosxCGS_follow_animation_win(win, -1, 1);\n\t\t\t\t\t\tif (valid_window(win, &attr, 1)) {\n\t\t\t\t\t\t\tSTORE(idx, win, attr);\n\t\t\t\t\t\t\tSCHED(win, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/* XXX Y */\n\t\t\t\t\t\tif (cache_list[idx].vis_state == -1)  {\n\t\t\t\t\t\t\tcache_list[idx].vis_state = VisibilityUnobscured;\n\t\t\t\t\t\t}\n#endif\n\t\t\t\t\t}\n\t\t\t\t\tX_LOCK;\n\t\t\t\t\tpixels += cache_list[idx].width * cache_list[idx].height;\n\t\t\t\t\tcache_list[idx].time = dnow();\n\t\t\t\t\tcache_list[idx].map_cnt++;\n\t\t\t\t\tEv_map[ik] = win;\n\t\t\t\t\tEv_rects[nrects].x1 = cache_list[idx].x;\n\t\t\t\t\tEv_rects[nrects].y1 = cache_list[idx].y;\n\t\t\t\t\tEv_rects[nrects].x2 = cache_list[idx].width;\n\t\t\t\t\tEv_rects[nrects].y2 = cache_list[idx].height;\n\t\t\t\t\tnrects++;\n\n\t\t\t\t\tif (! valid) {\n\t\t\t\t\t\tDELETE(idx);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcache_list[idx].map_state = IsViewable;\n\n\t\t\t} else if (type == UnmapNotify) {\n\t\t\t\tint x2, y2, w2, h2;\n\t\t\t\tidx = lookup_win_index(win);\nif (ncdb) fprintf(stderr, \"----%02d: UnmapNotify      0x%lx  %3d\\n\", ik, win, idx);\n\n\t\t\t\tif (idx < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (macosx_console) {\n\t\t\t\t\tif (mode == 2) {\n\t\t\t\t\t\tcache_list[idx].map_state = IsViewable;\n\t\t\t\t\t}\n\t\t\t\t}\n\n#if 0\n/*\n\t\t\t\tif (cache_list[idx].map_state == IsViewable || desktop_change || macosx_console)\n */\n#endif\n\t\t\t\tif (1) {\n\t\t\t\t\tX_UNLOCK;\n\t\t\t\t\tif (desktop_change) {\n\t\t\t\t\t\tint save = 1;\n\t\t\t\t\t\tsraRegionPtr r;\n\t\t\t\t\t\tif (cache_list[idx].bs_time > 0.0) {\n\t\t\t\t\t\t\tsave = 0;\n\t\t\t\t\t\t} else if (missed_su_restore) {\n\t\t\t\t\t\t\tr = idx_create_rgn(r0, idx);\n\t\t\t\t\t\t\tif (sraRgnAnd(r, missed_su_restore_rgn)) {\n\t\t\t\t\t\t\t\tsave = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsraRgnDestroy(r);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (missed_bs_restore) {\n\t\t\t\t\t\t\tr = idx_create_rgn(r0, idx);\n\t\t\t\t\t\t\tif (sraRgnAnd(r, missed_bs_restore_rgn)) {\n\t\t\t\t\t\t\t\tsave = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsraRgnDestroy(r);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (save) {\n\t\t\t\t\t\t\tvalid = 0;\n\t\t\t\t\t\t\tbs_save(idx, nbatch, &attr, 1, 0, &valid, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvalid = 0;\n\t\t\t\t\t\tbs_save(idx, nbatch, &attr, 1, 0, &valid, 1);\n\t\t\t\t\t}\n\t\t\t\t\tvalid = 0;\n\t\t\t\t\tif (su_restore(idx, nbatch, NULL, &attr, 1, 0, &valid, 1)) {\n\t\t\t\t\t\ttry_to_fix_su(win, idx, None, nbatch, \"unmapped\");\t\n\t\t\t\t\t\tif (valid) {\n\t\t\t\t\t\t\tSTORE(idx, win, attr);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tDELETE(idx);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tidx_add_rgn(missed_su_restore_rgn, r0, idx);\n\t\t\t\t\t\tmissed_su_restore++;\n\t\t\t\t\t}\n\t\t\t\t\tX_LOCK;\n\n\t\t\t\t\tpixels += cache_list[idx].width * cache_list[idx].height;\n\t\t\t\t\tcache_list[idx].time = dnow();\n\t\t\t\t\tcache_list[idx].unmap_cnt++;\n\t\t\t\t\tEv_unmap[ik] = win;\n\t\t\t\t\tEv_rects[nrects].x1 = cache_list[idx].x;\n\t\t\t\t\tEv_rects[nrects].y1 = cache_list[idx].y;\n\t\t\t\t\tEv_rects[nrects].x2 = cache_list[idx].width;\n\t\t\t\t\tEv_rects[nrects].y2 = cache_list[idx].height;\n\t\t\t\t\tnrects++;\n\t\t\t\t}\n\n\t\t\t\tx2 = cache_list[idx].x;\n\t\t\t\ty2 = cache_list[idx].y;\n\t\t\t\tw2 = cache_list[idx].width;\n\t\t\t\th2 = cache_list[idx].height;\n\t\t\t\tr = sraRgnCreateRect(x2, y2, x2+w2, y2+h2);\n\t\t\t\tsraRgnAnd(r, r0); \n\t\t\t\tsraRgnOr(unmapped_rgn, r); \n\t\t\t\tsraRgnDestroy(r);\n\n\t\t\t\tcache_list[idx].map_state = IsUnmapped;\n\n\t\t\t} else if (type == ReparentNotify) {\n\t\t\t\tif (ev.xreparent.parent != rootwin) {\n\t\t\t\t\twin2 = ev.xreparent.window;\n\t\t\t\t\tif (win2 != rootwin) {\n\t\t\t\t\t\tidx = lookup_win_index(win2);\nif (ncdb) fprintf(stderr, \"----%02d: ReparentNotifyRM 0x%lx  %3d\\n\", ik, win2, idx);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t} else if (type == DestroyNotify) {\n\t\t\t\twin2 = ev.xdestroywindow.window;\n\t\t\t\tidx = lookup_win_index(win2);\nif (ncdb) fprintf(stderr, \"----%02d: DestroyNotify    0x%lx  %3d\\n\", ik, win2, idx);\n\n\t\t\t\tif (idx >= 0) {\n\t\t\t\t\tDELETE(idx);\n\t\t\t\t}\n\t\t\t} else {\nif (ncdb) fprintf(stderr, \"igno%02d: ** Ignoring      0x%lx type: %s\\n\", ik, win, Etype(type));\n\t\t\t}\n\n\t\t}\n\t}\n\tX_UNLOCK;\n\n\tif (use_batch && nreg) {\n\t\tbatch_push(nreg, -1.0);\n\t}\n\tif (nrects) {\n\t\tif (scaling) {\n\t\t\tpush_borders(Ev_rects, nrects);\n\t\t}\n\t}\n\n\tcheck_sched(try_batch, &did_sched);\n\n\tif (n_CN || n_RN || n_DN || n_MN || n_UN || n_ST || n_DC || did_sched) {\n\t\tsnap_old();\n\t}\n\n\tsraRgnDestroy(r0);\n\tsraRgnDestroy(missed_su_restore_rgn);\n\tsraRgnDestroy(missed_bs_restore_rgn);\n\nif (ncdb) rfbLog(\"OUT check_ncache(): %.4f %.6f events: %d  pixels: %d\\n\", dnowx(), dnow() - now, n, pixels);\nif (ncdb) fprintf(stderr, \"\\n\");\n\treturn pixels;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"\\n*** SCAN_DISPLAY CHECK_NCACHE/%d *** %d rescan=%d\\n\"",
            "gotone",
            "y",
            "rescan"
          ],
          "line": 3254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dnowx",
          "args": [],
          "line": 3250
        },
        "resolved": true,
        "details": {
          "function_name": "dnowx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "439-441",
          "snippet": "double dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double dnow(void);",
            "double dnowx(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dnow(void);\ndouble dnowx(void);\n\ndouble dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XPutBackEvent",
          "args": [
            "dpy",
            "&ev"
          ],
          "line": 3243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XCheckTypedEvent",
          "args": [
            "dpy",
            "VisibilityNotify",
            "&ev"
          ],
          "line": 3239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XCheckTypedEvent",
          "args": [
            "dpy",
            "ConfigureNotify",
            "&ev"
          ],
          "line": 3237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XCheckTypedEvent",
          "args": [
            "dpy",
            "CreateNotify",
            "&ev"
          ],
          "line": 3235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XCheckTypedEvent",
          "args": [
            "dpy",
            "UnmapNotify",
            "&ev"
          ],
          "line": 3233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XCheckTypedEvent",
          "args": [
            "dpy",
            "MapNotify",
            "&ev"
          ],
          "line": 3231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XEventsQueued",
          "args": [
            "dpy",
            "QueuedAlready"
          ],
          "line": 3229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "macosx_checkevent",
          "args": [
            "NULL"
          ],
          "line": 3221
        },
        "resolved": true,
        "details": {
          "function_name": "macosx_checkevent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosx.c",
          "lines": "495-528",
          "snippet": "int macosx_checkevent(XEvent *ev) {\n\tint i = mac_events_ptr;\n\n\tif (mac_events_ptr == mac_events_last) {\n\t\treturn 0;\n\t}\n\tif (ev == NULL) {\n\t\treturn mac_events[i].type;\n\t}\n\n\tev->xany.window = mac_events[i].win;\n\n\tif (mac_events[i].type == CreateNotify) {\n\t\tev->type = CreateNotify;\n\t\tev->xany.window = rootwin;\n\t\tev->xcreatewindow.window = mac_events[i].win;\n\t} else if (mac_events[i].type == DestroyNotify) {\n\t\tev->type = DestroyNotify;\n\t\tev->xdestroywindow.window = mac_events[i].win;\n\t} else if (mac_events[i].type == VisibilityNotify) {\n\t\tev->type = VisibilityNotify;\n\t\tev->xvisibility.state = mac_events[i].vis;\n\t} else if (mac_events[i].type == MapNotify) {\n\t\tev->type = MapNotify;\n\t} else if (mac_events[i].type == UnmapNotify) {\n\t\tev->type = UnmapNotify;\n\t} else {\n\t\tfprintf(stderr, \"unknown macosx_checkevent: %d\\n\", mac_events[i].type);\n\t}\n\tmac_events_ptr++;\n\tmac_events_ptr = mac_events_ptr % MAX_EVENTS;\n\n\treturn mac_events[i].type;\n}",
          "includes": [
            "#include \"macosxCGS.h\"",
            "#include \"macosxCGP.h\"",
            "#include \"macosxCG.h\"",
            "#include \"connections.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"allowed_input_t.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define MAX_EVENTS 1024"
          ],
          "globals_used": [
            "int macosx_get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);",
            "int macosx_checkevent(XEvent *ev);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"macosxCGS.h\"\n#include \"macosxCGP.h\"\n#include \"macosxCG.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"allowed_input_t.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include \"config.h\"\n\n#define MAX_EVENTS 1024\n\nint macosx_get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);\nint macosx_checkevent(XEvent *ev);\n\nint macosx_checkevent(XEvent *ev) {\n\tint i = mac_events_ptr;\n\n\tif (mac_events_ptr == mac_events_last) {\n\t\treturn 0;\n\t}\n\tif (ev == NULL) {\n\t\treturn mac_events[i].type;\n\t}\n\n\tev->xany.window = mac_events[i].win;\n\n\tif (mac_events[i].type == CreateNotify) {\n\t\tev->type = CreateNotify;\n\t\tev->xany.window = rootwin;\n\t\tev->xcreatewindow.window = mac_events[i].win;\n\t} else if (mac_events[i].type == DestroyNotify) {\n\t\tev->type = DestroyNotify;\n\t\tev->xdestroywindow.window = mac_events[i].win;\n\t} else if (mac_events[i].type == VisibilityNotify) {\n\t\tev->type = VisibilityNotify;\n\t\tev->xvisibility.state = mac_events[i].vis;\n\t} else if (mac_events[i].type == MapNotify) {\n\t\tev->type = MapNotify;\n\t} else if (mac_events[i].type == UnmapNotify) {\n\t\tev->type = UnmapNotify;\n\t} else {\n\t\tfprintf(stderr, \"unknown macosx_checkevent: %d\\n\", mac_events[i].type);\n\t}\n\tmac_events_ptr++;\n\tmac_events_ptr = mac_events_ptr % MAX_EVENTS;\n\n\treturn mac_events[i].type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"ns y=%d\\n\"",
            "y"
          ],
          "line": 3209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdamage_hint_skip",
          "args": [
            "y"
          ],
          "line": 3193
        },
        "resolved": true,
        "details": {
          "function_name": "xdamage_hint_skip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xdamage.c",
          "lines": "638-734",
          "snippet": "int xdamage_hint_skip(int y) {\n\tstatic sraRegionPtr scanline = NULL;\n\tstatic sraRegionPtr tmpl_y = NULL;\n\tint fast_tmpl = 1;\n\tsraRegionPtr reg, tmpl;\n\tint ret, i, n, nreg;\n#ifndef NO_NCACHE\n\tstatic int ncache_no_skip = 0;\n\tstatic double last_ncache_no_skip = 0.0;\n\tstatic double last_ncache_no_skip_long = 0.0, ncache_fac = 0.25;\n#endif\n\n\tif (! xdamage_present || ! use_xdamage) {\n\t\treturn 0;\t/* cannot skip */\n\t}\n\tif (! xdamage_regions) {\n\t\treturn 0;\t/* cannot skip */\n\t}\n\n\tif (! scanline) {\n\t\t/* keep it around to avoid malloc etc, recreate */\n\t\tscanline = sraRgnCreate();\n\t}\n\tif (! tmpl_y) {\n\t\ttmpl_y = sraRgnCreateRect(0, 0, dpy_x, 1);\n\t}\n\n\tnreg = (xdamage_memory * NSCAN) + 1;\n\n#ifndef NO_NCACHE\n\tif (ncache > 0) {\n\t\tif (ncache_no_skip == 0) {\n\t\t\tdouble now = g_now;\n\t\t\tif (now > last_ncache_no_skip + 8.0) {\n\t\t\t\tncache_no_skip = 1;\n\t\t\t} else if (now < last_bs_restore + 0.5) {\n\t\t\t\tncache_no_skip = 1;\n\t\t\t} else if (now < last_su_restore + 0.5) {\n\t\t\t\tncache_no_skip = 1;\n\t\t\t} else if (now < last_copyrect + 0.5) {\n\t\t\t\tncache_no_skip = 1;\n\t\t\t}\n\t\t\tif (ncache_no_skip) {\n\t\t\t\tlast_ncache_no_skip = dnow();\n\t\t\t\tif (now > last_ncache_no_skip_long + 60.0) {\n\t\t\t\t\tncache_fac = 2.0;\n\t\t\t\t\tlast_ncache_no_skip_long = now;\n\t\t\t\t} else {\n\t\t\t\t\tncache_fac = 0.25;\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t} else {\n\t\t\tif (ncache_no_skip++ >= ncache_fac*nreg + 4) {\n\t\t\t\tncache_no_skip = 0;\n\t\t\t} else {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n#endif\n\n\tif (fast_tmpl) {\n\t\tsraRgnOffset(tmpl_y, 0, y);\n\t\ttmpl = tmpl_y;\n\t} else {\n\t\ttmpl = sraRgnCreateRect(0, y, dpy_x, y+1);\n\t}\n\n\tret = 1;\n\tfor (i=0; i<nreg; i++) {\n\t\t/* go back thru the history starting at most recent */\n\t\tn = (xdamage_ticker + nreg - i) % nreg;\n\t\treg = xdamage_regions[n];  \n\t\tif (reg == NULL) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (sraRgnEmpty(reg)) {\n\t\t\t/* checking for emptiness is very fast */\n\t\t\tcontinue;\n\t\t}\n\t\tsraRgnMakeEmpty(scanline);\n\t\tsraRgnOr(scanline, tmpl);\n\t\tif (sraRgnAnd(scanline, reg)) {\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fast_tmpl) {\n\t\tsraRgnOffset(tmpl_y, 0, -y);\n\t} else {\n\t\tsraRgnDestroy(tmpl);\n\t}\nif (0) fprintf(stderr, \"xdamage_hint_skip: %d -> %d\\n\", y, ret);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"unixpw.h\"",
            "#include \"userinput.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int use_xdamage = XDAMAGE;",
            "int xdamage_present = 0;",
            "double xdamage_memory = 1.0;",
            "sraRegionPtr *xdamage_regions = NULL;",
            "int xdamage_ticker = 0;",
            "int xdamage_hint_skip(int y);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"unixpw.h\"\n#include \"userinput.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint use_xdamage = XDAMAGE;\nint xdamage_present = 0;\ndouble xdamage_memory = 1.0;\nsraRegionPtr *xdamage_regions = NULL;\nint xdamage_ticker = 0;\nint xdamage_hint_skip(int y);\n\nint xdamage_hint_skip(int y) {\n\tstatic sraRegionPtr scanline = NULL;\n\tstatic sraRegionPtr tmpl_y = NULL;\n\tint fast_tmpl = 1;\n\tsraRegionPtr reg, tmpl;\n\tint ret, i, n, nreg;\n#ifndef NO_NCACHE\n\tstatic int ncache_no_skip = 0;\n\tstatic double last_ncache_no_skip = 0.0;\n\tstatic double last_ncache_no_skip_long = 0.0, ncache_fac = 0.25;\n#endif\n\n\tif (! xdamage_present || ! use_xdamage) {\n\t\treturn 0;\t/* cannot skip */\n\t}\n\tif (! xdamage_regions) {\n\t\treturn 0;\t/* cannot skip */\n\t}\n\n\tif (! scanline) {\n\t\t/* keep it around to avoid malloc etc, recreate */\n\t\tscanline = sraRgnCreate();\n\t}\n\tif (! tmpl_y) {\n\t\ttmpl_y = sraRgnCreateRect(0, 0, dpy_x, 1);\n\t}\n\n\tnreg = (xdamage_memory * NSCAN) + 1;\n\n#ifndef NO_NCACHE\n\tif (ncache > 0) {\n\t\tif (ncache_no_skip == 0) {\n\t\t\tdouble now = g_now;\n\t\t\tif (now > last_ncache_no_skip + 8.0) {\n\t\t\t\tncache_no_skip = 1;\n\t\t\t} else if (now < last_bs_restore + 0.5) {\n\t\t\t\tncache_no_skip = 1;\n\t\t\t} else if (now < last_su_restore + 0.5) {\n\t\t\t\tncache_no_skip = 1;\n\t\t\t} else if (now < last_copyrect + 0.5) {\n\t\t\t\tncache_no_skip = 1;\n\t\t\t}\n\t\t\tif (ncache_no_skip) {\n\t\t\t\tlast_ncache_no_skip = dnow();\n\t\t\t\tif (now > last_ncache_no_skip_long + 60.0) {\n\t\t\t\t\tncache_fac = 2.0;\n\t\t\t\t\tlast_ncache_no_skip_long = now;\n\t\t\t\t} else {\n\t\t\t\t\tncache_fac = 0.25;\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t} else {\n\t\t\tif (ncache_no_skip++ >= ncache_fac*nreg + 4) {\n\t\t\t\tncache_no_skip = 0;\n\t\t\t} else {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n#endif\n\n\tif (fast_tmpl) {\n\t\tsraRgnOffset(tmpl_y, 0, y);\n\t\ttmpl = tmpl_y;\n\t} else {\n\t\ttmpl = sraRgnCreateRect(0, y, dpy_x, y+1);\n\t}\n\n\tret = 1;\n\tfor (i=0; i<nreg; i++) {\n\t\t/* go back thru the history starting at most recent */\n\t\tn = (xdamage_ticker + nreg - i) % nreg;\n\t\treg = xdamage_regions[n];  \n\t\tif (reg == NULL) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (sraRgnEmpty(reg)) {\n\t\t\t/* checking for emptiness is very fast */\n\t\t\tcontinue;\n\t\t}\n\t\tsraRgnMakeEmpty(scanline);\n\t\tsraRgnOr(scanline, tmpl);\n\t\tif (sraRgnAnd(scanline, reg)) {\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fast_tmpl) {\n\t\tsraRgnOffset(tmpl_y, 0, -y);\n\t} else {\n\t\tsraRgnDestroy(tmpl);\n\t}\nif (0) fprintf(stderr, \"xdamage_hint_skip: %d -> %d\\n\", y, ret);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"scan_display: no main_fb!\\n\""
          ],
          "line": 3182
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <default8x16.h>\n#include \"userinput.h\"\n#include \"macosx.h\"\n#include \"screen.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"8to24.h\"\n#include \"win_utils.h\"\n#include \"xrandr.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nstatic int blackout_line_skip(int n, int x, int y, int rescan,\n    int *tile_count);\nstatic int blackout_line_cmpskip(int n, int x, int y, char *dst, char *src,\n    int w, int pixelsize);\nstatic int scan_display(int ystart, int rescan);\nstatic int xd_samples = 0, xd_misses = 0, xd_do_check = 0;\n\nstatic int scan_display(int ystart, int rescan) {\n\tchar *src, *dst;\n\tint pixelsize = bpp/8;\n\tint x, y, w, n;\n\tint tile_count = 0;\n\tint nodiffs = 0, diff_hint;\n\tint xd_check = 0, xd_freq = 1;\n\tstatic int xd_tck = 0;\n\n\ty = ystart;\n\n\tg_now = dnow();\n\n\tif (! main_fb) {\n\t\trfbLog(\"scan_display: no main_fb!\\n\");\n\t\treturn 0;\n\t}\n\n\tX_LOCK;\n\n\twhile (y < dpy_y) {\n\n\t\tif (use_xdamage) {\n\t\t\tXD_tot++;\n\t\t\txd_check = 0;\n\t\t\tif (xdamage_hint_skip(y)) {\n\t\t\t\tif (xd_do_check && dpy && use_xdamage == 1) {\n\t\t\t\t\txd_tck++;\n\t\t\t\t\txd_tck = xd_tck % xd_freq;\n\t\t\t\t\tif (xd_tck == 0) {\n\t\t\t\t\t\txd_check = 1;\n\t\t\t\t\t\txd_samples++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!xd_check) {\n\t\t\t\t\tXD_skip++;\n\t\t\t\t\ty += NSCAN;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (xd_do_check && 0) {\n\t\t\t\t\tfprintf(stderr, \"ns y=%d\\n\", y);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* grab the horizontal scanline from the display: */\n\n#ifndef NO_NCACHE\n/* XXX Y test */\nif (ncache > 0) {\n\tint gotone = 0;\n\tif (macosx_console) {\n\t\tif (macosx_checkevent(NULL)) {\n\t\t\tgotone = 1;\n\t\t}\n\t} else {\n#if !NO_X11\n\t\tXEvent ev;\n\t\tif (raw_fb_str) {\n\t\t\t;\n\t\t} else if (XEventsQueued(dpy, QueuedAlready) == 0) {\n\t\t\t;\t/* XXX Y resp */\n\t\t} else if (XCheckTypedEvent(dpy, MapNotify, &ev)) {\n\t\t\tgotone = 1;\n\t\t} else if (XCheckTypedEvent(dpy, UnmapNotify, &ev)) {\n\t\t\tgotone = 2;\n\t\t} else if (XCheckTypedEvent(dpy, CreateNotify, &ev)) {\n\t\t\tgotone = 3;\n\t\t} else if (XCheckTypedEvent(dpy, ConfigureNotify, &ev)) {\n\t\t\tgotone = 4;\n\t\t} else if (XCheckTypedEvent(dpy, VisibilityNotify, &ev)) {\n\t\t\tgotone = 5;\n\t\t}\n\t\tif (gotone) {\n\t\t\tXPutBackEvent(dpy, &ev);\n\t\t}\n#endif\n\t}\n\tif (gotone) {\n\t\tstatic int nomsg = 1;\n\t\tif (nomsg) {\n\t\t\tif (dnowx() > 20) {\n\t\t\t\tnomsg = 0;\n\t\t\t}\n\t\t} else {\nif (ncdb) fprintf(stderr, \"\\n*** SCAN_DISPLAY CHECK_NCACHE/%d *** %d rescan=%d\\n\", gotone, y, rescan);\n\t\t}\n\t\tX_UNLOCK;\n\t\tcheck_ncache(0, 1);\n\t\tX_LOCK;\n\t}\n}\n#endif\n\n\t\tXRANDR_SET_TRAP_RET(-1, \"scan_display-set\");\n\t\tcopy_image(scanline, 0, y, 0, 0);\n\t\tXRANDR_CHK_TRAP_RET(-1, \"scan_display-chk\");\n\n\t\t/* for better memory i/o try the whole line at once */\n\t\tsrc = scanline->data;\n\t\tdst = main_fb + y * main_bytes_per_line;\n\n\t\tif (! memcmp(dst, src, main_bytes_per_line)) {\n\t\t\t/* no changes anywhere in scan line */\n\t\t\tnodiffs = 1;\n\t\t\tif (! rescan) {\n\t\t\t\ty += NSCAN;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (xd_check) {\n\t\t\txd_misses++;\n\t\t}\n\n\t\tx = 0;\n\t\twhile (x < dpy_x) {\n\t\t\tn = (x/tile_x) + (y/tile_y) * ntiles_x;\n\t\t\tdiff_hint = 0;\n\n\t\t\tif (blackouts) {\n\t\t\t\tif (blackout_line_skip(n, x, y, rescan,\n\t\t\t\t    &tile_count)) {\n\t\t\t\t\tx += NSCAN;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (rescan) {\n\t\t\t\tif (nodiffs || tile_has_diff[n]) {\n\t\t\t\t\ttile_count += tile_has_diff[n];\n\t\t\t\t\tx += NSCAN;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else if (xdamage_tile_count &&\n\t\t\t    tile_has_xdamage_diff[n]) {\n\t\t\t\ttile_has_xdamage_diff[n] = 2;\n\t\t\t\tdiff_hint = 1;\n\t\t\t}\n\n\t\t\t/* set ptrs to correspond to the x offset: */\n\t\t\tsrc = scanline->data + x * pixelsize;\n\t\t\tdst = main_fb + y * main_bytes_per_line + x * pixelsize;\n\n\t\t\t/* compute the width of data to be compared: */\n\t\t\tif (x + NSCAN > dpy_x) {\n\t\t\t\tw = dpy_x - x;\n\t\t\t} else {\n\t\t\t\tw = NSCAN;\n\t\t\t}\n\n\t\t\tif (diff_hint || memcmp(dst, src, w * pixelsize)) {\n\t\t\t\t/* found a difference, record it: */\n\t\t\t\tif (! blackouts) {\n\t\t\t\t\ttile_has_diff[n] = 1;\n\t\t\t\t\ttile_count++;\t\t\n\t\t\t\t} else {\n\t\t\t\t\tif (blackout_line_cmpskip(n, x, y,\n\t\t\t\t\t    dst, src, w, pixelsize)) {\n\t\t\t\t\t\ttile_has_diff[n] = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttile_has_diff[n] = 1;\n\t\t\t\t\t\ttile_count++;\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tx += NSCAN;\n\t\t}\n\t\ty += NSCAN;\n\t}\n\n\tX_UNLOCK;\n\n\treturn tile_count;\n}"
  },
  {
    "function_name": "set_offset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/scan.c",
    "lines": "3149-3157",
    "snippet": "void set_offset(void) {\n\tWindow w;\n\tif (! subwin) {\n\t\treturn;\n\t}\n\tX_LOCK;\n\txtranslate(window, rootwin, 0, 0, &off_x, &off_y, &w, 0);\n\tX_UNLOCK;\n}",
    "includes": [
      "#include <default8x16.h>",
      "#include \"userinput.h\"",
      "#include \"macosx.h\"",
      "#include \"screen.h\"",
      "#include \"unixpw.h\"",
      "#include \"cleanup.h\"",
      "#include \"pointer.h\"",
      "#include \"screen.h\"",
      "#include \"8to24.h\"",
      "#include \"win_utils.h\"",
      "#include \"xrandr.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"xinerama.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void set_offset(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xtranslate",
          "args": [
            "window",
            "rootwin",
            "0",
            "0",
            "&off_x",
            "&off_y",
            "&w",
            "0"
          ],
          "line": 3155
        },
        "resolved": true,
        "details": {
          "function_name": "xtranslate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/win_utils.c",
          "lines": "142-173",
          "snippet": "Bool xtranslate(Window src, Window dst, int src_x, int src_y, int *dst_x,\n    int *dst_y, Window *child, int bequiet) {\n\tXErrorHandler old_handler = NULL;\n\tBool ok = False;\n\n\tRAWFB_RET(False)\n#if NO_X11\n\tnox11_exit(1);\n\tif (!src || !dst || !src_x || !src_y || !dst_x || !dst_y || !child || !bequiet) {}\n\tif (!old_handler || !ok) {}\n\treturn False;\n#else\n\n\ttrapped_xerror = 0;\n\told_handler = XSetErrorHandler(trap_xerror);\n\tif (XTranslateCoordinates(dpy, src, dst, src_x, src_y, dst_x,\n\t    dst_y, child)) {\n\t\tok = True;\n\t}\n\tif (trapped_xerror && trapped_xerror_event) {\n\t\tif (! quiet && ! bequiet) {\n\t\t\trfbLog(\"xtranslate: trapped XError: %s (0x%lx)\\n\",\n\t\t\t    xerror_string(trapped_xerror_event), src);\n\t\t}\n\t\tok = False;\n\t}\n\tXSetErrorHandler(old_handler);\n\ttrapped_xerror = 0;\n\t\n\treturn ok;\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"win_utils.h\"",
            "#include \"macosx.h\"",
            "#include \"xrandr.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"cleanup.h\"",
            "#include \"winattr_t.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win_utils.h\"\n#include \"macosx.h\"\n#include \"xrandr.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"cleanup.h\"\n#include \"winattr_t.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nBool xtranslate(Window src, Window dst, int src_x, int src_y, int *dst_x,\n    int *dst_y, Window *child, int bequiet) {\n\tXErrorHandler old_handler = NULL;\n\tBool ok = False;\n\n\tRAWFB_RET(False)\n#if NO_X11\n\tnox11_exit(1);\n\tif (!src || !dst || !src_x || !src_y || !dst_x || !dst_y || !child || !bequiet) {}\n\tif (!old_handler || !ok) {}\n\treturn False;\n#else\n\n\ttrapped_xerror = 0;\n\told_handler = XSetErrorHandler(trap_xerror);\n\tif (XTranslateCoordinates(dpy, src, dst, src_x, src_y, dst_x,\n\t    dst_y, child)) {\n\t\tok = True;\n\t}\n\tif (trapped_xerror && trapped_xerror_event) {\n\t\tif (! quiet && ! bequiet) {\n\t\t\trfbLog(\"xtranslate: trapped XError: %s (0x%lx)\\n\",\n\t\t\t    xerror_string(trapped_xerror_event), src);\n\t\t}\n\t\tok = False;\n\t}\n\tXSetErrorHandler(old_handler);\n\ttrapped_xerror = 0;\n\t\n\treturn ok;\n#endif\t/* NO_X11 */\n}"
        }
      }
    ],
    "contextual_snippet": "#include <default8x16.h>\n#include \"userinput.h\"\n#include \"macosx.h\"\n#include \"screen.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"8to24.h\"\n#include \"win_utils.h\"\n#include \"xrandr.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nvoid set_offset(void);\n\nvoid set_offset(void) {\n\tWindow w;\n\tif (! subwin) {\n\t\treturn;\n\t}\n\tX_LOCK;\n\txtranslate(window, rootwin, 0, 0, &off_x, &off_y, &w, 0);\n\tX_UNLOCK;\n}"
  },
  {
    "function_name": "blackout_line_cmpskip",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/scan.c",
    "lines": "3089-3144",
    "snippet": "static int blackout_line_cmpskip(int n, int x, int y, char *dst, char *src,\n    int w, int pixelsize) {\n\n\tint i, x1, y1, x2, y2, b, hit = 0;\n\tint beg = -1, end = -1; \n\n\tif (tile_blackout[n].cover == 0) {\n\t\treturn 0;\t/* 0 means do not skip it. */\n\t} else if (tile_blackout[n].cover == 2) {\n\t\treturn 1;\t/* 1 means skip it. */\n\t}\n\n\t/* tile has partial coverage: */\n\n\tfor (i=0; i < w * pixelsize; i++)  {\n\t\tif (*(dst+i) != *(src+i)) {\n\t\t\tbeg = i/pixelsize;\t/* beginning difference */\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (i = w * pixelsize - 1; i >= 0; i--)  {\n\t\tif (*(dst+i) != *(src+i)) {\n\t\t\tend = i/pixelsize;\t/* ending difference */\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (beg < 0 || end < 0) {\n\t\t/* problem finding range... */\n\t\treturn 0;\n\t}\n\n\t/* loop over blackout rectangles: */\n\tfor (b=0; b < tile_blackout[n].count; b++) {\n\t\t\n\t\t/* y in full display space: */\n\t\ty1 = tile_blackout[n].bo[b].y1;\n\t\ty2 = tile_blackout[n].bo[b].y2;\n\n\t\t/* x relative to tile origin: */\n\t\tx1 = tile_blackout[n].bo[b].x1 - x;\n\t\tx2 = tile_blackout[n].bo[b].x2 - x;\n\n\t\tif (y1 > y || y >= y2) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (x1 <= beg && end <= x2) {\n\t\t\thit = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (hit) {\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n}",
    "includes": [
      "#include <default8x16.h>",
      "#include \"userinput.h\"",
      "#include \"macosx.h\"",
      "#include \"screen.h\"",
      "#include \"unixpw.h\"",
      "#include \"cleanup.h\"",
      "#include \"pointer.h\"",
      "#include \"screen.h\"",
      "#include \"8to24.h\"",
      "#include \"win_utils.h\"",
      "#include \"xrandr.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"xinerama.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int blackout_line_cmpskip(int n, int x, int y, char *dst, char *src,\n    int w, int pixelsize);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <default8x16.h>\n#include \"userinput.h\"\n#include \"macosx.h\"\n#include \"screen.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"8to24.h\"\n#include \"win_utils.h\"\n#include \"xrandr.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nstatic int blackout_line_cmpskip(int n, int x, int y, char *dst, char *src,\n    int w, int pixelsize);\n\nstatic int blackout_line_cmpskip(int n, int x, int y, char *dst, char *src,\n    int w, int pixelsize) {\n\n\tint i, x1, y1, x2, y2, b, hit = 0;\n\tint beg = -1, end = -1; \n\n\tif (tile_blackout[n].cover == 0) {\n\t\treturn 0;\t/* 0 means do not skip it. */\n\t} else if (tile_blackout[n].cover == 2) {\n\t\treturn 1;\t/* 1 means skip it. */\n\t}\n\n\t/* tile has partial coverage: */\n\n\tfor (i=0; i < w * pixelsize; i++)  {\n\t\tif (*(dst+i) != *(src+i)) {\n\t\t\tbeg = i/pixelsize;\t/* beginning difference */\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (i = w * pixelsize - 1; i >= 0; i--)  {\n\t\tif (*(dst+i) != *(src+i)) {\n\t\t\tend = i/pixelsize;\t/* ending difference */\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (beg < 0 || end < 0) {\n\t\t/* problem finding range... */\n\t\treturn 0;\n\t}\n\n\t/* loop over blackout rectangles: */\n\tfor (b=0; b < tile_blackout[n].count; b++) {\n\t\t\n\t\t/* y in full display space: */\n\t\ty1 = tile_blackout[n].bo[b].y1;\n\t\ty2 = tile_blackout[n].bo[b].y2;\n\n\t\t/* x relative to tile origin: */\n\t\tx1 = tile_blackout[n].bo[b].x1 - x;\n\t\tx2 = tile_blackout[n].bo[b].x2 - x;\n\n\t\tif (y1 > y || y >= y2) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (x1 <= beg && end <= x2) {\n\t\t\thit = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (hit) {\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n}"
  },
  {
    "function_name": "blackout_line_skip",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/scan.c",
    "lines": "3045-3087",
    "snippet": "static int blackout_line_skip(int n, int x, int y, int rescan,\n    int *tile_count) {\n\t\n\tif (tile_blackout[n].cover == 2) {\n\t\ttile_has_diff[n] = 0;\n\t\treturn 1;\t/* skip it */\n\n\t} else if (tile_blackout[n].cover == 1) {\n\t\tint w, x1, y1, x2, y2, b, hit = 0;\n\t\tif (x + NSCAN > dpy_x) {\n\t\t\tw = dpy_x - x;\n\t\t} else {\n\t\t\tw = NSCAN;\n\t\t}\n\n\t\tfor (b=0; b < tile_blackout[n].count; b++) {\n\t\t\t\n\t\t\t/* n.b. these coords are in full display space: */\n\t\t\tx1 = tile_blackout[n].bo[b].x1;\n\t\t\tx2 = tile_blackout[n].bo[b].x2;\n\t\t\ty1 = tile_blackout[n].bo[b].y1;\n\t\t\ty2 = tile_blackout[n].bo[b].y2;\n\n\t\t\tif (x2 - x1 < w) {\n\t\t\t\t/* need to cover full width */\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (y1 <= y && y < y2) {\n\t\t\t\thit = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (hit) {\n\t\t\tif (! rescan) {\n\t\t\t\ttile_has_diff[n] = 0;\n\t\t\t} else {\n\t\t\t\t*tile_count += tile_has_diff[n];\n\t\t\t}\n\t\t\treturn 1;\t/* skip */\n\t\t}\n\t}\n\treturn 0;\t/* do not skip */\n}",
    "includes": [
      "#include <default8x16.h>",
      "#include \"userinput.h\"",
      "#include \"macosx.h\"",
      "#include \"screen.h\"",
      "#include \"unixpw.h\"",
      "#include \"cleanup.h\"",
      "#include \"pointer.h\"",
      "#include \"screen.h\"",
      "#include \"8to24.h\"",
      "#include \"win_utils.h\"",
      "#include \"xrandr.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"xinerama.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int blackout_line_skip(int n, int x, int y, int rescan,\n    int *tile_count);",
      "static int scan_display(int ystart, int rescan);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <default8x16.h>\n#include \"userinput.h\"\n#include \"macosx.h\"\n#include \"screen.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"8to24.h\"\n#include \"win_utils.h\"\n#include \"xrandr.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nstatic int blackout_line_skip(int n, int x, int y, int rescan,\n    int *tile_count);\nstatic int scan_display(int ystart, int rescan);\n\nstatic int blackout_line_skip(int n, int x, int y, int rescan,\n    int *tile_count) {\n\t\n\tif (tile_blackout[n].cover == 2) {\n\t\ttile_has_diff[n] = 0;\n\t\treturn 1;\t/* skip it */\n\n\t} else if (tile_blackout[n].cover == 1) {\n\t\tint w, x1, y1, x2, y2, b, hit = 0;\n\t\tif (x + NSCAN > dpy_x) {\n\t\t\tw = dpy_x - x;\n\t\t} else {\n\t\t\tw = NSCAN;\n\t\t}\n\n\t\tfor (b=0; b < tile_blackout[n].count; b++) {\n\t\t\t\n\t\t\t/* n.b. these coords are in full display space: */\n\t\t\tx1 = tile_blackout[n].bo[b].x1;\n\t\t\tx2 = tile_blackout[n].bo[b].x2;\n\t\t\ty1 = tile_blackout[n].bo[b].y1;\n\t\t\ty2 = tile_blackout[n].bo[b].y2;\n\n\t\t\tif (x2 - x1 < w) {\n\t\t\t\t/* need to cover full width */\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (y1 <= y && y < y2) {\n\t\t\t\thit = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (hit) {\n\t\t\tif (! rescan) {\n\t\t\t\ttile_has_diff[n] = 0;\n\t\t\t} else {\n\t\t\t\t*tile_count += tile_has_diff[n];\n\t\t\t}\n\t\t\treturn 1;\t/* skip */\n\t\t}\n\t}\n\treturn 0;\t/* do not skip */\n}"
  },
  {
    "function_name": "ping_clients",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/scan.c",
    "lines": "3017-3039",
    "snippet": "static void ping_clients(int tile_cnt) {\n\tstatic time_t last_send = 0;\n\ttime_t now = time(NULL);\n\n\tif (rfbMaxClientWait < 20000) {\n\t\trfbMaxClientWait = 20000;\n\t\trfbLog(\"reset rfbMaxClientWait to %d msec.\\n\",\n\t\t    rfbMaxClientWait);\n\t}\n\tif (tile_cnt > 0) {\n\t\tlast_send = now;\n\t} else if (tile_cnt < 0) {\n\t\t/* negative tile_cnt is -ping case */\n\t\tif (now >= last_send - tile_cnt) {\n\t\t\tmark_rect_as_modified(0, 0, 1, 1, 1);\n\t\t\tlast_send = now;\n\t\t}\n\t} else if (now - last_send > 5) {\n\t\t/* Send small heartbeat to client */\n\t\tmark_rect_as_modified(0, 0, 1, 1, 1);\n\t\tlast_send = now;\n\t}\n}",
    "includes": [
      "#include <default8x16.h>",
      "#include \"userinput.h\"",
      "#include \"macosx.h\"",
      "#include \"screen.h\"",
      "#include \"unixpw.h\"",
      "#include \"cleanup.h\"",
      "#include \"pointer.h\"",
      "#include \"screen.h\"",
      "#include \"8to24.h\"",
      "#include \"win_utils.h\"",
      "#include \"xrandr.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"xinerama.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void nap_set(int tile_cnt);",
      "static void nap_check(int tile_cnt);",
      "static void ping_clients(int tile_cnt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_rect_as_modified",
          "args": [
            "0",
            "0",
            "1",
            "1",
            "1"
          ],
          "line": 3036
        },
        "resolved": true,
        "details": {
          "function_name": "mark_rect_as_modified",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/scan.c",
          "lines": "1643-1682",
          "snippet": "void mark_rect_as_modified(int x1, int y1, int x2, int y2, int force) {\n\n\tif (damage_time != 0) {\n\t\t/*\n\t\t * This is not XDAMAGE, rather a hack for testing\n\t\t * where we allow the framebuffer to be corrupted for\n\t\t * damage_delay seconds.\n\t\t */\n\t\tint debug = 0;\n\t\tif (time(NULL) > damage_time + damage_delay) {\n\t\t\tif (! quiet) {\n\t\t\t\trfbLog(\"damaging turned off.\\n\");\n\t\t\t}\n\t\t\tdamage_time = 0;\n\t\t\tdamage_delay = 0;\n\t\t} else {\n\t\t\tif (debug) {\n\t\t\t\trfbLog(\"damaging viewer fb by not marking \"\n\t\t\t\t    \"rect: %d,%d,%d,%d\\n\", x1, y1, x2, y2);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n\n\n\tif (rfb_fb == main_fb || force) {\n\t\tmark_wrapper(x1, y1, x2, y2);\n\t\treturn;\n\t}\n\n\tif (cmap8to24) {\n\t\tbpp8to24(x1, y1, x2, y2);\n\t}\n\n\tif (scaling) {\n\t\tscale_and_mark_rect(x1, y1, x2, y2, 1);\n\t} else {\n\t\tmark_wrapper(x1, y1, x2, y2);\n\t}\n}",
          "includes": [
            "#include <default8x16.h>",
            "#include \"userinput.h\"",
            "#include \"macosx.h\"",
            "#include \"screen.h\"",
            "#include \"unixpw.h\"",
            "#include \"cleanup.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"8to24.h\"",
            "#include \"win_utils.h\"",
            "#include \"xrandr.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_rect_as_modified(int x1, int y1, int x2, int y2, int force);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <default8x16.h>\n#include \"userinput.h\"\n#include \"macosx.h\"\n#include \"screen.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"8to24.h\"\n#include \"win_utils.h\"\n#include \"xrandr.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nvoid mark_rect_as_modified(int x1, int y1, int x2, int y2, int force);\n\nvoid mark_rect_as_modified(int x1, int y1, int x2, int y2, int force) {\n\n\tif (damage_time != 0) {\n\t\t/*\n\t\t * This is not XDAMAGE, rather a hack for testing\n\t\t * where we allow the framebuffer to be corrupted for\n\t\t * damage_delay seconds.\n\t\t */\n\t\tint debug = 0;\n\t\tif (time(NULL) > damage_time + damage_delay) {\n\t\t\tif (! quiet) {\n\t\t\t\trfbLog(\"damaging turned off.\\n\");\n\t\t\t}\n\t\t\tdamage_time = 0;\n\t\t\tdamage_delay = 0;\n\t\t} else {\n\t\t\tif (debug) {\n\t\t\t\trfbLog(\"damaging viewer fb by not marking \"\n\t\t\t\t    \"rect: %d,%d,%d,%d\\n\", x1, y1, x2, y2);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n\n\n\tif (rfb_fb == main_fb || force) {\n\t\tmark_wrapper(x1, y1, x2, y2);\n\t\treturn;\n\t}\n\n\tif (cmap8to24) {\n\t\tbpp8to24(x1, y1, x2, y2);\n\t}\n\n\tif (scaling) {\n\t\tscale_and_mark_rect(x1, y1, x2, y2, 1);\n\t} else {\n\t\tmark_wrapper(x1, y1, x2, y2);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"reset rfbMaxClientWait to %d msec.\\n\"",
            "rfbMaxClientWait"
          ],
          "line": 3023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time",
          "args": [
            "NULL"
          ],
          "line": 3019
        },
        "resolved": true,
        "details": {
          "function_name": "csock_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "3270-3276",
          "snippet": "static void csock_timeout (int sig) {\n\trfbLog(\"sig: %d, csock_timeout.\\n\", sig);\n\tif (csock_timeout_sock >= 0) {\n\t\tclose(csock_timeout_sock);\n\t\tcsock_timeout_sock = -1;\n\t}\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int csock_timeout_sock = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nstatic int csock_timeout_sock = -1;\n\nstatic void csock_timeout (int sig) {\n\trfbLog(\"sig: %d, csock_timeout.\\n\", sig);\n\tif (csock_timeout_sock >= 0) {\n\t\tclose(csock_timeout_sock);\n\t\tcsock_timeout_sock = -1;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <default8x16.h>\n#include \"userinput.h\"\n#include \"macosx.h\"\n#include \"screen.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"8to24.h\"\n#include \"win_utils.h\"\n#include \"xrandr.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nstatic void nap_set(int tile_cnt);\nstatic void nap_check(int tile_cnt);\nstatic void ping_clients(int tile_cnt);\n\nstatic void ping_clients(int tile_cnt) {\n\tstatic time_t last_send = 0;\n\ttime_t now = time(NULL);\n\n\tif (rfbMaxClientWait < 20000) {\n\t\trfbMaxClientWait = 20000;\n\t\trfbLog(\"reset rfbMaxClientWait to %d msec.\\n\",\n\t\t    rfbMaxClientWait);\n\t}\n\tif (tile_cnt > 0) {\n\t\tlast_send = now;\n\t} else if (tile_cnt < 0) {\n\t\t/* negative tile_cnt is -ping case */\n\t\tif (now >= last_send - tile_cnt) {\n\t\t\tmark_rect_as_modified(0, 0, 1, 1, 1);\n\t\t\tlast_send = now;\n\t\t}\n\t} else if (now - last_send > 5) {\n\t\t/* Send small heartbeat to client */\n\t\tmark_rect_as_modified(0, 0, 1, 1, 1);\n\t\tlast_send = now;\n\t}\n}"
  },
  {
    "function_name": "nap_check",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/scan.c",
    "lines": "2954-3011",
    "snippet": "static void nap_check(int tile_cnt) {\n\ttime_t now;\n\n\tnap_diff_count += tile_cnt;\n\n\tif (! take_naps) {\n\t\treturn;\n\t}\n\n\tnow = time(NULL);\n\n\tif (screen_blank > 0) {\n\t\tint dt_ev, dt_fbu;\n\t\tstatic int ms = 0;\n\t\tif (ms == 0) {\n\t\t\tms = 2000;\n\t\t\tif (getenv(\"X11VNC_SB_FACTOR\")) {\n\t\t\t\tms = ms * atof(getenv(\"X11VNC_SB_FACTOR\"));\n\t\t\t}\n\t\t\tif (ms <= 0) {\n\t\t\t\tms = 2000;\n\t\t\t}\n\t\t}\n\n\t\t/* if no activity, pause here for a second or so. */\n\t\tdt_ev  = (int) (now - last_event);\n\t\tdt_fbu = (int) (now - last_fb_bytes_sent);\n\t\tif (dt_fbu > screen_blank) {\n\t\t\t/* sleep longer for no fb requests */\n\t\t\tif (debug_tiles > 1) {\n\t\t\t\tfprintf(stderr, \"screen blank sleep1: %d ms / 16, load: %s\\n\", 2 * ms, get_load());\n\t\t\t}\n\t\t\tnap_sleep(2 * ms, 16);\n\t\t\treturn;\n\t\t}\n\t\tif (dt_ev > screen_blank) {\n\t\t\tif (debug_tiles > 1) {\n\t\t\t\tfprintf(stderr, \"screen blank sleep2: %d ms / 8, load: %s\\n\", ms, get_load());\n\t\t\t}\n\t\t\tnap_sleep(ms, 8);\n\t\t\treturn;\n\t\t}\n\t}\n\tif (naptile && nap_ok && tile_cnt < naptile) {\n\t\tint ms = napfac * waitms;\n\t\tms = ms > napmax ? napmax : ms;\n\t\tif (now - last_input <= 3) {\n\t\t\tnap_ok = 0;\n\t\t} else if (now - last_local_input <= 3) {\n\t\t\tnap_ok = 0;\n\t\t} else {\n\t\t\tif (debug_tiles > 1) {\n\t\t\t\tfprintf(stderr, \"nap_check sleep: %d ms / 1, load: %s\\n\", ms, get_load());\n\t\t\t}\n\t\t\tnap_sleep(ms, 1);\n\t\t}\n\t}\n}",
    "includes": [
      "#include <default8x16.h>",
      "#include \"userinput.h\"",
      "#include \"macosx.h\"",
      "#include \"screen.h\"",
      "#include \"unixpw.h\"",
      "#include \"cleanup.h\"",
      "#include \"pointer.h\"",
      "#include \"screen.h\"",
      "#include \"8to24.h\"",
      "#include \"win_utils.h\"",
      "#include \"xrandr.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"xinerama.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void nap_set(int tile_cnt);",
      "static void nap_check(int tile_cnt);",
      "static void ping_clients(int tile_cnt);",
      "int nap_ok = 0;",
      "static int nap_diff_count = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nap_sleep",
          "args": [
            "ms",
            "1"
          ],
          "line": 3008
        },
        "resolved": true,
        "details": {
          "function_name": "nap_sleep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/scan.c",
          "lines": "2912-2928",
          "snippet": "void nap_sleep(int ms, int split) {\n\tint i, input = got_user_input;\n\tint gd = got_local_pointer_input;\n\n\tfor (i=0; i<split; i++) {\n\t\tusleep(ms * 1000 / split);\n\t\tif (! use_threads && i != split - 1) {\n\t\t\trfbPE(-1);\n\t\t}\n\t\tif (input != got_user_input) {\n\t\t\tbreak;\n\t\t}\n\t\tif (gd != got_local_pointer_input) {\n\t\t\tbreak;\n\t\t}\n\t}\n}",
          "includes": [
            "#include <default8x16.h>",
            "#include \"userinput.h\"",
            "#include \"macosx.h\"",
            "#include \"screen.h\"",
            "#include \"unixpw.h\"",
            "#include \"cleanup.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"8to24.h\"",
            "#include \"win_utils.h\"",
            "#include \"xrandr.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void nap_sleep(int ms, int split);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <default8x16.h>\n#include \"userinput.h\"\n#include \"macosx.h\"\n#include \"screen.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"8to24.h\"\n#include \"win_utils.h\"\n#include \"xrandr.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nvoid nap_sleep(int ms, int split);\n\nvoid nap_sleep(int ms, int split) {\n\tint i, input = got_user_input;\n\tint gd = got_local_pointer_input;\n\n\tfor (i=0; i<split; i++) {\n\t\tusleep(ms * 1000 / split);\n\t\tif (! use_threads && i != split - 1) {\n\t\t\trfbPE(-1);\n\t\t}\n\t\tif (input != got_user_input) {\n\t\t\tbreak;\n\t\t}\n\t\tif (gd != got_local_pointer_input) {\n\t\t\tbreak;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"nap_check sleep: %d ms / 1, load: %s\\n\"",
            "ms",
            "get_load()"
          ],
          "line": 3006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_load",
          "args": [],
          "line": 3006
        },
        "resolved": true,
        "details": {
          "function_name": "get_load",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/scan.c",
          "lines": "2930-2949",
          "snippet": "static char *get_load(void) {\n\tstatic char tmp[64];\n\tstatic int count = 0;\n\n\tif (count++ % 5 == 0) {\n\t\tstruct stat sb;\n\t\tmemset(tmp, 0, sizeof(tmp));\n\t\tif (stat(\"/proc/loadavg\", &sb) == 0) {\n\t\t\tint d = open(\"/proc/loadavg\", O_RDONLY);\n\t\t\tif (d >= 0) {\n\t\t\t\tread(d, tmp, 60);\n\t\t\t\tclose(d);\n\t\t\t}\n\t\t}\n\t\tif (tmp[0] == '\\0') {\n\t\t\tstrcat(tmp, \"unknown\");\n\t\t}\n\t}\n\treturn tmp;\n}",
          "includes": [
            "#include <default8x16.h>",
            "#include \"userinput.h\"",
            "#include \"macosx.h\"",
            "#include \"screen.h\"",
            "#include \"unixpw.h\"",
            "#include \"cleanup.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"8to24.h\"",
            "#include \"win_utils.h\"",
            "#include \"xrandr.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <default8x16.h>\n#include \"userinput.h\"\n#include \"macosx.h\"\n#include \"screen.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"8to24.h\"\n#include \"win_utils.h\"\n#include \"xrandr.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nstatic char *get_load(void) {\n\tstatic char tmp[64];\n\tstatic int count = 0;\n\n\tif (count++ % 5 == 0) {\n\t\tstruct stat sb;\n\t\tmemset(tmp, 0, sizeof(tmp));\n\t\tif (stat(\"/proc/loadavg\", &sb) == 0) {\n\t\t\tint d = open(\"/proc/loadavg\", O_RDONLY);\n\t\t\tif (d >= 0) {\n\t\t\t\tread(d, tmp, 60);\n\t\t\t\tclose(d);\n\t\t\t}\n\t\t}\n\t\tif (tmp[0] == '\\0') {\n\t\t\tstrcat(tmp, \"unknown\");\n\t\t}\n\t}\n\treturn tmp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"screen blank sleep2: %d ms / 8, load: %s\\n\"",
            "ms",
            "get_load()"
          ],
          "line": 2991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"screen blank sleep1: %d ms / 16, load: %s\\n\"",
            "2 * ms",
            "get_load()"
          ],
          "line": 2984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atof",
          "args": [
            "getenv(\"X11VNC_SB_FACTOR\")"
          ],
          "line": 2971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"X11VNC_SB_FACTOR\""
          ],
          "line": 2971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"X11VNC_SB_FACTOR\""
          ],
          "line": 2970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time",
          "args": [
            "NULL"
          ],
          "line": 2963
        },
        "resolved": true,
        "details": {
          "function_name": "csock_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "3270-3276",
          "snippet": "static void csock_timeout (int sig) {\n\trfbLog(\"sig: %d, csock_timeout.\\n\", sig);\n\tif (csock_timeout_sock >= 0) {\n\t\tclose(csock_timeout_sock);\n\t\tcsock_timeout_sock = -1;\n\t}\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int csock_timeout_sock = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nstatic int csock_timeout_sock = -1;\n\nstatic void csock_timeout (int sig) {\n\trfbLog(\"sig: %d, csock_timeout.\\n\", sig);\n\tif (csock_timeout_sock >= 0) {\n\t\tclose(csock_timeout_sock);\n\t\tcsock_timeout_sock = -1;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <default8x16.h>\n#include \"userinput.h\"\n#include \"macosx.h\"\n#include \"screen.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"8to24.h\"\n#include \"win_utils.h\"\n#include \"xrandr.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nstatic void nap_set(int tile_cnt);\nstatic void nap_check(int tile_cnt);\nstatic void ping_clients(int tile_cnt);\nint nap_ok = 0;\nstatic int nap_diff_count = 0;\n\nstatic void nap_check(int tile_cnt) {\n\ttime_t now;\n\n\tnap_diff_count += tile_cnt;\n\n\tif (! take_naps) {\n\t\treturn;\n\t}\n\n\tnow = time(NULL);\n\n\tif (screen_blank > 0) {\n\t\tint dt_ev, dt_fbu;\n\t\tstatic int ms = 0;\n\t\tif (ms == 0) {\n\t\t\tms = 2000;\n\t\t\tif (getenv(\"X11VNC_SB_FACTOR\")) {\n\t\t\t\tms = ms * atof(getenv(\"X11VNC_SB_FACTOR\"));\n\t\t\t}\n\t\t\tif (ms <= 0) {\n\t\t\t\tms = 2000;\n\t\t\t}\n\t\t}\n\n\t\t/* if no activity, pause here for a second or so. */\n\t\tdt_ev  = (int) (now - last_event);\n\t\tdt_fbu = (int) (now - last_fb_bytes_sent);\n\t\tif (dt_fbu > screen_blank) {\n\t\t\t/* sleep longer for no fb requests */\n\t\t\tif (debug_tiles > 1) {\n\t\t\t\tfprintf(stderr, \"screen blank sleep1: %d ms / 16, load: %s\\n\", 2 * ms, get_load());\n\t\t\t}\n\t\t\tnap_sleep(2 * ms, 16);\n\t\t\treturn;\n\t\t}\n\t\tif (dt_ev > screen_blank) {\n\t\t\tif (debug_tiles > 1) {\n\t\t\t\tfprintf(stderr, \"screen blank sleep2: %d ms / 8, load: %s\\n\", ms, get_load());\n\t\t\t}\n\t\t\tnap_sleep(ms, 8);\n\t\t\treturn;\n\t\t}\n\t}\n\tif (naptile && nap_ok && tile_cnt < naptile) {\n\t\tint ms = napfac * waitms;\n\t\tms = ms > napmax ? napmax : ms;\n\t\tif (now - last_input <= 3) {\n\t\t\tnap_ok = 0;\n\t\t} else if (now - last_local_input <= 3) {\n\t\t\tnap_ok = 0;\n\t\t} else {\n\t\t\tif (debug_tiles > 1) {\n\t\t\t\tfprintf(stderr, \"nap_check sleep: %d ms / 1, load: %s\\n\", ms, get_load());\n\t\t\t}\n\t\t\tnap_sleep(ms, 1);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "get_load",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/scan.c",
    "lines": "2930-2949",
    "snippet": "static char *get_load(void) {\n\tstatic char tmp[64];\n\tstatic int count = 0;\n\n\tif (count++ % 5 == 0) {\n\t\tstruct stat sb;\n\t\tmemset(tmp, 0, sizeof(tmp));\n\t\tif (stat(\"/proc/loadavg\", &sb) == 0) {\n\t\t\tint d = open(\"/proc/loadavg\", O_RDONLY);\n\t\t\tif (d >= 0) {\n\t\t\t\tread(d, tmp, 60);\n\t\t\t\tclose(d);\n\t\t\t}\n\t\t}\n\t\tif (tmp[0] == '\\0') {\n\t\t\tstrcat(tmp, \"unknown\");\n\t\t}\n\t}\n\treturn tmp;\n}",
    "includes": [
      "#include <default8x16.h>",
      "#include \"userinput.h\"",
      "#include \"macosx.h\"",
      "#include \"screen.h\"",
      "#include \"unixpw.h\"",
      "#include \"cleanup.h\"",
      "#include \"pointer.h\"",
      "#include \"screen.h\"",
      "#include \"8to24.h\"",
      "#include \"win_utils.h\"",
      "#include \"xrandr.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"xinerama.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "tmp",
            "\"unknown\""
          ],
          "line": 2945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "d"
          ],
          "line": 2941
        },
        "resolved": true,
        "details": {
          "function_name": "close_alarm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
          "lines": "666-672",
          "snippet": "static void close_alarm (int sig) {\n\tif (slave_fd >= 0) {\n\t\tclose(slave_fd);\n\t}\n\talarm_fired = 1;\n\tif (0) sig = 0;\t/* compiler warning */\n}",
          "includes": [
            "#include <sys/stropts.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <shadow.h>",
            "#include \"default8x16.h\"",
            "#include \"rates.h\"",
            "#include \"cursor.h\"",
            "#include \"sslhelper.h\"",
            "#include \"connections.h\"",
            "#include \"user.h\"",
            "#include \"connections.h\"",
            "#include \"xinerama.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int slave_fd = -1, alarm_fired = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nstatic int slave_fd = -1, alarm_fired = 0;\n\nstatic void close_alarm (int sig) {\n\tif (slave_fd >= 0) {\n\t\tclose(slave_fd);\n\t}\n\talarm_fired = 1;\n\tif (0) sig = 0;\t/* compiler warning */\n}"
        }
      },
      {
        "call_info": {
          "callee": "read",
          "args": [
            "d",
            "tmp",
            "60"
          ],
          "line": 2940
        },
        "resolved": true,
        "details": {
          "function_name": "read_exact",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "1292-1317",
          "snippet": "static int read_exact(int sock, char *buf, int len) {\n\tint n, fail = 0;\n\tif (sock < 0) {\n\t\treturn 0;\n\t}\n\twhile (len > 0) {\n\t\tn = read(sock, buf, len);\n\t\tif (n > 0) {\n\t\t\tbuf += n;\n\t\t\tlen -= n;\n\t\t} else if (n == 0) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t} else if (n < 0 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n\t\t\tusleep(10*1000);\n\t\t} else if (n < 0 && errno != EINTR) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fail) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void ssl_helper_pid(pid_t pid, int sock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid ssl_helper_pid(pid_t pid, int sock);\n\nstatic int read_exact(int sock, char *buf, int len) {\n\tint n, fail = 0;\n\tif (sock < 0) {\n\t\treturn 0;\n\t}\n\twhile (len > 0) {\n\t\tn = read(sock, buf, len);\n\t\tif (n > 0) {\n\t\t\tbuf += n;\n\t\t\tlen -= n;\n\t\t} else if (n == 0) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t} else if (n < 0 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n\t\t\tusleep(10*1000);\n\t\t} else if (n < 0 && errno != EINTR) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fail) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "\"/proc/loadavg\"",
            "O_RDONLY"
          ],
          "line": 2938
        },
        "resolved": true,
        "details": {
          "function_name": "accept_openssl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "3302-4284",
          "snippet": "void accept_openssl(int mode, int presock) {\n\tint sock = -1, listen = -1, cport, csock, vsock;\t\n\tint peerport = 0;\n\tint status, n, i, db = 0;\n\tstruct sockaddr_in addr;\n#ifdef __hpux\n\tint addrlen = sizeof(addr);\n#else\n\tsocklen_t addrlen = sizeof(addr);\n#endif\n\trfbClientPtr client;\n\tpid_t pid;\n\tchar uniq[] = \"_evilrats_\";\n\tchar cookie[256], rcookie[256], *name = NULL;\n\tint vencrypt_sel = 0;\n\tint anontls_sel = 0;\n\tchar *ipv6_name = NULL;\n\tstatic double last_https = 0.0;\n\tstatic char last_get[256];\n\tstatic int first = 1;\n\tunsigned char *rb;\n\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL  \n\tif (enc_str == NULL || strcmp(enc_str, \"none\")) {\n\t\tbadnews(\"0 accept_openssl\");\n\t}\n#endif\n\n\topenssl_last_helper_pid = 0;\n\n\t/* zero buffers for use below. */\n\tfor (i=0; i<256; i++) {\n\t\tif (first) {\n\t\t\tlast_get[i] = '\\0';\n\t\t}\n\t\tcookie[i]  = '\\0';\n\t\trcookie[i] = '\\0';\n\t}\n\tfirst = 0;\n\n\tif (getenv(\"ACCEPT_OPENSSL_DEBUG\")) {\n\t\tdb = atoi(getenv(\"ACCEPT_OPENSSL_DEBUG\"));\n\t}\n\n\t/* do INETD, VNC, or HTTPS cases (result is client socket or pipe) */\n\tif (mode == OPENSSL_INETD) {\n\t\tssl_initialized = 1;\n\n\t} else if (mode == OPENSSL_VNC) {\n\t\tsock = accept(openssl_sock, (struct sockaddr *)&addr, &addrlen);\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: accept connection failed\\n\");\n\t\t\trfbLogPerror(\"accept\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tlisten = openssl_sock;\n\n\t} else if (mode == OPENSSL_VNC6 || mode == OPENSSL_HTTPS6) {\n#if X11VNC_IPV6\n\t\tstruct sockaddr_in6 a6;\n\t\tsocklen_t a6len = sizeof(a6);\n\t\tint fd = (mode == OPENSSL_VNC6 ? openssl_sock6 : https_sock6); \n\n\t\tsock = accept(fd, (struct sockaddr *)&a6, &a6len);\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: accept connection failed\\n\");\n\t\t\trfbLogPerror(\"accept\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tipv6_name = ipv6_getipaddr((struct sockaddr *)&a6, a6len);\n\t\tif (!ipv6_name) ipv6_name = strdup(\"unknown\");\n\t\tlisten = fd;\n#endif\n\t} else if (mode == OPENSSL_REVERSE) {\n\t\tsock = presock;\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: connection failed\\n\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tif (getenv(\"OPENSSL_REVERSE_DEBUG\")) fprintf(stderr, \"OPENSSL_REVERSE: ipv6_client_ip_str: %s\\n\", ipv6_client_ip_str);\n\t\tif (ipv6_client_ip_str != NULL) {\n\t\t\tipv6_name = strdup(ipv6_client_ip_str);\n\t\t}\n\t\tlisten = -1;\n\n\t} else if (mode == OPENSSL_HTTPS) {\n\t\tsock = accept(https_sock, (struct sockaddr *)&addr, &addrlen);\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: accept connection failed\\n\");\n\t\t\trfbLogPerror(\"accept\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tlisten = https_sock;\n\t}\n\tif (db) fprintf(stderr, \"SSL: accept_openssl: sock: %d\\n\", sock);\n\n\tif (openssl_last_ip) {\n\t\tfree(openssl_last_ip);\n\t\topenssl_last_ip = NULL;\n\t}\n\tif (mode == OPENSSL_INETD) {\n\t\topenssl_last_ip = get_remote_host(fileno(stdin));\n\t} else if (mode == OPENSSL_VNC6 || mode == OPENSSL_HTTPS6) {\n\t\topenssl_last_ip = ipv6_name;\n\t} else if (mode == OPENSSL_REVERSE && ipv6_name != NULL) {\n\t\topenssl_last_ip = ipv6_name;\n\t} else {\n\t\topenssl_last_ip = get_remote_host(sock);\n\t}\n\n\tif (!check_ssl_access(openssl_last_ip)) {\n\t\trfbLog(\"SSL: accept_openssl: denying client %s\\n\", openssl_last_ip);\n\t\trfbLog(\"SSL: accept_openssl: does not match -allow or other reason.\\n\");\n\t\tclose(sock);\n\t\tsock = -1;\n\t\tif (ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\n\t/* now make a listening socket for child to connect back to us by: */\n\n\tcport = find_free_port(20000, 22000);\n\tif (! cport && ipv6_listen) {\n\t\trfbLog(\"SSL: accept_openssl: seeking IPv6 port.\\n\");\n\t\tcport = find_free_port6(20000, 22000);\n\t\trfbLog(\"SSL: accept_openssl: IPv6 port: %d\\n\", cport);\n\t}\n\tif (! cport) {\n\t\trfbLog(\"SSL: accept_openssl: could not find open port.\\n\");\n\t\tclose(sock);\n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\tif (db) fprintf(stderr, \"accept_openssl: cport: %d\\n\", cport);\n\n\tcsock = listen_tcp(cport, htonl(INADDR_LOOPBACK), 1);\n\n\tif (csock < 0) {\n\t\trfbLog(\"SSL: accept_openssl: could not listen on port %d.\\n\",\n\t\t    cport);\n\t\tclose(sock);\n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\tif (db) fprintf(stderr, \"accept_openssl: csock: %d\\n\", csock);\n\n\tfflush(stderr);\n\n\t/*\n\t * make a simple cookie to id the child socket, not foolproof\n\t * but hard to guess exactly (just worrying about local lusers\n\t * here, since we use INADDR_LOOPBACK).\n\t */\n\trb = (unsigned char *) calloc(6, 1);\n#if LIBVNCSERVER_HAVE_LIBSSL || HAVE_LIBSSL \n\tRAND_bytes(rb, 6);\n#endif\n\tsprintf(cookie, \"RB=%d%d%d%d%d%d/%f%f/%p\",\n\t    rb[0], rb[1], rb[2], rb[3], rb[4], rb[5],\n            dnow() - x11vnc_start, x11vnc_start, (void *)rb);\n\n\tif (mode == OPENSSL_VNC6) {\n\t\tname = strdup(ipv6_name);\n\t\tpeerport = get_remote_port(sock);\n\t} else if (mode == OPENSSL_REVERSE && ipv6_name != NULL) {\n\t\tname = strdup(ipv6_name);\n\t\tpeerport = get_remote_port(sock);\n\t} else if (mode != OPENSSL_INETD) {\n\t\tname = get_remote_host(sock);\n\t\tpeerport = get_remote_port(sock);\n\t} else {\n\t\topenssl_last_ip = get_remote_host(fileno(stdin));\n\t\tpeerport = get_remote_port(fileno(stdin));\n\t\tif (openssl_last_ip) {\n\t\t\tname = strdup(openssl_last_ip);\n\t\t} else {\n\t\t\tname = strdup(\"unknown\");\n\t\t}\n\t}\n\tif (name) {\n\t\tif (mode == OPENSSL_INETD) {\n\t\t\trfbLog(\"SSL: (inetd) spawning helper process \"\n\t\t\t    \"to handle: %s:%d\\n\", name, peerport);\n\t\t} else {\n\t\t\trfbLog(\"SSL: spawning helper process to handle: \"\n\t\t\t    \"%s:%d\\n\", name, peerport);\n\t\t}\n\t\tfree(name);\n\t\tname = NULL;\n\t}\n\n\tif (certret) {\n\t\tfree(certret);\n\t}\n\tif (certret_str) {\n\t\tfree(certret_str);\n\t\tcertret_str = NULL;\n\t}\n\tcertret = strdup(\"/tmp/x11vnc-certret.XXXXXX\");\n\tomode = umask(077);\n\tcertret_fd = mkstemp(certret);\n\tumask(omode);\n\tif (certret_fd < 0) {\n\t\tfree(certret);\n\t\tcertret = NULL;\n\t\tcertret_fd = -1;\n\t}\n\n\tif (dhret) {\n\t\tfree(dhret);\n\t}\n\tif (dhret_str) {\n\t\tfree(dhret_str);\n\t\tdhret_str = NULL;\n\t}\n\tdhret = strdup(\"/tmp/x11vnc-dhret.XXXXXX\");\n\tomode = umask(077);\n\tdhret_fd = mkstemp(dhret);\n\tumask(omode);\n\tif (dhret_fd < 0) {\n\t\tfree(dhret);\n\t\tdhret = NULL;\n\t\tdhret_fd = -1;\n\t}\n\n\t/* now fork the child to handle the SSL: */\n\tpid = fork();\n\n\tif (pid > 0) {\n\t\trfbLog(\"SSL: helper for peerport %d is pid %d: \\n\",\n\t\t    peerport, (int) pid);\n\t}\n\n\tif (pid < 0) {\n\t\trfbLog(\"SSL: accept_openssl: could not fork.\\n\");\n\t\trfbLogPerror(\"fork\");\n\t\tclose(sock);\n\t\tclose(csock);\n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\n\t} else if (pid == 0) {\n\t\tint s_in, s_out, httpsock = -1;\n\t\tint vncsock;\n\t\tint i, have_httpd = 0;\n\t\tint f_in  = fileno(stdin);\n\t\tint f_out = fileno(stdout);\n\t\tint skip_vnc_tls = mode == OPENSSL_HTTPS ? 1 : 0;\n\n\t\tif (db) fprintf(stderr, \"helper pid in: %d %d %d %d\\n\", f_in, f_out, sock, listen);\n\n\t\t/* reset all handlers to default (no interrupted() calls) */\n\t\tunset_signals();\n\n\t\t/* close all non-essential fd's */\n\t\tfor (i=0; i<256; i++) {\n\t\t\tif (mode == OPENSSL_INETD) {\n\t\t\t\tif (i == f_in || i == f_out) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i == sock) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (i == 2) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tclose(i);\n\t\t}\n\n\t\t/*\n\t\t * sadly, we are a long lived child and so the large\n\t\t * framebuffer memory areas will soon differ from parent.\n\t\t * try to free as much as possible.\n\t\t */\n\t\tlose_ram();\n\n\t\t/* now connect back to parent socket: */\n\t\tvncsock = connect_tcp(\"127.0.0.1\", cport);\n\t\tif (vncsock < 0) {\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: could not connect\"\n\t\t\t    \" back to: %d\\n\", getpid(), cport);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 1 (no local vncsock)\\n\", getpid());\n\t\t\texit(1);\n\t\t}\n\t\tif (db) fprintf(stderr, \"vncsock %d\\n\", vncsock);\n\n\t\t/* try to initialize SSL with the remote client */\n\n\t\tif (mode == OPENSSL_INETD) {\n\t\t\ts_in  = fileno(stdin);\n\t\t\ts_out = fileno(stdout);\n\t\t} else {\n\t\t\ts_in = s_out = sock;\n\t\t}\n\n\t\tif (! ssl_init(s_in, s_out, skip_vnc_tls, last_https)) {\n\t\t\tclose(vncsock);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 2 (ssl_init failed)\\n\", getpid());\n\t\t\texit(1);\n\t\t}\n\n\t\tif (vencrypt_selected != 0) {\n\t\t\tchar *tbuf;\n\t\t\ttbuf = (char *) malloc(strlen(cookie) + 100);\n\t\t\tsprintf(tbuf, \"%s,VENCRYPT=%d,%s\", uniq, vencrypt_selected, cookie);\n\t\t\twrite(vncsock, tbuf, strlen(cookie));\n\t\t\tgoto wrote_cookie;\n\t\t} else if (anontls_selected != 0) {\n\t\t\tchar *tbuf;\n\t\t\ttbuf = (char *) malloc(strlen(cookie) + 100);\n\t\t\tsprintf(tbuf, \"%s,ANONTLS=%d,%s\", uniq, anontls_selected, cookie);\n\t\t\twrite(vncsock, tbuf, strlen(cookie));\n\t\t\tgoto wrote_cookie;\n\t\t}\n\n\t\t/*\n\t\t * things get messy below since we are trying to do\n\t\t * *both* VNC and Java applet httpd through the same\n\t\t * SSL socket.\n\t\t */\n\n\t\tif (! screen) {\n\t\t\tclose(vncsock);\n\t\t\texit(1);\n\t\t}\n\t\tif (screen->httpListenSock >= 0 && screen->httpPort > 0) {\n\t\t\thave_httpd = 1;\n\t\t} else if (ipv6_http_fd >= 0) {\n\t\t\thave_httpd = 1;\n\t\t} else if (screen->httpListenSock == -2) {\n\t\t\thave_httpd = 1;\n\t\t}\n\t\tif (mode == OPENSSL_HTTPS && ! have_httpd) {\n\t\t\trfbLog(\"SSL: accept_openssl[%d]: no httpd socket for \"\n\t\t\t    \"-https mode\\n\", getpid());\n\t\t\tclose(vncsock);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 3 (no httpd sock)\\n\", getpid());\n\t\t\texit(1);\n\t\t}\n\n\t\tif (have_httpd) {\n\t\t\tint n = 0, is_http = 0;\n\t\t\tint hport = screen->httpPort; \n\t\t\tchar *iface = NULL;\n\t\t\tchar *buf, *tbuf;\n\n\t\t\tbuf  = (char *) calloc((ABSIZE+1), 1);\n\t\t\ttbuf = (char *) calloc((2*ABSIZE+1), 1);\n\n\t\t\tif (mode == OPENSSL_HTTPS) {\n\t\t\t\t/*\n\t\t\t\t * for this mode we know it is HTTP traffic\n\t\t\t\t * so we skip trying to guess.\n\t\t\t\t */\n\t\t\t\tis_http = 1;\n\t\t\t\tn = 0;\n\t\t\t\tgoto connect_to_httpd;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Check if there is stuff to read from remote end\n\t\t\t * if so it is likely a GET or HEAD.\n\t\t\t */\n\t\t\tif (! is_ssl_readable(s_in, last_https, last_get,\n\t\t\t    mode)) {\n\t\t\t\tgoto write_cookie;\n\t\t\t}\n\t\n\t\t\t/* \n\t\t\t * read first 2 bytes to try to guess.  sadly,\n\t\t\t * the user is often pondering a \"non-verified\n\t\t\t * cert\" dialog for a long time before the GET\n\t\t\t * is ever sent.  So often we timeout here.\n\t\t\t */\n\n\t\t\tif (db) fprintf(stderr, \"watch_for_http_traffic\\n\");\n\n\t\t\tis_http = watch_for_http_traffic(buf, &n, s_in);\n\n\t\t\tif (is_http < 0 || is_http == 0) {\n\t\t\t\t/*\n\t\t\t\t * error or http not detected, fall back\n\t\t\t\t * to normal VNC socket.\n\t\t\t\t */\n\t\t\t\tif (db) fprintf(stderr, \"is_http err: %d n: %d\\n\", is_http, n);\n\t\t\t\twrite(vncsock, cookie, strlen(cookie));\n\t\t\t\tif (n > 0) {\n\t\t\t\t\twrite(vncsock, buf, n);\n\t\t\t\t}\n\t\t\t\tgoto wrote_cookie;\n\t\t\t}\n\n\t\t\tif (db) fprintf(stderr, \"is_http: %d n: %d\\n\",\n\t\t\t    is_http, n);\n\t\t\tif (db) fprintf(stderr, \"buf: '%s'\\n\", buf);\n\n\t\t\tif (strstr(buf, \"/request.https.vnc.connection\")) {\n\t\t\t\tchar reply[] = \"HTTP/1.0 200 OK\\r\\n\"\n\t\t\t\t    \"Content-Type: octet-stream\\r\\n\"\n\t\t\t\t    \"Connection: Keep-Alive\\r\\n\"\n\t\t\t\t    \"VNC-Server: x11vnc\\r\\n\"\n\t\t\t\t    \"Pragma: no-cache\\r\\n\\r\\n\";\n\t\t\t\t/*\n\t\t\t\t * special case proxy coming thru https\n\t\t\t\t * instead of a direct SSL connection.\n\t\t\t\t */\n\t\t\t\trfbLog(\"Handling VNC request via https GET. [%d]\\n\", getpid());\n\t\t\t\trfbLog(\"-- %s\\n\", buf);\n\n\t\t\t\tif (strstr(buf, \"/reverse.proxy\")) {\n\t\t\t\t\tchar *buf2;\n\t\t\t\t\tint n, ptr;\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL \n\t\t\t\t\twrite(s_out, reply, strlen(reply));\n#else\n\t\t\t\t\tSSL_write(ssl, reply, strlen(reply));\n#endif\n\t\t\t\t\n\t\t\t\t\tbuf2  = (char *) calloc((8192+1), 1);\n\t\t\t\t\tn = 0;\n\t\t\t\t\tptr = 0;\n\t\t\t\t\twhile (ptr < 8192) {\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL \n\t\t\t\t\t\tn = read(s_in, buf2 + ptr, 1);\n#else\n\t\t\t\t\t\tn = SSL_read(ssl, buf2 + ptr, 1);\n#endif\n\t\t\t\t\t\tif (n > 0) {\n\t\t\t\t\t\t\tptr += n;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (db) fprintf(stderr, \"buf2: '%s'\\n\", buf2);\n\n\t\t\t\t\t\tif (strstr(buf2, \"\\r\\n\\r\\n\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfree(buf2);\n\t\t\t\t}\n\t\t\t\tgoto write_cookie;\n\n\t\t\t} else if (strstr(buf, \"/check.https.proxy.connection\")) {\n\t\t\t\tchar reply[] = \"HTTP/1.0 200 OK\\r\\n\"\n\t\t\t\t    \"Connection: close\\r\\n\"\n\t\t\t\t    \"Content-Type: octet-stream\\r\\n\"\n\t\t\t\t    \"VNC-Server: x11vnc\\r\\n\"\n\t\t\t\t    \"Pragma: no-cache\\r\\n\\r\\n\";\n\n\t\t\t\trfbLog(\"Handling Check HTTPS request via https GET. [%d]\\n\", getpid());\n\t\t\t\trfbLog(\"-- %s\\n\", buf);\n\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL \n\t\t\t\twrite(s_out, reply, strlen(reply));\n#else\n\t\t\t\tSSL_write(ssl, reply, strlen(reply));\n\t\t\t\tSSL_shutdown(ssl);\n#endif\n\n\t\t\t\tstrcpy(tbuf, uniq);\n\t\t\t\tstrcat(tbuf, cookie);\n\t\t\t\twrite(vncsock, tbuf, strlen(tbuf));\n\t\t\t\tclose(vncsock);\n\n\t\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 4 (check.https.proxy.connection)\\n\", getpid());\n\t\t\t\texit(0);\n\t\t\t}\n\t\t\tconnect_to_httpd:\n\n\t\t\t/*\n\t\t\t * Here we go... no turning back.  we have to\n\t\t\t * send failure to parent and close socket to have\n\t\t\t * http processed at all in a timely fashion...\n\t\t\t */\n\n\t\t\t/* send the failure tag: */\n\t\t\tstrcpy(tbuf, uniq);\n\n\t\t\tif (https_port_redir < 0 || (strstr(buf, \"PORT=\") || strstr(buf, \"port=\"))) {\n\t\t\t\tchar *q = strstr(buf, \"Host:\");\n\t\t\t\tint fport = 443, match = 0;\n\t\t\t\tchar num[16];\n\n\t\t\t\tif (q && strstr(q, \"\\n\")) {\n\t\t\t\t    q += strlen(\"Host:\") + 1;\n\t\t\t\t    while (*q != '\\n') {\n\t\t\t\t\tint p;\n\t\t\t\t\tif (*q == ':' && sscanf(q, \":%d\", &p) == 1) {\n\t\t\t\t\t\tif (p > 0 && p < 65536) {\n\t\t\t\t\t\t\tfport = p;\n\t\t\t\t\t\t\tmatch = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tq++;\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t\tif (!match || !https_port_redir) {\n\t\t\t\t\tint p;\n\t\t\t\t\tif (sscanf(buf, \"PORT=%d,\", &p) == 1) {\n\t\t\t\t\t\tif (p > 0 && p < 65536) {\n\t\t\t\t\t\t\tfport = p;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (sscanf(buf, \"port=%d,\", &p) == 1) {\n\t\t\t\t\t\tif (p > 0 && p < 65536) {\n\t\t\t\t\t\t\tfport = p;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsprintf(num, \"HP=%d,\", fport);\n\t\t\t\tstrcat(tbuf, num);\n\t\t\t}\n\n\t\t\tif (strstr(buf, \"HTTP/\") != NULL)  {\n\t\t\t\tchar *q, *str;\n\t\t\t\t/*\n\t\t\t\t * Also send back the GET line for heuristics.\n\t\t\t\t * (last_https, get file).\n\t\t\t\t */\n\t\t\t\tstr = strdup(buf);\n\t\t\t\tq = strstr(str, \"HTTP/\");\n\t\t\t\tif (q != NULL) {\n\t\t\t\t\t*q = '\\0';\t\n\t\t\t\t\tstrcat(tbuf, str);\n\t\t\t\t}\n\t\t\t\tfree(str);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Also send the cookie to pad out the number of\n\t\t\t * bytes to more than the parent wants to read.\n\t\t\t * Since this is the failure case, it does not\n\t\t\t * matter that we send more than strlen(cookie).\n\t\t\t */\n\t\t\tstrcat(tbuf, cookie);\n\t\t\twrite(vncsock, tbuf, strlen(tbuf));\n\n\t\t\tusleep(150*1000);\n\t\t\tif (db) fprintf(stderr, \"close vncsock: %d\\n\", vncsock);\n\t\t\tclose(vncsock);\n\n\t\t\t/* now, finally, connect to the libvncserver httpd: */\n\t\t\tif (screen->listenInterface == htonl(INADDR_ANY) ||\n\t\t\t    screen->listenInterface == htonl(INADDR_NONE)) {\n\t\t\t\tiface = \"127.0.0.1\";\n\t\t\t} else {\n\t\t\t\tstruct in_addr in;\n\t\t\t\tin.s_addr = screen->listenInterface;\n\t\t\t\tiface = inet_ntoa(in);\n\t\t\t}\n\t\t\tif (iface == NULL || !strcmp(iface, \"\")) {\n\t\t\t\tiface = \"127.0.0.1\";\n\t\t\t}\n\t\t\tif (db) fprintf(stderr, \"iface: %s:%d\\n\", iface, hport);\n\t\t\tusleep(150*1000);\n\n\t\t\thttpsock = connect_tcp(iface, hport);\n\n\t\t\tif (httpsock < 0) {\n\t\t\t\t/* UGH, after all of that! */\n\t\t\t\trfbLog(\"Could not connect to httpd socket!\\n\");\n\t\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 5.\\n\", getpid());\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (db) fprintf(stderr, \"ssl_helper[%d]: httpsock: %d %d\\n\",\n\t\t\t    getpid(), httpsock, n);\n\n\t\t\t/*\n\t\t\t * send what we read to httpd, and then connect\n\t\t\t * the rest of the SSL session to it:\n\t\t\t */\n\t\t\tif (n > 0) {\n\t\t\t\tchar *s = getenv(\"X11VNC_EXTRA_HTTPS_PARAMS\");\n\t\t\t\tint did_extra = 0;\n\n\t\t\t\tif (db) fprintf(stderr, \"sending http buffer httpsock: %d n=%d\\n'%s'\\n\", httpsock, n, buf);\n\t\t\t\tif (s != NULL) {\n\t\t\t\t\tchar *q = strstr(buf, \" HTTP/\");\n\t\t\t\t\tif (q) {\n\t\t\t\t\t\tint m;\n\t\t\t\t\t\t*q = '\\0';\n\t\t\t\t\t\tm = strlen(buf);\n\t\t\t\t\t\twrite(httpsock, buf, m);\n\t\t\t\t\t\twrite(httpsock, s, strlen(s));\n\t\t\t\t\t\t*q = ' ';\n\t\t\t\t\t\twrite(httpsock, q, n-m);\n\t\t\t\t\t\tdid_extra = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!did_extra) {\n\t\t\t\t\twrite(httpsock, buf, n);\n\t\t\t\t}\n\t\t\t}\n\t\t\tssl_xfer(httpsock, s_in, s_out, is_http);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 6 (https ssl_xfer done)\\n\", getpid());\n\t\t\texit(0);\n\t\t}\n\n\t\t/*\n\t\t * ok, back from the above https mess, simply send the\n\t\t * cookie back to the parent (who will attach us to\n\t\t * libvncserver), and connect the rest of the SSL session\n\t\t * to it.\n\t\t */\n\t\twrite_cookie:\n\t\twrite(vncsock, cookie, strlen(cookie));\n\n\t\twrote_cookie:\n\t\tssl_xfer(vncsock, s_in, s_out, 0);\n\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 7 (ssl_xfer done)\\n\", getpid());\n\t\tif (0) usleep(50 * 1000);\n\t\texit(0);\n\t}\n\t/* parent here */\n\n\tif (mode != OPENSSL_INETD) {\n\t\tclose(sock);\n\t}\n\tif (db) fprintf(stderr, \"helper process is: %d\\n\", pid);\n\n\t/* accept connection from our child.  */\n\tsignal(SIGALRM, csock_timeout);\n\tcsock_timeout_sock = csock;\n\talarm(20);\n\n\tvsock = accept(csock, (struct sockaddr *)&addr, &addrlen);\n\n\talarm(0);\n\tsignal(SIGALRM, SIG_DFL);\n\tclose(csock);\n\n\n\tif (vsock < 0) {\n\t\trfbLog(\"SSL: accept_openssl: connection from ssl_helper[%d] FAILED.\\n\", pid);\n\t\trfbLogPerror(\"accept\");\n\n\t\tkill(pid, SIGTERM);\n\t\twaitpid(pid, &status, WNOHANG); \n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tif (certret_fd >= 0) {\n\t\t\tclose(certret_fd);\n\t\t\tcertret_fd = -1;\n\t\t}\n\t\tif (certret) {\n\t\t\tunlink(certret);\n\t\t}\n\t\tif (dhret_fd >= 0) {\n\t\t\tclose(dhret_fd);\n\t\t\tdhret_fd = -1;\n\t\t}\n\t\tif (dhret) {\n\t\t\tunlink(dhret);\n\t\t}\n\t\treturn;\n\t}\n\tif (db) fprintf(stderr, \"accept_openssl: vsock: %d\\n\", vsock);\n\n\tn = read(vsock, rcookie, strlen(cookie));\n\tif (n < 0 && errno != 0) {\n\t\trfbLogPerror(\"read\");\n\t}\n\n\tif (certret) {\n\t\tstruct stat sbuf;\n\t\tsbuf.st_size = 0;\n\t\tif (certret_fd >= 0 && stat(certret, &sbuf) == 0 && sbuf.st_size > 0) {\n\t\t\tcertret_str = (char *) calloc(sbuf.st_size+1, 1);\n\t\t\tread(certret_fd, certret_str, sbuf.st_size);\n\t\t\tclose(certret_fd);\n\t\t\tcertret_fd = -1;\n\t\t}\n\t\tif (certret_fd >= 0) {\n\t\t\tclose(certret_fd);\n\t\t\tcertret_fd = -1;\n\t\t}\n\t\tunlink(certret);\n\t\tif (certret_str && strstr(certret_str, \"NOCERT\") == certret_str) {\n\t\t\tfree(certret_str);\n\t\t\tcertret_str = NULL;\n\t\t}\n\t\tif (0 && certret_str) {\n\t\t\tfprintf(stderr, \"certret_str[%d]:\\n%s\\n\", (int) sbuf.st_size, certret_str);\n\t\t}\n\t}\n\n\tif (dhret) {\n\t\tstruct stat sbuf;\n\t\tsbuf.st_size = 0;\n\t\tif (dhret_fd >= 0 && stat(dhret, &sbuf) == 0 && sbuf.st_size > 0) {\n\t\t\tdhret_str = (char *) calloc(sbuf.st_size+1, 1);\n\t\t\tread(dhret_fd, dhret_str, sbuf.st_size);\n\t\t\tclose(dhret_fd);\n\t\t\tdhret_fd = -1;\n\t\t}\n\t\tif (dhret_fd >= 0) {\n\t\t\tclose(dhret_fd);\n\t\t\tdhret_fd = -1;\n\t\t}\n\t\tunlink(dhret);\n\t\tif (dhret_str && strstr(dhret_str, \"NOCERT\") == dhret_str) {\n\t\t\tfree(dhret_str);\n\t\t\tdhret_str = NULL;\n\t\t}\n\t\tif (dhret_str) {\n\t\t\tif (new_dh_params == NULL) {\n\t\t\t\tfprintf(stderr, \"dhret_str[%d]:\\n%s\\n\", (int) sbuf.st_size, dhret_str);\n\t\t\t\tnew_dh_params = strdup(dhret_str);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (0) {\n\t\tfprintf(stderr, \"rcookie: %s\\n\", rcookie);\n\t\tfprintf(stderr, \"cookie:  %s\\n\", cookie);\n\t}\n\n\tif (strstr(rcookie, uniq) == rcookie) {\n\t\tchar *q = strstr(rcookie, \"RB=\");\n\t\tif (q && strstr(cookie, q) == cookie) {\n\t\t\tvencrypt_sel = 0;\n\t\t\tanontls_sel = 0;\n\t\t\tq = strstr(rcookie, \"VENCRYPT=\");\n\t\t\tif (q && sscanf(q, \"VENCRYPT=%d,\", &vencrypt_sel) == 1) {\n\t\t\t\tif (vencrypt_sel != 0) {\n\t\t\t\t\trfbLog(\"SSL: VENCRYPT mode=%d accepted. helper[%d]\\n\", vencrypt_sel, pid);\n\t\t\t\t\tgoto accept_client;\n\t\t\t\t}\n\t\t\t}\n\t\t\tq = strstr(rcookie, \"ANONTLS=\");\n\t\t\tif (q && sscanf(q, \"ANONTLS=%d,\", &anontls_sel) == 1) {\n\t\t\t\tif (anontls_sel != 0) {\n\t\t\t\t\trfbLog(\"SSL: ANONTLS mode=%d accepted. helper[%d]\\n\", anontls_sel, pid);\n\t\t\t\t\tgoto accept_client;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (n != (int) strlen(cookie) || strncmp(cookie, rcookie, n)) {\n\t\trfbLog(\"SSL: accept_openssl: cookie from ssl_helper[%d] FAILED. %d\\n\", pid, n);\n\t\tif (db) fprintf(stderr, \"'%s'\\n'%s'\\n\", cookie, rcookie);\n\t\tclose(vsock);\n\n\t\tif (strstr(rcookie, uniq) == rcookie) {\n\t\t\tint i;\n\t\t\tdouble https_download_wait_time = 15.0;\n\n\t\t\tif (getenv(\"X11VNC_HTTPS_DOWNLOAD_WAIT_TIME\")) {\n\t\t\t\thttps_download_wait_time = atof(getenv(\"X11VNC_HTTPS_DOWNLOAD_WAIT_TIME\"));\n\t\t\t}\n\n\t\t\trfbLog(\"SSL: BUT WAIT! HTTPS for helper process[%d] succeeded. Good.\\n\", pid);\n\t\t\tif (mode != OPENSSL_HTTPS) {\n\t\t\t\tlast_https = dnow();\n\t\t\t\tfor (i=0; i<256; i++) {\n\t\t\t\t\tlast_get[i] = '\\0';\n\t\t\t\t}\n\t\t\t\tstrncpy(last_get, rcookie, 100);\n\t\t\t\tif (db) fprintf(stderr, \"last_get: '%s'\\n\", last_get);\n\t\t\t}\n\t\t\tif (rcookie && strstr(rcookie, \"VncViewer.class\")) {\n\t\t\t\trfbLog(\"\\n\");\n\t\t\t\trfbLog(\"helper[%d]:\\n\", pid);\n\t\t\t\trfbLog(\"***********************************************************\\n\");\n\t\t\t\trfbLog(\"SSL: WARNING CLIENT ASKED FOR NONEXISTENT 'VncViewer.class'\\n\");\n\t\t\t\trfbLog(\"SSL: USER NEEDS TO MAKE SURE THE JAVA PLUGIN IS INSTALLED\\n\");\n\t\t\t\trfbLog(\"SSL: AND WORKING PROPERLY (e.g. a test-java-plugin page.)\\n\");\n\t\t\t\trfbLog(\"SSL: AND/OR USER NEEDS TO **RESTART** HIS WEB BROWSER.\\n\");\n\t\t\t\trfbLog(\"SSL: SOMETIMES THE BROWSER 'REMEMBERS' FAILED APPLET DOWN-\\n\");\n\t\t\t\trfbLog(\"SSL: LOADS AND RESTARTING IT IS THE ONLY WAY TO FIX THINGS.\\n\");\n\t\t\t\trfbLog(\"***********************************************************\\n\");\n\t\t\t\trfbLog(\"\\n\");\n\t\t\t}\n\t\t\tssl_helper_pid(pid, -2);\n\n\t\t\tif (https_port_redir) {\n\t\t\t\tdouble start;\n\t\t\t\tint origport = screen->port;\n\t\t\t\tint useport = screen->port;\n\t\t\t\tint saw_httpsock = 0;\n\t\t\t\t/* to expand $PORT correctly in index.vnc */\n\t\t\t\tif (https_port_redir < 0) {\n\t\t\t\t\tchar *q = strstr(rcookie, \"HP=\");\n\t\t\t\t\tif (q) {\n\t\t\t\t\t\tint p;\n\t\t\t\t\t\tif (sscanf(q, \"HP=%d,\", &p) == 1) {\n\t\t\t\t\t\t\tuseport = p;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tuseport = https_port_redir;\n\t\t\t\t}\n\t\t\t\tscreen->port = useport;\n\t\t\t\tif (origport != useport) {\n\t\t\t\t\trfbLog(\"SSL: -httpsredir guess port: %d  helper[%d]\\n\", screen->port, pid);\n\t\t\t\t}\n\n\t\t\t\tstart = dnow();\n\t\t\t\twhile (dnow() < start + https_download_wait_time) {\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\trfbPE(10000);\n\t\t\t\t\tusleep(10000);\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\twaitpid(pid, &status, WNOHANG); \n\t\t\t\t\tif (kill(pid, 0) != 0) {\n\t\t\t\t\t\trfbLog(\"SSL: helper[%d] pid finished\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (0 && saw_httpsock && screen->httpSock < 0) {\n\t\t\t\t\t\t/* this check can kill the helper too soon. */\n\t\t\t\t\t\trfbLog(\"SSL: httpSock for helper[%d] went away\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trfbLog(\"SSL: guessing child helper[%d] https finished. dt=%.6f\\n\",\n\t\t\t\t    pid, dnow() - start);\n\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\n\t\t\t\tscreen->port = origport;\n\t\t\t\tssl_helper_pid(0, -2);\n\t\t\t\tif (mode == OPENSSL_INETD) {\n\t\t\t\t\tclean_up_exit(1);\n\t\t\t\t}\n\t\t\t} else if (mode == OPENSSL_INETD) {\n\t\t\t\tdouble start;\n\t\t\t\tint saw_httpsock = 0;\n\n\t\t\t\t/* to expand $PORT correctly in index.vnc */\n\t\t\t\tif (screen->port == 0) {\n\t\t\t\t\tint fd = fileno(stdin);\n\t\t\t\t\tif (getenv(\"X11VNC_INETD_PORT\")) {\n\t\t\t\t\t\t/* mutex */\n\t\t\t\t\t\tscreen->port = atoi(getenv(\n\t\t\t\t\t\t    \"X11VNC_INETD_PORT\"));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tint tport = get_local_port(fd);\n\t\t\t\t\t\tif (tport > 0) {\n\t\t\t\t\t\t\tscreen->port = tport;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trfbLog(\"SSL: screen->port %d for helper[%d]\\n\", screen->port, pid);\n\n\t\t\t\t/* kludge for https fetch via inetd */\n\t\t\t\tstart = dnow();\n\t\t\t\twhile (dnow() < start + https_download_wait_time) {\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\trfbPE(10000);\n\t\t\t\t\tusleep(10000);\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\twaitpid(pid, &status, WNOHANG); \n\t\t\t\t\tif (kill(pid, 0) != 0) {\n\t\t\t\t\t\trfbLog(\"SSL: helper[%d] pid finished\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (0 && saw_httpsock && screen->httpSock < 0) {\n\t\t\t\t\t\t/* this check can kill the helper too soon. */\n\t\t\t\t\t\trfbLog(\"SSL: httpSock for helper[%d] went away\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trfbLog(\"SSL: OPENSSL_INETD guessing \"\n\t\t\t\t    \"child helper[%d] https finished. dt=%.6f\\n\",\n\t\t\t\t    pid, dnow() - start);\n\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\n\t\t\t\tssl_helper_pid(0, -2);\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\t/* this will actually only get earlier https */\n\t\t\tssl_helper_pid(0, -2);\n\t\t\treturn;\n\t\t}\n\t\tkill(pid, SIGTERM);\n\t\twaitpid(pid, &status, WNOHANG); \n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\n\taccept_client:\n\n\tif (db) fprintf(stderr, \"accept_openssl: cookie good: %s\\n\", cookie);\n\n\trfbLog(\"SSL: handshake with helper process[%d] succeeded.\\n\", pid);\n\n\topenssl_last_helper_pid = pid;\n\tssl_helper_pid(pid, vsock);\n\n\tif (vnc_redirect) {\n\t\tvnc_redirect_sock = vsock;\n\t\topenssl_last_helper_pid = 0;\n\t\treturn;\n\t}\n\n\tclient = create_new_client(vsock, 0);\n\topenssl_last_helper_pid = 0;\n\n\tif (client) {\n\t\tint swt = 0;\n\t\tif (mode == OPENSSL_VNC6 && openssl_last_ip != NULL) {\n\t\t\tswt = 1;\n\t\t} else if (mode == OPENSSL_REVERSE && ipv6_name != NULL && openssl_last_ip != NULL) {\n\t\t\tswt = 1;\n\t\t}\n\t\tif (swt) {\n\t\t\tif (client->host) {\n\t\t\t\tfree(client->host);\n\t\t\t}\n\t\t\tclient->host = strdup(openssl_last_ip);\n\t\t}\n\t\tif (db) fprintf(stderr, \"accept_openssl: client %p\\n\", (void *) client);\n\t\tif (db) fprintf(stderr, \"accept_openssl: new_client %p\\n\", (void *) screen->newClientHook);\n\t\tif (db) fprintf(stderr, \"accept_openssl: new_client %p\\n\", (void *) new_client);\n\t\tif (mode == OPENSSL_INETD) {\n\t\t\tinetd_client = client;\n\t\t\tclient->clientGoneHook = client_gone;\n\t\t}\n\t\tif (openssl_last_ip &&\n\t\t    strpbrk(openssl_last_ip, \"0123456789\") == openssl_last_ip) {\n\t\t\tclient->host = strdup(openssl_last_ip);\n\t\t}\n\t\tif (vencrypt_sel != 0) {\n\t\t\tclient->protocolMajorVersion = 3;\n\t\t\tclient->protocolMinorVersion = 8;\n#if LIBVNCSERVER_HAVE_LIBSSL || HAVE_LIBSSL \n\t\t\tif (!finish_vencrypt_auth(client, vencrypt_sel)) {\n\t\t\t\trfbCloseClient(client);\n\t\t\t\tclient = NULL;\n\t\t\t}\n#else\n\t\t\tbadnews(\"3 accept_openssl\");\n#endif\n\t\t} else if (anontls_sel != 0) {\n\t\t\tclient->protocolMajorVersion = 3;\n\t\t\tclient->protocolMinorVersion = 8;\n\t\t\trfbAuthNewClient(client);\n\t\t}\n\t\tif (use_threads && client != NULL) {\n\t\t\trfbStartOnHoldClient(client);\n\t\t}\n\t\t/* try to get RFB proto done now. */\n\t\tprogress_client();\n\t} else {\n\t\trfbLog(\"SSL: accept_openssl: rfbNewClient failed.\\n\");\n\t\tclose(vsock);\n\n\t\tkill(pid, SIGTERM);\n\t\twaitpid(pid, &status, WNOHANG); \n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define HAVE_LIBSSL 0",
            "#define LIBVNCSERVER_HAVE_LIBSSL 0",
            "#define ABSIZE 16384",
            "#define OPENSSL_REVERSE 6",
            "#define OPENSSL_HTTPS6  5",
            "#define OPENSSL_HTTPS   4",
            "#define OPENSSL_VNC6    3",
            "#define OPENSSL_VNC     2",
            "#define OPENSSL_INETD   1"
          ],
          "globals_used": [
            "int openssl_sock = -1;",
            "int openssl_sock6 = -1;",
            "int https_sock = -1;",
            "int https_sock6 = -1;",
            "pid_t openssl_last_helper_pid = 0;",
            "char *openssl_last_ip = NULL;",
            "static char *certret = NULL;",
            "static int certret_fd = -1;",
            "static mode_t omode;",
            "char *certret_str = NULL;",
            "static char *dhret = NULL;",
            "static int dhret_fd = -1;",
            "char *dhret_str = NULL;",
            "char *new_dh_params = NULL;",
            "void raw_xfer(int csock, int s_in, int s_out);",
            "static char *get_input(char *tag, char **in);",
            "void ssl_helper_pid(pid_t pid, int sock);",
            "void accept_openssl(int mode, int presock);",
            "static void lose_ram(void);",
            "static int vencrypt_selected = 0;",
            "static int anontls_selected = 0;",
            "static int csock_timeout_sock = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\n#define HAVE_LIBSSL 0\n#define LIBVNCSERVER_HAVE_LIBSSL 0\n#define ABSIZE 16384\n#define OPENSSL_REVERSE 6\n#define OPENSSL_HTTPS6  5\n#define OPENSSL_HTTPS   4\n#define OPENSSL_VNC6    3\n#define OPENSSL_VNC     2\n#define OPENSSL_INETD   1\n\nint openssl_sock = -1;\nint openssl_sock6 = -1;\nint https_sock = -1;\nint https_sock6 = -1;\npid_t openssl_last_helper_pid = 0;\nchar *openssl_last_ip = NULL;\nstatic char *certret = NULL;\nstatic int certret_fd = -1;\nstatic mode_t omode;\nchar *certret_str = NULL;\nstatic char *dhret = NULL;\nstatic int dhret_fd = -1;\nchar *dhret_str = NULL;\nchar *new_dh_params = NULL;\nvoid raw_xfer(int csock, int s_in, int s_out);\nstatic char *get_input(char *tag, char **in);\nvoid ssl_helper_pid(pid_t pid, int sock);\nvoid accept_openssl(int mode, int presock);\nstatic void lose_ram(void);\nstatic int vencrypt_selected = 0;\nstatic int anontls_selected = 0;\nstatic int csock_timeout_sock = -1;\n\nvoid accept_openssl(int mode, int presock) {\n\tint sock = -1, listen = -1, cport, csock, vsock;\t\n\tint peerport = 0;\n\tint status, n, i, db = 0;\n\tstruct sockaddr_in addr;\n#ifdef __hpux\n\tint addrlen = sizeof(addr);\n#else\n\tsocklen_t addrlen = sizeof(addr);\n#endif\n\trfbClientPtr client;\n\tpid_t pid;\n\tchar uniq[] = \"_evilrats_\";\n\tchar cookie[256], rcookie[256], *name = NULL;\n\tint vencrypt_sel = 0;\n\tint anontls_sel = 0;\n\tchar *ipv6_name = NULL;\n\tstatic double last_https = 0.0;\n\tstatic char last_get[256];\n\tstatic int first = 1;\n\tunsigned char *rb;\n\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL  \n\tif (enc_str == NULL || strcmp(enc_str, \"none\")) {\n\t\tbadnews(\"0 accept_openssl\");\n\t}\n#endif\n\n\topenssl_last_helper_pid = 0;\n\n\t/* zero buffers for use below. */\n\tfor (i=0; i<256; i++) {\n\t\tif (first) {\n\t\t\tlast_get[i] = '\\0';\n\t\t}\n\t\tcookie[i]  = '\\0';\n\t\trcookie[i] = '\\0';\n\t}\n\tfirst = 0;\n\n\tif (getenv(\"ACCEPT_OPENSSL_DEBUG\")) {\n\t\tdb = atoi(getenv(\"ACCEPT_OPENSSL_DEBUG\"));\n\t}\n\n\t/* do INETD, VNC, or HTTPS cases (result is client socket or pipe) */\n\tif (mode == OPENSSL_INETD) {\n\t\tssl_initialized = 1;\n\n\t} else if (mode == OPENSSL_VNC) {\n\t\tsock = accept(openssl_sock, (struct sockaddr *)&addr, &addrlen);\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: accept connection failed\\n\");\n\t\t\trfbLogPerror(\"accept\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tlisten = openssl_sock;\n\n\t} else if (mode == OPENSSL_VNC6 || mode == OPENSSL_HTTPS6) {\n#if X11VNC_IPV6\n\t\tstruct sockaddr_in6 a6;\n\t\tsocklen_t a6len = sizeof(a6);\n\t\tint fd = (mode == OPENSSL_VNC6 ? openssl_sock6 : https_sock6); \n\n\t\tsock = accept(fd, (struct sockaddr *)&a6, &a6len);\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: accept connection failed\\n\");\n\t\t\trfbLogPerror(\"accept\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tipv6_name = ipv6_getipaddr((struct sockaddr *)&a6, a6len);\n\t\tif (!ipv6_name) ipv6_name = strdup(\"unknown\");\n\t\tlisten = fd;\n#endif\n\t} else if (mode == OPENSSL_REVERSE) {\n\t\tsock = presock;\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: connection failed\\n\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tif (getenv(\"OPENSSL_REVERSE_DEBUG\")) fprintf(stderr, \"OPENSSL_REVERSE: ipv6_client_ip_str: %s\\n\", ipv6_client_ip_str);\n\t\tif (ipv6_client_ip_str != NULL) {\n\t\t\tipv6_name = strdup(ipv6_client_ip_str);\n\t\t}\n\t\tlisten = -1;\n\n\t} else if (mode == OPENSSL_HTTPS) {\n\t\tsock = accept(https_sock, (struct sockaddr *)&addr, &addrlen);\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: accept connection failed\\n\");\n\t\t\trfbLogPerror(\"accept\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tlisten = https_sock;\n\t}\n\tif (db) fprintf(stderr, \"SSL: accept_openssl: sock: %d\\n\", sock);\n\n\tif (openssl_last_ip) {\n\t\tfree(openssl_last_ip);\n\t\topenssl_last_ip = NULL;\n\t}\n\tif (mode == OPENSSL_INETD) {\n\t\topenssl_last_ip = get_remote_host(fileno(stdin));\n\t} else if (mode == OPENSSL_VNC6 || mode == OPENSSL_HTTPS6) {\n\t\topenssl_last_ip = ipv6_name;\n\t} else if (mode == OPENSSL_REVERSE && ipv6_name != NULL) {\n\t\topenssl_last_ip = ipv6_name;\n\t} else {\n\t\topenssl_last_ip = get_remote_host(sock);\n\t}\n\n\tif (!check_ssl_access(openssl_last_ip)) {\n\t\trfbLog(\"SSL: accept_openssl: denying client %s\\n\", openssl_last_ip);\n\t\trfbLog(\"SSL: accept_openssl: does not match -allow or other reason.\\n\");\n\t\tclose(sock);\n\t\tsock = -1;\n\t\tif (ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\n\t/* now make a listening socket for child to connect back to us by: */\n\n\tcport = find_free_port(20000, 22000);\n\tif (! cport && ipv6_listen) {\n\t\trfbLog(\"SSL: accept_openssl: seeking IPv6 port.\\n\");\n\t\tcport = find_free_port6(20000, 22000);\n\t\trfbLog(\"SSL: accept_openssl: IPv6 port: %d\\n\", cport);\n\t}\n\tif (! cport) {\n\t\trfbLog(\"SSL: accept_openssl: could not find open port.\\n\");\n\t\tclose(sock);\n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\tif (db) fprintf(stderr, \"accept_openssl: cport: %d\\n\", cport);\n\n\tcsock = listen_tcp(cport, htonl(INADDR_LOOPBACK), 1);\n\n\tif (csock < 0) {\n\t\trfbLog(\"SSL: accept_openssl: could not listen on port %d.\\n\",\n\t\t    cport);\n\t\tclose(sock);\n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\tif (db) fprintf(stderr, \"accept_openssl: csock: %d\\n\", csock);\n\n\tfflush(stderr);\n\n\t/*\n\t * make a simple cookie to id the child socket, not foolproof\n\t * but hard to guess exactly (just worrying about local lusers\n\t * here, since we use INADDR_LOOPBACK).\n\t */\n\trb = (unsigned char *) calloc(6, 1);\n#if LIBVNCSERVER_HAVE_LIBSSL || HAVE_LIBSSL \n\tRAND_bytes(rb, 6);\n#endif\n\tsprintf(cookie, \"RB=%d%d%d%d%d%d/%f%f/%p\",\n\t    rb[0], rb[1], rb[2], rb[3], rb[4], rb[5],\n            dnow() - x11vnc_start, x11vnc_start, (void *)rb);\n\n\tif (mode == OPENSSL_VNC6) {\n\t\tname = strdup(ipv6_name);\n\t\tpeerport = get_remote_port(sock);\n\t} else if (mode == OPENSSL_REVERSE && ipv6_name != NULL) {\n\t\tname = strdup(ipv6_name);\n\t\tpeerport = get_remote_port(sock);\n\t} else if (mode != OPENSSL_INETD) {\n\t\tname = get_remote_host(sock);\n\t\tpeerport = get_remote_port(sock);\n\t} else {\n\t\topenssl_last_ip = get_remote_host(fileno(stdin));\n\t\tpeerport = get_remote_port(fileno(stdin));\n\t\tif (openssl_last_ip) {\n\t\t\tname = strdup(openssl_last_ip);\n\t\t} else {\n\t\t\tname = strdup(\"unknown\");\n\t\t}\n\t}\n\tif (name) {\n\t\tif (mode == OPENSSL_INETD) {\n\t\t\trfbLog(\"SSL: (inetd) spawning helper process \"\n\t\t\t    \"to handle: %s:%d\\n\", name, peerport);\n\t\t} else {\n\t\t\trfbLog(\"SSL: spawning helper process to handle: \"\n\t\t\t    \"%s:%d\\n\", name, peerport);\n\t\t}\n\t\tfree(name);\n\t\tname = NULL;\n\t}\n\n\tif (certret) {\n\t\tfree(certret);\n\t}\n\tif (certret_str) {\n\t\tfree(certret_str);\n\t\tcertret_str = NULL;\n\t}\n\tcertret = strdup(\"/tmp/x11vnc-certret.XXXXXX\");\n\tomode = umask(077);\n\tcertret_fd = mkstemp(certret);\n\tumask(omode);\n\tif (certret_fd < 0) {\n\t\tfree(certret);\n\t\tcertret = NULL;\n\t\tcertret_fd = -1;\n\t}\n\n\tif (dhret) {\n\t\tfree(dhret);\n\t}\n\tif (dhret_str) {\n\t\tfree(dhret_str);\n\t\tdhret_str = NULL;\n\t}\n\tdhret = strdup(\"/tmp/x11vnc-dhret.XXXXXX\");\n\tomode = umask(077);\n\tdhret_fd = mkstemp(dhret);\n\tumask(omode);\n\tif (dhret_fd < 0) {\n\t\tfree(dhret);\n\t\tdhret = NULL;\n\t\tdhret_fd = -1;\n\t}\n\n\t/* now fork the child to handle the SSL: */\n\tpid = fork();\n\n\tif (pid > 0) {\n\t\trfbLog(\"SSL: helper for peerport %d is pid %d: \\n\",\n\t\t    peerport, (int) pid);\n\t}\n\n\tif (pid < 0) {\n\t\trfbLog(\"SSL: accept_openssl: could not fork.\\n\");\n\t\trfbLogPerror(\"fork\");\n\t\tclose(sock);\n\t\tclose(csock);\n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\n\t} else if (pid == 0) {\n\t\tint s_in, s_out, httpsock = -1;\n\t\tint vncsock;\n\t\tint i, have_httpd = 0;\n\t\tint f_in  = fileno(stdin);\n\t\tint f_out = fileno(stdout);\n\t\tint skip_vnc_tls = mode == OPENSSL_HTTPS ? 1 : 0;\n\n\t\tif (db) fprintf(stderr, \"helper pid in: %d %d %d %d\\n\", f_in, f_out, sock, listen);\n\n\t\t/* reset all handlers to default (no interrupted() calls) */\n\t\tunset_signals();\n\n\t\t/* close all non-essential fd's */\n\t\tfor (i=0; i<256; i++) {\n\t\t\tif (mode == OPENSSL_INETD) {\n\t\t\t\tif (i == f_in || i == f_out) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i == sock) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (i == 2) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tclose(i);\n\t\t}\n\n\t\t/*\n\t\t * sadly, we are a long lived child and so the large\n\t\t * framebuffer memory areas will soon differ from parent.\n\t\t * try to free as much as possible.\n\t\t */\n\t\tlose_ram();\n\n\t\t/* now connect back to parent socket: */\n\t\tvncsock = connect_tcp(\"127.0.0.1\", cport);\n\t\tif (vncsock < 0) {\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: could not connect\"\n\t\t\t    \" back to: %d\\n\", getpid(), cport);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 1 (no local vncsock)\\n\", getpid());\n\t\t\texit(1);\n\t\t}\n\t\tif (db) fprintf(stderr, \"vncsock %d\\n\", vncsock);\n\n\t\t/* try to initialize SSL with the remote client */\n\n\t\tif (mode == OPENSSL_INETD) {\n\t\t\ts_in  = fileno(stdin);\n\t\t\ts_out = fileno(stdout);\n\t\t} else {\n\t\t\ts_in = s_out = sock;\n\t\t}\n\n\t\tif (! ssl_init(s_in, s_out, skip_vnc_tls, last_https)) {\n\t\t\tclose(vncsock);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 2 (ssl_init failed)\\n\", getpid());\n\t\t\texit(1);\n\t\t}\n\n\t\tif (vencrypt_selected != 0) {\n\t\t\tchar *tbuf;\n\t\t\ttbuf = (char *) malloc(strlen(cookie) + 100);\n\t\t\tsprintf(tbuf, \"%s,VENCRYPT=%d,%s\", uniq, vencrypt_selected, cookie);\n\t\t\twrite(vncsock, tbuf, strlen(cookie));\n\t\t\tgoto wrote_cookie;\n\t\t} else if (anontls_selected != 0) {\n\t\t\tchar *tbuf;\n\t\t\ttbuf = (char *) malloc(strlen(cookie) + 100);\n\t\t\tsprintf(tbuf, \"%s,ANONTLS=%d,%s\", uniq, anontls_selected, cookie);\n\t\t\twrite(vncsock, tbuf, strlen(cookie));\n\t\t\tgoto wrote_cookie;\n\t\t}\n\n\t\t/*\n\t\t * things get messy below since we are trying to do\n\t\t * *both* VNC and Java applet httpd through the same\n\t\t * SSL socket.\n\t\t */\n\n\t\tif (! screen) {\n\t\t\tclose(vncsock);\n\t\t\texit(1);\n\t\t}\n\t\tif (screen->httpListenSock >= 0 && screen->httpPort > 0) {\n\t\t\thave_httpd = 1;\n\t\t} else if (ipv6_http_fd >= 0) {\n\t\t\thave_httpd = 1;\n\t\t} else if (screen->httpListenSock == -2) {\n\t\t\thave_httpd = 1;\n\t\t}\n\t\tif (mode == OPENSSL_HTTPS && ! have_httpd) {\n\t\t\trfbLog(\"SSL: accept_openssl[%d]: no httpd socket for \"\n\t\t\t    \"-https mode\\n\", getpid());\n\t\t\tclose(vncsock);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 3 (no httpd sock)\\n\", getpid());\n\t\t\texit(1);\n\t\t}\n\n\t\tif (have_httpd) {\n\t\t\tint n = 0, is_http = 0;\n\t\t\tint hport = screen->httpPort; \n\t\t\tchar *iface = NULL;\n\t\t\tchar *buf, *tbuf;\n\n\t\t\tbuf  = (char *) calloc((ABSIZE+1), 1);\n\t\t\ttbuf = (char *) calloc((2*ABSIZE+1), 1);\n\n\t\t\tif (mode == OPENSSL_HTTPS) {\n\t\t\t\t/*\n\t\t\t\t * for this mode we know it is HTTP traffic\n\t\t\t\t * so we skip trying to guess.\n\t\t\t\t */\n\t\t\t\tis_http = 1;\n\t\t\t\tn = 0;\n\t\t\t\tgoto connect_to_httpd;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Check if there is stuff to read from remote end\n\t\t\t * if so it is likely a GET or HEAD.\n\t\t\t */\n\t\t\tif (! is_ssl_readable(s_in, last_https, last_get,\n\t\t\t    mode)) {\n\t\t\t\tgoto write_cookie;\n\t\t\t}\n\t\n\t\t\t/* \n\t\t\t * read first 2 bytes to try to guess.  sadly,\n\t\t\t * the user is often pondering a \"non-verified\n\t\t\t * cert\" dialog for a long time before the GET\n\t\t\t * is ever sent.  So often we timeout here.\n\t\t\t */\n\n\t\t\tif (db) fprintf(stderr, \"watch_for_http_traffic\\n\");\n\n\t\t\tis_http = watch_for_http_traffic(buf, &n, s_in);\n\n\t\t\tif (is_http < 0 || is_http == 0) {\n\t\t\t\t/*\n\t\t\t\t * error or http not detected, fall back\n\t\t\t\t * to normal VNC socket.\n\t\t\t\t */\n\t\t\t\tif (db) fprintf(stderr, \"is_http err: %d n: %d\\n\", is_http, n);\n\t\t\t\twrite(vncsock, cookie, strlen(cookie));\n\t\t\t\tif (n > 0) {\n\t\t\t\t\twrite(vncsock, buf, n);\n\t\t\t\t}\n\t\t\t\tgoto wrote_cookie;\n\t\t\t}\n\n\t\t\tif (db) fprintf(stderr, \"is_http: %d n: %d\\n\",\n\t\t\t    is_http, n);\n\t\t\tif (db) fprintf(stderr, \"buf: '%s'\\n\", buf);\n\n\t\t\tif (strstr(buf, \"/request.https.vnc.connection\")) {\n\t\t\t\tchar reply[] = \"HTTP/1.0 200 OK\\r\\n\"\n\t\t\t\t    \"Content-Type: octet-stream\\r\\n\"\n\t\t\t\t    \"Connection: Keep-Alive\\r\\n\"\n\t\t\t\t    \"VNC-Server: x11vnc\\r\\n\"\n\t\t\t\t    \"Pragma: no-cache\\r\\n\\r\\n\";\n\t\t\t\t/*\n\t\t\t\t * special case proxy coming thru https\n\t\t\t\t * instead of a direct SSL connection.\n\t\t\t\t */\n\t\t\t\trfbLog(\"Handling VNC request via https GET. [%d]\\n\", getpid());\n\t\t\t\trfbLog(\"-- %s\\n\", buf);\n\n\t\t\t\tif (strstr(buf, \"/reverse.proxy\")) {\n\t\t\t\t\tchar *buf2;\n\t\t\t\t\tint n, ptr;\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL \n\t\t\t\t\twrite(s_out, reply, strlen(reply));\n#else\n\t\t\t\t\tSSL_write(ssl, reply, strlen(reply));\n#endif\n\t\t\t\t\n\t\t\t\t\tbuf2  = (char *) calloc((8192+1), 1);\n\t\t\t\t\tn = 0;\n\t\t\t\t\tptr = 0;\n\t\t\t\t\twhile (ptr < 8192) {\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL \n\t\t\t\t\t\tn = read(s_in, buf2 + ptr, 1);\n#else\n\t\t\t\t\t\tn = SSL_read(ssl, buf2 + ptr, 1);\n#endif\n\t\t\t\t\t\tif (n > 0) {\n\t\t\t\t\t\t\tptr += n;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (db) fprintf(stderr, \"buf2: '%s'\\n\", buf2);\n\n\t\t\t\t\t\tif (strstr(buf2, \"\\r\\n\\r\\n\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfree(buf2);\n\t\t\t\t}\n\t\t\t\tgoto write_cookie;\n\n\t\t\t} else if (strstr(buf, \"/check.https.proxy.connection\")) {\n\t\t\t\tchar reply[] = \"HTTP/1.0 200 OK\\r\\n\"\n\t\t\t\t    \"Connection: close\\r\\n\"\n\t\t\t\t    \"Content-Type: octet-stream\\r\\n\"\n\t\t\t\t    \"VNC-Server: x11vnc\\r\\n\"\n\t\t\t\t    \"Pragma: no-cache\\r\\n\\r\\n\";\n\n\t\t\t\trfbLog(\"Handling Check HTTPS request via https GET. [%d]\\n\", getpid());\n\t\t\t\trfbLog(\"-- %s\\n\", buf);\n\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL \n\t\t\t\twrite(s_out, reply, strlen(reply));\n#else\n\t\t\t\tSSL_write(ssl, reply, strlen(reply));\n\t\t\t\tSSL_shutdown(ssl);\n#endif\n\n\t\t\t\tstrcpy(tbuf, uniq);\n\t\t\t\tstrcat(tbuf, cookie);\n\t\t\t\twrite(vncsock, tbuf, strlen(tbuf));\n\t\t\t\tclose(vncsock);\n\n\t\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 4 (check.https.proxy.connection)\\n\", getpid());\n\t\t\t\texit(0);\n\t\t\t}\n\t\t\tconnect_to_httpd:\n\n\t\t\t/*\n\t\t\t * Here we go... no turning back.  we have to\n\t\t\t * send failure to parent and close socket to have\n\t\t\t * http processed at all in a timely fashion...\n\t\t\t */\n\n\t\t\t/* send the failure tag: */\n\t\t\tstrcpy(tbuf, uniq);\n\n\t\t\tif (https_port_redir < 0 || (strstr(buf, \"PORT=\") || strstr(buf, \"port=\"))) {\n\t\t\t\tchar *q = strstr(buf, \"Host:\");\n\t\t\t\tint fport = 443, match = 0;\n\t\t\t\tchar num[16];\n\n\t\t\t\tif (q && strstr(q, \"\\n\")) {\n\t\t\t\t    q += strlen(\"Host:\") + 1;\n\t\t\t\t    while (*q != '\\n') {\n\t\t\t\t\tint p;\n\t\t\t\t\tif (*q == ':' && sscanf(q, \":%d\", &p) == 1) {\n\t\t\t\t\t\tif (p > 0 && p < 65536) {\n\t\t\t\t\t\t\tfport = p;\n\t\t\t\t\t\t\tmatch = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tq++;\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t\tif (!match || !https_port_redir) {\n\t\t\t\t\tint p;\n\t\t\t\t\tif (sscanf(buf, \"PORT=%d,\", &p) == 1) {\n\t\t\t\t\t\tif (p > 0 && p < 65536) {\n\t\t\t\t\t\t\tfport = p;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (sscanf(buf, \"port=%d,\", &p) == 1) {\n\t\t\t\t\t\tif (p > 0 && p < 65536) {\n\t\t\t\t\t\t\tfport = p;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsprintf(num, \"HP=%d,\", fport);\n\t\t\t\tstrcat(tbuf, num);\n\t\t\t}\n\n\t\t\tif (strstr(buf, \"HTTP/\") != NULL)  {\n\t\t\t\tchar *q, *str;\n\t\t\t\t/*\n\t\t\t\t * Also send back the GET line for heuristics.\n\t\t\t\t * (last_https, get file).\n\t\t\t\t */\n\t\t\t\tstr = strdup(buf);\n\t\t\t\tq = strstr(str, \"HTTP/\");\n\t\t\t\tif (q != NULL) {\n\t\t\t\t\t*q = '\\0';\t\n\t\t\t\t\tstrcat(tbuf, str);\n\t\t\t\t}\n\t\t\t\tfree(str);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Also send the cookie to pad out the number of\n\t\t\t * bytes to more than the parent wants to read.\n\t\t\t * Since this is the failure case, it does not\n\t\t\t * matter that we send more than strlen(cookie).\n\t\t\t */\n\t\t\tstrcat(tbuf, cookie);\n\t\t\twrite(vncsock, tbuf, strlen(tbuf));\n\n\t\t\tusleep(150*1000);\n\t\t\tif (db) fprintf(stderr, \"close vncsock: %d\\n\", vncsock);\n\t\t\tclose(vncsock);\n\n\t\t\t/* now, finally, connect to the libvncserver httpd: */\n\t\t\tif (screen->listenInterface == htonl(INADDR_ANY) ||\n\t\t\t    screen->listenInterface == htonl(INADDR_NONE)) {\n\t\t\t\tiface = \"127.0.0.1\";\n\t\t\t} else {\n\t\t\t\tstruct in_addr in;\n\t\t\t\tin.s_addr = screen->listenInterface;\n\t\t\t\tiface = inet_ntoa(in);\n\t\t\t}\n\t\t\tif (iface == NULL || !strcmp(iface, \"\")) {\n\t\t\t\tiface = \"127.0.0.1\";\n\t\t\t}\n\t\t\tif (db) fprintf(stderr, \"iface: %s:%d\\n\", iface, hport);\n\t\t\tusleep(150*1000);\n\n\t\t\thttpsock = connect_tcp(iface, hport);\n\n\t\t\tif (httpsock < 0) {\n\t\t\t\t/* UGH, after all of that! */\n\t\t\t\trfbLog(\"Could not connect to httpd socket!\\n\");\n\t\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 5.\\n\", getpid());\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (db) fprintf(stderr, \"ssl_helper[%d]: httpsock: %d %d\\n\",\n\t\t\t    getpid(), httpsock, n);\n\n\t\t\t/*\n\t\t\t * send what we read to httpd, and then connect\n\t\t\t * the rest of the SSL session to it:\n\t\t\t */\n\t\t\tif (n > 0) {\n\t\t\t\tchar *s = getenv(\"X11VNC_EXTRA_HTTPS_PARAMS\");\n\t\t\t\tint did_extra = 0;\n\n\t\t\t\tif (db) fprintf(stderr, \"sending http buffer httpsock: %d n=%d\\n'%s'\\n\", httpsock, n, buf);\n\t\t\t\tif (s != NULL) {\n\t\t\t\t\tchar *q = strstr(buf, \" HTTP/\");\n\t\t\t\t\tif (q) {\n\t\t\t\t\t\tint m;\n\t\t\t\t\t\t*q = '\\0';\n\t\t\t\t\t\tm = strlen(buf);\n\t\t\t\t\t\twrite(httpsock, buf, m);\n\t\t\t\t\t\twrite(httpsock, s, strlen(s));\n\t\t\t\t\t\t*q = ' ';\n\t\t\t\t\t\twrite(httpsock, q, n-m);\n\t\t\t\t\t\tdid_extra = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!did_extra) {\n\t\t\t\t\twrite(httpsock, buf, n);\n\t\t\t\t}\n\t\t\t}\n\t\t\tssl_xfer(httpsock, s_in, s_out, is_http);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 6 (https ssl_xfer done)\\n\", getpid());\n\t\t\texit(0);\n\t\t}\n\n\t\t/*\n\t\t * ok, back from the above https mess, simply send the\n\t\t * cookie back to the parent (who will attach us to\n\t\t * libvncserver), and connect the rest of the SSL session\n\t\t * to it.\n\t\t */\n\t\twrite_cookie:\n\t\twrite(vncsock, cookie, strlen(cookie));\n\n\t\twrote_cookie:\n\t\tssl_xfer(vncsock, s_in, s_out, 0);\n\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 7 (ssl_xfer done)\\n\", getpid());\n\t\tif (0) usleep(50 * 1000);\n\t\texit(0);\n\t}\n\t/* parent here */\n\n\tif (mode != OPENSSL_INETD) {\n\t\tclose(sock);\n\t}\n\tif (db) fprintf(stderr, \"helper process is: %d\\n\", pid);\n\n\t/* accept connection from our child.  */\n\tsignal(SIGALRM, csock_timeout);\n\tcsock_timeout_sock = csock;\n\talarm(20);\n\n\tvsock = accept(csock, (struct sockaddr *)&addr, &addrlen);\n\n\talarm(0);\n\tsignal(SIGALRM, SIG_DFL);\n\tclose(csock);\n\n\n\tif (vsock < 0) {\n\t\trfbLog(\"SSL: accept_openssl: connection from ssl_helper[%d] FAILED.\\n\", pid);\n\t\trfbLogPerror(\"accept\");\n\n\t\tkill(pid, SIGTERM);\n\t\twaitpid(pid, &status, WNOHANG); \n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tif (certret_fd >= 0) {\n\t\t\tclose(certret_fd);\n\t\t\tcertret_fd = -1;\n\t\t}\n\t\tif (certret) {\n\t\t\tunlink(certret);\n\t\t}\n\t\tif (dhret_fd >= 0) {\n\t\t\tclose(dhret_fd);\n\t\t\tdhret_fd = -1;\n\t\t}\n\t\tif (dhret) {\n\t\t\tunlink(dhret);\n\t\t}\n\t\treturn;\n\t}\n\tif (db) fprintf(stderr, \"accept_openssl: vsock: %d\\n\", vsock);\n\n\tn = read(vsock, rcookie, strlen(cookie));\n\tif (n < 0 && errno != 0) {\n\t\trfbLogPerror(\"read\");\n\t}\n\n\tif (certret) {\n\t\tstruct stat sbuf;\n\t\tsbuf.st_size = 0;\n\t\tif (certret_fd >= 0 && stat(certret, &sbuf) == 0 && sbuf.st_size > 0) {\n\t\t\tcertret_str = (char *) calloc(sbuf.st_size+1, 1);\n\t\t\tread(certret_fd, certret_str, sbuf.st_size);\n\t\t\tclose(certret_fd);\n\t\t\tcertret_fd = -1;\n\t\t}\n\t\tif (certret_fd >= 0) {\n\t\t\tclose(certret_fd);\n\t\t\tcertret_fd = -1;\n\t\t}\n\t\tunlink(certret);\n\t\tif (certret_str && strstr(certret_str, \"NOCERT\") == certret_str) {\n\t\t\tfree(certret_str);\n\t\t\tcertret_str = NULL;\n\t\t}\n\t\tif (0 && certret_str) {\n\t\t\tfprintf(stderr, \"certret_str[%d]:\\n%s\\n\", (int) sbuf.st_size, certret_str);\n\t\t}\n\t}\n\n\tif (dhret) {\n\t\tstruct stat sbuf;\n\t\tsbuf.st_size = 0;\n\t\tif (dhret_fd >= 0 && stat(dhret, &sbuf) == 0 && sbuf.st_size > 0) {\n\t\t\tdhret_str = (char *) calloc(sbuf.st_size+1, 1);\n\t\t\tread(dhret_fd, dhret_str, sbuf.st_size);\n\t\t\tclose(dhret_fd);\n\t\t\tdhret_fd = -1;\n\t\t}\n\t\tif (dhret_fd >= 0) {\n\t\t\tclose(dhret_fd);\n\t\t\tdhret_fd = -1;\n\t\t}\n\t\tunlink(dhret);\n\t\tif (dhret_str && strstr(dhret_str, \"NOCERT\") == dhret_str) {\n\t\t\tfree(dhret_str);\n\t\t\tdhret_str = NULL;\n\t\t}\n\t\tif (dhret_str) {\n\t\t\tif (new_dh_params == NULL) {\n\t\t\t\tfprintf(stderr, \"dhret_str[%d]:\\n%s\\n\", (int) sbuf.st_size, dhret_str);\n\t\t\t\tnew_dh_params = strdup(dhret_str);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (0) {\n\t\tfprintf(stderr, \"rcookie: %s\\n\", rcookie);\n\t\tfprintf(stderr, \"cookie:  %s\\n\", cookie);\n\t}\n\n\tif (strstr(rcookie, uniq) == rcookie) {\n\t\tchar *q = strstr(rcookie, \"RB=\");\n\t\tif (q && strstr(cookie, q) == cookie) {\n\t\t\tvencrypt_sel = 0;\n\t\t\tanontls_sel = 0;\n\t\t\tq = strstr(rcookie, \"VENCRYPT=\");\n\t\t\tif (q && sscanf(q, \"VENCRYPT=%d,\", &vencrypt_sel) == 1) {\n\t\t\t\tif (vencrypt_sel != 0) {\n\t\t\t\t\trfbLog(\"SSL: VENCRYPT mode=%d accepted. helper[%d]\\n\", vencrypt_sel, pid);\n\t\t\t\t\tgoto accept_client;\n\t\t\t\t}\n\t\t\t}\n\t\t\tq = strstr(rcookie, \"ANONTLS=\");\n\t\t\tif (q && sscanf(q, \"ANONTLS=%d,\", &anontls_sel) == 1) {\n\t\t\t\tif (anontls_sel != 0) {\n\t\t\t\t\trfbLog(\"SSL: ANONTLS mode=%d accepted. helper[%d]\\n\", anontls_sel, pid);\n\t\t\t\t\tgoto accept_client;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (n != (int) strlen(cookie) || strncmp(cookie, rcookie, n)) {\n\t\trfbLog(\"SSL: accept_openssl: cookie from ssl_helper[%d] FAILED. %d\\n\", pid, n);\n\t\tif (db) fprintf(stderr, \"'%s'\\n'%s'\\n\", cookie, rcookie);\n\t\tclose(vsock);\n\n\t\tif (strstr(rcookie, uniq) == rcookie) {\n\t\t\tint i;\n\t\t\tdouble https_download_wait_time = 15.0;\n\n\t\t\tif (getenv(\"X11VNC_HTTPS_DOWNLOAD_WAIT_TIME\")) {\n\t\t\t\thttps_download_wait_time = atof(getenv(\"X11VNC_HTTPS_DOWNLOAD_WAIT_TIME\"));\n\t\t\t}\n\n\t\t\trfbLog(\"SSL: BUT WAIT! HTTPS for helper process[%d] succeeded. Good.\\n\", pid);\n\t\t\tif (mode != OPENSSL_HTTPS) {\n\t\t\t\tlast_https = dnow();\n\t\t\t\tfor (i=0; i<256; i++) {\n\t\t\t\t\tlast_get[i] = '\\0';\n\t\t\t\t}\n\t\t\t\tstrncpy(last_get, rcookie, 100);\n\t\t\t\tif (db) fprintf(stderr, \"last_get: '%s'\\n\", last_get);\n\t\t\t}\n\t\t\tif (rcookie && strstr(rcookie, \"VncViewer.class\")) {\n\t\t\t\trfbLog(\"\\n\");\n\t\t\t\trfbLog(\"helper[%d]:\\n\", pid);\n\t\t\t\trfbLog(\"***********************************************************\\n\");\n\t\t\t\trfbLog(\"SSL: WARNING CLIENT ASKED FOR NONEXISTENT 'VncViewer.class'\\n\");\n\t\t\t\trfbLog(\"SSL: USER NEEDS TO MAKE SURE THE JAVA PLUGIN IS INSTALLED\\n\");\n\t\t\t\trfbLog(\"SSL: AND WORKING PROPERLY (e.g. a test-java-plugin page.)\\n\");\n\t\t\t\trfbLog(\"SSL: AND/OR USER NEEDS TO **RESTART** HIS WEB BROWSER.\\n\");\n\t\t\t\trfbLog(\"SSL: SOMETIMES THE BROWSER 'REMEMBERS' FAILED APPLET DOWN-\\n\");\n\t\t\t\trfbLog(\"SSL: LOADS AND RESTARTING IT IS THE ONLY WAY TO FIX THINGS.\\n\");\n\t\t\t\trfbLog(\"***********************************************************\\n\");\n\t\t\t\trfbLog(\"\\n\");\n\t\t\t}\n\t\t\tssl_helper_pid(pid, -2);\n\n\t\t\tif (https_port_redir) {\n\t\t\t\tdouble start;\n\t\t\t\tint origport = screen->port;\n\t\t\t\tint useport = screen->port;\n\t\t\t\tint saw_httpsock = 0;\n\t\t\t\t/* to expand $PORT correctly in index.vnc */\n\t\t\t\tif (https_port_redir < 0) {\n\t\t\t\t\tchar *q = strstr(rcookie, \"HP=\");\n\t\t\t\t\tif (q) {\n\t\t\t\t\t\tint p;\n\t\t\t\t\t\tif (sscanf(q, \"HP=%d,\", &p) == 1) {\n\t\t\t\t\t\t\tuseport = p;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tuseport = https_port_redir;\n\t\t\t\t}\n\t\t\t\tscreen->port = useport;\n\t\t\t\tif (origport != useport) {\n\t\t\t\t\trfbLog(\"SSL: -httpsredir guess port: %d  helper[%d]\\n\", screen->port, pid);\n\t\t\t\t}\n\n\t\t\t\tstart = dnow();\n\t\t\t\twhile (dnow() < start + https_download_wait_time) {\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\trfbPE(10000);\n\t\t\t\t\tusleep(10000);\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\twaitpid(pid, &status, WNOHANG); \n\t\t\t\t\tif (kill(pid, 0) != 0) {\n\t\t\t\t\t\trfbLog(\"SSL: helper[%d] pid finished\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (0 && saw_httpsock && screen->httpSock < 0) {\n\t\t\t\t\t\t/* this check can kill the helper too soon. */\n\t\t\t\t\t\trfbLog(\"SSL: httpSock for helper[%d] went away\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trfbLog(\"SSL: guessing child helper[%d] https finished. dt=%.6f\\n\",\n\t\t\t\t    pid, dnow() - start);\n\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\n\t\t\t\tscreen->port = origport;\n\t\t\t\tssl_helper_pid(0, -2);\n\t\t\t\tif (mode == OPENSSL_INETD) {\n\t\t\t\t\tclean_up_exit(1);\n\t\t\t\t}\n\t\t\t} else if (mode == OPENSSL_INETD) {\n\t\t\t\tdouble start;\n\t\t\t\tint saw_httpsock = 0;\n\n\t\t\t\t/* to expand $PORT correctly in index.vnc */\n\t\t\t\tif (screen->port == 0) {\n\t\t\t\t\tint fd = fileno(stdin);\n\t\t\t\t\tif (getenv(\"X11VNC_INETD_PORT\")) {\n\t\t\t\t\t\t/* mutex */\n\t\t\t\t\t\tscreen->port = atoi(getenv(\n\t\t\t\t\t\t    \"X11VNC_INETD_PORT\"));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tint tport = get_local_port(fd);\n\t\t\t\t\t\tif (tport > 0) {\n\t\t\t\t\t\t\tscreen->port = tport;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trfbLog(\"SSL: screen->port %d for helper[%d]\\n\", screen->port, pid);\n\n\t\t\t\t/* kludge for https fetch via inetd */\n\t\t\t\tstart = dnow();\n\t\t\t\twhile (dnow() < start + https_download_wait_time) {\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\trfbPE(10000);\n\t\t\t\t\tusleep(10000);\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\twaitpid(pid, &status, WNOHANG); \n\t\t\t\t\tif (kill(pid, 0) != 0) {\n\t\t\t\t\t\trfbLog(\"SSL: helper[%d] pid finished\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (0 && saw_httpsock && screen->httpSock < 0) {\n\t\t\t\t\t\t/* this check can kill the helper too soon. */\n\t\t\t\t\t\trfbLog(\"SSL: httpSock for helper[%d] went away\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trfbLog(\"SSL: OPENSSL_INETD guessing \"\n\t\t\t\t    \"child helper[%d] https finished. dt=%.6f\\n\",\n\t\t\t\t    pid, dnow() - start);\n\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\n\t\t\t\tssl_helper_pid(0, -2);\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\t/* this will actually only get earlier https */\n\t\t\tssl_helper_pid(0, -2);\n\t\t\treturn;\n\t\t}\n\t\tkill(pid, SIGTERM);\n\t\twaitpid(pid, &status, WNOHANG); \n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\n\taccept_client:\n\n\tif (db) fprintf(stderr, \"accept_openssl: cookie good: %s\\n\", cookie);\n\n\trfbLog(\"SSL: handshake with helper process[%d] succeeded.\\n\", pid);\n\n\topenssl_last_helper_pid = pid;\n\tssl_helper_pid(pid, vsock);\n\n\tif (vnc_redirect) {\n\t\tvnc_redirect_sock = vsock;\n\t\topenssl_last_helper_pid = 0;\n\t\treturn;\n\t}\n\n\tclient = create_new_client(vsock, 0);\n\topenssl_last_helper_pid = 0;\n\n\tif (client) {\n\t\tint swt = 0;\n\t\tif (mode == OPENSSL_VNC6 && openssl_last_ip != NULL) {\n\t\t\tswt = 1;\n\t\t} else if (mode == OPENSSL_REVERSE && ipv6_name != NULL && openssl_last_ip != NULL) {\n\t\t\tswt = 1;\n\t\t}\n\t\tif (swt) {\n\t\t\tif (client->host) {\n\t\t\t\tfree(client->host);\n\t\t\t}\n\t\t\tclient->host = strdup(openssl_last_ip);\n\t\t}\n\t\tif (db) fprintf(stderr, \"accept_openssl: client %p\\n\", (void *) client);\n\t\tif (db) fprintf(stderr, \"accept_openssl: new_client %p\\n\", (void *) screen->newClientHook);\n\t\tif (db) fprintf(stderr, \"accept_openssl: new_client %p\\n\", (void *) new_client);\n\t\tif (mode == OPENSSL_INETD) {\n\t\t\tinetd_client = client;\n\t\t\tclient->clientGoneHook = client_gone;\n\t\t}\n\t\tif (openssl_last_ip &&\n\t\t    strpbrk(openssl_last_ip, \"0123456789\") == openssl_last_ip) {\n\t\t\tclient->host = strdup(openssl_last_ip);\n\t\t}\n\t\tif (vencrypt_sel != 0) {\n\t\t\tclient->protocolMajorVersion = 3;\n\t\t\tclient->protocolMinorVersion = 8;\n#if LIBVNCSERVER_HAVE_LIBSSL || HAVE_LIBSSL \n\t\t\tif (!finish_vencrypt_auth(client, vencrypt_sel)) {\n\t\t\t\trfbCloseClient(client);\n\t\t\t\tclient = NULL;\n\t\t\t}\n#else\n\t\t\tbadnews(\"3 accept_openssl\");\n#endif\n\t\t} else if (anontls_sel != 0) {\n\t\t\tclient->protocolMajorVersion = 3;\n\t\t\tclient->protocolMinorVersion = 8;\n\t\t\trfbAuthNewClient(client);\n\t\t}\n\t\tif (use_threads && client != NULL) {\n\t\t\trfbStartOnHoldClient(client);\n\t\t}\n\t\t/* try to get RFB proto done now. */\n\t\tprogress_client();\n\t} else {\n\t\trfbLog(\"SSL: accept_openssl: rfbNewClient failed.\\n\");\n\t\tclose(vsock);\n\n\t\tkill(pid, SIGTERM);\n\t\twaitpid(pid, &status, WNOHANG); \n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "\"/proc/loadavg\"",
            "&sb"
          ],
          "line": 2937
        },
        "resolved": true,
        "details": {
          "function_name": "grab_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "3178-3224",
          "snippet": "void grab_state(int *ptr_grabbed, int *kbd_grabbed) {\n\tint rcp, rck;\n\tdouble t0, t1;\n\tdouble ta, tb, tc;\n\t*ptr_grabbed = -1;\n\t*kbd_grabbed = -1;\n\n\tif (!dpy) {\n\t\treturn;\n\t}\n\t*ptr_grabbed = 0;\n\t*kbd_grabbed = 0;\n\n#if !NO_X11\n\tX_LOCK;\n\n\tXSync(dpy, False);\n\n\tta = t0 = dnow();\n\n\trcp = XGrabPointer(dpy, window, False, 0, GrabModeAsync, GrabModeAsync, None, None, CurrentTime);\n\tXUngrabPointer(dpy, CurrentTime);\n\n\ttb = dnow();\n\t\n\trck = XGrabKeyboard(dpy, window, False, GrabModeAsync, GrabModeAsync, CurrentTime);\n\tXUngrabKeyboard(dpy, CurrentTime);\n\n\ttc = dnow();\n\n\tXSync(dpy, False);\n\n\tt1 = dnow();\n\n\tX_UNLOCK;\n\tif (rcp == AlreadyGrabbed || rcp == GrabFrozen) {\n\t\t*ptr_grabbed = 1;\n\t}\n\tif (rck == AlreadyGrabbed || rck == GrabFrozen) {\n\t\t*kbd_grabbed = 1;\n\t}\n\tif (rc_npieces < 10) {\n\t\trfbLog(\"grab_state: checked %d,%d in %.6f sec (%.6f %.6f)\\n\",\n\t\t    *ptr_grabbed, *kbd_grabbed, t1-t0, tb-ta, tc-tb);\n\t}\n#endif\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void grab_state(int *ptr_grabbed, int *kbd_grabbed);",
            "extern int rc_npieces;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid grab_state(int *ptr_grabbed, int *kbd_grabbed);\nextern int rc_npieces;\n\nvoid grab_state(int *ptr_grabbed, int *kbd_grabbed) {\n\tint rcp, rck;\n\tdouble t0, t1;\n\tdouble ta, tb, tc;\n\t*ptr_grabbed = -1;\n\t*kbd_grabbed = -1;\n\n\tif (!dpy) {\n\t\treturn;\n\t}\n\t*ptr_grabbed = 0;\n\t*kbd_grabbed = 0;\n\n#if !NO_X11\n\tX_LOCK;\n\n\tXSync(dpy, False);\n\n\tta = t0 = dnow();\n\n\trcp = XGrabPointer(dpy, window, False, 0, GrabModeAsync, GrabModeAsync, None, None, CurrentTime);\n\tXUngrabPointer(dpy, CurrentTime);\n\n\ttb = dnow();\n\t\n\trck = XGrabKeyboard(dpy, window, False, GrabModeAsync, GrabModeAsync, CurrentTime);\n\tXUngrabKeyboard(dpy, CurrentTime);\n\n\ttc = dnow();\n\n\tXSync(dpy, False);\n\n\tt1 = dnow();\n\n\tX_UNLOCK;\n\tif (rcp == AlreadyGrabbed || rcp == GrabFrozen) {\n\t\t*ptr_grabbed = 1;\n\t}\n\tif (rck == AlreadyGrabbed || rck == GrabFrozen) {\n\t\t*kbd_grabbed = 1;\n\t}\n\tif (rc_npieces < 10) {\n\t\trfbLog(\"grab_state: checked %d,%d in %.6f sec (%.6f %.6f)\\n\",\n\t\t    *ptr_grabbed, *kbd_grabbed, t1-t0, tb-ta, tc-tb);\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "tmp",
            "0",
            "sizeof(tmp)"
          ],
          "line": 2936
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <default8x16.h>\n#include \"userinput.h\"\n#include \"macosx.h\"\n#include \"screen.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"8to24.h\"\n#include \"win_utils.h\"\n#include \"xrandr.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nstatic char *get_load(void) {\n\tstatic char tmp[64];\n\tstatic int count = 0;\n\n\tif (count++ % 5 == 0) {\n\t\tstruct stat sb;\n\t\tmemset(tmp, 0, sizeof(tmp));\n\t\tif (stat(\"/proc/loadavg\", &sb) == 0) {\n\t\t\tint d = open(\"/proc/loadavg\", O_RDONLY);\n\t\t\tif (d >= 0) {\n\t\t\t\tread(d, tmp, 60);\n\t\t\t\tclose(d);\n\t\t\t}\n\t\t}\n\t\tif (tmp[0] == '\\0') {\n\t\t\tstrcat(tmp, \"unknown\");\n\t\t}\n\t}\n\treturn tmp;\n}"
  },
  {
    "function_name": "nap_sleep",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/scan.c",
    "lines": "2912-2928",
    "snippet": "void nap_sleep(int ms, int split) {\n\tint i, input = got_user_input;\n\tint gd = got_local_pointer_input;\n\n\tfor (i=0; i<split; i++) {\n\t\tusleep(ms * 1000 / split);\n\t\tif (! use_threads && i != split - 1) {\n\t\t\trfbPE(-1);\n\t\t}\n\t\tif (input != got_user_input) {\n\t\t\tbreak;\n\t\t}\n\t\tif (gd != got_local_pointer_input) {\n\t\t\tbreak;\n\t\t}\n\t}\n}",
    "includes": [
      "#include <default8x16.h>",
      "#include \"userinput.h\"",
      "#include \"macosx.h\"",
      "#include \"screen.h\"",
      "#include \"unixpw.h\"",
      "#include \"cleanup.h\"",
      "#include \"pointer.h\"",
      "#include \"screen.h\"",
      "#include \"8to24.h\"",
      "#include \"win_utils.h\"",
      "#include \"xrandr.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"xinerama.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void nap_sleep(int ms, int split);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rfbPE",
          "args": [
            "-1"
          ],
          "line": 2919
        },
        "resolved": true,
        "details": {
          "function_name": "rfbPE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "561-619",
          "snippet": "int rfbPE(long usec) {\n\tint uip0 = unixpw_in_progress;\n\tstatic int check_rate = -1;\n\tint res = 0;\n\tif (! screen) {\n\t\treturn res;\n\t}\n \tif (unixpw && unixpw_in_progress && !unixpw_in_rfbPE) {\n\t\trfbLog(\"unixpw_in_rfbPE: skipping rfbPE\\n\");\n \t\treturn res;\n \t}\n\n\tif (debug_tiles > 2) {\n\t\tdouble tm = dnow();\n\t\tfprintf(stderr, \"rfbPE(%d)  t: %.4f\\n\",\n\t\t    (int) usec, tm - x11vnc_start);\n\t}\n\n\tif (usec > USEC_MAX) {\n\t\tusec = USEC_MAX;\n\t}\n\tif (! use_threads) {\n\t\trfbBool r;\n\t\tr = rfbProcessEvents(screen, usec);\n\t\tif (r) {\n\t\t\tres = 1;\n\t\t}\n\t}\n\n \tif (unixpw && unixpw_in_progress && !uip0) {\n\t\tif (!unixpw_in_rfbPE) {\n\t\t\trfbLog(\"rfbPE: got new client in non-rfbPE\\n\");\n\t\t\t;\t/* this is new unixpw client  */\n\t\t}\n \t}\n\n\tif (ipv6_listen) {\n\t\tcheck_ipv6_listen(usec);\n\t}\n\tif (unix_sock) {\n\t\tcheck_unix_sock(usec);\n\t}\n\tif (check_rate != 0) {\n\t\tif (check_rate < 0) {\n\t\t\tif (getenv(\"CHECK_RATE\")) {\n\t\t\t\tcheck_rate = 1;\n\t\t\t} else {\n\t\t\t\tcheck_rate = 0;\n\t\t\t}\n\t\t}\n\t\tif (check_rate && !all_input && x11vnc_current < last_client + 45)  {\n\t\t\tcheck_allinput_rate();\n\t\t}\n\t}\n\tif (all_input) {\n\t\tdo_allinput(usec);\n\t}\n\treturn res;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [
            "#define USEC_MAX 999999\t\t/* libvncsever assumes < 1 second */"
          ],
          "globals_used": [
            "int nfix(int i, int n);",
            "int nabs(int n);",
            "double dnow(void);",
            "int rfbPE(long usec);",
            "void rfbCFD(long usec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\n#define USEC_MAX 999999\t\t/* libvncsever assumes < 1 second */\n\nint nfix(int i, int n);\nint nabs(int n);\ndouble dnow(void);\nint rfbPE(long usec);\nvoid rfbCFD(long usec);\n\nint rfbPE(long usec) {\n\tint uip0 = unixpw_in_progress;\n\tstatic int check_rate = -1;\n\tint res = 0;\n\tif (! screen) {\n\t\treturn res;\n\t}\n \tif (unixpw && unixpw_in_progress && !unixpw_in_rfbPE) {\n\t\trfbLog(\"unixpw_in_rfbPE: skipping rfbPE\\n\");\n \t\treturn res;\n \t}\n\n\tif (debug_tiles > 2) {\n\t\tdouble tm = dnow();\n\t\tfprintf(stderr, \"rfbPE(%d)  t: %.4f\\n\",\n\t\t    (int) usec, tm - x11vnc_start);\n\t}\n\n\tif (usec > USEC_MAX) {\n\t\tusec = USEC_MAX;\n\t}\n\tif (! use_threads) {\n\t\trfbBool r;\n\t\tr = rfbProcessEvents(screen, usec);\n\t\tif (r) {\n\t\t\tres = 1;\n\t\t}\n\t}\n\n \tif (unixpw && unixpw_in_progress && !uip0) {\n\t\tif (!unixpw_in_rfbPE) {\n\t\t\trfbLog(\"rfbPE: got new client in non-rfbPE\\n\");\n\t\t\t;\t/* this is new unixpw client  */\n\t\t}\n \t}\n\n\tif (ipv6_listen) {\n\t\tcheck_ipv6_listen(usec);\n\t}\n\tif (unix_sock) {\n\t\tcheck_unix_sock(usec);\n\t}\n\tif (check_rate != 0) {\n\t\tif (check_rate < 0) {\n\t\t\tif (getenv(\"CHECK_RATE\")) {\n\t\t\t\tcheck_rate = 1;\n\t\t\t} else {\n\t\t\t\tcheck_rate = 0;\n\t\t\t}\n\t\t}\n\t\tif (check_rate && !all_input && x11vnc_current < last_client + 45)  {\n\t\t\tcheck_allinput_rate();\n\t\t}\n\t}\n\tif (all_input) {\n\t\tdo_allinput(usec);\n\t}\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "ms * 1000 / split"
          ],
          "line": 2917
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <default8x16.h>\n#include \"userinput.h\"\n#include \"macosx.h\"\n#include \"screen.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"8to24.h\"\n#include \"win_utils.h\"\n#include \"xrandr.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nvoid nap_sleep(int ms, int split);\n\nvoid nap_sleep(int ms, int split) {\n\tint i, input = got_user_input;\n\tint gd = got_local_pointer_input;\n\n\tfor (i=0; i<split; i++) {\n\t\tusleep(ms * 1000 / split);\n\t\tif (! use_threads && i != split - 1) {\n\t\t\trfbPE(-1);\n\t\t}\n\t\tif (input != got_user_input) {\n\t\t\tbreak;\n\t\t}\n\t\tif (gd != got_local_pointer_input) {\n\t\t\tbreak;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "nap_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/scan.c",
    "lines": "2870-2907",
    "snippet": "static void nap_set(int tile_cnt) {\n\tint nap_in = nap_ok;\n\ttime_t now = time(NULL);\n\n\tif (scan_count == 0) {\n\t\t/* roll up check for all NSCAN scans */\n\t\tnap_ok = 0;\n\t\tif (naptile && nap_diff_count < 2 * NSCAN * naptile) {\n\t\t\t/* \"2\" is a fudge to permit a bit of bg drawing */\n\t\t\tnap_ok = 1;\n\t\t}\n\t\tnap_diff_count = 0;\n\t}\n\tif (nap_ok && ! nap_in && use_xdamage) {\n\t\tif (XD_skip > 0.8 * XD_tot) \t{\n\t\t\t/* X DAMAGE is keeping load low, so skip nap */\n\t\t\tnap_ok = 0;\n\t\t}\n\t}\n\tif (! nap_ok && client_count) {\n\t\tif(now > last_fb_bytes_sent + no_fbu_blank) {\n\t\t\tif (debug_tiles > 1) {\n\t\t\t\tfprintf(stderr, \"nap_set: nap_ok=1: now: %d last: %d\\n\",\n\t\t\t\t    (int) now, (int) last_fb_bytes_sent);\n\t\t\t}\n\t\t\tnap_ok = 1;\n\t\t}\n\t}\n\n\tif (show_cursor) {\n\t\t/* kludge for the up to 4 tiles the mouse patch could occupy */\n\t\tif ( tile_cnt > 4) {\n\t\t\tlast_event = now;\n\t\t}\n\t} else if (tile_cnt != 0) {\n\t\tlast_event = now;\n\t}\n}",
    "includes": [
      "#include <default8x16.h>",
      "#include \"userinput.h\"",
      "#include \"macosx.h\"",
      "#include \"screen.h\"",
      "#include \"unixpw.h\"",
      "#include \"cleanup.h\"",
      "#include \"pointer.h\"",
      "#include \"screen.h\"",
      "#include \"8to24.h\"",
      "#include \"win_utils.h\"",
      "#include \"xrandr.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"xinerama.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void nap_set(int tile_cnt);",
      "static void nap_check(int tile_cnt);",
      "static void ping_clients(int tile_cnt);",
      "int nap_ok = 0;",
      "static int nap_diff_count = 0;",
      "static int scan_count = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"nap_set: nap_ok=1: now: %d last: %d\\n\"",
            "(int) now",
            "(int) last_fb_bytes_sent"
          ],
          "line": 2892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time",
          "args": [
            "NULL"
          ],
          "line": 2872
        },
        "resolved": true,
        "details": {
          "function_name": "csock_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "3270-3276",
          "snippet": "static void csock_timeout (int sig) {\n\trfbLog(\"sig: %d, csock_timeout.\\n\", sig);\n\tif (csock_timeout_sock >= 0) {\n\t\tclose(csock_timeout_sock);\n\t\tcsock_timeout_sock = -1;\n\t}\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int csock_timeout_sock = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nstatic int csock_timeout_sock = -1;\n\nstatic void csock_timeout (int sig) {\n\trfbLog(\"sig: %d, csock_timeout.\\n\", sig);\n\tif (csock_timeout_sock >= 0) {\n\t\tclose(csock_timeout_sock);\n\t\tcsock_timeout_sock = -1;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <default8x16.h>\n#include \"userinput.h\"\n#include \"macosx.h\"\n#include \"screen.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"8to24.h\"\n#include \"win_utils.h\"\n#include \"xrandr.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nstatic void nap_set(int tile_cnt);\nstatic void nap_check(int tile_cnt);\nstatic void ping_clients(int tile_cnt);\nint nap_ok = 0;\nstatic int nap_diff_count = 0;\nstatic int scan_count = 0;\n\nstatic void nap_set(int tile_cnt) {\n\tint nap_in = nap_ok;\n\ttime_t now = time(NULL);\n\n\tif (scan_count == 0) {\n\t\t/* roll up check for all NSCAN scans */\n\t\tnap_ok = 0;\n\t\tif (naptile && nap_diff_count < 2 * NSCAN * naptile) {\n\t\t\t/* \"2\" is a fudge to permit a bit of bg drawing */\n\t\t\tnap_ok = 1;\n\t\t}\n\t\tnap_diff_count = 0;\n\t}\n\tif (nap_ok && ! nap_in && use_xdamage) {\n\t\tif (XD_skip > 0.8 * XD_tot) \t{\n\t\t\t/* X DAMAGE is keeping load low, so skip nap */\n\t\t\tnap_ok = 0;\n\t\t}\n\t}\n\tif (! nap_ok && client_count) {\n\t\tif(now > last_fb_bytes_sent + no_fbu_blank) {\n\t\t\tif (debug_tiles > 1) {\n\t\t\t\tfprintf(stderr, \"nap_set: nap_ok=1: now: %d last: %d\\n\",\n\t\t\t\t    (int) now, (int) last_fb_bytes_sent);\n\t\t\t}\n\t\t\tnap_ok = 1;\n\t\t}\n\t}\n\n\tif (show_cursor) {\n\t\t/* kludge for the up to 4 tiles the mouse patch could occupy */\n\t\tif ( tile_cnt > 4) {\n\t\t\tlast_event = now;\n\t\t}\n\t} else if (tile_cnt != 0) {\n\t\tlast_event = now;\n\t}\n}"
  },
  {
    "function_name": "print_tiles",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/scan.c",
    "lines": "2827-2864",
    "snippet": "static void print_tiles(void) {\n\t/* hack for viewing tile diffs on the screen. */\n\tstatic char *prev = NULL;\n\tint n, x, y, ms = 1500;\n\n\tms = 1;\n\n\tif (! prev) {\n\t\tprev = (char *) malloc((size_t) ntiles);\n\t\tfor (n=0; n < ntiles; n++) {\n\t\t\tprev[n] = 0;\n\t\t}\n\t}\n\tfprintf(stderr, \"   \");\n\tfor (x=0; x < ntiles_x; x++) {\n\t\tfprintf(stderr, \"%1d\", x % 10);\n\t}\n\tfprintf(stderr, \"\\n\");\n\tn = 0;\n\tfor (y=0; y < ntiles_y; y++) {\n\t\tfprintf(stderr, \"%2d \", y);\n\t\tfor (x=0; x < ntiles_x; x++) {\n\t\t\tif (tile_has_diff[n]) {\n\t\t\t\tfprintf(stderr, \"X\");\n\t\t\t} else if (prev[n]) {\n\t\t\t\tfprintf(stderr, \"o\");\n\t\t\t} else {\n\t\t\t\tfprintf(stderr, \".\");\n\t\t\t}\n\t\t\tn++;\n\t\t}\n\t\tfprintf(stderr, \"\\n\");\n\t}\n\tfor (n=0; n < ntiles; n++) {\n\t\tprev[n] = tile_has_diff[n];\n\t}\n\tusleep(ms * 1000);\n}",
    "includes": [
      "#include <default8x16.h>",
      "#include \"userinput.h\"",
      "#include \"macosx.h\"",
      "#include \"screen.h\"",
      "#include \"unixpw.h\"",
      "#include \"cleanup.h\"",
      "#include \"pointer.h\"",
      "#include \"screen.h\"",
      "#include \"8to24.h\"",
      "#include \"win_utils.h\"",
      "#include \"xrandr.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"xinerama.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "ms * 1000"
          ],
          "line": 2863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"\\n\""
          ],
          "line": 2858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\".\""
          ],
          "line": 2854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"o\""
          ],
          "line": 2852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"X\""
          ],
          "line": 2850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%2d \"",
            "y"
          ],
          "line": 2847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"\\n\""
          ],
          "line": 2844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%1d\"",
            "x % 10"
          ],
          "line": 2842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"   \""
          ],
          "line": 2840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "(size_t) ntiles"
          ],
          "line": 2835
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <default8x16.h>\n#include \"userinput.h\"\n#include \"macosx.h\"\n#include \"screen.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"8to24.h\"\n#include \"win_utils.h\"\n#include \"xrandr.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nstatic void print_tiles(void) {\n\t/* hack for viewing tile diffs on the screen. */\n\tstatic char *prev = NULL;\n\tint n, x, y, ms = 1500;\n\n\tms = 1;\n\n\tif (! prev) {\n\t\tprev = (char *) malloc((size_t) ntiles);\n\t\tfor (n=0; n < ntiles; n++) {\n\t\t\tprev[n] = 0;\n\t\t}\n\t}\n\tfprintf(stderr, \"   \");\n\tfor (x=0; x < ntiles_x; x++) {\n\t\tfprintf(stderr, \"%1d\", x % 10);\n\t}\n\tfprintf(stderr, \"\\n\");\n\tn = 0;\n\tfor (y=0; y < ntiles_y; y++) {\n\t\tfprintf(stderr, \"%2d \", y);\n\t\tfor (x=0; x < ntiles_x; x++) {\n\t\t\tif (tile_has_diff[n]) {\n\t\t\t\tfprintf(stderr, \"X\");\n\t\t\t} else if (prev[n]) {\n\t\t\t\tfprintf(stderr, \"o\");\n\t\t\t} else {\n\t\t\t\tfprintf(stderr, \".\");\n\t\t\t}\n\t\t\tn++;\n\t\t}\n\t\tfprintf(stderr, \"\\n\");\n\t}\n\tfor (n=0; n < ntiles; n++) {\n\t\tprev[n] = tile_has_diff[n];\n\t}\n\tusleep(ms * 1000);\n}"
  },
  {
    "function_name": "copy_snap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/scan.c",
    "lines": "2742-2820",
    "snippet": "int copy_snap(void) {\n\tint db = 1;\n\tchar *fbp;\n\tint i, y, block_size;\n\tdouble dt;\n\tstatic int first = 1, snapcnt = 0;\n\n\tif (raw_fb_str) {\n\t\tint read_all_at_once = 1;\n\t\tdouble start = dnow();\n\t\tif (rawfb_reset < 0) {\n\t\t\tif (getenv(\"SNAPFB_RAWFB_RESET\")) {\n\t\t\t\trawfb_reset = 1;\n\t\t\t} else {\n\t\t\t\trawfb_reset = 0;\n\t\t\t}\n\t\t}\n\t\tif (snap_fb == NULL || snap == NULL) {\n\t\t\trfbLog(\"copy_snap: rawfb mode and null snap fb\\n\"); \n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tif (rawfb_reset) {\n\t\t\tinitialize_raw_fb(1);\n\t\t}\n\t\tif (raw_fb_bytes_per_line != snap->bytes_per_line) {\n\t\t\tread_all_at_once = 0;\n\t\t}\n\t\tif (raw_fb_full_str && strstr(raw_fb_full_str, \"/dev/vcsa\")) {\n\t\t\tsnap_vcsa_rawfb();\n\t\t} else if (read_all_at_once) {\n\t\t\tsnap_all_rawfb();\n\t\t} else {\n\t\t\t/* this goes line by line, XXX not working for video */\n\t\t\tcopy_raw_fb(snap, 0, 0, dpy_x, dpy_y);\n\t\t}\nif (db && snapcnt++ < 5) rfbLog(\"rawfb copy_snap took: %.5f secs\\n\", dnow() - start);\n\n\t\treturn 0;\n\t}\n\t\n\tif (! fs_factor) {\n\t\treturn 0;\n\t}\n\n\n\tif (! snap_fb || ! snap || ! snaprect) {\n\t\treturn 0;\n\t}\n\tblock_size = ((dpy_y/fs_factor) * snap->bytes_per_line);\n\n\tfbp = snap_fb;\n\ty = 0;\n\n\n\tdtime0(&dt);\n\tX_LOCK;\n\n\t/* screen may be too big for 1 shm area, so broken into fs_factor */\n\tfor (i=0; i < fs_factor; i++) {\n\t\tXRANDR_SET_TRAP_RET(-1, \"copy_snap-set\");\n\t\tcopy_image(snaprect, 0, y, 0, 0);\n\t\tXRANDR_CHK_TRAP_RET(-1, \"copy_snap-chk\");\n\n\t\tmemcpy(fbp, snaprect->data, (size_t) block_size);\n\n\t\ty += dpy_y / fs_factor;\n\t\tfbp += block_size;\n\t}\n\n\tX_UNLOCK;\n\n\tdt = dtime(&dt);\n\tif (first) {\n\t\trfbLog(\"copy_snap: time for -snapfb snapshot: %.3f sec\\n\", dt);\n\t\tfirst = 0;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <default8x16.h>",
      "#include \"userinput.h\"",
      "#include \"macosx.h\"",
      "#include \"screen.h\"",
      "#include \"unixpw.h\"",
      "#include \"cleanup.h\"",
      "#include \"pointer.h\"",
      "#include \"screen.h\"",
      "#include \"8to24.h\"",
      "#include \"win_utils.h\"",
      "#include \"xrandr.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"xinerama.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void shm_delete(XShmSegmentInfo *shm);",
      "int copy_snap(void);",
      "static int fs_factor = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"copy_snap: time for -snapfb snapshot: %.3f sec\\n\"",
            "dt"
          ],
          "line": 2815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dtime",
          "args": [
            "&dt"
          ],
          "line": 2813
        },
        "resolved": true,
        "details": {
          "function_name": "dtime0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "429-432",
          "snippet": "double dtime0(double *t_old) {\n\t*t_old = 0.0;\n\treturn dtime(t_old);\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double dtime(double *);",
            "double dtime0(double *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dtime(double *);\ndouble dtime0(double *);\n\ndouble dtime0(double *t_old) {\n\t*t_old = 0.0;\n\treturn dtime(t_old);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "fbp",
            "snaprect->data",
            "(size_t) block_size"
          ],
          "line": 2805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XRANDR_CHK_TRAP_RET",
          "args": [
            "-1",
            "\"copy_snap-chk\""
          ],
          "line": 2803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_image",
          "args": [
            "snaprect",
            "0",
            "y",
            "0",
            "0"
          ],
          "line": 2802
        },
        "resolved": true,
        "details": {
          "function_name": "copy_image",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "832-868",
          "snippet": "void copy_image(XImage *dest, int x, int y, unsigned int w, unsigned int h) {\n\t/* default (w=0, h=0) is the fill the entire XImage */\n\tif (dest == NULL) {\n\t\treturn;\n\t}\n\tif (w < 1)  {\n\t\tw = dest->width;\n\t}\n\tif (h < 1)  {\n\t\th = dest->height;\n\t}\n\n\tif (raw_fb) {\n\t\tcopy_raw_fb(dest, x, y, w, h);\n\n\t} else if (use_snapfb && snap_fb && dest != snaprect) {\n\t\tchar *src, *dst;\n\t\tunsigned int line;\n\t\tint pixelsize = bpp/8;\n\n\t\tsrc = snap->data + snap->bytes_per_line*y + pixelsize*x;\n\t\tdst = dest->data;\n\t\tfor (line = 0; line < h; line++) {\n\t\t\tmemcpy(dst, src, w * pixelsize);\n\t\t\tsrc += snap->bytes_per_line;\n\t\t\tdst += dest->bytes_per_line;\n\t\t}\n\n\t} else if ((using_shm && ! xform24to32) && (int) w == dest->width &&\n\t    (int) h == dest->height) {\n\t\tXShmGetImage_wr(dpy, window, dest, x, y, AllPlanes);\n\n\t} else {\n\t\tXGetSubImage_wr(dpy, window, x, y, w, h, AllPlanes,\n\t\t    ZPixmap, dest, 0, 0);\n\t}\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "XImage *XShmCreateImage_wr(Display* disp, Visual* vis, unsigned int depth,\n    int format, char* data, XShmSegmentInfo* shminfo, unsigned int width,\n    unsigned int height);",
            "XImage *XCreateImage_wr(Display *disp, Visual *visual, unsigned int depth,\n    int format, int offset, char *data, unsigned int width,\n    unsigned int height, int bitmap_pad, int bytes_per_line);",
            "void copy_image(XImage *dest, int x, int y, unsigned int w, unsigned int h);",
            "Bool XTestCompareCurrentCursorWithWindow_wr(Display* dpy, Window w);",
            "void XTestDiscard_wr(Display *dpy);",
            "int XFree_wr(void *data);",
            "void copy_raw_fb(XImage *dest, int x, int y, unsigned int w, unsigned int h);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nXImage *XShmCreateImage_wr(Display* disp, Visual* vis, unsigned int depth,\n    int format, char* data, XShmSegmentInfo* shminfo, unsigned int width,\n    unsigned int height);\nXImage *XCreateImage_wr(Display *disp, Visual *visual, unsigned int depth,\n    int format, int offset, char *data, unsigned int width,\n    unsigned int height, int bitmap_pad, int bytes_per_line);\nvoid copy_image(XImage *dest, int x, int y, unsigned int w, unsigned int h);\nBool XTestCompareCurrentCursorWithWindow_wr(Display* dpy, Window w);\nvoid XTestDiscard_wr(Display *dpy);\nint XFree_wr(void *data);\nvoid copy_raw_fb(XImage *dest, int x, int y, unsigned int w, unsigned int h);\n\nvoid copy_image(XImage *dest, int x, int y, unsigned int w, unsigned int h) {\n\t/* default (w=0, h=0) is the fill the entire XImage */\n\tif (dest == NULL) {\n\t\treturn;\n\t}\n\tif (w < 1)  {\n\t\tw = dest->width;\n\t}\n\tif (h < 1)  {\n\t\th = dest->height;\n\t}\n\n\tif (raw_fb) {\n\t\tcopy_raw_fb(dest, x, y, w, h);\n\n\t} else if (use_snapfb && snap_fb && dest != snaprect) {\n\t\tchar *src, *dst;\n\t\tunsigned int line;\n\t\tint pixelsize = bpp/8;\n\n\t\tsrc = snap->data + snap->bytes_per_line*y + pixelsize*x;\n\t\tdst = dest->data;\n\t\tfor (line = 0; line < h; line++) {\n\t\t\tmemcpy(dst, src, w * pixelsize);\n\t\t\tsrc += snap->bytes_per_line;\n\t\t\tdst += dest->bytes_per_line;\n\t\t}\n\n\t} else if ((using_shm && ! xform24to32) && (int) w == dest->width &&\n\t    (int) h == dest->height) {\n\t\tXShmGetImage_wr(dpy, window, dest, x, y, AllPlanes);\n\n\t} else {\n\t\tXGetSubImage_wr(dpy, window, x, y, w, h, AllPlanes,\n\t\t    ZPixmap, dest, 0, 0);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "XRANDR_SET_TRAP_RET",
          "args": [
            "-1",
            "\"copy_snap-set\""
          ],
          "line": 2801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"rawfb copy_snap took: %.5f secs\\n\"",
            "dnow() - start"
          ],
          "line": 2777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dnow",
          "args": [],
          "line": 2777
        },
        "resolved": true,
        "details": {
          "function_name": "dnowx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "439-441",
          "snippet": "double dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double dnow(void);",
            "double dnowx(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dnow(void);\ndouble dnowx(void);\n\ndouble dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_raw_fb",
          "args": [
            "snap",
            "0",
            "0",
            "dpy_x",
            "dpy_y"
          ],
          "line": 2775
        },
        "resolved": true,
        "details": {
          "function_name": "copy_raw_fb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "724-830",
          "snippet": "void copy_raw_fb(XImage *dest, int x, int y, unsigned int w, unsigned int h) {\n\tchar *src, *dst;\n\tunsigned int line;\n\tint pixelsize = bpp/8;\n\tstatic int db = -1;\n\n#ifdef MACOSX\n\tif (macosx_console && macosx_read_opengl) {\n\t\tmacosx_copy_opengl(dest->data, x, y, w, h);\n\t\treturn;\n\t}\n#endif\n\n\tif (xform24to32) {\n\t\tcopy_raw_fb_24_to_32(dest, x, y, w, h);\n\t\treturn;\n\t}\n\tif (raw_fb_native_bpp < 8) {\n\t\tcopy_raw_fb_low_bpp(dest, x, y, w, h);\n\t\treturn;\n\t}\n\tif (db < 0) {\n\t\tif (getenv(\"DEBUG_COPY_RAW_FB\")) {\n\t\t\tdb = atoi(getenv(\"DEBUG_COPY_RAW_FB\"));\n\t\t} else {\n\t\t\tdb = 0;\n\t\t}\n\t}\n\n\tif (clipshift && ! use_snapfb) {\n\t\tx += coff_x;\n\t\ty += coff_y;\n\t}\n\n\n\tif (use_snapfb && dest != snap) {\n\t\t/* snapfb src */\n\t\tsrc = snap->data + snap->bytes_per_line*y + pixelsize*x;\n\t\tdst = dest->data;\n\nif (db) fprintf(stderr, \"snap->bytes_per_line: %d, dest->bytes_per_line: %d, w: %d h: %d dpy_x: %d wdpy_x: %d cdpy_x: %d bpp: %d pixelsize: %d\\n\", snap->bytes_per_line, dest->bytes_per_line, w, h, dpy_x, wdpy_x, cdpy_x, bpp, pixelsize);\n\n\t\tfor (line = 0; line < h; line++) {\n\t\t\tmemcpy(dst, src, w * pixelsize);\n\t\t\tsrc += snap->bytes_per_line;\n\t\t\tdst += dest->bytes_per_line;\n\t\t}\n\n\t} else if (! raw_fb_seek) {\n\t\t/* mmap */\n\t\tint bpl = raw_fb_bytes_per_line;\n\n\t\tif (clipshift && wdpy_x != cdpy_x) {\n\t\t\tbpl = wdpy_x * pixelsize;\n\t\t}\n\n\t\tsrc = raw_fb_addr + raw_fb_offset + bpl*y + pixelsize*x;\n\t\tdst = dest->data;\n\nif (db) fprintf(stderr, \"bpl: %d, dest->bytes_per_line: %d, w: %d h: %d dpy_x: %d wdpy_x: %d cdpy_x: %d bpp: %d pixelsize: %d\\n\", bpl, dest->bytes_per_line, w, h, dpy_x, wdpy_x, cdpy_x, bpp, pixelsize);\n\n\t\tfor (line = 0; line < h; line++) {\n\t\t\tmemcpy(dst, src, w * pixelsize);\n\t\t\tsrc += bpl;\n\t\t\tdst += dest->bytes_per_line;\n\t\t}\n\n\t} else {\n\t\t/* lseek */\n\t\tint n, len, del, sz = w * pixelsize;\n\t\toff_t off;\n\t\tint bpl = raw_fb_bytes_per_line;\n\n\t\tif (clipshift && wdpy_x != cdpy_x) {\n\t\t\tbpl = wdpy_x * pixelsize;\n\t\t}\n\n\t\toff = (off_t) (raw_fb_offset + bpl*y + pixelsize*x);\n\n\t\tlseek(raw_fb_fd, off, SEEK_SET);\n\t\tdst = dest->data;\n\nif (db) fprintf(stderr, \"lseek 0 ps: %d  sz: %d off: %d bpl: %d\\n\", pixelsize, sz, (int) off, bpl);\n\n\t\tfor (line = 0; line < h; line++) {\n\t\t\tlen = sz;\n\t\t\tdel = 0;\n\t\t\twhile (len > 0) {\n\t\t\t\tn = read(raw_fb_fd, dst + del, len);\n\n\t\t\t\tif (n > 0) {\n\t\t\t\t\tdel += n;\n\t\t\t\t\tlen -= n;\n\t\t\t\t} else if (n == 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (errno != EINTR && errno != EAGAIN) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (bpl > sz) {\n\t\t\t\toff = (off_t) (bpl - sz);\n\t\t\t\tlseek(raw_fb_fd, off, SEEK_CUR);\n\t\t\t}\n\t\t\tdst += dest->bytes_per_line;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int clipshift = 0;",
            "XImage *XCreateImage_wr(Display *disp, Visual *visual, unsigned int depth,\n    int format, int offset, char *data, unsigned int width,\n    unsigned int height, int bitmap_pad, int bytes_per_line);",
            "void copy_image(XImage *dest, int x, int y, unsigned int w, unsigned int h);",
            "Bool XTestCompareCurrentCursorWithWindow_wr(Display* dpy, Window w);",
            "int XFree_wr(void *data);",
            "void copy_raw_fb(XImage *dest, int x, int y, unsigned int w, unsigned int h);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nint clipshift = 0;\nXImage *XCreateImage_wr(Display *disp, Visual *visual, unsigned int depth,\n    int format, int offset, char *data, unsigned int width,\n    unsigned int height, int bitmap_pad, int bytes_per_line);\nvoid copy_image(XImage *dest, int x, int y, unsigned int w, unsigned int h);\nBool XTestCompareCurrentCursorWithWindow_wr(Display* dpy, Window w);\nint XFree_wr(void *data);\nvoid copy_raw_fb(XImage *dest, int x, int y, unsigned int w, unsigned int h);\n\nvoid copy_raw_fb(XImage *dest, int x, int y, unsigned int w, unsigned int h) {\n\tchar *src, *dst;\n\tunsigned int line;\n\tint pixelsize = bpp/8;\n\tstatic int db = -1;\n\n#ifdef MACOSX\n\tif (macosx_console && macosx_read_opengl) {\n\t\tmacosx_copy_opengl(dest->data, x, y, w, h);\n\t\treturn;\n\t}\n#endif\n\n\tif (xform24to32) {\n\t\tcopy_raw_fb_24_to_32(dest, x, y, w, h);\n\t\treturn;\n\t}\n\tif (raw_fb_native_bpp < 8) {\n\t\tcopy_raw_fb_low_bpp(dest, x, y, w, h);\n\t\treturn;\n\t}\n\tif (db < 0) {\n\t\tif (getenv(\"DEBUG_COPY_RAW_FB\")) {\n\t\t\tdb = atoi(getenv(\"DEBUG_COPY_RAW_FB\"));\n\t\t} else {\n\t\t\tdb = 0;\n\t\t}\n\t}\n\n\tif (clipshift && ! use_snapfb) {\n\t\tx += coff_x;\n\t\ty += coff_y;\n\t}\n\n\n\tif (use_snapfb && dest != snap) {\n\t\t/* snapfb src */\n\t\tsrc = snap->data + snap->bytes_per_line*y + pixelsize*x;\n\t\tdst = dest->data;\n\nif (db) fprintf(stderr, \"snap->bytes_per_line: %d, dest->bytes_per_line: %d, w: %d h: %d dpy_x: %d wdpy_x: %d cdpy_x: %d bpp: %d pixelsize: %d\\n\", snap->bytes_per_line, dest->bytes_per_line, w, h, dpy_x, wdpy_x, cdpy_x, bpp, pixelsize);\n\n\t\tfor (line = 0; line < h; line++) {\n\t\t\tmemcpy(dst, src, w * pixelsize);\n\t\t\tsrc += snap->bytes_per_line;\n\t\t\tdst += dest->bytes_per_line;\n\t\t}\n\n\t} else if (! raw_fb_seek) {\n\t\t/* mmap */\n\t\tint bpl = raw_fb_bytes_per_line;\n\n\t\tif (clipshift && wdpy_x != cdpy_x) {\n\t\t\tbpl = wdpy_x * pixelsize;\n\t\t}\n\n\t\tsrc = raw_fb_addr + raw_fb_offset + bpl*y + pixelsize*x;\n\t\tdst = dest->data;\n\nif (db) fprintf(stderr, \"bpl: %d, dest->bytes_per_line: %d, w: %d h: %d dpy_x: %d wdpy_x: %d cdpy_x: %d bpp: %d pixelsize: %d\\n\", bpl, dest->bytes_per_line, w, h, dpy_x, wdpy_x, cdpy_x, bpp, pixelsize);\n\n\t\tfor (line = 0; line < h; line++) {\n\t\t\tmemcpy(dst, src, w * pixelsize);\n\t\t\tsrc += bpl;\n\t\t\tdst += dest->bytes_per_line;\n\t\t}\n\n\t} else {\n\t\t/* lseek */\n\t\tint n, len, del, sz = w * pixelsize;\n\t\toff_t off;\n\t\tint bpl = raw_fb_bytes_per_line;\n\n\t\tif (clipshift && wdpy_x != cdpy_x) {\n\t\t\tbpl = wdpy_x * pixelsize;\n\t\t}\n\n\t\toff = (off_t) (raw_fb_offset + bpl*y + pixelsize*x);\n\n\t\tlseek(raw_fb_fd, off, SEEK_SET);\n\t\tdst = dest->data;\n\nif (db) fprintf(stderr, \"lseek 0 ps: %d  sz: %d off: %d bpl: %d\\n\", pixelsize, sz, (int) off, bpl);\n\n\t\tfor (line = 0; line < h; line++) {\n\t\t\tlen = sz;\n\t\t\tdel = 0;\n\t\t\twhile (len > 0) {\n\t\t\t\tn = read(raw_fb_fd, dst + del, len);\n\n\t\t\t\tif (n > 0) {\n\t\t\t\t\tdel += n;\n\t\t\t\t\tlen -= n;\n\t\t\t\t} else if (n == 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (errno != EINTR && errno != EAGAIN) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (bpl > sz) {\n\t\t\t\toff = (off_t) (bpl - sz);\n\t\t\t\tlseek(raw_fb_fd, off, SEEK_CUR);\n\t\t\t}\n\t\t\tdst += dest->bytes_per_line;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "snap_all_rawfb",
          "args": [],
          "line": 2772
        },
        "resolved": true,
        "details": {
          "function_name": "snap_all_rawfb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/scan.c",
          "lines": "2677-2740",
          "snippet": "static void snap_all_rawfb(void) {\n\tint pixelsize = bpp/8;\n\tint n, sz;\n\tchar *dst;\n\tstatic char *unclipped_dst = NULL;\n\tstatic int unclipped_len = 0;\n\n\tdst = snap->data;\n\n\tif (xform24to32 && bpp == 32) {\n\t\tpixelsize = 3;\n\t}\n\tsz = dpy_y * snap->bytes_per_line;\n\n\tif (wdpy_x > dpy_x || wdpy_y > dpy_y) {\n\t\tsz = wdpy_x * wdpy_y * pixelsize;\n\t\tif (sz > unclipped_len || unclipped_dst == NULL) {\n\t\t\tif (unclipped_dst) {\n\t\t\t\tfree(unclipped_dst);\n\t\t\t}\n\t\t\tunclipped_dst = (char *) malloc(sz+4);\n\t\t\tunclipped_len = sz;\n\t\t}\n\t\tdst = unclipped_dst;\n\t}\n\t\t\n\tif (! raw_fb_seek) {\n\t\tmemcpy(dst, raw_fb_addr + raw_fb_offset, sz);\n\n\t} else {\n\t\tint len = sz, del = 0;\n\t\toff_t off = (off_t) raw_fb_offset;\n\n\t\tlseek(raw_fb_fd, off, SEEK_SET);\n\t\twhile (len > 0) {\n\t\t\tn = read(raw_fb_fd, dst + del, len);\n\t\t\tif (n > 0) {\n\t\t\t\tdel += n;\n\t\t\t\tlen -= n;\n\t\t\t} else if (n == 0) {\n\t\t\t\tbreak;\n\t\t\t} else if (errno != EINTR && errno != EAGAIN) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (dst == unclipped_dst) {\n\t\tchar *src;\n\t\tint h;\n\t\tint x = off_x + coff_x;\n\t\tint y = off_y + coff_y;\n\n\t\tsrc = unclipped_dst + y * wdpy_x * pixelsize +\n\t\t    x * pixelsize;\n\t\tdst = snap->data;\n\n\t\tfor (h = 0; h < dpy_y; h++) {\n\t\t\tmemcpy(dst, src, dpy_x * pixelsize);\n\t\t\tsrc += wdpy_x * pixelsize;\n\t\t\tdst += snap->bytes_per_line;\n\t\t}\n\t}\n}",
          "includes": [
            "#include <default8x16.h>",
            "#include \"userinput.h\"",
            "#include \"macosx.h\"",
            "#include \"screen.h\"",
            "#include \"unixpw.h\"",
            "#include \"cleanup.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"8to24.h\"",
            "#include \"win_utils.h\"",
            "#include \"xrandr.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int blackout_line_cmpskip(int n, int x, int y, char *dst, char *src,\n    int w, int pixelsize);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <default8x16.h>\n#include \"userinput.h\"\n#include \"macosx.h\"\n#include \"screen.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"8to24.h\"\n#include \"win_utils.h\"\n#include \"xrandr.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nstatic int blackout_line_cmpskip(int n, int x, int y, char *dst, char *src,\n    int w, int pixelsize);\n\nstatic void snap_all_rawfb(void) {\n\tint pixelsize = bpp/8;\n\tint n, sz;\n\tchar *dst;\n\tstatic char *unclipped_dst = NULL;\n\tstatic int unclipped_len = 0;\n\n\tdst = snap->data;\n\n\tif (xform24to32 && bpp == 32) {\n\t\tpixelsize = 3;\n\t}\n\tsz = dpy_y * snap->bytes_per_line;\n\n\tif (wdpy_x > dpy_x || wdpy_y > dpy_y) {\n\t\tsz = wdpy_x * wdpy_y * pixelsize;\n\t\tif (sz > unclipped_len || unclipped_dst == NULL) {\n\t\t\tif (unclipped_dst) {\n\t\t\t\tfree(unclipped_dst);\n\t\t\t}\n\t\t\tunclipped_dst = (char *) malloc(sz+4);\n\t\t\tunclipped_len = sz;\n\t\t}\n\t\tdst = unclipped_dst;\n\t}\n\t\t\n\tif (! raw_fb_seek) {\n\t\tmemcpy(dst, raw_fb_addr + raw_fb_offset, sz);\n\n\t} else {\n\t\tint len = sz, del = 0;\n\t\toff_t off = (off_t) raw_fb_offset;\n\n\t\tlseek(raw_fb_fd, off, SEEK_SET);\n\t\twhile (len > 0) {\n\t\t\tn = read(raw_fb_fd, dst + del, len);\n\t\t\tif (n > 0) {\n\t\t\t\tdel += n;\n\t\t\t\tlen -= n;\n\t\t\t} else if (n == 0) {\n\t\t\t\tbreak;\n\t\t\t} else if (errno != EINTR && errno != EAGAIN) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (dst == unclipped_dst) {\n\t\tchar *src;\n\t\tint h;\n\t\tint x = off_x + coff_x;\n\t\tint y = off_y + coff_y;\n\n\t\tsrc = unclipped_dst + y * wdpy_x * pixelsize +\n\t\t    x * pixelsize;\n\t\tdst = snap->data;\n\n\t\tfor (h = 0; h < dpy_y; h++) {\n\t\t\tmemcpy(dst, src, dpy_x * pixelsize);\n\t\t\tsrc += wdpy_x * pixelsize;\n\t\t\tdst += snap->bytes_per_line;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "snap_vcsa_rawfb",
          "args": [],
          "line": 2770
        },
        "resolved": true,
        "details": {
          "function_name": "snap_vcsa_rawfb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/scan.c",
          "lines": "2486-2675",
          "snippet": "static void snap_vcsa_rawfb(void) {\n\tint n;\n\tchar *dst;\n\tchar buf[32];\n\tint i, len, del;\n\tunsigned char rows, cols, xpos, ypos;\n\tstatic int prev_rows = -1, prev_cols = -1;\n\tstatic unsigned char prev_xpos = -1, prev_ypos = -1;\n\tstatic char *vcsabuf  = NULL;\n\tstatic char *vcsabuf0 = NULL;\n\tstatic unsigned int color_tab[16];\n\tstatic int Cw = 8, Ch = 16;\n\tstatic int db = -1, first = 1;\n\tint created = 0;\n\trfbScreenInfo s;\n\trfbScreenInfoPtr fake_screen = &s;\n\tint Bpp = raw_fb_native_bpp / 8;\n\n\tif (db < 0) {\n\t\tif (getenv(\"X11VNC_DEBUG_VCSA\")) {\n\t\t\tdb = atoi(getenv(\"X11VNC_DEBUG_VCSA\"));\n\t\t} else {\n\t\t\tdb = 0;\n\t\t}\n\t}\n\n\tif (first) {\n\t\tunsigned int rm = raw_fb_native_red_mask;\n\t\tunsigned int gm = raw_fb_native_green_mask;\n\t\tunsigned int bm = raw_fb_native_blue_mask;\n\t\tunsigned int rs = raw_fb_native_red_shift;\n\t\tunsigned int gs = raw_fb_native_green_shift;\n\t\tunsigned int bs = raw_fb_native_blue_shift;\n\t\tunsigned int rx = raw_fb_native_red_max;\n\t\tunsigned int gx = raw_fb_native_green_max;\n\t\tunsigned int bx = raw_fb_native_blue_max;\n\n\t\tfor (i=0; i < 16; i++) {\n\t\t\tint r = console_cmap[3*i+0];\n\t\t\tint g = console_cmap[3*i+1];\n\t\t\tint b = console_cmap[3*i+2];\n\t\t\tr = rx * r / 255;\n\t\t\tg = gx * g / 255;\n\t\t\tb = bx * b / 255;\n\t\t\tcolor_tab[i] = (r << rs) | (g << gs) | (b << bs);\n\t\t\tif (db) fprintf(stderr, \"cmap[%02d] 0x%08x  %04d %04d %04d\\n\", i, color_tab[i], r, g, b); \n\t\t\tif (i != 0 && getenv(\"RAWFB_VCSA_BW\")) {\n\t\t\t\tcolor_tab[i] = rm | gm | bm;\n\t\t\t}\n\t\t}\n\t}\n\tfirst = 0;\n\n\tlseek(raw_fb_fd, 0, SEEK_SET);\n\tlen = 4;\n\tdel = 0;\n\tmemset(buf, 0, sizeof(buf));\n\twhile (len > 0) {\n\t\tn = read(raw_fb_fd, buf + del, len);\n\t\tif (n > 0) {\n\t\t\tdel += n;\n\t\t\tlen -= n;\n\t\t} else if (n == 0) {\n\t\t\tbreak;\n\t\t} else if (errno != EINTR && errno != EAGAIN) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\trows = (unsigned char) buf[0];\n\tcols = (unsigned char) buf[1];\n\txpos = (unsigned char) buf[2];\n\typos = (unsigned char) buf[3];\n\n\tif (db) fprintf(stderr, \"rows=%d cols=%d xpos=%d ypos=%d Bpp=%d\\n\", rows, cols, xpos, ypos, Bpp);\n\tif (rows == 0 || cols == 0) {\n\t\tusleep(100 * 1000);\n\t\treturn;\n\t}\n\n\tif (vcsabuf == NULL || prev_rows != rows || prev_cols != cols) {\n\t\tif (vcsabuf) {\n\t\t\tfree(vcsabuf);\n\t\t\tfree(vcsabuf0);\n\t\t}\n\t\tvcsabuf  = (char *) calloc(2 * rows * cols, 1);\n\t\tvcsabuf0 = (char *) calloc(2 * rows * cols, 1);\n\t\tcreated = 1;\n\n\t\tif (prev_rows != -1 && prev_cols != -1) {\n\t\t\tdo_new_fb(1);\n\t\t}\n\n\t\tprev_rows = rows;\n\t\tprev_cols = cols;\n\t}\n\n\tif (!rfbEndianTest) {\n\t\tunsigned char tc = rows;\n\t\trows = cols;\n\t\tcols = tc;\n\n\t\ttc = xpos;\n\t\txpos = ypos;\n\t\typos = tc;\n\t}\n\n\tlen = 2 * rows * cols;\n\tdel = 0;\n\tmemset(vcsabuf, 0, len);\n\twhile (len > 0) {\n\t\tn = read(raw_fb_fd, vcsabuf + del, len);\n\t\tif (n > 0) {\n\t\t\tdel += n;\n\t\t\tlen -= n;\n\t\t} else if (n == 0) {\n\t\t\tbreak;\n\t\t} else if (errno != EINTR && errno != EAGAIN) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfake_screen->frameBuffer = snap->data;\n\tfake_screen->paddedWidthInBytes = snap->bytes_per_line;\n\tfake_screen->serverFormat.bitsPerPixel = raw_fb_native_bpp;\n\tfake_screen->width = snap->width;\n\tfake_screen->height = snap->height;\n\n\tfor (i=0; i < rows * cols; i++) {\n\t\tint ix, iy, x, y, w, h;\n\t\tunsigned char chr = 0;\n\t\tunsigned char attr;\n\t\tunsigned int fore, back;\n\t\tunsigned short *usp;\n\t\tunsigned int *uip;\n\t\tchr  = (unsigned char) vcsabuf[2*i];\n\t\tattr = vcsabuf[2*i+1];\n\n\t\tiy = i / cols;\n\t\tix = i - iy * cols;\n\n\t\tif (ix == prev_xpos && iy == prev_ypos) {\n\t\t\t;\n\t\t} else if (ix == xpos && iy == ypos) {\n\t\t\t;\n\t\t} else if (!created && chr == vcsabuf0[2*i] && attr == vcsabuf0[2*i+1]) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!rfbEndianTest) {\n\t\t\tunsigned char tc = chr;\n\t\t\tchr = attr;\n\t\t\tattr = tc;\n\t\t}\n\n\t\ty = iy * Ch;\n\t\tx = ix * Cw;\n\t\tdst = snap->data + y * snap->bytes_per_line + x * Bpp;\n\n\t\tfore = color_tab[attr & 0xf];\n\t\tback = color_tab[(attr >> 4) & 0x7];\n\n\t\tif (ix == xpos && iy == ypos) {\n\t\t\tunsigned int ti = fore;\n\t\t\tfore = back;\n\t\t\tback = ti;\n\t\t}\n\n\t\tfor (h = 0; h < Ch; h++) {\n\t\t\tif (Bpp == 1) {\n\t\t\t\tmemset(dst, back, Cw);\n\t\t\t} else if (Bpp == 2) {\n\t\t\t\tfor (w = 0; w < Cw; w++) {\n\t\t\t\t\tusp = (unsigned short *) (dst + w*Bpp); \n\t\t\t\t\t*usp = (unsigned short) back;\n\t\t\t\t}\n\t\t\t} else if (Bpp == 4) {\n\t\t\t\tfor (w = 0; w < Cw; w++) {\n\t\t\t\t\tuip = (unsigned int *) (dst + w*Bpp); \n\t\t\t\t\t*uip = (unsigned int) back;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdst += snap->bytes_per_line;\n\t\t}\n\t\trfbDrawChar(fake_screen, &default8x16Font, x, y + Ch, chr, fore);\n\t}\n\tmemcpy(vcsabuf0, vcsabuf, 2 * rows * cols); \n\tprev_xpos = xpos;\n\tprev_ypos = ypos;\n}",
          "includes": [
            "#include <default8x16.h>",
            "#include \"userinput.h\"",
            "#include \"macosx.h\"",
            "#include \"screen.h\"",
            "#include \"unixpw.h\"",
            "#include \"cleanup.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"8to24.h\"",
            "#include \"win_utils.h\"",
            "#include \"xrandr.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void rotate_curs(char *dst_0, char *src_0, int Dx, int Dy, int Bpp);",
            "static unsigned char console_cmap[16*3]={\n/*  0 */\t0x00, 0x00, 0x00,\n/*  1 */\t0x00, 0x00, 0xAA,\n/*  2 */\t0x00, 0xAA, 0x00,\n/*  3 */\t0x00, 0xAA, 0xAA,\n/*  4 */\t0xAA, 0x00, 0x00,\n/*  5 */\t0xAA, 0x00, 0xAA,\n/*  6 */\t0xAA, 0x55, 0x00,\n/*  7 */\t0xAA, 0xAA, 0xAA,\n/*  8 */\t0x55, 0x55, 0x55,\n/*  9 */\t0x55, 0x55, 0xAA,\n/* 10 */\t0x55, 0xFF, 0x55,\n/* 11 */\t0x55, 0xFF, 0xFF,\n/* 12 */\t0xFF, 0x55, 0x55,\n/* 13 */\t0xFF, 0x55, 0xFF,\n/* 14 */\t0xFF, 0xFF, 0x00,\n/* 15 */\t0xFF, 0xFF, 0xFF\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <default8x16.h>\n#include \"userinput.h\"\n#include \"macosx.h\"\n#include \"screen.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"8to24.h\"\n#include \"win_utils.h\"\n#include \"xrandr.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nvoid rotate_curs(char *dst_0, char *src_0, int Dx, int Dy, int Bpp);\nstatic unsigned char console_cmap[16*3]={\n/*  0 */\t0x00, 0x00, 0x00,\n/*  1 */\t0x00, 0x00, 0xAA,\n/*  2 */\t0x00, 0xAA, 0x00,\n/*  3 */\t0x00, 0xAA, 0xAA,\n/*  4 */\t0xAA, 0x00, 0x00,\n/*  5 */\t0xAA, 0x00, 0xAA,\n/*  6 */\t0xAA, 0x55, 0x00,\n/*  7 */\t0xAA, 0xAA, 0xAA,\n/*  8 */\t0x55, 0x55, 0x55,\n/*  9 */\t0x55, 0x55, 0xAA,\n/* 10 */\t0x55, 0xFF, 0x55,\n/* 11 */\t0x55, 0xFF, 0xFF,\n/* 12 */\t0xFF, 0x55, 0x55,\n/* 13 */\t0xFF, 0x55, 0xFF,\n/* 14 */\t0xFF, 0xFF, 0x00,\n/* 15 */\t0xFF, 0xFF, 0xFF\n};\n\nstatic void snap_vcsa_rawfb(void) {\n\tint n;\n\tchar *dst;\n\tchar buf[32];\n\tint i, len, del;\n\tunsigned char rows, cols, xpos, ypos;\n\tstatic int prev_rows = -1, prev_cols = -1;\n\tstatic unsigned char prev_xpos = -1, prev_ypos = -1;\n\tstatic char *vcsabuf  = NULL;\n\tstatic char *vcsabuf0 = NULL;\n\tstatic unsigned int color_tab[16];\n\tstatic int Cw = 8, Ch = 16;\n\tstatic int db = -1, first = 1;\n\tint created = 0;\n\trfbScreenInfo s;\n\trfbScreenInfoPtr fake_screen = &s;\n\tint Bpp = raw_fb_native_bpp / 8;\n\n\tif (db < 0) {\n\t\tif (getenv(\"X11VNC_DEBUG_VCSA\")) {\n\t\t\tdb = atoi(getenv(\"X11VNC_DEBUG_VCSA\"));\n\t\t} else {\n\t\t\tdb = 0;\n\t\t}\n\t}\n\n\tif (first) {\n\t\tunsigned int rm = raw_fb_native_red_mask;\n\t\tunsigned int gm = raw_fb_native_green_mask;\n\t\tunsigned int bm = raw_fb_native_blue_mask;\n\t\tunsigned int rs = raw_fb_native_red_shift;\n\t\tunsigned int gs = raw_fb_native_green_shift;\n\t\tunsigned int bs = raw_fb_native_blue_shift;\n\t\tunsigned int rx = raw_fb_native_red_max;\n\t\tunsigned int gx = raw_fb_native_green_max;\n\t\tunsigned int bx = raw_fb_native_blue_max;\n\n\t\tfor (i=0; i < 16; i++) {\n\t\t\tint r = console_cmap[3*i+0];\n\t\t\tint g = console_cmap[3*i+1];\n\t\t\tint b = console_cmap[3*i+2];\n\t\t\tr = rx * r / 255;\n\t\t\tg = gx * g / 255;\n\t\t\tb = bx * b / 255;\n\t\t\tcolor_tab[i] = (r << rs) | (g << gs) | (b << bs);\n\t\t\tif (db) fprintf(stderr, \"cmap[%02d] 0x%08x  %04d %04d %04d\\n\", i, color_tab[i], r, g, b); \n\t\t\tif (i != 0 && getenv(\"RAWFB_VCSA_BW\")) {\n\t\t\t\tcolor_tab[i] = rm | gm | bm;\n\t\t\t}\n\t\t}\n\t}\n\tfirst = 0;\n\n\tlseek(raw_fb_fd, 0, SEEK_SET);\n\tlen = 4;\n\tdel = 0;\n\tmemset(buf, 0, sizeof(buf));\n\twhile (len > 0) {\n\t\tn = read(raw_fb_fd, buf + del, len);\n\t\tif (n > 0) {\n\t\t\tdel += n;\n\t\t\tlen -= n;\n\t\t} else if (n == 0) {\n\t\t\tbreak;\n\t\t} else if (errno != EINTR && errno != EAGAIN) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\trows = (unsigned char) buf[0];\n\tcols = (unsigned char) buf[1];\n\txpos = (unsigned char) buf[2];\n\typos = (unsigned char) buf[3];\n\n\tif (db) fprintf(stderr, \"rows=%d cols=%d xpos=%d ypos=%d Bpp=%d\\n\", rows, cols, xpos, ypos, Bpp);\n\tif (rows == 0 || cols == 0) {\n\t\tusleep(100 * 1000);\n\t\treturn;\n\t}\n\n\tif (vcsabuf == NULL || prev_rows != rows || prev_cols != cols) {\n\t\tif (vcsabuf) {\n\t\t\tfree(vcsabuf);\n\t\t\tfree(vcsabuf0);\n\t\t}\n\t\tvcsabuf  = (char *) calloc(2 * rows * cols, 1);\n\t\tvcsabuf0 = (char *) calloc(2 * rows * cols, 1);\n\t\tcreated = 1;\n\n\t\tif (prev_rows != -1 && prev_cols != -1) {\n\t\t\tdo_new_fb(1);\n\t\t}\n\n\t\tprev_rows = rows;\n\t\tprev_cols = cols;\n\t}\n\n\tif (!rfbEndianTest) {\n\t\tunsigned char tc = rows;\n\t\trows = cols;\n\t\tcols = tc;\n\n\t\ttc = xpos;\n\t\txpos = ypos;\n\t\typos = tc;\n\t}\n\n\tlen = 2 * rows * cols;\n\tdel = 0;\n\tmemset(vcsabuf, 0, len);\n\twhile (len > 0) {\n\t\tn = read(raw_fb_fd, vcsabuf + del, len);\n\t\tif (n > 0) {\n\t\t\tdel += n;\n\t\t\tlen -= n;\n\t\t} else if (n == 0) {\n\t\t\tbreak;\n\t\t} else if (errno != EINTR && errno != EAGAIN) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfake_screen->frameBuffer = snap->data;\n\tfake_screen->paddedWidthInBytes = snap->bytes_per_line;\n\tfake_screen->serverFormat.bitsPerPixel = raw_fb_native_bpp;\n\tfake_screen->width = snap->width;\n\tfake_screen->height = snap->height;\n\n\tfor (i=0; i < rows * cols; i++) {\n\t\tint ix, iy, x, y, w, h;\n\t\tunsigned char chr = 0;\n\t\tunsigned char attr;\n\t\tunsigned int fore, back;\n\t\tunsigned short *usp;\n\t\tunsigned int *uip;\n\t\tchr  = (unsigned char) vcsabuf[2*i];\n\t\tattr = vcsabuf[2*i+1];\n\n\t\tiy = i / cols;\n\t\tix = i - iy * cols;\n\n\t\tif (ix == prev_xpos && iy == prev_ypos) {\n\t\t\t;\n\t\t} else if (ix == xpos && iy == ypos) {\n\t\t\t;\n\t\t} else if (!created && chr == vcsabuf0[2*i] && attr == vcsabuf0[2*i+1]) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!rfbEndianTest) {\n\t\t\tunsigned char tc = chr;\n\t\t\tchr = attr;\n\t\t\tattr = tc;\n\t\t}\n\n\t\ty = iy * Ch;\n\t\tx = ix * Cw;\n\t\tdst = snap->data + y * snap->bytes_per_line + x * Bpp;\n\n\t\tfore = color_tab[attr & 0xf];\n\t\tback = color_tab[(attr >> 4) & 0x7];\n\n\t\tif (ix == xpos && iy == ypos) {\n\t\t\tunsigned int ti = fore;\n\t\t\tfore = back;\n\t\t\tback = ti;\n\t\t}\n\n\t\tfor (h = 0; h < Ch; h++) {\n\t\t\tif (Bpp == 1) {\n\t\t\t\tmemset(dst, back, Cw);\n\t\t\t} else if (Bpp == 2) {\n\t\t\t\tfor (w = 0; w < Cw; w++) {\n\t\t\t\t\tusp = (unsigned short *) (dst + w*Bpp); \n\t\t\t\t\t*usp = (unsigned short) back;\n\t\t\t\t}\n\t\t\t} else if (Bpp == 4) {\n\t\t\t\tfor (w = 0; w < Cw; w++) {\n\t\t\t\t\tuip = (unsigned int *) (dst + w*Bpp); \n\t\t\t\t\t*uip = (unsigned int) back;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdst += snap->bytes_per_line;\n\t\t}\n\t\trfbDrawChar(fake_screen, &default8x16Font, x, y + Ch, chr, fore);\n\t}\n\tmemcpy(vcsabuf0, vcsabuf, 2 * rows * cols); \n\tprev_xpos = xpos;\n\tprev_ypos = ypos;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "raw_fb_full_str",
            "\"/dev/vcsa\""
          ],
          "line": 2769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "initialize_raw_fb",
          "args": [
            "1"
          ],
          "line": 2764
        },
        "resolved": true,
        "details": {
          "function_name": "initialize_raw_fb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/screen.c",
          "lines": "1640-2395",
          "snippet": "XImage *initialize_raw_fb(int reset) {\n\tchar *str, *rstr, *q;\n\tint w, h, b, shmid = 0;\n\tunsigned long rm = 0, gm = 0, bm = 0, tm;\n\tstatic XImage ximage_struct;\t/* n.b.: not (XImage *) */\n\tstatic XImage ximage_struct_snap;\n\tint closedpy = 1, i, m, db = 0;\n\tint do_macosx = 0;\n\tint do_reflect = 0;\n\tchar *unlink_me = NULL;\n\n\tstatic char *last_file = NULL;\n\tstatic int last_mode = 0;\n\n\tif (reset && last_mode) {\n\t\tint fd;\n\t\tif (last_mode != RAWFB_MMAP && last_mode != RAWFB_FILE) {\n\t\t\treturn NULL;\n\t\t}\n\t\tif (last_mode == RAWFB_MMAP) {\n\t\t\tmunmap(raw_fb_addr, raw_fb_mmap);\n\t\t}\n\t\tif (raw_fb_fd >= 0) {\n\t\t\tclose(raw_fb_fd);\n\t\t}\n\t\traw_fb_fd = -1;\nif (db) fprintf(stderr, \"initialize_raw_fb reset\\n\");\n\t\t\t\n\t\tfd = -1;\n\t\tif (rawfb_dev_video) {\n\t\t\tfd = open(last_file, O_RDWR);\n\t\t}\n\t\tif (fd < 0) {\n\t\t\tfd = open(last_file, O_RDONLY);\n\t\t}\n\t\tif (fd < 0) {\n\t\t\trfbLogEnable(1);\n\t\t\trfbLog(\"failed to rawfb file: %s\\n\", last_file);\n\t\t\trfbLogPerror(\"open\");\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\traw_fb_fd = fd;\n\t\tif (last_mode == RAWFB_MMAP) {\n\t\t\traw_fb_addr = mmap(0, raw_fb_mmap, PROT_READ,\n\t\t\t    MAP_SHARED, fd, 0);\n\n\t\t\tif (raw_fb_addr == MAP_FAILED || raw_fb_addr == NULL) {\n\t\t\t\trfbLogEnable(1);\n\t\t\t\trfbLog(\"failed to mmap file: %s\\n\", last_file);\n\t\t\t\trfbLog(\"   raw_fb_addr: %p\\n\", raw_fb_addr);\n\t\t\t\trfbLogPerror(\"mmap\");\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t}\n\t\treturn NULL;\n\t}\n\n#ifdef MACOSX\n\tif (raw_fb_addr != NULL && macosx_console && raw_fb_addr == macosx_get_fb_addr()) {\n\t\traw_fb_addr = NULL;\n\t}\n#endif\n\n\tif (raw_fb_addr || raw_fb_seek) {\n\t\tif (raw_fb_shm) {\n\t\t\tshmdt(raw_fb_addr);\n#if LIBVNCSERVER_HAVE_MMAP\n\t\t} else if (raw_fb_mmap) {\n\t\t\tmunmap(raw_fb_addr, raw_fb_mmap);\n\t\t\tif (raw_fb_fd >= 0) {\n\t\t\t\tclose(raw_fb_fd);\n\t\t\t}\n\t\t\traw_fb_fd = -1;\n#endif\n\t\t} else if (raw_fb_seek) {\n\t\t\tif (raw_fb_fd >= 0) {\n\t\t\t\tclose(raw_fb_fd);\n\t\t\t}\n\t\t\traw_fb_fd = -1;\n\t\t}\n\t\traw_fb_addr = NULL;\n\t\traw_fb_mmap = 0;\n\t\traw_fb_seek = 0;\n\t}\n\tif (! raw_fb_str) {\n\t\treturn NULL;\n\t}\n\n\tif (raw_fb_str[0] == '+') {\n\t\trstr = strdup(raw_fb_str+1);\n\t\tclosedpy = 0;\n\t\tif (! window) {\n\t\t\twindow = rootwin;\n\t\t}\n\t} else {\n\t\trstr = strdup(raw_fb_str);\n\t}\n\n\t/* testing aliases */\n\tif (!strcasecmp(rstr, \"NULL\") || !strcasecmp(rstr, \"ZERO\")\n\t    || !strcasecmp(rstr, \"NONE\")) {\n\t\trstr = strdup(\"map:/dev/zero@640x480x32\");\n\t} else if (!strcasecmp(rstr, \"NULLBIG\") || !strcasecmp(rstr, \"NONEBIG\")) {\n\t\trstr = strdup(\"map:/dev/zero@1024x768x32\");\n\t}\n\tif (!strcasecmp(rstr, \"RAND\")) {\n\t\trstr = strdup(\"file:/dev/urandom@128x128x16\");\n\t} else if (!strcasecmp(rstr, \"RANDBIG\")) {\n\t\trstr = strdup(\"file:/dev/urandom@640x480x16\");\n\t} else if (!strcasecmp(rstr, \"RANDHUGE\")) {\n\t\trstr = strdup(\"file:/dev/urandom@1024x768x16\");\n\t}\n\tif (strstr(rstr, \"solid=\") == rstr) {\n\t\tchar *n = rstr + strlen(\"solid=\");\n\t\tchar tmp[] = \"/tmp/rawfb_solid.XXXXXX\";\n\t\tchar str[100];\n\t\tunsigned int vals[1024], val;\n\t\tint x, y, fd, w = 1024, h = 768;\n\t\tif (strstr(n, \"0x\")) {\n\t\t\tif (sscanf(n, \"0x%x\", &val) != 1) {\n\t\t\t\tval = 0;\n\t\t\t}\n\t\t}\n\t\tif (val == 0) {\n\t\t\tval = get_pixel(n);\n\t\t}\n\t\tif (val == 0) {\n\t\t\tval = 0xFF00FF;\n\t\t}\n\t\tfd = mkstemp(tmp);\n\t\tfor (y = 0; y < h; y++) {\n\t\t\tfor (x = 0; x < w; x++) {\n\t\t\t\tvals[x] = val;\n\t\t\t}\n\t\t\twrite(fd, (char *)vals, 4 * w);\n\t\t}\n\t\tclose(fd);\n\t\tfd = open(tmp, O_WRONLY);\n\t\tunlink_me = strdup(tmp);\n\t\tsprintf(str, \"map:%s@%dx%dx32\", tmp, w, h);\n\t\trstr = strdup(str);\n\t} else if (strstr(rstr, \"swirl\") == rstr) {\n\t\tchar tmp[] = \"/tmp/rawfb_swirl.XXXXXX\";\n\t\tchar str[100];\n\t\tunsigned int val[1024];\n\t\tunsigned int c1, c2, c3, c4;\n\t\tint x, y, fd, w = 1024, h = 768;\n\t\tfd = mkstemp(tmp);\n\t\tfor (y = 0; y < h; y++) {\n\t\t\tfor (x = 0; x < w; x++) {\n\t\t\t\tc1 = 0;\n\t\t\t\tc2 = ((x+y)*128)/(w+h);\n\t\t\t\tc3 = (x*128)/w;\n\t\t\t\tc4 = (y*256)/h;\n\t\t\t\tval[x] = (c1 << 24) | (c2 << 16) | (c3 << 8) | (c4 << 0);\n\t\t\t}\n\t\t\twrite(fd, (char *)val, 4 * w);\n\t\t}\n\t\tclose(fd);\n\t\tfd = open(tmp, O_WRONLY);\n\t\tunlink_me = strdup(tmp);\n\t\tsprintf(str, \"map:%s@%dx%dx32\", tmp, w, h);\n\t\trstr = strdup(str);\n\t}\n\n\n\tif ( (q = strstr(rstr, \"setup:\")) == rstr) {\n\t\tFILE *pipe;\n\t\tchar line[1024], *t;\n\n\t\tset_child_info();\n\t\tq += strlen(\"setup:\");\n\t\t/* rawfb-setup */\n\t\tif (no_external_cmds || !cmd_ok(\"rawfb-setup\")) {\n\t\t\trfbLogEnable(1);\n\t\t\trfbLog(\"cannot run external commands in -nocmds \"\n\t\t\t    \"mode:\\n\");\n\t\t\trfbLog(\"   \\\"%s\\\"\\n\", q);\n\t\t\trfbLog(\"   exiting.\\n\");\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\trfbLog(\"running command to setup rawfb: %s\\n\", q);\n\t\tclose_exec_fds();\n\t\tpipe = popen(q, \"r\");\n\t\tif (! pipe) {\n\t\t\trfbLogEnable(1);\n\t\t\trfbLog(\"popen of setup command failed.\\n\");\n\t\t\trfbLogPerror(\"popen\");\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tline[0] = '\\0';\n\t\tif (fgets(line, 1024, pipe) == NULL) {\n\t\t\trfbLogEnable(1);\n\t\t\trfbLog(\"read of setup command failed.\\n\");\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tpclose(pipe);\n\t\tstr = strdup(line);\n\t\tt = str;\n\t\twhile (*t != '\\0') {\n\t\t\tif (*t == '\\n') {\n\t\t\t\t*t = '\\0';\n\t\t\t}\n\t\t\tt++;\n\t\t}\n\t\trfbLog(\"setup command returned: %s\\n\", str);\n\n\t} else {\n\t\tstr = strdup(rstr);\n\t}\n\n\traw_fb_shm = 0;\n\traw_fb_mmap = 0;\n\traw_fb_seek = 0;\n\traw_fb_fd = -1;\n\traw_fb_addr = NULL;\n\traw_fb_offset = 0;\n\traw_fb_bytes_per_line = 0;\n\trawfb_vnc_reflect = 0;\n\n\tlast_mode = 0;\n\tif (last_file) {\n\t\tfree(last_file);\n\t\tlast_file = NULL;\n\t}\n\tif (strstr(str, \"Video\") == str) {\n\t\tif (pipeinput_str != NULL) {\n\t\t\tfree(pipeinput_str);\n\t\t}\n\t\tpipeinput_str = strdup(\"VID\");\n\t\tinitialize_pipeinput();\n\t\tstr[0] = 'v';\n\t}\n\n\tif (strstr(str, \"video\") == str || strstr(str, \"/dev/video\") == str) {\n\t\tchar *str2 = v4l_guess(str, &raw_fb_fd);\n\t\tif (str2 == NULL) {\n\t\t\trfbLog(\"v4l_guess failed for: %s\\n\", str);\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tstr = str2;\n\t\trfbLog(\"v4l_guess returned: %s\\n\", str);\n\t\trawfb_dev_video = 1;\n\t} else if (strstr(str, \"dev/video\")) {\n\t\trawfb_dev_video = 1;\n\t} else if (strstr(str, \"console\") == str || strstr(str, \"fb\") == str ||\n\t    strstr(str, \"/dev/fb\") == str || strstr(str, \"vt\") == str) {\n\t\tchar *str2 = console_guess(str, &raw_fb_fd);\n\t\tif (str2 == NULL) {\n\t\t\trfbLog(\"console_guess failed for: %s\\n\", str);\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tstr = str2;\n\t\trfbLog(\"console_guess returned: %s\\n\", str);\n\t} else if (strstr(str, \"vnc:\") == str) {\n\t\tchar *str2 = vnc_reflect_guess(str, &raw_fb_addr);\n\n\t\trawfb_vnc_reflect = 1;\n\t\tdo_reflect = 1;\n\n\t\tstr = str2;\n\t\trfbLog(\"vnc_reflector set rawfb str to: %s\\n\", str);\n\t\tif (pipeinput_str == NULL) {\n\t\t\tpipeinput_str = strdup(\"VNC\");\n\t\t}\n\t\tinitialize_pipeinput();\n\t}\n\n\tif (closedpy && !view_only && got_noviewonly) {\n\t\trfbLog(\"not closing X DISPLAY under -noviewonly option.\\n\");\n\t\tclosedpy = 0;\n\t\tif (! window) {\n\t\t\twindow = rootwin;\n\t\t}\n\t}\n\n\tif (! raw_fb_orig_dpy && dpy) {\n\t\traw_fb_orig_dpy = strdup(DisplayString(dpy));\n\t}\n#ifndef BOLDLY_CLOSE_DISPLAY\n#define BOLDLY_CLOSE_DISPLAY 1\n#endif\n#if BOLDLY_CLOSE_DISPLAY\n\tif (closedpy) {\n\t\tif (dpy) {\n\t\t\trfbLog(\"closing X DISPLAY: %s in rawfb mode.\\n\",\n\t\t\t    DisplayString(dpy));\n\t\t\tXCloseDisplay_wr(dpy);\t/* yow! */\n\t\t}\n\t\tdpy = NULL;\n\t}\n#endif\n\n\t/*\n\t * -rawfb shm:163938442@640x480x32:ff/ff00/ff0000+3000\n\t * -rawfb map:/path/to/file@640x480x32:ff/ff00/ff0000\n\t * -rawfb file:/path/to/file@640x480x32:ff/ff00/ff0000\n\t */\n\n\tif (raw_fb_full_str) {\n\t\tfree(raw_fb_full_str);\n\t}\n\traw_fb_full_str = strdup(str);\n\n\n\t/* +O offset */\n\tchar *end = NULL;\n\tif ((q = strrchr(str, '+')) != NULL) {\n\t\tend = q;\n\t\tif (sscanf(q, \"+%d\", &raw_fb_offset) != 1) {\n\t\t\traw_fb_offset = 0;\n\t\t}\n\t}\n\n\t/* #VWxVH virtual dimensions */\n\tif ((q = strrchr(str, '#')) != NULL) {\n\t\tif (q < end) end = q;\n\t\tif (sscanf(q, \"#%dx%d\", &raw_fb_virt_x, &raw_fb_virt_y) != 2) {\n\t\t\traw_fb_virt_x = 0;\n\t\t\traw_fb_virt_y = 0;\n\t\t}\n\t}\n\n\tif (end != NULL) *end = '\\0';\n\n\tif ((q = strrchr(str, ':')) != NULL) {\n\t\tif (sscanf(q, \":%lx/%lx/%lx\", &rm, &gm, &bm) == 3) {\n\t\t\t*q = '\\0';\n\t\t} else if (sscanf(q, \":0x%lx/0x%lx/0x%lx\", &rm, &gm, &bm)== 3) {\n\t\t\t*q = '\\0';\n\t\t} else if (sscanf(q, \":%lu/%lu/%lu\", &rm, &gm, &bm) == 3) {\n\t\t\t*q = '\\0';\n\t\t} else {\n\t\t\trm = 0;\n\t\t\tgm = 0;\n\t\t\tbm = 0;\n\t\t}\n\t}\n\tif ((q = strrchr(str, '@')) == NULL) {\n\t\trfbLogEnable(1);\n\t\trfbLog(\"invalid rawfb str: %s\\n\", str);\n\t\tclean_up_exit(1);\n\t}\n\n\tif (strrchr(q, '-')) {\n\t\tchar *q2 = strrchr(q, '-');\n\t\traw_fb_bytes_per_line = atoi(q2+1);\n\t\t*q2 = '\\0';\n\t}\n\t/* @WxHxB */\n\tif (sscanf(q, \"@%dx%dx%d\", &w, &h, &b) != 3) {\n\t\trfbLogEnable(1);\n\t\trfbLog(\"invalid rawfb str: %s\\n\", str);\n\t\tclean_up_exit(1);\n\t}\n\t*q = '\\0';\n\n\tif (rm == 0 && gm == 0 && bm == 0) {\n\t\t/* guess masks... */\n\t\tif (b == 24 || b == 32) {\n\t\t\trm = 0xff0000;\n\t\t\tgm = 0x00ff00;\n\t\t\tbm = 0x0000ff;\n\t\t} else if (b == 16) {\n\t\t\trm = 0xf800;\n\t\t\tgm = 0x07e0;\n\t\t\tbm = 0x001f;\n\t\t} else if (b == 8) {\n\t\t\trm = 0x07;\n\t\t\tgm = 0x38;\n\t\t\tbm = 0xc0;\n\t\t}\n\t}\n\t/* we can fake -flipbyteorder to some degree... */\n\tif (flip_byte_order) {\n\t\tif (b == 24 || b == 32) {\n\t\t\ttm = rm;\n\t\t\trm = bm;\n\t\t\tbm = tm;\n\t\t} else if (b == 16) {\n\t\t\tunsigned short s1, s2;\n\t\t\ts1 = (unsigned short) rm;\n\t\t\ts2 = ((0xff & s1) << 8) | ((0xff00 & s1) >> 8);\n\t\t\trm = (unsigned long) s2;\n\t\t\ts1 = (unsigned short) gm;\n\t\t\ts2 = ((0xff & s1) << 8) | ((0xff00 & s1) >> 8);\n\t\t\tgm = (unsigned long) s2;\n\t\t\ts1 = (unsigned short) bm;\n\t\t\ts2 = ((0xff & s1) << 8) | ((0xff00 & s1) >> 8);\n\t\t\tbm = (unsigned long) s2;\n\t\t}\n\t}\n\n\t/* native fb stuff for bpp < 8 only */\n\traw_fb_native_bpp = b;\n\traw_fb_native_red_mask = rm;\n\traw_fb_native_green_mask = gm;\n\traw_fb_native_blue_mask = bm;\n\traw_fb_native_red_shift = 100;\n\traw_fb_native_green_shift = 100;\n\traw_fb_native_blue_shift = 100;\n\traw_fb_native_red_max = 1;\n\traw_fb_native_green_max = 1;\n\traw_fb_native_blue_max = 1;\n\tm = 1;\n\tfor (i=0; i<32; i++)  {\n\t\tif (raw_fb_native_red_mask & m) {\n\t\t\tif (raw_fb_native_red_shift == 100) {\n\t\t\t\traw_fb_native_red_shift = i;\n\t\t\t}\n\t\t\traw_fb_native_red_max *= 2;\n\t\t}\n\t\tif (raw_fb_native_green_mask & m) {\n\t\t\tif (raw_fb_native_green_shift == 100) {\n\t\t\t\traw_fb_native_green_shift = i;\n\t\t\t}\n\t\t\traw_fb_native_green_max *= 2;\n\t\t}\n\t\tif (raw_fb_native_blue_mask & m) {\n\t\t\tif (raw_fb_native_blue_shift == 100) {\n\t\t\t\traw_fb_native_blue_shift = i;\n\t\t\t}\n\t\t\traw_fb_native_blue_max *= 2;\n\t\t}\n\t\tm = m << 1;\n\t}\n\traw_fb_native_red_max -= 1;\n\traw_fb_native_green_max -= 1;\n\traw_fb_native_blue_max -= 1;\n\n\tif (b < 8) {\n\t\t/* e.g. VGA16 */\n\t\trfbLog(\"raw_fb_native_bpp: %d 0x%02lx 0x%02lx 0x%02lx %d/%d/%d %d/%d/%d\\n\", raw_fb_native_bpp,\n\t\t    raw_fb_native_red_mask, raw_fb_native_green_mask, raw_fb_native_blue_mask,\n\t\t    raw_fb_native_red_max, raw_fb_native_green_max, raw_fb_native_blue_max,\n\t\t    raw_fb_native_red_shift, raw_fb_native_green_shift, raw_fb_native_blue_shift);\n\t\traw_fb_expand_bytes = 1;\n\t\tb = 8;\n\t\trm = 0x07;\n\t\tgm = 0x38;\n\t\tbm = 0xc0;\n\t}\n\t/* end of stuff for bpp < 8 */\n\n\tdpy_x = wdpy_x = w;\n\tdpy_y = wdpy_y = h;\n\toff_x = 0;\n\toff_y = 0;\n\n\tif (rawfb_dev_video) {\n\t\tif (b == 24) {\n\t\t\trfbLog(\"enabling -24to32 for 24bpp video\\n\");\n\t\t\txform24to32 = 1;\n\t\t} else {\n\t\t\tif (xform24to32) {\n\t\t\t\trfbLog(\"disabling -24to32 for 24bpp video\\n\");\n\t\t\t}\n\t\t\txform24to32 = 0;\n\t\t}\n\t}\n\n\tif (xform24to32) {\n\t\tif (b != 24) {\n\t\t\trfbLog(\"warning: -24to32 mode and bpp=%d\\n\", b);\n\t\t}\n\t\tb = 32;\n\t}\n\tif (strstr(str, \"snap:\") == str) {\n\t\tuse_snapfb = 1;\n\t\tstr[0] = 'f'; str[1] = 'i'; str[2] = 'l'; str[3] = 'e';\n\t}\n\n\tif (strstr(str, \"shm:\") != str && strstr(str, \"mmap:\") != str &&\n\t    strstr(str, \"map:\") != str && strstr(str, \"file:\") != str) {\n\t\t/* hmmm, not following directions, see if map: applies */\n\t\tstruct stat sbuf;\n\t\tif (stat(str, &sbuf) == 0) {\n\t\t\tchar *newstr;\n\t\t\tint len = strlen(\"map:\") + strlen(str) + 1;\n\t\t\trfbLog(\"no type prefix: %s\\n\", raw_fb_str);\n\t\t\trfbLog(\"  but file exists, so assuming: map:%s\\n\",\n\t\t\t    raw_fb_str);\n\t\t\tnewstr = (char *) malloc(len);\n\t\t\tstrcpy(newstr, \"map:\");\n\t\t\tstrcat(newstr, str);\n\t\t\tfree(str);\n\t\t\tstr = newstr;\n\t\t}\n\t}\n\n\tif (sscanf(str, \"shm:%d\", &shmid) == 1) {\n\t\t/* shm:N */\n#if HAVE_XSHM || HAVE_SHMAT\n\t\traw_fb_addr = (char *) shmat(shmid, 0, SHM_RDONLY);\n\t\tif (! raw_fb_addr) {\n\t\t\trfbLogEnable(1);\n\t\t\trfbLog(\"failed to attach to shm: %d, %s\\n\", shmid, str);\n\t\t\trfbLogPerror(\"shmat\");\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\traw_fb_shm = 1;\n\t\trfbLog(\"rawfb: shm: %d W: %d H: %d B: %d addr: %p\\n\",\n\t\t    shmid, w, h, b, raw_fb_addr);\n\t\tlast_mode = RAWFB_SHM;\n#else\n\t\trfbLogEnable(1);\n\t\trfbLog(\"x11vnc was compiled without shm support.\\n\");\n\t\trfbLogPerror(\"shmat\");\n\t\tclean_up_exit(1);\n#endif\n\t} else if (strstr(str, \"map:\") == str || strstr(str, \"mmap:\") == str\n\t    || strstr(str, \"file:\") == str) {\n\t\t/* map:/path/... or file:/path  */\n\t\tint fd, do_mmap = 1, size, vsize = 0;\n\t\tstruct stat sbuf;\n\n\t\tif (*str == 'f') {\n\t\t\tdo_mmap = 0;\n\t\t}\n\t\tq = strchr(str, ':');\n\t\tq++;\n\n\t\tmacosx_console = 0;\n\t\tif (strstr(q, \"macosx:\") == q) {\n\t\t\t/* mmap:macosx:/dev/null@... */\n\t\t\tq += strlen(\"macosx:\");\t\t\t\n\t\t\tdo_macosx = 1;\n\t\t\tdo_mmap = 0;\n\t\t\tmacosx_console = 1;\n\t\t}\n\n\t\tlast_file = strdup(q);\n\n\t\tfd = raw_fb_fd;\n\t\tif (fd < 0 && rawfb_dev_video) {\n\t\t\tfd = open(q, O_RDWR);\n\t\t}\n\t\tif (fd < 0) {\n\t\t\tfd = open(q, O_RDONLY);\n\t\t}\n\t\tif (fd < 0) {\n\t\t\trfbLogEnable(1);\n\t\t\trfbLog(\"failed to open file: %s, %s\\n\", q, str);\n\t\t\trfbLogPerror(\"open\");\n\t\t\tlinux_dev_fb_msg(q);\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\traw_fb_fd = fd;\n\n\t\tif (raw_fb_native_bpp < 8) {\n\t\t\tsize = w*h*raw_fb_native_bpp/8 + raw_fb_offset;\n\t\t} else if (xform24to32) {\n\t\t\tsize = w*h*24/8 + raw_fb_offset;\n\t\t} else if (raw_fb_virt_x != 0 && raw_fb_virt_y != 0) {\n\t\t\tsize = w*h*b/8;\n\t\t\tvsize = raw_fb_virt_x*raw_fb_virt_y*b/8;\n\t\t\trawfb_double_buffer = 1;\n\t\t\trfbLog(\"virtual size: %d\", vsize);\n\t\t} else {\n\t\t\tsize = w*h*b/8 + raw_fb_offset;\n\t\t}\n\n\t\tif (fstat(fd, &sbuf) == 0) {\n\t\t\tif (S_ISREG(sbuf.st_mode)) {\n\t\t\t\tif (0) size = sbuf.st_size;\n\t\t\t} else {\n\t\t\t\trfbLog(\"raw fb is non-regular file: %s\\n\", q);\n\t\t\t}\n\t\t}\n\n\t\tif (do_macosx) {\n\t\t\traw_fb_addr = macosx_get_fb_addr();\n\t\t\traw_fb_mmap = size;\n\t\t\trfbLog(\"rawfb: macosx fb: %s\\n\", q);\n\t\t\trfbLog(\"   w: %d h: %d b: %d addr: %p sz: %d\\n\", w, h,\n\t\t\t    b, raw_fb_addr, size);\n\t\t\tlast_mode = 0;\n\t\t} else if (do_reflect) {\n\t\t\traw_fb_mmap = size;\n\t\t\trfbLog(\"rawfb: vnc fb: %s\\n\", q);\n\t\t\trfbLog(\"   w: %d h: %d b: %d addr: %p sz: %d\\n\", w, h,\n\t\t\t    b, raw_fb_addr, size);\n\t\t\tlast_mode = 0;\n\n\t\t} else if (do_mmap) {\n#if LIBVNCSERVER_HAVE_MMAP\n\t\t\tif (vsize != 0) {\n\t\t\t\traw_fb_addr = mmap(0, vsize, PROT_READ, MAP_SHARED, fd, 0);\n\t\t\t} else {\n\t\t\t\traw_fb_addr = mmap(0, size, PROT_READ, MAP_SHARED, fd, 0);\n\t\t\t}\n\n\t\t\tif (raw_fb_addr == MAP_FAILED || raw_fb_addr == NULL) {\n\t\t\t\trfbLogEnable(1);\n\t\t\t\trfbLog(\"failed to mmap file: %s, %s\\n\", q, str);\n\t\t\t\trfbLog(\"   raw_fb_addr: %p\\n\", raw_fb_addr);\n\t\t\t\trfbLogPerror(\"mmap\");\n\n\t\t\t\traw_fb_addr = NULL;\n\t\t\t\trfbLog(\"mmap(2) failed, trying slower lseek(2)\\n\");\n\t\t\t\traw_fb_seek = size;\n\t\t\t\tlast_mode = RAWFB_FILE;\n\n\t\t\t} else {\n\t\t\t\traw_fb_mmap = size;\n\n\t\t\t\trfbLog(\"rawfb: mmap file: %s\\n\", q);\n\t\t\t\tif (vsize != 0) {\n\t\t\t\t\trfbLog(\"   w: %d h: %d b: %d addr: %p sz: %d\\n\", w, h,\n\t\t\t\t\t\tb, raw_fb_addr, vsize);\n\t\t\t\t} else {\n\t\t\t\t\trfbLog(\"   w: %d h: %d b: %d addr: %p sz: %d\\n\", w, h,\n\t\t\t\t\t\tb, raw_fb_addr, size);\n\t\t\t\t}\n\t\t\t\tlast_mode = RAWFB_MMAP;\n\t\t\t}\n#else\n\t\t\trfbLog(\"mmap(2) not supported on system, using\"\n\t\t\t    \" slower lseek(2)\\n\");\n\t\t\traw_fb_seek = size;\n\t\t\tlast_mode = RAWFB_FILE;\n#endif\n\t\t} else {\n\t\t\traw_fb_seek = size;\n\t\t\tlast_mode = RAWFB_FILE;\n\n\t\t\trfbLog(\"rawfb: seek file: %s\\n\", q);\n\t\t\trfbLog(\"   W: %d H: %d B: %d sz: %d\\n\", w, h, b, size);\n\t\t}\n\t} else {\n\t\trfbLogEnable(1);\n\t\trfbLog(\"invalid rawfb str: %s\\n\", str);\n\t\tclean_up_exit(1);\n\t}\n\n\tif (unlink_me) {\n\t\tunlink(unlink_me);\n\t}\n\n\tif (! raw_fb_image) {\n\t\traw_fb_image = &ximage_struct;\n\t}\n\n\tinitialize_clipshift();\n\n\tif (raw_fb_bytes_per_line == 0) {\n\t\traw_fb_bytes_per_line = dpy_x*b/8;\n\n\t\t/*\n\t\t * Put cases here were we can determine that\n\t\t * raw_bytes_per_line != dpy_x*b/8\n\t\t */\n#ifdef MACOSX\n\t\tif (do_macosx) {\n\t\t\traw_fb_bytes_per_line = macosxCG_CGDisplayBytesPerRow();\n\t\t}\n#endif\n\t}\n\n\traw_fb_image->bytes_per_line = dpy_x * b/8;\n\traw_fb = (char *) malloc(dpy_y * dpy_x * b/8);\n\traw_fb_image->data = raw_fb;\n\traw_fb_image->format = ZPixmap;\n\traw_fb_image->width  = dpy_x;\n\traw_fb_image->height = dpy_y;\n\traw_fb_image->bits_per_pixel = b;\n\traw_fb_image->bitmap_unit = -1;\n\n\n\tif (use_snapfb && (raw_fb_seek || raw_fb_mmap)) {\n\t\tint b_use = b;\n\t\tif (snap_fb) {\n\t\t\tfree(snap_fb);\n\t\t}\n\t\tif (b_use == 32 && xform24to32) {\n\t\t\t/*\n\t\t\t * The actual framebuffer (e.g. mapped addr) and\n\t\t\t * snap fb must be the same bpp.  E.g. both 24bpp.\n\t\t\t * Reading FROM snap to utility image will be\n\t\t\t * transformed 24->32 in copy_raw_fb_24_to_32.\n\t\t\t *\n\t\t\t * addr -> snap -> (scanline, fullscreen, ...)\n\t\t\t */\n\t\t\tb_use = 24;\n\t\t\traw_fb_bytes_per_line = dpy_x * b_use/8;\n\t\t}\n\t\tsnap_fb = (char *) malloc(dpy_y * dpy_x * b_use/8);\n\t\tsnap = &ximage_struct_snap;\n\t\tsnap->data = snap_fb;\n\t\tsnap->format = ZPixmap;\n\t\tsnap->width  = dpy_x;\n\t\tsnap->height = dpy_y;\n\t\tsnap->bits_per_pixel = b_use;\n\t\tsnap->bytes_per_line = dpy_x * b_use/8;\n\t\tsnap->bitmap_unit = -1;\n\t}\n\n\n\traw_fb_image->red_mask = rm;\n\traw_fb_image->green_mask = gm;\n\traw_fb_image->blue_mask = bm;\n\n\traw_fb_image->depth = 0;\n\tm = 1;\n\tfor (i=0; i<32; i++)  {\n\t\tif (rm & m) {\n\t\t\traw_fb_image->depth++;\n\t\t}\n\t\tif (gm & m) {\n\t\t\traw_fb_image->depth++;\n\t\t}\n\t\tif (bm & m) {\n\t\t\traw_fb_image->depth++;\n\t\t}\n\t\tm = m << 1;\n\t}\n\tif (raw_fb_native_bpp < 8) {\n\t\traw_fb_image->depth = raw_fb_expand_bytes * 8;\n\t}\n\tif (! raw_fb_image->depth) { \n\t\traw_fb_image->depth = (b == 32) ? 24 : b;\n\t}\n\n\tdepth = raw_fb_image->depth;\n\n\tif (raw_fb_image->depth == 15) {\n\t\t/* unresolved bug with RGB555... */\n\t\tdepth++;\n\t}\n\n\tif (clipshift || raw_fb_native_bpp < 8) {\n\t\tmemset(raw_fb, 0xff, dpy_y * raw_fb_image->bytes_per_line);\n\t} else if (raw_fb_addr && ! xform24to32) {\n\t\tmemcpy(raw_fb, raw_fb_addr + raw_fb_offset, dpy_y * raw_fb_image->bytes_per_line);\n\t} else {\n\t\tmemset(raw_fb, 0xff, dpy_y * raw_fb_image->bytes_per_line);\n\t}\n\n\tif (verbose) {\n\t\trfbLog(\"\\n\");\n\t\trfbLog(\"rawfb:  raw_fb  %p\\n\", raw_fb);\n\t\trfbLog(\"        format  %d\\n\", raw_fb_image->format);\n\t\trfbLog(\"        width   %d\\n\", raw_fb_image->width);\n\t\trfbLog(\"        height  %d\\n\", raw_fb_image->height);\n\t\trfbLog(\"        bpp     %d\\n\", raw_fb_image->bits_per_pixel);\n\t\trfbLog(\"        depth   %d\\n\", raw_fb_image->depth);\n\t\trfbLog(\"        bpl     %d\\n\", raw_fb_image->bytes_per_line);\n\t\tif (use_snapfb && snap_fb) {\n\t\t\trfbLog(\"        snap_fb %p\\n\", snap_fb);\n\t\t}\n\t}\n\n\tfree(str);\n\n\treturn raw_fb_image;\n}",
          "includes": [
            "#include <rfb/rfbclient.h>",
            "#include \"xi2_devices.h\"",
            "#include \"pm.h\"",
            "#include \"xrecord.h\"",
            "#include \"xrandr.h\"",
            "#include \"inet.h\"",
            "#include \"solid.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"linuxfb.h\"",
            "#include \"v4l.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"remote.h\"",
            "#include \"connections.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"pointer.h\"",
            "#include \"rates.h\"",
            "#include \"user.h\"",
            "#include \"scan.h\"",
            "#include \"userinput.h\"",
            "#include \"cleanup.h\"",
            "#include \"win_utils.h\"",
            "#include \"xdamage.h\"",
            "#include \"xinerama.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xevents.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define BOLDLY_CLOSE_DISPLAY 1",
            "#define RAWFB_SHM  3",
            "#define RAWFB_FILE 2",
            "#define RAWFB_MMAP 1"
          ],
          "globals_used": [
            "void set_colormap(int reset);",
            "int parse_rotate_string(char *str, int *mode);",
            "void initialize_screen(int *argc, char **argv, XImage *fb);",
            "char *vnc_reflect_guess(char *str, char **raw_fb_addr);",
            "rfbBool vnc_reflect_send_cuttext(char *str, int len);",
            "static void debug_colormap(XImage *fb);",
            "static void set_visual(char *str);",
            "static void install_fake_fb(int w, int h, int bpp);",
            "XImage *initialize_raw_fb(int);",
            "static void initialize_clipshift(void);",
            "int rawfb_dev_video = 0;",
            "int rawfb_vnc_reflect = 0;",
            "int rawfb_double_buffer = 0;",
            "static char *raw_fb_orig_dpy = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <rfb/rfbclient.h>\n#include \"xi2_devices.h\"\n#include \"pm.h\"\n#include \"xrecord.h\"\n#include \"xrandr.h\"\n#include \"inet.h\"\n#include \"solid.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"remote.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"scan.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xdamage.h\"\n#include \"xinerama.h\"\n#include \"xwrappers.h\"\n#include \"xevents.h\"\n#include \"x11vnc.h\"\n\n#define BOLDLY_CLOSE_DISPLAY 1\n#define RAWFB_SHM  3\n#define RAWFB_FILE 2\n#define RAWFB_MMAP 1\n\nvoid set_colormap(int reset);\nint parse_rotate_string(char *str, int *mode);\nvoid initialize_screen(int *argc, char **argv, XImage *fb);\nchar *vnc_reflect_guess(char *str, char **raw_fb_addr);\nrfbBool vnc_reflect_send_cuttext(char *str, int len);\nstatic void debug_colormap(XImage *fb);\nstatic void set_visual(char *str);\nstatic void install_fake_fb(int w, int h, int bpp);\nXImage *initialize_raw_fb(int);\nstatic void initialize_clipshift(void);\nint rawfb_dev_video = 0;\nint rawfb_vnc_reflect = 0;\nint rawfb_double_buffer = 0;\nstatic char *raw_fb_orig_dpy = NULL;\n\nXImage *initialize_raw_fb(int reset) {\n\tchar *str, *rstr, *q;\n\tint w, h, b, shmid = 0;\n\tunsigned long rm = 0, gm = 0, bm = 0, tm;\n\tstatic XImage ximage_struct;\t/* n.b.: not (XImage *) */\n\tstatic XImage ximage_struct_snap;\n\tint closedpy = 1, i, m, db = 0;\n\tint do_macosx = 0;\n\tint do_reflect = 0;\n\tchar *unlink_me = NULL;\n\n\tstatic char *last_file = NULL;\n\tstatic int last_mode = 0;\n\n\tif (reset && last_mode) {\n\t\tint fd;\n\t\tif (last_mode != RAWFB_MMAP && last_mode != RAWFB_FILE) {\n\t\t\treturn NULL;\n\t\t}\n\t\tif (last_mode == RAWFB_MMAP) {\n\t\t\tmunmap(raw_fb_addr, raw_fb_mmap);\n\t\t}\n\t\tif (raw_fb_fd >= 0) {\n\t\t\tclose(raw_fb_fd);\n\t\t}\n\t\traw_fb_fd = -1;\nif (db) fprintf(stderr, \"initialize_raw_fb reset\\n\");\n\t\t\t\n\t\tfd = -1;\n\t\tif (rawfb_dev_video) {\n\t\t\tfd = open(last_file, O_RDWR);\n\t\t}\n\t\tif (fd < 0) {\n\t\t\tfd = open(last_file, O_RDONLY);\n\t\t}\n\t\tif (fd < 0) {\n\t\t\trfbLogEnable(1);\n\t\t\trfbLog(\"failed to rawfb file: %s\\n\", last_file);\n\t\t\trfbLogPerror(\"open\");\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\traw_fb_fd = fd;\n\t\tif (last_mode == RAWFB_MMAP) {\n\t\t\traw_fb_addr = mmap(0, raw_fb_mmap, PROT_READ,\n\t\t\t    MAP_SHARED, fd, 0);\n\n\t\t\tif (raw_fb_addr == MAP_FAILED || raw_fb_addr == NULL) {\n\t\t\t\trfbLogEnable(1);\n\t\t\t\trfbLog(\"failed to mmap file: %s\\n\", last_file);\n\t\t\t\trfbLog(\"   raw_fb_addr: %p\\n\", raw_fb_addr);\n\t\t\t\trfbLogPerror(\"mmap\");\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t}\n\t\treturn NULL;\n\t}\n\n#ifdef MACOSX\n\tif (raw_fb_addr != NULL && macosx_console && raw_fb_addr == macosx_get_fb_addr()) {\n\t\traw_fb_addr = NULL;\n\t}\n#endif\n\n\tif (raw_fb_addr || raw_fb_seek) {\n\t\tif (raw_fb_shm) {\n\t\t\tshmdt(raw_fb_addr);\n#if LIBVNCSERVER_HAVE_MMAP\n\t\t} else if (raw_fb_mmap) {\n\t\t\tmunmap(raw_fb_addr, raw_fb_mmap);\n\t\t\tif (raw_fb_fd >= 0) {\n\t\t\t\tclose(raw_fb_fd);\n\t\t\t}\n\t\t\traw_fb_fd = -1;\n#endif\n\t\t} else if (raw_fb_seek) {\n\t\t\tif (raw_fb_fd >= 0) {\n\t\t\t\tclose(raw_fb_fd);\n\t\t\t}\n\t\t\traw_fb_fd = -1;\n\t\t}\n\t\traw_fb_addr = NULL;\n\t\traw_fb_mmap = 0;\n\t\traw_fb_seek = 0;\n\t}\n\tif (! raw_fb_str) {\n\t\treturn NULL;\n\t}\n\n\tif (raw_fb_str[0] == '+') {\n\t\trstr = strdup(raw_fb_str+1);\n\t\tclosedpy = 0;\n\t\tif (! window) {\n\t\t\twindow = rootwin;\n\t\t}\n\t} else {\n\t\trstr = strdup(raw_fb_str);\n\t}\n\n\t/* testing aliases */\n\tif (!strcasecmp(rstr, \"NULL\") || !strcasecmp(rstr, \"ZERO\")\n\t    || !strcasecmp(rstr, \"NONE\")) {\n\t\trstr = strdup(\"map:/dev/zero@640x480x32\");\n\t} else if (!strcasecmp(rstr, \"NULLBIG\") || !strcasecmp(rstr, \"NONEBIG\")) {\n\t\trstr = strdup(\"map:/dev/zero@1024x768x32\");\n\t}\n\tif (!strcasecmp(rstr, \"RAND\")) {\n\t\trstr = strdup(\"file:/dev/urandom@128x128x16\");\n\t} else if (!strcasecmp(rstr, \"RANDBIG\")) {\n\t\trstr = strdup(\"file:/dev/urandom@640x480x16\");\n\t} else if (!strcasecmp(rstr, \"RANDHUGE\")) {\n\t\trstr = strdup(\"file:/dev/urandom@1024x768x16\");\n\t}\n\tif (strstr(rstr, \"solid=\") == rstr) {\n\t\tchar *n = rstr + strlen(\"solid=\");\n\t\tchar tmp[] = \"/tmp/rawfb_solid.XXXXXX\";\n\t\tchar str[100];\n\t\tunsigned int vals[1024], val;\n\t\tint x, y, fd, w = 1024, h = 768;\n\t\tif (strstr(n, \"0x\")) {\n\t\t\tif (sscanf(n, \"0x%x\", &val) != 1) {\n\t\t\t\tval = 0;\n\t\t\t}\n\t\t}\n\t\tif (val == 0) {\n\t\t\tval = get_pixel(n);\n\t\t}\n\t\tif (val == 0) {\n\t\t\tval = 0xFF00FF;\n\t\t}\n\t\tfd = mkstemp(tmp);\n\t\tfor (y = 0; y < h; y++) {\n\t\t\tfor (x = 0; x < w; x++) {\n\t\t\t\tvals[x] = val;\n\t\t\t}\n\t\t\twrite(fd, (char *)vals, 4 * w);\n\t\t}\n\t\tclose(fd);\n\t\tfd = open(tmp, O_WRONLY);\n\t\tunlink_me = strdup(tmp);\n\t\tsprintf(str, \"map:%s@%dx%dx32\", tmp, w, h);\n\t\trstr = strdup(str);\n\t} else if (strstr(rstr, \"swirl\") == rstr) {\n\t\tchar tmp[] = \"/tmp/rawfb_swirl.XXXXXX\";\n\t\tchar str[100];\n\t\tunsigned int val[1024];\n\t\tunsigned int c1, c2, c3, c4;\n\t\tint x, y, fd, w = 1024, h = 768;\n\t\tfd = mkstemp(tmp);\n\t\tfor (y = 0; y < h; y++) {\n\t\t\tfor (x = 0; x < w; x++) {\n\t\t\t\tc1 = 0;\n\t\t\t\tc2 = ((x+y)*128)/(w+h);\n\t\t\t\tc3 = (x*128)/w;\n\t\t\t\tc4 = (y*256)/h;\n\t\t\t\tval[x] = (c1 << 24) | (c2 << 16) | (c3 << 8) | (c4 << 0);\n\t\t\t}\n\t\t\twrite(fd, (char *)val, 4 * w);\n\t\t}\n\t\tclose(fd);\n\t\tfd = open(tmp, O_WRONLY);\n\t\tunlink_me = strdup(tmp);\n\t\tsprintf(str, \"map:%s@%dx%dx32\", tmp, w, h);\n\t\trstr = strdup(str);\n\t}\n\n\n\tif ( (q = strstr(rstr, \"setup:\")) == rstr) {\n\t\tFILE *pipe;\n\t\tchar line[1024], *t;\n\n\t\tset_child_info();\n\t\tq += strlen(\"setup:\");\n\t\t/* rawfb-setup */\n\t\tif (no_external_cmds || !cmd_ok(\"rawfb-setup\")) {\n\t\t\trfbLogEnable(1);\n\t\t\trfbLog(\"cannot run external commands in -nocmds \"\n\t\t\t    \"mode:\\n\");\n\t\t\trfbLog(\"   \\\"%s\\\"\\n\", q);\n\t\t\trfbLog(\"   exiting.\\n\");\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\trfbLog(\"running command to setup rawfb: %s\\n\", q);\n\t\tclose_exec_fds();\n\t\tpipe = popen(q, \"r\");\n\t\tif (! pipe) {\n\t\t\trfbLogEnable(1);\n\t\t\trfbLog(\"popen of setup command failed.\\n\");\n\t\t\trfbLogPerror(\"popen\");\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tline[0] = '\\0';\n\t\tif (fgets(line, 1024, pipe) == NULL) {\n\t\t\trfbLogEnable(1);\n\t\t\trfbLog(\"read of setup command failed.\\n\");\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tpclose(pipe);\n\t\tstr = strdup(line);\n\t\tt = str;\n\t\twhile (*t != '\\0') {\n\t\t\tif (*t == '\\n') {\n\t\t\t\t*t = '\\0';\n\t\t\t}\n\t\t\tt++;\n\t\t}\n\t\trfbLog(\"setup command returned: %s\\n\", str);\n\n\t} else {\n\t\tstr = strdup(rstr);\n\t}\n\n\traw_fb_shm = 0;\n\traw_fb_mmap = 0;\n\traw_fb_seek = 0;\n\traw_fb_fd = -1;\n\traw_fb_addr = NULL;\n\traw_fb_offset = 0;\n\traw_fb_bytes_per_line = 0;\n\trawfb_vnc_reflect = 0;\n\n\tlast_mode = 0;\n\tif (last_file) {\n\t\tfree(last_file);\n\t\tlast_file = NULL;\n\t}\n\tif (strstr(str, \"Video\") == str) {\n\t\tif (pipeinput_str != NULL) {\n\t\t\tfree(pipeinput_str);\n\t\t}\n\t\tpipeinput_str = strdup(\"VID\");\n\t\tinitialize_pipeinput();\n\t\tstr[0] = 'v';\n\t}\n\n\tif (strstr(str, \"video\") == str || strstr(str, \"/dev/video\") == str) {\n\t\tchar *str2 = v4l_guess(str, &raw_fb_fd);\n\t\tif (str2 == NULL) {\n\t\t\trfbLog(\"v4l_guess failed for: %s\\n\", str);\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tstr = str2;\n\t\trfbLog(\"v4l_guess returned: %s\\n\", str);\n\t\trawfb_dev_video = 1;\n\t} else if (strstr(str, \"dev/video\")) {\n\t\trawfb_dev_video = 1;\n\t} else if (strstr(str, \"console\") == str || strstr(str, \"fb\") == str ||\n\t    strstr(str, \"/dev/fb\") == str || strstr(str, \"vt\") == str) {\n\t\tchar *str2 = console_guess(str, &raw_fb_fd);\n\t\tif (str2 == NULL) {\n\t\t\trfbLog(\"console_guess failed for: %s\\n\", str);\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tstr = str2;\n\t\trfbLog(\"console_guess returned: %s\\n\", str);\n\t} else if (strstr(str, \"vnc:\") == str) {\n\t\tchar *str2 = vnc_reflect_guess(str, &raw_fb_addr);\n\n\t\trawfb_vnc_reflect = 1;\n\t\tdo_reflect = 1;\n\n\t\tstr = str2;\n\t\trfbLog(\"vnc_reflector set rawfb str to: %s\\n\", str);\n\t\tif (pipeinput_str == NULL) {\n\t\t\tpipeinput_str = strdup(\"VNC\");\n\t\t}\n\t\tinitialize_pipeinput();\n\t}\n\n\tif (closedpy && !view_only && got_noviewonly) {\n\t\trfbLog(\"not closing X DISPLAY under -noviewonly option.\\n\");\n\t\tclosedpy = 0;\n\t\tif (! window) {\n\t\t\twindow = rootwin;\n\t\t}\n\t}\n\n\tif (! raw_fb_orig_dpy && dpy) {\n\t\traw_fb_orig_dpy = strdup(DisplayString(dpy));\n\t}\n#ifndef BOLDLY_CLOSE_DISPLAY\n#define BOLDLY_CLOSE_DISPLAY 1\n#endif\n#if BOLDLY_CLOSE_DISPLAY\n\tif (closedpy) {\n\t\tif (dpy) {\n\t\t\trfbLog(\"closing X DISPLAY: %s in rawfb mode.\\n\",\n\t\t\t    DisplayString(dpy));\n\t\t\tXCloseDisplay_wr(dpy);\t/* yow! */\n\t\t}\n\t\tdpy = NULL;\n\t}\n#endif\n\n\t/*\n\t * -rawfb shm:163938442@640x480x32:ff/ff00/ff0000+3000\n\t * -rawfb map:/path/to/file@640x480x32:ff/ff00/ff0000\n\t * -rawfb file:/path/to/file@640x480x32:ff/ff00/ff0000\n\t */\n\n\tif (raw_fb_full_str) {\n\t\tfree(raw_fb_full_str);\n\t}\n\traw_fb_full_str = strdup(str);\n\n\n\t/* +O offset */\n\tchar *end = NULL;\n\tif ((q = strrchr(str, '+')) != NULL) {\n\t\tend = q;\n\t\tif (sscanf(q, \"+%d\", &raw_fb_offset) != 1) {\n\t\t\traw_fb_offset = 0;\n\t\t}\n\t}\n\n\t/* #VWxVH virtual dimensions */\n\tif ((q = strrchr(str, '#')) != NULL) {\n\t\tif (q < end) end = q;\n\t\tif (sscanf(q, \"#%dx%d\", &raw_fb_virt_x, &raw_fb_virt_y) != 2) {\n\t\t\traw_fb_virt_x = 0;\n\t\t\traw_fb_virt_y = 0;\n\t\t}\n\t}\n\n\tif (end != NULL) *end = '\\0';\n\n\tif ((q = strrchr(str, ':')) != NULL) {\n\t\tif (sscanf(q, \":%lx/%lx/%lx\", &rm, &gm, &bm) == 3) {\n\t\t\t*q = '\\0';\n\t\t} else if (sscanf(q, \":0x%lx/0x%lx/0x%lx\", &rm, &gm, &bm)== 3) {\n\t\t\t*q = '\\0';\n\t\t} else if (sscanf(q, \":%lu/%lu/%lu\", &rm, &gm, &bm) == 3) {\n\t\t\t*q = '\\0';\n\t\t} else {\n\t\t\trm = 0;\n\t\t\tgm = 0;\n\t\t\tbm = 0;\n\t\t}\n\t}\n\tif ((q = strrchr(str, '@')) == NULL) {\n\t\trfbLogEnable(1);\n\t\trfbLog(\"invalid rawfb str: %s\\n\", str);\n\t\tclean_up_exit(1);\n\t}\n\n\tif (strrchr(q, '-')) {\n\t\tchar *q2 = strrchr(q, '-');\n\t\traw_fb_bytes_per_line = atoi(q2+1);\n\t\t*q2 = '\\0';\n\t}\n\t/* @WxHxB */\n\tif (sscanf(q, \"@%dx%dx%d\", &w, &h, &b) != 3) {\n\t\trfbLogEnable(1);\n\t\trfbLog(\"invalid rawfb str: %s\\n\", str);\n\t\tclean_up_exit(1);\n\t}\n\t*q = '\\0';\n\n\tif (rm == 0 && gm == 0 && bm == 0) {\n\t\t/* guess masks... */\n\t\tif (b == 24 || b == 32) {\n\t\t\trm = 0xff0000;\n\t\t\tgm = 0x00ff00;\n\t\t\tbm = 0x0000ff;\n\t\t} else if (b == 16) {\n\t\t\trm = 0xf800;\n\t\t\tgm = 0x07e0;\n\t\t\tbm = 0x001f;\n\t\t} else if (b == 8) {\n\t\t\trm = 0x07;\n\t\t\tgm = 0x38;\n\t\t\tbm = 0xc0;\n\t\t}\n\t}\n\t/* we can fake -flipbyteorder to some degree... */\n\tif (flip_byte_order) {\n\t\tif (b == 24 || b == 32) {\n\t\t\ttm = rm;\n\t\t\trm = bm;\n\t\t\tbm = tm;\n\t\t} else if (b == 16) {\n\t\t\tunsigned short s1, s2;\n\t\t\ts1 = (unsigned short) rm;\n\t\t\ts2 = ((0xff & s1) << 8) | ((0xff00 & s1) >> 8);\n\t\t\trm = (unsigned long) s2;\n\t\t\ts1 = (unsigned short) gm;\n\t\t\ts2 = ((0xff & s1) << 8) | ((0xff00 & s1) >> 8);\n\t\t\tgm = (unsigned long) s2;\n\t\t\ts1 = (unsigned short) bm;\n\t\t\ts2 = ((0xff & s1) << 8) | ((0xff00 & s1) >> 8);\n\t\t\tbm = (unsigned long) s2;\n\t\t}\n\t}\n\n\t/* native fb stuff for bpp < 8 only */\n\traw_fb_native_bpp = b;\n\traw_fb_native_red_mask = rm;\n\traw_fb_native_green_mask = gm;\n\traw_fb_native_blue_mask = bm;\n\traw_fb_native_red_shift = 100;\n\traw_fb_native_green_shift = 100;\n\traw_fb_native_blue_shift = 100;\n\traw_fb_native_red_max = 1;\n\traw_fb_native_green_max = 1;\n\traw_fb_native_blue_max = 1;\n\tm = 1;\n\tfor (i=0; i<32; i++)  {\n\t\tif (raw_fb_native_red_mask & m) {\n\t\t\tif (raw_fb_native_red_shift == 100) {\n\t\t\t\traw_fb_native_red_shift = i;\n\t\t\t}\n\t\t\traw_fb_native_red_max *= 2;\n\t\t}\n\t\tif (raw_fb_native_green_mask & m) {\n\t\t\tif (raw_fb_native_green_shift == 100) {\n\t\t\t\traw_fb_native_green_shift = i;\n\t\t\t}\n\t\t\traw_fb_native_green_max *= 2;\n\t\t}\n\t\tif (raw_fb_native_blue_mask & m) {\n\t\t\tif (raw_fb_native_blue_shift == 100) {\n\t\t\t\traw_fb_native_blue_shift = i;\n\t\t\t}\n\t\t\traw_fb_native_blue_max *= 2;\n\t\t}\n\t\tm = m << 1;\n\t}\n\traw_fb_native_red_max -= 1;\n\traw_fb_native_green_max -= 1;\n\traw_fb_native_blue_max -= 1;\n\n\tif (b < 8) {\n\t\t/* e.g. VGA16 */\n\t\trfbLog(\"raw_fb_native_bpp: %d 0x%02lx 0x%02lx 0x%02lx %d/%d/%d %d/%d/%d\\n\", raw_fb_native_bpp,\n\t\t    raw_fb_native_red_mask, raw_fb_native_green_mask, raw_fb_native_blue_mask,\n\t\t    raw_fb_native_red_max, raw_fb_native_green_max, raw_fb_native_blue_max,\n\t\t    raw_fb_native_red_shift, raw_fb_native_green_shift, raw_fb_native_blue_shift);\n\t\traw_fb_expand_bytes = 1;\n\t\tb = 8;\n\t\trm = 0x07;\n\t\tgm = 0x38;\n\t\tbm = 0xc0;\n\t}\n\t/* end of stuff for bpp < 8 */\n\n\tdpy_x = wdpy_x = w;\n\tdpy_y = wdpy_y = h;\n\toff_x = 0;\n\toff_y = 0;\n\n\tif (rawfb_dev_video) {\n\t\tif (b == 24) {\n\t\t\trfbLog(\"enabling -24to32 for 24bpp video\\n\");\n\t\t\txform24to32 = 1;\n\t\t} else {\n\t\t\tif (xform24to32) {\n\t\t\t\trfbLog(\"disabling -24to32 for 24bpp video\\n\");\n\t\t\t}\n\t\t\txform24to32 = 0;\n\t\t}\n\t}\n\n\tif (xform24to32) {\n\t\tif (b != 24) {\n\t\t\trfbLog(\"warning: -24to32 mode and bpp=%d\\n\", b);\n\t\t}\n\t\tb = 32;\n\t}\n\tif (strstr(str, \"snap:\") == str) {\n\t\tuse_snapfb = 1;\n\t\tstr[0] = 'f'; str[1] = 'i'; str[2] = 'l'; str[3] = 'e';\n\t}\n\n\tif (strstr(str, \"shm:\") != str && strstr(str, \"mmap:\") != str &&\n\t    strstr(str, \"map:\") != str && strstr(str, \"file:\") != str) {\n\t\t/* hmmm, not following directions, see if map: applies */\n\t\tstruct stat sbuf;\n\t\tif (stat(str, &sbuf) == 0) {\n\t\t\tchar *newstr;\n\t\t\tint len = strlen(\"map:\") + strlen(str) + 1;\n\t\t\trfbLog(\"no type prefix: %s\\n\", raw_fb_str);\n\t\t\trfbLog(\"  but file exists, so assuming: map:%s\\n\",\n\t\t\t    raw_fb_str);\n\t\t\tnewstr = (char *) malloc(len);\n\t\t\tstrcpy(newstr, \"map:\");\n\t\t\tstrcat(newstr, str);\n\t\t\tfree(str);\n\t\t\tstr = newstr;\n\t\t}\n\t}\n\n\tif (sscanf(str, \"shm:%d\", &shmid) == 1) {\n\t\t/* shm:N */\n#if HAVE_XSHM || HAVE_SHMAT\n\t\traw_fb_addr = (char *) shmat(shmid, 0, SHM_RDONLY);\n\t\tif (! raw_fb_addr) {\n\t\t\trfbLogEnable(1);\n\t\t\trfbLog(\"failed to attach to shm: %d, %s\\n\", shmid, str);\n\t\t\trfbLogPerror(\"shmat\");\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\traw_fb_shm = 1;\n\t\trfbLog(\"rawfb: shm: %d W: %d H: %d B: %d addr: %p\\n\",\n\t\t    shmid, w, h, b, raw_fb_addr);\n\t\tlast_mode = RAWFB_SHM;\n#else\n\t\trfbLogEnable(1);\n\t\trfbLog(\"x11vnc was compiled without shm support.\\n\");\n\t\trfbLogPerror(\"shmat\");\n\t\tclean_up_exit(1);\n#endif\n\t} else if (strstr(str, \"map:\") == str || strstr(str, \"mmap:\") == str\n\t    || strstr(str, \"file:\") == str) {\n\t\t/* map:/path/... or file:/path  */\n\t\tint fd, do_mmap = 1, size, vsize = 0;\n\t\tstruct stat sbuf;\n\n\t\tif (*str == 'f') {\n\t\t\tdo_mmap = 0;\n\t\t}\n\t\tq = strchr(str, ':');\n\t\tq++;\n\n\t\tmacosx_console = 0;\n\t\tif (strstr(q, \"macosx:\") == q) {\n\t\t\t/* mmap:macosx:/dev/null@... */\n\t\t\tq += strlen(\"macosx:\");\t\t\t\n\t\t\tdo_macosx = 1;\n\t\t\tdo_mmap = 0;\n\t\t\tmacosx_console = 1;\n\t\t}\n\n\t\tlast_file = strdup(q);\n\n\t\tfd = raw_fb_fd;\n\t\tif (fd < 0 && rawfb_dev_video) {\n\t\t\tfd = open(q, O_RDWR);\n\t\t}\n\t\tif (fd < 0) {\n\t\t\tfd = open(q, O_RDONLY);\n\t\t}\n\t\tif (fd < 0) {\n\t\t\trfbLogEnable(1);\n\t\t\trfbLog(\"failed to open file: %s, %s\\n\", q, str);\n\t\t\trfbLogPerror(\"open\");\n\t\t\tlinux_dev_fb_msg(q);\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\traw_fb_fd = fd;\n\n\t\tif (raw_fb_native_bpp < 8) {\n\t\t\tsize = w*h*raw_fb_native_bpp/8 + raw_fb_offset;\n\t\t} else if (xform24to32) {\n\t\t\tsize = w*h*24/8 + raw_fb_offset;\n\t\t} else if (raw_fb_virt_x != 0 && raw_fb_virt_y != 0) {\n\t\t\tsize = w*h*b/8;\n\t\t\tvsize = raw_fb_virt_x*raw_fb_virt_y*b/8;\n\t\t\trawfb_double_buffer = 1;\n\t\t\trfbLog(\"virtual size: %d\", vsize);\n\t\t} else {\n\t\t\tsize = w*h*b/8 + raw_fb_offset;\n\t\t}\n\n\t\tif (fstat(fd, &sbuf) == 0) {\n\t\t\tif (S_ISREG(sbuf.st_mode)) {\n\t\t\t\tif (0) size = sbuf.st_size;\n\t\t\t} else {\n\t\t\t\trfbLog(\"raw fb is non-regular file: %s\\n\", q);\n\t\t\t}\n\t\t}\n\n\t\tif (do_macosx) {\n\t\t\traw_fb_addr = macosx_get_fb_addr();\n\t\t\traw_fb_mmap = size;\n\t\t\trfbLog(\"rawfb: macosx fb: %s\\n\", q);\n\t\t\trfbLog(\"   w: %d h: %d b: %d addr: %p sz: %d\\n\", w, h,\n\t\t\t    b, raw_fb_addr, size);\n\t\t\tlast_mode = 0;\n\t\t} else if (do_reflect) {\n\t\t\traw_fb_mmap = size;\n\t\t\trfbLog(\"rawfb: vnc fb: %s\\n\", q);\n\t\t\trfbLog(\"   w: %d h: %d b: %d addr: %p sz: %d\\n\", w, h,\n\t\t\t    b, raw_fb_addr, size);\n\t\t\tlast_mode = 0;\n\n\t\t} else if (do_mmap) {\n#if LIBVNCSERVER_HAVE_MMAP\n\t\t\tif (vsize != 0) {\n\t\t\t\traw_fb_addr = mmap(0, vsize, PROT_READ, MAP_SHARED, fd, 0);\n\t\t\t} else {\n\t\t\t\traw_fb_addr = mmap(0, size, PROT_READ, MAP_SHARED, fd, 0);\n\t\t\t}\n\n\t\t\tif (raw_fb_addr == MAP_FAILED || raw_fb_addr == NULL) {\n\t\t\t\trfbLogEnable(1);\n\t\t\t\trfbLog(\"failed to mmap file: %s, %s\\n\", q, str);\n\t\t\t\trfbLog(\"   raw_fb_addr: %p\\n\", raw_fb_addr);\n\t\t\t\trfbLogPerror(\"mmap\");\n\n\t\t\t\traw_fb_addr = NULL;\n\t\t\t\trfbLog(\"mmap(2) failed, trying slower lseek(2)\\n\");\n\t\t\t\traw_fb_seek = size;\n\t\t\t\tlast_mode = RAWFB_FILE;\n\n\t\t\t} else {\n\t\t\t\traw_fb_mmap = size;\n\n\t\t\t\trfbLog(\"rawfb: mmap file: %s\\n\", q);\n\t\t\t\tif (vsize != 0) {\n\t\t\t\t\trfbLog(\"   w: %d h: %d b: %d addr: %p sz: %d\\n\", w, h,\n\t\t\t\t\t\tb, raw_fb_addr, vsize);\n\t\t\t\t} else {\n\t\t\t\t\trfbLog(\"   w: %d h: %d b: %d addr: %p sz: %d\\n\", w, h,\n\t\t\t\t\t\tb, raw_fb_addr, size);\n\t\t\t\t}\n\t\t\t\tlast_mode = RAWFB_MMAP;\n\t\t\t}\n#else\n\t\t\trfbLog(\"mmap(2) not supported on system, using\"\n\t\t\t    \" slower lseek(2)\\n\");\n\t\t\traw_fb_seek = size;\n\t\t\tlast_mode = RAWFB_FILE;\n#endif\n\t\t} else {\n\t\t\traw_fb_seek = size;\n\t\t\tlast_mode = RAWFB_FILE;\n\n\t\t\trfbLog(\"rawfb: seek file: %s\\n\", q);\n\t\t\trfbLog(\"   W: %d H: %d B: %d sz: %d\\n\", w, h, b, size);\n\t\t}\n\t} else {\n\t\trfbLogEnable(1);\n\t\trfbLog(\"invalid rawfb str: %s\\n\", str);\n\t\tclean_up_exit(1);\n\t}\n\n\tif (unlink_me) {\n\t\tunlink(unlink_me);\n\t}\n\n\tif (! raw_fb_image) {\n\t\traw_fb_image = &ximage_struct;\n\t}\n\n\tinitialize_clipshift();\n\n\tif (raw_fb_bytes_per_line == 0) {\n\t\traw_fb_bytes_per_line = dpy_x*b/8;\n\n\t\t/*\n\t\t * Put cases here were we can determine that\n\t\t * raw_bytes_per_line != dpy_x*b/8\n\t\t */\n#ifdef MACOSX\n\t\tif (do_macosx) {\n\t\t\traw_fb_bytes_per_line = macosxCG_CGDisplayBytesPerRow();\n\t\t}\n#endif\n\t}\n\n\traw_fb_image->bytes_per_line = dpy_x * b/8;\n\traw_fb = (char *) malloc(dpy_y * dpy_x * b/8);\n\traw_fb_image->data = raw_fb;\n\traw_fb_image->format = ZPixmap;\n\traw_fb_image->width  = dpy_x;\n\traw_fb_image->height = dpy_y;\n\traw_fb_image->bits_per_pixel = b;\n\traw_fb_image->bitmap_unit = -1;\n\n\n\tif (use_snapfb && (raw_fb_seek || raw_fb_mmap)) {\n\t\tint b_use = b;\n\t\tif (snap_fb) {\n\t\t\tfree(snap_fb);\n\t\t}\n\t\tif (b_use == 32 && xform24to32) {\n\t\t\t/*\n\t\t\t * The actual framebuffer (e.g. mapped addr) and\n\t\t\t * snap fb must be the same bpp.  E.g. both 24bpp.\n\t\t\t * Reading FROM snap to utility image will be\n\t\t\t * transformed 24->32 in copy_raw_fb_24_to_32.\n\t\t\t *\n\t\t\t * addr -> snap -> (scanline, fullscreen, ...)\n\t\t\t */\n\t\t\tb_use = 24;\n\t\t\traw_fb_bytes_per_line = dpy_x * b_use/8;\n\t\t}\n\t\tsnap_fb = (char *) malloc(dpy_y * dpy_x * b_use/8);\n\t\tsnap = &ximage_struct_snap;\n\t\tsnap->data = snap_fb;\n\t\tsnap->format = ZPixmap;\n\t\tsnap->width  = dpy_x;\n\t\tsnap->height = dpy_y;\n\t\tsnap->bits_per_pixel = b_use;\n\t\tsnap->bytes_per_line = dpy_x * b_use/8;\n\t\tsnap->bitmap_unit = -1;\n\t}\n\n\n\traw_fb_image->red_mask = rm;\n\traw_fb_image->green_mask = gm;\n\traw_fb_image->blue_mask = bm;\n\n\traw_fb_image->depth = 0;\n\tm = 1;\n\tfor (i=0; i<32; i++)  {\n\t\tif (rm & m) {\n\t\t\traw_fb_image->depth++;\n\t\t}\n\t\tif (gm & m) {\n\t\t\traw_fb_image->depth++;\n\t\t}\n\t\tif (bm & m) {\n\t\t\traw_fb_image->depth++;\n\t\t}\n\t\tm = m << 1;\n\t}\n\tif (raw_fb_native_bpp < 8) {\n\t\traw_fb_image->depth = raw_fb_expand_bytes * 8;\n\t}\n\tif (! raw_fb_image->depth) { \n\t\traw_fb_image->depth = (b == 32) ? 24 : b;\n\t}\n\n\tdepth = raw_fb_image->depth;\n\n\tif (raw_fb_image->depth == 15) {\n\t\t/* unresolved bug with RGB555... */\n\t\tdepth++;\n\t}\n\n\tif (clipshift || raw_fb_native_bpp < 8) {\n\t\tmemset(raw_fb, 0xff, dpy_y * raw_fb_image->bytes_per_line);\n\t} else if (raw_fb_addr && ! xform24to32) {\n\t\tmemcpy(raw_fb, raw_fb_addr + raw_fb_offset, dpy_y * raw_fb_image->bytes_per_line);\n\t} else {\n\t\tmemset(raw_fb, 0xff, dpy_y * raw_fb_image->bytes_per_line);\n\t}\n\n\tif (verbose) {\n\t\trfbLog(\"\\n\");\n\t\trfbLog(\"rawfb:  raw_fb  %p\\n\", raw_fb);\n\t\trfbLog(\"        format  %d\\n\", raw_fb_image->format);\n\t\trfbLog(\"        width   %d\\n\", raw_fb_image->width);\n\t\trfbLog(\"        height  %d\\n\", raw_fb_image->height);\n\t\trfbLog(\"        bpp     %d\\n\", raw_fb_image->bits_per_pixel);\n\t\trfbLog(\"        depth   %d\\n\", raw_fb_image->depth);\n\t\trfbLog(\"        bpl     %d\\n\", raw_fb_image->bytes_per_line);\n\t\tif (use_snapfb && snap_fb) {\n\t\t\trfbLog(\"        snap_fb %p\\n\", snap_fb);\n\t\t}\n\t}\n\n\tfree(str);\n\n\treturn raw_fb_image;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clean_up_exit",
          "args": [
            "1"
          ],
          "line": 2761
        },
        "resolved": true,
        "details": {
          "function_name": "clean_up_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
          "lines": "151-266",
          "snippet": "void clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"uinput.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"screen.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"connections.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void clean_up_exit(int ret);",
            "int known_sigpipe_mode(char *s);",
            "static int exit_flag = 0;",
            "static void clean_icon_mode(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid clean_up_exit(int ret);\nint known_sigpipe_mode(char *s);\nstatic int exit_flag = 0;\nstatic void clean_icon_mode(void);\n\nvoid clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"copy_snap: rawfb mode and null snap fb\\n\""
          ],
          "line": 2760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"SNAPFB_RAWFB_RESET\""
          ],
          "line": 2753
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <default8x16.h>\n#include \"userinput.h\"\n#include \"macosx.h\"\n#include \"screen.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"8to24.h\"\n#include \"win_utils.h\"\n#include \"xrandr.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nvoid shm_delete(XShmSegmentInfo *shm);\nint copy_snap(void);\nstatic int fs_factor = 0;\n\nint copy_snap(void) {\n\tint db = 1;\n\tchar *fbp;\n\tint i, y, block_size;\n\tdouble dt;\n\tstatic int first = 1, snapcnt = 0;\n\n\tif (raw_fb_str) {\n\t\tint read_all_at_once = 1;\n\t\tdouble start = dnow();\n\t\tif (rawfb_reset < 0) {\n\t\t\tif (getenv(\"SNAPFB_RAWFB_RESET\")) {\n\t\t\t\trawfb_reset = 1;\n\t\t\t} else {\n\t\t\t\trawfb_reset = 0;\n\t\t\t}\n\t\t}\n\t\tif (snap_fb == NULL || snap == NULL) {\n\t\t\trfbLog(\"copy_snap: rawfb mode and null snap fb\\n\"); \n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tif (rawfb_reset) {\n\t\t\tinitialize_raw_fb(1);\n\t\t}\n\t\tif (raw_fb_bytes_per_line != snap->bytes_per_line) {\n\t\t\tread_all_at_once = 0;\n\t\t}\n\t\tif (raw_fb_full_str && strstr(raw_fb_full_str, \"/dev/vcsa\")) {\n\t\t\tsnap_vcsa_rawfb();\n\t\t} else if (read_all_at_once) {\n\t\t\tsnap_all_rawfb();\n\t\t} else {\n\t\t\t/* this goes line by line, XXX not working for video */\n\t\t\tcopy_raw_fb(snap, 0, 0, dpy_x, dpy_y);\n\t\t}\nif (db && snapcnt++ < 5) rfbLog(\"rawfb copy_snap took: %.5f secs\\n\", dnow() - start);\n\n\t\treturn 0;\n\t}\n\t\n\tif (! fs_factor) {\n\t\treturn 0;\n\t}\n\n\n\tif (! snap_fb || ! snap || ! snaprect) {\n\t\treturn 0;\n\t}\n\tblock_size = ((dpy_y/fs_factor) * snap->bytes_per_line);\n\n\tfbp = snap_fb;\n\ty = 0;\n\n\n\tdtime0(&dt);\n\tX_LOCK;\n\n\t/* screen may be too big for 1 shm area, so broken into fs_factor */\n\tfor (i=0; i < fs_factor; i++) {\n\t\tXRANDR_SET_TRAP_RET(-1, \"copy_snap-set\");\n\t\tcopy_image(snaprect, 0, y, 0, 0);\n\t\tXRANDR_CHK_TRAP_RET(-1, \"copy_snap-chk\");\n\n\t\tmemcpy(fbp, snaprect->data, (size_t) block_size);\n\n\t\ty += dpy_y / fs_factor;\n\t\tfbp += block_size;\n\t}\n\n\tX_UNLOCK;\n\n\tdt = dtime(&dt);\n\tif (first) {\n\t\trfbLog(\"copy_snap: time for -snapfb snapshot: %.3f sec\\n\", dt);\n\t\tfirst = 0;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "snap_all_rawfb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/scan.c",
    "lines": "2677-2740",
    "snippet": "static void snap_all_rawfb(void) {\n\tint pixelsize = bpp/8;\n\tint n, sz;\n\tchar *dst;\n\tstatic char *unclipped_dst = NULL;\n\tstatic int unclipped_len = 0;\n\n\tdst = snap->data;\n\n\tif (xform24to32 && bpp == 32) {\n\t\tpixelsize = 3;\n\t}\n\tsz = dpy_y * snap->bytes_per_line;\n\n\tif (wdpy_x > dpy_x || wdpy_y > dpy_y) {\n\t\tsz = wdpy_x * wdpy_y * pixelsize;\n\t\tif (sz > unclipped_len || unclipped_dst == NULL) {\n\t\t\tif (unclipped_dst) {\n\t\t\t\tfree(unclipped_dst);\n\t\t\t}\n\t\t\tunclipped_dst = (char *) malloc(sz+4);\n\t\t\tunclipped_len = sz;\n\t\t}\n\t\tdst = unclipped_dst;\n\t}\n\t\t\n\tif (! raw_fb_seek) {\n\t\tmemcpy(dst, raw_fb_addr + raw_fb_offset, sz);\n\n\t} else {\n\t\tint len = sz, del = 0;\n\t\toff_t off = (off_t) raw_fb_offset;\n\n\t\tlseek(raw_fb_fd, off, SEEK_SET);\n\t\twhile (len > 0) {\n\t\t\tn = read(raw_fb_fd, dst + del, len);\n\t\t\tif (n > 0) {\n\t\t\t\tdel += n;\n\t\t\t\tlen -= n;\n\t\t\t} else if (n == 0) {\n\t\t\t\tbreak;\n\t\t\t} else if (errno != EINTR && errno != EAGAIN) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (dst == unclipped_dst) {\n\t\tchar *src;\n\t\tint h;\n\t\tint x = off_x + coff_x;\n\t\tint y = off_y + coff_y;\n\n\t\tsrc = unclipped_dst + y * wdpy_x * pixelsize +\n\t\t    x * pixelsize;\n\t\tdst = snap->data;\n\n\t\tfor (h = 0; h < dpy_y; h++) {\n\t\t\tmemcpy(dst, src, dpy_x * pixelsize);\n\t\t\tsrc += wdpy_x * pixelsize;\n\t\t\tdst += snap->bytes_per_line;\n\t\t}\n\t}\n}",
    "includes": [
      "#include <default8x16.h>",
      "#include \"userinput.h\"",
      "#include \"macosx.h\"",
      "#include \"screen.h\"",
      "#include \"unixpw.h\"",
      "#include \"cleanup.h\"",
      "#include \"pointer.h\"",
      "#include \"screen.h\"",
      "#include \"8to24.h\"",
      "#include \"win_utils.h\"",
      "#include \"xrandr.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"xinerama.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int blackout_line_cmpskip(int n, int x, int y, char *dst, char *src,\n    int w, int pixelsize);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dst",
            "src",
            "dpy_x * pixelsize"
          ],
          "line": 2735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read",
          "args": [
            "raw_fb_fd",
            "dst + del",
            "len"
          ],
          "line": 2712
        },
        "resolved": true,
        "details": {
          "function_name": "read_exact",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "1292-1317",
          "snippet": "static int read_exact(int sock, char *buf, int len) {\n\tint n, fail = 0;\n\tif (sock < 0) {\n\t\treturn 0;\n\t}\n\twhile (len > 0) {\n\t\tn = read(sock, buf, len);\n\t\tif (n > 0) {\n\t\t\tbuf += n;\n\t\t\tlen -= n;\n\t\t} else if (n == 0) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t} else if (n < 0 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n\t\t\tusleep(10*1000);\n\t\t} else if (n < 0 && errno != EINTR) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fail) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void ssl_helper_pid(pid_t pid, int sock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid ssl_helper_pid(pid_t pid, int sock);\n\nstatic int read_exact(int sock, char *buf, int len) {\n\tint n, fail = 0;\n\tif (sock < 0) {\n\t\treturn 0;\n\t}\n\twhile (len > 0) {\n\t\tn = read(sock, buf, len);\n\t\tif (n > 0) {\n\t\t\tbuf += n;\n\t\t\tlen -= n;\n\t\t} else if (n == 0) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t} else if (n < 0 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n\t\t\tusleep(10*1000);\n\t\t} else if (n < 0 && errno != EINTR) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fail) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "lseek",
          "args": [
            "raw_fb_fd",
            "off",
            "SEEK_SET"
          ],
          "line": 2710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dst",
            "raw_fb_addr + raw_fb_offset",
            "sz"
          ],
          "line": 2704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sz+4"
          ],
          "line": 2697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "unclipped_dst"
          ],
          "line": 2695
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <default8x16.h>\n#include \"userinput.h\"\n#include \"macosx.h\"\n#include \"screen.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"8to24.h\"\n#include \"win_utils.h\"\n#include \"xrandr.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nstatic int blackout_line_cmpskip(int n, int x, int y, char *dst, char *src,\n    int w, int pixelsize);\n\nstatic void snap_all_rawfb(void) {\n\tint pixelsize = bpp/8;\n\tint n, sz;\n\tchar *dst;\n\tstatic char *unclipped_dst = NULL;\n\tstatic int unclipped_len = 0;\n\n\tdst = snap->data;\n\n\tif (xform24to32 && bpp == 32) {\n\t\tpixelsize = 3;\n\t}\n\tsz = dpy_y * snap->bytes_per_line;\n\n\tif (wdpy_x > dpy_x || wdpy_y > dpy_y) {\n\t\tsz = wdpy_x * wdpy_y * pixelsize;\n\t\tif (sz > unclipped_len || unclipped_dst == NULL) {\n\t\t\tif (unclipped_dst) {\n\t\t\t\tfree(unclipped_dst);\n\t\t\t}\n\t\t\tunclipped_dst = (char *) malloc(sz+4);\n\t\t\tunclipped_len = sz;\n\t\t}\n\t\tdst = unclipped_dst;\n\t}\n\t\t\n\tif (! raw_fb_seek) {\n\t\tmemcpy(dst, raw_fb_addr + raw_fb_offset, sz);\n\n\t} else {\n\t\tint len = sz, del = 0;\n\t\toff_t off = (off_t) raw_fb_offset;\n\n\t\tlseek(raw_fb_fd, off, SEEK_SET);\n\t\twhile (len > 0) {\n\t\t\tn = read(raw_fb_fd, dst + del, len);\n\t\t\tif (n > 0) {\n\t\t\t\tdel += n;\n\t\t\t\tlen -= n;\n\t\t\t} else if (n == 0) {\n\t\t\t\tbreak;\n\t\t\t} else if (errno != EINTR && errno != EAGAIN) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (dst == unclipped_dst) {\n\t\tchar *src;\n\t\tint h;\n\t\tint x = off_x + coff_x;\n\t\tint y = off_y + coff_y;\n\n\t\tsrc = unclipped_dst + y * wdpy_x * pixelsize +\n\t\t    x * pixelsize;\n\t\tdst = snap->data;\n\n\t\tfor (h = 0; h < dpy_y; h++) {\n\t\t\tmemcpy(dst, src, dpy_x * pixelsize);\n\t\t\tsrc += wdpy_x * pixelsize;\n\t\t\tdst += snap->bytes_per_line;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "snap_vcsa_rawfb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/scan.c",
    "lines": "2486-2675",
    "snippet": "static void snap_vcsa_rawfb(void) {\n\tint n;\n\tchar *dst;\n\tchar buf[32];\n\tint i, len, del;\n\tunsigned char rows, cols, xpos, ypos;\n\tstatic int prev_rows = -1, prev_cols = -1;\n\tstatic unsigned char prev_xpos = -1, prev_ypos = -1;\n\tstatic char *vcsabuf  = NULL;\n\tstatic char *vcsabuf0 = NULL;\n\tstatic unsigned int color_tab[16];\n\tstatic int Cw = 8, Ch = 16;\n\tstatic int db = -1, first = 1;\n\tint created = 0;\n\trfbScreenInfo s;\n\trfbScreenInfoPtr fake_screen = &s;\n\tint Bpp = raw_fb_native_bpp / 8;\n\n\tif (db < 0) {\n\t\tif (getenv(\"X11VNC_DEBUG_VCSA\")) {\n\t\t\tdb = atoi(getenv(\"X11VNC_DEBUG_VCSA\"));\n\t\t} else {\n\t\t\tdb = 0;\n\t\t}\n\t}\n\n\tif (first) {\n\t\tunsigned int rm = raw_fb_native_red_mask;\n\t\tunsigned int gm = raw_fb_native_green_mask;\n\t\tunsigned int bm = raw_fb_native_blue_mask;\n\t\tunsigned int rs = raw_fb_native_red_shift;\n\t\tunsigned int gs = raw_fb_native_green_shift;\n\t\tunsigned int bs = raw_fb_native_blue_shift;\n\t\tunsigned int rx = raw_fb_native_red_max;\n\t\tunsigned int gx = raw_fb_native_green_max;\n\t\tunsigned int bx = raw_fb_native_blue_max;\n\n\t\tfor (i=0; i < 16; i++) {\n\t\t\tint r = console_cmap[3*i+0];\n\t\t\tint g = console_cmap[3*i+1];\n\t\t\tint b = console_cmap[3*i+2];\n\t\t\tr = rx * r / 255;\n\t\t\tg = gx * g / 255;\n\t\t\tb = bx * b / 255;\n\t\t\tcolor_tab[i] = (r << rs) | (g << gs) | (b << bs);\n\t\t\tif (db) fprintf(stderr, \"cmap[%02d] 0x%08x  %04d %04d %04d\\n\", i, color_tab[i], r, g, b); \n\t\t\tif (i != 0 && getenv(\"RAWFB_VCSA_BW\")) {\n\t\t\t\tcolor_tab[i] = rm | gm | bm;\n\t\t\t}\n\t\t}\n\t}\n\tfirst = 0;\n\n\tlseek(raw_fb_fd, 0, SEEK_SET);\n\tlen = 4;\n\tdel = 0;\n\tmemset(buf, 0, sizeof(buf));\n\twhile (len > 0) {\n\t\tn = read(raw_fb_fd, buf + del, len);\n\t\tif (n > 0) {\n\t\t\tdel += n;\n\t\t\tlen -= n;\n\t\t} else if (n == 0) {\n\t\t\tbreak;\n\t\t} else if (errno != EINTR && errno != EAGAIN) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\trows = (unsigned char) buf[0];\n\tcols = (unsigned char) buf[1];\n\txpos = (unsigned char) buf[2];\n\typos = (unsigned char) buf[3];\n\n\tif (db) fprintf(stderr, \"rows=%d cols=%d xpos=%d ypos=%d Bpp=%d\\n\", rows, cols, xpos, ypos, Bpp);\n\tif (rows == 0 || cols == 0) {\n\t\tusleep(100 * 1000);\n\t\treturn;\n\t}\n\n\tif (vcsabuf == NULL || prev_rows != rows || prev_cols != cols) {\n\t\tif (vcsabuf) {\n\t\t\tfree(vcsabuf);\n\t\t\tfree(vcsabuf0);\n\t\t}\n\t\tvcsabuf  = (char *) calloc(2 * rows * cols, 1);\n\t\tvcsabuf0 = (char *) calloc(2 * rows * cols, 1);\n\t\tcreated = 1;\n\n\t\tif (prev_rows != -1 && prev_cols != -1) {\n\t\t\tdo_new_fb(1);\n\t\t}\n\n\t\tprev_rows = rows;\n\t\tprev_cols = cols;\n\t}\n\n\tif (!rfbEndianTest) {\n\t\tunsigned char tc = rows;\n\t\trows = cols;\n\t\tcols = tc;\n\n\t\ttc = xpos;\n\t\txpos = ypos;\n\t\typos = tc;\n\t}\n\n\tlen = 2 * rows * cols;\n\tdel = 0;\n\tmemset(vcsabuf, 0, len);\n\twhile (len > 0) {\n\t\tn = read(raw_fb_fd, vcsabuf + del, len);\n\t\tif (n > 0) {\n\t\t\tdel += n;\n\t\t\tlen -= n;\n\t\t} else if (n == 0) {\n\t\t\tbreak;\n\t\t} else if (errno != EINTR && errno != EAGAIN) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfake_screen->frameBuffer = snap->data;\n\tfake_screen->paddedWidthInBytes = snap->bytes_per_line;\n\tfake_screen->serverFormat.bitsPerPixel = raw_fb_native_bpp;\n\tfake_screen->width = snap->width;\n\tfake_screen->height = snap->height;\n\n\tfor (i=0; i < rows * cols; i++) {\n\t\tint ix, iy, x, y, w, h;\n\t\tunsigned char chr = 0;\n\t\tunsigned char attr;\n\t\tunsigned int fore, back;\n\t\tunsigned short *usp;\n\t\tunsigned int *uip;\n\t\tchr  = (unsigned char) vcsabuf[2*i];\n\t\tattr = vcsabuf[2*i+1];\n\n\t\tiy = i / cols;\n\t\tix = i - iy * cols;\n\n\t\tif (ix == prev_xpos && iy == prev_ypos) {\n\t\t\t;\n\t\t} else if (ix == xpos && iy == ypos) {\n\t\t\t;\n\t\t} else if (!created && chr == vcsabuf0[2*i] && attr == vcsabuf0[2*i+1]) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!rfbEndianTest) {\n\t\t\tunsigned char tc = chr;\n\t\t\tchr = attr;\n\t\t\tattr = tc;\n\t\t}\n\n\t\ty = iy * Ch;\n\t\tx = ix * Cw;\n\t\tdst = snap->data + y * snap->bytes_per_line + x * Bpp;\n\n\t\tfore = color_tab[attr & 0xf];\n\t\tback = color_tab[(attr >> 4) & 0x7];\n\n\t\tif (ix == xpos && iy == ypos) {\n\t\t\tunsigned int ti = fore;\n\t\t\tfore = back;\n\t\t\tback = ti;\n\t\t}\n\n\t\tfor (h = 0; h < Ch; h++) {\n\t\t\tif (Bpp == 1) {\n\t\t\t\tmemset(dst, back, Cw);\n\t\t\t} else if (Bpp == 2) {\n\t\t\t\tfor (w = 0; w < Cw; w++) {\n\t\t\t\t\tusp = (unsigned short *) (dst + w*Bpp); \n\t\t\t\t\t*usp = (unsigned short) back;\n\t\t\t\t}\n\t\t\t} else if (Bpp == 4) {\n\t\t\t\tfor (w = 0; w < Cw; w++) {\n\t\t\t\t\tuip = (unsigned int *) (dst + w*Bpp); \n\t\t\t\t\t*uip = (unsigned int) back;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdst += snap->bytes_per_line;\n\t\t}\n\t\trfbDrawChar(fake_screen, &default8x16Font, x, y + Ch, chr, fore);\n\t}\n\tmemcpy(vcsabuf0, vcsabuf, 2 * rows * cols); \n\tprev_xpos = xpos;\n\tprev_ypos = ypos;\n}",
    "includes": [
      "#include <default8x16.h>",
      "#include \"userinput.h\"",
      "#include \"macosx.h\"",
      "#include \"screen.h\"",
      "#include \"unixpw.h\"",
      "#include \"cleanup.h\"",
      "#include \"pointer.h\"",
      "#include \"screen.h\"",
      "#include \"8to24.h\"",
      "#include \"win_utils.h\"",
      "#include \"xrandr.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"xinerama.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void rotate_curs(char *dst_0, char *src_0, int Dx, int Dy, int Bpp);",
      "static unsigned char console_cmap[16*3]={\n/*  0 */\t0x00, 0x00, 0x00,\n/*  1 */\t0x00, 0x00, 0xAA,\n/*  2 */\t0x00, 0xAA, 0x00,\n/*  3 */\t0x00, 0xAA, 0xAA,\n/*  4 */\t0xAA, 0x00, 0x00,\n/*  5 */\t0xAA, 0x00, 0xAA,\n/*  6 */\t0xAA, 0x55, 0x00,\n/*  7 */\t0xAA, 0xAA, 0xAA,\n/*  8 */\t0x55, 0x55, 0x55,\n/*  9 */\t0x55, 0x55, 0xAA,\n/* 10 */\t0x55, 0xFF, 0x55,\n/* 11 */\t0x55, 0xFF, 0xFF,\n/* 12 */\t0xFF, 0x55, 0x55,\n/* 13 */\t0xFF, 0x55, 0xFF,\n/* 14 */\t0xFF, 0xFF, 0x00,\n/* 15 */\t0xFF, 0xFF, 0xFF\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "vcsabuf0",
            "vcsabuf",
            "2 * rows * cols"
          ],
          "line": 2672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbDrawChar",
          "args": [
            "fake_screen",
            "&default8x16Font",
            "x",
            "y + Ch",
            "chr",
            "fore"
          ],
          "line": 2670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "dst",
            "back",
            "Cw"
          ],
          "line": 2656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read",
          "args": [
            "raw_fb_fd",
            "vcsabuf + del",
            "len"
          ],
          "line": 2597
        },
        "resolved": true,
        "details": {
          "function_name": "read_exact",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "1292-1317",
          "snippet": "static int read_exact(int sock, char *buf, int len) {\n\tint n, fail = 0;\n\tif (sock < 0) {\n\t\treturn 0;\n\t}\n\twhile (len > 0) {\n\t\tn = read(sock, buf, len);\n\t\tif (n > 0) {\n\t\t\tbuf += n;\n\t\t\tlen -= n;\n\t\t} else if (n == 0) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t} else if (n < 0 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n\t\t\tusleep(10*1000);\n\t\t} else if (n < 0 && errno != EINTR) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fail) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void ssl_helper_pid(pid_t pid, int sock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid ssl_helper_pid(pid_t pid, int sock);\n\nstatic int read_exact(int sock, char *buf, int len) {\n\tint n, fail = 0;\n\tif (sock < 0) {\n\t\treturn 0;\n\t}\n\twhile (len > 0) {\n\t\tn = read(sock, buf, len);\n\t\tif (n > 0) {\n\t\t\tbuf += n;\n\t\t\tlen -= n;\n\t\t} else if (n == 0) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t} else if (n < 0 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n\t\t\tusleep(10*1000);\n\t\t} else if (n < 0 && errno != EINTR) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fail) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "vcsabuf",
            "0",
            "len"
          ],
          "line": 2595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_new_fb",
          "args": [
            "1"
          ],
          "line": 2576
        },
        "resolved": true,
        "details": {
          "function_name": "do_new_fb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/screen.c",
          "lines": "1008-1068",
          "snippet": "void do_new_fb(int reset_mem) {\n\tXImage *fb;\n\n\t/* for threaded we really should lock libvncserver out. */\n\tif (use_threads) {\n\t\tint ms = 1000;\n\t\tif (getenv(\"X11VNC_THREADS_NEW_FB_SLEEP\")) {\n\t\t\tms = atoi(getenv(\"X11VNC_THREADS_NEW_FB_SLEEP\"));\n\t\t} else if (subwin) {\n\t\t\tms = 500;\n\t\t} else {\n\t\t\tms = 1000;\n\t\t}\n\t\trfbLog(\"Warning: changing framebuffers in threaded mode may be unstable.\\n\");\n\t\tthreads_drop_input = 1;\n\t\tusleep(ms * 1000);\n\t}\n\n\tINPUT_LOCK;\n\tlock_client_sends(1);\n\n\tif (use_threads) {\n\t\tsettle_clients(1);\n\t}\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\tif (reset_mem == 1) {\n\t\t/* reset_mem == 2 is a hack for changing users... */\n\t\tclean_shm(0);\n\t\tfree_tiles();\n\t}\n\n\tfree_old_fb();\n\n\tfb = initialize_xdisplay_fb();\n\n\tinitialize_screen(NULL, NULL, fb);\n\n\tif (reset_mem) {\n\t\tinitialize_tiles();\n\t\tinitialize_blackouts_and_xinerama();\n\t\tinitialize_polling_images();\n\t}\n\tif (ncache) {\n\t\tcheck_ncache(1, 0);\n\t}\n\n\tprep_clients_for_new_fb();\n\tlock_client_sends(0);\n\tINPUT_UNLOCK;\n\n\tif (use_threads) {\n\t\t/* need to let things settle... */\n\t\tsettle_clients(0);\n\t\tthreads_drop_input = 0;\n\t}\n}",
          "includes": [
            "#include <rfb/rfbclient.h>",
            "#include \"xi2_devices.h\"",
            "#include \"pm.h\"",
            "#include \"xrecord.h\"",
            "#include \"xrandr.h\"",
            "#include \"inet.h\"",
            "#include \"solid.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"linuxfb.h\"",
            "#include \"v4l.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"remote.h\"",
            "#include \"connections.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"pointer.h\"",
            "#include \"rates.h\"",
            "#include \"user.h\"",
            "#include \"scan.h\"",
            "#include \"userinput.h\"",
            "#include \"cleanup.h\"",
            "#include \"win_utils.h\"",
            "#include \"xdamage.h\"",
            "#include \"xinerama.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xevents.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void do_new_fb(int reset_mem);",
            "void free_old_fb(void);",
            "XImage *initialize_xdisplay_fb(void);",
            "int parse_rotate_string(char *str, int *mode);",
            "void initialize_screen(int *argc, char **argv, XImage *fb);",
            "static void debug_colormap(XImage *fb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <rfb/rfbclient.h>\n#include \"xi2_devices.h\"\n#include \"pm.h\"\n#include \"xrecord.h\"\n#include \"xrandr.h\"\n#include \"inet.h\"\n#include \"solid.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"remote.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"scan.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xdamage.h\"\n#include \"xinerama.h\"\n#include \"xwrappers.h\"\n#include \"xevents.h\"\n#include \"x11vnc.h\"\n\nvoid do_new_fb(int reset_mem);\nvoid free_old_fb(void);\nXImage *initialize_xdisplay_fb(void);\nint parse_rotate_string(char *str, int *mode);\nvoid initialize_screen(int *argc, char **argv, XImage *fb);\nstatic void debug_colormap(XImage *fb);\n\nvoid do_new_fb(int reset_mem) {\n\tXImage *fb;\n\n\t/* for threaded we really should lock libvncserver out. */\n\tif (use_threads) {\n\t\tint ms = 1000;\n\t\tif (getenv(\"X11VNC_THREADS_NEW_FB_SLEEP\")) {\n\t\t\tms = atoi(getenv(\"X11VNC_THREADS_NEW_FB_SLEEP\"));\n\t\t} else if (subwin) {\n\t\t\tms = 500;\n\t\t} else {\n\t\t\tms = 1000;\n\t\t}\n\t\trfbLog(\"Warning: changing framebuffers in threaded mode may be unstable.\\n\");\n\t\tthreads_drop_input = 1;\n\t\tusleep(ms * 1000);\n\t}\n\n\tINPUT_LOCK;\n\tlock_client_sends(1);\n\n\tif (use_threads) {\n\t\tsettle_clients(1);\n\t}\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\tif (reset_mem == 1) {\n\t\t/* reset_mem == 2 is a hack for changing users... */\n\t\tclean_shm(0);\n\t\tfree_tiles();\n\t}\n\n\tfree_old_fb();\n\n\tfb = initialize_xdisplay_fb();\n\n\tinitialize_screen(NULL, NULL, fb);\n\n\tif (reset_mem) {\n\t\tinitialize_tiles();\n\t\tinitialize_blackouts_and_xinerama();\n\t\tinitialize_polling_images();\n\t}\n\tif (ncache) {\n\t\tcheck_ncache(1, 0);\n\t}\n\n\tprep_clients_for_new_fb();\n\tlock_client_sends(0);\n\tINPUT_UNLOCK;\n\n\tif (use_threads) {\n\t\t/* need to let things settle... */\n\t\tsettle_clients(0);\n\t\tthreads_drop_input = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "2 * rows * cols",
            "1"
          ],
          "line": 2572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "2 * rows * cols",
            "1"
          ],
          "line": 2571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "vcsabuf0"
          ],
          "line": 2569
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "100 * 1000"
          ],
          "line": 2562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"rows=%d cols=%d xpos=%d ypos=%d Bpp=%d\\n\"",
            "rows",
            "cols",
            "xpos",
            "ypos",
            "Bpp"
          ],
          "line": 2560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "buf",
            "0",
            "sizeof(buf)"
          ],
          "line": 2542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lseek",
          "args": [
            "raw_fb_fd",
            "0",
            "SEEK_SET"
          ],
          "line": 2539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"RAWFB_VCSA_BW\""
          ],
          "line": 2532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"cmap[%02d] 0x%08x  %04d %04d %04d\\n\"",
            "i",
            "color_tab[i]",
            "r",
            "g",
            "b"
          ],
          "line": 2531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "getenv(\"X11VNC_DEBUG_VCSA\")"
          ],
          "line": 2506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"X11VNC_DEBUG_VCSA\""
          ],
          "line": 2506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"X11VNC_DEBUG_VCSA\""
          ],
          "line": 2505
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <default8x16.h>\n#include \"userinput.h\"\n#include \"macosx.h\"\n#include \"screen.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"8to24.h\"\n#include \"win_utils.h\"\n#include \"xrandr.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nvoid rotate_curs(char *dst_0, char *src_0, int Dx, int Dy, int Bpp);\nstatic unsigned char console_cmap[16*3]={\n/*  0 */\t0x00, 0x00, 0x00,\n/*  1 */\t0x00, 0x00, 0xAA,\n/*  2 */\t0x00, 0xAA, 0x00,\n/*  3 */\t0x00, 0xAA, 0xAA,\n/*  4 */\t0xAA, 0x00, 0x00,\n/*  5 */\t0xAA, 0x00, 0xAA,\n/*  6 */\t0xAA, 0x55, 0x00,\n/*  7 */\t0xAA, 0xAA, 0xAA,\n/*  8 */\t0x55, 0x55, 0x55,\n/*  9 */\t0x55, 0x55, 0xAA,\n/* 10 */\t0x55, 0xFF, 0x55,\n/* 11 */\t0x55, 0xFF, 0xFF,\n/* 12 */\t0xFF, 0x55, 0x55,\n/* 13 */\t0xFF, 0x55, 0xFF,\n/* 14 */\t0xFF, 0xFF, 0x00,\n/* 15 */\t0xFF, 0xFF, 0xFF\n};\n\nstatic void snap_vcsa_rawfb(void) {\n\tint n;\n\tchar *dst;\n\tchar buf[32];\n\tint i, len, del;\n\tunsigned char rows, cols, xpos, ypos;\n\tstatic int prev_rows = -1, prev_cols = -1;\n\tstatic unsigned char prev_xpos = -1, prev_ypos = -1;\n\tstatic char *vcsabuf  = NULL;\n\tstatic char *vcsabuf0 = NULL;\n\tstatic unsigned int color_tab[16];\n\tstatic int Cw = 8, Ch = 16;\n\tstatic int db = -1, first = 1;\n\tint created = 0;\n\trfbScreenInfo s;\n\trfbScreenInfoPtr fake_screen = &s;\n\tint Bpp = raw_fb_native_bpp / 8;\n\n\tif (db < 0) {\n\t\tif (getenv(\"X11VNC_DEBUG_VCSA\")) {\n\t\t\tdb = atoi(getenv(\"X11VNC_DEBUG_VCSA\"));\n\t\t} else {\n\t\t\tdb = 0;\n\t\t}\n\t}\n\n\tif (first) {\n\t\tunsigned int rm = raw_fb_native_red_mask;\n\t\tunsigned int gm = raw_fb_native_green_mask;\n\t\tunsigned int bm = raw_fb_native_blue_mask;\n\t\tunsigned int rs = raw_fb_native_red_shift;\n\t\tunsigned int gs = raw_fb_native_green_shift;\n\t\tunsigned int bs = raw_fb_native_blue_shift;\n\t\tunsigned int rx = raw_fb_native_red_max;\n\t\tunsigned int gx = raw_fb_native_green_max;\n\t\tunsigned int bx = raw_fb_native_blue_max;\n\n\t\tfor (i=0; i < 16; i++) {\n\t\t\tint r = console_cmap[3*i+0];\n\t\t\tint g = console_cmap[3*i+1];\n\t\t\tint b = console_cmap[3*i+2];\n\t\t\tr = rx * r / 255;\n\t\t\tg = gx * g / 255;\n\t\t\tb = bx * b / 255;\n\t\t\tcolor_tab[i] = (r << rs) | (g << gs) | (b << bs);\n\t\t\tif (db) fprintf(stderr, \"cmap[%02d] 0x%08x  %04d %04d %04d\\n\", i, color_tab[i], r, g, b); \n\t\t\tif (i != 0 && getenv(\"RAWFB_VCSA_BW\")) {\n\t\t\t\tcolor_tab[i] = rm | gm | bm;\n\t\t\t}\n\t\t}\n\t}\n\tfirst = 0;\n\n\tlseek(raw_fb_fd, 0, SEEK_SET);\n\tlen = 4;\n\tdel = 0;\n\tmemset(buf, 0, sizeof(buf));\n\twhile (len > 0) {\n\t\tn = read(raw_fb_fd, buf + del, len);\n\t\tif (n > 0) {\n\t\t\tdel += n;\n\t\t\tlen -= n;\n\t\t} else if (n == 0) {\n\t\t\tbreak;\n\t\t} else if (errno != EINTR && errno != EAGAIN) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\trows = (unsigned char) buf[0];\n\tcols = (unsigned char) buf[1];\n\txpos = (unsigned char) buf[2];\n\typos = (unsigned char) buf[3];\n\n\tif (db) fprintf(stderr, \"rows=%d cols=%d xpos=%d ypos=%d Bpp=%d\\n\", rows, cols, xpos, ypos, Bpp);\n\tif (rows == 0 || cols == 0) {\n\t\tusleep(100 * 1000);\n\t\treturn;\n\t}\n\n\tif (vcsabuf == NULL || prev_rows != rows || prev_cols != cols) {\n\t\tif (vcsabuf) {\n\t\t\tfree(vcsabuf);\n\t\t\tfree(vcsabuf0);\n\t\t}\n\t\tvcsabuf  = (char *) calloc(2 * rows * cols, 1);\n\t\tvcsabuf0 = (char *) calloc(2 * rows * cols, 1);\n\t\tcreated = 1;\n\n\t\tif (prev_rows != -1 && prev_cols != -1) {\n\t\t\tdo_new_fb(1);\n\t\t}\n\n\t\tprev_rows = rows;\n\t\tprev_cols = cols;\n\t}\n\n\tif (!rfbEndianTest) {\n\t\tunsigned char tc = rows;\n\t\trows = cols;\n\t\tcols = tc;\n\n\t\ttc = xpos;\n\t\txpos = ypos;\n\t\typos = tc;\n\t}\n\n\tlen = 2 * rows * cols;\n\tdel = 0;\n\tmemset(vcsabuf, 0, len);\n\twhile (len > 0) {\n\t\tn = read(raw_fb_fd, vcsabuf + del, len);\n\t\tif (n > 0) {\n\t\t\tdel += n;\n\t\t\tlen -= n;\n\t\t} else if (n == 0) {\n\t\t\tbreak;\n\t\t} else if (errno != EINTR && errno != EAGAIN) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfake_screen->frameBuffer = snap->data;\n\tfake_screen->paddedWidthInBytes = snap->bytes_per_line;\n\tfake_screen->serverFormat.bitsPerPixel = raw_fb_native_bpp;\n\tfake_screen->width = snap->width;\n\tfake_screen->height = snap->height;\n\n\tfor (i=0; i < rows * cols; i++) {\n\t\tint ix, iy, x, y, w, h;\n\t\tunsigned char chr = 0;\n\t\tunsigned char attr;\n\t\tunsigned int fore, back;\n\t\tunsigned short *usp;\n\t\tunsigned int *uip;\n\t\tchr  = (unsigned char) vcsabuf[2*i];\n\t\tattr = vcsabuf[2*i+1];\n\n\t\tiy = i / cols;\n\t\tix = i - iy * cols;\n\n\t\tif (ix == prev_xpos && iy == prev_ypos) {\n\t\t\t;\n\t\t} else if (ix == xpos && iy == ypos) {\n\t\t\t;\n\t\t} else if (!created && chr == vcsabuf0[2*i] && attr == vcsabuf0[2*i+1]) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!rfbEndianTest) {\n\t\t\tunsigned char tc = chr;\n\t\t\tchr = attr;\n\t\t\tattr = tc;\n\t\t}\n\n\t\ty = iy * Ch;\n\t\tx = ix * Cw;\n\t\tdst = snap->data + y * snap->bytes_per_line + x * Bpp;\n\n\t\tfore = color_tab[attr & 0xf];\n\t\tback = color_tab[(attr >> 4) & 0x7];\n\n\t\tif (ix == xpos && iy == ypos) {\n\t\t\tunsigned int ti = fore;\n\t\t\tfore = back;\n\t\t\tback = ti;\n\t\t}\n\n\t\tfor (h = 0; h < Ch; h++) {\n\t\t\tif (Bpp == 1) {\n\t\t\t\tmemset(dst, back, Cw);\n\t\t\t} else if (Bpp == 2) {\n\t\t\t\tfor (w = 0; w < Cw; w++) {\n\t\t\t\t\tusp = (unsigned short *) (dst + w*Bpp); \n\t\t\t\t\t*usp = (unsigned short) back;\n\t\t\t\t}\n\t\t\t} else if (Bpp == 4) {\n\t\t\t\tfor (w = 0; w < Cw; w++) {\n\t\t\t\t\tuip = (unsigned int *) (dst + w*Bpp); \n\t\t\t\t\t*uip = (unsigned int) back;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdst += snap->bytes_per_line;\n\t\t}\n\t\trfbDrawChar(fake_screen, &default8x16Font, x, y + Ch, chr, fore);\n\t}\n\tmemcpy(vcsabuf0, vcsabuf, 2 * rows * cols); \n\tprev_xpos = xpos;\n\tprev_ypos = ypos;\n}"
  },
  {
    "function_name": "copy_screen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/scan.c",
    "lines": "2412-2455",
    "snippet": "int copy_screen(void) {\n\tchar *fbp;\n\tint i, y, block_size;\n\n\tif (! fs_factor) {\n\t\treturn 0;\n\t}\n\tif (debug_tiles) fprintf(stderr, \"copy_screen\\n\");\n\n\tif (unixpw_in_progress) return 0;\n\n\n\tif (! main_fb) {\n\t\treturn 0;\n\t}\n\n\tblock_size = ((dpy_y/fs_factor) * main_bytes_per_line);\n\n\tfbp = main_fb;\n\ty = 0;\n\n\tX_LOCK;\n\n\t/* screen may be too big for 1 shm area, so broken into fs_factor */\n\tfor (i=0; i < fs_factor; i++) {\n\t\tXRANDR_SET_TRAP_RET(-1, \"copy_screen-set\");\n\t\tcopy_image(fullscreen, 0, y, 0, 0);\n\t\tXRANDR_CHK_TRAP_RET(-1, \"copy_screen-chk\");\n\n\t\tmemcpy(fbp, fullscreen->data, (size_t) block_size);\n\n\t\ty += dpy_y / fs_factor;\n\t\tfbp += block_size;\n\t}\n\n\tX_UNLOCK;\n\n\tif (blackouts) {\n\t\tblackout_regions();\n\t}\n\n\tmark_rect_as_modified(0, 0, dpy_x, dpy_y, 0);\n\treturn 0;\n}",
    "includes": [
      "#include <default8x16.h>",
      "#include \"userinput.h\"",
      "#include \"macosx.h\"",
      "#include \"screen.h\"",
      "#include \"unixpw.h\"",
      "#include \"cleanup.h\"",
      "#include \"pointer.h\"",
      "#include \"screen.h\"",
      "#include \"8to24.h\"",
      "#include \"win_utils.h\"",
      "#include \"xrandr.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"xinerama.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void shm_delete(XShmSegmentInfo *shm);",
      "int copy_screen(void);",
      "static void blackout_regions(void);",
      "static int fs_factor = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_rect_as_modified",
          "args": [
            "0",
            "0",
            "dpy_x",
            "dpy_y",
            "0"
          ],
          "line": 2453
        },
        "resolved": true,
        "details": {
          "function_name": "mark_rect_as_modified",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/scan.c",
          "lines": "1643-1682",
          "snippet": "void mark_rect_as_modified(int x1, int y1, int x2, int y2, int force) {\n\n\tif (damage_time != 0) {\n\t\t/*\n\t\t * This is not XDAMAGE, rather a hack for testing\n\t\t * where we allow the framebuffer to be corrupted for\n\t\t * damage_delay seconds.\n\t\t */\n\t\tint debug = 0;\n\t\tif (time(NULL) > damage_time + damage_delay) {\n\t\t\tif (! quiet) {\n\t\t\t\trfbLog(\"damaging turned off.\\n\");\n\t\t\t}\n\t\t\tdamage_time = 0;\n\t\t\tdamage_delay = 0;\n\t\t} else {\n\t\t\tif (debug) {\n\t\t\t\trfbLog(\"damaging viewer fb by not marking \"\n\t\t\t\t    \"rect: %d,%d,%d,%d\\n\", x1, y1, x2, y2);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n\n\n\tif (rfb_fb == main_fb || force) {\n\t\tmark_wrapper(x1, y1, x2, y2);\n\t\treturn;\n\t}\n\n\tif (cmap8to24) {\n\t\tbpp8to24(x1, y1, x2, y2);\n\t}\n\n\tif (scaling) {\n\t\tscale_and_mark_rect(x1, y1, x2, y2, 1);\n\t} else {\n\t\tmark_wrapper(x1, y1, x2, y2);\n\t}\n}",
          "includes": [
            "#include <default8x16.h>",
            "#include \"userinput.h\"",
            "#include \"macosx.h\"",
            "#include \"screen.h\"",
            "#include \"unixpw.h\"",
            "#include \"cleanup.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"8to24.h\"",
            "#include \"win_utils.h\"",
            "#include \"xrandr.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_rect_as_modified(int x1, int y1, int x2, int y2, int force);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <default8x16.h>\n#include \"userinput.h\"\n#include \"macosx.h\"\n#include \"screen.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"8to24.h\"\n#include \"win_utils.h\"\n#include \"xrandr.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nvoid mark_rect_as_modified(int x1, int y1, int x2, int y2, int force);\n\nvoid mark_rect_as_modified(int x1, int y1, int x2, int y2, int force) {\n\n\tif (damage_time != 0) {\n\t\t/*\n\t\t * This is not XDAMAGE, rather a hack for testing\n\t\t * where we allow the framebuffer to be corrupted for\n\t\t * damage_delay seconds.\n\t\t */\n\t\tint debug = 0;\n\t\tif (time(NULL) > damage_time + damage_delay) {\n\t\t\tif (! quiet) {\n\t\t\t\trfbLog(\"damaging turned off.\\n\");\n\t\t\t}\n\t\t\tdamage_time = 0;\n\t\t\tdamage_delay = 0;\n\t\t} else {\n\t\t\tif (debug) {\n\t\t\t\trfbLog(\"damaging viewer fb by not marking \"\n\t\t\t\t    \"rect: %d,%d,%d,%d\\n\", x1, y1, x2, y2);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n\n\n\tif (rfb_fb == main_fb || force) {\n\t\tmark_wrapper(x1, y1, x2, y2);\n\t\treturn;\n\t}\n\n\tif (cmap8to24) {\n\t\tbpp8to24(x1, y1, x2, y2);\n\t}\n\n\tif (scaling) {\n\t\tscale_and_mark_rect(x1, y1, x2, y2, 1);\n\t} else {\n\t\tmark_wrapper(x1, y1, x2, y2);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "blackout_regions",
          "args": [],
          "line": 2450
        },
        "resolved": true,
        "details": {
          "function_name": "blackout_regions",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/scan.c",
          "lines": "2399-2404",
          "snippet": "static void blackout_regions(void) {\n\tint i;\n\tfor (i=0; i < blackouts; i++) {\n\t\tzero_fb(blackr[i].x1, blackr[i].y1, blackr[i].x2, blackr[i].y2);\n\t}\n}",
          "includes": [
            "#include <default8x16.h>",
            "#include \"userinput.h\"",
            "#include \"macosx.h\"",
            "#include \"screen.h\"",
            "#include \"unixpw.h\"",
            "#include \"cleanup.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"8to24.h\"",
            "#include \"win_utils.h\"",
            "#include \"xrandr.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void blackout_regions(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <default8x16.h>\n#include \"userinput.h\"\n#include \"macosx.h\"\n#include \"screen.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"8to24.h\"\n#include \"win_utils.h\"\n#include \"xrandr.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nstatic void blackout_regions(void);\n\nstatic void blackout_regions(void) {\n\tint i;\n\tfor (i=0; i < blackouts; i++) {\n\t\tzero_fb(blackr[i].x1, blackr[i].y1, blackr[i].x2, blackr[i].y2);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "fbp",
            "fullscreen->data",
            "(size_t) block_size"
          ],
          "line": 2441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XRANDR_CHK_TRAP_RET",
          "args": [
            "-1",
            "\"copy_screen-chk\""
          ],
          "line": 2439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_image",
          "args": [
            "fullscreen",
            "0",
            "y",
            "0",
            "0"
          ],
          "line": 2438
        },
        "resolved": true,
        "details": {
          "function_name": "copy_image",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "832-868",
          "snippet": "void copy_image(XImage *dest, int x, int y, unsigned int w, unsigned int h) {\n\t/* default (w=0, h=0) is the fill the entire XImage */\n\tif (dest == NULL) {\n\t\treturn;\n\t}\n\tif (w < 1)  {\n\t\tw = dest->width;\n\t}\n\tif (h < 1)  {\n\t\th = dest->height;\n\t}\n\n\tif (raw_fb) {\n\t\tcopy_raw_fb(dest, x, y, w, h);\n\n\t} else if (use_snapfb && snap_fb && dest != snaprect) {\n\t\tchar *src, *dst;\n\t\tunsigned int line;\n\t\tint pixelsize = bpp/8;\n\n\t\tsrc = snap->data + snap->bytes_per_line*y + pixelsize*x;\n\t\tdst = dest->data;\n\t\tfor (line = 0; line < h; line++) {\n\t\t\tmemcpy(dst, src, w * pixelsize);\n\t\t\tsrc += snap->bytes_per_line;\n\t\t\tdst += dest->bytes_per_line;\n\t\t}\n\n\t} else if ((using_shm && ! xform24to32) && (int) w == dest->width &&\n\t    (int) h == dest->height) {\n\t\tXShmGetImage_wr(dpy, window, dest, x, y, AllPlanes);\n\n\t} else {\n\t\tXGetSubImage_wr(dpy, window, x, y, w, h, AllPlanes,\n\t\t    ZPixmap, dest, 0, 0);\n\t}\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "XImage *XShmCreateImage_wr(Display* disp, Visual* vis, unsigned int depth,\n    int format, char* data, XShmSegmentInfo* shminfo, unsigned int width,\n    unsigned int height);",
            "XImage *XCreateImage_wr(Display *disp, Visual *visual, unsigned int depth,\n    int format, int offset, char *data, unsigned int width,\n    unsigned int height, int bitmap_pad, int bytes_per_line);",
            "void copy_image(XImage *dest, int x, int y, unsigned int w, unsigned int h);",
            "Bool XTestCompareCurrentCursorWithWindow_wr(Display* dpy, Window w);",
            "void XTestDiscard_wr(Display *dpy);",
            "int XFree_wr(void *data);",
            "void copy_raw_fb(XImage *dest, int x, int y, unsigned int w, unsigned int h);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nXImage *XShmCreateImage_wr(Display* disp, Visual* vis, unsigned int depth,\n    int format, char* data, XShmSegmentInfo* shminfo, unsigned int width,\n    unsigned int height);\nXImage *XCreateImage_wr(Display *disp, Visual *visual, unsigned int depth,\n    int format, int offset, char *data, unsigned int width,\n    unsigned int height, int bitmap_pad, int bytes_per_line);\nvoid copy_image(XImage *dest, int x, int y, unsigned int w, unsigned int h);\nBool XTestCompareCurrentCursorWithWindow_wr(Display* dpy, Window w);\nvoid XTestDiscard_wr(Display *dpy);\nint XFree_wr(void *data);\nvoid copy_raw_fb(XImage *dest, int x, int y, unsigned int w, unsigned int h);\n\nvoid copy_image(XImage *dest, int x, int y, unsigned int w, unsigned int h) {\n\t/* default (w=0, h=0) is the fill the entire XImage */\n\tif (dest == NULL) {\n\t\treturn;\n\t}\n\tif (w < 1)  {\n\t\tw = dest->width;\n\t}\n\tif (h < 1)  {\n\t\th = dest->height;\n\t}\n\n\tif (raw_fb) {\n\t\tcopy_raw_fb(dest, x, y, w, h);\n\n\t} else if (use_snapfb && snap_fb && dest != snaprect) {\n\t\tchar *src, *dst;\n\t\tunsigned int line;\n\t\tint pixelsize = bpp/8;\n\n\t\tsrc = snap->data + snap->bytes_per_line*y + pixelsize*x;\n\t\tdst = dest->data;\n\t\tfor (line = 0; line < h; line++) {\n\t\t\tmemcpy(dst, src, w * pixelsize);\n\t\t\tsrc += snap->bytes_per_line;\n\t\t\tdst += dest->bytes_per_line;\n\t\t}\n\n\t} else if ((using_shm && ! xform24to32) && (int) w == dest->width &&\n\t    (int) h == dest->height) {\n\t\tXShmGetImage_wr(dpy, window, dest, x, y, AllPlanes);\n\n\t} else {\n\t\tXGetSubImage_wr(dpy, window, x, y, w, h, AllPlanes,\n\t\t    ZPixmap, dest, 0, 0);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "XRANDR_SET_TRAP_RET",
          "args": [
            "-1",
            "\"copy_screen-set\""
          ],
          "line": 2437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"copy_screen\\n\""
          ],
          "line": 2419
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <default8x16.h>\n#include \"userinput.h\"\n#include \"macosx.h\"\n#include \"screen.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"8to24.h\"\n#include \"win_utils.h\"\n#include \"xrandr.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nvoid shm_delete(XShmSegmentInfo *shm);\nint copy_screen(void);\nstatic void blackout_regions(void);\nstatic int fs_factor = 0;\n\nint copy_screen(void) {\n\tchar *fbp;\n\tint i, y, block_size;\n\n\tif (! fs_factor) {\n\t\treturn 0;\n\t}\n\tif (debug_tiles) fprintf(stderr, \"copy_screen\\n\");\n\n\tif (unixpw_in_progress) return 0;\n\n\n\tif (! main_fb) {\n\t\treturn 0;\n\t}\n\n\tblock_size = ((dpy_y/fs_factor) * main_bytes_per_line);\n\n\tfbp = main_fb;\n\ty = 0;\n\n\tX_LOCK;\n\n\t/* screen may be too big for 1 shm area, so broken into fs_factor */\n\tfor (i=0; i < fs_factor; i++) {\n\t\tXRANDR_SET_TRAP_RET(-1, \"copy_screen-set\");\n\t\tcopy_image(fullscreen, 0, y, 0, 0);\n\t\tXRANDR_CHK_TRAP_RET(-1, \"copy_screen-chk\");\n\n\t\tmemcpy(fbp, fullscreen->data, (size_t) block_size);\n\n\t\ty += dpy_y / fs_factor;\n\t\tfbp += block_size;\n\t}\n\n\tX_UNLOCK;\n\n\tif (blackouts) {\n\t\tblackout_regions();\n\t}\n\n\tmark_rect_as_modified(0, 0, dpy_x, dpy_y, 0);\n\treturn 0;\n}"
  },
  {
    "function_name": "blackout_regions",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/scan.c",
    "lines": "2399-2404",
    "snippet": "static void blackout_regions(void) {\n\tint i;\n\tfor (i=0; i < blackouts; i++) {\n\t\tzero_fb(blackr[i].x1, blackr[i].y1, blackr[i].x2, blackr[i].y2);\n\t}\n}",
    "includes": [
      "#include <default8x16.h>",
      "#include \"userinput.h\"",
      "#include \"macosx.h\"",
      "#include \"screen.h\"",
      "#include \"unixpw.h\"",
      "#include \"cleanup.h\"",
      "#include \"pointer.h\"",
      "#include \"screen.h\"",
      "#include \"8to24.h\"",
      "#include \"win_utils.h\"",
      "#include \"xrandr.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"xinerama.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void blackout_regions(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "zero_fb",
          "args": [
            "blackr[i].x1",
            "blackr[i].y1",
            "blackr[i].x2",
            "blackr[i].y2"
          ],
          "line": 2402
        },
        "resolved": true,
        "details": {
          "function_name": "zero_fb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xinerama.c",
          "lines": "531-561",
          "snippet": "void zero_fb(int x1, int y1, int x2, int y2) {\n\tint pixelsize = bpp/8;\n\tint line, fill = 0, yfac = 1;\n\tchar *dst;\n\n#ifndef NO_NCACHE\n\tif (ncache > 0) {\n\t\tyfac = 1+ncache;\n\t\tif (ncache_xrootpmap) {\n\t\t\tyfac++;\n\t\t}\n\t}\n#endif\n\t\n\tif (x1 < 0 || x2 <= x1 || x2 > dpy_x) {\n\t\treturn;\n\t}\n\tif (y1 < 0 || y2 <= y1 || y2 > yfac * dpy_y) {\n\t\treturn;\n\t}\n\tif (! main_fb) {\n\t\treturn;\n\t}\n\n\tdst = main_fb + y1 * main_bytes_per_line + x1 * pixelsize;\n\tline = y1;\n\twhile (line++ < y2) {\n\t\tmemset(dst, fill, (size_t) (x2 - x1) * pixelsize);\n\t\tdst += main_bytes_per_line;\n\t}\n}",
          "includes": [
            "#include \"scan.h\"",
            "#include \"blackout_t.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void zero_fb(int x1, int y1, int x2, int y2);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"scan.h\"\n#include \"blackout_t.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid zero_fb(int x1, int y1, int x2, int y2);\n\nvoid zero_fb(int x1, int y1, int x2, int y2) {\n\tint pixelsize = bpp/8;\n\tint line, fill = 0, yfac = 1;\n\tchar *dst;\n\n#ifndef NO_NCACHE\n\tif (ncache > 0) {\n\t\tyfac = 1+ncache;\n\t\tif (ncache_xrootpmap) {\n\t\t\tyfac++;\n\t\t}\n\t}\n#endif\n\t\n\tif (x1 < 0 || x2 <= x1 || x2 > dpy_x) {\n\t\treturn;\n\t}\n\tif (y1 < 0 || y2 <= y1 || y2 > yfac * dpy_y) {\n\t\treturn;\n\t}\n\tif (! main_fb) {\n\t\treturn;\n\t}\n\n\tdst = main_fb + y1 * main_bytes_per_line + x1 * pixelsize;\n\tline = y1;\n\twhile (line++ < y2) {\n\t\tmemset(dst, fill, (size_t) (x2 - x1) * pixelsize);\n\t\tdst += main_bytes_per_line;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <default8x16.h>\n#include \"userinput.h\"\n#include \"macosx.h\"\n#include \"screen.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"8to24.h\"\n#include \"win_utils.h\"\n#include \"xrandr.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nstatic void blackout_regions(void);\n\nstatic void blackout_regions(void) {\n\tint i;\n\tfor (i=0; i < blackouts; i++) {\n\t\tzero_fb(blackr[i].x1, blackr[i].y1, blackr[i].x2, blackr[i].y2);\n\t}\n}"
  },
  {
    "function_name": "grow_islands",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/scan.c",
    "lines": "2363-2394",
    "snippet": "static int grow_islands(void) {\n\tint x, y, n, run;\n\tint diffs = 0, ct;\n\n\t/*\n\t * n.b. the way we scan here should keep an extension going,\n\t * and so also fill in gaps effectively...\n\t */\n\n\t/* left to right: */\n\tfor (y=0; y < ntiles_y; y++) {\n\t\trun = 0;\n\t\tfor (x=0; x <= ntiles_x - 2; x++) {\n\t\t\tct = island_try(x, y, x+1, y, &run);\n\t\t\tif (ct < 0) return ct;\t/* fatal */\n\t\t}\n\t}\n\t/* right to left: */\n\tfor (y=0; y < ntiles_y; y++) {\n\t\trun = 0;\n\t\tfor (x = ntiles_x - 1; x >= 1; x--) {\n\t\t\tct = island_try(x, y, x-1, y, &run);\n\t\t\tif (ct < 0) return ct;\t/* fatal */\n\t\t}\n\t}\n\tfor (n=0; n < ntiles; n++) {\n\t\tif (tile_has_diff[n]) {\n\t\t\tdiffs++;\n\t\t}\n\t}\n\treturn diffs;\n}",
    "includes": [
      "#include <default8x16.h>",
      "#include \"userinput.h\"",
      "#include \"macosx.h\"",
      "#include \"screen.h\"",
      "#include \"unixpw.h\"",
      "#include \"cleanup.h\"",
      "#include \"pointer.h\"",
      "#include \"screen.h\"",
      "#include \"8to24.h\"",
      "#include \"win_utils.h\"",
      "#include \"xrandr.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"xinerama.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int island_try(int x, int y, int u, int v, int *run);",
      "static int grow_islands(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "island_try",
          "args": [
            "x",
            "y",
            "x-1",
            "y",
            "&run"
          ],
          "line": 2384
        },
        "resolved": true,
        "details": {
          "function_name": "island_try",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/scan.c",
          "lines": "2331-2356",
          "snippet": "static int island_try(int x, int y, int u, int v, int *run) {\n\tint n, m, ct;\n\n\tn = x + y * ntiles_x;\n\tm = u + v * ntiles_x;\n\n\tif (tile_has_diff[n]) {\n\t\t(*run)++;\n\t} else {\n\t\t*run = 0;\n\t}\n\n\tif (tile_has_diff[n] && ! tile_has_diff[m]) {\n\t\t/* found a discontinuity */\n\n\t\tif (tile_tried[m]) {\n\t\t\treturn 0;\n\t\t} else if (*run < grow_fill) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tct = copy_tiles(u, v, 1);\n\t\tif (ct < 0) return ct;\t/* fatal */\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include <default8x16.h>",
            "#include \"userinput.h\"",
            "#include \"macosx.h\"",
            "#include \"screen.h\"",
            "#include \"unixpw.h\"",
            "#include \"cleanup.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"8to24.h\"",
            "#include \"win_utils.h\"",
            "#include \"xrandr.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int island_try(int x, int y, int u, int v, int *run);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <default8x16.h>\n#include \"userinput.h\"\n#include \"macosx.h\"\n#include \"screen.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"8to24.h\"\n#include \"win_utils.h\"\n#include \"xrandr.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nstatic int island_try(int x, int y, int u, int v, int *run);\n\nstatic int island_try(int x, int y, int u, int v, int *run) {\n\tint n, m, ct;\n\n\tn = x + y * ntiles_x;\n\tm = u + v * ntiles_x;\n\n\tif (tile_has_diff[n]) {\n\t\t(*run)++;\n\t} else {\n\t\t*run = 0;\n\t}\n\n\tif (tile_has_diff[n] && ! tile_has_diff[m]) {\n\t\t/* found a discontinuity */\n\n\t\tif (tile_tried[m]) {\n\t\t\treturn 0;\n\t\t} else if (*run < grow_fill) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tct = copy_tiles(u, v, 1);\n\t\tif (ct < 0) return ct;\t/* fatal */\n\t}\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <default8x16.h>\n#include \"userinput.h\"\n#include \"macosx.h\"\n#include \"screen.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"8to24.h\"\n#include \"win_utils.h\"\n#include \"xrandr.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nstatic int island_try(int x, int y, int u, int v, int *run);\nstatic int grow_islands(void);\n\nstatic int grow_islands(void) {\n\tint x, y, n, run;\n\tint diffs = 0, ct;\n\n\t/*\n\t * n.b. the way we scan here should keep an extension going,\n\t * and so also fill in gaps effectively...\n\t */\n\n\t/* left to right: */\n\tfor (y=0; y < ntiles_y; y++) {\n\t\trun = 0;\n\t\tfor (x=0; x <= ntiles_x - 2; x++) {\n\t\t\tct = island_try(x, y, x+1, y, &run);\n\t\t\tif (ct < 0) return ct;\t/* fatal */\n\t\t}\n\t}\n\t/* right to left: */\n\tfor (y=0; y < ntiles_y; y++) {\n\t\trun = 0;\n\t\tfor (x = ntiles_x - 1; x >= 1; x--) {\n\t\t\tct = island_try(x, y, x-1, y, &run);\n\t\t\tif (ct < 0) return ct;\t/* fatal */\n\t\t}\n\t}\n\tfor (n=0; n < ntiles; n++) {\n\t\tif (tile_has_diff[n]) {\n\t\t\tdiffs++;\n\t\t}\n\t}\n\treturn diffs;\n}"
  },
  {
    "function_name": "island_try",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/scan.c",
    "lines": "2331-2356",
    "snippet": "static int island_try(int x, int y, int u, int v, int *run) {\n\tint n, m, ct;\n\n\tn = x + y * ntiles_x;\n\tm = u + v * ntiles_x;\n\n\tif (tile_has_diff[n]) {\n\t\t(*run)++;\n\t} else {\n\t\t*run = 0;\n\t}\n\n\tif (tile_has_diff[n] && ! tile_has_diff[m]) {\n\t\t/* found a discontinuity */\n\n\t\tif (tile_tried[m]) {\n\t\t\treturn 0;\n\t\t} else if (*run < grow_fill) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tct = copy_tiles(u, v, 1);\n\t\tif (ct < 0) return ct;\t/* fatal */\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include <default8x16.h>",
      "#include \"userinput.h\"",
      "#include \"macosx.h\"",
      "#include \"screen.h\"",
      "#include \"unixpw.h\"",
      "#include \"cleanup.h\"",
      "#include \"pointer.h\"",
      "#include \"screen.h\"",
      "#include \"8to24.h\"",
      "#include \"win_utils.h\"",
      "#include \"xrandr.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"xinerama.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int island_try(int x, int y, int u, int v, int *run);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_tiles",
          "args": [
            "u",
            "v",
            "1"
          ],
          "line": 2352
        },
        "resolved": true,
        "details": {
          "function_name": "copy_tiles",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/scan.c",
          "lines": "1708-2045",
          "snippet": "static int copy_tiles(int tx, int ty, int nt) {\n\tint x, y, line;\n\tint size_x, size_y, width1, width2;\n\tint off, len, n, dw, dx, t;\n\tint w1, w2, dx1, dx2;\t/* tmps for normal and short tiles */\n\tint pixelsize = bpp/8;\n\tint first_min, last_max;\n\tint first_x = -1, last_x = -1;\n\tstatic int prev_ntiles_x = -1;\n\n\tchar *src, *dst, *s_src, *s_dst, *m_src, *m_dst;\n\tchar *h_src, *h_dst;\n\tif (unixpw_in_progress) return 0;\n\n\tif (ntiles_x != prev_ntiles_x && first_line != NULL) {\n\t\tfree(first_line);\tfirst_line = NULL;\n\t\tfree(last_line);\tlast_line = NULL;\n\t\tfree(left_diff);\tleft_diff = NULL;\n\t\tfree(right_diff);\tright_diff = NULL;\n\t}\n\n\tif (first_line == NULL) {\n\t\t/* allocate arrays first time in. */\n\t\tint n = ntiles_x + 1;\n\t\trfbLog(\"copy_tiles: allocating first_line at size %d\\n\", n);\n\t\tfirst_line = (int *) malloc((size_t) (n * sizeof(int)));\n\t\tlast_line  = (int *) malloc((size_t) (n * sizeof(int)));\n\t\tleft_diff  = (unsigned short *)\n\t\t\tmalloc((size_t) (n * sizeof(unsigned short)));\n\t\tright_diff = (unsigned short *)\n\t\t\tmalloc((size_t) (n * sizeof(unsigned short)));\n\t}\n\tprev_ntiles_x = ntiles_x;\n\n\tx = tx * tile_x;\n\ty = ty * tile_y;\n\n\tsize_x = dpy_x - x;\n\tif ( size_x > tile_x * nt ) {\n\t\tsize_x = tile_x * nt;\n\t\twidth1 = tile_x;\n\t\twidth2 = tile_x;\n\t} else {\n\t\t/* short tile */\n\t\twidth1 = tile_x;\t/* internal tile */\n\t\twidth2 = size_x - (nt - 1) * tile_x;\t/* right hand tile */\n\t}\n\n\tsize_y = dpy_y - y;\n\tif ( size_y > tile_y ) {\n\t\tsize_y = tile_y;\n\t}\n\n\tn = tx + ty * ntiles_x;\t\t/* number of the first tile */\n\n\tif (blackouts && tile_blackout[n].cover == 2) {\n\t\t/*\n\t\t * If there are blackouts and this tile is completely covered\n\t\t * no need to poll screen or do anything else..\n\t\t * n.b. we are in single copy_tile mode: nt=1\n\t\t */\n\t\ttile_has_diff[n] = 0;\n\t\treturn(0);\n\t}\n\n\tX_LOCK;\n\tXRANDR_SET_TRAP_RET(-1, \"copy_tile-set\");\n\t/* read in the whole tile run at once: */\n\tcopy_image(tile_row[nt], x, y, size_x, size_y);\n\tXRANDR_CHK_TRAP_RET(-1, \"copy_tile-chk\");\n\n\n\tX_UNLOCK;\n\n\tif (blackouts && tile_blackout[n].cover == 1) {\n\t\t/*\n\t\t * If there are blackouts and this tile is partially covered\n\t\t * we should re-black-out the portion.\n\t\t * n.b. we are in single copy_tile mode: nt=1\n\t\t */\n\t\tint x1, x2, y1, y2, b;\n\t\tint w, s, fill = 0;\n\n\t\tfor (b=0; b < tile_blackout[n].count; b++) {\n\t\t\tchar *b_dst = tile_row[nt]->data;\n\t\t\t\n\t\t\tx1 = tile_blackout[n].bo[b].x1 - x;\n\t\t\ty1 = tile_blackout[n].bo[b].y1 - y;\n\t\t\tx2 = tile_blackout[n].bo[b].x2 - x;\n\t\t\ty2 = tile_blackout[n].bo[b].y2 - y;\n\n\t\t\tw = (x2 - x1) * pixelsize;\n\t\t\ts = x1 * pixelsize;\n\n\t\t\tfor (line = 0; line < size_y; line++) {\n\t\t\t\tif (y1 <= line && line < y2) {\n\t\t\t\t\tmemset(b_dst + s, fill, (size_t) w);\n\t\t\t\t}\n\t\t\t\tb_dst += tile_row[nt]->bytes_per_line;\n\t\t\t}\n\t\t}\n\t}\n\n\tsrc = tile_row[nt]->data;\n\tdst = main_fb + y * main_bytes_per_line + x * pixelsize;\n\n\ts_src = src;\n\ts_dst = dst;\n\n\tfor (t=1; t <= nt; t++) {\n\t\tfirst_line[t] = -1;\n\t}\n\n\t/* find the first line with difference: */\n\tw1 = width1 * pixelsize;\n\tw2 = width2 * pixelsize;\n\n\t/* foreach line: */\n\tfor (line = 0; line < size_y; line++) {\n\t\t/* foreach horizontal tile: */\n\t\tfor (t=1; t <= nt; t++) {\n\t\t\tif (first_line[t] != -1) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\toff = (t-1) * w1;\n\t\t\tif (t == nt) {\n\t\t\t\tlen = w2;\t/* possible short tile */\n\t\t\t} else {\n\t\t\t\tlen = w1;\n\t\t\t}\n\t\t\t\n\t\t\tif (memcmp(s_dst + off, s_src + off, len)) {\n\t\t\t\tfirst_line[t] = line;\n\t\t\t}\n\t\t}\n\t\ts_src += tile_row[nt]->bytes_per_line;\n\t\ts_dst += main_bytes_per_line;\n\t}\n\n\t/* see if there were any differences for any tile: */\n\tfirst_min = -1;\n\tfor (t=1; t <= nt; t++) {\n\t\ttile_tried[n+(t-1)] = 1;\n\t\tif (first_line[t] != -1) {\n\t\t\tif (first_min == -1 || first_line[t] < first_min) {\n\t\t\t\tfirst_min = first_line[t];\n\t\t\t}\n\t\t}\n\t}\n\tif (first_min == -1) {\n\t\t/* no tile has a difference, note this and get out: */\n\t\tfor (t=1; t <= nt; t++) {\n\t\t\ttile_has_diff[n+(t-1)] = 0;\n\t\t}\n\t\treturn(0);\n\t} else {\n\t\t/*\n\t\t * at least one tile has a difference.  make sure info\n\t\t * is recorded (e.g. sometimes we guess tiles and they\n\t\t * came in with tile_has_diff 0)\n\t\t */\n\t\tfor (t=1; t <= nt; t++) {\n\t\t\tif (first_line[t] == -1) {\n\t\t\t\ttile_has_diff[n+(t-1)] = 0;\n\t\t\t} else {\n\t\t\t\ttile_has_diff[n+(t-1)] = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tm_src = src + (tile_row[nt]->bytes_per_line * size_y);\n\tm_dst = dst + (main_bytes_per_line * size_y);\n\n\tfor (t=1; t <= nt; t++) {\n\t\tlast_line[t] = first_line[t];\n\t}\n\n\t/* find the last line with difference: */\n\tw1 = width1 * pixelsize;\n\tw2 = width2 * pixelsize;\n\n\t/* foreach line: */\n\tfor (line = size_y - 1; line > first_min; line--) {\n\n\t\tm_src -= tile_row[nt]->bytes_per_line;\n\t\tm_dst -= main_bytes_per_line;\n\n\t\t/* foreach tile: */\n\t\tfor (t=1; t <= nt; t++) {\n\t\t\tif (first_line[t] == -1\n\t\t\t    || last_line[t] != first_line[t]) {\n\t\t\t\t/* tile has no changes or already done */\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\toff = (t-1) * w1;\n\t\t\tif (t == nt) {\n\t\t\t\tlen = w2;\t/* possible short tile */\n\t\t\t} else {\n\t\t\t\tlen = w1;\n\t\t\t}\n\t\t\tif (memcmp(m_dst + off, m_src + off, len)) {\n\t\t\t\tlast_line[t] = line;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/*\n\t * determine the farthest down last changed line\n\t * will be used below to limit our memcpy() to the framebuffer.\n\t */\n\tlast_max = -1;\n\tfor (t=1; t <= nt; t++) {\n\t\tif (first_line[t] == -1) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (last_max == -1 || last_line[t] > last_max) {\n\t\t\tlast_max = last_line[t];\n\t\t}\n\t}\n\n\t/* look for differences on left and right hand edges: */\n\tfor (t=1; t <= nt; t++) {\n\t\tleft_diff[t] = 0;\n\t\tright_diff[t] = 0;\n\t}\n\n\th_src = src;\n\th_dst = dst;\n\n\tw1 = width1 * pixelsize;\n\tw2 = width2 * pixelsize;\n\n\tdx1 = (width1 - tile_fuzz) * pixelsize;\n\tdx2 = (width2 - tile_fuzz) * pixelsize;\n\tdw = tile_fuzz * pixelsize; \n\n\t/* foreach line: */\n\tfor (line = 0; line < size_y; line++) {\n\t\t/* foreach tile: */\n\t\tfor (t=1; t <= nt; t++) {\n\t\t\tif (first_line[t] == -1) {\n\t\t\t\t/* tile has no changes at all */\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\toff = (t-1) * w1;\n\t\t\tif (t == nt) {\n\t\t\t\tdx = dx2;\t/* possible short tile */\n\t\t\t\tif (dx <= 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdx = dx1;\n\t\t\t}\n\n\t\t\tif (! left_diff[t] && memcmp(h_dst + off,\n\t\t\t    h_src + off, dw)) {\n\t\t\t\tleft_diff[t] = 1;\n\t\t\t}\n\t\t\tif (! right_diff[t] && memcmp(h_dst + off + dx,\n\t\t\t    h_src + off + dx, dw) ) {\n\t\t\t\tright_diff[t] = 1;\n\t\t\t}\n\t\t}\n\t\th_src += tile_row[nt]->bytes_per_line;\n\t\th_dst += main_bytes_per_line;\n\t}\n\n\t/* now finally copy the difference to the rfb framebuffer: */\n\ts_src = src + tile_row[nt]->bytes_per_line * first_min;\n\ts_dst = dst + main_bytes_per_line * first_min;\n\n\tfor (line = first_min; line <= last_max; line++) {\n\t\t/* for I/O speed we do not do this tile by tile */\n\t\tmemcpy(s_dst, s_src, size_x * pixelsize);\n\t\tif (nt == 1) {\n\t\t\t/*\n\t\t\t * optimization for tall skinny lines, e.g. wm\n\t\t\t * frame. try to find first_x and last_x to limit\n\t\t\t * the size of the hint.  could help for a slow\n\t\t\t * link.  Unfortunately we spent a lot of time\n\t\t\t * reading in the many tiles.\n\t\t\t *\n\t\t\t * BTW, we like to think the above memcpy leaves\n\t\t\t * the data we use below in the cache... (but\n\t\t\t * it could be two 128 byte segments at 32bpp)\n\t\t\t * so this inner loop is not as bad as it seems.\n\t\t\t */\n\t\t\tint k, kx;\n\t\t\tkx = pixelsize;\n\t\t\tfor (k=0; k<size_x; k++) {\n\t\t\t\tif (memcmp(s_dst + k*kx, s_src + k*kx, kx))  {\n\t\t\t\t\tif (first_x == -1 || k < first_x) {\n\t\t\t\t\t\tfirst_x = k;\n\t\t\t\t\t}\n\t\t\t\t\tif (last_x == -1 || k > last_x) {\n\t\t\t\t\t\tlast_x = k;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ts_src += tile_row[nt]->bytes_per_line;\n\t\ts_dst += main_bytes_per_line;\n\t}\n\n\t/* record all the info in the region array for this tile: */\n\tfor (t=1; t <= nt; t++) {\n\t\tint s = t - 1;\n\n\t\tif (first_line[t] == -1) {\n\t\t\t/* tile unchanged */\n\t\t\tcontinue;\n\t\t}\n\t\ttile_region[n+s].first_line = first_line[t];\n\t\ttile_region[n+s].last_line  = last_line[t];\n\n\t\ttile_region[n+s].first_x = first_x;\n\t\ttile_region[n+s].last_x  = last_x;\n\n\t\ttile_region[n+s].top_diff = 0;\n\t\ttile_region[n+s].bot_diff = 0;\n\t\tif ( first_line[t] < tile_fuzz ) {\n\t\t\ttile_region[n+s].top_diff = 1;\n\t\t}\n\t\tif ( last_line[t] > (size_y - 1) - tile_fuzz ) {\n\t\t\ttile_region[n+s].bot_diff = 1;\n\t\t}\n\n\t\ttile_region[n+s].left_diff  = left_diff[t];\n\t\ttile_region[n+s].right_diff = right_diff[t];\n\n\t\ttile_copied[n+s] = 1;\n\t}\n\n\treturn(1);\n}",
          "includes": [
            "#include <default8x16.h>",
            "#include \"userinput.h\"",
            "#include \"macosx.h\"",
            "#include \"screen.h\"",
            "#include \"unixpw.h\"",
            "#include \"cleanup.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"8to24.h\"",
            "#include \"win_utils.h\"",
            "#include \"xrandr.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void create_tile_hint(int x, int y, int tw, int th, hint_t *hint);",
            "static void extend_tile_hint(int x, int y, int tw, int th, hint_t *hint);",
            "static void mark_hint(hint_t hint);",
            "static int copy_tiles(int tx, int ty, int nt);",
            "static int island_try(int x, int y, int u, int v, int *run);",
            "static int blackout_line_cmpskip(int n, int x, int y, char *dst, char *src,\n    int w, int pixelsize);",
            "static region_t *tile_region;",
            "static int *first_line = NULL, *last_line = NULL;",
            "static unsigned short *left_diff = NULL, *right_diff = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <default8x16.h>\n#include \"userinput.h\"\n#include \"macosx.h\"\n#include \"screen.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"8to24.h\"\n#include \"win_utils.h\"\n#include \"xrandr.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nstatic void create_tile_hint(int x, int y, int tw, int th, hint_t *hint);\nstatic void extend_tile_hint(int x, int y, int tw, int th, hint_t *hint);\nstatic void mark_hint(hint_t hint);\nstatic int copy_tiles(int tx, int ty, int nt);\nstatic int island_try(int x, int y, int u, int v, int *run);\nstatic int blackout_line_cmpskip(int n, int x, int y, char *dst, char *src,\n    int w, int pixelsize);\nstatic region_t *tile_region;\nstatic int *first_line = NULL, *last_line = NULL;\nstatic unsigned short *left_diff = NULL, *right_diff = NULL;\n\nstatic int copy_tiles(int tx, int ty, int nt) {\n\tint x, y, line;\n\tint size_x, size_y, width1, width2;\n\tint off, len, n, dw, dx, t;\n\tint w1, w2, dx1, dx2;\t/* tmps for normal and short tiles */\n\tint pixelsize = bpp/8;\n\tint first_min, last_max;\n\tint first_x = -1, last_x = -1;\n\tstatic int prev_ntiles_x = -1;\n\n\tchar *src, *dst, *s_src, *s_dst, *m_src, *m_dst;\n\tchar *h_src, *h_dst;\n\tif (unixpw_in_progress) return 0;\n\n\tif (ntiles_x != prev_ntiles_x && first_line != NULL) {\n\t\tfree(first_line);\tfirst_line = NULL;\n\t\tfree(last_line);\tlast_line = NULL;\n\t\tfree(left_diff);\tleft_diff = NULL;\n\t\tfree(right_diff);\tright_diff = NULL;\n\t}\n\n\tif (first_line == NULL) {\n\t\t/* allocate arrays first time in. */\n\t\tint n = ntiles_x + 1;\n\t\trfbLog(\"copy_tiles: allocating first_line at size %d\\n\", n);\n\t\tfirst_line = (int *) malloc((size_t) (n * sizeof(int)));\n\t\tlast_line  = (int *) malloc((size_t) (n * sizeof(int)));\n\t\tleft_diff  = (unsigned short *)\n\t\t\tmalloc((size_t) (n * sizeof(unsigned short)));\n\t\tright_diff = (unsigned short *)\n\t\t\tmalloc((size_t) (n * sizeof(unsigned short)));\n\t}\n\tprev_ntiles_x = ntiles_x;\n\n\tx = tx * tile_x;\n\ty = ty * tile_y;\n\n\tsize_x = dpy_x - x;\n\tif ( size_x > tile_x * nt ) {\n\t\tsize_x = tile_x * nt;\n\t\twidth1 = tile_x;\n\t\twidth2 = tile_x;\n\t} else {\n\t\t/* short tile */\n\t\twidth1 = tile_x;\t/* internal tile */\n\t\twidth2 = size_x - (nt - 1) * tile_x;\t/* right hand tile */\n\t}\n\n\tsize_y = dpy_y - y;\n\tif ( size_y > tile_y ) {\n\t\tsize_y = tile_y;\n\t}\n\n\tn = tx + ty * ntiles_x;\t\t/* number of the first tile */\n\n\tif (blackouts && tile_blackout[n].cover == 2) {\n\t\t/*\n\t\t * If there are blackouts and this tile is completely covered\n\t\t * no need to poll screen or do anything else..\n\t\t * n.b. we are in single copy_tile mode: nt=1\n\t\t */\n\t\ttile_has_diff[n] = 0;\n\t\treturn(0);\n\t}\n\n\tX_LOCK;\n\tXRANDR_SET_TRAP_RET(-1, \"copy_tile-set\");\n\t/* read in the whole tile run at once: */\n\tcopy_image(tile_row[nt], x, y, size_x, size_y);\n\tXRANDR_CHK_TRAP_RET(-1, \"copy_tile-chk\");\n\n\n\tX_UNLOCK;\n\n\tif (blackouts && tile_blackout[n].cover == 1) {\n\t\t/*\n\t\t * If there are blackouts and this tile is partially covered\n\t\t * we should re-black-out the portion.\n\t\t * n.b. we are in single copy_tile mode: nt=1\n\t\t */\n\t\tint x1, x2, y1, y2, b;\n\t\tint w, s, fill = 0;\n\n\t\tfor (b=0; b < tile_blackout[n].count; b++) {\n\t\t\tchar *b_dst = tile_row[nt]->data;\n\t\t\t\n\t\t\tx1 = tile_blackout[n].bo[b].x1 - x;\n\t\t\ty1 = tile_blackout[n].bo[b].y1 - y;\n\t\t\tx2 = tile_blackout[n].bo[b].x2 - x;\n\t\t\ty2 = tile_blackout[n].bo[b].y2 - y;\n\n\t\t\tw = (x2 - x1) * pixelsize;\n\t\t\ts = x1 * pixelsize;\n\n\t\t\tfor (line = 0; line < size_y; line++) {\n\t\t\t\tif (y1 <= line && line < y2) {\n\t\t\t\t\tmemset(b_dst + s, fill, (size_t) w);\n\t\t\t\t}\n\t\t\t\tb_dst += tile_row[nt]->bytes_per_line;\n\t\t\t}\n\t\t}\n\t}\n\n\tsrc = tile_row[nt]->data;\n\tdst = main_fb + y * main_bytes_per_line + x * pixelsize;\n\n\ts_src = src;\n\ts_dst = dst;\n\n\tfor (t=1; t <= nt; t++) {\n\t\tfirst_line[t] = -1;\n\t}\n\n\t/* find the first line with difference: */\n\tw1 = width1 * pixelsize;\n\tw2 = width2 * pixelsize;\n\n\t/* foreach line: */\n\tfor (line = 0; line < size_y; line++) {\n\t\t/* foreach horizontal tile: */\n\t\tfor (t=1; t <= nt; t++) {\n\t\t\tif (first_line[t] != -1) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\toff = (t-1) * w1;\n\t\t\tif (t == nt) {\n\t\t\t\tlen = w2;\t/* possible short tile */\n\t\t\t} else {\n\t\t\t\tlen = w1;\n\t\t\t}\n\t\t\t\n\t\t\tif (memcmp(s_dst + off, s_src + off, len)) {\n\t\t\t\tfirst_line[t] = line;\n\t\t\t}\n\t\t}\n\t\ts_src += tile_row[nt]->bytes_per_line;\n\t\ts_dst += main_bytes_per_line;\n\t}\n\n\t/* see if there were any differences for any tile: */\n\tfirst_min = -1;\n\tfor (t=1; t <= nt; t++) {\n\t\ttile_tried[n+(t-1)] = 1;\n\t\tif (first_line[t] != -1) {\n\t\t\tif (first_min == -1 || first_line[t] < first_min) {\n\t\t\t\tfirst_min = first_line[t];\n\t\t\t}\n\t\t}\n\t}\n\tif (first_min == -1) {\n\t\t/* no tile has a difference, note this and get out: */\n\t\tfor (t=1; t <= nt; t++) {\n\t\t\ttile_has_diff[n+(t-1)] = 0;\n\t\t}\n\t\treturn(0);\n\t} else {\n\t\t/*\n\t\t * at least one tile has a difference.  make sure info\n\t\t * is recorded (e.g. sometimes we guess tiles and they\n\t\t * came in with tile_has_diff 0)\n\t\t */\n\t\tfor (t=1; t <= nt; t++) {\n\t\t\tif (first_line[t] == -1) {\n\t\t\t\ttile_has_diff[n+(t-1)] = 0;\n\t\t\t} else {\n\t\t\t\ttile_has_diff[n+(t-1)] = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tm_src = src + (tile_row[nt]->bytes_per_line * size_y);\n\tm_dst = dst + (main_bytes_per_line * size_y);\n\n\tfor (t=1; t <= nt; t++) {\n\t\tlast_line[t] = first_line[t];\n\t}\n\n\t/* find the last line with difference: */\n\tw1 = width1 * pixelsize;\n\tw2 = width2 * pixelsize;\n\n\t/* foreach line: */\n\tfor (line = size_y - 1; line > first_min; line--) {\n\n\t\tm_src -= tile_row[nt]->bytes_per_line;\n\t\tm_dst -= main_bytes_per_line;\n\n\t\t/* foreach tile: */\n\t\tfor (t=1; t <= nt; t++) {\n\t\t\tif (first_line[t] == -1\n\t\t\t    || last_line[t] != first_line[t]) {\n\t\t\t\t/* tile has no changes or already done */\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\toff = (t-1) * w1;\n\t\t\tif (t == nt) {\n\t\t\t\tlen = w2;\t/* possible short tile */\n\t\t\t} else {\n\t\t\t\tlen = w1;\n\t\t\t}\n\t\t\tif (memcmp(m_dst + off, m_src + off, len)) {\n\t\t\t\tlast_line[t] = line;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/*\n\t * determine the farthest down last changed line\n\t * will be used below to limit our memcpy() to the framebuffer.\n\t */\n\tlast_max = -1;\n\tfor (t=1; t <= nt; t++) {\n\t\tif (first_line[t] == -1) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (last_max == -1 || last_line[t] > last_max) {\n\t\t\tlast_max = last_line[t];\n\t\t}\n\t}\n\n\t/* look for differences on left and right hand edges: */\n\tfor (t=1; t <= nt; t++) {\n\t\tleft_diff[t] = 0;\n\t\tright_diff[t] = 0;\n\t}\n\n\th_src = src;\n\th_dst = dst;\n\n\tw1 = width1 * pixelsize;\n\tw2 = width2 * pixelsize;\n\n\tdx1 = (width1 - tile_fuzz) * pixelsize;\n\tdx2 = (width2 - tile_fuzz) * pixelsize;\n\tdw = tile_fuzz * pixelsize; \n\n\t/* foreach line: */\n\tfor (line = 0; line < size_y; line++) {\n\t\t/* foreach tile: */\n\t\tfor (t=1; t <= nt; t++) {\n\t\t\tif (first_line[t] == -1) {\n\t\t\t\t/* tile has no changes at all */\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\toff = (t-1) * w1;\n\t\t\tif (t == nt) {\n\t\t\t\tdx = dx2;\t/* possible short tile */\n\t\t\t\tif (dx <= 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdx = dx1;\n\t\t\t}\n\n\t\t\tif (! left_diff[t] && memcmp(h_dst + off,\n\t\t\t    h_src + off, dw)) {\n\t\t\t\tleft_diff[t] = 1;\n\t\t\t}\n\t\t\tif (! right_diff[t] && memcmp(h_dst + off + dx,\n\t\t\t    h_src + off + dx, dw) ) {\n\t\t\t\tright_diff[t] = 1;\n\t\t\t}\n\t\t}\n\t\th_src += tile_row[nt]->bytes_per_line;\n\t\th_dst += main_bytes_per_line;\n\t}\n\n\t/* now finally copy the difference to the rfb framebuffer: */\n\ts_src = src + tile_row[nt]->bytes_per_line * first_min;\n\ts_dst = dst + main_bytes_per_line * first_min;\n\n\tfor (line = first_min; line <= last_max; line++) {\n\t\t/* for I/O speed we do not do this tile by tile */\n\t\tmemcpy(s_dst, s_src, size_x * pixelsize);\n\t\tif (nt == 1) {\n\t\t\t/*\n\t\t\t * optimization for tall skinny lines, e.g. wm\n\t\t\t * frame. try to find first_x and last_x to limit\n\t\t\t * the size of the hint.  could help for a slow\n\t\t\t * link.  Unfortunately we spent a lot of time\n\t\t\t * reading in the many tiles.\n\t\t\t *\n\t\t\t * BTW, we like to think the above memcpy leaves\n\t\t\t * the data we use below in the cache... (but\n\t\t\t * it could be two 128 byte segments at 32bpp)\n\t\t\t * so this inner loop is not as bad as it seems.\n\t\t\t */\n\t\t\tint k, kx;\n\t\t\tkx = pixelsize;\n\t\t\tfor (k=0; k<size_x; k++) {\n\t\t\t\tif (memcmp(s_dst + k*kx, s_src + k*kx, kx))  {\n\t\t\t\t\tif (first_x == -1 || k < first_x) {\n\t\t\t\t\t\tfirst_x = k;\n\t\t\t\t\t}\n\t\t\t\t\tif (last_x == -1 || k > last_x) {\n\t\t\t\t\t\tlast_x = k;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ts_src += tile_row[nt]->bytes_per_line;\n\t\ts_dst += main_bytes_per_line;\n\t}\n\n\t/* record all the info in the region array for this tile: */\n\tfor (t=1; t <= nt; t++) {\n\t\tint s = t - 1;\n\n\t\tif (first_line[t] == -1) {\n\t\t\t/* tile unchanged */\n\t\t\tcontinue;\n\t\t}\n\t\ttile_region[n+s].first_line = first_line[t];\n\t\ttile_region[n+s].last_line  = last_line[t];\n\n\t\ttile_region[n+s].first_x = first_x;\n\t\ttile_region[n+s].last_x  = last_x;\n\n\t\ttile_region[n+s].top_diff = 0;\n\t\ttile_region[n+s].bot_diff = 0;\n\t\tif ( first_line[t] < tile_fuzz ) {\n\t\t\ttile_region[n+s].top_diff = 1;\n\t\t}\n\t\tif ( last_line[t] > (size_y - 1) - tile_fuzz ) {\n\t\t\ttile_region[n+s].bot_diff = 1;\n\t\t}\n\n\t\ttile_region[n+s].left_diff  = left_diff[t];\n\t\ttile_region[n+s].right_diff = right_diff[t];\n\n\t\ttile_copied[n+s] = 1;\n\t}\n\n\treturn(1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <default8x16.h>\n#include \"userinput.h\"\n#include \"macosx.h\"\n#include \"screen.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"8to24.h\"\n#include \"win_utils.h\"\n#include \"xrandr.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nstatic int island_try(int x, int y, int u, int v, int *run);\n\nstatic int island_try(int x, int y, int u, int v, int *run) {\n\tint n, m, ct;\n\n\tn = x + y * ntiles_x;\n\tm = u + v * ntiles_x;\n\n\tif (tile_has_diff[n]) {\n\t\t(*run)++;\n\t} else {\n\t\t*run = 0;\n\t}\n\n\tif (tile_has_diff[n] && ! tile_has_diff[m]) {\n\t\t/* found a discontinuity */\n\n\t\tif (tile_tried[m]) {\n\t\t\treturn 0;\n\t\t} else if (*run < grow_fill) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tct = copy_tiles(u, v, 1);\n\t\tif (ct < 0) return ct;\t/* fatal */\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "fill_tile_gaps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/scan.c",
    "lines": "2299-2329",
    "snippet": "static int fill_tile_gaps(void) {\n\tint x, y, run, saw;\n\tint n, diffs = 0, ct;\n\n\t/* horizontal: */\n\tfor (y=0; y < ntiles_y; y++) {\n\t\trun = 0;\n\t\tsaw = 0;\n\t\tfor (x=0; x < ntiles_x; x++) {\n\t\t\tct = gap_try(x, y, &run, &saw, 1);\n\t\t\tif (ct < 0) return ct;\t/* fatal */\n\t\t}\n\t}\n\n\t/* vertical: */\n\tfor (x=0; x < ntiles_x; x++) {\n\t\trun = 0;\n\t\tsaw = 0;\n\t\tfor (y=0; y < ntiles_y; y++) {\n\t\t\tct = gap_try(x, y, &run, &saw, 0);\n\t\t\tif (ct < 0) return ct;\t/* fatal */\n\t\t}\n\t}\n\n\tfor (n=0; n < ntiles; n++) {\n\t\tif (tile_has_diff[n]) {\n\t\t\tdiffs++;\n\t\t}\n\t}\n\treturn diffs;\n}",
    "includes": [
      "#include <default8x16.h>",
      "#include \"userinput.h\"",
      "#include \"macosx.h\"",
      "#include \"screen.h\"",
      "#include \"unixpw.h\"",
      "#include \"cleanup.h\"",
      "#include \"pointer.h\"",
      "#include \"screen.h\"",
      "#include \"8to24.h\"",
      "#include \"win_utils.h\"",
      "#include \"xrandr.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"xinerama.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int fill_tile_gaps(void);",
      "static int island_try(int x, int y, int u, int v, int *run);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "gap_try",
          "args": [
            "x",
            "y",
            "&run",
            "&saw",
            "0"
          ],
          "line": 2318
        },
        "resolved": true,
        "details": {
          "function_name": "gap_try",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/scan.c",
          "lines": "2252-2289",
          "snippet": "static int gap_try(int x, int y, int *run, int *saw, int along_x) {\n\tint n, m, i, xt, yt, ct;\n\n\tn = x + y * ntiles_x;\n\n\tif (! tile_has_diff[n]) {\n\t\tif (*saw) {\n\t\t\t(*run)++;\t/* extend the gap run. */\n\t\t}\n\t\treturn 0;\n\t}\n\tif (! *saw || *run == 0 || *run > gaps_fill) {\n\t\t*run = 0;\t\t/* unacceptable run. */\n\t\t*saw = 1;\n\t\treturn 0;\n\t}\n\n\tfor (i=1; i <= *run; i++) {\t/* iterate thru the run. */\n\t\tif (along_x) {\n\t\t\txt = x - i;\n\t\t\tyt = y;\n\t\t} else {\n\t\t\txt = x;\n\t\t\tyt = y - i;\n\t\t}\n\n\t\tm = xt + yt * ntiles_x;\n\t\tif (tile_tried[m]) {\t/* do not repeat tiles */\n\t\t\tcontinue;\n\t\t}\n\n\t\tct = copy_tiles(xt, yt, 1);\n\t\tif (ct < 0) return ct;\t/* fatal */\n\t}\n\t*run = 0;\n\t*saw = 1;\n\treturn 1;\n}",
          "includes": [
            "#include <default8x16.h>",
            "#include \"userinput.h\"",
            "#include \"macosx.h\"",
            "#include \"screen.h\"",
            "#include \"unixpw.h\"",
            "#include \"cleanup.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"8to24.h\"",
            "#include \"win_utils.h\"",
            "#include \"xrandr.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int gap_try(int x, int y, int *run, int *saw, int along_x);",
            "static int island_try(int x, int y, int u, int v, int *run);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <default8x16.h>\n#include \"userinput.h\"\n#include \"macosx.h\"\n#include \"screen.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"8to24.h\"\n#include \"win_utils.h\"\n#include \"xrandr.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nstatic int gap_try(int x, int y, int *run, int *saw, int along_x);\nstatic int island_try(int x, int y, int u, int v, int *run);\n\nstatic int gap_try(int x, int y, int *run, int *saw, int along_x) {\n\tint n, m, i, xt, yt, ct;\n\n\tn = x + y * ntiles_x;\n\n\tif (! tile_has_diff[n]) {\n\t\tif (*saw) {\n\t\t\t(*run)++;\t/* extend the gap run. */\n\t\t}\n\t\treturn 0;\n\t}\n\tif (! *saw || *run == 0 || *run > gaps_fill) {\n\t\t*run = 0;\t\t/* unacceptable run. */\n\t\t*saw = 1;\n\t\treturn 0;\n\t}\n\n\tfor (i=1; i <= *run; i++) {\t/* iterate thru the run. */\n\t\tif (along_x) {\n\t\t\txt = x - i;\n\t\t\tyt = y;\n\t\t} else {\n\t\t\txt = x;\n\t\t\tyt = y - i;\n\t\t}\n\n\t\tm = xt + yt * ntiles_x;\n\t\tif (tile_tried[m]) {\t/* do not repeat tiles */\n\t\t\tcontinue;\n\t\t}\n\n\t\tct = copy_tiles(xt, yt, 1);\n\t\tif (ct < 0) return ct;\t/* fatal */\n\t}\n\t*run = 0;\n\t*saw = 1;\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <default8x16.h>\n#include \"userinput.h\"\n#include \"macosx.h\"\n#include \"screen.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"8to24.h\"\n#include \"win_utils.h\"\n#include \"xrandr.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nstatic int fill_tile_gaps(void);\nstatic int island_try(int x, int y, int u, int v, int *run);\n\nstatic int fill_tile_gaps(void) {\n\tint x, y, run, saw;\n\tint n, diffs = 0, ct;\n\n\t/* horizontal: */\n\tfor (y=0; y < ntiles_y; y++) {\n\t\trun = 0;\n\t\tsaw = 0;\n\t\tfor (x=0; x < ntiles_x; x++) {\n\t\t\tct = gap_try(x, y, &run, &saw, 1);\n\t\t\tif (ct < 0) return ct;\t/* fatal */\n\t\t}\n\t}\n\n\t/* vertical: */\n\tfor (x=0; x < ntiles_x; x++) {\n\t\trun = 0;\n\t\tsaw = 0;\n\t\tfor (y=0; y < ntiles_y; y++) {\n\t\t\tct = gap_try(x, y, &run, &saw, 0);\n\t\t\tif (ct < 0) return ct;\t/* fatal */\n\t\t}\n\t}\n\n\tfor (n=0; n < ntiles; n++) {\n\t\tif (tile_has_diff[n]) {\n\t\t\tdiffs++;\n\t\t}\n\t}\n\treturn diffs;\n}"
  },
  {
    "function_name": "gap_try",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/scan.c",
    "lines": "2252-2289",
    "snippet": "static int gap_try(int x, int y, int *run, int *saw, int along_x) {\n\tint n, m, i, xt, yt, ct;\n\n\tn = x + y * ntiles_x;\n\n\tif (! tile_has_diff[n]) {\n\t\tif (*saw) {\n\t\t\t(*run)++;\t/* extend the gap run. */\n\t\t}\n\t\treturn 0;\n\t}\n\tif (! *saw || *run == 0 || *run > gaps_fill) {\n\t\t*run = 0;\t\t/* unacceptable run. */\n\t\t*saw = 1;\n\t\treturn 0;\n\t}\n\n\tfor (i=1; i <= *run; i++) {\t/* iterate thru the run. */\n\t\tif (along_x) {\n\t\t\txt = x - i;\n\t\t\tyt = y;\n\t\t} else {\n\t\t\txt = x;\n\t\t\tyt = y - i;\n\t\t}\n\n\t\tm = xt + yt * ntiles_x;\n\t\tif (tile_tried[m]) {\t/* do not repeat tiles */\n\t\t\tcontinue;\n\t\t}\n\n\t\tct = copy_tiles(xt, yt, 1);\n\t\tif (ct < 0) return ct;\t/* fatal */\n\t}\n\t*run = 0;\n\t*saw = 1;\n\treturn 1;\n}",
    "includes": [
      "#include <default8x16.h>",
      "#include \"userinput.h\"",
      "#include \"macosx.h\"",
      "#include \"screen.h\"",
      "#include \"unixpw.h\"",
      "#include \"cleanup.h\"",
      "#include \"pointer.h\"",
      "#include \"screen.h\"",
      "#include \"8to24.h\"",
      "#include \"win_utils.h\"",
      "#include \"xrandr.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"xinerama.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int gap_try(int x, int y, int *run, int *saw, int along_x);",
      "static int island_try(int x, int y, int u, int v, int *run);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_tiles",
          "args": [
            "xt",
            "yt",
            "1"
          ],
          "line": 2283
        },
        "resolved": true,
        "details": {
          "function_name": "copy_tiles",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/scan.c",
          "lines": "1708-2045",
          "snippet": "static int copy_tiles(int tx, int ty, int nt) {\n\tint x, y, line;\n\tint size_x, size_y, width1, width2;\n\tint off, len, n, dw, dx, t;\n\tint w1, w2, dx1, dx2;\t/* tmps for normal and short tiles */\n\tint pixelsize = bpp/8;\n\tint first_min, last_max;\n\tint first_x = -1, last_x = -1;\n\tstatic int prev_ntiles_x = -1;\n\n\tchar *src, *dst, *s_src, *s_dst, *m_src, *m_dst;\n\tchar *h_src, *h_dst;\n\tif (unixpw_in_progress) return 0;\n\n\tif (ntiles_x != prev_ntiles_x && first_line != NULL) {\n\t\tfree(first_line);\tfirst_line = NULL;\n\t\tfree(last_line);\tlast_line = NULL;\n\t\tfree(left_diff);\tleft_diff = NULL;\n\t\tfree(right_diff);\tright_diff = NULL;\n\t}\n\n\tif (first_line == NULL) {\n\t\t/* allocate arrays first time in. */\n\t\tint n = ntiles_x + 1;\n\t\trfbLog(\"copy_tiles: allocating first_line at size %d\\n\", n);\n\t\tfirst_line = (int *) malloc((size_t) (n * sizeof(int)));\n\t\tlast_line  = (int *) malloc((size_t) (n * sizeof(int)));\n\t\tleft_diff  = (unsigned short *)\n\t\t\tmalloc((size_t) (n * sizeof(unsigned short)));\n\t\tright_diff = (unsigned short *)\n\t\t\tmalloc((size_t) (n * sizeof(unsigned short)));\n\t}\n\tprev_ntiles_x = ntiles_x;\n\n\tx = tx * tile_x;\n\ty = ty * tile_y;\n\n\tsize_x = dpy_x - x;\n\tif ( size_x > tile_x * nt ) {\n\t\tsize_x = tile_x * nt;\n\t\twidth1 = tile_x;\n\t\twidth2 = tile_x;\n\t} else {\n\t\t/* short tile */\n\t\twidth1 = tile_x;\t/* internal tile */\n\t\twidth2 = size_x - (nt - 1) * tile_x;\t/* right hand tile */\n\t}\n\n\tsize_y = dpy_y - y;\n\tif ( size_y > tile_y ) {\n\t\tsize_y = tile_y;\n\t}\n\n\tn = tx + ty * ntiles_x;\t\t/* number of the first tile */\n\n\tif (blackouts && tile_blackout[n].cover == 2) {\n\t\t/*\n\t\t * If there are blackouts and this tile is completely covered\n\t\t * no need to poll screen or do anything else..\n\t\t * n.b. we are in single copy_tile mode: nt=1\n\t\t */\n\t\ttile_has_diff[n] = 0;\n\t\treturn(0);\n\t}\n\n\tX_LOCK;\n\tXRANDR_SET_TRAP_RET(-1, \"copy_tile-set\");\n\t/* read in the whole tile run at once: */\n\tcopy_image(tile_row[nt], x, y, size_x, size_y);\n\tXRANDR_CHK_TRAP_RET(-1, \"copy_tile-chk\");\n\n\n\tX_UNLOCK;\n\n\tif (blackouts && tile_blackout[n].cover == 1) {\n\t\t/*\n\t\t * If there are blackouts and this tile is partially covered\n\t\t * we should re-black-out the portion.\n\t\t * n.b. we are in single copy_tile mode: nt=1\n\t\t */\n\t\tint x1, x2, y1, y2, b;\n\t\tint w, s, fill = 0;\n\n\t\tfor (b=0; b < tile_blackout[n].count; b++) {\n\t\t\tchar *b_dst = tile_row[nt]->data;\n\t\t\t\n\t\t\tx1 = tile_blackout[n].bo[b].x1 - x;\n\t\t\ty1 = tile_blackout[n].bo[b].y1 - y;\n\t\t\tx2 = tile_blackout[n].bo[b].x2 - x;\n\t\t\ty2 = tile_blackout[n].bo[b].y2 - y;\n\n\t\t\tw = (x2 - x1) * pixelsize;\n\t\t\ts = x1 * pixelsize;\n\n\t\t\tfor (line = 0; line < size_y; line++) {\n\t\t\t\tif (y1 <= line && line < y2) {\n\t\t\t\t\tmemset(b_dst + s, fill, (size_t) w);\n\t\t\t\t}\n\t\t\t\tb_dst += tile_row[nt]->bytes_per_line;\n\t\t\t}\n\t\t}\n\t}\n\n\tsrc = tile_row[nt]->data;\n\tdst = main_fb + y * main_bytes_per_line + x * pixelsize;\n\n\ts_src = src;\n\ts_dst = dst;\n\n\tfor (t=1; t <= nt; t++) {\n\t\tfirst_line[t] = -1;\n\t}\n\n\t/* find the first line with difference: */\n\tw1 = width1 * pixelsize;\n\tw2 = width2 * pixelsize;\n\n\t/* foreach line: */\n\tfor (line = 0; line < size_y; line++) {\n\t\t/* foreach horizontal tile: */\n\t\tfor (t=1; t <= nt; t++) {\n\t\t\tif (first_line[t] != -1) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\toff = (t-1) * w1;\n\t\t\tif (t == nt) {\n\t\t\t\tlen = w2;\t/* possible short tile */\n\t\t\t} else {\n\t\t\t\tlen = w1;\n\t\t\t}\n\t\t\t\n\t\t\tif (memcmp(s_dst + off, s_src + off, len)) {\n\t\t\t\tfirst_line[t] = line;\n\t\t\t}\n\t\t}\n\t\ts_src += tile_row[nt]->bytes_per_line;\n\t\ts_dst += main_bytes_per_line;\n\t}\n\n\t/* see if there were any differences for any tile: */\n\tfirst_min = -1;\n\tfor (t=1; t <= nt; t++) {\n\t\ttile_tried[n+(t-1)] = 1;\n\t\tif (first_line[t] != -1) {\n\t\t\tif (first_min == -1 || first_line[t] < first_min) {\n\t\t\t\tfirst_min = first_line[t];\n\t\t\t}\n\t\t}\n\t}\n\tif (first_min == -1) {\n\t\t/* no tile has a difference, note this and get out: */\n\t\tfor (t=1; t <= nt; t++) {\n\t\t\ttile_has_diff[n+(t-1)] = 0;\n\t\t}\n\t\treturn(0);\n\t} else {\n\t\t/*\n\t\t * at least one tile has a difference.  make sure info\n\t\t * is recorded (e.g. sometimes we guess tiles and they\n\t\t * came in with tile_has_diff 0)\n\t\t */\n\t\tfor (t=1; t <= nt; t++) {\n\t\t\tif (first_line[t] == -1) {\n\t\t\t\ttile_has_diff[n+(t-1)] = 0;\n\t\t\t} else {\n\t\t\t\ttile_has_diff[n+(t-1)] = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tm_src = src + (tile_row[nt]->bytes_per_line * size_y);\n\tm_dst = dst + (main_bytes_per_line * size_y);\n\n\tfor (t=1; t <= nt; t++) {\n\t\tlast_line[t] = first_line[t];\n\t}\n\n\t/* find the last line with difference: */\n\tw1 = width1 * pixelsize;\n\tw2 = width2 * pixelsize;\n\n\t/* foreach line: */\n\tfor (line = size_y - 1; line > first_min; line--) {\n\n\t\tm_src -= tile_row[nt]->bytes_per_line;\n\t\tm_dst -= main_bytes_per_line;\n\n\t\t/* foreach tile: */\n\t\tfor (t=1; t <= nt; t++) {\n\t\t\tif (first_line[t] == -1\n\t\t\t    || last_line[t] != first_line[t]) {\n\t\t\t\t/* tile has no changes or already done */\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\toff = (t-1) * w1;\n\t\t\tif (t == nt) {\n\t\t\t\tlen = w2;\t/* possible short tile */\n\t\t\t} else {\n\t\t\t\tlen = w1;\n\t\t\t}\n\t\t\tif (memcmp(m_dst + off, m_src + off, len)) {\n\t\t\t\tlast_line[t] = line;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/*\n\t * determine the farthest down last changed line\n\t * will be used below to limit our memcpy() to the framebuffer.\n\t */\n\tlast_max = -1;\n\tfor (t=1; t <= nt; t++) {\n\t\tif (first_line[t] == -1) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (last_max == -1 || last_line[t] > last_max) {\n\t\t\tlast_max = last_line[t];\n\t\t}\n\t}\n\n\t/* look for differences on left and right hand edges: */\n\tfor (t=1; t <= nt; t++) {\n\t\tleft_diff[t] = 0;\n\t\tright_diff[t] = 0;\n\t}\n\n\th_src = src;\n\th_dst = dst;\n\n\tw1 = width1 * pixelsize;\n\tw2 = width2 * pixelsize;\n\n\tdx1 = (width1 - tile_fuzz) * pixelsize;\n\tdx2 = (width2 - tile_fuzz) * pixelsize;\n\tdw = tile_fuzz * pixelsize; \n\n\t/* foreach line: */\n\tfor (line = 0; line < size_y; line++) {\n\t\t/* foreach tile: */\n\t\tfor (t=1; t <= nt; t++) {\n\t\t\tif (first_line[t] == -1) {\n\t\t\t\t/* tile has no changes at all */\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\toff = (t-1) * w1;\n\t\t\tif (t == nt) {\n\t\t\t\tdx = dx2;\t/* possible short tile */\n\t\t\t\tif (dx <= 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdx = dx1;\n\t\t\t}\n\n\t\t\tif (! left_diff[t] && memcmp(h_dst + off,\n\t\t\t    h_src + off, dw)) {\n\t\t\t\tleft_diff[t] = 1;\n\t\t\t}\n\t\t\tif (! right_diff[t] && memcmp(h_dst + off + dx,\n\t\t\t    h_src + off + dx, dw) ) {\n\t\t\t\tright_diff[t] = 1;\n\t\t\t}\n\t\t}\n\t\th_src += tile_row[nt]->bytes_per_line;\n\t\th_dst += main_bytes_per_line;\n\t}\n\n\t/* now finally copy the difference to the rfb framebuffer: */\n\ts_src = src + tile_row[nt]->bytes_per_line * first_min;\n\ts_dst = dst + main_bytes_per_line * first_min;\n\n\tfor (line = first_min; line <= last_max; line++) {\n\t\t/* for I/O speed we do not do this tile by tile */\n\t\tmemcpy(s_dst, s_src, size_x * pixelsize);\n\t\tif (nt == 1) {\n\t\t\t/*\n\t\t\t * optimization for tall skinny lines, e.g. wm\n\t\t\t * frame. try to find first_x and last_x to limit\n\t\t\t * the size of the hint.  could help for a slow\n\t\t\t * link.  Unfortunately we spent a lot of time\n\t\t\t * reading in the many tiles.\n\t\t\t *\n\t\t\t * BTW, we like to think the above memcpy leaves\n\t\t\t * the data we use below in the cache... (but\n\t\t\t * it could be two 128 byte segments at 32bpp)\n\t\t\t * so this inner loop is not as bad as it seems.\n\t\t\t */\n\t\t\tint k, kx;\n\t\t\tkx = pixelsize;\n\t\t\tfor (k=0; k<size_x; k++) {\n\t\t\t\tif (memcmp(s_dst + k*kx, s_src + k*kx, kx))  {\n\t\t\t\t\tif (first_x == -1 || k < first_x) {\n\t\t\t\t\t\tfirst_x = k;\n\t\t\t\t\t}\n\t\t\t\t\tif (last_x == -1 || k > last_x) {\n\t\t\t\t\t\tlast_x = k;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ts_src += tile_row[nt]->bytes_per_line;\n\t\ts_dst += main_bytes_per_line;\n\t}\n\n\t/* record all the info in the region array for this tile: */\n\tfor (t=1; t <= nt; t++) {\n\t\tint s = t - 1;\n\n\t\tif (first_line[t] == -1) {\n\t\t\t/* tile unchanged */\n\t\t\tcontinue;\n\t\t}\n\t\ttile_region[n+s].first_line = first_line[t];\n\t\ttile_region[n+s].last_line  = last_line[t];\n\n\t\ttile_region[n+s].first_x = first_x;\n\t\ttile_region[n+s].last_x  = last_x;\n\n\t\ttile_region[n+s].top_diff = 0;\n\t\ttile_region[n+s].bot_diff = 0;\n\t\tif ( first_line[t] < tile_fuzz ) {\n\t\t\ttile_region[n+s].top_diff = 1;\n\t\t}\n\t\tif ( last_line[t] > (size_y - 1) - tile_fuzz ) {\n\t\t\ttile_region[n+s].bot_diff = 1;\n\t\t}\n\n\t\ttile_region[n+s].left_diff  = left_diff[t];\n\t\ttile_region[n+s].right_diff = right_diff[t];\n\n\t\ttile_copied[n+s] = 1;\n\t}\n\n\treturn(1);\n}",
          "includes": [
            "#include <default8x16.h>",
            "#include \"userinput.h\"",
            "#include \"macosx.h\"",
            "#include \"screen.h\"",
            "#include \"unixpw.h\"",
            "#include \"cleanup.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"8to24.h\"",
            "#include \"win_utils.h\"",
            "#include \"xrandr.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void create_tile_hint(int x, int y, int tw, int th, hint_t *hint);",
            "static void extend_tile_hint(int x, int y, int tw, int th, hint_t *hint);",
            "static void mark_hint(hint_t hint);",
            "static int copy_tiles(int tx, int ty, int nt);",
            "static int island_try(int x, int y, int u, int v, int *run);",
            "static int blackout_line_cmpskip(int n, int x, int y, char *dst, char *src,\n    int w, int pixelsize);",
            "static region_t *tile_region;",
            "static int *first_line = NULL, *last_line = NULL;",
            "static unsigned short *left_diff = NULL, *right_diff = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <default8x16.h>\n#include \"userinput.h\"\n#include \"macosx.h\"\n#include \"screen.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"8to24.h\"\n#include \"win_utils.h\"\n#include \"xrandr.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nstatic void create_tile_hint(int x, int y, int tw, int th, hint_t *hint);\nstatic void extend_tile_hint(int x, int y, int tw, int th, hint_t *hint);\nstatic void mark_hint(hint_t hint);\nstatic int copy_tiles(int tx, int ty, int nt);\nstatic int island_try(int x, int y, int u, int v, int *run);\nstatic int blackout_line_cmpskip(int n, int x, int y, char *dst, char *src,\n    int w, int pixelsize);\nstatic region_t *tile_region;\nstatic int *first_line = NULL, *last_line = NULL;\nstatic unsigned short *left_diff = NULL, *right_diff = NULL;\n\nstatic int copy_tiles(int tx, int ty, int nt) {\n\tint x, y, line;\n\tint size_x, size_y, width1, width2;\n\tint off, len, n, dw, dx, t;\n\tint w1, w2, dx1, dx2;\t/* tmps for normal and short tiles */\n\tint pixelsize = bpp/8;\n\tint first_min, last_max;\n\tint first_x = -1, last_x = -1;\n\tstatic int prev_ntiles_x = -1;\n\n\tchar *src, *dst, *s_src, *s_dst, *m_src, *m_dst;\n\tchar *h_src, *h_dst;\n\tif (unixpw_in_progress) return 0;\n\n\tif (ntiles_x != prev_ntiles_x && first_line != NULL) {\n\t\tfree(first_line);\tfirst_line = NULL;\n\t\tfree(last_line);\tlast_line = NULL;\n\t\tfree(left_diff);\tleft_diff = NULL;\n\t\tfree(right_diff);\tright_diff = NULL;\n\t}\n\n\tif (first_line == NULL) {\n\t\t/* allocate arrays first time in. */\n\t\tint n = ntiles_x + 1;\n\t\trfbLog(\"copy_tiles: allocating first_line at size %d\\n\", n);\n\t\tfirst_line = (int *) malloc((size_t) (n * sizeof(int)));\n\t\tlast_line  = (int *) malloc((size_t) (n * sizeof(int)));\n\t\tleft_diff  = (unsigned short *)\n\t\t\tmalloc((size_t) (n * sizeof(unsigned short)));\n\t\tright_diff = (unsigned short *)\n\t\t\tmalloc((size_t) (n * sizeof(unsigned short)));\n\t}\n\tprev_ntiles_x = ntiles_x;\n\n\tx = tx * tile_x;\n\ty = ty * tile_y;\n\n\tsize_x = dpy_x - x;\n\tif ( size_x > tile_x * nt ) {\n\t\tsize_x = tile_x * nt;\n\t\twidth1 = tile_x;\n\t\twidth2 = tile_x;\n\t} else {\n\t\t/* short tile */\n\t\twidth1 = tile_x;\t/* internal tile */\n\t\twidth2 = size_x - (nt - 1) * tile_x;\t/* right hand tile */\n\t}\n\n\tsize_y = dpy_y - y;\n\tif ( size_y > tile_y ) {\n\t\tsize_y = tile_y;\n\t}\n\n\tn = tx + ty * ntiles_x;\t\t/* number of the first tile */\n\n\tif (blackouts && tile_blackout[n].cover == 2) {\n\t\t/*\n\t\t * If there are blackouts and this tile is completely covered\n\t\t * no need to poll screen or do anything else..\n\t\t * n.b. we are in single copy_tile mode: nt=1\n\t\t */\n\t\ttile_has_diff[n] = 0;\n\t\treturn(0);\n\t}\n\n\tX_LOCK;\n\tXRANDR_SET_TRAP_RET(-1, \"copy_tile-set\");\n\t/* read in the whole tile run at once: */\n\tcopy_image(tile_row[nt], x, y, size_x, size_y);\n\tXRANDR_CHK_TRAP_RET(-1, \"copy_tile-chk\");\n\n\n\tX_UNLOCK;\n\n\tif (blackouts && tile_blackout[n].cover == 1) {\n\t\t/*\n\t\t * If there are blackouts and this tile is partially covered\n\t\t * we should re-black-out the portion.\n\t\t * n.b. we are in single copy_tile mode: nt=1\n\t\t */\n\t\tint x1, x2, y1, y2, b;\n\t\tint w, s, fill = 0;\n\n\t\tfor (b=0; b < tile_blackout[n].count; b++) {\n\t\t\tchar *b_dst = tile_row[nt]->data;\n\t\t\t\n\t\t\tx1 = tile_blackout[n].bo[b].x1 - x;\n\t\t\ty1 = tile_blackout[n].bo[b].y1 - y;\n\t\t\tx2 = tile_blackout[n].bo[b].x2 - x;\n\t\t\ty2 = tile_blackout[n].bo[b].y2 - y;\n\n\t\t\tw = (x2 - x1) * pixelsize;\n\t\t\ts = x1 * pixelsize;\n\n\t\t\tfor (line = 0; line < size_y; line++) {\n\t\t\t\tif (y1 <= line && line < y2) {\n\t\t\t\t\tmemset(b_dst + s, fill, (size_t) w);\n\t\t\t\t}\n\t\t\t\tb_dst += tile_row[nt]->bytes_per_line;\n\t\t\t}\n\t\t}\n\t}\n\n\tsrc = tile_row[nt]->data;\n\tdst = main_fb + y * main_bytes_per_line + x * pixelsize;\n\n\ts_src = src;\n\ts_dst = dst;\n\n\tfor (t=1; t <= nt; t++) {\n\t\tfirst_line[t] = -1;\n\t}\n\n\t/* find the first line with difference: */\n\tw1 = width1 * pixelsize;\n\tw2 = width2 * pixelsize;\n\n\t/* foreach line: */\n\tfor (line = 0; line < size_y; line++) {\n\t\t/* foreach horizontal tile: */\n\t\tfor (t=1; t <= nt; t++) {\n\t\t\tif (first_line[t] != -1) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\toff = (t-1) * w1;\n\t\t\tif (t == nt) {\n\t\t\t\tlen = w2;\t/* possible short tile */\n\t\t\t} else {\n\t\t\t\tlen = w1;\n\t\t\t}\n\t\t\t\n\t\t\tif (memcmp(s_dst + off, s_src + off, len)) {\n\t\t\t\tfirst_line[t] = line;\n\t\t\t}\n\t\t}\n\t\ts_src += tile_row[nt]->bytes_per_line;\n\t\ts_dst += main_bytes_per_line;\n\t}\n\n\t/* see if there were any differences for any tile: */\n\tfirst_min = -1;\n\tfor (t=1; t <= nt; t++) {\n\t\ttile_tried[n+(t-1)] = 1;\n\t\tif (first_line[t] != -1) {\n\t\t\tif (first_min == -1 || first_line[t] < first_min) {\n\t\t\t\tfirst_min = first_line[t];\n\t\t\t}\n\t\t}\n\t}\n\tif (first_min == -1) {\n\t\t/* no tile has a difference, note this and get out: */\n\t\tfor (t=1; t <= nt; t++) {\n\t\t\ttile_has_diff[n+(t-1)] = 0;\n\t\t}\n\t\treturn(0);\n\t} else {\n\t\t/*\n\t\t * at least one tile has a difference.  make sure info\n\t\t * is recorded (e.g. sometimes we guess tiles and they\n\t\t * came in with tile_has_diff 0)\n\t\t */\n\t\tfor (t=1; t <= nt; t++) {\n\t\t\tif (first_line[t] == -1) {\n\t\t\t\ttile_has_diff[n+(t-1)] = 0;\n\t\t\t} else {\n\t\t\t\ttile_has_diff[n+(t-1)] = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tm_src = src + (tile_row[nt]->bytes_per_line * size_y);\n\tm_dst = dst + (main_bytes_per_line * size_y);\n\n\tfor (t=1; t <= nt; t++) {\n\t\tlast_line[t] = first_line[t];\n\t}\n\n\t/* find the last line with difference: */\n\tw1 = width1 * pixelsize;\n\tw2 = width2 * pixelsize;\n\n\t/* foreach line: */\n\tfor (line = size_y - 1; line > first_min; line--) {\n\n\t\tm_src -= tile_row[nt]->bytes_per_line;\n\t\tm_dst -= main_bytes_per_line;\n\n\t\t/* foreach tile: */\n\t\tfor (t=1; t <= nt; t++) {\n\t\t\tif (first_line[t] == -1\n\t\t\t    || last_line[t] != first_line[t]) {\n\t\t\t\t/* tile has no changes or already done */\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\toff = (t-1) * w1;\n\t\t\tif (t == nt) {\n\t\t\t\tlen = w2;\t/* possible short tile */\n\t\t\t} else {\n\t\t\t\tlen = w1;\n\t\t\t}\n\t\t\tif (memcmp(m_dst + off, m_src + off, len)) {\n\t\t\t\tlast_line[t] = line;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/*\n\t * determine the farthest down last changed line\n\t * will be used below to limit our memcpy() to the framebuffer.\n\t */\n\tlast_max = -1;\n\tfor (t=1; t <= nt; t++) {\n\t\tif (first_line[t] == -1) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (last_max == -1 || last_line[t] > last_max) {\n\t\t\tlast_max = last_line[t];\n\t\t}\n\t}\n\n\t/* look for differences on left and right hand edges: */\n\tfor (t=1; t <= nt; t++) {\n\t\tleft_diff[t] = 0;\n\t\tright_diff[t] = 0;\n\t}\n\n\th_src = src;\n\th_dst = dst;\n\n\tw1 = width1 * pixelsize;\n\tw2 = width2 * pixelsize;\n\n\tdx1 = (width1 - tile_fuzz) * pixelsize;\n\tdx2 = (width2 - tile_fuzz) * pixelsize;\n\tdw = tile_fuzz * pixelsize; \n\n\t/* foreach line: */\n\tfor (line = 0; line < size_y; line++) {\n\t\t/* foreach tile: */\n\t\tfor (t=1; t <= nt; t++) {\n\t\t\tif (first_line[t] == -1) {\n\t\t\t\t/* tile has no changes at all */\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\toff = (t-1) * w1;\n\t\t\tif (t == nt) {\n\t\t\t\tdx = dx2;\t/* possible short tile */\n\t\t\t\tif (dx <= 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdx = dx1;\n\t\t\t}\n\n\t\t\tif (! left_diff[t] && memcmp(h_dst + off,\n\t\t\t    h_src + off, dw)) {\n\t\t\t\tleft_diff[t] = 1;\n\t\t\t}\n\t\t\tif (! right_diff[t] && memcmp(h_dst + off + dx,\n\t\t\t    h_src + off + dx, dw) ) {\n\t\t\t\tright_diff[t] = 1;\n\t\t\t}\n\t\t}\n\t\th_src += tile_row[nt]->bytes_per_line;\n\t\th_dst += main_bytes_per_line;\n\t}\n\n\t/* now finally copy the difference to the rfb framebuffer: */\n\ts_src = src + tile_row[nt]->bytes_per_line * first_min;\n\ts_dst = dst + main_bytes_per_line * first_min;\n\n\tfor (line = first_min; line <= last_max; line++) {\n\t\t/* for I/O speed we do not do this tile by tile */\n\t\tmemcpy(s_dst, s_src, size_x * pixelsize);\n\t\tif (nt == 1) {\n\t\t\t/*\n\t\t\t * optimization for tall skinny lines, e.g. wm\n\t\t\t * frame. try to find first_x and last_x to limit\n\t\t\t * the size of the hint.  could help for a slow\n\t\t\t * link.  Unfortunately we spent a lot of time\n\t\t\t * reading in the many tiles.\n\t\t\t *\n\t\t\t * BTW, we like to think the above memcpy leaves\n\t\t\t * the data we use below in the cache... (but\n\t\t\t * it could be two 128 byte segments at 32bpp)\n\t\t\t * so this inner loop is not as bad as it seems.\n\t\t\t */\n\t\t\tint k, kx;\n\t\t\tkx = pixelsize;\n\t\t\tfor (k=0; k<size_x; k++) {\n\t\t\t\tif (memcmp(s_dst + k*kx, s_src + k*kx, kx))  {\n\t\t\t\t\tif (first_x == -1 || k < first_x) {\n\t\t\t\t\t\tfirst_x = k;\n\t\t\t\t\t}\n\t\t\t\t\tif (last_x == -1 || k > last_x) {\n\t\t\t\t\t\tlast_x = k;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ts_src += tile_row[nt]->bytes_per_line;\n\t\ts_dst += main_bytes_per_line;\n\t}\n\n\t/* record all the info in the region array for this tile: */\n\tfor (t=1; t <= nt; t++) {\n\t\tint s = t - 1;\n\n\t\tif (first_line[t] == -1) {\n\t\t\t/* tile unchanged */\n\t\t\tcontinue;\n\t\t}\n\t\ttile_region[n+s].first_line = first_line[t];\n\t\ttile_region[n+s].last_line  = last_line[t];\n\n\t\ttile_region[n+s].first_x = first_x;\n\t\ttile_region[n+s].last_x  = last_x;\n\n\t\ttile_region[n+s].top_diff = 0;\n\t\ttile_region[n+s].bot_diff = 0;\n\t\tif ( first_line[t] < tile_fuzz ) {\n\t\t\ttile_region[n+s].top_diff = 1;\n\t\t}\n\t\tif ( last_line[t] > (size_y - 1) - tile_fuzz ) {\n\t\t\ttile_region[n+s].bot_diff = 1;\n\t\t}\n\n\t\ttile_region[n+s].left_diff  = left_diff[t];\n\t\ttile_region[n+s].right_diff = right_diff[t];\n\n\t\ttile_copied[n+s] = 1;\n\t}\n\n\treturn(1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <default8x16.h>\n#include \"userinput.h\"\n#include \"macosx.h\"\n#include \"screen.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"8to24.h\"\n#include \"win_utils.h\"\n#include \"xrandr.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nstatic int gap_try(int x, int y, int *run, int *saw, int along_x);\nstatic int island_try(int x, int y, int u, int v, int *run);\n\nstatic int gap_try(int x, int y, int *run, int *saw, int along_x) {\n\tint n, m, i, xt, yt, ct;\n\n\tn = x + y * ntiles_x;\n\n\tif (! tile_has_diff[n]) {\n\t\tif (*saw) {\n\t\t\t(*run)++;\t/* extend the gap run. */\n\t\t}\n\t\treturn 0;\n\t}\n\tif (! *saw || *run == 0 || *run > gaps_fill) {\n\t\t*run = 0;\t\t/* unacceptable run. */\n\t\t*saw = 1;\n\t\treturn 0;\n\t}\n\n\tfor (i=1; i <= *run; i++) {\t/* iterate thru the run. */\n\t\tif (along_x) {\n\t\t\txt = x - i;\n\t\t\tyt = y;\n\t\t} else {\n\t\t\txt = x;\n\t\t\tyt = y - i;\n\t\t}\n\n\t\tm = xt + yt * ntiles_x;\n\t\tif (tile_tried[m]) {\t/* do not repeat tiles */\n\t\t\tcontinue;\n\t\t}\n\n\t\tct = copy_tiles(xt, yt, 1);\n\t\tif (ct < 0) return ct;\t/* fatal */\n\t}\n\t*run = 0;\n\t*saw = 1;\n\treturn 1;\n}"
  },
  {
    "function_name": "copy_tiles_additional_pass",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/scan.c",
    "lines": "2223-2250",
    "snippet": "static int copy_tiles_additional_pass(void) {\n\tint x, y, n;\n\tint diffs = 0, ct;\n\n\tif (unixpw_in_progress) return 0;\n\n\tfor (y=0; y < ntiles_y; y++) {\n\t\tfor (x=0; x < ntiles_x; x++) {\n\t\t\tn = x + y * ntiles_x;\t\t/* number of this tile */\n\n\t\t\tif (! tile_has_diff[n]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (tile_copied[n]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tct = copy_tiles(x, y, 1);\n\t\t\tif (ct < 0) return ct;\t/* fatal */\n\t\t}\n\t}\n\tfor (n=0; n < ntiles; n++) {\n\t\tif (tile_has_diff[n]) {\n\t\t\tdiffs++;\n\t\t}\n\t}\n\treturn diffs;\n}",
    "includes": [
      "#include <default8x16.h>",
      "#include \"userinput.h\"",
      "#include \"macosx.h\"",
      "#include \"screen.h\"",
      "#include \"unixpw.h\"",
      "#include \"cleanup.h\"",
      "#include \"pointer.h\"",
      "#include \"screen.h\"",
      "#include \"8to24.h\"",
      "#include \"win_utils.h\"",
      "#include \"xrandr.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"xinerama.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int copy_tiles_additional_pass(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_tiles",
          "args": [
            "x",
            "y",
            "1"
          ],
          "line": 2240
        },
        "resolved": true,
        "details": {
          "function_name": "copy_tiles",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/scan.c",
          "lines": "1708-2045",
          "snippet": "static int copy_tiles(int tx, int ty, int nt) {\n\tint x, y, line;\n\tint size_x, size_y, width1, width2;\n\tint off, len, n, dw, dx, t;\n\tint w1, w2, dx1, dx2;\t/* tmps for normal and short tiles */\n\tint pixelsize = bpp/8;\n\tint first_min, last_max;\n\tint first_x = -1, last_x = -1;\n\tstatic int prev_ntiles_x = -1;\n\n\tchar *src, *dst, *s_src, *s_dst, *m_src, *m_dst;\n\tchar *h_src, *h_dst;\n\tif (unixpw_in_progress) return 0;\n\n\tif (ntiles_x != prev_ntiles_x && first_line != NULL) {\n\t\tfree(first_line);\tfirst_line = NULL;\n\t\tfree(last_line);\tlast_line = NULL;\n\t\tfree(left_diff);\tleft_diff = NULL;\n\t\tfree(right_diff);\tright_diff = NULL;\n\t}\n\n\tif (first_line == NULL) {\n\t\t/* allocate arrays first time in. */\n\t\tint n = ntiles_x + 1;\n\t\trfbLog(\"copy_tiles: allocating first_line at size %d\\n\", n);\n\t\tfirst_line = (int *) malloc((size_t) (n * sizeof(int)));\n\t\tlast_line  = (int *) malloc((size_t) (n * sizeof(int)));\n\t\tleft_diff  = (unsigned short *)\n\t\t\tmalloc((size_t) (n * sizeof(unsigned short)));\n\t\tright_diff = (unsigned short *)\n\t\t\tmalloc((size_t) (n * sizeof(unsigned short)));\n\t}\n\tprev_ntiles_x = ntiles_x;\n\n\tx = tx * tile_x;\n\ty = ty * tile_y;\n\n\tsize_x = dpy_x - x;\n\tif ( size_x > tile_x * nt ) {\n\t\tsize_x = tile_x * nt;\n\t\twidth1 = tile_x;\n\t\twidth2 = tile_x;\n\t} else {\n\t\t/* short tile */\n\t\twidth1 = tile_x;\t/* internal tile */\n\t\twidth2 = size_x - (nt - 1) * tile_x;\t/* right hand tile */\n\t}\n\n\tsize_y = dpy_y - y;\n\tif ( size_y > tile_y ) {\n\t\tsize_y = tile_y;\n\t}\n\n\tn = tx + ty * ntiles_x;\t\t/* number of the first tile */\n\n\tif (blackouts && tile_blackout[n].cover == 2) {\n\t\t/*\n\t\t * If there are blackouts and this tile is completely covered\n\t\t * no need to poll screen or do anything else..\n\t\t * n.b. we are in single copy_tile mode: nt=1\n\t\t */\n\t\ttile_has_diff[n] = 0;\n\t\treturn(0);\n\t}\n\n\tX_LOCK;\n\tXRANDR_SET_TRAP_RET(-1, \"copy_tile-set\");\n\t/* read in the whole tile run at once: */\n\tcopy_image(tile_row[nt], x, y, size_x, size_y);\n\tXRANDR_CHK_TRAP_RET(-1, \"copy_tile-chk\");\n\n\n\tX_UNLOCK;\n\n\tif (blackouts && tile_blackout[n].cover == 1) {\n\t\t/*\n\t\t * If there are blackouts and this tile is partially covered\n\t\t * we should re-black-out the portion.\n\t\t * n.b. we are in single copy_tile mode: nt=1\n\t\t */\n\t\tint x1, x2, y1, y2, b;\n\t\tint w, s, fill = 0;\n\n\t\tfor (b=0; b < tile_blackout[n].count; b++) {\n\t\t\tchar *b_dst = tile_row[nt]->data;\n\t\t\t\n\t\t\tx1 = tile_blackout[n].bo[b].x1 - x;\n\t\t\ty1 = tile_blackout[n].bo[b].y1 - y;\n\t\t\tx2 = tile_blackout[n].bo[b].x2 - x;\n\t\t\ty2 = tile_blackout[n].bo[b].y2 - y;\n\n\t\t\tw = (x2 - x1) * pixelsize;\n\t\t\ts = x1 * pixelsize;\n\n\t\t\tfor (line = 0; line < size_y; line++) {\n\t\t\t\tif (y1 <= line && line < y2) {\n\t\t\t\t\tmemset(b_dst + s, fill, (size_t) w);\n\t\t\t\t}\n\t\t\t\tb_dst += tile_row[nt]->bytes_per_line;\n\t\t\t}\n\t\t}\n\t}\n\n\tsrc = tile_row[nt]->data;\n\tdst = main_fb + y * main_bytes_per_line + x * pixelsize;\n\n\ts_src = src;\n\ts_dst = dst;\n\n\tfor (t=1; t <= nt; t++) {\n\t\tfirst_line[t] = -1;\n\t}\n\n\t/* find the first line with difference: */\n\tw1 = width1 * pixelsize;\n\tw2 = width2 * pixelsize;\n\n\t/* foreach line: */\n\tfor (line = 0; line < size_y; line++) {\n\t\t/* foreach horizontal tile: */\n\t\tfor (t=1; t <= nt; t++) {\n\t\t\tif (first_line[t] != -1) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\toff = (t-1) * w1;\n\t\t\tif (t == nt) {\n\t\t\t\tlen = w2;\t/* possible short tile */\n\t\t\t} else {\n\t\t\t\tlen = w1;\n\t\t\t}\n\t\t\t\n\t\t\tif (memcmp(s_dst + off, s_src + off, len)) {\n\t\t\t\tfirst_line[t] = line;\n\t\t\t}\n\t\t}\n\t\ts_src += tile_row[nt]->bytes_per_line;\n\t\ts_dst += main_bytes_per_line;\n\t}\n\n\t/* see if there were any differences for any tile: */\n\tfirst_min = -1;\n\tfor (t=1; t <= nt; t++) {\n\t\ttile_tried[n+(t-1)] = 1;\n\t\tif (first_line[t] != -1) {\n\t\t\tif (first_min == -1 || first_line[t] < first_min) {\n\t\t\t\tfirst_min = first_line[t];\n\t\t\t}\n\t\t}\n\t}\n\tif (first_min == -1) {\n\t\t/* no tile has a difference, note this and get out: */\n\t\tfor (t=1; t <= nt; t++) {\n\t\t\ttile_has_diff[n+(t-1)] = 0;\n\t\t}\n\t\treturn(0);\n\t} else {\n\t\t/*\n\t\t * at least one tile has a difference.  make sure info\n\t\t * is recorded (e.g. sometimes we guess tiles and they\n\t\t * came in with tile_has_diff 0)\n\t\t */\n\t\tfor (t=1; t <= nt; t++) {\n\t\t\tif (first_line[t] == -1) {\n\t\t\t\ttile_has_diff[n+(t-1)] = 0;\n\t\t\t} else {\n\t\t\t\ttile_has_diff[n+(t-1)] = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tm_src = src + (tile_row[nt]->bytes_per_line * size_y);\n\tm_dst = dst + (main_bytes_per_line * size_y);\n\n\tfor (t=1; t <= nt; t++) {\n\t\tlast_line[t] = first_line[t];\n\t}\n\n\t/* find the last line with difference: */\n\tw1 = width1 * pixelsize;\n\tw2 = width2 * pixelsize;\n\n\t/* foreach line: */\n\tfor (line = size_y - 1; line > first_min; line--) {\n\n\t\tm_src -= tile_row[nt]->bytes_per_line;\n\t\tm_dst -= main_bytes_per_line;\n\n\t\t/* foreach tile: */\n\t\tfor (t=1; t <= nt; t++) {\n\t\t\tif (first_line[t] == -1\n\t\t\t    || last_line[t] != first_line[t]) {\n\t\t\t\t/* tile has no changes or already done */\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\toff = (t-1) * w1;\n\t\t\tif (t == nt) {\n\t\t\t\tlen = w2;\t/* possible short tile */\n\t\t\t} else {\n\t\t\t\tlen = w1;\n\t\t\t}\n\t\t\tif (memcmp(m_dst + off, m_src + off, len)) {\n\t\t\t\tlast_line[t] = line;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/*\n\t * determine the farthest down last changed line\n\t * will be used below to limit our memcpy() to the framebuffer.\n\t */\n\tlast_max = -1;\n\tfor (t=1; t <= nt; t++) {\n\t\tif (first_line[t] == -1) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (last_max == -1 || last_line[t] > last_max) {\n\t\t\tlast_max = last_line[t];\n\t\t}\n\t}\n\n\t/* look for differences on left and right hand edges: */\n\tfor (t=1; t <= nt; t++) {\n\t\tleft_diff[t] = 0;\n\t\tright_diff[t] = 0;\n\t}\n\n\th_src = src;\n\th_dst = dst;\n\n\tw1 = width1 * pixelsize;\n\tw2 = width2 * pixelsize;\n\n\tdx1 = (width1 - tile_fuzz) * pixelsize;\n\tdx2 = (width2 - tile_fuzz) * pixelsize;\n\tdw = tile_fuzz * pixelsize; \n\n\t/* foreach line: */\n\tfor (line = 0; line < size_y; line++) {\n\t\t/* foreach tile: */\n\t\tfor (t=1; t <= nt; t++) {\n\t\t\tif (first_line[t] == -1) {\n\t\t\t\t/* tile has no changes at all */\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\toff = (t-1) * w1;\n\t\t\tif (t == nt) {\n\t\t\t\tdx = dx2;\t/* possible short tile */\n\t\t\t\tif (dx <= 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdx = dx1;\n\t\t\t}\n\n\t\t\tif (! left_diff[t] && memcmp(h_dst + off,\n\t\t\t    h_src + off, dw)) {\n\t\t\t\tleft_diff[t] = 1;\n\t\t\t}\n\t\t\tif (! right_diff[t] && memcmp(h_dst + off + dx,\n\t\t\t    h_src + off + dx, dw) ) {\n\t\t\t\tright_diff[t] = 1;\n\t\t\t}\n\t\t}\n\t\th_src += tile_row[nt]->bytes_per_line;\n\t\th_dst += main_bytes_per_line;\n\t}\n\n\t/* now finally copy the difference to the rfb framebuffer: */\n\ts_src = src + tile_row[nt]->bytes_per_line * first_min;\n\ts_dst = dst + main_bytes_per_line * first_min;\n\n\tfor (line = first_min; line <= last_max; line++) {\n\t\t/* for I/O speed we do not do this tile by tile */\n\t\tmemcpy(s_dst, s_src, size_x * pixelsize);\n\t\tif (nt == 1) {\n\t\t\t/*\n\t\t\t * optimization for tall skinny lines, e.g. wm\n\t\t\t * frame. try to find first_x and last_x to limit\n\t\t\t * the size of the hint.  could help for a slow\n\t\t\t * link.  Unfortunately we spent a lot of time\n\t\t\t * reading in the many tiles.\n\t\t\t *\n\t\t\t * BTW, we like to think the above memcpy leaves\n\t\t\t * the data we use below in the cache... (but\n\t\t\t * it could be two 128 byte segments at 32bpp)\n\t\t\t * so this inner loop is not as bad as it seems.\n\t\t\t */\n\t\t\tint k, kx;\n\t\t\tkx = pixelsize;\n\t\t\tfor (k=0; k<size_x; k++) {\n\t\t\t\tif (memcmp(s_dst + k*kx, s_src + k*kx, kx))  {\n\t\t\t\t\tif (first_x == -1 || k < first_x) {\n\t\t\t\t\t\tfirst_x = k;\n\t\t\t\t\t}\n\t\t\t\t\tif (last_x == -1 || k > last_x) {\n\t\t\t\t\t\tlast_x = k;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ts_src += tile_row[nt]->bytes_per_line;\n\t\ts_dst += main_bytes_per_line;\n\t}\n\n\t/* record all the info in the region array for this tile: */\n\tfor (t=1; t <= nt; t++) {\n\t\tint s = t - 1;\n\n\t\tif (first_line[t] == -1) {\n\t\t\t/* tile unchanged */\n\t\t\tcontinue;\n\t\t}\n\t\ttile_region[n+s].first_line = first_line[t];\n\t\ttile_region[n+s].last_line  = last_line[t];\n\n\t\ttile_region[n+s].first_x = first_x;\n\t\ttile_region[n+s].last_x  = last_x;\n\n\t\ttile_region[n+s].top_diff = 0;\n\t\ttile_region[n+s].bot_diff = 0;\n\t\tif ( first_line[t] < tile_fuzz ) {\n\t\t\ttile_region[n+s].top_diff = 1;\n\t\t}\n\t\tif ( last_line[t] > (size_y - 1) - tile_fuzz ) {\n\t\t\ttile_region[n+s].bot_diff = 1;\n\t\t}\n\n\t\ttile_region[n+s].left_diff  = left_diff[t];\n\t\ttile_region[n+s].right_diff = right_diff[t];\n\n\t\ttile_copied[n+s] = 1;\n\t}\n\n\treturn(1);\n}",
          "includes": [
            "#include <default8x16.h>",
            "#include \"userinput.h\"",
            "#include \"macosx.h\"",
            "#include \"screen.h\"",
            "#include \"unixpw.h\"",
            "#include \"cleanup.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"8to24.h\"",
            "#include \"win_utils.h\"",
            "#include \"xrandr.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void create_tile_hint(int x, int y, int tw, int th, hint_t *hint);",
            "static void extend_tile_hint(int x, int y, int tw, int th, hint_t *hint);",
            "static void mark_hint(hint_t hint);",
            "static int copy_tiles(int tx, int ty, int nt);",
            "static int island_try(int x, int y, int u, int v, int *run);",
            "static int blackout_line_cmpskip(int n, int x, int y, char *dst, char *src,\n    int w, int pixelsize);",
            "static region_t *tile_region;",
            "static int *first_line = NULL, *last_line = NULL;",
            "static unsigned short *left_diff = NULL, *right_diff = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <default8x16.h>\n#include \"userinput.h\"\n#include \"macosx.h\"\n#include \"screen.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"8to24.h\"\n#include \"win_utils.h\"\n#include \"xrandr.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nstatic void create_tile_hint(int x, int y, int tw, int th, hint_t *hint);\nstatic void extend_tile_hint(int x, int y, int tw, int th, hint_t *hint);\nstatic void mark_hint(hint_t hint);\nstatic int copy_tiles(int tx, int ty, int nt);\nstatic int island_try(int x, int y, int u, int v, int *run);\nstatic int blackout_line_cmpskip(int n, int x, int y, char *dst, char *src,\n    int w, int pixelsize);\nstatic region_t *tile_region;\nstatic int *first_line = NULL, *last_line = NULL;\nstatic unsigned short *left_diff = NULL, *right_diff = NULL;\n\nstatic int copy_tiles(int tx, int ty, int nt) {\n\tint x, y, line;\n\tint size_x, size_y, width1, width2;\n\tint off, len, n, dw, dx, t;\n\tint w1, w2, dx1, dx2;\t/* tmps for normal and short tiles */\n\tint pixelsize = bpp/8;\n\tint first_min, last_max;\n\tint first_x = -1, last_x = -1;\n\tstatic int prev_ntiles_x = -1;\n\n\tchar *src, *dst, *s_src, *s_dst, *m_src, *m_dst;\n\tchar *h_src, *h_dst;\n\tif (unixpw_in_progress) return 0;\n\n\tif (ntiles_x != prev_ntiles_x && first_line != NULL) {\n\t\tfree(first_line);\tfirst_line = NULL;\n\t\tfree(last_line);\tlast_line = NULL;\n\t\tfree(left_diff);\tleft_diff = NULL;\n\t\tfree(right_diff);\tright_diff = NULL;\n\t}\n\n\tif (first_line == NULL) {\n\t\t/* allocate arrays first time in. */\n\t\tint n = ntiles_x + 1;\n\t\trfbLog(\"copy_tiles: allocating first_line at size %d\\n\", n);\n\t\tfirst_line = (int *) malloc((size_t) (n * sizeof(int)));\n\t\tlast_line  = (int *) malloc((size_t) (n * sizeof(int)));\n\t\tleft_diff  = (unsigned short *)\n\t\t\tmalloc((size_t) (n * sizeof(unsigned short)));\n\t\tright_diff = (unsigned short *)\n\t\t\tmalloc((size_t) (n * sizeof(unsigned short)));\n\t}\n\tprev_ntiles_x = ntiles_x;\n\n\tx = tx * tile_x;\n\ty = ty * tile_y;\n\n\tsize_x = dpy_x - x;\n\tif ( size_x > tile_x * nt ) {\n\t\tsize_x = tile_x * nt;\n\t\twidth1 = tile_x;\n\t\twidth2 = tile_x;\n\t} else {\n\t\t/* short tile */\n\t\twidth1 = tile_x;\t/* internal tile */\n\t\twidth2 = size_x - (nt - 1) * tile_x;\t/* right hand tile */\n\t}\n\n\tsize_y = dpy_y - y;\n\tif ( size_y > tile_y ) {\n\t\tsize_y = tile_y;\n\t}\n\n\tn = tx + ty * ntiles_x;\t\t/* number of the first tile */\n\n\tif (blackouts && tile_blackout[n].cover == 2) {\n\t\t/*\n\t\t * If there are blackouts and this tile is completely covered\n\t\t * no need to poll screen or do anything else..\n\t\t * n.b. we are in single copy_tile mode: nt=1\n\t\t */\n\t\ttile_has_diff[n] = 0;\n\t\treturn(0);\n\t}\n\n\tX_LOCK;\n\tXRANDR_SET_TRAP_RET(-1, \"copy_tile-set\");\n\t/* read in the whole tile run at once: */\n\tcopy_image(tile_row[nt], x, y, size_x, size_y);\n\tXRANDR_CHK_TRAP_RET(-1, \"copy_tile-chk\");\n\n\n\tX_UNLOCK;\n\n\tif (blackouts && tile_blackout[n].cover == 1) {\n\t\t/*\n\t\t * If there are blackouts and this tile is partially covered\n\t\t * we should re-black-out the portion.\n\t\t * n.b. we are in single copy_tile mode: nt=1\n\t\t */\n\t\tint x1, x2, y1, y2, b;\n\t\tint w, s, fill = 0;\n\n\t\tfor (b=0; b < tile_blackout[n].count; b++) {\n\t\t\tchar *b_dst = tile_row[nt]->data;\n\t\t\t\n\t\t\tx1 = tile_blackout[n].bo[b].x1 - x;\n\t\t\ty1 = tile_blackout[n].bo[b].y1 - y;\n\t\t\tx2 = tile_blackout[n].bo[b].x2 - x;\n\t\t\ty2 = tile_blackout[n].bo[b].y2 - y;\n\n\t\t\tw = (x2 - x1) * pixelsize;\n\t\t\ts = x1 * pixelsize;\n\n\t\t\tfor (line = 0; line < size_y; line++) {\n\t\t\t\tif (y1 <= line && line < y2) {\n\t\t\t\t\tmemset(b_dst + s, fill, (size_t) w);\n\t\t\t\t}\n\t\t\t\tb_dst += tile_row[nt]->bytes_per_line;\n\t\t\t}\n\t\t}\n\t}\n\n\tsrc = tile_row[nt]->data;\n\tdst = main_fb + y * main_bytes_per_line + x * pixelsize;\n\n\ts_src = src;\n\ts_dst = dst;\n\n\tfor (t=1; t <= nt; t++) {\n\t\tfirst_line[t] = -1;\n\t}\n\n\t/* find the first line with difference: */\n\tw1 = width1 * pixelsize;\n\tw2 = width2 * pixelsize;\n\n\t/* foreach line: */\n\tfor (line = 0; line < size_y; line++) {\n\t\t/* foreach horizontal tile: */\n\t\tfor (t=1; t <= nt; t++) {\n\t\t\tif (first_line[t] != -1) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\toff = (t-1) * w1;\n\t\t\tif (t == nt) {\n\t\t\t\tlen = w2;\t/* possible short tile */\n\t\t\t} else {\n\t\t\t\tlen = w1;\n\t\t\t}\n\t\t\t\n\t\t\tif (memcmp(s_dst + off, s_src + off, len)) {\n\t\t\t\tfirst_line[t] = line;\n\t\t\t}\n\t\t}\n\t\ts_src += tile_row[nt]->bytes_per_line;\n\t\ts_dst += main_bytes_per_line;\n\t}\n\n\t/* see if there were any differences for any tile: */\n\tfirst_min = -1;\n\tfor (t=1; t <= nt; t++) {\n\t\ttile_tried[n+(t-1)] = 1;\n\t\tif (first_line[t] != -1) {\n\t\t\tif (first_min == -1 || first_line[t] < first_min) {\n\t\t\t\tfirst_min = first_line[t];\n\t\t\t}\n\t\t}\n\t}\n\tif (first_min == -1) {\n\t\t/* no tile has a difference, note this and get out: */\n\t\tfor (t=1; t <= nt; t++) {\n\t\t\ttile_has_diff[n+(t-1)] = 0;\n\t\t}\n\t\treturn(0);\n\t} else {\n\t\t/*\n\t\t * at least one tile has a difference.  make sure info\n\t\t * is recorded (e.g. sometimes we guess tiles and they\n\t\t * came in with tile_has_diff 0)\n\t\t */\n\t\tfor (t=1; t <= nt; t++) {\n\t\t\tif (first_line[t] == -1) {\n\t\t\t\ttile_has_diff[n+(t-1)] = 0;\n\t\t\t} else {\n\t\t\t\ttile_has_diff[n+(t-1)] = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tm_src = src + (tile_row[nt]->bytes_per_line * size_y);\n\tm_dst = dst + (main_bytes_per_line * size_y);\n\n\tfor (t=1; t <= nt; t++) {\n\t\tlast_line[t] = first_line[t];\n\t}\n\n\t/* find the last line with difference: */\n\tw1 = width1 * pixelsize;\n\tw2 = width2 * pixelsize;\n\n\t/* foreach line: */\n\tfor (line = size_y - 1; line > first_min; line--) {\n\n\t\tm_src -= tile_row[nt]->bytes_per_line;\n\t\tm_dst -= main_bytes_per_line;\n\n\t\t/* foreach tile: */\n\t\tfor (t=1; t <= nt; t++) {\n\t\t\tif (first_line[t] == -1\n\t\t\t    || last_line[t] != first_line[t]) {\n\t\t\t\t/* tile has no changes or already done */\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\toff = (t-1) * w1;\n\t\t\tif (t == nt) {\n\t\t\t\tlen = w2;\t/* possible short tile */\n\t\t\t} else {\n\t\t\t\tlen = w1;\n\t\t\t}\n\t\t\tif (memcmp(m_dst + off, m_src + off, len)) {\n\t\t\t\tlast_line[t] = line;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/*\n\t * determine the farthest down last changed line\n\t * will be used below to limit our memcpy() to the framebuffer.\n\t */\n\tlast_max = -1;\n\tfor (t=1; t <= nt; t++) {\n\t\tif (first_line[t] == -1) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (last_max == -1 || last_line[t] > last_max) {\n\t\t\tlast_max = last_line[t];\n\t\t}\n\t}\n\n\t/* look for differences on left and right hand edges: */\n\tfor (t=1; t <= nt; t++) {\n\t\tleft_diff[t] = 0;\n\t\tright_diff[t] = 0;\n\t}\n\n\th_src = src;\n\th_dst = dst;\n\n\tw1 = width1 * pixelsize;\n\tw2 = width2 * pixelsize;\n\n\tdx1 = (width1 - tile_fuzz) * pixelsize;\n\tdx2 = (width2 - tile_fuzz) * pixelsize;\n\tdw = tile_fuzz * pixelsize; \n\n\t/* foreach line: */\n\tfor (line = 0; line < size_y; line++) {\n\t\t/* foreach tile: */\n\t\tfor (t=1; t <= nt; t++) {\n\t\t\tif (first_line[t] == -1) {\n\t\t\t\t/* tile has no changes at all */\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\toff = (t-1) * w1;\n\t\t\tif (t == nt) {\n\t\t\t\tdx = dx2;\t/* possible short tile */\n\t\t\t\tif (dx <= 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdx = dx1;\n\t\t\t}\n\n\t\t\tif (! left_diff[t] && memcmp(h_dst + off,\n\t\t\t    h_src + off, dw)) {\n\t\t\t\tleft_diff[t] = 1;\n\t\t\t}\n\t\t\tif (! right_diff[t] && memcmp(h_dst + off + dx,\n\t\t\t    h_src + off + dx, dw) ) {\n\t\t\t\tright_diff[t] = 1;\n\t\t\t}\n\t\t}\n\t\th_src += tile_row[nt]->bytes_per_line;\n\t\th_dst += main_bytes_per_line;\n\t}\n\n\t/* now finally copy the difference to the rfb framebuffer: */\n\ts_src = src + tile_row[nt]->bytes_per_line * first_min;\n\ts_dst = dst + main_bytes_per_line * first_min;\n\n\tfor (line = first_min; line <= last_max; line++) {\n\t\t/* for I/O speed we do not do this tile by tile */\n\t\tmemcpy(s_dst, s_src, size_x * pixelsize);\n\t\tif (nt == 1) {\n\t\t\t/*\n\t\t\t * optimization for tall skinny lines, e.g. wm\n\t\t\t * frame. try to find first_x and last_x to limit\n\t\t\t * the size of the hint.  could help for a slow\n\t\t\t * link.  Unfortunately we spent a lot of time\n\t\t\t * reading in the many tiles.\n\t\t\t *\n\t\t\t * BTW, we like to think the above memcpy leaves\n\t\t\t * the data we use below in the cache... (but\n\t\t\t * it could be two 128 byte segments at 32bpp)\n\t\t\t * so this inner loop is not as bad as it seems.\n\t\t\t */\n\t\t\tint k, kx;\n\t\t\tkx = pixelsize;\n\t\t\tfor (k=0; k<size_x; k++) {\n\t\t\t\tif (memcmp(s_dst + k*kx, s_src + k*kx, kx))  {\n\t\t\t\t\tif (first_x == -1 || k < first_x) {\n\t\t\t\t\t\tfirst_x = k;\n\t\t\t\t\t}\n\t\t\t\t\tif (last_x == -1 || k > last_x) {\n\t\t\t\t\t\tlast_x = k;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ts_src += tile_row[nt]->bytes_per_line;\n\t\ts_dst += main_bytes_per_line;\n\t}\n\n\t/* record all the info in the region array for this tile: */\n\tfor (t=1; t <= nt; t++) {\n\t\tint s = t - 1;\n\n\t\tif (first_line[t] == -1) {\n\t\t\t/* tile unchanged */\n\t\t\tcontinue;\n\t\t}\n\t\ttile_region[n+s].first_line = first_line[t];\n\t\ttile_region[n+s].last_line  = last_line[t];\n\n\t\ttile_region[n+s].first_x = first_x;\n\t\ttile_region[n+s].last_x  = last_x;\n\n\t\ttile_region[n+s].top_diff = 0;\n\t\ttile_region[n+s].bot_diff = 0;\n\t\tif ( first_line[t] < tile_fuzz ) {\n\t\t\ttile_region[n+s].top_diff = 1;\n\t\t}\n\t\tif ( last_line[t] > (size_y - 1) - tile_fuzz ) {\n\t\t\ttile_region[n+s].bot_diff = 1;\n\t\t}\n\n\t\ttile_region[n+s].left_diff  = left_diff[t];\n\t\ttile_region[n+s].right_diff = right_diff[t];\n\n\t\ttile_copied[n+s] = 1;\n\t}\n\n\treturn(1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <default8x16.h>\n#include \"userinput.h\"\n#include \"macosx.h\"\n#include \"screen.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"8to24.h\"\n#include \"win_utils.h\"\n#include \"xrandr.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nstatic int copy_tiles_additional_pass(void);\n\nstatic int copy_tiles_additional_pass(void) {\n\tint x, y, n;\n\tint diffs = 0, ct;\n\n\tif (unixpw_in_progress) return 0;\n\n\tfor (y=0; y < ntiles_y; y++) {\n\t\tfor (x=0; x < ntiles_x; x++) {\n\t\t\tn = x + y * ntiles_x;\t\t/* number of this tile */\n\n\t\t\tif (! tile_has_diff[n]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (tile_copied[n]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tct = copy_tiles(x, y, 1);\n\t\t\tif (ct < 0) return ct;\t/* fatal */\n\t\t}\n\t}\n\tfor (n=0; n < ntiles; n++) {\n\t\tif (tile_has_diff[n]) {\n\t\t\tdiffs++;\n\t\t}\n\t}\n\treturn diffs;\n}"
  },
  {
    "function_name": "copy_tiles_backward_pass",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/scan.c",
    "lines": "2180-2221",
    "snippet": "static int copy_tiles_backward_pass(void) {\n\tint x, y, n, m;\n\tint diffs = 0, ct;\n\n\tif (unixpw_in_progress) return 0;\n\n\tfor (y = ntiles_y - 1; y >= 0; y--) {\n\t    for (x = ntiles_x - 1; x >= 0; x--) {\n\t\tn = x + y * ntiles_x;\t\t/* number of this tile */\n\n\t\tif (! tile_has_diff[n]) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tm = x + (y-1) * ntiles_x;\t/* neighboring tile upward */\n\n\t\tif (y >= 1 && ! tile_has_diff[m] && tile_region[n].top_diff) {\n\t\t\tif (! tile_tried[m]) {\n\t\t\t\ttile_has_diff[m] = 2;\n\t\t\t\tct = copy_tiles(x, y-1, 1);\n\t\t\t\tif (ct < 0) return ct;\t/* fatal */\n\t\t\t}\n\t\t}\n\n\t\tm = (x-1) + y * ntiles_x;\t/* neighboring tile to left */\n\n\t\tif (x >= 1 && ! tile_has_diff[m] && tile_region[n].left_diff) {\n\t\t\tif (! tile_tried[m]) {\n\t\t\t\ttile_has_diff[m] = 2;\n\t\t\t\tct = copy_tiles(x-1, y, 1);\n\t\t\t\tif (ct < 0) return ct;\t/* fatal */\n\t\t\t}\n\t\t}\n\t    }\n\t}\n\tfor (n=0; n < ntiles; n++) {\n\t\tif (tile_has_diff[n]) {\n\t\t\tdiffs++;\n\t\t}\n\t}\n\treturn diffs;\n}",
    "includes": [
      "#include <default8x16.h>",
      "#include \"userinput.h\"",
      "#include \"macosx.h\"",
      "#include \"screen.h\"",
      "#include \"unixpw.h\"",
      "#include \"cleanup.h\"",
      "#include \"pointer.h\"",
      "#include \"screen.h\"",
      "#include \"8to24.h\"",
      "#include \"win_utils.h\"",
      "#include \"xrandr.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"xinerama.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int copy_tiles_backward_pass(void);",
      "static region_t *tile_region;",
      "static unsigned short *left_diff = NULL, *right_diff = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_tiles",
          "args": [
            "x-1",
            "y",
            "1"
          ],
          "line": 2209
        },
        "resolved": true,
        "details": {
          "function_name": "copy_tiles",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/scan.c",
          "lines": "1708-2045",
          "snippet": "static int copy_tiles(int tx, int ty, int nt) {\n\tint x, y, line;\n\tint size_x, size_y, width1, width2;\n\tint off, len, n, dw, dx, t;\n\tint w1, w2, dx1, dx2;\t/* tmps for normal and short tiles */\n\tint pixelsize = bpp/8;\n\tint first_min, last_max;\n\tint first_x = -1, last_x = -1;\n\tstatic int prev_ntiles_x = -1;\n\n\tchar *src, *dst, *s_src, *s_dst, *m_src, *m_dst;\n\tchar *h_src, *h_dst;\n\tif (unixpw_in_progress) return 0;\n\n\tif (ntiles_x != prev_ntiles_x && first_line != NULL) {\n\t\tfree(first_line);\tfirst_line = NULL;\n\t\tfree(last_line);\tlast_line = NULL;\n\t\tfree(left_diff);\tleft_diff = NULL;\n\t\tfree(right_diff);\tright_diff = NULL;\n\t}\n\n\tif (first_line == NULL) {\n\t\t/* allocate arrays first time in. */\n\t\tint n = ntiles_x + 1;\n\t\trfbLog(\"copy_tiles: allocating first_line at size %d\\n\", n);\n\t\tfirst_line = (int *) malloc((size_t) (n * sizeof(int)));\n\t\tlast_line  = (int *) malloc((size_t) (n * sizeof(int)));\n\t\tleft_diff  = (unsigned short *)\n\t\t\tmalloc((size_t) (n * sizeof(unsigned short)));\n\t\tright_diff = (unsigned short *)\n\t\t\tmalloc((size_t) (n * sizeof(unsigned short)));\n\t}\n\tprev_ntiles_x = ntiles_x;\n\n\tx = tx * tile_x;\n\ty = ty * tile_y;\n\n\tsize_x = dpy_x - x;\n\tif ( size_x > tile_x * nt ) {\n\t\tsize_x = tile_x * nt;\n\t\twidth1 = tile_x;\n\t\twidth2 = tile_x;\n\t} else {\n\t\t/* short tile */\n\t\twidth1 = tile_x;\t/* internal tile */\n\t\twidth2 = size_x - (nt - 1) * tile_x;\t/* right hand tile */\n\t}\n\n\tsize_y = dpy_y - y;\n\tif ( size_y > tile_y ) {\n\t\tsize_y = tile_y;\n\t}\n\n\tn = tx + ty * ntiles_x;\t\t/* number of the first tile */\n\n\tif (blackouts && tile_blackout[n].cover == 2) {\n\t\t/*\n\t\t * If there are blackouts and this tile is completely covered\n\t\t * no need to poll screen or do anything else..\n\t\t * n.b. we are in single copy_tile mode: nt=1\n\t\t */\n\t\ttile_has_diff[n] = 0;\n\t\treturn(0);\n\t}\n\n\tX_LOCK;\n\tXRANDR_SET_TRAP_RET(-1, \"copy_tile-set\");\n\t/* read in the whole tile run at once: */\n\tcopy_image(tile_row[nt], x, y, size_x, size_y);\n\tXRANDR_CHK_TRAP_RET(-1, \"copy_tile-chk\");\n\n\n\tX_UNLOCK;\n\n\tif (blackouts && tile_blackout[n].cover == 1) {\n\t\t/*\n\t\t * If there are blackouts and this tile is partially covered\n\t\t * we should re-black-out the portion.\n\t\t * n.b. we are in single copy_tile mode: nt=1\n\t\t */\n\t\tint x1, x2, y1, y2, b;\n\t\tint w, s, fill = 0;\n\n\t\tfor (b=0; b < tile_blackout[n].count; b++) {\n\t\t\tchar *b_dst = tile_row[nt]->data;\n\t\t\t\n\t\t\tx1 = tile_blackout[n].bo[b].x1 - x;\n\t\t\ty1 = tile_blackout[n].bo[b].y1 - y;\n\t\t\tx2 = tile_blackout[n].bo[b].x2 - x;\n\t\t\ty2 = tile_blackout[n].bo[b].y2 - y;\n\n\t\t\tw = (x2 - x1) * pixelsize;\n\t\t\ts = x1 * pixelsize;\n\n\t\t\tfor (line = 0; line < size_y; line++) {\n\t\t\t\tif (y1 <= line && line < y2) {\n\t\t\t\t\tmemset(b_dst + s, fill, (size_t) w);\n\t\t\t\t}\n\t\t\t\tb_dst += tile_row[nt]->bytes_per_line;\n\t\t\t}\n\t\t}\n\t}\n\n\tsrc = tile_row[nt]->data;\n\tdst = main_fb + y * main_bytes_per_line + x * pixelsize;\n\n\ts_src = src;\n\ts_dst = dst;\n\n\tfor (t=1; t <= nt; t++) {\n\t\tfirst_line[t] = -1;\n\t}\n\n\t/* find the first line with difference: */\n\tw1 = width1 * pixelsize;\n\tw2 = width2 * pixelsize;\n\n\t/* foreach line: */\n\tfor (line = 0; line < size_y; line++) {\n\t\t/* foreach horizontal tile: */\n\t\tfor (t=1; t <= nt; t++) {\n\t\t\tif (first_line[t] != -1) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\toff = (t-1) * w1;\n\t\t\tif (t == nt) {\n\t\t\t\tlen = w2;\t/* possible short tile */\n\t\t\t} else {\n\t\t\t\tlen = w1;\n\t\t\t}\n\t\t\t\n\t\t\tif (memcmp(s_dst + off, s_src + off, len)) {\n\t\t\t\tfirst_line[t] = line;\n\t\t\t}\n\t\t}\n\t\ts_src += tile_row[nt]->bytes_per_line;\n\t\ts_dst += main_bytes_per_line;\n\t}\n\n\t/* see if there were any differences for any tile: */\n\tfirst_min = -1;\n\tfor (t=1; t <= nt; t++) {\n\t\ttile_tried[n+(t-1)] = 1;\n\t\tif (first_line[t] != -1) {\n\t\t\tif (first_min == -1 || first_line[t] < first_min) {\n\t\t\t\tfirst_min = first_line[t];\n\t\t\t}\n\t\t}\n\t}\n\tif (first_min == -1) {\n\t\t/* no tile has a difference, note this and get out: */\n\t\tfor (t=1; t <= nt; t++) {\n\t\t\ttile_has_diff[n+(t-1)] = 0;\n\t\t}\n\t\treturn(0);\n\t} else {\n\t\t/*\n\t\t * at least one tile has a difference.  make sure info\n\t\t * is recorded (e.g. sometimes we guess tiles and they\n\t\t * came in with tile_has_diff 0)\n\t\t */\n\t\tfor (t=1; t <= nt; t++) {\n\t\t\tif (first_line[t] == -1) {\n\t\t\t\ttile_has_diff[n+(t-1)] = 0;\n\t\t\t} else {\n\t\t\t\ttile_has_diff[n+(t-1)] = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tm_src = src + (tile_row[nt]->bytes_per_line * size_y);\n\tm_dst = dst + (main_bytes_per_line * size_y);\n\n\tfor (t=1; t <= nt; t++) {\n\t\tlast_line[t] = first_line[t];\n\t}\n\n\t/* find the last line with difference: */\n\tw1 = width1 * pixelsize;\n\tw2 = width2 * pixelsize;\n\n\t/* foreach line: */\n\tfor (line = size_y - 1; line > first_min; line--) {\n\n\t\tm_src -= tile_row[nt]->bytes_per_line;\n\t\tm_dst -= main_bytes_per_line;\n\n\t\t/* foreach tile: */\n\t\tfor (t=1; t <= nt; t++) {\n\t\t\tif (first_line[t] == -1\n\t\t\t    || last_line[t] != first_line[t]) {\n\t\t\t\t/* tile has no changes or already done */\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\toff = (t-1) * w1;\n\t\t\tif (t == nt) {\n\t\t\t\tlen = w2;\t/* possible short tile */\n\t\t\t} else {\n\t\t\t\tlen = w1;\n\t\t\t}\n\t\t\tif (memcmp(m_dst + off, m_src + off, len)) {\n\t\t\t\tlast_line[t] = line;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/*\n\t * determine the farthest down last changed line\n\t * will be used below to limit our memcpy() to the framebuffer.\n\t */\n\tlast_max = -1;\n\tfor (t=1; t <= nt; t++) {\n\t\tif (first_line[t] == -1) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (last_max == -1 || last_line[t] > last_max) {\n\t\t\tlast_max = last_line[t];\n\t\t}\n\t}\n\n\t/* look for differences on left and right hand edges: */\n\tfor (t=1; t <= nt; t++) {\n\t\tleft_diff[t] = 0;\n\t\tright_diff[t] = 0;\n\t}\n\n\th_src = src;\n\th_dst = dst;\n\n\tw1 = width1 * pixelsize;\n\tw2 = width2 * pixelsize;\n\n\tdx1 = (width1 - tile_fuzz) * pixelsize;\n\tdx2 = (width2 - tile_fuzz) * pixelsize;\n\tdw = tile_fuzz * pixelsize; \n\n\t/* foreach line: */\n\tfor (line = 0; line < size_y; line++) {\n\t\t/* foreach tile: */\n\t\tfor (t=1; t <= nt; t++) {\n\t\t\tif (first_line[t] == -1) {\n\t\t\t\t/* tile has no changes at all */\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\toff = (t-1) * w1;\n\t\t\tif (t == nt) {\n\t\t\t\tdx = dx2;\t/* possible short tile */\n\t\t\t\tif (dx <= 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdx = dx1;\n\t\t\t}\n\n\t\t\tif (! left_diff[t] && memcmp(h_dst + off,\n\t\t\t    h_src + off, dw)) {\n\t\t\t\tleft_diff[t] = 1;\n\t\t\t}\n\t\t\tif (! right_diff[t] && memcmp(h_dst + off + dx,\n\t\t\t    h_src + off + dx, dw) ) {\n\t\t\t\tright_diff[t] = 1;\n\t\t\t}\n\t\t}\n\t\th_src += tile_row[nt]->bytes_per_line;\n\t\th_dst += main_bytes_per_line;\n\t}\n\n\t/* now finally copy the difference to the rfb framebuffer: */\n\ts_src = src + tile_row[nt]->bytes_per_line * first_min;\n\ts_dst = dst + main_bytes_per_line * first_min;\n\n\tfor (line = first_min; line <= last_max; line++) {\n\t\t/* for I/O speed we do not do this tile by tile */\n\t\tmemcpy(s_dst, s_src, size_x * pixelsize);\n\t\tif (nt == 1) {\n\t\t\t/*\n\t\t\t * optimization for tall skinny lines, e.g. wm\n\t\t\t * frame. try to find first_x and last_x to limit\n\t\t\t * the size of the hint.  could help for a slow\n\t\t\t * link.  Unfortunately we spent a lot of time\n\t\t\t * reading in the many tiles.\n\t\t\t *\n\t\t\t * BTW, we like to think the above memcpy leaves\n\t\t\t * the data we use below in the cache... (but\n\t\t\t * it could be two 128 byte segments at 32bpp)\n\t\t\t * so this inner loop is not as bad as it seems.\n\t\t\t */\n\t\t\tint k, kx;\n\t\t\tkx = pixelsize;\n\t\t\tfor (k=0; k<size_x; k++) {\n\t\t\t\tif (memcmp(s_dst + k*kx, s_src + k*kx, kx))  {\n\t\t\t\t\tif (first_x == -1 || k < first_x) {\n\t\t\t\t\t\tfirst_x = k;\n\t\t\t\t\t}\n\t\t\t\t\tif (last_x == -1 || k > last_x) {\n\t\t\t\t\t\tlast_x = k;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ts_src += tile_row[nt]->bytes_per_line;\n\t\ts_dst += main_bytes_per_line;\n\t}\n\n\t/* record all the info in the region array for this tile: */\n\tfor (t=1; t <= nt; t++) {\n\t\tint s = t - 1;\n\n\t\tif (first_line[t] == -1) {\n\t\t\t/* tile unchanged */\n\t\t\tcontinue;\n\t\t}\n\t\ttile_region[n+s].first_line = first_line[t];\n\t\ttile_region[n+s].last_line  = last_line[t];\n\n\t\ttile_region[n+s].first_x = first_x;\n\t\ttile_region[n+s].last_x  = last_x;\n\n\t\ttile_region[n+s].top_diff = 0;\n\t\ttile_region[n+s].bot_diff = 0;\n\t\tif ( first_line[t] < tile_fuzz ) {\n\t\t\ttile_region[n+s].top_diff = 1;\n\t\t}\n\t\tif ( last_line[t] > (size_y - 1) - tile_fuzz ) {\n\t\t\ttile_region[n+s].bot_diff = 1;\n\t\t}\n\n\t\ttile_region[n+s].left_diff  = left_diff[t];\n\t\ttile_region[n+s].right_diff = right_diff[t];\n\n\t\ttile_copied[n+s] = 1;\n\t}\n\n\treturn(1);\n}",
          "includes": [
            "#include <default8x16.h>",
            "#include \"userinput.h\"",
            "#include \"macosx.h\"",
            "#include \"screen.h\"",
            "#include \"unixpw.h\"",
            "#include \"cleanup.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"8to24.h\"",
            "#include \"win_utils.h\"",
            "#include \"xrandr.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void create_tile_hint(int x, int y, int tw, int th, hint_t *hint);",
            "static void extend_tile_hint(int x, int y, int tw, int th, hint_t *hint);",
            "static void mark_hint(hint_t hint);",
            "static int copy_tiles(int tx, int ty, int nt);",
            "static int island_try(int x, int y, int u, int v, int *run);",
            "static int blackout_line_cmpskip(int n, int x, int y, char *dst, char *src,\n    int w, int pixelsize);",
            "static region_t *tile_region;",
            "static int *first_line = NULL, *last_line = NULL;",
            "static unsigned short *left_diff = NULL, *right_diff = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <default8x16.h>\n#include \"userinput.h\"\n#include \"macosx.h\"\n#include \"screen.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"8to24.h\"\n#include \"win_utils.h\"\n#include \"xrandr.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nstatic void create_tile_hint(int x, int y, int tw, int th, hint_t *hint);\nstatic void extend_tile_hint(int x, int y, int tw, int th, hint_t *hint);\nstatic void mark_hint(hint_t hint);\nstatic int copy_tiles(int tx, int ty, int nt);\nstatic int island_try(int x, int y, int u, int v, int *run);\nstatic int blackout_line_cmpskip(int n, int x, int y, char *dst, char *src,\n    int w, int pixelsize);\nstatic region_t *tile_region;\nstatic int *first_line = NULL, *last_line = NULL;\nstatic unsigned short *left_diff = NULL, *right_diff = NULL;\n\nstatic int copy_tiles(int tx, int ty, int nt) {\n\tint x, y, line;\n\tint size_x, size_y, width1, width2;\n\tint off, len, n, dw, dx, t;\n\tint w1, w2, dx1, dx2;\t/* tmps for normal and short tiles */\n\tint pixelsize = bpp/8;\n\tint first_min, last_max;\n\tint first_x = -1, last_x = -1;\n\tstatic int prev_ntiles_x = -1;\n\n\tchar *src, *dst, *s_src, *s_dst, *m_src, *m_dst;\n\tchar *h_src, *h_dst;\n\tif (unixpw_in_progress) return 0;\n\n\tif (ntiles_x != prev_ntiles_x && first_line != NULL) {\n\t\tfree(first_line);\tfirst_line = NULL;\n\t\tfree(last_line);\tlast_line = NULL;\n\t\tfree(left_diff);\tleft_diff = NULL;\n\t\tfree(right_diff);\tright_diff = NULL;\n\t}\n\n\tif (first_line == NULL) {\n\t\t/* allocate arrays first time in. */\n\t\tint n = ntiles_x + 1;\n\t\trfbLog(\"copy_tiles: allocating first_line at size %d\\n\", n);\n\t\tfirst_line = (int *) malloc((size_t) (n * sizeof(int)));\n\t\tlast_line  = (int *) malloc((size_t) (n * sizeof(int)));\n\t\tleft_diff  = (unsigned short *)\n\t\t\tmalloc((size_t) (n * sizeof(unsigned short)));\n\t\tright_diff = (unsigned short *)\n\t\t\tmalloc((size_t) (n * sizeof(unsigned short)));\n\t}\n\tprev_ntiles_x = ntiles_x;\n\n\tx = tx * tile_x;\n\ty = ty * tile_y;\n\n\tsize_x = dpy_x - x;\n\tif ( size_x > tile_x * nt ) {\n\t\tsize_x = tile_x * nt;\n\t\twidth1 = tile_x;\n\t\twidth2 = tile_x;\n\t} else {\n\t\t/* short tile */\n\t\twidth1 = tile_x;\t/* internal tile */\n\t\twidth2 = size_x - (nt - 1) * tile_x;\t/* right hand tile */\n\t}\n\n\tsize_y = dpy_y - y;\n\tif ( size_y > tile_y ) {\n\t\tsize_y = tile_y;\n\t}\n\n\tn = tx + ty * ntiles_x;\t\t/* number of the first tile */\n\n\tif (blackouts && tile_blackout[n].cover == 2) {\n\t\t/*\n\t\t * If there are blackouts and this tile is completely covered\n\t\t * no need to poll screen or do anything else..\n\t\t * n.b. we are in single copy_tile mode: nt=1\n\t\t */\n\t\ttile_has_diff[n] = 0;\n\t\treturn(0);\n\t}\n\n\tX_LOCK;\n\tXRANDR_SET_TRAP_RET(-1, \"copy_tile-set\");\n\t/* read in the whole tile run at once: */\n\tcopy_image(tile_row[nt], x, y, size_x, size_y);\n\tXRANDR_CHK_TRAP_RET(-1, \"copy_tile-chk\");\n\n\n\tX_UNLOCK;\n\n\tif (blackouts && tile_blackout[n].cover == 1) {\n\t\t/*\n\t\t * If there are blackouts and this tile is partially covered\n\t\t * we should re-black-out the portion.\n\t\t * n.b. we are in single copy_tile mode: nt=1\n\t\t */\n\t\tint x1, x2, y1, y2, b;\n\t\tint w, s, fill = 0;\n\n\t\tfor (b=0; b < tile_blackout[n].count; b++) {\n\t\t\tchar *b_dst = tile_row[nt]->data;\n\t\t\t\n\t\t\tx1 = tile_blackout[n].bo[b].x1 - x;\n\t\t\ty1 = tile_blackout[n].bo[b].y1 - y;\n\t\t\tx2 = tile_blackout[n].bo[b].x2 - x;\n\t\t\ty2 = tile_blackout[n].bo[b].y2 - y;\n\n\t\t\tw = (x2 - x1) * pixelsize;\n\t\t\ts = x1 * pixelsize;\n\n\t\t\tfor (line = 0; line < size_y; line++) {\n\t\t\t\tif (y1 <= line && line < y2) {\n\t\t\t\t\tmemset(b_dst + s, fill, (size_t) w);\n\t\t\t\t}\n\t\t\t\tb_dst += tile_row[nt]->bytes_per_line;\n\t\t\t}\n\t\t}\n\t}\n\n\tsrc = tile_row[nt]->data;\n\tdst = main_fb + y * main_bytes_per_line + x * pixelsize;\n\n\ts_src = src;\n\ts_dst = dst;\n\n\tfor (t=1; t <= nt; t++) {\n\t\tfirst_line[t] = -1;\n\t}\n\n\t/* find the first line with difference: */\n\tw1 = width1 * pixelsize;\n\tw2 = width2 * pixelsize;\n\n\t/* foreach line: */\n\tfor (line = 0; line < size_y; line++) {\n\t\t/* foreach horizontal tile: */\n\t\tfor (t=1; t <= nt; t++) {\n\t\t\tif (first_line[t] != -1) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\toff = (t-1) * w1;\n\t\t\tif (t == nt) {\n\t\t\t\tlen = w2;\t/* possible short tile */\n\t\t\t} else {\n\t\t\t\tlen = w1;\n\t\t\t}\n\t\t\t\n\t\t\tif (memcmp(s_dst + off, s_src + off, len)) {\n\t\t\t\tfirst_line[t] = line;\n\t\t\t}\n\t\t}\n\t\ts_src += tile_row[nt]->bytes_per_line;\n\t\ts_dst += main_bytes_per_line;\n\t}\n\n\t/* see if there were any differences for any tile: */\n\tfirst_min = -1;\n\tfor (t=1; t <= nt; t++) {\n\t\ttile_tried[n+(t-1)] = 1;\n\t\tif (first_line[t] != -1) {\n\t\t\tif (first_min == -1 || first_line[t] < first_min) {\n\t\t\t\tfirst_min = first_line[t];\n\t\t\t}\n\t\t}\n\t}\n\tif (first_min == -1) {\n\t\t/* no tile has a difference, note this and get out: */\n\t\tfor (t=1; t <= nt; t++) {\n\t\t\ttile_has_diff[n+(t-1)] = 0;\n\t\t}\n\t\treturn(0);\n\t} else {\n\t\t/*\n\t\t * at least one tile has a difference.  make sure info\n\t\t * is recorded (e.g. sometimes we guess tiles and they\n\t\t * came in with tile_has_diff 0)\n\t\t */\n\t\tfor (t=1; t <= nt; t++) {\n\t\t\tif (first_line[t] == -1) {\n\t\t\t\ttile_has_diff[n+(t-1)] = 0;\n\t\t\t} else {\n\t\t\t\ttile_has_diff[n+(t-1)] = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tm_src = src + (tile_row[nt]->bytes_per_line * size_y);\n\tm_dst = dst + (main_bytes_per_line * size_y);\n\n\tfor (t=1; t <= nt; t++) {\n\t\tlast_line[t] = first_line[t];\n\t}\n\n\t/* find the last line with difference: */\n\tw1 = width1 * pixelsize;\n\tw2 = width2 * pixelsize;\n\n\t/* foreach line: */\n\tfor (line = size_y - 1; line > first_min; line--) {\n\n\t\tm_src -= tile_row[nt]->bytes_per_line;\n\t\tm_dst -= main_bytes_per_line;\n\n\t\t/* foreach tile: */\n\t\tfor (t=1; t <= nt; t++) {\n\t\t\tif (first_line[t] == -1\n\t\t\t    || last_line[t] != first_line[t]) {\n\t\t\t\t/* tile has no changes or already done */\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\toff = (t-1) * w1;\n\t\t\tif (t == nt) {\n\t\t\t\tlen = w2;\t/* possible short tile */\n\t\t\t} else {\n\t\t\t\tlen = w1;\n\t\t\t}\n\t\t\tif (memcmp(m_dst + off, m_src + off, len)) {\n\t\t\t\tlast_line[t] = line;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/*\n\t * determine the farthest down last changed line\n\t * will be used below to limit our memcpy() to the framebuffer.\n\t */\n\tlast_max = -1;\n\tfor (t=1; t <= nt; t++) {\n\t\tif (first_line[t] == -1) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (last_max == -1 || last_line[t] > last_max) {\n\t\t\tlast_max = last_line[t];\n\t\t}\n\t}\n\n\t/* look for differences on left and right hand edges: */\n\tfor (t=1; t <= nt; t++) {\n\t\tleft_diff[t] = 0;\n\t\tright_diff[t] = 0;\n\t}\n\n\th_src = src;\n\th_dst = dst;\n\n\tw1 = width1 * pixelsize;\n\tw2 = width2 * pixelsize;\n\n\tdx1 = (width1 - tile_fuzz) * pixelsize;\n\tdx2 = (width2 - tile_fuzz) * pixelsize;\n\tdw = tile_fuzz * pixelsize; \n\n\t/* foreach line: */\n\tfor (line = 0; line < size_y; line++) {\n\t\t/* foreach tile: */\n\t\tfor (t=1; t <= nt; t++) {\n\t\t\tif (first_line[t] == -1) {\n\t\t\t\t/* tile has no changes at all */\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\toff = (t-1) * w1;\n\t\t\tif (t == nt) {\n\t\t\t\tdx = dx2;\t/* possible short tile */\n\t\t\t\tif (dx <= 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdx = dx1;\n\t\t\t}\n\n\t\t\tif (! left_diff[t] && memcmp(h_dst + off,\n\t\t\t    h_src + off, dw)) {\n\t\t\t\tleft_diff[t] = 1;\n\t\t\t}\n\t\t\tif (! right_diff[t] && memcmp(h_dst + off + dx,\n\t\t\t    h_src + off + dx, dw) ) {\n\t\t\t\tright_diff[t] = 1;\n\t\t\t}\n\t\t}\n\t\th_src += tile_row[nt]->bytes_per_line;\n\t\th_dst += main_bytes_per_line;\n\t}\n\n\t/* now finally copy the difference to the rfb framebuffer: */\n\ts_src = src + tile_row[nt]->bytes_per_line * first_min;\n\ts_dst = dst + main_bytes_per_line * first_min;\n\n\tfor (line = first_min; line <= last_max; line++) {\n\t\t/* for I/O speed we do not do this tile by tile */\n\t\tmemcpy(s_dst, s_src, size_x * pixelsize);\n\t\tif (nt == 1) {\n\t\t\t/*\n\t\t\t * optimization for tall skinny lines, e.g. wm\n\t\t\t * frame. try to find first_x and last_x to limit\n\t\t\t * the size of the hint.  could help for a slow\n\t\t\t * link.  Unfortunately we spent a lot of time\n\t\t\t * reading in the many tiles.\n\t\t\t *\n\t\t\t * BTW, we like to think the above memcpy leaves\n\t\t\t * the data we use below in the cache... (but\n\t\t\t * it could be two 128 byte segments at 32bpp)\n\t\t\t * so this inner loop is not as bad as it seems.\n\t\t\t */\n\t\t\tint k, kx;\n\t\t\tkx = pixelsize;\n\t\t\tfor (k=0; k<size_x; k++) {\n\t\t\t\tif (memcmp(s_dst + k*kx, s_src + k*kx, kx))  {\n\t\t\t\t\tif (first_x == -1 || k < first_x) {\n\t\t\t\t\t\tfirst_x = k;\n\t\t\t\t\t}\n\t\t\t\t\tif (last_x == -1 || k > last_x) {\n\t\t\t\t\t\tlast_x = k;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ts_src += tile_row[nt]->bytes_per_line;\n\t\ts_dst += main_bytes_per_line;\n\t}\n\n\t/* record all the info in the region array for this tile: */\n\tfor (t=1; t <= nt; t++) {\n\t\tint s = t - 1;\n\n\t\tif (first_line[t] == -1) {\n\t\t\t/* tile unchanged */\n\t\t\tcontinue;\n\t\t}\n\t\ttile_region[n+s].first_line = first_line[t];\n\t\ttile_region[n+s].last_line  = last_line[t];\n\n\t\ttile_region[n+s].first_x = first_x;\n\t\ttile_region[n+s].last_x  = last_x;\n\n\t\ttile_region[n+s].top_diff = 0;\n\t\ttile_region[n+s].bot_diff = 0;\n\t\tif ( first_line[t] < tile_fuzz ) {\n\t\t\ttile_region[n+s].top_diff = 1;\n\t\t}\n\t\tif ( last_line[t] > (size_y - 1) - tile_fuzz ) {\n\t\t\ttile_region[n+s].bot_diff = 1;\n\t\t}\n\n\t\ttile_region[n+s].left_diff  = left_diff[t];\n\t\ttile_region[n+s].right_diff = right_diff[t];\n\n\t\ttile_copied[n+s] = 1;\n\t}\n\n\treturn(1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <default8x16.h>\n#include \"userinput.h\"\n#include \"macosx.h\"\n#include \"screen.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"8to24.h\"\n#include \"win_utils.h\"\n#include \"xrandr.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nstatic int copy_tiles_backward_pass(void);\nstatic region_t *tile_region;\nstatic unsigned short *left_diff = NULL, *right_diff = NULL;\n\nstatic int copy_tiles_backward_pass(void) {\n\tint x, y, n, m;\n\tint diffs = 0, ct;\n\n\tif (unixpw_in_progress) return 0;\n\n\tfor (y = ntiles_y - 1; y >= 0; y--) {\n\t    for (x = ntiles_x - 1; x >= 0; x--) {\n\t\tn = x + y * ntiles_x;\t\t/* number of this tile */\n\n\t\tif (! tile_has_diff[n]) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tm = x + (y-1) * ntiles_x;\t/* neighboring tile upward */\n\n\t\tif (y >= 1 && ! tile_has_diff[m] && tile_region[n].top_diff) {\n\t\t\tif (! tile_tried[m]) {\n\t\t\t\ttile_has_diff[m] = 2;\n\t\t\t\tct = copy_tiles(x, y-1, 1);\n\t\t\t\tif (ct < 0) return ct;\t/* fatal */\n\t\t\t}\n\t\t}\n\n\t\tm = (x-1) + y * ntiles_x;\t/* neighboring tile to left */\n\n\t\tif (x >= 1 && ! tile_has_diff[m] && tile_region[n].left_diff) {\n\t\t\tif (! tile_tried[m]) {\n\t\t\t\ttile_has_diff[m] = 2;\n\t\t\t\tct = copy_tiles(x-1, y, 1);\n\t\t\t\tif (ct < 0) return ct;\t/* fatal */\n\t\t\t}\n\t\t}\n\t    }\n\t}\n\tfor (n=0; n < ntiles; n++) {\n\t\tif (tile_has_diff[n]) {\n\t\t\tdiffs++;\n\t\t}\n\t}\n\treturn diffs;\n}"
  },
  {
    "function_name": "copy_all_tile_runs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/scan.c",
    "lines": "2106-2168",
    "snippet": "static int copy_all_tile_runs(void) {\n\tint x, y, n, m, i;\n\tint diffs = 0, ct;\n\tint in_run = 0, run = 0;\n\tint ntave = 0, ntcnt = 0;\n\n\tif (unixpw_in_progress) return 0;\n\n\tfor (y=0; y < ntiles_y; y++) {\n\t\tfor (x=0; x < ntiles_x + 1; x++) {\n\t\t\tn = x + y * ntiles_x;\n\n\t\t\tif (x != ntiles_x && tile_has_diff[n]) {\n\t\t\t\tin_run = 1;\n\t\t\t\trun++;\n\t\t\t} else {\n\t\t\t\tif (! in_run) {\n\t\t\t\t\tin_run = 0;\n\t\t\t\t\trun = 0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tct = copy_tiles(x - run, y, run);\n\t\t\t\tif (ct < 0) return ct;\t/* fatal */\n\n\t\t\t\tntcnt++;\n\t\t\t\tntave += run;\n\t\t\t\tdiffs += run;\n\n\t\t\t\t/* neighboring tile downward: */\n\t\t\t\tfor (i=1; i <= run; i++) {\n\t\t\t\t\tif ((y+1) < ntiles_y\n\t\t\t\t\t    && tile_region[n-i].bot_diff) {\n\t\t\t\t\t\tm = (x-i) + (y+1) * ntiles_x;\n\t\t\t\t\t\tif (! tile_has_diff[m]) {\n\t\t\t\t\t\t\ttile_has_diff[m] = 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/* neighboring tile to right: */\n\t\t\t\tif (((x-1)+1) < ntiles_x\n\t\t\t\t    && tile_region[n-1].right_diff) {\n\t\t\t\t\tm = ((x-1)+1) + y * ntiles_x;\n\t\t\t\t\tif (! tile_has_diff[m]) {\n\t\t\t\t\t\ttile_has_diff[m] = 2;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t/* note that this starts a new run */\n\t\t\t\t\tin_run = 1;\n\t\t\t\t\trun = 1;\n\t\t\t\t} else {\n\t\t\t\t\tin_run = 0;\n\t\t\t\t\trun = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * Could some activity go here, to emulate threaded\n\t\t * behavior by servicing some libvncserver tasks?\n\t\t */\n\t}\n\treturn diffs;\n}",
    "includes": [
      "#include <default8x16.h>",
      "#include \"userinput.h\"",
      "#include \"macosx.h\"",
      "#include \"screen.h\"",
      "#include \"unixpw.h\"",
      "#include \"cleanup.h\"",
      "#include \"pointer.h\"",
      "#include \"screen.h\"",
      "#include \"8to24.h\"",
      "#include \"win_utils.h\"",
      "#include \"xrandr.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"xinerama.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int copy_all_tile_runs(void);",
      "static int island_try(int x, int y, int u, int v, int *run);",
      "static region_t *tile_region;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_tiles",
          "args": [
            "x - run",
            "y",
            "run"
          ],
          "line": 2127
        },
        "resolved": true,
        "details": {
          "function_name": "copy_tiles",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/scan.c",
          "lines": "1708-2045",
          "snippet": "static int copy_tiles(int tx, int ty, int nt) {\n\tint x, y, line;\n\tint size_x, size_y, width1, width2;\n\tint off, len, n, dw, dx, t;\n\tint w1, w2, dx1, dx2;\t/* tmps for normal and short tiles */\n\tint pixelsize = bpp/8;\n\tint first_min, last_max;\n\tint first_x = -1, last_x = -1;\n\tstatic int prev_ntiles_x = -1;\n\n\tchar *src, *dst, *s_src, *s_dst, *m_src, *m_dst;\n\tchar *h_src, *h_dst;\n\tif (unixpw_in_progress) return 0;\n\n\tif (ntiles_x != prev_ntiles_x && first_line != NULL) {\n\t\tfree(first_line);\tfirst_line = NULL;\n\t\tfree(last_line);\tlast_line = NULL;\n\t\tfree(left_diff);\tleft_diff = NULL;\n\t\tfree(right_diff);\tright_diff = NULL;\n\t}\n\n\tif (first_line == NULL) {\n\t\t/* allocate arrays first time in. */\n\t\tint n = ntiles_x + 1;\n\t\trfbLog(\"copy_tiles: allocating first_line at size %d\\n\", n);\n\t\tfirst_line = (int *) malloc((size_t) (n * sizeof(int)));\n\t\tlast_line  = (int *) malloc((size_t) (n * sizeof(int)));\n\t\tleft_diff  = (unsigned short *)\n\t\t\tmalloc((size_t) (n * sizeof(unsigned short)));\n\t\tright_diff = (unsigned short *)\n\t\t\tmalloc((size_t) (n * sizeof(unsigned short)));\n\t}\n\tprev_ntiles_x = ntiles_x;\n\n\tx = tx * tile_x;\n\ty = ty * tile_y;\n\n\tsize_x = dpy_x - x;\n\tif ( size_x > tile_x * nt ) {\n\t\tsize_x = tile_x * nt;\n\t\twidth1 = tile_x;\n\t\twidth2 = tile_x;\n\t} else {\n\t\t/* short tile */\n\t\twidth1 = tile_x;\t/* internal tile */\n\t\twidth2 = size_x - (nt - 1) * tile_x;\t/* right hand tile */\n\t}\n\n\tsize_y = dpy_y - y;\n\tif ( size_y > tile_y ) {\n\t\tsize_y = tile_y;\n\t}\n\n\tn = tx + ty * ntiles_x;\t\t/* number of the first tile */\n\n\tif (blackouts && tile_blackout[n].cover == 2) {\n\t\t/*\n\t\t * If there are blackouts and this tile is completely covered\n\t\t * no need to poll screen or do anything else..\n\t\t * n.b. we are in single copy_tile mode: nt=1\n\t\t */\n\t\ttile_has_diff[n] = 0;\n\t\treturn(0);\n\t}\n\n\tX_LOCK;\n\tXRANDR_SET_TRAP_RET(-1, \"copy_tile-set\");\n\t/* read in the whole tile run at once: */\n\tcopy_image(tile_row[nt], x, y, size_x, size_y);\n\tXRANDR_CHK_TRAP_RET(-1, \"copy_tile-chk\");\n\n\n\tX_UNLOCK;\n\n\tif (blackouts && tile_blackout[n].cover == 1) {\n\t\t/*\n\t\t * If there are blackouts and this tile is partially covered\n\t\t * we should re-black-out the portion.\n\t\t * n.b. we are in single copy_tile mode: nt=1\n\t\t */\n\t\tint x1, x2, y1, y2, b;\n\t\tint w, s, fill = 0;\n\n\t\tfor (b=0; b < tile_blackout[n].count; b++) {\n\t\t\tchar *b_dst = tile_row[nt]->data;\n\t\t\t\n\t\t\tx1 = tile_blackout[n].bo[b].x1 - x;\n\t\t\ty1 = tile_blackout[n].bo[b].y1 - y;\n\t\t\tx2 = tile_blackout[n].bo[b].x2 - x;\n\t\t\ty2 = tile_blackout[n].bo[b].y2 - y;\n\n\t\t\tw = (x2 - x1) * pixelsize;\n\t\t\ts = x1 * pixelsize;\n\n\t\t\tfor (line = 0; line < size_y; line++) {\n\t\t\t\tif (y1 <= line && line < y2) {\n\t\t\t\t\tmemset(b_dst + s, fill, (size_t) w);\n\t\t\t\t}\n\t\t\t\tb_dst += tile_row[nt]->bytes_per_line;\n\t\t\t}\n\t\t}\n\t}\n\n\tsrc = tile_row[nt]->data;\n\tdst = main_fb + y * main_bytes_per_line + x * pixelsize;\n\n\ts_src = src;\n\ts_dst = dst;\n\n\tfor (t=1; t <= nt; t++) {\n\t\tfirst_line[t] = -1;\n\t}\n\n\t/* find the first line with difference: */\n\tw1 = width1 * pixelsize;\n\tw2 = width2 * pixelsize;\n\n\t/* foreach line: */\n\tfor (line = 0; line < size_y; line++) {\n\t\t/* foreach horizontal tile: */\n\t\tfor (t=1; t <= nt; t++) {\n\t\t\tif (first_line[t] != -1) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\toff = (t-1) * w1;\n\t\t\tif (t == nt) {\n\t\t\t\tlen = w2;\t/* possible short tile */\n\t\t\t} else {\n\t\t\t\tlen = w1;\n\t\t\t}\n\t\t\t\n\t\t\tif (memcmp(s_dst + off, s_src + off, len)) {\n\t\t\t\tfirst_line[t] = line;\n\t\t\t}\n\t\t}\n\t\ts_src += tile_row[nt]->bytes_per_line;\n\t\ts_dst += main_bytes_per_line;\n\t}\n\n\t/* see if there were any differences for any tile: */\n\tfirst_min = -1;\n\tfor (t=1; t <= nt; t++) {\n\t\ttile_tried[n+(t-1)] = 1;\n\t\tif (first_line[t] != -1) {\n\t\t\tif (first_min == -1 || first_line[t] < first_min) {\n\t\t\t\tfirst_min = first_line[t];\n\t\t\t}\n\t\t}\n\t}\n\tif (first_min == -1) {\n\t\t/* no tile has a difference, note this and get out: */\n\t\tfor (t=1; t <= nt; t++) {\n\t\t\ttile_has_diff[n+(t-1)] = 0;\n\t\t}\n\t\treturn(0);\n\t} else {\n\t\t/*\n\t\t * at least one tile has a difference.  make sure info\n\t\t * is recorded (e.g. sometimes we guess tiles and they\n\t\t * came in with tile_has_diff 0)\n\t\t */\n\t\tfor (t=1; t <= nt; t++) {\n\t\t\tif (first_line[t] == -1) {\n\t\t\t\ttile_has_diff[n+(t-1)] = 0;\n\t\t\t} else {\n\t\t\t\ttile_has_diff[n+(t-1)] = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tm_src = src + (tile_row[nt]->bytes_per_line * size_y);\n\tm_dst = dst + (main_bytes_per_line * size_y);\n\n\tfor (t=1; t <= nt; t++) {\n\t\tlast_line[t] = first_line[t];\n\t}\n\n\t/* find the last line with difference: */\n\tw1 = width1 * pixelsize;\n\tw2 = width2 * pixelsize;\n\n\t/* foreach line: */\n\tfor (line = size_y - 1; line > first_min; line--) {\n\n\t\tm_src -= tile_row[nt]->bytes_per_line;\n\t\tm_dst -= main_bytes_per_line;\n\n\t\t/* foreach tile: */\n\t\tfor (t=1; t <= nt; t++) {\n\t\t\tif (first_line[t] == -1\n\t\t\t    || last_line[t] != first_line[t]) {\n\t\t\t\t/* tile has no changes or already done */\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\toff = (t-1) * w1;\n\t\t\tif (t == nt) {\n\t\t\t\tlen = w2;\t/* possible short tile */\n\t\t\t} else {\n\t\t\t\tlen = w1;\n\t\t\t}\n\t\t\tif (memcmp(m_dst + off, m_src + off, len)) {\n\t\t\t\tlast_line[t] = line;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/*\n\t * determine the farthest down last changed line\n\t * will be used below to limit our memcpy() to the framebuffer.\n\t */\n\tlast_max = -1;\n\tfor (t=1; t <= nt; t++) {\n\t\tif (first_line[t] == -1) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (last_max == -1 || last_line[t] > last_max) {\n\t\t\tlast_max = last_line[t];\n\t\t}\n\t}\n\n\t/* look for differences on left and right hand edges: */\n\tfor (t=1; t <= nt; t++) {\n\t\tleft_diff[t] = 0;\n\t\tright_diff[t] = 0;\n\t}\n\n\th_src = src;\n\th_dst = dst;\n\n\tw1 = width1 * pixelsize;\n\tw2 = width2 * pixelsize;\n\n\tdx1 = (width1 - tile_fuzz) * pixelsize;\n\tdx2 = (width2 - tile_fuzz) * pixelsize;\n\tdw = tile_fuzz * pixelsize; \n\n\t/* foreach line: */\n\tfor (line = 0; line < size_y; line++) {\n\t\t/* foreach tile: */\n\t\tfor (t=1; t <= nt; t++) {\n\t\t\tif (first_line[t] == -1) {\n\t\t\t\t/* tile has no changes at all */\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\toff = (t-1) * w1;\n\t\t\tif (t == nt) {\n\t\t\t\tdx = dx2;\t/* possible short tile */\n\t\t\t\tif (dx <= 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdx = dx1;\n\t\t\t}\n\n\t\t\tif (! left_diff[t] && memcmp(h_dst + off,\n\t\t\t    h_src + off, dw)) {\n\t\t\t\tleft_diff[t] = 1;\n\t\t\t}\n\t\t\tif (! right_diff[t] && memcmp(h_dst + off + dx,\n\t\t\t    h_src + off + dx, dw) ) {\n\t\t\t\tright_diff[t] = 1;\n\t\t\t}\n\t\t}\n\t\th_src += tile_row[nt]->bytes_per_line;\n\t\th_dst += main_bytes_per_line;\n\t}\n\n\t/* now finally copy the difference to the rfb framebuffer: */\n\ts_src = src + tile_row[nt]->bytes_per_line * first_min;\n\ts_dst = dst + main_bytes_per_line * first_min;\n\n\tfor (line = first_min; line <= last_max; line++) {\n\t\t/* for I/O speed we do not do this tile by tile */\n\t\tmemcpy(s_dst, s_src, size_x * pixelsize);\n\t\tif (nt == 1) {\n\t\t\t/*\n\t\t\t * optimization for tall skinny lines, e.g. wm\n\t\t\t * frame. try to find first_x and last_x to limit\n\t\t\t * the size of the hint.  could help for a slow\n\t\t\t * link.  Unfortunately we spent a lot of time\n\t\t\t * reading in the many tiles.\n\t\t\t *\n\t\t\t * BTW, we like to think the above memcpy leaves\n\t\t\t * the data we use below in the cache... (but\n\t\t\t * it could be two 128 byte segments at 32bpp)\n\t\t\t * so this inner loop is not as bad as it seems.\n\t\t\t */\n\t\t\tint k, kx;\n\t\t\tkx = pixelsize;\n\t\t\tfor (k=0; k<size_x; k++) {\n\t\t\t\tif (memcmp(s_dst + k*kx, s_src + k*kx, kx))  {\n\t\t\t\t\tif (first_x == -1 || k < first_x) {\n\t\t\t\t\t\tfirst_x = k;\n\t\t\t\t\t}\n\t\t\t\t\tif (last_x == -1 || k > last_x) {\n\t\t\t\t\t\tlast_x = k;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ts_src += tile_row[nt]->bytes_per_line;\n\t\ts_dst += main_bytes_per_line;\n\t}\n\n\t/* record all the info in the region array for this tile: */\n\tfor (t=1; t <= nt; t++) {\n\t\tint s = t - 1;\n\n\t\tif (first_line[t] == -1) {\n\t\t\t/* tile unchanged */\n\t\t\tcontinue;\n\t\t}\n\t\ttile_region[n+s].first_line = first_line[t];\n\t\ttile_region[n+s].last_line  = last_line[t];\n\n\t\ttile_region[n+s].first_x = first_x;\n\t\ttile_region[n+s].last_x  = last_x;\n\n\t\ttile_region[n+s].top_diff = 0;\n\t\ttile_region[n+s].bot_diff = 0;\n\t\tif ( first_line[t] < tile_fuzz ) {\n\t\t\ttile_region[n+s].top_diff = 1;\n\t\t}\n\t\tif ( last_line[t] > (size_y - 1) - tile_fuzz ) {\n\t\t\ttile_region[n+s].bot_diff = 1;\n\t\t}\n\n\t\ttile_region[n+s].left_diff  = left_diff[t];\n\t\ttile_region[n+s].right_diff = right_diff[t];\n\n\t\ttile_copied[n+s] = 1;\n\t}\n\n\treturn(1);\n}",
          "includes": [
            "#include <default8x16.h>",
            "#include \"userinput.h\"",
            "#include \"macosx.h\"",
            "#include \"screen.h\"",
            "#include \"unixpw.h\"",
            "#include \"cleanup.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"8to24.h\"",
            "#include \"win_utils.h\"",
            "#include \"xrandr.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void create_tile_hint(int x, int y, int tw, int th, hint_t *hint);",
            "static void extend_tile_hint(int x, int y, int tw, int th, hint_t *hint);",
            "static void mark_hint(hint_t hint);",
            "static int copy_tiles(int tx, int ty, int nt);",
            "static int island_try(int x, int y, int u, int v, int *run);",
            "static int blackout_line_cmpskip(int n, int x, int y, char *dst, char *src,\n    int w, int pixelsize);",
            "static region_t *tile_region;",
            "static int *first_line = NULL, *last_line = NULL;",
            "static unsigned short *left_diff = NULL, *right_diff = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <default8x16.h>\n#include \"userinput.h\"\n#include \"macosx.h\"\n#include \"screen.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"8to24.h\"\n#include \"win_utils.h\"\n#include \"xrandr.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nstatic void create_tile_hint(int x, int y, int tw, int th, hint_t *hint);\nstatic void extend_tile_hint(int x, int y, int tw, int th, hint_t *hint);\nstatic void mark_hint(hint_t hint);\nstatic int copy_tiles(int tx, int ty, int nt);\nstatic int island_try(int x, int y, int u, int v, int *run);\nstatic int blackout_line_cmpskip(int n, int x, int y, char *dst, char *src,\n    int w, int pixelsize);\nstatic region_t *tile_region;\nstatic int *first_line = NULL, *last_line = NULL;\nstatic unsigned short *left_diff = NULL, *right_diff = NULL;\n\nstatic int copy_tiles(int tx, int ty, int nt) {\n\tint x, y, line;\n\tint size_x, size_y, width1, width2;\n\tint off, len, n, dw, dx, t;\n\tint w1, w2, dx1, dx2;\t/* tmps for normal and short tiles */\n\tint pixelsize = bpp/8;\n\tint first_min, last_max;\n\tint first_x = -1, last_x = -1;\n\tstatic int prev_ntiles_x = -1;\n\n\tchar *src, *dst, *s_src, *s_dst, *m_src, *m_dst;\n\tchar *h_src, *h_dst;\n\tif (unixpw_in_progress) return 0;\n\n\tif (ntiles_x != prev_ntiles_x && first_line != NULL) {\n\t\tfree(first_line);\tfirst_line = NULL;\n\t\tfree(last_line);\tlast_line = NULL;\n\t\tfree(left_diff);\tleft_diff = NULL;\n\t\tfree(right_diff);\tright_diff = NULL;\n\t}\n\n\tif (first_line == NULL) {\n\t\t/* allocate arrays first time in. */\n\t\tint n = ntiles_x + 1;\n\t\trfbLog(\"copy_tiles: allocating first_line at size %d\\n\", n);\n\t\tfirst_line = (int *) malloc((size_t) (n * sizeof(int)));\n\t\tlast_line  = (int *) malloc((size_t) (n * sizeof(int)));\n\t\tleft_diff  = (unsigned short *)\n\t\t\tmalloc((size_t) (n * sizeof(unsigned short)));\n\t\tright_diff = (unsigned short *)\n\t\t\tmalloc((size_t) (n * sizeof(unsigned short)));\n\t}\n\tprev_ntiles_x = ntiles_x;\n\n\tx = tx * tile_x;\n\ty = ty * tile_y;\n\n\tsize_x = dpy_x - x;\n\tif ( size_x > tile_x * nt ) {\n\t\tsize_x = tile_x * nt;\n\t\twidth1 = tile_x;\n\t\twidth2 = tile_x;\n\t} else {\n\t\t/* short tile */\n\t\twidth1 = tile_x;\t/* internal tile */\n\t\twidth2 = size_x - (nt - 1) * tile_x;\t/* right hand tile */\n\t}\n\n\tsize_y = dpy_y - y;\n\tif ( size_y > tile_y ) {\n\t\tsize_y = tile_y;\n\t}\n\n\tn = tx + ty * ntiles_x;\t\t/* number of the first tile */\n\n\tif (blackouts && tile_blackout[n].cover == 2) {\n\t\t/*\n\t\t * If there are blackouts and this tile is completely covered\n\t\t * no need to poll screen or do anything else..\n\t\t * n.b. we are in single copy_tile mode: nt=1\n\t\t */\n\t\ttile_has_diff[n] = 0;\n\t\treturn(0);\n\t}\n\n\tX_LOCK;\n\tXRANDR_SET_TRAP_RET(-1, \"copy_tile-set\");\n\t/* read in the whole tile run at once: */\n\tcopy_image(tile_row[nt], x, y, size_x, size_y);\n\tXRANDR_CHK_TRAP_RET(-1, \"copy_tile-chk\");\n\n\n\tX_UNLOCK;\n\n\tif (blackouts && tile_blackout[n].cover == 1) {\n\t\t/*\n\t\t * If there are blackouts and this tile is partially covered\n\t\t * we should re-black-out the portion.\n\t\t * n.b. we are in single copy_tile mode: nt=1\n\t\t */\n\t\tint x1, x2, y1, y2, b;\n\t\tint w, s, fill = 0;\n\n\t\tfor (b=0; b < tile_blackout[n].count; b++) {\n\t\t\tchar *b_dst = tile_row[nt]->data;\n\t\t\t\n\t\t\tx1 = tile_blackout[n].bo[b].x1 - x;\n\t\t\ty1 = tile_blackout[n].bo[b].y1 - y;\n\t\t\tx2 = tile_blackout[n].bo[b].x2 - x;\n\t\t\ty2 = tile_blackout[n].bo[b].y2 - y;\n\n\t\t\tw = (x2 - x1) * pixelsize;\n\t\t\ts = x1 * pixelsize;\n\n\t\t\tfor (line = 0; line < size_y; line++) {\n\t\t\t\tif (y1 <= line && line < y2) {\n\t\t\t\t\tmemset(b_dst + s, fill, (size_t) w);\n\t\t\t\t}\n\t\t\t\tb_dst += tile_row[nt]->bytes_per_line;\n\t\t\t}\n\t\t}\n\t}\n\n\tsrc = tile_row[nt]->data;\n\tdst = main_fb + y * main_bytes_per_line + x * pixelsize;\n\n\ts_src = src;\n\ts_dst = dst;\n\n\tfor (t=1; t <= nt; t++) {\n\t\tfirst_line[t] = -1;\n\t}\n\n\t/* find the first line with difference: */\n\tw1 = width1 * pixelsize;\n\tw2 = width2 * pixelsize;\n\n\t/* foreach line: */\n\tfor (line = 0; line < size_y; line++) {\n\t\t/* foreach horizontal tile: */\n\t\tfor (t=1; t <= nt; t++) {\n\t\t\tif (first_line[t] != -1) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\toff = (t-1) * w1;\n\t\t\tif (t == nt) {\n\t\t\t\tlen = w2;\t/* possible short tile */\n\t\t\t} else {\n\t\t\t\tlen = w1;\n\t\t\t}\n\t\t\t\n\t\t\tif (memcmp(s_dst + off, s_src + off, len)) {\n\t\t\t\tfirst_line[t] = line;\n\t\t\t}\n\t\t}\n\t\ts_src += tile_row[nt]->bytes_per_line;\n\t\ts_dst += main_bytes_per_line;\n\t}\n\n\t/* see if there were any differences for any tile: */\n\tfirst_min = -1;\n\tfor (t=1; t <= nt; t++) {\n\t\ttile_tried[n+(t-1)] = 1;\n\t\tif (first_line[t] != -1) {\n\t\t\tif (first_min == -1 || first_line[t] < first_min) {\n\t\t\t\tfirst_min = first_line[t];\n\t\t\t}\n\t\t}\n\t}\n\tif (first_min == -1) {\n\t\t/* no tile has a difference, note this and get out: */\n\t\tfor (t=1; t <= nt; t++) {\n\t\t\ttile_has_diff[n+(t-1)] = 0;\n\t\t}\n\t\treturn(0);\n\t} else {\n\t\t/*\n\t\t * at least one tile has a difference.  make sure info\n\t\t * is recorded (e.g. sometimes we guess tiles and they\n\t\t * came in with tile_has_diff 0)\n\t\t */\n\t\tfor (t=1; t <= nt; t++) {\n\t\t\tif (first_line[t] == -1) {\n\t\t\t\ttile_has_diff[n+(t-1)] = 0;\n\t\t\t} else {\n\t\t\t\ttile_has_diff[n+(t-1)] = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tm_src = src + (tile_row[nt]->bytes_per_line * size_y);\n\tm_dst = dst + (main_bytes_per_line * size_y);\n\n\tfor (t=1; t <= nt; t++) {\n\t\tlast_line[t] = first_line[t];\n\t}\n\n\t/* find the last line with difference: */\n\tw1 = width1 * pixelsize;\n\tw2 = width2 * pixelsize;\n\n\t/* foreach line: */\n\tfor (line = size_y - 1; line > first_min; line--) {\n\n\t\tm_src -= tile_row[nt]->bytes_per_line;\n\t\tm_dst -= main_bytes_per_line;\n\n\t\t/* foreach tile: */\n\t\tfor (t=1; t <= nt; t++) {\n\t\t\tif (first_line[t] == -1\n\t\t\t    || last_line[t] != first_line[t]) {\n\t\t\t\t/* tile has no changes or already done */\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\toff = (t-1) * w1;\n\t\t\tif (t == nt) {\n\t\t\t\tlen = w2;\t/* possible short tile */\n\t\t\t} else {\n\t\t\t\tlen = w1;\n\t\t\t}\n\t\t\tif (memcmp(m_dst + off, m_src + off, len)) {\n\t\t\t\tlast_line[t] = line;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/*\n\t * determine the farthest down last changed line\n\t * will be used below to limit our memcpy() to the framebuffer.\n\t */\n\tlast_max = -1;\n\tfor (t=1; t <= nt; t++) {\n\t\tif (first_line[t] == -1) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (last_max == -1 || last_line[t] > last_max) {\n\t\t\tlast_max = last_line[t];\n\t\t}\n\t}\n\n\t/* look for differences on left and right hand edges: */\n\tfor (t=1; t <= nt; t++) {\n\t\tleft_diff[t] = 0;\n\t\tright_diff[t] = 0;\n\t}\n\n\th_src = src;\n\th_dst = dst;\n\n\tw1 = width1 * pixelsize;\n\tw2 = width2 * pixelsize;\n\n\tdx1 = (width1 - tile_fuzz) * pixelsize;\n\tdx2 = (width2 - tile_fuzz) * pixelsize;\n\tdw = tile_fuzz * pixelsize; \n\n\t/* foreach line: */\n\tfor (line = 0; line < size_y; line++) {\n\t\t/* foreach tile: */\n\t\tfor (t=1; t <= nt; t++) {\n\t\t\tif (first_line[t] == -1) {\n\t\t\t\t/* tile has no changes at all */\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\toff = (t-1) * w1;\n\t\t\tif (t == nt) {\n\t\t\t\tdx = dx2;\t/* possible short tile */\n\t\t\t\tif (dx <= 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdx = dx1;\n\t\t\t}\n\n\t\t\tif (! left_diff[t] && memcmp(h_dst + off,\n\t\t\t    h_src + off, dw)) {\n\t\t\t\tleft_diff[t] = 1;\n\t\t\t}\n\t\t\tif (! right_diff[t] && memcmp(h_dst + off + dx,\n\t\t\t    h_src + off + dx, dw) ) {\n\t\t\t\tright_diff[t] = 1;\n\t\t\t}\n\t\t}\n\t\th_src += tile_row[nt]->bytes_per_line;\n\t\th_dst += main_bytes_per_line;\n\t}\n\n\t/* now finally copy the difference to the rfb framebuffer: */\n\ts_src = src + tile_row[nt]->bytes_per_line * first_min;\n\ts_dst = dst + main_bytes_per_line * first_min;\n\n\tfor (line = first_min; line <= last_max; line++) {\n\t\t/* for I/O speed we do not do this tile by tile */\n\t\tmemcpy(s_dst, s_src, size_x * pixelsize);\n\t\tif (nt == 1) {\n\t\t\t/*\n\t\t\t * optimization for tall skinny lines, e.g. wm\n\t\t\t * frame. try to find first_x and last_x to limit\n\t\t\t * the size of the hint.  could help for a slow\n\t\t\t * link.  Unfortunately we spent a lot of time\n\t\t\t * reading in the many tiles.\n\t\t\t *\n\t\t\t * BTW, we like to think the above memcpy leaves\n\t\t\t * the data we use below in the cache... (but\n\t\t\t * it could be two 128 byte segments at 32bpp)\n\t\t\t * so this inner loop is not as bad as it seems.\n\t\t\t */\n\t\t\tint k, kx;\n\t\t\tkx = pixelsize;\n\t\t\tfor (k=0; k<size_x; k++) {\n\t\t\t\tif (memcmp(s_dst + k*kx, s_src + k*kx, kx))  {\n\t\t\t\t\tif (first_x == -1 || k < first_x) {\n\t\t\t\t\t\tfirst_x = k;\n\t\t\t\t\t}\n\t\t\t\t\tif (last_x == -1 || k > last_x) {\n\t\t\t\t\t\tlast_x = k;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ts_src += tile_row[nt]->bytes_per_line;\n\t\ts_dst += main_bytes_per_line;\n\t}\n\n\t/* record all the info in the region array for this tile: */\n\tfor (t=1; t <= nt; t++) {\n\t\tint s = t - 1;\n\n\t\tif (first_line[t] == -1) {\n\t\t\t/* tile unchanged */\n\t\t\tcontinue;\n\t\t}\n\t\ttile_region[n+s].first_line = first_line[t];\n\t\ttile_region[n+s].last_line  = last_line[t];\n\n\t\ttile_region[n+s].first_x = first_x;\n\t\ttile_region[n+s].last_x  = last_x;\n\n\t\ttile_region[n+s].top_diff = 0;\n\t\ttile_region[n+s].bot_diff = 0;\n\t\tif ( first_line[t] < tile_fuzz ) {\n\t\t\ttile_region[n+s].top_diff = 1;\n\t\t}\n\t\tif ( last_line[t] > (size_y - 1) - tile_fuzz ) {\n\t\t\ttile_region[n+s].bot_diff = 1;\n\t\t}\n\n\t\ttile_region[n+s].left_diff  = left_diff[t];\n\t\ttile_region[n+s].right_diff = right_diff[t];\n\n\t\ttile_copied[n+s] = 1;\n\t}\n\n\treturn(1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <default8x16.h>\n#include \"userinput.h\"\n#include \"macosx.h\"\n#include \"screen.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"8to24.h\"\n#include \"win_utils.h\"\n#include \"xrandr.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nstatic int copy_all_tile_runs(void);\nstatic int island_try(int x, int y, int u, int v, int *run);\nstatic region_t *tile_region;\n\nstatic int copy_all_tile_runs(void) {\n\tint x, y, n, m, i;\n\tint diffs = 0, ct;\n\tint in_run = 0, run = 0;\n\tint ntave = 0, ntcnt = 0;\n\n\tif (unixpw_in_progress) return 0;\n\n\tfor (y=0; y < ntiles_y; y++) {\n\t\tfor (x=0; x < ntiles_x + 1; x++) {\n\t\t\tn = x + y * ntiles_x;\n\n\t\t\tif (x != ntiles_x && tile_has_diff[n]) {\n\t\t\t\tin_run = 1;\n\t\t\t\trun++;\n\t\t\t} else {\n\t\t\t\tif (! in_run) {\n\t\t\t\t\tin_run = 0;\n\t\t\t\t\trun = 0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tct = copy_tiles(x - run, y, run);\n\t\t\t\tif (ct < 0) return ct;\t/* fatal */\n\n\t\t\t\tntcnt++;\n\t\t\t\tntave += run;\n\t\t\t\tdiffs += run;\n\n\t\t\t\t/* neighboring tile downward: */\n\t\t\t\tfor (i=1; i <= run; i++) {\n\t\t\t\t\tif ((y+1) < ntiles_y\n\t\t\t\t\t    && tile_region[n-i].bot_diff) {\n\t\t\t\t\t\tm = (x-i) + (y+1) * ntiles_x;\n\t\t\t\t\t\tif (! tile_has_diff[m]) {\n\t\t\t\t\t\t\ttile_has_diff[m] = 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/* neighboring tile to right: */\n\t\t\t\tif (((x-1)+1) < ntiles_x\n\t\t\t\t    && tile_region[n-1].right_diff) {\n\t\t\t\t\tm = ((x-1)+1) + y * ntiles_x;\n\t\t\t\t\tif (! tile_has_diff[m]) {\n\t\t\t\t\t\ttile_has_diff[m] = 2;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t/* note that this starts a new run */\n\t\t\t\t\tin_run = 1;\n\t\t\t\t\trun = 1;\n\t\t\t\t} else {\n\t\t\t\t\tin_run = 0;\n\t\t\t\t\trun = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * Could some activity go here, to emulate threaded\n\t\t * behavior by servicing some libvncserver tasks?\n\t\t */\n\t}\n\treturn diffs;\n}"
  },
  {
    "function_name": "copy_all_tiles",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/scan.c",
    "lines": "2060-2100",
    "snippet": "static int copy_all_tiles(void) {\n\tint x, y, n, m;\n\tint diffs = 0, ct;\n\n\tif (unixpw_in_progress) return 0;\n\n\tfor (y=0; y < ntiles_y; y++) {\n\t\tfor (x=0; x < ntiles_x; x++) {\n\t\t\tn = x + y * ntiles_x;\n\n\t\t\tif (tile_has_diff[n]) {\n\t\t\t\tct = copy_tiles(x, y, 1);\n\t\t\t\tif (ct < 0) return ct;\t/* fatal */\n\t\t\t}\n\t\t\tif (! tile_has_diff[n]) {\n\t\t\t\t/*\n\t\t\t\t * n.b. copy_tiles() may have detected\n\t\t\t\t * no change and reset tile_has_diff to 0.\n\t\t\t\t */\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdiffs++;\n\n\t\t\t/* neighboring tile downward: */\n\t\t\tif ( (y+1) < ntiles_y && tile_region[n].bot_diff) {\n\t\t\t\tm = x + (y+1) * ntiles_x;\n\t\t\t\tif (! tile_has_diff[m]) {\n\t\t\t\t\ttile_has_diff[m] = 2;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* neighboring tile to right: */\n\t\t\tif ( (x+1) < ntiles_x && tile_region[n].right_diff) {\n\t\t\t\tm = (x+1) + y * ntiles_x;\n\t\t\t\tif (! tile_has_diff[m]) {\n\t\t\t\t\ttile_has_diff[m] = 2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn diffs;\n}",
    "includes": [
      "#include <default8x16.h>",
      "#include \"userinput.h\"",
      "#include \"macosx.h\"",
      "#include \"screen.h\"",
      "#include \"unixpw.h\"",
      "#include \"cleanup.h\"",
      "#include \"pointer.h\"",
      "#include \"screen.h\"",
      "#include \"8to24.h\"",
      "#include \"win_utils.h\"",
      "#include \"xrandr.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"xinerama.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int copy_all_tiles(void);",
      "static region_t *tile_region;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_tiles",
          "args": [
            "x",
            "y",
            "1"
          ],
          "line": 2071
        },
        "resolved": true,
        "details": {
          "function_name": "copy_tiles",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/scan.c",
          "lines": "1708-2045",
          "snippet": "static int copy_tiles(int tx, int ty, int nt) {\n\tint x, y, line;\n\tint size_x, size_y, width1, width2;\n\tint off, len, n, dw, dx, t;\n\tint w1, w2, dx1, dx2;\t/* tmps for normal and short tiles */\n\tint pixelsize = bpp/8;\n\tint first_min, last_max;\n\tint first_x = -1, last_x = -1;\n\tstatic int prev_ntiles_x = -1;\n\n\tchar *src, *dst, *s_src, *s_dst, *m_src, *m_dst;\n\tchar *h_src, *h_dst;\n\tif (unixpw_in_progress) return 0;\n\n\tif (ntiles_x != prev_ntiles_x && first_line != NULL) {\n\t\tfree(first_line);\tfirst_line = NULL;\n\t\tfree(last_line);\tlast_line = NULL;\n\t\tfree(left_diff);\tleft_diff = NULL;\n\t\tfree(right_diff);\tright_diff = NULL;\n\t}\n\n\tif (first_line == NULL) {\n\t\t/* allocate arrays first time in. */\n\t\tint n = ntiles_x + 1;\n\t\trfbLog(\"copy_tiles: allocating first_line at size %d\\n\", n);\n\t\tfirst_line = (int *) malloc((size_t) (n * sizeof(int)));\n\t\tlast_line  = (int *) malloc((size_t) (n * sizeof(int)));\n\t\tleft_diff  = (unsigned short *)\n\t\t\tmalloc((size_t) (n * sizeof(unsigned short)));\n\t\tright_diff = (unsigned short *)\n\t\t\tmalloc((size_t) (n * sizeof(unsigned short)));\n\t}\n\tprev_ntiles_x = ntiles_x;\n\n\tx = tx * tile_x;\n\ty = ty * tile_y;\n\n\tsize_x = dpy_x - x;\n\tif ( size_x > tile_x * nt ) {\n\t\tsize_x = tile_x * nt;\n\t\twidth1 = tile_x;\n\t\twidth2 = tile_x;\n\t} else {\n\t\t/* short tile */\n\t\twidth1 = tile_x;\t/* internal tile */\n\t\twidth2 = size_x - (nt - 1) * tile_x;\t/* right hand tile */\n\t}\n\n\tsize_y = dpy_y - y;\n\tif ( size_y > tile_y ) {\n\t\tsize_y = tile_y;\n\t}\n\n\tn = tx + ty * ntiles_x;\t\t/* number of the first tile */\n\n\tif (blackouts && tile_blackout[n].cover == 2) {\n\t\t/*\n\t\t * If there are blackouts and this tile is completely covered\n\t\t * no need to poll screen or do anything else..\n\t\t * n.b. we are in single copy_tile mode: nt=1\n\t\t */\n\t\ttile_has_diff[n] = 0;\n\t\treturn(0);\n\t}\n\n\tX_LOCK;\n\tXRANDR_SET_TRAP_RET(-1, \"copy_tile-set\");\n\t/* read in the whole tile run at once: */\n\tcopy_image(tile_row[nt], x, y, size_x, size_y);\n\tXRANDR_CHK_TRAP_RET(-1, \"copy_tile-chk\");\n\n\n\tX_UNLOCK;\n\n\tif (blackouts && tile_blackout[n].cover == 1) {\n\t\t/*\n\t\t * If there are blackouts and this tile is partially covered\n\t\t * we should re-black-out the portion.\n\t\t * n.b. we are in single copy_tile mode: nt=1\n\t\t */\n\t\tint x1, x2, y1, y2, b;\n\t\tint w, s, fill = 0;\n\n\t\tfor (b=0; b < tile_blackout[n].count; b++) {\n\t\t\tchar *b_dst = tile_row[nt]->data;\n\t\t\t\n\t\t\tx1 = tile_blackout[n].bo[b].x1 - x;\n\t\t\ty1 = tile_blackout[n].bo[b].y1 - y;\n\t\t\tx2 = tile_blackout[n].bo[b].x2 - x;\n\t\t\ty2 = tile_blackout[n].bo[b].y2 - y;\n\n\t\t\tw = (x2 - x1) * pixelsize;\n\t\t\ts = x1 * pixelsize;\n\n\t\t\tfor (line = 0; line < size_y; line++) {\n\t\t\t\tif (y1 <= line && line < y2) {\n\t\t\t\t\tmemset(b_dst + s, fill, (size_t) w);\n\t\t\t\t}\n\t\t\t\tb_dst += tile_row[nt]->bytes_per_line;\n\t\t\t}\n\t\t}\n\t}\n\n\tsrc = tile_row[nt]->data;\n\tdst = main_fb + y * main_bytes_per_line + x * pixelsize;\n\n\ts_src = src;\n\ts_dst = dst;\n\n\tfor (t=1; t <= nt; t++) {\n\t\tfirst_line[t] = -1;\n\t}\n\n\t/* find the first line with difference: */\n\tw1 = width1 * pixelsize;\n\tw2 = width2 * pixelsize;\n\n\t/* foreach line: */\n\tfor (line = 0; line < size_y; line++) {\n\t\t/* foreach horizontal tile: */\n\t\tfor (t=1; t <= nt; t++) {\n\t\t\tif (first_line[t] != -1) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\toff = (t-1) * w1;\n\t\t\tif (t == nt) {\n\t\t\t\tlen = w2;\t/* possible short tile */\n\t\t\t} else {\n\t\t\t\tlen = w1;\n\t\t\t}\n\t\t\t\n\t\t\tif (memcmp(s_dst + off, s_src + off, len)) {\n\t\t\t\tfirst_line[t] = line;\n\t\t\t}\n\t\t}\n\t\ts_src += tile_row[nt]->bytes_per_line;\n\t\ts_dst += main_bytes_per_line;\n\t}\n\n\t/* see if there were any differences for any tile: */\n\tfirst_min = -1;\n\tfor (t=1; t <= nt; t++) {\n\t\ttile_tried[n+(t-1)] = 1;\n\t\tif (first_line[t] != -1) {\n\t\t\tif (first_min == -1 || first_line[t] < first_min) {\n\t\t\t\tfirst_min = first_line[t];\n\t\t\t}\n\t\t}\n\t}\n\tif (first_min == -1) {\n\t\t/* no tile has a difference, note this and get out: */\n\t\tfor (t=1; t <= nt; t++) {\n\t\t\ttile_has_diff[n+(t-1)] = 0;\n\t\t}\n\t\treturn(0);\n\t} else {\n\t\t/*\n\t\t * at least one tile has a difference.  make sure info\n\t\t * is recorded (e.g. sometimes we guess tiles and they\n\t\t * came in with tile_has_diff 0)\n\t\t */\n\t\tfor (t=1; t <= nt; t++) {\n\t\t\tif (first_line[t] == -1) {\n\t\t\t\ttile_has_diff[n+(t-1)] = 0;\n\t\t\t} else {\n\t\t\t\ttile_has_diff[n+(t-1)] = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tm_src = src + (tile_row[nt]->bytes_per_line * size_y);\n\tm_dst = dst + (main_bytes_per_line * size_y);\n\n\tfor (t=1; t <= nt; t++) {\n\t\tlast_line[t] = first_line[t];\n\t}\n\n\t/* find the last line with difference: */\n\tw1 = width1 * pixelsize;\n\tw2 = width2 * pixelsize;\n\n\t/* foreach line: */\n\tfor (line = size_y - 1; line > first_min; line--) {\n\n\t\tm_src -= tile_row[nt]->bytes_per_line;\n\t\tm_dst -= main_bytes_per_line;\n\n\t\t/* foreach tile: */\n\t\tfor (t=1; t <= nt; t++) {\n\t\t\tif (first_line[t] == -1\n\t\t\t    || last_line[t] != first_line[t]) {\n\t\t\t\t/* tile has no changes or already done */\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\toff = (t-1) * w1;\n\t\t\tif (t == nt) {\n\t\t\t\tlen = w2;\t/* possible short tile */\n\t\t\t} else {\n\t\t\t\tlen = w1;\n\t\t\t}\n\t\t\tif (memcmp(m_dst + off, m_src + off, len)) {\n\t\t\t\tlast_line[t] = line;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/*\n\t * determine the farthest down last changed line\n\t * will be used below to limit our memcpy() to the framebuffer.\n\t */\n\tlast_max = -1;\n\tfor (t=1; t <= nt; t++) {\n\t\tif (first_line[t] == -1) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (last_max == -1 || last_line[t] > last_max) {\n\t\t\tlast_max = last_line[t];\n\t\t}\n\t}\n\n\t/* look for differences on left and right hand edges: */\n\tfor (t=1; t <= nt; t++) {\n\t\tleft_diff[t] = 0;\n\t\tright_diff[t] = 0;\n\t}\n\n\th_src = src;\n\th_dst = dst;\n\n\tw1 = width1 * pixelsize;\n\tw2 = width2 * pixelsize;\n\n\tdx1 = (width1 - tile_fuzz) * pixelsize;\n\tdx2 = (width2 - tile_fuzz) * pixelsize;\n\tdw = tile_fuzz * pixelsize; \n\n\t/* foreach line: */\n\tfor (line = 0; line < size_y; line++) {\n\t\t/* foreach tile: */\n\t\tfor (t=1; t <= nt; t++) {\n\t\t\tif (first_line[t] == -1) {\n\t\t\t\t/* tile has no changes at all */\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\toff = (t-1) * w1;\n\t\t\tif (t == nt) {\n\t\t\t\tdx = dx2;\t/* possible short tile */\n\t\t\t\tif (dx <= 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdx = dx1;\n\t\t\t}\n\n\t\t\tif (! left_diff[t] && memcmp(h_dst + off,\n\t\t\t    h_src + off, dw)) {\n\t\t\t\tleft_diff[t] = 1;\n\t\t\t}\n\t\t\tif (! right_diff[t] && memcmp(h_dst + off + dx,\n\t\t\t    h_src + off + dx, dw) ) {\n\t\t\t\tright_diff[t] = 1;\n\t\t\t}\n\t\t}\n\t\th_src += tile_row[nt]->bytes_per_line;\n\t\th_dst += main_bytes_per_line;\n\t}\n\n\t/* now finally copy the difference to the rfb framebuffer: */\n\ts_src = src + tile_row[nt]->bytes_per_line * first_min;\n\ts_dst = dst + main_bytes_per_line * first_min;\n\n\tfor (line = first_min; line <= last_max; line++) {\n\t\t/* for I/O speed we do not do this tile by tile */\n\t\tmemcpy(s_dst, s_src, size_x * pixelsize);\n\t\tif (nt == 1) {\n\t\t\t/*\n\t\t\t * optimization for tall skinny lines, e.g. wm\n\t\t\t * frame. try to find first_x and last_x to limit\n\t\t\t * the size of the hint.  could help for a slow\n\t\t\t * link.  Unfortunately we spent a lot of time\n\t\t\t * reading in the many tiles.\n\t\t\t *\n\t\t\t * BTW, we like to think the above memcpy leaves\n\t\t\t * the data we use below in the cache... (but\n\t\t\t * it could be two 128 byte segments at 32bpp)\n\t\t\t * so this inner loop is not as bad as it seems.\n\t\t\t */\n\t\t\tint k, kx;\n\t\t\tkx = pixelsize;\n\t\t\tfor (k=0; k<size_x; k++) {\n\t\t\t\tif (memcmp(s_dst + k*kx, s_src + k*kx, kx))  {\n\t\t\t\t\tif (first_x == -1 || k < first_x) {\n\t\t\t\t\t\tfirst_x = k;\n\t\t\t\t\t}\n\t\t\t\t\tif (last_x == -1 || k > last_x) {\n\t\t\t\t\t\tlast_x = k;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ts_src += tile_row[nt]->bytes_per_line;\n\t\ts_dst += main_bytes_per_line;\n\t}\n\n\t/* record all the info in the region array for this tile: */\n\tfor (t=1; t <= nt; t++) {\n\t\tint s = t - 1;\n\n\t\tif (first_line[t] == -1) {\n\t\t\t/* tile unchanged */\n\t\t\tcontinue;\n\t\t}\n\t\ttile_region[n+s].first_line = first_line[t];\n\t\ttile_region[n+s].last_line  = last_line[t];\n\n\t\ttile_region[n+s].first_x = first_x;\n\t\ttile_region[n+s].last_x  = last_x;\n\n\t\ttile_region[n+s].top_diff = 0;\n\t\ttile_region[n+s].bot_diff = 0;\n\t\tif ( first_line[t] < tile_fuzz ) {\n\t\t\ttile_region[n+s].top_diff = 1;\n\t\t}\n\t\tif ( last_line[t] > (size_y - 1) - tile_fuzz ) {\n\t\t\ttile_region[n+s].bot_diff = 1;\n\t\t}\n\n\t\ttile_region[n+s].left_diff  = left_diff[t];\n\t\ttile_region[n+s].right_diff = right_diff[t];\n\n\t\ttile_copied[n+s] = 1;\n\t}\n\n\treturn(1);\n}",
          "includes": [
            "#include <default8x16.h>",
            "#include \"userinput.h\"",
            "#include \"macosx.h\"",
            "#include \"screen.h\"",
            "#include \"unixpw.h\"",
            "#include \"cleanup.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"8to24.h\"",
            "#include \"win_utils.h\"",
            "#include \"xrandr.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void create_tile_hint(int x, int y, int tw, int th, hint_t *hint);",
            "static void extend_tile_hint(int x, int y, int tw, int th, hint_t *hint);",
            "static void mark_hint(hint_t hint);",
            "static int copy_tiles(int tx, int ty, int nt);",
            "static int island_try(int x, int y, int u, int v, int *run);",
            "static int blackout_line_cmpskip(int n, int x, int y, char *dst, char *src,\n    int w, int pixelsize);",
            "static region_t *tile_region;",
            "static int *first_line = NULL, *last_line = NULL;",
            "static unsigned short *left_diff = NULL, *right_diff = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <default8x16.h>\n#include \"userinput.h\"\n#include \"macosx.h\"\n#include \"screen.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"8to24.h\"\n#include \"win_utils.h\"\n#include \"xrandr.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nstatic void create_tile_hint(int x, int y, int tw, int th, hint_t *hint);\nstatic void extend_tile_hint(int x, int y, int tw, int th, hint_t *hint);\nstatic void mark_hint(hint_t hint);\nstatic int copy_tiles(int tx, int ty, int nt);\nstatic int island_try(int x, int y, int u, int v, int *run);\nstatic int blackout_line_cmpskip(int n, int x, int y, char *dst, char *src,\n    int w, int pixelsize);\nstatic region_t *tile_region;\nstatic int *first_line = NULL, *last_line = NULL;\nstatic unsigned short *left_diff = NULL, *right_diff = NULL;\n\nstatic int copy_tiles(int tx, int ty, int nt) {\n\tint x, y, line;\n\tint size_x, size_y, width1, width2;\n\tint off, len, n, dw, dx, t;\n\tint w1, w2, dx1, dx2;\t/* tmps for normal and short tiles */\n\tint pixelsize = bpp/8;\n\tint first_min, last_max;\n\tint first_x = -1, last_x = -1;\n\tstatic int prev_ntiles_x = -1;\n\n\tchar *src, *dst, *s_src, *s_dst, *m_src, *m_dst;\n\tchar *h_src, *h_dst;\n\tif (unixpw_in_progress) return 0;\n\n\tif (ntiles_x != prev_ntiles_x && first_line != NULL) {\n\t\tfree(first_line);\tfirst_line = NULL;\n\t\tfree(last_line);\tlast_line = NULL;\n\t\tfree(left_diff);\tleft_diff = NULL;\n\t\tfree(right_diff);\tright_diff = NULL;\n\t}\n\n\tif (first_line == NULL) {\n\t\t/* allocate arrays first time in. */\n\t\tint n = ntiles_x + 1;\n\t\trfbLog(\"copy_tiles: allocating first_line at size %d\\n\", n);\n\t\tfirst_line = (int *) malloc((size_t) (n * sizeof(int)));\n\t\tlast_line  = (int *) malloc((size_t) (n * sizeof(int)));\n\t\tleft_diff  = (unsigned short *)\n\t\t\tmalloc((size_t) (n * sizeof(unsigned short)));\n\t\tright_diff = (unsigned short *)\n\t\t\tmalloc((size_t) (n * sizeof(unsigned short)));\n\t}\n\tprev_ntiles_x = ntiles_x;\n\n\tx = tx * tile_x;\n\ty = ty * tile_y;\n\n\tsize_x = dpy_x - x;\n\tif ( size_x > tile_x * nt ) {\n\t\tsize_x = tile_x * nt;\n\t\twidth1 = tile_x;\n\t\twidth2 = tile_x;\n\t} else {\n\t\t/* short tile */\n\t\twidth1 = tile_x;\t/* internal tile */\n\t\twidth2 = size_x - (nt - 1) * tile_x;\t/* right hand tile */\n\t}\n\n\tsize_y = dpy_y - y;\n\tif ( size_y > tile_y ) {\n\t\tsize_y = tile_y;\n\t}\n\n\tn = tx + ty * ntiles_x;\t\t/* number of the first tile */\n\n\tif (blackouts && tile_blackout[n].cover == 2) {\n\t\t/*\n\t\t * If there are blackouts and this tile is completely covered\n\t\t * no need to poll screen or do anything else..\n\t\t * n.b. we are in single copy_tile mode: nt=1\n\t\t */\n\t\ttile_has_diff[n] = 0;\n\t\treturn(0);\n\t}\n\n\tX_LOCK;\n\tXRANDR_SET_TRAP_RET(-1, \"copy_tile-set\");\n\t/* read in the whole tile run at once: */\n\tcopy_image(tile_row[nt], x, y, size_x, size_y);\n\tXRANDR_CHK_TRAP_RET(-1, \"copy_tile-chk\");\n\n\n\tX_UNLOCK;\n\n\tif (blackouts && tile_blackout[n].cover == 1) {\n\t\t/*\n\t\t * If there are blackouts and this tile is partially covered\n\t\t * we should re-black-out the portion.\n\t\t * n.b. we are in single copy_tile mode: nt=1\n\t\t */\n\t\tint x1, x2, y1, y2, b;\n\t\tint w, s, fill = 0;\n\n\t\tfor (b=0; b < tile_blackout[n].count; b++) {\n\t\t\tchar *b_dst = tile_row[nt]->data;\n\t\t\t\n\t\t\tx1 = tile_blackout[n].bo[b].x1 - x;\n\t\t\ty1 = tile_blackout[n].bo[b].y1 - y;\n\t\t\tx2 = tile_blackout[n].bo[b].x2 - x;\n\t\t\ty2 = tile_blackout[n].bo[b].y2 - y;\n\n\t\t\tw = (x2 - x1) * pixelsize;\n\t\t\ts = x1 * pixelsize;\n\n\t\t\tfor (line = 0; line < size_y; line++) {\n\t\t\t\tif (y1 <= line && line < y2) {\n\t\t\t\t\tmemset(b_dst + s, fill, (size_t) w);\n\t\t\t\t}\n\t\t\t\tb_dst += tile_row[nt]->bytes_per_line;\n\t\t\t}\n\t\t}\n\t}\n\n\tsrc = tile_row[nt]->data;\n\tdst = main_fb + y * main_bytes_per_line + x * pixelsize;\n\n\ts_src = src;\n\ts_dst = dst;\n\n\tfor (t=1; t <= nt; t++) {\n\t\tfirst_line[t] = -1;\n\t}\n\n\t/* find the first line with difference: */\n\tw1 = width1 * pixelsize;\n\tw2 = width2 * pixelsize;\n\n\t/* foreach line: */\n\tfor (line = 0; line < size_y; line++) {\n\t\t/* foreach horizontal tile: */\n\t\tfor (t=1; t <= nt; t++) {\n\t\t\tif (first_line[t] != -1) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\toff = (t-1) * w1;\n\t\t\tif (t == nt) {\n\t\t\t\tlen = w2;\t/* possible short tile */\n\t\t\t} else {\n\t\t\t\tlen = w1;\n\t\t\t}\n\t\t\t\n\t\t\tif (memcmp(s_dst + off, s_src + off, len)) {\n\t\t\t\tfirst_line[t] = line;\n\t\t\t}\n\t\t}\n\t\ts_src += tile_row[nt]->bytes_per_line;\n\t\ts_dst += main_bytes_per_line;\n\t}\n\n\t/* see if there were any differences for any tile: */\n\tfirst_min = -1;\n\tfor (t=1; t <= nt; t++) {\n\t\ttile_tried[n+(t-1)] = 1;\n\t\tif (first_line[t] != -1) {\n\t\t\tif (first_min == -1 || first_line[t] < first_min) {\n\t\t\t\tfirst_min = first_line[t];\n\t\t\t}\n\t\t}\n\t}\n\tif (first_min == -1) {\n\t\t/* no tile has a difference, note this and get out: */\n\t\tfor (t=1; t <= nt; t++) {\n\t\t\ttile_has_diff[n+(t-1)] = 0;\n\t\t}\n\t\treturn(0);\n\t} else {\n\t\t/*\n\t\t * at least one tile has a difference.  make sure info\n\t\t * is recorded (e.g. sometimes we guess tiles and they\n\t\t * came in with tile_has_diff 0)\n\t\t */\n\t\tfor (t=1; t <= nt; t++) {\n\t\t\tif (first_line[t] == -1) {\n\t\t\t\ttile_has_diff[n+(t-1)] = 0;\n\t\t\t} else {\n\t\t\t\ttile_has_diff[n+(t-1)] = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tm_src = src + (tile_row[nt]->bytes_per_line * size_y);\n\tm_dst = dst + (main_bytes_per_line * size_y);\n\n\tfor (t=1; t <= nt; t++) {\n\t\tlast_line[t] = first_line[t];\n\t}\n\n\t/* find the last line with difference: */\n\tw1 = width1 * pixelsize;\n\tw2 = width2 * pixelsize;\n\n\t/* foreach line: */\n\tfor (line = size_y - 1; line > first_min; line--) {\n\n\t\tm_src -= tile_row[nt]->bytes_per_line;\n\t\tm_dst -= main_bytes_per_line;\n\n\t\t/* foreach tile: */\n\t\tfor (t=1; t <= nt; t++) {\n\t\t\tif (first_line[t] == -1\n\t\t\t    || last_line[t] != first_line[t]) {\n\t\t\t\t/* tile has no changes or already done */\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\toff = (t-1) * w1;\n\t\t\tif (t == nt) {\n\t\t\t\tlen = w2;\t/* possible short tile */\n\t\t\t} else {\n\t\t\t\tlen = w1;\n\t\t\t}\n\t\t\tif (memcmp(m_dst + off, m_src + off, len)) {\n\t\t\t\tlast_line[t] = line;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/*\n\t * determine the farthest down last changed line\n\t * will be used below to limit our memcpy() to the framebuffer.\n\t */\n\tlast_max = -1;\n\tfor (t=1; t <= nt; t++) {\n\t\tif (first_line[t] == -1) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (last_max == -1 || last_line[t] > last_max) {\n\t\t\tlast_max = last_line[t];\n\t\t}\n\t}\n\n\t/* look for differences on left and right hand edges: */\n\tfor (t=1; t <= nt; t++) {\n\t\tleft_diff[t] = 0;\n\t\tright_diff[t] = 0;\n\t}\n\n\th_src = src;\n\th_dst = dst;\n\n\tw1 = width1 * pixelsize;\n\tw2 = width2 * pixelsize;\n\n\tdx1 = (width1 - tile_fuzz) * pixelsize;\n\tdx2 = (width2 - tile_fuzz) * pixelsize;\n\tdw = tile_fuzz * pixelsize; \n\n\t/* foreach line: */\n\tfor (line = 0; line < size_y; line++) {\n\t\t/* foreach tile: */\n\t\tfor (t=1; t <= nt; t++) {\n\t\t\tif (first_line[t] == -1) {\n\t\t\t\t/* tile has no changes at all */\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\toff = (t-1) * w1;\n\t\t\tif (t == nt) {\n\t\t\t\tdx = dx2;\t/* possible short tile */\n\t\t\t\tif (dx <= 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdx = dx1;\n\t\t\t}\n\n\t\t\tif (! left_diff[t] && memcmp(h_dst + off,\n\t\t\t    h_src + off, dw)) {\n\t\t\t\tleft_diff[t] = 1;\n\t\t\t}\n\t\t\tif (! right_diff[t] && memcmp(h_dst + off + dx,\n\t\t\t    h_src + off + dx, dw) ) {\n\t\t\t\tright_diff[t] = 1;\n\t\t\t}\n\t\t}\n\t\th_src += tile_row[nt]->bytes_per_line;\n\t\th_dst += main_bytes_per_line;\n\t}\n\n\t/* now finally copy the difference to the rfb framebuffer: */\n\ts_src = src + tile_row[nt]->bytes_per_line * first_min;\n\ts_dst = dst + main_bytes_per_line * first_min;\n\n\tfor (line = first_min; line <= last_max; line++) {\n\t\t/* for I/O speed we do not do this tile by tile */\n\t\tmemcpy(s_dst, s_src, size_x * pixelsize);\n\t\tif (nt == 1) {\n\t\t\t/*\n\t\t\t * optimization for tall skinny lines, e.g. wm\n\t\t\t * frame. try to find first_x and last_x to limit\n\t\t\t * the size of the hint.  could help for a slow\n\t\t\t * link.  Unfortunately we spent a lot of time\n\t\t\t * reading in the many tiles.\n\t\t\t *\n\t\t\t * BTW, we like to think the above memcpy leaves\n\t\t\t * the data we use below in the cache... (but\n\t\t\t * it could be two 128 byte segments at 32bpp)\n\t\t\t * so this inner loop is not as bad as it seems.\n\t\t\t */\n\t\t\tint k, kx;\n\t\t\tkx = pixelsize;\n\t\t\tfor (k=0; k<size_x; k++) {\n\t\t\t\tif (memcmp(s_dst + k*kx, s_src + k*kx, kx))  {\n\t\t\t\t\tif (first_x == -1 || k < first_x) {\n\t\t\t\t\t\tfirst_x = k;\n\t\t\t\t\t}\n\t\t\t\t\tif (last_x == -1 || k > last_x) {\n\t\t\t\t\t\tlast_x = k;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ts_src += tile_row[nt]->bytes_per_line;\n\t\ts_dst += main_bytes_per_line;\n\t}\n\n\t/* record all the info in the region array for this tile: */\n\tfor (t=1; t <= nt; t++) {\n\t\tint s = t - 1;\n\n\t\tif (first_line[t] == -1) {\n\t\t\t/* tile unchanged */\n\t\t\tcontinue;\n\t\t}\n\t\ttile_region[n+s].first_line = first_line[t];\n\t\ttile_region[n+s].last_line  = last_line[t];\n\n\t\ttile_region[n+s].first_x = first_x;\n\t\ttile_region[n+s].last_x  = last_x;\n\n\t\ttile_region[n+s].top_diff = 0;\n\t\ttile_region[n+s].bot_diff = 0;\n\t\tif ( first_line[t] < tile_fuzz ) {\n\t\t\ttile_region[n+s].top_diff = 1;\n\t\t}\n\t\tif ( last_line[t] > (size_y - 1) - tile_fuzz ) {\n\t\t\ttile_region[n+s].bot_diff = 1;\n\t\t}\n\n\t\ttile_region[n+s].left_diff  = left_diff[t];\n\t\ttile_region[n+s].right_diff = right_diff[t];\n\n\t\ttile_copied[n+s] = 1;\n\t}\n\n\treturn(1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <default8x16.h>\n#include \"userinput.h\"\n#include \"macosx.h\"\n#include \"screen.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"8to24.h\"\n#include \"win_utils.h\"\n#include \"xrandr.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nstatic int copy_all_tiles(void);\nstatic region_t *tile_region;\n\nstatic int copy_all_tiles(void) {\n\tint x, y, n, m;\n\tint diffs = 0, ct;\n\n\tif (unixpw_in_progress) return 0;\n\n\tfor (y=0; y < ntiles_y; y++) {\n\t\tfor (x=0; x < ntiles_x; x++) {\n\t\t\tn = x + y * ntiles_x;\n\n\t\t\tif (tile_has_diff[n]) {\n\t\t\t\tct = copy_tiles(x, y, 1);\n\t\t\t\tif (ct < 0) return ct;\t/* fatal */\n\t\t\t}\n\t\t\tif (! tile_has_diff[n]) {\n\t\t\t\t/*\n\t\t\t\t * n.b. copy_tiles() may have detected\n\t\t\t\t * no change and reset tile_has_diff to 0.\n\t\t\t\t */\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdiffs++;\n\n\t\t\t/* neighboring tile downward: */\n\t\t\tif ( (y+1) < ntiles_y && tile_region[n].bot_diff) {\n\t\t\t\tm = x + (y+1) * ntiles_x;\n\t\t\t\tif (! tile_has_diff[m]) {\n\t\t\t\t\ttile_has_diff[m] = 2;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* neighboring tile to right: */\n\t\t\tif ( (x+1) < ntiles_x && tile_region[n].right_diff) {\n\t\t\t\tm = (x+1) + y * ntiles_x;\n\t\t\t\tif (! tile_has_diff[m]) {\n\t\t\t\t\ttile_has_diff[m] = 2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn diffs;\n}"
  },
  {
    "function_name": "copy_tiles",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/scan.c",
    "lines": "1708-2045",
    "snippet": "static int copy_tiles(int tx, int ty, int nt) {\n\tint x, y, line;\n\tint size_x, size_y, width1, width2;\n\tint off, len, n, dw, dx, t;\n\tint w1, w2, dx1, dx2;\t/* tmps for normal and short tiles */\n\tint pixelsize = bpp/8;\n\tint first_min, last_max;\n\tint first_x = -1, last_x = -1;\n\tstatic int prev_ntiles_x = -1;\n\n\tchar *src, *dst, *s_src, *s_dst, *m_src, *m_dst;\n\tchar *h_src, *h_dst;\n\tif (unixpw_in_progress) return 0;\n\n\tif (ntiles_x != prev_ntiles_x && first_line != NULL) {\n\t\tfree(first_line);\tfirst_line = NULL;\n\t\tfree(last_line);\tlast_line = NULL;\n\t\tfree(left_diff);\tleft_diff = NULL;\n\t\tfree(right_diff);\tright_diff = NULL;\n\t}\n\n\tif (first_line == NULL) {\n\t\t/* allocate arrays first time in. */\n\t\tint n = ntiles_x + 1;\n\t\trfbLog(\"copy_tiles: allocating first_line at size %d\\n\", n);\n\t\tfirst_line = (int *) malloc((size_t) (n * sizeof(int)));\n\t\tlast_line  = (int *) malloc((size_t) (n * sizeof(int)));\n\t\tleft_diff  = (unsigned short *)\n\t\t\tmalloc((size_t) (n * sizeof(unsigned short)));\n\t\tright_diff = (unsigned short *)\n\t\t\tmalloc((size_t) (n * sizeof(unsigned short)));\n\t}\n\tprev_ntiles_x = ntiles_x;\n\n\tx = tx * tile_x;\n\ty = ty * tile_y;\n\n\tsize_x = dpy_x - x;\n\tif ( size_x > tile_x * nt ) {\n\t\tsize_x = tile_x * nt;\n\t\twidth1 = tile_x;\n\t\twidth2 = tile_x;\n\t} else {\n\t\t/* short tile */\n\t\twidth1 = tile_x;\t/* internal tile */\n\t\twidth2 = size_x - (nt - 1) * tile_x;\t/* right hand tile */\n\t}\n\n\tsize_y = dpy_y - y;\n\tif ( size_y > tile_y ) {\n\t\tsize_y = tile_y;\n\t}\n\n\tn = tx + ty * ntiles_x;\t\t/* number of the first tile */\n\n\tif (blackouts && tile_blackout[n].cover == 2) {\n\t\t/*\n\t\t * If there are blackouts and this tile is completely covered\n\t\t * no need to poll screen or do anything else..\n\t\t * n.b. we are in single copy_tile mode: nt=1\n\t\t */\n\t\ttile_has_diff[n] = 0;\n\t\treturn(0);\n\t}\n\n\tX_LOCK;\n\tXRANDR_SET_TRAP_RET(-1, \"copy_tile-set\");\n\t/* read in the whole tile run at once: */\n\tcopy_image(tile_row[nt], x, y, size_x, size_y);\n\tXRANDR_CHK_TRAP_RET(-1, \"copy_tile-chk\");\n\n\n\tX_UNLOCK;\n\n\tif (blackouts && tile_blackout[n].cover == 1) {\n\t\t/*\n\t\t * If there are blackouts and this tile is partially covered\n\t\t * we should re-black-out the portion.\n\t\t * n.b. we are in single copy_tile mode: nt=1\n\t\t */\n\t\tint x1, x2, y1, y2, b;\n\t\tint w, s, fill = 0;\n\n\t\tfor (b=0; b < tile_blackout[n].count; b++) {\n\t\t\tchar *b_dst = tile_row[nt]->data;\n\t\t\t\n\t\t\tx1 = tile_blackout[n].bo[b].x1 - x;\n\t\t\ty1 = tile_blackout[n].bo[b].y1 - y;\n\t\t\tx2 = tile_blackout[n].bo[b].x2 - x;\n\t\t\ty2 = tile_blackout[n].bo[b].y2 - y;\n\n\t\t\tw = (x2 - x1) * pixelsize;\n\t\t\ts = x1 * pixelsize;\n\n\t\t\tfor (line = 0; line < size_y; line++) {\n\t\t\t\tif (y1 <= line && line < y2) {\n\t\t\t\t\tmemset(b_dst + s, fill, (size_t) w);\n\t\t\t\t}\n\t\t\t\tb_dst += tile_row[nt]->bytes_per_line;\n\t\t\t}\n\t\t}\n\t}\n\n\tsrc = tile_row[nt]->data;\n\tdst = main_fb + y * main_bytes_per_line + x * pixelsize;\n\n\ts_src = src;\n\ts_dst = dst;\n\n\tfor (t=1; t <= nt; t++) {\n\t\tfirst_line[t] = -1;\n\t}\n\n\t/* find the first line with difference: */\n\tw1 = width1 * pixelsize;\n\tw2 = width2 * pixelsize;\n\n\t/* foreach line: */\n\tfor (line = 0; line < size_y; line++) {\n\t\t/* foreach horizontal tile: */\n\t\tfor (t=1; t <= nt; t++) {\n\t\t\tif (first_line[t] != -1) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\toff = (t-1) * w1;\n\t\t\tif (t == nt) {\n\t\t\t\tlen = w2;\t/* possible short tile */\n\t\t\t} else {\n\t\t\t\tlen = w1;\n\t\t\t}\n\t\t\t\n\t\t\tif (memcmp(s_dst + off, s_src + off, len)) {\n\t\t\t\tfirst_line[t] = line;\n\t\t\t}\n\t\t}\n\t\ts_src += tile_row[nt]->bytes_per_line;\n\t\ts_dst += main_bytes_per_line;\n\t}\n\n\t/* see if there were any differences for any tile: */\n\tfirst_min = -1;\n\tfor (t=1; t <= nt; t++) {\n\t\ttile_tried[n+(t-1)] = 1;\n\t\tif (first_line[t] != -1) {\n\t\t\tif (first_min == -1 || first_line[t] < first_min) {\n\t\t\t\tfirst_min = first_line[t];\n\t\t\t}\n\t\t}\n\t}\n\tif (first_min == -1) {\n\t\t/* no tile has a difference, note this and get out: */\n\t\tfor (t=1; t <= nt; t++) {\n\t\t\ttile_has_diff[n+(t-1)] = 0;\n\t\t}\n\t\treturn(0);\n\t} else {\n\t\t/*\n\t\t * at least one tile has a difference.  make sure info\n\t\t * is recorded (e.g. sometimes we guess tiles and they\n\t\t * came in with tile_has_diff 0)\n\t\t */\n\t\tfor (t=1; t <= nt; t++) {\n\t\t\tif (first_line[t] == -1) {\n\t\t\t\ttile_has_diff[n+(t-1)] = 0;\n\t\t\t} else {\n\t\t\t\ttile_has_diff[n+(t-1)] = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tm_src = src + (tile_row[nt]->bytes_per_line * size_y);\n\tm_dst = dst + (main_bytes_per_line * size_y);\n\n\tfor (t=1; t <= nt; t++) {\n\t\tlast_line[t] = first_line[t];\n\t}\n\n\t/* find the last line with difference: */\n\tw1 = width1 * pixelsize;\n\tw2 = width2 * pixelsize;\n\n\t/* foreach line: */\n\tfor (line = size_y - 1; line > first_min; line--) {\n\n\t\tm_src -= tile_row[nt]->bytes_per_line;\n\t\tm_dst -= main_bytes_per_line;\n\n\t\t/* foreach tile: */\n\t\tfor (t=1; t <= nt; t++) {\n\t\t\tif (first_line[t] == -1\n\t\t\t    || last_line[t] != first_line[t]) {\n\t\t\t\t/* tile has no changes or already done */\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\toff = (t-1) * w1;\n\t\t\tif (t == nt) {\n\t\t\t\tlen = w2;\t/* possible short tile */\n\t\t\t} else {\n\t\t\t\tlen = w1;\n\t\t\t}\n\t\t\tif (memcmp(m_dst + off, m_src + off, len)) {\n\t\t\t\tlast_line[t] = line;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/*\n\t * determine the farthest down last changed line\n\t * will be used below to limit our memcpy() to the framebuffer.\n\t */\n\tlast_max = -1;\n\tfor (t=1; t <= nt; t++) {\n\t\tif (first_line[t] == -1) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (last_max == -1 || last_line[t] > last_max) {\n\t\t\tlast_max = last_line[t];\n\t\t}\n\t}\n\n\t/* look for differences on left and right hand edges: */\n\tfor (t=1; t <= nt; t++) {\n\t\tleft_diff[t] = 0;\n\t\tright_diff[t] = 0;\n\t}\n\n\th_src = src;\n\th_dst = dst;\n\n\tw1 = width1 * pixelsize;\n\tw2 = width2 * pixelsize;\n\n\tdx1 = (width1 - tile_fuzz) * pixelsize;\n\tdx2 = (width2 - tile_fuzz) * pixelsize;\n\tdw = tile_fuzz * pixelsize; \n\n\t/* foreach line: */\n\tfor (line = 0; line < size_y; line++) {\n\t\t/* foreach tile: */\n\t\tfor (t=1; t <= nt; t++) {\n\t\t\tif (first_line[t] == -1) {\n\t\t\t\t/* tile has no changes at all */\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\toff = (t-1) * w1;\n\t\t\tif (t == nt) {\n\t\t\t\tdx = dx2;\t/* possible short tile */\n\t\t\t\tif (dx <= 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdx = dx1;\n\t\t\t}\n\n\t\t\tif (! left_diff[t] && memcmp(h_dst + off,\n\t\t\t    h_src + off, dw)) {\n\t\t\t\tleft_diff[t] = 1;\n\t\t\t}\n\t\t\tif (! right_diff[t] && memcmp(h_dst + off + dx,\n\t\t\t    h_src + off + dx, dw) ) {\n\t\t\t\tright_diff[t] = 1;\n\t\t\t}\n\t\t}\n\t\th_src += tile_row[nt]->bytes_per_line;\n\t\th_dst += main_bytes_per_line;\n\t}\n\n\t/* now finally copy the difference to the rfb framebuffer: */\n\ts_src = src + tile_row[nt]->bytes_per_line * first_min;\n\ts_dst = dst + main_bytes_per_line * first_min;\n\n\tfor (line = first_min; line <= last_max; line++) {\n\t\t/* for I/O speed we do not do this tile by tile */\n\t\tmemcpy(s_dst, s_src, size_x * pixelsize);\n\t\tif (nt == 1) {\n\t\t\t/*\n\t\t\t * optimization for tall skinny lines, e.g. wm\n\t\t\t * frame. try to find first_x and last_x to limit\n\t\t\t * the size of the hint.  could help for a slow\n\t\t\t * link.  Unfortunately we spent a lot of time\n\t\t\t * reading in the many tiles.\n\t\t\t *\n\t\t\t * BTW, we like to think the above memcpy leaves\n\t\t\t * the data we use below in the cache... (but\n\t\t\t * it could be two 128 byte segments at 32bpp)\n\t\t\t * so this inner loop is not as bad as it seems.\n\t\t\t */\n\t\t\tint k, kx;\n\t\t\tkx = pixelsize;\n\t\t\tfor (k=0; k<size_x; k++) {\n\t\t\t\tif (memcmp(s_dst + k*kx, s_src + k*kx, kx))  {\n\t\t\t\t\tif (first_x == -1 || k < first_x) {\n\t\t\t\t\t\tfirst_x = k;\n\t\t\t\t\t}\n\t\t\t\t\tif (last_x == -1 || k > last_x) {\n\t\t\t\t\t\tlast_x = k;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ts_src += tile_row[nt]->bytes_per_line;\n\t\ts_dst += main_bytes_per_line;\n\t}\n\n\t/* record all the info in the region array for this tile: */\n\tfor (t=1; t <= nt; t++) {\n\t\tint s = t - 1;\n\n\t\tif (first_line[t] == -1) {\n\t\t\t/* tile unchanged */\n\t\t\tcontinue;\n\t\t}\n\t\ttile_region[n+s].first_line = first_line[t];\n\t\ttile_region[n+s].last_line  = last_line[t];\n\n\t\ttile_region[n+s].first_x = first_x;\n\t\ttile_region[n+s].last_x  = last_x;\n\n\t\ttile_region[n+s].top_diff = 0;\n\t\ttile_region[n+s].bot_diff = 0;\n\t\tif ( first_line[t] < tile_fuzz ) {\n\t\t\ttile_region[n+s].top_diff = 1;\n\t\t}\n\t\tif ( last_line[t] > (size_y - 1) - tile_fuzz ) {\n\t\t\ttile_region[n+s].bot_diff = 1;\n\t\t}\n\n\t\ttile_region[n+s].left_diff  = left_diff[t];\n\t\ttile_region[n+s].right_diff = right_diff[t];\n\n\t\ttile_copied[n+s] = 1;\n\t}\n\n\treturn(1);\n}",
    "includes": [
      "#include <default8x16.h>",
      "#include \"userinput.h\"",
      "#include \"macosx.h\"",
      "#include \"screen.h\"",
      "#include \"unixpw.h\"",
      "#include \"cleanup.h\"",
      "#include \"pointer.h\"",
      "#include \"screen.h\"",
      "#include \"8to24.h\"",
      "#include \"win_utils.h\"",
      "#include \"xrandr.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"xinerama.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void create_tile_hint(int x, int y, int tw, int th, hint_t *hint);",
      "static void extend_tile_hint(int x, int y, int tw, int th, hint_t *hint);",
      "static void mark_hint(hint_t hint);",
      "static int copy_tiles(int tx, int ty, int nt);",
      "static int island_try(int x, int y, int u, int v, int *run);",
      "static int blackout_line_cmpskip(int n, int x, int y, char *dst, char *src,\n    int w, int pixelsize);",
      "static region_t *tile_region;",
      "static int *first_line = NULL, *last_line = NULL;",
      "static unsigned short *left_diff = NULL, *right_diff = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "s_dst + k*kx",
            "s_src + k*kx",
            "kx"
          ],
          "line": 2001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "s_dst",
            "s_src",
            "size_x * pixelsize"
          ],
          "line": 1984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "h_dst + off + dx",
            "h_src + off + dx",
            "dw"
          ],
          "line": 1969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "h_dst + off",
            "h_src + off",
            "dw"
          ],
          "line": 1965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "m_dst + off",
            "m_src + off",
            "len"
          ],
          "line": 1910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "s_dst + off",
            "s_src + off",
            "len"
          ],
          "line": 1840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "b_dst + s",
            "fill",
            "(size_t) w"
          ],
          "line": 1804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XRANDR_CHK_TRAP_RET",
          "args": [
            "-1",
            "\"copy_tile-chk\""
          ],
          "line": 1777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_image",
          "args": [
            "tile_row[nt]",
            "x",
            "y",
            "size_x",
            "size_y"
          ],
          "line": 1776
        },
        "resolved": true,
        "details": {
          "function_name": "copy_image",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "832-868",
          "snippet": "void copy_image(XImage *dest, int x, int y, unsigned int w, unsigned int h) {\n\t/* default (w=0, h=0) is the fill the entire XImage */\n\tif (dest == NULL) {\n\t\treturn;\n\t}\n\tif (w < 1)  {\n\t\tw = dest->width;\n\t}\n\tif (h < 1)  {\n\t\th = dest->height;\n\t}\n\n\tif (raw_fb) {\n\t\tcopy_raw_fb(dest, x, y, w, h);\n\n\t} else if (use_snapfb && snap_fb && dest != snaprect) {\n\t\tchar *src, *dst;\n\t\tunsigned int line;\n\t\tint pixelsize = bpp/8;\n\n\t\tsrc = snap->data + snap->bytes_per_line*y + pixelsize*x;\n\t\tdst = dest->data;\n\t\tfor (line = 0; line < h; line++) {\n\t\t\tmemcpy(dst, src, w * pixelsize);\n\t\t\tsrc += snap->bytes_per_line;\n\t\t\tdst += dest->bytes_per_line;\n\t\t}\n\n\t} else if ((using_shm && ! xform24to32) && (int) w == dest->width &&\n\t    (int) h == dest->height) {\n\t\tXShmGetImage_wr(dpy, window, dest, x, y, AllPlanes);\n\n\t} else {\n\t\tXGetSubImage_wr(dpy, window, x, y, w, h, AllPlanes,\n\t\t    ZPixmap, dest, 0, 0);\n\t}\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "XImage *XShmCreateImage_wr(Display* disp, Visual* vis, unsigned int depth,\n    int format, char* data, XShmSegmentInfo* shminfo, unsigned int width,\n    unsigned int height);",
            "XImage *XCreateImage_wr(Display *disp, Visual *visual, unsigned int depth,\n    int format, int offset, char *data, unsigned int width,\n    unsigned int height, int bitmap_pad, int bytes_per_line);",
            "void copy_image(XImage *dest, int x, int y, unsigned int w, unsigned int h);",
            "Bool XTestCompareCurrentCursorWithWindow_wr(Display* dpy, Window w);",
            "void XTestDiscard_wr(Display *dpy);",
            "int XFree_wr(void *data);",
            "void copy_raw_fb(XImage *dest, int x, int y, unsigned int w, unsigned int h);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nXImage *XShmCreateImage_wr(Display* disp, Visual* vis, unsigned int depth,\n    int format, char* data, XShmSegmentInfo* shminfo, unsigned int width,\n    unsigned int height);\nXImage *XCreateImage_wr(Display *disp, Visual *visual, unsigned int depth,\n    int format, int offset, char *data, unsigned int width,\n    unsigned int height, int bitmap_pad, int bytes_per_line);\nvoid copy_image(XImage *dest, int x, int y, unsigned int w, unsigned int h);\nBool XTestCompareCurrentCursorWithWindow_wr(Display* dpy, Window w);\nvoid XTestDiscard_wr(Display *dpy);\nint XFree_wr(void *data);\nvoid copy_raw_fb(XImage *dest, int x, int y, unsigned int w, unsigned int h);\n\nvoid copy_image(XImage *dest, int x, int y, unsigned int w, unsigned int h) {\n\t/* default (w=0, h=0) is the fill the entire XImage */\n\tif (dest == NULL) {\n\t\treturn;\n\t}\n\tif (w < 1)  {\n\t\tw = dest->width;\n\t}\n\tif (h < 1)  {\n\t\th = dest->height;\n\t}\n\n\tif (raw_fb) {\n\t\tcopy_raw_fb(dest, x, y, w, h);\n\n\t} else if (use_snapfb && snap_fb && dest != snaprect) {\n\t\tchar *src, *dst;\n\t\tunsigned int line;\n\t\tint pixelsize = bpp/8;\n\n\t\tsrc = snap->data + snap->bytes_per_line*y + pixelsize*x;\n\t\tdst = dest->data;\n\t\tfor (line = 0; line < h; line++) {\n\t\t\tmemcpy(dst, src, w * pixelsize);\n\t\t\tsrc += snap->bytes_per_line;\n\t\t\tdst += dest->bytes_per_line;\n\t\t}\n\n\t} else if ((using_shm && ! xform24to32) && (int) w == dest->width &&\n\t    (int) h == dest->height) {\n\t\tXShmGetImage_wr(dpy, window, dest, x, y, AllPlanes);\n\n\t} else {\n\t\tXGetSubImage_wr(dpy, window, x, y, w, h, AllPlanes,\n\t\t    ZPixmap, dest, 0, 0);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "XRANDR_SET_TRAP_RET",
          "args": [
            "-1",
            "\"copy_tile-set\""
          ],
          "line": 1774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "(size_t) (n * sizeof(unsigned short))"
          ],
          "line": 1738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "(size_t) (n * sizeof(unsigned short))"
          ],
          "line": 1736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "(size_t) (n * sizeof(int))"
          ],
          "line": 1734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "(size_t) (n * sizeof(int))"
          ],
          "line": 1733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"copy_tiles: allocating first_line at size %d\\n\"",
            "n"
          ],
          "line": 1732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "right_diff"
          ],
          "line": 1726
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <default8x16.h>\n#include \"userinput.h\"\n#include \"macosx.h\"\n#include \"screen.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"8to24.h\"\n#include \"win_utils.h\"\n#include \"xrandr.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nstatic void create_tile_hint(int x, int y, int tw, int th, hint_t *hint);\nstatic void extend_tile_hint(int x, int y, int tw, int th, hint_t *hint);\nstatic void mark_hint(hint_t hint);\nstatic int copy_tiles(int tx, int ty, int nt);\nstatic int island_try(int x, int y, int u, int v, int *run);\nstatic int blackout_line_cmpskip(int n, int x, int y, char *dst, char *src,\n    int w, int pixelsize);\nstatic region_t *tile_region;\nstatic int *first_line = NULL, *last_line = NULL;\nstatic unsigned short *left_diff = NULL, *right_diff = NULL;\n\nstatic int copy_tiles(int tx, int ty, int nt) {\n\tint x, y, line;\n\tint size_x, size_y, width1, width2;\n\tint off, len, n, dw, dx, t;\n\tint w1, w2, dx1, dx2;\t/* tmps for normal and short tiles */\n\tint pixelsize = bpp/8;\n\tint first_min, last_max;\n\tint first_x = -1, last_x = -1;\n\tstatic int prev_ntiles_x = -1;\n\n\tchar *src, *dst, *s_src, *s_dst, *m_src, *m_dst;\n\tchar *h_src, *h_dst;\n\tif (unixpw_in_progress) return 0;\n\n\tif (ntiles_x != prev_ntiles_x && first_line != NULL) {\n\t\tfree(first_line);\tfirst_line = NULL;\n\t\tfree(last_line);\tlast_line = NULL;\n\t\tfree(left_diff);\tleft_diff = NULL;\n\t\tfree(right_diff);\tright_diff = NULL;\n\t}\n\n\tif (first_line == NULL) {\n\t\t/* allocate arrays first time in. */\n\t\tint n = ntiles_x + 1;\n\t\trfbLog(\"copy_tiles: allocating first_line at size %d\\n\", n);\n\t\tfirst_line = (int *) malloc((size_t) (n * sizeof(int)));\n\t\tlast_line  = (int *) malloc((size_t) (n * sizeof(int)));\n\t\tleft_diff  = (unsigned short *)\n\t\t\tmalloc((size_t) (n * sizeof(unsigned short)));\n\t\tright_diff = (unsigned short *)\n\t\t\tmalloc((size_t) (n * sizeof(unsigned short)));\n\t}\n\tprev_ntiles_x = ntiles_x;\n\n\tx = tx * tile_x;\n\ty = ty * tile_y;\n\n\tsize_x = dpy_x - x;\n\tif ( size_x > tile_x * nt ) {\n\t\tsize_x = tile_x * nt;\n\t\twidth1 = tile_x;\n\t\twidth2 = tile_x;\n\t} else {\n\t\t/* short tile */\n\t\twidth1 = tile_x;\t/* internal tile */\n\t\twidth2 = size_x - (nt - 1) * tile_x;\t/* right hand tile */\n\t}\n\n\tsize_y = dpy_y - y;\n\tif ( size_y > tile_y ) {\n\t\tsize_y = tile_y;\n\t}\n\n\tn = tx + ty * ntiles_x;\t\t/* number of the first tile */\n\n\tif (blackouts && tile_blackout[n].cover == 2) {\n\t\t/*\n\t\t * If there are blackouts and this tile is completely covered\n\t\t * no need to poll screen or do anything else..\n\t\t * n.b. we are in single copy_tile mode: nt=1\n\t\t */\n\t\ttile_has_diff[n] = 0;\n\t\treturn(0);\n\t}\n\n\tX_LOCK;\n\tXRANDR_SET_TRAP_RET(-1, \"copy_tile-set\");\n\t/* read in the whole tile run at once: */\n\tcopy_image(tile_row[nt], x, y, size_x, size_y);\n\tXRANDR_CHK_TRAP_RET(-1, \"copy_tile-chk\");\n\n\n\tX_UNLOCK;\n\n\tif (blackouts && tile_blackout[n].cover == 1) {\n\t\t/*\n\t\t * If there are blackouts and this tile is partially covered\n\t\t * we should re-black-out the portion.\n\t\t * n.b. we are in single copy_tile mode: nt=1\n\t\t */\n\t\tint x1, x2, y1, y2, b;\n\t\tint w, s, fill = 0;\n\n\t\tfor (b=0; b < tile_blackout[n].count; b++) {\n\t\t\tchar *b_dst = tile_row[nt]->data;\n\t\t\t\n\t\t\tx1 = tile_blackout[n].bo[b].x1 - x;\n\t\t\ty1 = tile_blackout[n].bo[b].y1 - y;\n\t\t\tx2 = tile_blackout[n].bo[b].x2 - x;\n\t\t\ty2 = tile_blackout[n].bo[b].y2 - y;\n\n\t\t\tw = (x2 - x1) * pixelsize;\n\t\t\ts = x1 * pixelsize;\n\n\t\t\tfor (line = 0; line < size_y; line++) {\n\t\t\t\tif (y1 <= line && line < y2) {\n\t\t\t\t\tmemset(b_dst + s, fill, (size_t) w);\n\t\t\t\t}\n\t\t\t\tb_dst += tile_row[nt]->bytes_per_line;\n\t\t\t}\n\t\t}\n\t}\n\n\tsrc = tile_row[nt]->data;\n\tdst = main_fb + y * main_bytes_per_line + x * pixelsize;\n\n\ts_src = src;\n\ts_dst = dst;\n\n\tfor (t=1; t <= nt; t++) {\n\t\tfirst_line[t] = -1;\n\t}\n\n\t/* find the first line with difference: */\n\tw1 = width1 * pixelsize;\n\tw2 = width2 * pixelsize;\n\n\t/* foreach line: */\n\tfor (line = 0; line < size_y; line++) {\n\t\t/* foreach horizontal tile: */\n\t\tfor (t=1; t <= nt; t++) {\n\t\t\tif (first_line[t] != -1) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\toff = (t-1) * w1;\n\t\t\tif (t == nt) {\n\t\t\t\tlen = w2;\t/* possible short tile */\n\t\t\t} else {\n\t\t\t\tlen = w1;\n\t\t\t}\n\t\t\t\n\t\t\tif (memcmp(s_dst + off, s_src + off, len)) {\n\t\t\t\tfirst_line[t] = line;\n\t\t\t}\n\t\t}\n\t\ts_src += tile_row[nt]->bytes_per_line;\n\t\ts_dst += main_bytes_per_line;\n\t}\n\n\t/* see if there were any differences for any tile: */\n\tfirst_min = -1;\n\tfor (t=1; t <= nt; t++) {\n\t\ttile_tried[n+(t-1)] = 1;\n\t\tif (first_line[t] != -1) {\n\t\t\tif (first_min == -1 || first_line[t] < first_min) {\n\t\t\t\tfirst_min = first_line[t];\n\t\t\t}\n\t\t}\n\t}\n\tif (first_min == -1) {\n\t\t/* no tile has a difference, note this and get out: */\n\t\tfor (t=1; t <= nt; t++) {\n\t\t\ttile_has_diff[n+(t-1)] = 0;\n\t\t}\n\t\treturn(0);\n\t} else {\n\t\t/*\n\t\t * at least one tile has a difference.  make sure info\n\t\t * is recorded (e.g. sometimes we guess tiles and they\n\t\t * came in with tile_has_diff 0)\n\t\t */\n\t\tfor (t=1; t <= nt; t++) {\n\t\t\tif (first_line[t] == -1) {\n\t\t\t\ttile_has_diff[n+(t-1)] = 0;\n\t\t\t} else {\n\t\t\t\ttile_has_diff[n+(t-1)] = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tm_src = src + (tile_row[nt]->bytes_per_line * size_y);\n\tm_dst = dst + (main_bytes_per_line * size_y);\n\n\tfor (t=1; t <= nt; t++) {\n\t\tlast_line[t] = first_line[t];\n\t}\n\n\t/* find the last line with difference: */\n\tw1 = width1 * pixelsize;\n\tw2 = width2 * pixelsize;\n\n\t/* foreach line: */\n\tfor (line = size_y - 1; line > first_min; line--) {\n\n\t\tm_src -= tile_row[nt]->bytes_per_line;\n\t\tm_dst -= main_bytes_per_line;\n\n\t\t/* foreach tile: */\n\t\tfor (t=1; t <= nt; t++) {\n\t\t\tif (first_line[t] == -1\n\t\t\t    || last_line[t] != first_line[t]) {\n\t\t\t\t/* tile has no changes or already done */\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\toff = (t-1) * w1;\n\t\t\tif (t == nt) {\n\t\t\t\tlen = w2;\t/* possible short tile */\n\t\t\t} else {\n\t\t\t\tlen = w1;\n\t\t\t}\n\t\t\tif (memcmp(m_dst + off, m_src + off, len)) {\n\t\t\t\tlast_line[t] = line;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/*\n\t * determine the farthest down last changed line\n\t * will be used below to limit our memcpy() to the framebuffer.\n\t */\n\tlast_max = -1;\n\tfor (t=1; t <= nt; t++) {\n\t\tif (first_line[t] == -1) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (last_max == -1 || last_line[t] > last_max) {\n\t\t\tlast_max = last_line[t];\n\t\t}\n\t}\n\n\t/* look for differences on left and right hand edges: */\n\tfor (t=1; t <= nt; t++) {\n\t\tleft_diff[t] = 0;\n\t\tright_diff[t] = 0;\n\t}\n\n\th_src = src;\n\th_dst = dst;\n\n\tw1 = width1 * pixelsize;\n\tw2 = width2 * pixelsize;\n\n\tdx1 = (width1 - tile_fuzz) * pixelsize;\n\tdx2 = (width2 - tile_fuzz) * pixelsize;\n\tdw = tile_fuzz * pixelsize; \n\n\t/* foreach line: */\n\tfor (line = 0; line < size_y; line++) {\n\t\t/* foreach tile: */\n\t\tfor (t=1; t <= nt; t++) {\n\t\t\tif (first_line[t] == -1) {\n\t\t\t\t/* tile has no changes at all */\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\toff = (t-1) * w1;\n\t\t\tif (t == nt) {\n\t\t\t\tdx = dx2;\t/* possible short tile */\n\t\t\t\tif (dx <= 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdx = dx1;\n\t\t\t}\n\n\t\t\tif (! left_diff[t] && memcmp(h_dst + off,\n\t\t\t    h_src + off, dw)) {\n\t\t\t\tleft_diff[t] = 1;\n\t\t\t}\n\t\t\tif (! right_diff[t] && memcmp(h_dst + off + dx,\n\t\t\t    h_src + off + dx, dw) ) {\n\t\t\t\tright_diff[t] = 1;\n\t\t\t}\n\t\t}\n\t\th_src += tile_row[nt]->bytes_per_line;\n\t\th_dst += main_bytes_per_line;\n\t}\n\n\t/* now finally copy the difference to the rfb framebuffer: */\n\ts_src = src + tile_row[nt]->bytes_per_line * first_min;\n\ts_dst = dst + main_bytes_per_line * first_min;\n\n\tfor (line = first_min; line <= last_max; line++) {\n\t\t/* for I/O speed we do not do this tile by tile */\n\t\tmemcpy(s_dst, s_src, size_x * pixelsize);\n\t\tif (nt == 1) {\n\t\t\t/*\n\t\t\t * optimization for tall skinny lines, e.g. wm\n\t\t\t * frame. try to find first_x and last_x to limit\n\t\t\t * the size of the hint.  could help for a slow\n\t\t\t * link.  Unfortunately we spent a lot of time\n\t\t\t * reading in the many tiles.\n\t\t\t *\n\t\t\t * BTW, we like to think the above memcpy leaves\n\t\t\t * the data we use below in the cache... (but\n\t\t\t * it could be two 128 byte segments at 32bpp)\n\t\t\t * so this inner loop is not as bad as it seems.\n\t\t\t */\n\t\t\tint k, kx;\n\t\t\tkx = pixelsize;\n\t\t\tfor (k=0; k<size_x; k++) {\n\t\t\t\tif (memcmp(s_dst + k*kx, s_src + k*kx, kx))  {\n\t\t\t\t\tif (first_x == -1 || k < first_x) {\n\t\t\t\t\t\tfirst_x = k;\n\t\t\t\t\t}\n\t\t\t\t\tif (last_x == -1 || k > last_x) {\n\t\t\t\t\t\tlast_x = k;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ts_src += tile_row[nt]->bytes_per_line;\n\t\ts_dst += main_bytes_per_line;\n\t}\n\n\t/* record all the info in the region array for this tile: */\n\tfor (t=1; t <= nt; t++) {\n\t\tint s = t - 1;\n\n\t\tif (first_line[t] == -1) {\n\t\t\t/* tile unchanged */\n\t\t\tcontinue;\n\t\t}\n\t\ttile_region[n+s].first_line = first_line[t];\n\t\ttile_region[n+s].last_line  = last_line[t];\n\n\t\ttile_region[n+s].first_x = first_x;\n\t\ttile_region[n+s].last_x  = last_x;\n\n\t\ttile_region[n+s].top_diff = 0;\n\t\ttile_region[n+s].bot_diff = 0;\n\t\tif ( first_line[t] < tile_fuzz ) {\n\t\t\ttile_region[n+s].top_diff = 1;\n\t\t}\n\t\tif ( last_line[t] > (size_y - 1) - tile_fuzz ) {\n\t\t\ttile_region[n+s].bot_diff = 1;\n\t\t}\n\n\t\ttile_region[n+s].left_diff  = left_diff[t];\n\t\ttile_region[n+s].right_diff = right_diff[t];\n\n\t\ttile_copied[n+s] = 1;\n\t}\n\n\treturn(1);\n}"
  },
  {
    "function_name": "mark_hint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/scan.c",
    "lines": "1687-1694",
    "snippet": "static void mark_hint(hint_t hint) {\n\tint x = hint.x;\t\n\tint y = hint.y;\t\n\tint w = hint.w;\t\n\tint h = hint.h;\t\n\n\tmark_rect_as_modified(x, y, x + w, y + h, 0);\n}",
    "includes": [
      "#include <default8x16.h>",
      "#include \"userinput.h\"",
      "#include \"macosx.h\"",
      "#include \"screen.h\"",
      "#include \"unixpw.h\"",
      "#include \"cleanup.h\"",
      "#include \"pointer.h\"",
      "#include \"screen.h\"",
      "#include \"8to24.h\"",
      "#include \"win_utils.h\"",
      "#include \"xrandr.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"xinerama.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void create_tile_hint(int x, int y, int tw, int th, hint_t *hint);",
      "static void extend_tile_hint(int x, int y, int tw, int th, hint_t *hint);",
      "static void mark_hint(hint_t hint);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_rect_as_modified",
          "args": [
            "x",
            "y",
            "x + w",
            "y + h",
            "0"
          ],
          "line": 1693
        },
        "resolved": true,
        "details": {
          "function_name": "mark_rect_as_modified",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/scan.c",
          "lines": "1643-1682",
          "snippet": "void mark_rect_as_modified(int x1, int y1, int x2, int y2, int force) {\n\n\tif (damage_time != 0) {\n\t\t/*\n\t\t * This is not XDAMAGE, rather a hack for testing\n\t\t * where we allow the framebuffer to be corrupted for\n\t\t * damage_delay seconds.\n\t\t */\n\t\tint debug = 0;\n\t\tif (time(NULL) > damage_time + damage_delay) {\n\t\t\tif (! quiet) {\n\t\t\t\trfbLog(\"damaging turned off.\\n\");\n\t\t\t}\n\t\t\tdamage_time = 0;\n\t\t\tdamage_delay = 0;\n\t\t} else {\n\t\t\tif (debug) {\n\t\t\t\trfbLog(\"damaging viewer fb by not marking \"\n\t\t\t\t    \"rect: %d,%d,%d,%d\\n\", x1, y1, x2, y2);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n\n\n\tif (rfb_fb == main_fb || force) {\n\t\tmark_wrapper(x1, y1, x2, y2);\n\t\treturn;\n\t}\n\n\tif (cmap8to24) {\n\t\tbpp8to24(x1, y1, x2, y2);\n\t}\n\n\tif (scaling) {\n\t\tscale_and_mark_rect(x1, y1, x2, y2, 1);\n\t} else {\n\t\tmark_wrapper(x1, y1, x2, y2);\n\t}\n}",
          "includes": [
            "#include <default8x16.h>",
            "#include \"userinput.h\"",
            "#include \"macosx.h\"",
            "#include \"screen.h\"",
            "#include \"unixpw.h\"",
            "#include \"cleanup.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"8to24.h\"",
            "#include \"win_utils.h\"",
            "#include \"xrandr.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_rect_as_modified(int x1, int y1, int x2, int y2, int force);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <default8x16.h>\n#include \"userinput.h\"\n#include \"macosx.h\"\n#include \"screen.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"8to24.h\"\n#include \"win_utils.h\"\n#include \"xrandr.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nvoid mark_rect_as_modified(int x1, int y1, int x2, int y2, int force);\n\nvoid mark_rect_as_modified(int x1, int y1, int x2, int y2, int force) {\n\n\tif (damage_time != 0) {\n\t\t/*\n\t\t * This is not XDAMAGE, rather a hack for testing\n\t\t * where we allow the framebuffer to be corrupted for\n\t\t * damage_delay seconds.\n\t\t */\n\t\tint debug = 0;\n\t\tif (time(NULL) > damage_time + damage_delay) {\n\t\t\tif (! quiet) {\n\t\t\t\trfbLog(\"damaging turned off.\\n\");\n\t\t\t}\n\t\t\tdamage_time = 0;\n\t\t\tdamage_delay = 0;\n\t\t} else {\n\t\t\tif (debug) {\n\t\t\t\trfbLog(\"damaging viewer fb by not marking \"\n\t\t\t\t    \"rect: %d,%d,%d,%d\\n\", x1, y1, x2, y2);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n\n\n\tif (rfb_fb == main_fb || force) {\n\t\tmark_wrapper(x1, y1, x2, y2);\n\t\treturn;\n\t}\n\n\tif (cmap8to24) {\n\t\tbpp8to24(x1, y1, x2, y2);\n\t}\n\n\tif (scaling) {\n\t\tscale_and_mark_rect(x1, y1, x2, y2, 1);\n\t} else {\n\t\tmark_wrapper(x1, y1, x2, y2);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <default8x16.h>\n#include \"userinput.h\"\n#include \"macosx.h\"\n#include \"screen.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"8to24.h\"\n#include \"win_utils.h\"\n#include \"xrandr.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nstatic void create_tile_hint(int x, int y, int tw, int th, hint_t *hint);\nstatic void extend_tile_hint(int x, int y, int tw, int th, hint_t *hint);\nstatic void mark_hint(hint_t hint);\n\nstatic void mark_hint(hint_t hint) {\n\tint x = hint.x;\t\n\tint y = hint.y;\t\n\tint w = hint.w;\t\n\tint h = hint.h;\t\n\n\tmark_rect_as_modified(x, y, x + w, y + h, 0);\n}"
  },
  {
    "function_name": "mark_rect_as_modified",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/scan.c",
    "lines": "1643-1682",
    "snippet": "void mark_rect_as_modified(int x1, int y1, int x2, int y2, int force) {\n\n\tif (damage_time != 0) {\n\t\t/*\n\t\t * This is not XDAMAGE, rather a hack for testing\n\t\t * where we allow the framebuffer to be corrupted for\n\t\t * damage_delay seconds.\n\t\t */\n\t\tint debug = 0;\n\t\tif (time(NULL) > damage_time + damage_delay) {\n\t\t\tif (! quiet) {\n\t\t\t\trfbLog(\"damaging turned off.\\n\");\n\t\t\t}\n\t\t\tdamage_time = 0;\n\t\t\tdamage_delay = 0;\n\t\t} else {\n\t\t\tif (debug) {\n\t\t\t\trfbLog(\"damaging viewer fb by not marking \"\n\t\t\t\t    \"rect: %d,%d,%d,%d\\n\", x1, y1, x2, y2);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n\n\n\tif (rfb_fb == main_fb || force) {\n\t\tmark_wrapper(x1, y1, x2, y2);\n\t\treturn;\n\t}\n\n\tif (cmap8to24) {\n\t\tbpp8to24(x1, y1, x2, y2);\n\t}\n\n\tif (scaling) {\n\t\tscale_and_mark_rect(x1, y1, x2, y2, 1);\n\t} else {\n\t\tmark_wrapper(x1, y1, x2, y2);\n\t}\n}",
    "includes": [
      "#include <default8x16.h>",
      "#include \"userinput.h\"",
      "#include \"macosx.h\"",
      "#include \"screen.h\"",
      "#include \"unixpw.h\"",
      "#include \"cleanup.h\"",
      "#include \"pointer.h\"",
      "#include \"screen.h\"",
      "#include \"8to24.h\"",
      "#include \"win_utils.h\"",
      "#include \"xrandr.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"xinerama.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void mark_rect_as_modified(int x1, int y1, int x2, int y2, int force);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_wrapper",
          "args": [
            "x1",
            "y1",
            "x2",
            "y2"
          ],
          "line": 1680
        },
        "resolved": true,
        "details": {
          "function_name": "mark_wrapper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/scan.c",
          "lines": "1616-1641",
          "snippet": "void mark_wrapper(int x1, int y1, int x2, int y2) {\n\tint t, r_x1 = x1, r_y1 = y1, r_x2 = x2, r_y2 = y2;\n\n\tif (rotating) {\n\t\t/* well we hope rot_fb will always be the last one... */\n\t\trotate_coords(x1, y1, &r_x1, &r_y1, -1, -1);\n\t\trotate_coords(x2, y2, &r_x2, &r_y2, -1, -1);\n\t\trotate_fb(x1, y1, x2, y2);\n\t\tif (r_x1 > r_x2) {\n\t\t\tt = r_x1;\n\t\t\tr_x1 = r_x2;\n\t\t\tr_x2 = t;\n\t\t}\n\t\tif (r_y1 > r_y2) {\n\t\t\tt = r_y1;\n\t\t\tr_y1 = r_y2;\n\t\t\tr_y2 = t;\n\t\t}\n\t\t/* painting errors  */\n\t\tr_x1--;\n\t\tr_x2++;\n\t\tr_y1--;\n\t\tr_y2++;\n\t}\n\trfbMarkRectAsModified(screen, r_x1, r_y1, r_x2, r_y2);\n}",
          "includes": [
            "#include <default8x16.h>",
            "#include \"userinput.h\"",
            "#include \"macosx.h\"",
            "#include \"screen.h\"",
            "#include \"unixpw.h\"",
            "#include \"cleanup.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"8to24.h\"",
            "#include \"win_utils.h\"",
            "#include \"xrandr.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <default8x16.h>\n#include \"userinput.h\"\n#include \"macosx.h\"\n#include \"screen.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"8to24.h\"\n#include \"win_utils.h\"\n#include \"xrandr.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nvoid mark_wrapper(int x1, int y1, int x2, int y2) {\n\tint t, r_x1 = x1, r_y1 = y1, r_x2 = x2, r_y2 = y2;\n\n\tif (rotating) {\n\t\t/* well we hope rot_fb will always be the last one... */\n\t\trotate_coords(x1, y1, &r_x1, &r_y1, -1, -1);\n\t\trotate_coords(x2, y2, &r_x2, &r_y2, -1, -1);\n\t\trotate_fb(x1, y1, x2, y2);\n\t\tif (r_x1 > r_x2) {\n\t\t\tt = r_x1;\n\t\t\tr_x1 = r_x2;\n\t\t\tr_x2 = t;\n\t\t}\n\t\tif (r_y1 > r_y2) {\n\t\t\tt = r_y1;\n\t\t\tr_y1 = r_y2;\n\t\t\tr_y2 = t;\n\t\t}\n\t\t/* painting errors  */\n\t\tr_x1--;\n\t\tr_x2++;\n\t\tr_y1--;\n\t\tr_y2++;\n\t}\n\trfbMarkRectAsModified(screen, r_x1, r_y1, r_x2, r_y2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "scale_and_mark_rect",
          "args": [
            "x1",
            "y1",
            "x2",
            "y2",
            "1"
          ],
          "line": 1678
        },
        "resolved": true,
        "details": {
          "function_name": "scale_and_mark_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/scan.c",
          "lines": "1300-1342",
          "snippet": "void scale_and_mark_rect(int X1, int Y1, int X2, int Y2, int mark) {\n\tchar *dst_fb, *src_fb = main_fb;\n\tint dst_bpl, Bpp = bpp/8, fac = 1;\n\n\tif (!screen || !rfb_fb || !main_fb) {\n\t\treturn;\n\t}\n\tif (! screen->serverFormat.trueColour) {\n\t\t/*\n\t\t * PseudoColor colormap... blending leads to random colors.\n\t\t * User can override with \":fb\"\n\t\t */\n\t\tif (scaling_blend == 1) {\n\t\t\t/* :fb option sets it to 2 */\n\t\t\tif (default_visual->class == StaticGray) {\n\t\t\t\t/*\n\t\t\t\t * StaticGray can be blended OK, otherwise\n\t\t\t\t * user can disable with :nb\n\t\t\t\t */\n\t\t\t\t;\n\t\t\t} else {\n\t\t\t\tscaling_blend = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (cmap8to24 && cmap8to24_fb) {\n\t\tsrc_fb = cmap8to24_fb;\n\t\tif (scaling) {\n\t\t\tif (depth <= 8) {\n\t\t\t\tfac = 4;\n\t\t\t} else if (depth <= 16) {\n\t\t\t\tfac = 2;\n\t\t\t}\n\t\t}\n\t}\n\tdst_fb = rfb_fb;\n\tdst_bpl = rfb_bytes_per_line;\n\n\tscale_rect(scale_fac_x, scale_fac_y, scaling_blend, scaling_interpolate, fac * Bpp,\n\t    src_fb, fac * main_bytes_per_line, dst_fb, dst_bpl, dpy_x, dpy_y,\n\t    scaled_x, scaled_y, X1, Y1, X2, Y2, mark);\n}",
          "includes": [
            "#include <default8x16.h>",
            "#include \"userinput.h\"",
            "#include \"macosx.h\"",
            "#include \"screen.h\"",
            "#include \"unixpw.h\"",
            "#include \"cleanup.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"8to24.h\"",
            "#include \"win_utils.h\"",
            "#include \"xrandr.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void scale_rect(double factor_x, double factor_y, int blend, int interpolate, int Bpp,\n    char *src_fb, int src_bytes_per_line, char *dst_fb, int dst_bytes_per_line,\n    int Nx, int Ny, int nx, int ny, int X1, int Y1, int X2, int Y2, int mark);",
            "void scale_and_mark_rect(int X1, int Y1, int X2, int Y2, int mark);",
            "void rotate_curs(char *dst_0, char *src_0, int Dx, int Dy, int Bpp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <default8x16.h>\n#include \"userinput.h\"\n#include \"macosx.h\"\n#include \"screen.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"8to24.h\"\n#include \"win_utils.h\"\n#include \"xrandr.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nvoid scale_rect(double factor_x, double factor_y, int blend, int interpolate, int Bpp,\n    char *src_fb, int src_bytes_per_line, char *dst_fb, int dst_bytes_per_line,\n    int Nx, int Ny, int nx, int ny, int X1, int Y1, int X2, int Y2, int mark);\nvoid scale_and_mark_rect(int X1, int Y1, int X2, int Y2, int mark);\nvoid rotate_curs(char *dst_0, char *src_0, int Dx, int Dy, int Bpp);\n\nvoid scale_and_mark_rect(int X1, int Y1, int X2, int Y2, int mark) {\n\tchar *dst_fb, *src_fb = main_fb;\n\tint dst_bpl, Bpp = bpp/8, fac = 1;\n\n\tif (!screen || !rfb_fb || !main_fb) {\n\t\treturn;\n\t}\n\tif (! screen->serverFormat.trueColour) {\n\t\t/*\n\t\t * PseudoColor colormap... blending leads to random colors.\n\t\t * User can override with \":fb\"\n\t\t */\n\t\tif (scaling_blend == 1) {\n\t\t\t/* :fb option sets it to 2 */\n\t\t\tif (default_visual->class == StaticGray) {\n\t\t\t\t/*\n\t\t\t\t * StaticGray can be blended OK, otherwise\n\t\t\t\t * user can disable with :nb\n\t\t\t\t */\n\t\t\t\t;\n\t\t\t} else {\n\t\t\t\tscaling_blend = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (cmap8to24 && cmap8to24_fb) {\n\t\tsrc_fb = cmap8to24_fb;\n\t\tif (scaling) {\n\t\t\tif (depth <= 8) {\n\t\t\t\tfac = 4;\n\t\t\t} else if (depth <= 16) {\n\t\t\t\tfac = 2;\n\t\t\t}\n\t\t}\n\t}\n\tdst_fb = rfb_fb;\n\tdst_bpl = rfb_bytes_per_line;\n\n\tscale_rect(scale_fac_x, scale_fac_y, scaling_blend, scaling_interpolate, fac * Bpp,\n\t    src_fb, fac * main_bytes_per_line, dst_fb, dst_bpl, dpy_x, dpy_y,\n\t    scaled_x, scaled_y, X1, Y1, X2, Y2, mark);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpp8to24",
          "args": [
            "x1",
            "y1",
            "x2",
            "y2"
          ],
          "line": 1674
        },
        "resolved": true,
        "details": {
          "function_name": "bpp8to24",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/8to24.c",
          "lines": "1809-2054",
          "snippet": "void bpp8to24(int x1, int y1, int x2, int y2) {\n\tchar *src, *dst;\n\tunsigned char *uc;\n\tunsigned short *us;\n\tunsigned int *ui;\n\tint idx, pixelsize = bpp/8;\n\tint line, k, i, j, h, w;\n\tint n_off;\n\tsraRegionPtr rect;\n\tint validate = 1;\n\tstatic int last_map_count = 0, call_count = 0;\n\tstatic double last_get_8bpp_validate = 0.0;\n\tstatic double last_snapshot = 0.0;\n\tdouble now;\n\tdouble dt, d0 = 0.0, t2;\n\n\tRAWFB_RET_VOID\n\n\tif (! cmap8to24 || ! cmap8to24_fb) {\n\t\t/* hmmm, why were we called? */\n\t\treturn;\n\t}\n\nif (db24 > 1) fprintf(stderr, \"bpp8to24 %d %d %d %d %.4f\\n\", x1, y1, x2, y2, dnow() - last_get_8bpp_validate);\n\n\tcall_count++;\n\n\t/* clip to display just in case: */\n\tif (!ncache) {\n\t\tx1 = nfix(x1, dpy_x);\n\t\ty1 = nfix(y1, dpy_y);\n\t\tx2 = nfix(x2, dpy_x+1);\n\t\ty2 = nfix(y2, dpy_y+1);\n\t}\n\n\tif (wireframe_in_progress) {\n\t\t/*\n\t\t * draw_box() manages cmap8to24_fb for us so we get out as\n\t\t * soon as we can.  No need to cp main_fb -> cmap8to24_fb.\n\t\t */\n\t\treturn;\n\t}\n\n\t/* copy from main_fb to cmap8to24_fb regardless of 8bpp windows: */\n\n\th = y2 - y1;\n\tw = x2 - x1;\n\n\tif (depth == 24) {\n\t\t/* pixelsize = 4 */\n\t\tn_off = main_bytes_per_line * y1 + pixelsize * x1;\n\n\t\tsrc = main_fb      + n_off;\n\t\tdst = cmap8to24_fb + n_off;\n\n\t\t/* otherwise, the pixel data as is */\n\t\tfor (line = 0; line < h; line++) {\n\t\t\tmemcpy(dst, src, w * pixelsize);\n\t\t\tsrc += main_bytes_per_line;\n\t\t\tdst += main_bytes_per_line;\n\t\t}\n\t} else if (depth <= 16) {\n\t\t/* need to cook up to depth 24 TrueColor  */\n\t\tint ps1 = 1, ps2 = 4;\n\t\tif (depth > 8) {\n\t\t\tps1 = 2;\n\t\t}\n\n\t\t/* pixelsize = 1, 2 */\n\t\tn_off = main_bytes_per_line * y1 + pixelsize * x1;\n\n\t\tsrc = main_fb + n_off;\n\t\tdst = cmap8to24_fb + (4/ps1) * n_off;\n\n\t\tset_root_cmap();\n\t\tif (root_cmap) {\n#if 0\n\t\t\tunsigned int hi;\n#endif\n\n\t\t\t/* line by line ... */\n\t\t\tfor (line = 0; line < h; line++) {\n\t\t\t\t/* pixel by pixel... */\n\t\t\t\tfor (j = 0; j < w; j++) {\n\t\t\t\t\tif (ps1 == 2) {\n\t\t\t\t\t\tus = (unsigned short *) (src + ps1 * j);\n\t\t\t\t\t\tidx = (int) (*us);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tuc = (unsigned char *)  (src + ps1 * j);\n\t\t\t\t\t\tidx = (int) (*uc);\n\t\t\t\t\t}\n\t\t\t\t\tui = (unsigned int *)  (dst + ps2 * j);\n\nif (0 && line % 100 == 0 && j % 32 == 0) fprintf(stderr, \"%d %d %u  x1=%d y1=%d\\n\", line, j, root_rgb[idx], x1, y1);\n#if 0\n\t\t\t\t\tif (do_hibits) {\n\t\t\t\t\t\thi = idx << 24;\n\t\t\t\t\t\t*ui = hi | rgb[0][idx];\n\t\t\t\t\t} else {\n\t\t\t\t\t}\n#endif\n\t\t\t\t\t*ui = root_rgb[idx];\nif (db24 > 2) histo[idx]++;\n\t\t\t\t}\n\t\t\t\tsrc += main_bytes_per_line;\n\t\t\t\tdst += main_bytes_per_line * (4/ps1);\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\n\tif (last_map_count > MAX_8BPP_WINDOWS/4) {\n\t\t/* table is filling up... skip validating sometimes: */\n\t\tint skip = 3;\n\t\tif (last_map_count > MAX_8BPP_WINDOWS/2) {\n\t\t\tskip = 6;\n\t\t} else if (last_map_count > 3*MAX_8BPP_WINDOWS/4) {\n\t\t\tskip = 12;\n\t\t}\n\t\tif (call_count % skip != 0) {\n\t\t\tvalidate = 0;\n\t\t}\n\t}\n\nif (db24 > 2) {for(i=0;i<256;i++){histo[i]=0;}}\n\n\tnow = dnow();\n\tdt = now - last_get_8bpp_validate;\n\t/* TUNABLES  */\n\tif (dt < 0.003) {\n\t\t;\t/* XXX does this still give painting errors? */\n\t} else {\n\t\tint snapit = 0;\n\t\tdouble delay1, delay2, delay3;\n\t\tif (poll_8to24_delay >= POLL_8TO24_DELAY) {\n\t\t\tdelay1 = 1.0 * poll_8to24_delay;\n\t\t\tdelay2 = 2.0 * poll_8to24_delay;\n\t\t\tdelay3 = 10. * poll_8to24_delay;\n\t\t} else {\n\t\t\tdelay1 = 1.0 * POLL_8TO24_DELAY;\t/* 0.05 */\n\t\t\tdelay2 = 2.0 * POLL_8TO24_DELAY;\t/* 0.1  */\n\t\t\tdelay3 = 10. * POLL_8TO24_DELAY;\t/* 0.5  */\n\t\t}\n\t\tif (cache_win > 1.0) {\n\t\t\tdelay2 *= 2;\n\t\t\tdelay3 *= 2;\n\t\t}\n\t\tif (dt < delay1) {\n\t\t\tvalidate = 0;\n\t\t}\n\t\tif (last_map_count) {\n\t\t\tif (now > last_snapshot + delay2) {\n\t\t\t\tsnapit = 1;\n\t\t\t}\n\t\t} else {\n\t\t\tif (now > last_snapshot + delay3) {\n\t\t\t\tsnapit = 1;\n\t\t\t}\n\t\t}\n\n\t\tif (snapit) {\n\t\t\t/* less problems if we update the stack frequently */\n\t\t\tsnapshot_stack_list(0, 0.0);\nif (0) fprintf(stderr, \"SNAP time: %.4f\\n\", dnow() - now);\n\t\t\tupdate_stack_list();\n\t\t\tlast_snapshot = dnow();\nif (0) fprintf(stderr, \"UPDA time: %.4f\\n\", last_snapshot - now);\n\t\t}\n\nif (0) t2 = dnow();\n\t\tlast_map_count = get_8bpp_regions(validate);\n\t\tif (validate) {\n\t\t\tlast_get_8bpp_validate = dnow();\n\t\t}\nif (0) fprintf(stderr, \"get8bpp-%d: %.4f\\n\", validate, dnow() - t2);\n\t}\nif (db24) d0 = dnow();\n\nif (db24 > 1) fprintf(stderr, \"bpp8to24 w=%d h=%d m=%p c=%p r=%p ncmaps=%d\\n\", w, h, main_fb, cmap8to24_fb, rfb_fb, ncmaps);\n\n\t/*\n\t * now go back and transform and 8bpp regions to TrueColor in\n\t * cmap8to24_fb.\n\t */\n\tif (last_map_count && (ncmaps || depth <= 16)) {\n\t\tint i, j;\n\t\tint win[MAX_8BPP_WINDOWS];\n\t\tint did[MAX_8BPP_WINDOWS];\n\t\tint count = 0;\n\n\t\t/*\n\t\t * first, grab all of the associated colormaps from the\n\t\t * X server.  Hopefully just 1 or 2...\n\t\t */\n\t\tfor (j=0; j<ncmaps; j++) {\n\t\t\tif (! get_cmap(j, cmaps[j])) {\n\t\t\t\tcmap_failed[j] = 1;\n\t\t\t} else {\n\t\t\t\tcmap_failed[j] = 0;\n\t\t\t}\nif (db24 > 2) fprintf(stderr, \"cmap %d  %.4f\\n\", (int) cmaps[j], dnow() - d0);\n\t\t}\n\t\tfor (i=0; i < MAX_8BPP_WINDOWS; i++) {\n\t\t\tsraRegionPtr reg = windows_8bpp[i].clip_region;\n\t\t\tif (reg) {\n\t\t\t\trect = sraRgnCreateRect(x1, y1, x2, y2);\n\t\t\t\tif (sraRgnAnd(rect, reg)) {\n\t\t\t\t\twin[count] = i;\n\t\t\t\t\tdid[count++] = 0;\n\t\t\t\t}\n\t\t\t\tsraRgnDestroy(rect);\n\t\t\t}\n\t\t}\n\n\t\tif (count) {\n\n\t\t\trect = sraRgnCreateRect(x1, y1, x2, y2);\n\t\t\t/* try to apply lower windows first */\n\t\t\tfor (k=0; k < stack_list_num; k++) {\n\t\t\t\tWindow swin = stack_list[k].win;\n\t\t\t\tfor (j=0; j<count; j++) {\n\t\t\t\t\ti = win[j];\n\t\t\t\t\tif (did[j]) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (windows_8bpp[i].top == swin) {\n\t\t\t\t\t\tdo_8bpp_region(i, rect);\n\t\t\t\t\t\tdid[j] = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (j=0; j<count; j++) {\n\t\t\t\tif (! did[j]) {\n\t\t\t\t\ti = win[j];\n\t\t\t\t\tdo_8bpp_region(i, rect);\n\t\t\t\t\tdid[j] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsraRgnDestroy(rect);\n\t\t}\n\t}\nif (0) fprintf(stderr, \"done time: %.4f\\n\", dnow() - d0);\n\nif (db24 > 2) {for(i=0; i<256;i++) {fprintf(stderr, \" cmap histo[%03d] %d\\n\", i, histo[i]);}}\n}",
          "includes": [
            "#include \"xwrappers.h\"",
            "#include \"win_utils.h\"",
            "#include \"util.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define MAX_8BPP_WINDOWS 64"
          ],
          "globals_used": [
            "void bpp8to24(int, int, int, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xwrappers.h\"\n#include \"win_utils.h\"\n#include \"util.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\n#define MAX_8BPP_WINDOWS 64\n\nvoid bpp8to24(int, int, int, int);\n\nvoid bpp8to24(int x1, int y1, int x2, int y2) {\n\tchar *src, *dst;\n\tunsigned char *uc;\n\tunsigned short *us;\n\tunsigned int *ui;\n\tint idx, pixelsize = bpp/8;\n\tint line, k, i, j, h, w;\n\tint n_off;\n\tsraRegionPtr rect;\n\tint validate = 1;\n\tstatic int last_map_count = 0, call_count = 0;\n\tstatic double last_get_8bpp_validate = 0.0;\n\tstatic double last_snapshot = 0.0;\n\tdouble now;\n\tdouble dt, d0 = 0.0, t2;\n\n\tRAWFB_RET_VOID\n\n\tif (! cmap8to24 || ! cmap8to24_fb) {\n\t\t/* hmmm, why were we called? */\n\t\treturn;\n\t}\n\nif (db24 > 1) fprintf(stderr, \"bpp8to24 %d %d %d %d %.4f\\n\", x1, y1, x2, y2, dnow() - last_get_8bpp_validate);\n\n\tcall_count++;\n\n\t/* clip to display just in case: */\n\tif (!ncache) {\n\t\tx1 = nfix(x1, dpy_x);\n\t\ty1 = nfix(y1, dpy_y);\n\t\tx2 = nfix(x2, dpy_x+1);\n\t\ty2 = nfix(y2, dpy_y+1);\n\t}\n\n\tif (wireframe_in_progress) {\n\t\t/*\n\t\t * draw_box() manages cmap8to24_fb for us so we get out as\n\t\t * soon as we can.  No need to cp main_fb -> cmap8to24_fb.\n\t\t */\n\t\treturn;\n\t}\n\n\t/* copy from main_fb to cmap8to24_fb regardless of 8bpp windows: */\n\n\th = y2 - y1;\n\tw = x2 - x1;\n\n\tif (depth == 24) {\n\t\t/* pixelsize = 4 */\n\t\tn_off = main_bytes_per_line * y1 + pixelsize * x1;\n\n\t\tsrc = main_fb      + n_off;\n\t\tdst = cmap8to24_fb + n_off;\n\n\t\t/* otherwise, the pixel data as is */\n\t\tfor (line = 0; line < h; line++) {\n\t\t\tmemcpy(dst, src, w * pixelsize);\n\t\t\tsrc += main_bytes_per_line;\n\t\t\tdst += main_bytes_per_line;\n\t\t}\n\t} else if (depth <= 16) {\n\t\t/* need to cook up to depth 24 TrueColor  */\n\t\tint ps1 = 1, ps2 = 4;\n\t\tif (depth > 8) {\n\t\t\tps1 = 2;\n\t\t}\n\n\t\t/* pixelsize = 1, 2 */\n\t\tn_off = main_bytes_per_line * y1 + pixelsize * x1;\n\n\t\tsrc = main_fb + n_off;\n\t\tdst = cmap8to24_fb + (4/ps1) * n_off;\n\n\t\tset_root_cmap();\n\t\tif (root_cmap) {\n#if 0\n\t\t\tunsigned int hi;\n#endif\n\n\t\t\t/* line by line ... */\n\t\t\tfor (line = 0; line < h; line++) {\n\t\t\t\t/* pixel by pixel... */\n\t\t\t\tfor (j = 0; j < w; j++) {\n\t\t\t\t\tif (ps1 == 2) {\n\t\t\t\t\t\tus = (unsigned short *) (src + ps1 * j);\n\t\t\t\t\t\tidx = (int) (*us);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tuc = (unsigned char *)  (src + ps1 * j);\n\t\t\t\t\t\tidx = (int) (*uc);\n\t\t\t\t\t}\n\t\t\t\t\tui = (unsigned int *)  (dst + ps2 * j);\n\nif (0 && line % 100 == 0 && j % 32 == 0) fprintf(stderr, \"%d %d %u  x1=%d y1=%d\\n\", line, j, root_rgb[idx], x1, y1);\n#if 0\n\t\t\t\t\tif (do_hibits) {\n\t\t\t\t\t\thi = idx << 24;\n\t\t\t\t\t\t*ui = hi | rgb[0][idx];\n\t\t\t\t\t} else {\n\t\t\t\t\t}\n#endif\n\t\t\t\t\t*ui = root_rgb[idx];\nif (db24 > 2) histo[idx]++;\n\t\t\t\t}\n\t\t\t\tsrc += main_bytes_per_line;\n\t\t\t\tdst += main_bytes_per_line * (4/ps1);\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\n\tif (last_map_count > MAX_8BPP_WINDOWS/4) {\n\t\t/* table is filling up... skip validating sometimes: */\n\t\tint skip = 3;\n\t\tif (last_map_count > MAX_8BPP_WINDOWS/2) {\n\t\t\tskip = 6;\n\t\t} else if (last_map_count > 3*MAX_8BPP_WINDOWS/4) {\n\t\t\tskip = 12;\n\t\t}\n\t\tif (call_count % skip != 0) {\n\t\t\tvalidate = 0;\n\t\t}\n\t}\n\nif (db24 > 2) {for(i=0;i<256;i++){histo[i]=0;}}\n\n\tnow = dnow();\n\tdt = now - last_get_8bpp_validate;\n\t/* TUNABLES  */\n\tif (dt < 0.003) {\n\t\t;\t/* XXX does this still give painting errors? */\n\t} else {\n\t\tint snapit = 0;\n\t\tdouble delay1, delay2, delay3;\n\t\tif (poll_8to24_delay >= POLL_8TO24_DELAY) {\n\t\t\tdelay1 = 1.0 * poll_8to24_delay;\n\t\t\tdelay2 = 2.0 * poll_8to24_delay;\n\t\t\tdelay3 = 10. * poll_8to24_delay;\n\t\t} else {\n\t\t\tdelay1 = 1.0 * POLL_8TO24_DELAY;\t/* 0.05 */\n\t\t\tdelay2 = 2.0 * POLL_8TO24_DELAY;\t/* 0.1  */\n\t\t\tdelay3 = 10. * POLL_8TO24_DELAY;\t/* 0.5  */\n\t\t}\n\t\tif (cache_win > 1.0) {\n\t\t\tdelay2 *= 2;\n\t\t\tdelay3 *= 2;\n\t\t}\n\t\tif (dt < delay1) {\n\t\t\tvalidate = 0;\n\t\t}\n\t\tif (last_map_count) {\n\t\t\tif (now > last_snapshot + delay2) {\n\t\t\t\tsnapit = 1;\n\t\t\t}\n\t\t} else {\n\t\t\tif (now > last_snapshot + delay3) {\n\t\t\t\tsnapit = 1;\n\t\t\t}\n\t\t}\n\n\t\tif (snapit) {\n\t\t\t/* less problems if we update the stack frequently */\n\t\t\tsnapshot_stack_list(0, 0.0);\nif (0) fprintf(stderr, \"SNAP time: %.4f\\n\", dnow() - now);\n\t\t\tupdate_stack_list();\n\t\t\tlast_snapshot = dnow();\nif (0) fprintf(stderr, \"UPDA time: %.4f\\n\", last_snapshot - now);\n\t\t}\n\nif (0) t2 = dnow();\n\t\tlast_map_count = get_8bpp_regions(validate);\n\t\tif (validate) {\n\t\t\tlast_get_8bpp_validate = dnow();\n\t\t}\nif (0) fprintf(stderr, \"get8bpp-%d: %.4f\\n\", validate, dnow() - t2);\n\t}\nif (db24) d0 = dnow();\n\nif (db24 > 1) fprintf(stderr, \"bpp8to24 w=%d h=%d m=%p c=%p r=%p ncmaps=%d\\n\", w, h, main_fb, cmap8to24_fb, rfb_fb, ncmaps);\n\n\t/*\n\t * now go back and transform and 8bpp regions to TrueColor in\n\t * cmap8to24_fb.\n\t */\n\tif (last_map_count && (ncmaps || depth <= 16)) {\n\t\tint i, j;\n\t\tint win[MAX_8BPP_WINDOWS];\n\t\tint did[MAX_8BPP_WINDOWS];\n\t\tint count = 0;\n\n\t\t/*\n\t\t * first, grab all of the associated colormaps from the\n\t\t * X server.  Hopefully just 1 or 2...\n\t\t */\n\t\tfor (j=0; j<ncmaps; j++) {\n\t\t\tif (! get_cmap(j, cmaps[j])) {\n\t\t\t\tcmap_failed[j] = 1;\n\t\t\t} else {\n\t\t\t\tcmap_failed[j] = 0;\n\t\t\t}\nif (db24 > 2) fprintf(stderr, \"cmap %d  %.4f\\n\", (int) cmaps[j], dnow() - d0);\n\t\t}\n\t\tfor (i=0; i < MAX_8BPP_WINDOWS; i++) {\n\t\t\tsraRegionPtr reg = windows_8bpp[i].clip_region;\n\t\t\tif (reg) {\n\t\t\t\trect = sraRgnCreateRect(x1, y1, x2, y2);\n\t\t\t\tif (sraRgnAnd(rect, reg)) {\n\t\t\t\t\twin[count] = i;\n\t\t\t\t\tdid[count++] = 0;\n\t\t\t\t}\n\t\t\t\tsraRgnDestroy(rect);\n\t\t\t}\n\t\t}\n\n\t\tif (count) {\n\n\t\t\trect = sraRgnCreateRect(x1, y1, x2, y2);\n\t\t\t/* try to apply lower windows first */\n\t\t\tfor (k=0; k < stack_list_num; k++) {\n\t\t\t\tWindow swin = stack_list[k].win;\n\t\t\t\tfor (j=0; j<count; j++) {\n\t\t\t\t\ti = win[j];\n\t\t\t\t\tif (did[j]) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (windows_8bpp[i].top == swin) {\n\t\t\t\t\t\tdo_8bpp_region(i, rect);\n\t\t\t\t\t\tdid[j] = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (j=0; j<count; j++) {\n\t\t\t\tif (! did[j]) {\n\t\t\t\t\ti = win[j];\n\t\t\t\t\tdo_8bpp_region(i, rect);\n\t\t\t\t\tdid[j] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsraRgnDestroy(rect);\n\t\t}\n\t}\nif (0) fprintf(stderr, \"done time: %.4f\\n\", dnow() - d0);\n\nif (db24 > 2) {for(i=0; i<256;i++) {fprintf(stderr, \" cmap histo[%03d] %d\\n\", i, histo[i]);}}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"damaging viewer fb by not marking \"\n\t\t\t\t    \"rect: %d,%d,%d,%d\\n\"",
            "x1",
            "y1",
            "x2",
            "y2"
          ],
          "line": 1660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"damaging turned off.\\n\""
          ],
          "line": 1654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time",
          "args": [
            "NULL"
          ],
          "line": 1652
        },
        "resolved": true,
        "details": {
          "function_name": "csock_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "3270-3276",
          "snippet": "static void csock_timeout (int sig) {\n\trfbLog(\"sig: %d, csock_timeout.\\n\", sig);\n\tif (csock_timeout_sock >= 0) {\n\t\tclose(csock_timeout_sock);\n\t\tcsock_timeout_sock = -1;\n\t}\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int csock_timeout_sock = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nstatic int csock_timeout_sock = -1;\n\nstatic void csock_timeout (int sig) {\n\trfbLog(\"sig: %d, csock_timeout.\\n\", sig);\n\tif (csock_timeout_sock >= 0) {\n\t\tclose(csock_timeout_sock);\n\t\tcsock_timeout_sock = -1;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <default8x16.h>\n#include \"userinput.h\"\n#include \"macosx.h\"\n#include \"screen.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"8to24.h\"\n#include \"win_utils.h\"\n#include \"xrandr.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nvoid mark_rect_as_modified(int x1, int y1, int x2, int y2, int force);\n\nvoid mark_rect_as_modified(int x1, int y1, int x2, int y2, int force) {\n\n\tif (damage_time != 0) {\n\t\t/*\n\t\t * This is not XDAMAGE, rather a hack for testing\n\t\t * where we allow the framebuffer to be corrupted for\n\t\t * damage_delay seconds.\n\t\t */\n\t\tint debug = 0;\n\t\tif (time(NULL) > damage_time + damage_delay) {\n\t\t\tif (! quiet) {\n\t\t\t\trfbLog(\"damaging turned off.\\n\");\n\t\t\t}\n\t\t\tdamage_time = 0;\n\t\t\tdamage_delay = 0;\n\t\t} else {\n\t\t\tif (debug) {\n\t\t\t\trfbLog(\"damaging viewer fb by not marking \"\n\t\t\t\t    \"rect: %d,%d,%d,%d\\n\", x1, y1, x2, y2);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n\n\n\tif (rfb_fb == main_fb || force) {\n\t\tmark_wrapper(x1, y1, x2, y2);\n\t\treturn;\n\t}\n\n\tif (cmap8to24) {\n\t\tbpp8to24(x1, y1, x2, y2);\n\t}\n\n\tif (scaling) {\n\t\tscale_and_mark_rect(x1, y1, x2, y2, 1);\n\t} else {\n\t\tmark_wrapper(x1, y1, x2, y2);\n\t}\n}"
  },
  {
    "function_name": "mark_wrapper",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/scan.c",
    "lines": "1616-1641",
    "snippet": "void mark_wrapper(int x1, int y1, int x2, int y2) {\n\tint t, r_x1 = x1, r_y1 = y1, r_x2 = x2, r_y2 = y2;\n\n\tif (rotating) {\n\t\t/* well we hope rot_fb will always be the last one... */\n\t\trotate_coords(x1, y1, &r_x1, &r_y1, -1, -1);\n\t\trotate_coords(x2, y2, &r_x2, &r_y2, -1, -1);\n\t\trotate_fb(x1, y1, x2, y2);\n\t\tif (r_x1 > r_x2) {\n\t\t\tt = r_x1;\n\t\t\tr_x1 = r_x2;\n\t\t\tr_x2 = t;\n\t\t}\n\t\tif (r_y1 > r_y2) {\n\t\t\tt = r_y1;\n\t\t\tr_y1 = r_y2;\n\t\t\tr_y2 = t;\n\t\t}\n\t\t/* painting errors  */\n\t\tr_x1--;\n\t\tr_x2++;\n\t\tr_y1--;\n\t\tr_y2++;\n\t}\n\trfbMarkRectAsModified(screen, r_x1, r_y1, r_x2, r_y2);\n}",
    "includes": [
      "#include <default8x16.h>",
      "#include \"userinput.h\"",
      "#include \"macosx.h\"",
      "#include \"screen.h\"",
      "#include \"unixpw.h\"",
      "#include \"cleanup.h\"",
      "#include \"pointer.h\"",
      "#include \"screen.h\"",
      "#include \"8to24.h\"",
      "#include \"win_utils.h\"",
      "#include \"xrandr.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"xinerama.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rfbMarkRectAsModified",
          "args": [
            "screen",
            "r_x1",
            "r_y1",
            "r_x2",
            "r_y2"
          ],
          "line": 1640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rotate_fb",
          "args": [
            "x1",
            "y1",
            "x2",
            "y2"
          ],
          "line": 1623
        },
        "resolved": true,
        "details": {
          "function_name": "rotate_fb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/scan.c",
          "lines": "1456-1538",
          "snippet": "void rotate_fb(int x1, int y1, int x2, int y2) {\n\tint x, y, xn, yn, r_x1, r_y1, r_x2, r_y2, Bpp = bpp/8;\n\tint fbl = rfb_bytes_per_line;\n\tint rbl = rot_bytes_per_line;\n\tint Dx, Dy;\n\tchar *src, *dst;\n\tchar *src_0 = rfb_fb;\n\tchar *dst_0 = rot_fb;\n\n\tif (! rotating || ! rot_fb) {\n\t\treturn;\n\t}\n\n\tif (scaling) {\n\t\tDx = scaled_x;\n\t\tDy = scaled_y;\n\t} else {\n\t\tDx = dpy_x;\n\t\tDy = dpy_y;\n\t}\n\trotate_coords(x1, y1, &r_x1, &r_y1, -1, -1);\n\trotate_coords(x2, y2, &r_x2, &r_y2, -1, -1);\n\n\tdst = rot_fb;\n\n\tif (rotating == ROTATE_X) {\n\t\tfor (y = y1; y < y2; y++)  {\n\t\t\tfor (x = x1; x < x2; x++)  {\n\t\t\t\txn = Dx - x - 1;\n\t\t\t\tyn = y;\n\t\t\t\tROT_COPY\n\t\t\t}\n\t\t}\n\t} else if (rotating == ROTATE_Y) {\n\t\tfor (y = y1; y < y2; y++)  {\n\t\t\tfor (x = x1; x < x2; x++)  {\n\t\t\t\txn = x;\n\t\t\t\tyn = Dy - y - 1;\n\t\t\t\tROT_COPY\n\t\t\t}\n\t\t}\n\t} else if (rotating == ROTATE_XY) {\n\t\tfor (y = y1; y < y2; y++)  {\n\t\t\tfor (x = x1; x < x2; x++)  {\n\t\t\t\txn = Dx - x - 1;\n\t\t\t\tyn = Dy - y - 1;\n\t\t\t\tROT_COPY\n\t\t\t}\n\t\t}\n\t} else if (rotating == ROTATE_90) {\n\t\tfor (y = y1; y < y2; y++)  {\n\t\t\tfor (x = x1; x < x2; x++)  {\n\t\t\t\txn = Dy - y - 1;\n\t\t\t\tyn = x;\n\t\t\t\tROT_COPY\n\t\t\t}\n\t\t}\n\t} else if (rotating == ROTATE_90X) {\n\t\tfor (y = y1; y < y2; y++)  {\n\t\t\tfor (x = x1; x < x2; x++)  {\n\t\t\t\txn = y;\n\t\t\t\tyn = x;\n\t\t\t\tROT_COPY\n\t\t\t}\n\t\t}\n\t} else if (rotating == ROTATE_90Y) {\n\t\tfor (y = y1; y < y2; y++)  {\n\t\t\tfor (x = x1; x < x2; x++)  {\n\t\t\t\txn = Dy - y - 1;\n\t\t\t\tyn = Dx - x - 1;\n\t\t\t\tROT_COPY\n\t\t\t}\n\t\t}\n\t} else if (rotating == ROTATE_270) {\n\t\tfor (y = y1; y < y2; y++)  {\n\t\t\tfor (x = x1; x < x2; x++)  {\n\t\t\t\txn = y;\n\t\t\t\tyn = Dx - x - 1;\n\t\t\t\tROT_COPY\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include <default8x16.h>",
            "#include \"userinput.h\"",
            "#include \"macosx.h\"",
            "#include \"screen.h\"",
            "#include \"unixpw.h\"",
            "#include \"cleanup.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"8to24.h\"",
            "#include \"win_utils.h\"",
            "#include \"xrandr.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define ROT_COPY \\\n\tsrc = src_0 + fbl*y  + Bpp*x;  \\\n\tdst = dst_0 + rbl*yn + Bpp*xn; \\\n\tif (Bpp == 1) { \\\n\t\t*(dst) = *(src);\t \\\n\t} else if (Bpp == 2) { \\\n\t\t*(dst+0) = *(src+0);\t \\\n\t\t*(dst+1) = *(src+1);\t \\\n\t} else if (Bpp == 3) { \\\n\t\t*(dst+0) = *(src+0);\t \\\n\t\t*(dst+1) = *(src+1);\t \\\n\t\t*(dst+2) = *(src+2);\t \\\n\t} else if (Bpp == 4) { \\\n\t\t*(dst+0) = *(src+0);\t \\\n\t\t*(dst+1) = *(src+1);\t \\\n\t\t*(dst+2) = *(src+2);\t \\\n\t\t*(dst+3) = *(src+3);\t \\\n\t}"
          ],
          "globals_used": [
            "void rotate_curs(char *dst_0, char *src_0, int Dx, int Dy, int Bpp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <default8x16.h>\n#include \"userinput.h\"\n#include \"macosx.h\"\n#include \"screen.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"8to24.h\"\n#include \"win_utils.h\"\n#include \"xrandr.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\n#define ROT_COPY \\\n\tsrc = src_0 + fbl*y  + Bpp*x;  \\\n\tdst = dst_0 + rbl*yn + Bpp*xn; \\\n\tif (Bpp == 1) { \\\n\t\t*(dst) = *(src);\t \\\n\t} else if (Bpp == 2) { \\\n\t\t*(dst+0) = *(src+0);\t \\\n\t\t*(dst+1) = *(src+1);\t \\\n\t} else if (Bpp == 3) { \\\n\t\t*(dst+0) = *(src+0);\t \\\n\t\t*(dst+1) = *(src+1);\t \\\n\t\t*(dst+2) = *(src+2);\t \\\n\t} else if (Bpp == 4) { \\\n\t\t*(dst+0) = *(src+0);\t \\\n\t\t*(dst+1) = *(src+1);\t \\\n\t\t*(dst+2) = *(src+2);\t \\\n\t\t*(dst+3) = *(src+3);\t \\\n\t}\n\nvoid rotate_curs(char *dst_0, char *src_0, int Dx, int Dy, int Bpp);\n\nvoid rotate_fb(int x1, int y1, int x2, int y2) {\n\tint x, y, xn, yn, r_x1, r_y1, r_x2, r_y2, Bpp = bpp/8;\n\tint fbl = rfb_bytes_per_line;\n\tint rbl = rot_bytes_per_line;\n\tint Dx, Dy;\n\tchar *src, *dst;\n\tchar *src_0 = rfb_fb;\n\tchar *dst_0 = rot_fb;\n\n\tif (! rotating || ! rot_fb) {\n\t\treturn;\n\t}\n\n\tif (scaling) {\n\t\tDx = scaled_x;\n\t\tDy = scaled_y;\n\t} else {\n\t\tDx = dpy_x;\n\t\tDy = dpy_y;\n\t}\n\trotate_coords(x1, y1, &r_x1, &r_y1, -1, -1);\n\trotate_coords(x2, y2, &r_x2, &r_y2, -1, -1);\n\n\tdst = rot_fb;\n\n\tif (rotating == ROTATE_X) {\n\t\tfor (y = y1; y < y2; y++)  {\n\t\t\tfor (x = x1; x < x2; x++)  {\n\t\t\t\txn = Dx - x - 1;\n\t\t\t\tyn = y;\n\t\t\t\tROT_COPY\n\t\t\t}\n\t\t}\n\t} else if (rotating == ROTATE_Y) {\n\t\tfor (y = y1; y < y2; y++)  {\n\t\t\tfor (x = x1; x < x2; x++)  {\n\t\t\t\txn = x;\n\t\t\t\tyn = Dy - y - 1;\n\t\t\t\tROT_COPY\n\t\t\t}\n\t\t}\n\t} else if (rotating == ROTATE_XY) {\n\t\tfor (y = y1; y < y2; y++)  {\n\t\t\tfor (x = x1; x < x2; x++)  {\n\t\t\t\txn = Dx - x - 1;\n\t\t\t\tyn = Dy - y - 1;\n\t\t\t\tROT_COPY\n\t\t\t}\n\t\t}\n\t} else if (rotating == ROTATE_90) {\n\t\tfor (y = y1; y < y2; y++)  {\n\t\t\tfor (x = x1; x < x2; x++)  {\n\t\t\t\txn = Dy - y - 1;\n\t\t\t\tyn = x;\n\t\t\t\tROT_COPY\n\t\t\t}\n\t\t}\n\t} else if (rotating == ROTATE_90X) {\n\t\tfor (y = y1; y < y2; y++)  {\n\t\t\tfor (x = x1; x < x2; x++)  {\n\t\t\t\txn = y;\n\t\t\t\tyn = x;\n\t\t\t\tROT_COPY\n\t\t\t}\n\t\t}\n\t} else if (rotating == ROTATE_90Y) {\n\t\tfor (y = y1; y < y2; y++)  {\n\t\t\tfor (x = x1; x < x2; x++)  {\n\t\t\t\txn = Dy - y - 1;\n\t\t\t\tyn = Dx - x - 1;\n\t\t\t\tROT_COPY\n\t\t\t}\n\t\t}\n\t} else if (rotating == ROTATE_270) {\n\t\tfor (y = y1; y < y2; y++)  {\n\t\t\tfor (x = x1; x < x2; x++)  {\n\t\t\t\txn = y;\n\t\t\t\tyn = Dx - x - 1;\n\t\t\t\tROT_COPY\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rotate_coords",
          "args": [
            "x2",
            "y2",
            "&r_x2",
            "&r_y2",
            "-1",
            "-1"
          ],
          "line": 1622
        },
        "resolved": true,
        "details": {
          "function_name": "rotate_coords_inverse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/scan.c",
          "lines": "1388-1434",
          "snippet": "void rotate_coords_inverse(int x, int y, int *xo, int *yo, int dxi, int dyi) {\n\tint xi = x, yi = y;\n\n\tint Dx, Dy;\n\n\tif (dxi >= 0) {\n\t\tDx = dxi;\n\t\tDy = dyi;\n\t} else if (scaling) {\n\t\tDx = scaled_x;\n\t\tDy = scaled_y;\n\t} else {\n\t\tDx = dpy_x;\n\t\tDy = dpy_y;\n\t}\n\tif (! rotating_same) {\n\t\tint t = Dx;\n\t\tDx = Dy;\n\t\tDy = t;\n\t}\n\n\tif (rotating == ROTATE_NONE) {\n\t\t*xo = xi;\n\t\t*yo = yi;\n\t} else if (rotating == ROTATE_X) {\n\t\t*xo = Dx - xi - 1;\n\t\t*yo = yi;\n\t} else if (rotating == ROTATE_Y) {\n\t\t*xo = xi;\n\t\t*yo = Dy - yi - 1;\n\t} else if (rotating == ROTATE_XY) {\n\t\t*xo = Dx - xi - 1;\n\t\t*yo = Dy - yi - 1;\n\t} else if (rotating == ROTATE_90) {\n\t\t*xo = yi;\n\t\t*yo = Dx - xi - 1;\n\t} else if (rotating == ROTATE_90X) {\n\t\t*xo = yi;\n\t\t*yo = xi;\n\t} else if (rotating == ROTATE_90Y) {\n\t\t*xo = Dy - yi - 1;\n\t\t*yo = Dx - xi - 1;\n\t} else if (rotating == ROTATE_270) {\n\t\t*xo = Dy - yi - 1;\n\t\t*yo = xi;\n\t}\n}",
          "includes": [
            "#include <default8x16.h>",
            "#include \"userinput.h\"",
            "#include \"macosx.h\"",
            "#include \"screen.h\"",
            "#include \"unixpw.h\"",
            "#include \"cleanup.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"8to24.h\"",
            "#include \"win_utils.h\"",
            "#include \"xrandr.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void rotate_coords(int x, int y, int *xo, int *yo, int dxi, int dyi);",
            "void rotate_coords_inverse(int x, int y, int *xo, int *yo, int dxi, int dyi);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <default8x16.h>\n#include \"userinput.h\"\n#include \"macosx.h\"\n#include \"screen.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"8to24.h\"\n#include \"win_utils.h\"\n#include \"xrandr.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nvoid rotate_coords(int x, int y, int *xo, int *yo, int dxi, int dyi);\nvoid rotate_coords_inverse(int x, int y, int *xo, int *yo, int dxi, int dyi);\n\nvoid rotate_coords_inverse(int x, int y, int *xo, int *yo, int dxi, int dyi) {\n\tint xi = x, yi = y;\n\n\tint Dx, Dy;\n\n\tif (dxi >= 0) {\n\t\tDx = dxi;\n\t\tDy = dyi;\n\t} else if (scaling) {\n\t\tDx = scaled_x;\n\t\tDy = scaled_y;\n\t} else {\n\t\tDx = dpy_x;\n\t\tDy = dpy_y;\n\t}\n\tif (! rotating_same) {\n\t\tint t = Dx;\n\t\tDx = Dy;\n\t\tDy = t;\n\t}\n\n\tif (rotating == ROTATE_NONE) {\n\t\t*xo = xi;\n\t\t*yo = yi;\n\t} else if (rotating == ROTATE_X) {\n\t\t*xo = Dx - xi - 1;\n\t\t*yo = yi;\n\t} else if (rotating == ROTATE_Y) {\n\t\t*xo = xi;\n\t\t*yo = Dy - yi - 1;\n\t} else if (rotating == ROTATE_XY) {\n\t\t*xo = Dx - xi - 1;\n\t\t*yo = Dy - yi - 1;\n\t} else if (rotating == ROTATE_90) {\n\t\t*xo = yi;\n\t\t*yo = Dx - xi - 1;\n\t} else if (rotating == ROTATE_90X) {\n\t\t*xo = yi;\n\t\t*yo = xi;\n\t} else if (rotating == ROTATE_90Y) {\n\t\t*xo = Dy - yi - 1;\n\t\t*yo = Dx - xi - 1;\n\t} else if (rotating == ROTATE_270) {\n\t\t*xo = Dy - yi - 1;\n\t\t*yo = xi;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <default8x16.h>\n#include \"userinput.h\"\n#include \"macosx.h\"\n#include \"screen.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"8to24.h\"\n#include \"win_utils.h\"\n#include \"xrandr.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nvoid mark_wrapper(int x1, int y1, int x2, int y2) {\n\tint t, r_x1 = x1, r_y1 = y1, r_x2 = x2, r_y2 = y2;\n\n\tif (rotating) {\n\t\t/* well we hope rot_fb will always be the last one... */\n\t\trotate_coords(x1, y1, &r_x1, &r_y1, -1, -1);\n\t\trotate_coords(x2, y2, &r_x2, &r_y2, -1, -1);\n\t\trotate_fb(x1, y1, x2, y2);\n\t\tif (r_x1 > r_x2) {\n\t\t\tt = r_x1;\n\t\t\tr_x1 = r_x2;\n\t\t\tr_x2 = t;\n\t\t}\n\t\tif (r_y1 > r_y2) {\n\t\t\tt = r_y1;\n\t\t\tr_y1 = r_y2;\n\t\t\tr_y2 = t;\n\t\t}\n\t\t/* painting errors  */\n\t\tr_x1--;\n\t\tr_x2++;\n\t\tr_y1--;\n\t\tr_y2++;\n\t}\n\trfbMarkRectAsModified(screen, r_x1, r_y1, r_x2, r_y2);\n}"
  },
  {
    "function_name": "rotate_curs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/scan.c",
    "lines": "1540-1614",
    "snippet": "void rotate_curs(char *dst_0, char *src_0, int Dx, int Dy, int Bpp) {\n\tint x, y, xn, yn;\n\tchar *src, *dst;\n\tint fbl, rbl;\n\n\tif (! rotating) {\n\t\treturn;\n\t}\n\n\tfbl = Dx * Bpp;\n\tif (rotating_same) {\n\t\trbl = Dx * Bpp;\n\t} else {\n\t\trbl = Dy * Bpp;\n\t}\n\n\tif (rotating == ROTATE_X) {\n\t\tfor (y = 0; y < Dy; y++)  {\n\t\t\tfor (x = 0; x < Dx; x++)  {\n\t\t\t\txn = Dx - x - 1;\n\t\t\t\tyn = y;\n\t\t\t\tROT_COPY\nif (0) fprintf(stderr, \"rcurs: %d %d  %d %d\\n\", x, y, xn, yn);\n\t\t\t}\n\t\t}\n\t} else if (rotating == ROTATE_Y) {\n\t\tfor (y = 0; y < Dy; y++)  {\n\t\t\tfor (x = 0; x < Dx; x++)  {\n\t\t\t\txn = x;\n\t\t\t\tyn = Dy - y - 1;\n\t\t\t\tROT_COPY\n\t\t\t}\n\t\t}\n\t} else if (rotating == ROTATE_XY) {\n\t\tfor (y = 0; y < Dy; y++)  {\n\t\t\tfor (x = 0; x < Dx; x++)  {\n\t\t\t\txn = Dx - x - 1;\n\t\t\t\tyn = Dy - y - 1;\n\t\t\t\tROT_COPY\n\t\t\t}\n\t\t}\n\t} else if (rotating == ROTATE_90) {\n\t\tfor (y = 0; y < Dy; y++)  {\n\t\t\tfor (x = 0; x < Dx; x++)  {\n\t\t\t\txn = Dy - y - 1;\n\t\t\t\tyn = x;\n\t\t\t\tROT_COPY\n\t\t\t}\n\t\t}\n\t} else if (rotating == ROTATE_90X) {\n\t\tfor (y = 0; y < Dy; y++)  {\n\t\t\tfor (x = 0; x < Dx; x++)  {\n\t\t\t\txn = y;\n\t\t\t\tyn = x;\n\t\t\t\tROT_COPY\n\t\t\t}\n\t\t}\n\t} else if (rotating == ROTATE_90Y) {\n\t\tfor (y = 0; y < Dy; y++)  {\n\t\t\tfor (x = 0; x < Dx; x++)  {\n\t\t\t\txn = Dy - y - 1;\n\t\t\t\tyn = Dx - x - 1;\n\t\t\t\tROT_COPY\n\t\t\t}\n\t\t}\n\t} else if (rotating == ROTATE_270) {\n\t\tfor (y = 0; y < Dy; y++)  {\n\t\t\tfor (x = 0; x < Dx; x++)  {\n\t\t\t\txn = y;\n\t\t\t\tyn = Dx - x - 1;\n\t\t\t\tROT_COPY\n\t\t\t}\n\t\t}\n\t}\n}",
    "includes": [
      "#include <default8x16.h>",
      "#include \"userinput.h\"",
      "#include \"macosx.h\"",
      "#include \"screen.h\"",
      "#include \"unixpw.h\"",
      "#include \"cleanup.h\"",
      "#include \"pointer.h\"",
      "#include \"screen.h\"",
      "#include \"8to24.h\"",
      "#include \"win_utils.h\"",
      "#include \"xrandr.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"xinerama.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [
      "#define ROT_COPY \\\n\tsrc = src_0 + fbl*y  + Bpp*x;  \\\n\tdst = dst_0 + rbl*yn + Bpp*xn; \\\n\tif (Bpp == 1) { \\\n\t\t*(dst) = *(src);\t \\\n\t} else if (Bpp == 2) { \\\n\t\t*(dst+0) = *(src+0);\t \\\n\t\t*(dst+1) = *(src+1);\t \\\n\t} else if (Bpp == 3) { \\\n\t\t*(dst+0) = *(src+0);\t \\\n\t\t*(dst+1) = *(src+1);\t \\\n\t\t*(dst+2) = *(src+2);\t \\\n\t} else if (Bpp == 4) { \\\n\t\t*(dst+0) = *(src+0);\t \\\n\t\t*(dst+1) = *(src+1);\t \\\n\t\t*(dst+2) = *(src+2);\t \\\n\t\t*(dst+3) = *(src+3);\t \\\n\t}"
    ],
    "globals_used": [
      "void rotate_curs(char *dst_0, char *src_0, int Dx, int Dy, int Bpp);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <default8x16.h>\n#include \"userinput.h\"\n#include \"macosx.h\"\n#include \"screen.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"8to24.h\"\n#include \"win_utils.h\"\n#include \"xrandr.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\n#define ROT_COPY \\\n\tsrc = src_0 + fbl*y  + Bpp*x;  \\\n\tdst = dst_0 + rbl*yn + Bpp*xn; \\\n\tif (Bpp == 1) { \\\n\t\t*(dst) = *(src);\t \\\n\t} else if (Bpp == 2) { \\\n\t\t*(dst+0) = *(src+0);\t \\\n\t\t*(dst+1) = *(src+1);\t \\\n\t} else if (Bpp == 3) { \\\n\t\t*(dst+0) = *(src+0);\t \\\n\t\t*(dst+1) = *(src+1);\t \\\n\t\t*(dst+2) = *(src+2);\t \\\n\t} else if (Bpp == 4) { \\\n\t\t*(dst+0) = *(src+0);\t \\\n\t\t*(dst+1) = *(src+1);\t \\\n\t\t*(dst+2) = *(src+2);\t \\\n\t\t*(dst+3) = *(src+3);\t \\\n\t}\n\nvoid rotate_curs(char *dst_0, char *src_0, int Dx, int Dy, int Bpp);\n\nvoid rotate_curs(char *dst_0, char *src_0, int Dx, int Dy, int Bpp) {\n\tint x, y, xn, yn;\n\tchar *src, *dst;\n\tint fbl, rbl;\n\n\tif (! rotating) {\n\t\treturn;\n\t}\n\n\tfbl = Dx * Bpp;\n\tif (rotating_same) {\n\t\trbl = Dx * Bpp;\n\t} else {\n\t\trbl = Dy * Bpp;\n\t}\n\n\tif (rotating == ROTATE_X) {\n\t\tfor (y = 0; y < Dy; y++)  {\n\t\t\tfor (x = 0; x < Dx; x++)  {\n\t\t\t\txn = Dx - x - 1;\n\t\t\t\tyn = y;\n\t\t\t\tROT_COPY\nif (0) fprintf(stderr, \"rcurs: %d %d  %d %d\\n\", x, y, xn, yn);\n\t\t\t}\n\t\t}\n\t} else if (rotating == ROTATE_Y) {\n\t\tfor (y = 0; y < Dy; y++)  {\n\t\t\tfor (x = 0; x < Dx; x++)  {\n\t\t\t\txn = x;\n\t\t\t\tyn = Dy - y - 1;\n\t\t\t\tROT_COPY\n\t\t\t}\n\t\t}\n\t} else if (rotating == ROTATE_XY) {\n\t\tfor (y = 0; y < Dy; y++)  {\n\t\t\tfor (x = 0; x < Dx; x++)  {\n\t\t\t\txn = Dx - x - 1;\n\t\t\t\tyn = Dy - y - 1;\n\t\t\t\tROT_COPY\n\t\t\t}\n\t\t}\n\t} else if (rotating == ROTATE_90) {\n\t\tfor (y = 0; y < Dy; y++)  {\n\t\t\tfor (x = 0; x < Dx; x++)  {\n\t\t\t\txn = Dy - y - 1;\n\t\t\t\tyn = x;\n\t\t\t\tROT_COPY\n\t\t\t}\n\t\t}\n\t} else if (rotating == ROTATE_90X) {\n\t\tfor (y = 0; y < Dy; y++)  {\n\t\t\tfor (x = 0; x < Dx; x++)  {\n\t\t\t\txn = y;\n\t\t\t\tyn = x;\n\t\t\t\tROT_COPY\n\t\t\t}\n\t\t}\n\t} else if (rotating == ROTATE_90Y) {\n\t\tfor (y = 0; y < Dy; y++)  {\n\t\t\tfor (x = 0; x < Dx; x++)  {\n\t\t\t\txn = Dy - y - 1;\n\t\t\t\tyn = Dx - x - 1;\n\t\t\t\tROT_COPY\n\t\t\t}\n\t\t}\n\t} else if (rotating == ROTATE_270) {\n\t\tfor (y = 0; y < Dy; y++)  {\n\t\t\tfor (x = 0; x < Dx; x++)  {\n\t\t\t\txn = y;\n\t\t\t\tyn = Dx - x - 1;\n\t\t\t\tROT_COPY\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "rotate_fb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/scan.c",
    "lines": "1456-1538",
    "snippet": "void rotate_fb(int x1, int y1, int x2, int y2) {\n\tint x, y, xn, yn, r_x1, r_y1, r_x2, r_y2, Bpp = bpp/8;\n\tint fbl = rfb_bytes_per_line;\n\tint rbl = rot_bytes_per_line;\n\tint Dx, Dy;\n\tchar *src, *dst;\n\tchar *src_0 = rfb_fb;\n\tchar *dst_0 = rot_fb;\n\n\tif (! rotating || ! rot_fb) {\n\t\treturn;\n\t}\n\n\tif (scaling) {\n\t\tDx = scaled_x;\n\t\tDy = scaled_y;\n\t} else {\n\t\tDx = dpy_x;\n\t\tDy = dpy_y;\n\t}\n\trotate_coords(x1, y1, &r_x1, &r_y1, -1, -1);\n\trotate_coords(x2, y2, &r_x2, &r_y2, -1, -1);\n\n\tdst = rot_fb;\n\n\tif (rotating == ROTATE_X) {\n\t\tfor (y = y1; y < y2; y++)  {\n\t\t\tfor (x = x1; x < x2; x++)  {\n\t\t\t\txn = Dx - x - 1;\n\t\t\t\tyn = y;\n\t\t\t\tROT_COPY\n\t\t\t}\n\t\t}\n\t} else if (rotating == ROTATE_Y) {\n\t\tfor (y = y1; y < y2; y++)  {\n\t\t\tfor (x = x1; x < x2; x++)  {\n\t\t\t\txn = x;\n\t\t\t\tyn = Dy - y - 1;\n\t\t\t\tROT_COPY\n\t\t\t}\n\t\t}\n\t} else if (rotating == ROTATE_XY) {\n\t\tfor (y = y1; y < y2; y++)  {\n\t\t\tfor (x = x1; x < x2; x++)  {\n\t\t\t\txn = Dx - x - 1;\n\t\t\t\tyn = Dy - y - 1;\n\t\t\t\tROT_COPY\n\t\t\t}\n\t\t}\n\t} else if (rotating == ROTATE_90) {\n\t\tfor (y = y1; y < y2; y++)  {\n\t\t\tfor (x = x1; x < x2; x++)  {\n\t\t\t\txn = Dy - y - 1;\n\t\t\t\tyn = x;\n\t\t\t\tROT_COPY\n\t\t\t}\n\t\t}\n\t} else if (rotating == ROTATE_90X) {\n\t\tfor (y = y1; y < y2; y++)  {\n\t\t\tfor (x = x1; x < x2; x++)  {\n\t\t\t\txn = y;\n\t\t\t\tyn = x;\n\t\t\t\tROT_COPY\n\t\t\t}\n\t\t}\n\t} else if (rotating == ROTATE_90Y) {\n\t\tfor (y = y1; y < y2; y++)  {\n\t\t\tfor (x = x1; x < x2; x++)  {\n\t\t\t\txn = Dy - y - 1;\n\t\t\t\tyn = Dx - x - 1;\n\t\t\t\tROT_COPY\n\t\t\t}\n\t\t}\n\t} else if (rotating == ROTATE_270) {\n\t\tfor (y = y1; y < y2; y++)  {\n\t\t\tfor (x = x1; x < x2; x++)  {\n\t\t\t\txn = y;\n\t\t\t\tyn = Dx - x - 1;\n\t\t\t\tROT_COPY\n\t\t\t}\n\t\t}\n\t}\n}",
    "includes": [
      "#include <default8x16.h>",
      "#include \"userinput.h\"",
      "#include \"macosx.h\"",
      "#include \"screen.h\"",
      "#include \"unixpw.h\"",
      "#include \"cleanup.h\"",
      "#include \"pointer.h\"",
      "#include \"screen.h\"",
      "#include \"8to24.h\"",
      "#include \"win_utils.h\"",
      "#include \"xrandr.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"xinerama.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [
      "#define ROT_COPY \\\n\tsrc = src_0 + fbl*y  + Bpp*x;  \\\n\tdst = dst_0 + rbl*yn + Bpp*xn; \\\n\tif (Bpp == 1) { \\\n\t\t*(dst) = *(src);\t \\\n\t} else if (Bpp == 2) { \\\n\t\t*(dst+0) = *(src+0);\t \\\n\t\t*(dst+1) = *(src+1);\t \\\n\t} else if (Bpp == 3) { \\\n\t\t*(dst+0) = *(src+0);\t \\\n\t\t*(dst+1) = *(src+1);\t \\\n\t\t*(dst+2) = *(src+2);\t \\\n\t} else if (Bpp == 4) { \\\n\t\t*(dst+0) = *(src+0);\t \\\n\t\t*(dst+1) = *(src+1);\t \\\n\t\t*(dst+2) = *(src+2);\t \\\n\t\t*(dst+3) = *(src+3);\t \\\n\t}"
    ],
    "globals_used": [
      "void rotate_curs(char *dst_0, char *src_0, int Dx, int Dy, int Bpp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rotate_coords",
          "args": [
            "x2",
            "y2",
            "&r_x2",
            "&r_y2",
            "-1",
            "-1"
          ],
          "line": 1477
        },
        "resolved": true,
        "details": {
          "function_name": "rotate_coords_inverse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/scan.c",
          "lines": "1388-1434",
          "snippet": "void rotate_coords_inverse(int x, int y, int *xo, int *yo, int dxi, int dyi) {\n\tint xi = x, yi = y;\n\n\tint Dx, Dy;\n\n\tif (dxi >= 0) {\n\t\tDx = dxi;\n\t\tDy = dyi;\n\t} else if (scaling) {\n\t\tDx = scaled_x;\n\t\tDy = scaled_y;\n\t} else {\n\t\tDx = dpy_x;\n\t\tDy = dpy_y;\n\t}\n\tif (! rotating_same) {\n\t\tint t = Dx;\n\t\tDx = Dy;\n\t\tDy = t;\n\t}\n\n\tif (rotating == ROTATE_NONE) {\n\t\t*xo = xi;\n\t\t*yo = yi;\n\t} else if (rotating == ROTATE_X) {\n\t\t*xo = Dx - xi - 1;\n\t\t*yo = yi;\n\t} else if (rotating == ROTATE_Y) {\n\t\t*xo = xi;\n\t\t*yo = Dy - yi - 1;\n\t} else if (rotating == ROTATE_XY) {\n\t\t*xo = Dx - xi - 1;\n\t\t*yo = Dy - yi - 1;\n\t} else if (rotating == ROTATE_90) {\n\t\t*xo = yi;\n\t\t*yo = Dx - xi - 1;\n\t} else if (rotating == ROTATE_90X) {\n\t\t*xo = yi;\n\t\t*yo = xi;\n\t} else if (rotating == ROTATE_90Y) {\n\t\t*xo = Dy - yi - 1;\n\t\t*yo = Dx - xi - 1;\n\t} else if (rotating == ROTATE_270) {\n\t\t*xo = Dy - yi - 1;\n\t\t*yo = xi;\n\t}\n}",
          "includes": [
            "#include <default8x16.h>",
            "#include \"userinput.h\"",
            "#include \"macosx.h\"",
            "#include \"screen.h\"",
            "#include \"unixpw.h\"",
            "#include \"cleanup.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"8to24.h\"",
            "#include \"win_utils.h\"",
            "#include \"xrandr.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void rotate_coords(int x, int y, int *xo, int *yo, int dxi, int dyi);",
            "void rotate_coords_inverse(int x, int y, int *xo, int *yo, int dxi, int dyi);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <default8x16.h>\n#include \"userinput.h\"\n#include \"macosx.h\"\n#include \"screen.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"8to24.h\"\n#include \"win_utils.h\"\n#include \"xrandr.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nvoid rotate_coords(int x, int y, int *xo, int *yo, int dxi, int dyi);\nvoid rotate_coords_inverse(int x, int y, int *xo, int *yo, int dxi, int dyi);\n\nvoid rotate_coords_inverse(int x, int y, int *xo, int *yo, int dxi, int dyi) {\n\tint xi = x, yi = y;\n\n\tint Dx, Dy;\n\n\tif (dxi >= 0) {\n\t\tDx = dxi;\n\t\tDy = dyi;\n\t} else if (scaling) {\n\t\tDx = scaled_x;\n\t\tDy = scaled_y;\n\t} else {\n\t\tDx = dpy_x;\n\t\tDy = dpy_y;\n\t}\n\tif (! rotating_same) {\n\t\tint t = Dx;\n\t\tDx = Dy;\n\t\tDy = t;\n\t}\n\n\tif (rotating == ROTATE_NONE) {\n\t\t*xo = xi;\n\t\t*yo = yi;\n\t} else if (rotating == ROTATE_X) {\n\t\t*xo = Dx - xi - 1;\n\t\t*yo = yi;\n\t} else if (rotating == ROTATE_Y) {\n\t\t*xo = xi;\n\t\t*yo = Dy - yi - 1;\n\t} else if (rotating == ROTATE_XY) {\n\t\t*xo = Dx - xi - 1;\n\t\t*yo = Dy - yi - 1;\n\t} else if (rotating == ROTATE_90) {\n\t\t*xo = yi;\n\t\t*yo = Dx - xi - 1;\n\t} else if (rotating == ROTATE_90X) {\n\t\t*xo = yi;\n\t\t*yo = xi;\n\t} else if (rotating == ROTATE_90Y) {\n\t\t*xo = Dy - yi - 1;\n\t\t*yo = Dx - xi - 1;\n\t} else if (rotating == ROTATE_270) {\n\t\t*xo = Dy - yi - 1;\n\t\t*yo = xi;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <default8x16.h>\n#include \"userinput.h\"\n#include \"macosx.h\"\n#include \"screen.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"8to24.h\"\n#include \"win_utils.h\"\n#include \"xrandr.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\n#define ROT_COPY \\\n\tsrc = src_0 + fbl*y  + Bpp*x;  \\\n\tdst = dst_0 + rbl*yn + Bpp*xn; \\\n\tif (Bpp == 1) { \\\n\t\t*(dst) = *(src);\t \\\n\t} else if (Bpp == 2) { \\\n\t\t*(dst+0) = *(src+0);\t \\\n\t\t*(dst+1) = *(src+1);\t \\\n\t} else if (Bpp == 3) { \\\n\t\t*(dst+0) = *(src+0);\t \\\n\t\t*(dst+1) = *(src+1);\t \\\n\t\t*(dst+2) = *(src+2);\t \\\n\t} else if (Bpp == 4) { \\\n\t\t*(dst+0) = *(src+0);\t \\\n\t\t*(dst+1) = *(src+1);\t \\\n\t\t*(dst+2) = *(src+2);\t \\\n\t\t*(dst+3) = *(src+3);\t \\\n\t}\n\nvoid rotate_curs(char *dst_0, char *src_0, int Dx, int Dy, int Bpp);\n\nvoid rotate_fb(int x1, int y1, int x2, int y2) {\n\tint x, y, xn, yn, r_x1, r_y1, r_x2, r_y2, Bpp = bpp/8;\n\tint fbl = rfb_bytes_per_line;\n\tint rbl = rot_bytes_per_line;\n\tint Dx, Dy;\n\tchar *src, *dst;\n\tchar *src_0 = rfb_fb;\n\tchar *dst_0 = rot_fb;\n\n\tif (! rotating || ! rot_fb) {\n\t\treturn;\n\t}\n\n\tif (scaling) {\n\t\tDx = scaled_x;\n\t\tDy = scaled_y;\n\t} else {\n\t\tDx = dpy_x;\n\t\tDy = dpy_y;\n\t}\n\trotate_coords(x1, y1, &r_x1, &r_y1, -1, -1);\n\trotate_coords(x2, y2, &r_x2, &r_y2, -1, -1);\n\n\tdst = rot_fb;\n\n\tif (rotating == ROTATE_X) {\n\t\tfor (y = y1; y < y2; y++)  {\n\t\t\tfor (x = x1; x < x2; x++)  {\n\t\t\t\txn = Dx - x - 1;\n\t\t\t\tyn = y;\n\t\t\t\tROT_COPY\n\t\t\t}\n\t\t}\n\t} else if (rotating == ROTATE_Y) {\n\t\tfor (y = y1; y < y2; y++)  {\n\t\t\tfor (x = x1; x < x2; x++)  {\n\t\t\t\txn = x;\n\t\t\t\tyn = Dy - y - 1;\n\t\t\t\tROT_COPY\n\t\t\t}\n\t\t}\n\t} else if (rotating == ROTATE_XY) {\n\t\tfor (y = y1; y < y2; y++)  {\n\t\t\tfor (x = x1; x < x2; x++)  {\n\t\t\t\txn = Dx - x - 1;\n\t\t\t\tyn = Dy - y - 1;\n\t\t\t\tROT_COPY\n\t\t\t}\n\t\t}\n\t} else if (rotating == ROTATE_90) {\n\t\tfor (y = y1; y < y2; y++)  {\n\t\t\tfor (x = x1; x < x2; x++)  {\n\t\t\t\txn = Dy - y - 1;\n\t\t\t\tyn = x;\n\t\t\t\tROT_COPY\n\t\t\t}\n\t\t}\n\t} else if (rotating == ROTATE_90X) {\n\t\tfor (y = y1; y < y2; y++)  {\n\t\t\tfor (x = x1; x < x2; x++)  {\n\t\t\t\txn = y;\n\t\t\t\tyn = x;\n\t\t\t\tROT_COPY\n\t\t\t}\n\t\t}\n\t} else if (rotating == ROTATE_90Y) {\n\t\tfor (y = y1; y < y2; y++)  {\n\t\t\tfor (x = x1; x < x2; x++)  {\n\t\t\t\txn = Dy - y - 1;\n\t\t\t\tyn = Dx - x - 1;\n\t\t\t\tROT_COPY\n\t\t\t}\n\t\t}\n\t} else if (rotating == ROTATE_270) {\n\t\tfor (y = y1; y < y2; y++)  {\n\t\t\tfor (x = x1; x < x2; x++)  {\n\t\t\t\txn = y;\n\t\t\t\tyn = Dx - x - 1;\n\t\t\t\tROT_COPY\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "rotate_coords_inverse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/scan.c",
    "lines": "1388-1434",
    "snippet": "void rotate_coords_inverse(int x, int y, int *xo, int *yo, int dxi, int dyi) {\n\tint xi = x, yi = y;\n\n\tint Dx, Dy;\n\n\tif (dxi >= 0) {\n\t\tDx = dxi;\n\t\tDy = dyi;\n\t} else if (scaling) {\n\t\tDx = scaled_x;\n\t\tDy = scaled_y;\n\t} else {\n\t\tDx = dpy_x;\n\t\tDy = dpy_y;\n\t}\n\tif (! rotating_same) {\n\t\tint t = Dx;\n\t\tDx = Dy;\n\t\tDy = t;\n\t}\n\n\tif (rotating == ROTATE_NONE) {\n\t\t*xo = xi;\n\t\t*yo = yi;\n\t} else if (rotating == ROTATE_X) {\n\t\t*xo = Dx - xi - 1;\n\t\t*yo = yi;\n\t} else if (rotating == ROTATE_Y) {\n\t\t*xo = xi;\n\t\t*yo = Dy - yi - 1;\n\t} else if (rotating == ROTATE_XY) {\n\t\t*xo = Dx - xi - 1;\n\t\t*yo = Dy - yi - 1;\n\t} else if (rotating == ROTATE_90) {\n\t\t*xo = yi;\n\t\t*yo = Dx - xi - 1;\n\t} else if (rotating == ROTATE_90X) {\n\t\t*xo = yi;\n\t\t*yo = xi;\n\t} else if (rotating == ROTATE_90Y) {\n\t\t*xo = Dy - yi - 1;\n\t\t*yo = Dx - xi - 1;\n\t} else if (rotating == ROTATE_270) {\n\t\t*xo = Dy - yi - 1;\n\t\t*yo = xi;\n\t}\n}",
    "includes": [
      "#include <default8x16.h>",
      "#include \"userinput.h\"",
      "#include \"macosx.h\"",
      "#include \"screen.h\"",
      "#include \"unixpw.h\"",
      "#include \"cleanup.h\"",
      "#include \"pointer.h\"",
      "#include \"screen.h\"",
      "#include \"8to24.h\"",
      "#include \"win_utils.h\"",
      "#include \"xrandr.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"xinerama.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void rotate_coords(int x, int y, int *xo, int *yo, int dxi, int dyi);",
      "void rotate_coords_inverse(int x, int y, int *xo, int *yo, int dxi, int dyi);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <default8x16.h>\n#include \"userinput.h\"\n#include \"macosx.h\"\n#include \"screen.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"8to24.h\"\n#include \"win_utils.h\"\n#include \"xrandr.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nvoid rotate_coords(int x, int y, int *xo, int *yo, int dxi, int dyi);\nvoid rotate_coords_inverse(int x, int y, int *xo, int *yo, int dxi, int dyi);\n\nvoid rotate_coords_inverse(int x, int y, int *xo, int *yo, int dxi, int dyi) {\n\tint xi = x, yi = y;\n\n\tint Dx, Dy;\n\n\tif (dxi >= 0) {\n\t\tDx = dxi;\n\t\tDy = dyi;\n\t} else if (scaling) {\n\t\tDx = scaled_x;\n\t\tDy = scaled_y;\n\t} else {\n\t\tDx = dpy_x;\n\t\tDy = dpy_y;\n\t}\n\tif (! rotating_same) {\n\t\tint t = Dx;\n\t\tDx = Dy;\n\t\tDy = t;\n\t}\n\n\tif (rotating == ROTATE_NONE) {\n\t\t*xo = xi;\n\t\t*yo = yi;\n\t} else if (rotating == ROTATE_X) {\n\t\t*xo = Dx - xi - 1;\n\t\t*yo = yi;\n\t} else if (rotating == ROTATE_Y) {\n\t\t*xo = xi;\n\t\t*yo = Dy - yi - 1;\n\t} else if (rotating == ROTATE_XY) {\n\t\t*xo = Dx - xi - 1;\n\t\t*yo = Dy - yi - 1;\n\t} else if (rotating == ROTATE_90) {\n\t\t*xo = yi;\n\t\t*yo = Dx - xi - 1;\n\t} else if (rotating == ROTATE_90X) {\n\t\t*xo = yi;\n\t\t*yo = xi;\n\t} else if (rotating == ROTATE_90Y) {\n\t\t*xo = Dy - yi - 1;\n\t\t*yo = Dx - xi - 1;\n\t} else if (rotating == ROTATE_270) {\n\t\t*xo = Dy - yi - 1;\n\t\t*yo = xi;\n\t}\n}"
  },
  {
    "function_name": "rotate_coords",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/scan.c",
    "lines": "1344-1386",
    "snippet": "void rotate_coords(int x, int y, int *xo, int *yo, int dxi, int dyi) {\n\tint xi = x, yi = y;\n\tint Dx, Dy;\n\n\tif (dxi >= 0) {\n\t\tDx = dxi;\n\t\tDy = dyi;\n\t} else if (scaling) {\n\t\tDx = scaled_x;\n\t\tDy = scaled_y;\n\t} else {\n\t\tDx = dpy_x;\n\t\tDy = dpy_y;\n\t}\n\n\t/* ncache?? */\n\n\tif (rotating == ROTATE_NONE) {\n\t\t*xo = xi;\n\t\t*yo = yi;\n\t} else if (rotating == ROTATE_X) {\n\t\t*xo = Dx - xi - 1;\n\t\t*yo = yi;\n\t} else if (rotating == ROTATE_Y) {\n\t\t*xo = xi;\n\t\t*yo = Dy - yi - 1;\n\t} else if (rotating == ROTATE_XY) {\n\t\t*xo = Dx - xi - 1;\n\t\t*yo = Dy - yi - 1;\n\t} else if (rotating == ROTATE_90) {\n\t\t*xo = Dy - yi - 1;\n\t\t*yo = xi;\n\t} else if (rotating == ROTATE_90X) {\n\t\t*xo = yi;\n\t\t*yo = xi;\n\t} else if (rotating == ROTATE_90Y) {\n\t\t*xo = Dy - yi - 1;\n\t\t*yo = Dx - xi - 1;\n\t} else if (rotating == ROTATE_270) {\n\t\t*xo = yi;\n\t\t*yo = Dx - xi - 1;\n\t}\n}",
    "includes": [
      "#include <default8x16.h>",
      "#include \"userinput.h\"",
      "#include \"macosx.h\"",
      "#include \"screen.h\"",
      "#include \"unixpw.h\"",
      "#include \"cleanup.h\"",
      "#include \"pointer.h\"",
      "#include \"screen.h\"",
      "#include \"8to24.h\"",
      "#include \"win_utils.h\"",
      "#include \"xrandr.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"xinerama.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void rotate_coords(int x, int y, int *xo, int *yo, int dxi, int dyi);",
      "void rotate_coords_inverse(int x, int y, int *xo, int *yo, int dxi, int dyi);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <default8x16.h>\n#include \"userinput.h\"\n#include \"macosx.h\"\n#include \"screen.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"8to24.h\"\n#include \"win_utils.h\"\n#include \"xrandr.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nvoid rotate_coords(int x, int y, int *xo, int *yo, int dxi, int dyi);\nvoid rotate_coords_inverse(int x, int y, int *xo, int *yo, int dxi, int dyi);\n\nvoid rotate_coords(int x, int y, int *xo, int *yo, int dxi, int dyi) {\n\tint xi = x, yi = y;\n\tint Dx, Dy;\n\n\tif (dxi >= 0) {\n\t\tDx = dxi;\n\t\tDy = dyi;\n\t} else if (scaling) {\n\t\tDx = scaled_x;\n\t\tDy = scaled_y;\n\t} else {\n\t\tDx = dpy_x;\n\t\tDy = dpy_y;\n\t}\n\n\t/* ncache?? */\n\n\tif (rotating == ROTATE_NONE) {\n\t\t*xo = xi;\n\t\t*yo = yi;\n\t} else if (rotating == ROTATE_X) {\n\t\t*xo = Dx - xi - 1;\n\t\t*yo = yi;\n\t} else if (rotating == ROTATE_Y) {\n\t\t*xo = xi;\n\t\t*yo = Dy - yi - 1;\n\t} else if (rotating == ROTATE_XY) {\n\t\t*xo = Dx - xi - 1;\n\t\t*yo = Dy - yi - 1;\n\t} else if (rotating == ROTATE_90) {\n\t\t*xo = Dy - yi - 1;\n\t\t*yo = xi;\n\t} else if (rotating == ROTATE_90X) {\n\t\t*xo = yi;\n\t\t*yo = xi;\n\t} else if (rotating == ROTATE_90Y) {\n\t\t*xo = Dy - yi - 1;\n\t\t*yo = Dx - xi - 1;\n\t} else if (rotating == ROTATE_270) {\n\t\t*xo = yi;\n\t\t*yo = Dx - xi - 1;\n\t}\n}"
  },
  {
    "function_name": "scale_and_mark_rect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/scan.c",
    "lines": "1300-1342",
    "snippet": "void scale_and_mark_rect(int X1, int Y1, int X2, int Y2, int mark) {\n\tchar *dst_fb, *src_fb = main_fb;\n\tint dst_bpl, Bpp = bpp/8, fac = 1;\n\n\tif (!screen || !rfb_fb || !main_fb) {\n\t\treturn;\n\t}\n\tif (! screen->serverFormat.trueColour) {\n\t\t/*\n\t\t * PseudoColor colormap... blending leads to random colors.\n\t\t * User can override with \":fb\"\n\t\t */\n\t\tif (scaling_blend == 1) {\n\t\t\t/* :fb option sets it to 2 */\n\t\t\tif (default_visual->class == StaticGray) {\n\t\t\t\t/*\n\t\t\t\t * StaticGray can be blended OK, otherwise\n\t\t\t\t * user can disable with :nb\n\t\t\t\t */\n\t\t\t\t;\n\t\t\t} else {\n\t\t\t\tscaling_blend = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (cmap8to24 && cmap8to24_fb) {\n\t\tsrc_fb = cmap8to24_fb;\n\t\tif (scaling) {\n\t\t\tif (depth <= 8) {\n\t\t\t\tfac = 4;\n\t\t\t} else if (depth <= 16) {\n\t\t\t\tfac = 2;\n\t\t\t}\n\t\t}\n\t}\n\tdst_fb = rfb_fb;\n\tdst_bpl = rfb_bytes_per_line;\n\n\tscale_rect(scale_fac_x, scale_fac_y, scaling_blend, scaling_interpolate, fac * Bpp,\n\t    src_fb, fac * main_bytes_per_line, dst_fb, dst_bpl, dpy_x, dpy_y,\n\t    scaled_x, scaled_y, X1, Y1, X2, Y2, mark);\n}",
    "includes": [
      "#include <default8x16.h>",
      "#include \"userinput.h\"",
      "#include \"macosx.h\"",
      "#include \"screen.h\"",
      "#include \"unixpw.h\"",
      "#include \"cleanup.h\"",
      "#include \"pointer.h\"",
      "#include \"screen.h\"",
      "#include \"8to24.h\"",
      "#include \"win_utils.h\"",
      "#include \"xrandr.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"xinerama.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void scale_rect(double factor_x, double factor_y, int blend, int interpolate, int Bpp,\n    char *src_fb, int src_bytes_per_line, char *dst_fb, int dst_bytes_per_line,\n    int Nx, int Ny, int nx, int ny, int X1, int Y1, int X2, int Y2, int mark);",
      "void scale_and_mark_rect(int X1, int Y1, int X2, int Y2, int mark);",
      "void rotate_curs(char *dst_0, char *src_0, int Dx, int Dy, int Bpp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "scale_rect",
          "args": [
            "scale_fac_x",
            "scale_fac_y",
            "scaling_blend",
            "scaling_interpolate",
            "fac * Bpp",
            "src_fb",
            "fac * main_bytes_per_line",
            "dst_fb",
            "dst_bpl",
            "dpy_x",
            "dpy_y",
            "scaled_x",
            "scaled_y",
            "X1",
            "Y1",
            "X2",
            "Y2",
            "mark"
          ],
          "line": 1339
        },
        "resolved": true,
        "details": {
          "function_name": "scale_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/scan.c",
          "lines": "777-1229",
          "snippet": "void scale_rect(double factor_x, double factor_y, int blend, int interpolate, int Bpp,\n    char *src_fb, int src_bytes_per_line, char *dst_fb, int dst_bytes_per_line,\n    int Nx, int Ny, int nx, int ny, int X1, int Y1, int X2, int Y2, int mark) {\n/*\n * Notation:\n * \"i\" an x pixel index in the destination (scaled) framebuffer\n * \"j\" a  y pixel index in the destination (scaled) framebuffer\n * \"I\" an x pixel index in the source (un-scaled, i.e. main) framebuffer\n * \"J\" a  y pixel index in the source (un-scaled, i.e. main) framebuffer\n *\n *  Similarly for nx, ny, Nx, Ny, etc.  Lowercase: dest, Uppercase: source.\n */\n\tint i, j, i1, i2, j1, j2;\t/* indices for scaled fb (dest) */\n\tint I, J, I1, I2, J1, J2;\t/* indices for main fb   (source) */\n\n\tdouble w, wx, wy, wtot;\t/* pixel weights */\n\n\tdouble x1, y1, x2, y2;\t/* x-y coords for destination pixels edges */\n\tdouble dx, dy;\t\t/* size of destination pixel */\n\tdouble ddx=0, ddy=0;\t/* for interpolation expansion */\n\n\tchar *src, *dest;\t/* pointers to the two framebuffers */\n\n\n\tunsigned short us = 0;\n\tunsigned char  uc = 0;\n\tunsigned int   ui = 0;\n\n\tint use_noblend_shortcut = 1;\n\tint shrink;\t\t/* whether shrinking or expanding */\n\tstatic int constant_weights = -1, mag_int = -1;\n\tstatic int last_Nx = -1, last_Ny = -1, cnt = 0;\n\tstatic double last_factor = -1.0;\n\tint b, k;\n\tdouble pixave[4];\t/* for averaging pixel values */\n\n\tif (factor_x <= 1.0 && factor_y <= 1.0) {\n\t\tshrink = 1;\n\t} else {\n\t\tshrink = 0;\n\t}\n\n\t/*\n\t * N.B. width and height (real numbers) of a scaled pixel.\n\t * both are > 1   (e.g. 1.333 for -scale 3/4)\n\t * they should also be equal but we don't assume it.\n\t *\n\t * This new way is probably the best we can do, take the inverse\n\t * of the scaling factor to double precision.\n\t */\n\tdx = 1.0/factor_x;\n\tdy = 1.0/factor_y;\n\n\t/*\n\t * There is some speedup if the pixel weights are constant, so\n\t * let's special case these.\n\t *\n\t * If scale = 1/n and n divides Nx and Ny, the pixel weights\n\t * are constant (e.g. 1/2 => equal on 2x2 square).\n\t */\n\tif (factor_x != last_factor || Nx != last_Nx || Ny != last_Ny) {\n\t\tconstant_weights = -1;\n\t\tmag_int = -1;\n\t\tlast_Nx = Nx;\n\t\tlast_Ny = Ny;\n\t\tlast_factor = factor_x;\n\t}\n\tif (constant_weights < 0 && factor_x != factor_y) {\n\t\tconstant_weights = 0;\n\t\tmag_int = 0;\n\n\t} else if (constant_weights < 0) {\n\t\tint n = 0;\n\n\t\tconstant_weights = 0;\n\t\tmag_int = 0;\n\n\t\tfor (i = 2; i<=128; i++) {\n\t\t\tdouble test = ((double) 1)/ i;\n\t\t\tdouble diff, eps = 1.0e-7;\n\t\t\tdiff = factor_x - test;\n\t\t\tif (-eps < diff && diff < eps) {\n\t\t\t\tn = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (! blend || ! shrink || interpolate) {\n\t\t\t;\n\t\t} else if (n != 0) {\n\t\t\tif (Nx % n == 0 && Ny % n == 0) {\n\t\t\t\tstatic int didmsg = 0;\n\t\t\t\tif (mark && ! didmsg) {\n\t\t\t\t\tdidmsg = 1;\n\t\t\t\t\trfbLog(\"scale_and_mark_rect: using \"\n\t\t\t\t\t    \"constant pixel weight speedup \"\n\t\t\t\t\t    \"for 1/%d\\n\", n);\n\t\t\t\t}\n\t\t\t\tconstant_weights = 1;\n\t\t\t}\n\t\t}\n\n\t\tn = 0;\n\t\tfor (i = 2; i<=32; i++) {\n\t\t\tdouble test = (double) i;\n\t\t\tdouble diff, eps = 1.0e-7;\n\t\t\tdiff = factor_x - test;\n\t\t\tif (-eps < diff && diff < eps) {\n\t\t\t\tn = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (! blend && factor_x > 1.0 && n) {\n\t\t\tmag_int = n;\n\t\t}\n\t}\n\n\tif (mark && factor_x > 1.0 && blend) {\n\t\t/*\n\t\t * kludge: correct for interpolating blurring leaking\n\t\t * up or left 1 destination pixel.\n\t\t */\n\t\tif (X1 > 0) X1--;\n\t\tif (Y1 > 0) Y1--;\n\t}\n\n\t/*\n\t * find the extent of the change the input rectangle induces in\n\t * the scaled framebuffer.\n\t */\n\n\t/* Left edges: find largest i such that i * dx <= X1  */\n\ti1 = FLOOR(X1/dx);\n\n\t/* Right edges: find smallest i such that (i+1) * dx >= X2+1  */\n\ti2 = CEIL( (X2+1)/dx ) - 1;\n\n\t/* To be safe, correct any overflows: */\n\ti1 = nfix(i1, nx);\n\ti2 = nfix(i2, nx) + 1;\t/* add 1 to make a rectangle upper boundary */\n\n\t/* Repeat above for y direction: */\n\tj1 = FLOOR(Y1/dy);\n\tj2 = CEIL( (Y2+1)/dy ) - 1;\n\n\tj1 = nfix(j1, ny);\n\tj2 = nfix(j2, ny) + 1;\n\n\t/*\n\t * special case integer magnification with no blending.\n\t * vision impaired magnification usage is interested in this case.\n\t */\n\tif (mark && ! blend && mag_int && Bpp != 3) {\n\t\tint jmin, jmax, imin, imax;\n\n\t\t/* outer loop over *source* pixels */\n\t\tfor (J=Y1; J < Y2; J++) {\n\t\t    jmin = J * mag_int;\n\t\t    jmax = jmin + mag_int;\n\t\t    for (I=X1; I < X2; I++) {\n\t\t\t/* extract value */\n\t\t\tsrc = src_fb + J*src_bytes_per_line + I*Bpp;\n\t\t\tif (Bpp == 4) {\n\t\t\t\tui = *((unsigned int *)src);\n\t\t\t} else if (Bpp == 2) {\n\t\t\t\tus = *((unsigned short *)src);\n\t\t\t} else if (Bpp == 1) {\n\t\t\t\tuc = *((unsigned char *)src);\n\t\t\t}\n\t\t\timin = I * mag_int;\n\t\t\timax = imin + mag_int;\n\t\t\t/* inner loop over *dest* pixels */\n\t\t\tfor (j=jmin; j<jmax; j++) {\n\t\t\t    dest = dst_fb + j*dst_bytes_per_line + imin*Bpp;\n\t\t\t    for (i=imin; i<imax; i++) {\n\t\t\t\tif (Bpp == 4) {\n\t\t\t\t\t*((unsigned int *)dest) = ui;\n\t\t\t\t} else if (Bpp == 2) {\n\t\t\t\t\t*((unsigned short *)dest) = us;\n\t\t\t\t} else if (Bpp == 1) {\n\t\t\t\t\t*((unsigned char *)dest) = uc;\n\t\t\t\t}\n\t\t\t\tdest += Bpp;\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t}\n\t\tgoto markit;\n\t}\n\n\t/* set these all to 1.0 to begin with */\n\twx = 1.0;\n\twy = 1.0;\n\tw  = 1.0;\n\n\t/*\n\t * Loop over destination pixels in scaled fb:\n\t */\n\tfor (j=j1; j<j2; j++) {\n\t\ty1 =  j * dy;\t/* top edge */\n\t\tif (y1 > Ny - 1) {\n\t\t\t/* can go over with dy = 1/scale_fac */\n\t\t\ty1 = Ny - 1;\n\t\t}\n\t\ty2 = y1 + dy;\t/* bottom edge */\n\n\t\t/* Find main fb indices covered by this dest pixel: */\n\t\tJ1 = (int) FLOOR(y1);\n\t\tJ1 = nfix(J1, Ny);\n\n\t\tif (shrink && ! interpolate) {\n\t\t\tJ2 = (int) CEIL(y2) - 1;\n\t\t\tJ2 = nfix(J2, Ny);\n\t\t} else {\n\t\t\tJ2 = J1 + 1;\t/* simple interpolation */\n\t\t\tddy = y1 - J1;\n\t\t}\n\n\t\t/* destination char* pointer: */\n\t\tdest = dst_fb + j*dst_bytes_per_line + i1*Bpp;\n\t\t\n\t\tfor (i=i1; i<i2; i++) {\n\n\t\t\tx1 =  i * dx;\t/* left edge */\n\t\t\tif (x1 > Nx - 1) {\n\t\t\t\t/* can go over with dx = 1/scale_fac */\n\t\t\t\tx1 = Nx - 1;\n\t\t\t}\n\t\t\tx2 = x1 + dx;\t/* right edge */\n\n\t\t\tcnt++;\n\n\t\t\t/* Find main fb indices covered by this dest pixel: */\n\t\t\tI1 = (int) FLOOR(x1);\n\t\t\tif (I1 >= Nx) I1 = Nx - 1;\n\n\t\t\tif (! blend && use_noblend_shortcut) {\n\t\t\t\t/*\n\t\t\t\t * The noblend case involves no weights,\n\t\t\t\t * and 1 pixel, so just copy the value\n\t\t\t\t * directly.\n\t\t\t\t */\n\t\t\t\tsrc = src_fb + J1*src_bytes_per_line + I1*Bpp;\n\t\t\t\tif (Bpp == 4) {\n\t\t\t\t\t*((unsigned int *)dest)\n\t\t\t\t\t    = *((unsigned int *)src);\n\t\t\t\t} else if (Bpp == 2) {\n\t\t\t\t\t*((unsigned short *)dest)\n\t\t\t\t\t    = *((unsigned short *)src);\n\t\t\t\t} else if (Bpp == 1) {\n\t\t\t\t\t*(dest) = *(src);\n\t\t\t\t} else if (Bpp == 3) {\n\t\t\t\t\t/* rare case */\n\t\t\t\t\tfor (k=0; k<=2; k++) {\n\t\t\t\t\t\t*(dest+k) = *(src+k);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdest += Bpp;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tif (shrink && ! interpolate) {\n\t\t\t\tI2 = (int) CEIL(x2) - 1;\n\t\t\t\tif (I2 >= Nx) I2 = Nx - 1;\n\t\t\t} else {\n\t\t\t\tI2 = I1 + 1;\t/* simple interpolation */\n\t\t\t\tddx = x1 - I1;\n\t\t\t}\n\n\t\t\t/* Zero out accumulators for next pixel average: */\n\t\t\tfor (b=0; b<4; b++) {\n\t\t\t\tpixave[b] = 0.0; /* for RGB weighted sums */\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * wtot is for accumulating the total weight.\n\t\t\t * It should always sum to 1/(scale_fac * scale_fac).\n\t\t\t */\n\t\t\twtot = 0.0;\n\n\t\t\t/*\n\t\t\t * Loop over source pixels covered by this dest pixel.\n\t\t\t * \n\t\t\t * These \"extra\" loops over \"J\" and \"I\" make\n\t\t\t * the cache/cacheline performance unclear.\n\t\t\t * For example, will the data brought in from\n\t\t\t * src for j, i, and J=0 still be in the cache\n\t\t\t * after the J > 0 data have been accessed and\n\t\t\t * we are at j, i+1, J=0?  The stride in J is\n\t\t\t * main_bytes_per_line, and so ~4 KB.\n\t\t\t *\n\t\t\t * Typical case when shrinking are 2x2 loop, so\n\t\t\t * just two lines to worry about.\n\t\t\t */\n\t\t\tfor (J=J1; J<=J2; J++) {\n\t\t\t    /* see comments for I, x1, x2, etc. below */\n\t\t\t    if (constant_weights) {\n\t\t\t\t;\n\t\t\t    } else if (! blend) {\n\t\t\t\tif (J != J1) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\twy = 1.0;\n\n\t\t\t\t/* interpolation scheme: */\n\t\t\t    } else if (! shrink || interpolate) {\n\t\t\t\tif (J >= Ny) {\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if (J == J1) {\n\t\t\t\t\twy = 1.0 - ddy;\n\t\t\t\t} else if (J != J1) {\n\t\t\t\t\twy = ddy;\n\t\t\t\t}\n\n\t\t\t\t/* integration scheme: */\n\t\t\t    } else if (J < y1) {\n\t\t\t\twy = J+1 - y1;\n\t\t\t    } else if (J+1 > y2) {\n\t\t\t\twy = y2 - J;\n\t\t\t    } else {\n\t\t\t\twy = 1.0;\n\t\t\t    }\n\n\t\t\t    src = src_fb + J*src_bytes_per_line + I1*Bpp;\n\n\t\t\t    for (I=I1; I<=I2; I++) {\n\n\t\t\t\t/* Work out the weight: */\n\n\t\t\t\tif (constant_weights) {\n\t\t\t\t\t;\n\t\t\t\t} else if (! blend) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Ugh, PseudoColor colormap is\n\t\t\t\t\t * bad news, to avoid random\n\t\t\t\t\t * colors just take the first\n\t\t\t\t\t * pixel.  Or user may have\n\t\t\t\t\t * specified :nb to fraction.\n\t\t\t\t\t * The :fb will force blending\n\t\t\t\t\t * for this case.\n\t\t\t\t\t */\n\t\t\t\t\tif (I != I1) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\twx = 1.0;\n\n\t\t\t\t\t/* interpolation scheme: */\n\t\t\t\t} else if (! shrink || interpolate) {\n\t\t\t\t\tif (I >= Nx) {\n\t\t\t\t\t\tcontinue;\t/* off edge */\n\t\t\t\t\t} else if (I == I1) {\n\t\t\t\t\t\twx = 1.0 - ddx;\n\t\t\t\t\t} else if (I != I1) {\n\t\t\t\t\t\twx = ddx;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* integration scheme: */\n\t\t\t\t} else if (I < x1) {\n\t\t\t\t\t/* \n\t\t\t\t\t * source left edge (I) to the\n\t\t\t\t\t * left of dest left edge (x1):\n\t\t\t\t\t * fractional weight\n\t\t\t\t\t */\n\t\t\t\t\twx = I+1 - x1;\n\t\t\t\t} else if (I+1 > x2) {\n\t\t\t\t\t/* \n\t\t\t\t\t * source right edge (I+1) to the\n\t\t\t\t\t * right of dest right edge (x2):\n\t\t\t\t\t * fractional weight\n\t\t\t\t\t */\n\t\t\t\t\twx = x2 - I;\n\t\t\t\t} else {\n\t\t\t\t\t/* \n\t\t\t\t\t * source edges (I and I+1) completely\n\t\t\t\t\t * inside dest edges (x1 and x2):\n\t\t\t\t\t * full weight\n\t\t\t\t\t */\n\t\t\t\t\twx = 1.0;\n\t\t\t\t}\n\n\t\t\t\tw = wx * wy;\n\t\t\t\twtot += w;\n\n\t\t\t\t/* \n\t\t\t\t * We average the unsigned char value\n\t\t\t\t * instead of char value: otherwise\n\t\t\t\t * the minimum (char 0) is right next\n\t\t\t\t * to the maximum (char -1)!  This way\n\t\t\t\t * they are spread between 0 and 255.\n\t\t\t\t */\n\t\t\t\tif (Bpp == 4) {\n\t\t\t\t\t/* unroll the loops, can give 20% */\n\t\t\t\t\tpixave[0] += w * ((unsigned char) *(src  ));\n\t\t\t\t\tpixave[1] += w * ((unsigned char) *(src+1));\n\t\t\t\t\tpixave[2] += w * ((unsigned char) *(src+2));\n\t\t\t\t\tpixave[3] += w * ((unsigned char) *(src+3));\n\t\t\t\t} else if (Bpp == 2) {\n\t\t\t\t\t/*\n\t\t\t\t\t * 16bpp: trickier with green\n\t\t\t\t\t * split over two bytes, so we\n\t\t\t\t\t * use the masks:\n\t\t\t\t\t */\n\t\t\t\t\tus = *((unsigned short *) src);\n\t\t\t\t\tpixave[0] += w*(us & main_red_mask);\n\t\t\t\t\tpixave[1] += w*(us & main_green_mask);\n\t\t\t\t\tpixave[2] += w*(us & main_blue_mask);\n\t\t\t\t} else if (Bpp == 1) {\n\t\t\t\t\tpixave[0] += w *\n\t\t\t\t\t    ((unsigned char) *(src));\n\t\t\t\t} else {\n\t\t\t\t\tfor (b=0; b<Bpp; b++) {\n\t\t\t\t\t\tpixave[b] += w *\n\t\t\t\t\t\t    ((unsigned char) *(src+b));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsrc += Bpp;\n\t\t\t    }\n\t\t\t}\n\n\t\t\tif (wtot <= 0.0) {\n\t\t\t\twtot = 1.0;\n\t\t\t}\n\t\t\twtot = 1.0/wtot;\t/* normalization factor */\n\n\t\t\t/* place weighted average pixel in the scaled fb: */\n\t\t\tif (Bpp == 4) {\n\t\t\t\t*(dest  ) = (char) (wtot * pixave[0]);\n\t\t\t\t*(dest+1) = (char) (wtot * pixave[1]);\n\t\t\t\t*(dest+2) = (char) (wtot * pixave[2]);\n\t\t\t\t*(dest+3) = (char) (wtot * pixave[3]);\n\t\t\t} else if (Bpp == 2) {\n\t\t\t\t/* 16bpp / 565 case: */\n\t\t\t\tpixave[0] *= wtot;\n\t\t\t\tpixave[1] *= wtot;\n\t\t\t\tpixave[2] *= wtot;\n\t\t\t\tus =  (main_red_mask   & (int) pixave[0])\n\t\t\t\t    | (main_green_mask & (int) pixave[1])\n\t\t\t\t    | (main_blue_mask  & (int) pixave[2]);\n\t\t\t\t*( (unsigned short *) dest ) = us;\n\t\t\t} else if (Bpp == 1) {\n\t\t\t\t*(dest) = (char) (wtot * pixave[0]);\n\t\t\t} else {\n\t\t\t\tfor (b=0; b<Bpp; b++) {\n\t\t\t\t\t*(dest+b) = (char) (wtot * pixave[b]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tdest += Bpp;\n\t\t}\n\t}\n\tmarkit:\n\tif (mark) {\n\t\tmark_rect_as_modified(i1, j1, i2, j2, 1);\n\t}\n}",
          "includes": [
            "#include <default8x16.h>",
            "#include \"userinput.h\"",
            "#include \"macosx.h\"",
            "#include \"screen.h\"",
            "#include \"unixpw.h\"",
            "#include \"cleanup.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"8to24.h\"",
            "#include \"win_utils.h\"",
            "#include \"xrandr.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void scale_rect(double factor_x, double factor_y, int blend, int interpolate, int Bpp,\n    char *src_fb, int src_bytes_per_line, char *dst_fb, int dst_bytes_per_line,\n    int Nx, int Ny, int nx, int ny, int X1, int Y1, int X2, int Y2, int mark);",
            "void scale_and_mark_rect(int X1, int Y1, int X2, int Y2, int mark);",
            "void mark_rect_as_modified(int x1, int y1, int x2, int y2, int force);",
            "void nap_sleep(int ms, int split);",
            "void rotate_curs(char *dst_0, char *src_0, int Dx, int Dy, int Bpp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <default8x16.h>\n#include \"userinput.h\"\n#include \"macosx.h\"\n#include \"screen.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"8to24.h\"\n#include \"win_utils.h\"\n#include \"xrandr.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nvoid scale_rect(double factor_x, double factor_y, int blend, int interpolate, int Bpp,\n    char *src_fb, int src_bytes_per_line, char *dst_fb, int dst_bytes_per_line,\n    int Nx, int Ny, int nx, int ny, int X1, int Y1, int X2, int Y2, int mark);\nvoid scale_and_mark_rect(int X1, int Y1, int X2, int Y2, int mark);\nvoid mark_rect_as_modified(int x1, int y1, int x2, int y2, int force);\nvoid nap_sleep(int ms, int split);\nvoid rotate_curs(char *dst_0, char *src_0, int Dx, int Dy, int Bpp);\n\nvoid scale_rect(double factor_x, double factor_y, int blend, int interpolate, int Bpp,\n    char *src_fb, int src_bytes_per_line, char *dst_fb, int dst_bytes_per_line,\n    int Nx, int Ny, int nx, int ny, int X1, int Y1, int X2, int Y2, int mark) {\n/*\n * Notation:\n * \"i\" an x pixel index in the destination (scaled) framebuffer\n * \"j\" a  y pixel index in the destination (scaled) framebuffer\n * \"I\" an x pixel index in the source (un-scaled, i.e. main) framebuffer\n * \"J\" a  y pixel index in the source (un-scaled, i.e. main) framebuffer\n *\n *  Similarly for nx, ny, Nx, Ny, etc.  Lowercase: dest, Uppercase: source.\n */\n\tint i, j, i1, i2, j1, j2;\t/* indices for scaled fb (dest) */\n\tint I, J, I1, I2, J1, J2;\t/* indices for main fb   (source) */\n\n\tdouble w, wx, wy, wtot;\t/* pixel weights */\n\n\tdouble x1, y1, x2, y2;\t/* x-y coords for destination pixels edges */\n\tdouble dx, dy;\t\t/* size of destination pixel */\n\tdouble ddx=0, ddy=0;\t/* for interpolation expansion */\n\n\tchar *src, *dest;\t/* pointers to the two framebuffers */\n\n\n\tunsigned short us = 0;\n\tunsigned char  uc = 0;\n\tunsigned int   ui = 0;\n\n\tint use_noblend_shortcut = 1;\n\tint shrink;\t\t/* whether shrinking or expanding */\n\tstatic int constant_weights = -1, mag_int = -1;\n\tstatic int last_Nx = -1, last_Ny = -1, cnt = 0;\n\tstatic double last_factor = -1.0;\n\tint b, k;\n\tdouble pixave[4];\t/* for averaging pixel values */\n\n\tif (factor_x <= 1.0 && factor_y <= 1.0) {\n\t\tshrink = 1;\n\t} else {\n\t\tshrink = 0;\n\t}\n\n\t/*\n\t * N.B. width and height (real numbers) of a scaled pixel.\n\t * both are > 1   (e.g. 1.333 for -scale 3/4)\n\t * they should also be equal but we don't assume it.\n\t *\n\t * This new way is probably the best we can do, take the inverse\n\t * of the scaling factor to double precision.\n\t */\n\tdx = 1.0/factor_x;\n\tdy = 1.0/factor_y;\n\n\t/*\n\t * There is some speedup if the pixel weights are constant, so\n\t * let's special case these.\n\t *\n\t * If scale = 1/n and n divides Nx and Ny, the pixel weights\n\t * are constant (e.g. 1/2 => equal on 2x2 square).\n\t */\n\tif (factor_x != last_factor || Nx != last_Nx || Ny != last_Ny) {\n\t\tconstant_weights = -1;\n\t\tmag_int = -1;\n\t\tlast_Nx = Nx;\n\t\tlast_Ny = Ny;\n\t\tlast_factor = factor_x;\n\t}\n\tif (constant_weights < 0 && factor_x != factor_y) {\n\t\tconstant_weights = 0;\n\t\tmag_int = 0;\n\n\t} else if (constant_weights < 0) {\n\t\tint n = 0;\n\n\t\tconstant_weights = 0;\n\t\tmag_int = 0;\n\n\t\tfor (i = 2; i<=128; i++) {\n\t\t\tdouble test = ((double) 1)/ i;\n\t\t\tdouble diff, eps = 1.0e-7;\n\t\t\tdiff = factor_x - test;\n\t\t\tif (-eps < diff && diff < eps) {\n\t\t\t\tn = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (! blend || ! shrink || interpolate) {\n\t\t\t;\n\t\t} else if (n != 0) {\n\t\t\tif (Nx % n == 0 && Ny % n == 0) {\n\t\t\t\tstatic int didmsg = 0;\n\t\t\t\tif (mark && ! didmsg) {\n\t\t\t\t\tdidmsg = 1;\n\t\t\t\t\trfbLog(\"scale_and_mark_rect: using \"\n\t\t\t\t\t    \"constant pixel weight speedup \"\n\t\t\t\t\t    \"for 1/%d\\n\", n);\n\t\t\t\t}\n\t\t\t\tconstant_weights = 1;\n\t\t\t}\n\t\t}\n\n\t\tn = 0;\n\t\tfor (i = 2; i<=32; i++) {\n\t\t\tdouble test = (double) i;\n\t\t\tdouble diff, eps = 1.0e-7;\n\t\t\tdiff = factor_x - test;\n\t\t\tif (-eps < diff && diff < eps) {\n\t\t\t\tn = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (! blend && factor_x > 1.0 && n) {\n\t\t\tmag_int = n;\n\t\t}\n\t}\n\n\tif (mark && factor_x > 1.0 && blend) {\n\t\t/*\n\t\t * kludge: correct for interpolating blurring leaking\n\t\t * up or left 1 destination pixel.\n\t\t */\n\t\tif (X1 > 0) X1--;\n\t\tif (Y1 > 0) Y1--;\n\t}\n\n\t/*\n\t * find the extent of the change the input rectangle induces in\n\t * the scaled framebuffer.\n\t */\n\n\t/* Left edges: find largest i such that i * dx <= X1  */\n\ti1 = FLOOR(X1/dx);\n\n\t/* Right edges: find smallest i such that (i+1) * dx >= X2+1  */\n\ti2 = CEIL( (X2+1)/dx ) - 1;\n\n\t/* To be safe, correct any overflows: */\n\ti1 = nfix(i1, nx);\n\ti2 = nfix(i2, nx) + 1;\t/* add 1 to make a rectangle upper boundary */\n\n\t/* Repeat above for y direction: */\n\tj1 = FLOOR(Y1/dy);\n\tj2 = CEIL( (Y2+1)/dy ) - 1;\n\n\tj1 = nfix(j1, ny);\n\tj2 = nfix(j2, ny) + 1;\n\n\t/*\n\t * special case integer magnification with no blending.\n\t * vision impaired magnification usage is interested in this case.\n\t */\n\tif (mark && ! blend && mag_int && Bpp != 3) {\n\t\tint jmin, jmax, imin, imax;\n\n\t\t/* outer loop over *source* pixels */\n\t\tfor (J=Y1; J < Y2; J++) {\n\t\t    jmin = J * mag_int;\n\t\t    jmax = jmin + mag_int;\n\t\t    for (I=X1; I < X2; I++) {\n\t\t\t/* extract value */\n\t\t\tsrc = src_fb + J*src_bytes_per_line + I*Bpp;\n\t\t\tif (Bpp == 4) {\n\t\t\t\tui = *((unsigned int *)src);\n\t\t\t} else if (Bpp == 2) {\n\t\t\t\tus = *((unsigned short *)src);\n\t\t\t} else if (Bpp == 1) {\n\t\t\t\tuc = *((unsigned char *)src);\n\t\t\t}\n\t\t\timin = I * mag_int;\n\t\t\timax = imin + mag_int;\n\t\t\t/* inner loop over *dest* pixels */\n\t\t\tfor (j=jmin; j<jmax; j++) {\n\t\t\t    dest = dst_fb + j*dst_bytes_per_line + imin*Bpp;\n\t\t\t    for (i=imin; i<imax; i++) {\n\t\t\t\tif (Bpp == 4) {\n\t\t\t\t\t*((unsigned int *)dest) = ui;\n\t\t\t\t} else if (Bpp == 2) {\n\t\t\t\t\t*((unsigned short *)dest) = us;\n\t\t\t\t} else if (Bpp == 1) {\n\t\t\t\t\t*((unsigned char *)dest) = uc;\n\t\t\t\t}\n\t\t\t\tdest += Bpp;\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t}\n\t\tgoto markit;\n\t}\n\n\t/* set these all to 1.0 to begin with */\n\twx = 1.0;\n\twy = 1.0;\n\tw  = 1.0;\n\n\t/*\n\t * Loop over destination pixels in scaled fb:\n\t */\n\tfor (j=j1; j<j2; j++) {\n\t\ty1 =  j * dy;\t/* top edge */\n\t\tif (y1 > Ny - 1) {\n\t\t\t/* can go over with dy = 1/scale_fac */\n\t\t\ty1 = Ny - 1;\n\t\t}\n\t\ty2 = y1 + dy;\t/* bottom edge */\n\n\t\t/* Find main fb indices covered by this dest pixel: */\n\t\tJ1 = (int) FLOOR(y1);\n\t\tJ1 = nfix(J1, Ny);\n\n\t\tif (shrink && ! interpolate) {\n\t\t\tJ2 = (int) CEIL(y2) - 1;\n\t\t\tJ2 = nfix(J2, Ny);\n\t\t} else {\n\t\t\tJ2 = J1 + 1;\t/* simple interpolation */\n\t\t\tddy = y1 - J1;\n\t\t}\n\n\t\t/* destination char* pointer: */\n\t\tdest = dst_fb + j*dst_bytes_per_line + i1*Bpp;\n\t\t\n\t\tfor (i=i1; i<i2; i++) {\n\n\t\t\tx1 =  i * dx;\t/* left edge */\n\t\t\tif (x1 > Nx - 1) {\n\t\t\t\t/* can go over with dx = 1/scale_fac */\n\t\t\t\tx1 = Nx - 1;\n\t\t\t}\n\t\t\tx2 = x1 + dx;\t/* right edge */\n\n\t\t\tcnt++;\n\n\t\t\t/* Find main fb indices covered by this dest pixel: */\n\t\t\tI1 = (int) FLOOR(x1);\n\t\t\tif (I1 >= Nx) I1 = Nx - 1;\n\n\t\t\tif (! blend && use_noblend_shortcut) {\n\t\t\t\t/*\n\t\t\t\t * The noblend case involves no weights,\n\t\t\t\t * and 1 pixel, so just copy the value\n\t\t\t\t * directly.\n\t\t\t\t */\n\t\t\t\tsrc = src_fb + J1*src_bytes_per_line + I1*Bpp;\n\t\t\t\tif (Bpp == 4) {\n\t\t\t\t\t*((unsigned int *)dest)\n\t\t\t\t\t    = *((unsigned int *)src);\n\t\t\t\t} else if (Bpp == 2) {\n\t\t\t\t\t*((unsigned short *)dest)\n\t\t\t\t\t    = *((unsigned short *)src);\n\t\t\t\t} else if (Bpp == 1) {\n\t\t\t\t\t*(dest) = *(src);\n\t\t\t\t} else if (Bpp == 3) {\n\t\t\t\t\t/* rare case */\n\t\t\t\t\tfor (k=0; k<=2; k++) {\n\t\t\t\t\t\t*(dest+k) = *(src+k);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdest += Bpp;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tif (shrink && ! interpolate) {\n\t\t\t\tI2 = (int) CEIL(x2) - 1;\n\t\t\t\tif (I2 >= Nx) I2 = Nx - 1;\n\t\t\t} else {\n\t\t\t\tI2 = I1 + 1;\t/* simple interpolation */\n\t\t\t\tddx = x1 - I1;\n\t\t\t}\n\n\t\t\t/* Zero out accumulators for next pixel average: */\n\t\t\tfor (b=0; b<4; b++) {\n\t\t\t\tpixave[b] = 0.0; /* for RGB weighted sums */\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * wtot is for accumulating the total weight.\n\t\t\t * It should always sum to 1/(scale_fac * scale_fac).\n\t\t\t */\n\t\t\twtot = 0.0;\n\n\t\t\t/*\n\t\t\t * Loop over source pixels covered by this dest pixel.\n\t\t\t * \n\t\t\t * These \"extra\" loops over \"J\" and \"I\" make\n\t\t\t * the cache/cacheline performance unclear.\n\t\t\t * For example, will the data brought in from\n\t\t\t * src for j, i, and J=0 still be in the cache\n\t\t\t * after the J > 0 data have been accessed and\n\t\t\t * we are at j, i+1, J=0?  The stride in J is\n\t\t\t * main_bytes_per_line, and so ~4 KB.\n\t\t\t *\n\t\t\t * Typical case when shrinking are 2x2 loop, so\n\t\t\t * just two lines to worry about.\n\t\t\t */\n\t\t\tfor (J=J1; J<=J2; J++) {\n\t\t\t    /* see comments for I, x1, x2, etc. below */\n\t\t\t    if (constant_weights) {\n\t\t\t\t;\n\t\t\t    } else if (! blend) {\n\t\t\t\tif (J != J1) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\twy = 1.0;\n\n\t\t\t\t/* interpolation scheme: */\n\t\t\t    } else if (! shrink || interpolate) {\n\t\t\t\tif (J >= Ny) {\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if (J == J1) {\n\t\t\t\t\twy = 1.0 - ddy;\n\t\t\t\t} else if (J != J1) {\n\t\t\t\t\twy = ddy;\n\t\t\t\t}\n\n\t\t\t\t/* integration scheme: */\n\t\t\t    } else if (J < y1) {\n\t\t\t\twy = J+1 - y1;\n\t\t\t    } else if (J+1 > y2) {\n\t\t\t\twy = y2 - J;\n\t\t\t    } else {\n\t\t\t\twy = 1.0;\n\t\t\t    }\n\n\t\t\t    src = src_fb + J*src_bytes_per_line + I1*Bpp;\n\n\t\t\t    for (I=I1; I<=I2; I++) {\n\n\t\t\t\t/* Work out the weight: */\n\n\t\t\t\tif (constant_weights) {\n\t\t\t\t\t;\n\t\t\t\t} else if (! blend) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Ugh, PseudoColor colormap is\n\t\t\t\t\t * bad news, to avoid random\n\t\t\t\t\t * colors just take the first\n\t\t\t\t\t * pixel.  Or user may have\n\t\t\t\t\t * specified :nb to fraction.\n\t\t\t\t\t * The :fb will force blending\n\t\t\t\t\t * for this case.\n\t\t\t\t\t */\n\t\t\t\t\tif (I != I1) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\twx = 1.0;\n\n\t\t\t\t\t/* interpolation scheme: */\n\t\t\t\t} else if (! shrink || interpolate) {\n\t\t\t\t\tif (I >= Nx) {\n\t\t\t\t\t\tcontinue;\t/* off edge */\n\t\t\t\t\t} else if (I == I1) {\n\t\t\t\t\t\twx = 1.0 - ddx;\n\t\t\t\t\t} else if (I != I1) {\n\t\t\t\t\t\twx = ddx;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* integration scheme: */\n\t\t\t\t} else if (I < x1) {\n\t\t\t\t\t/* \n\t\t\t\t\t * source left edge (I) to the\n\t\t\t\t\t * left of dest left edge (x1):\n\t\t\t\t\t * fractional weight\n\t\t\t\t\t */\n\t\t\t\t\twx = I+1 - x1;\n\t\t\t\t} else if (I+1 > x2) {\n\t\t\t\t\t/* \n\t\t\t\t\t * source right edge (I+1) to the\n\t\t\t\t\t * right of dest right edge (x2):\n\t\t\t\t\t * fractional weight\n\t\t\t\t\t */\n\t\t\t\t\twx = x2 - I;\n\t\t\t\t} else {\n\t\t\t\t\t/* \n\t\t\t\t\t * source edges (I and I+1) completely\n\t\t\t\t\t * inside dest edges (x1 and x2):\n\t\t\t\t\t * full weight\n\t\t\t\t\t */\n\t\t\t\t\twx = 1.0;\n\t\t\t\t}\n\n\t\t\t\tw = wx * wy;\n\t\t\t\twtot += w;\n\n\t\t\t\t/* \n\t\t\t\t * We average the unsigned char value\n\t\t\t\t * instead of char value: otherwise\n\t\t\t\t * the minimum (char 0) is right next\n\t\t\t\t * to the maximum (char -1)!  This way\n\t\t\t\t * they are spread between 0 and 255.\n\t\t\t\t */\n\t\t\t\tif (Bpp == 4) {\n\t\t\t\t\t/* unroll the loops, can give 20% */\n\t\t\t\t\tpixave[0] += w * ((unsigned char) *(src  ));\n\t\t\t\t\tpixave[1] += w * ((unsigned char) *(src+1));\n\t\t\t\t\tpixave[2] += w * ((unsigned char) *(src+2));\n\t\t\t\t\tpixave[3] += w * ((unsigned char) *(src+3));\n\t\t\t\t} else if (Bpp == 2) {\n\t\t\t\t\t/*\n\t\t\t\t\t * 16bpp: trickier with green\n\t\t\t\t\t * split over two bytes, so we\n\t\t\t\t\t * use the masks:\n\t\t\t\t\t */\n\t\t\t\t\tus = *((unsigned short *) src);\n\t\t\t\t\tpixave[0] += w*(us & main_red_mask);\n\t\t\t\t\tpixave[1] += w*(us & main_green_mask);\n\t\t\t\t\tpixave[2] += w*(us & main_blue_mask);\n\t\t\t\t} else if (Bpp == 1) {\n\t\t\t\t\tpixave[0] += w *\n\t\t\t\t\t    ((unsigned char) *(src));\n\t\t\t\t} else {\n\t\t\t\t\tfor (b=0; b<Bpp; b++) {\n\t\t\t\t\t\tpixave[b] += w *\n\t\t\t\t\t\t    ((unsigned char) *(src+b));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsrc += Bpp;\n\t\t\t    }\n\t\t\t}\n\n\t\t\tif (wtot <= 0.0) {\n\t\t\t\twtot = 1.0;\n\t\t\t}\n\t\t\twtot = 1.0/wtot;\t/* normalization factor */\n\n\t\t\t/* place weighted average pixel in the scaled fb: */\n\t\t\tif (Bpp == 4) {\n\t\t\t\t*(dest  ) = (char) (wtot * pixave[0]);\n\t\t\t\t*(dest+1) = (char) (wtot * pixave[1]);\n\t\t\t\t*(dest+2) = (char) (wtot * pixave[2]);\n\t\t\t\t*(dest+3) = (char) (wtot * pixave[3]);\n\t\t\t} else if (Bpp == 2) {\n\t\t\t\t/* 16bpp / 565 case: */\n\t\t\t\tpixave[0] *= wtot;\n\t\t\t\tpixave[1] *= wtot;\n\t\t\t\tpixave[2] *= wtot;\n\t\t\t\tus =  (main_red_mask   & (int) pixave[0])\n\t\t\t\t    | (main_green_mask & (int) pixave[1])\n\t\t\t\t    | (main_blue_mask  & (int) pixave[2]);\n\t\t\t\t*( (unsigned short *) dest ) = us;\n\t\t\t} else if (Bpp == 1) {\n\t\t\t\t*(dest) = (char) (wtot * pixave[0]);\n\t\t\t} else {\n\t\t\t\tfor (b=0; b<Bpp; b++) {\n\t\t\t\t\t*(dest+b) = (char) (wtot * pixave[b]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tdest += Bpp;\n\t\t}\n\t}\n\tmarkit:\n\tif (mark) {\n\t\tmark_rect_as_modified(i1, j1, i2, j2, 1);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <default8x16.h>\n#include \"userinput.h\"\n#include \"macosx.h\"\n#include \"screen.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"8to24.h\"\n#include \"win_utils.h\"\n#include \"xrandr.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nvoid scale_rect(double factor_x, double factor_y, int blend, int interpolate, int Bpp,\n    char *src_fb, int src_bytes_per_line, char *dst_fb, int dst_bytes_per_line,\n    int Nx, int Ny, int nx, int ny, int X1, int Y1, int X2, int Y2, int mark);\nvoid scale_and_mark_rect(int X1, int Y1, int X2, int Y2, int mark);\nvoid rotate_curs(char *dst_0, char *src_0, int Dx, int Dy, int Bpp);\n\nvoid scale_and_mark_rect(int X1, int Y1, int X2, int Y2, int mark) {\n\tchar *dst_fb, *src_fb = main_fb;\n\tint dst_bpl, Bpp = bpp/8, fac = 1;\n\n\tif (!screen || !rfb_fb || !main_fb) {\n\t\treturn;\n\t}\n\tif (! screen->serverFormat.trueColour) {\n\t\t/*\n\t\t * PseudoColor colormap... blending leads to random colors.\n\t\t * User can override with \":fb\"\n\t\t */\n\t\tif (scaling_blend == 1) {\n\t\t\t/* :fb option sets it to 2 */\n\t\t\tif (default_visual->class == StaticGray) {\n\t\t\t\t/*\n\t\t\t\t * StaticGray can be blended OK, otherwise\n\t\t\t\t * user can disable with :nb\n\t\t\t\t */\n\t\t\t\t;\n\t\t\t} else {\n\t\t\t\tscaling_blend = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (cmap8to24 && cmap8to24_fb) {\n\t\tsrc_fb = cmap8to24_fb;\n\t\tif (scaling) {\n\t\t\tif (depth <= 8) {\n\t\t\t\tfac = 4;\n\t\t\t} else if (depth <= 16) {\n\t\t\t\tfac = 2;\n\t\t\t}\n\t\t}\n\t}\n\tdst_fb = rfb_fb;\n\tdst_bpl = rfb_bytes_per_line;\n\n\tscale_rect(scale_fac_x, scale_fac_y, scaling_blend, scaling_interpolate, fac * Bpp,\n\t    src_fb, fac * main_bytes_per_line, dst_fb, dst_bpl, dpy_x, dpy_y,\n\t    scaled_x, scaled_y, X1, Y1, X2, Y2, mark);\n}"
  },
  {
    "function_name": "scale_rect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/scan.c",
    "lines": "777-1229",
    "snippet": "void scale_rect(double factor_x, double factor_y, int blend, int interpolate, int Bpp,\n    char *src_fb, int src_bytes_per_line, char *dst_fb, int dst_bytes_per_line,\n    int Nx, int Ny, int nx, int ny, int X1, int Y1, int X2, int Y2, int mark) {\n/*\n * Notation:\n * \"i\" an x pixel index in the destination (scaled) framebuffer\n * \"j\" a  y pixel index in the destination (scaled) framebuffer\n * \"I\" an x pixel index in the source (un-scaled, i.e. main) framebuffer\n * \"J\" a  y pixel index in the source (un-scaled, i.e. main) framebuffer\n *\n *  Similarly for nx, ny, Nx, Ny, etc.  Lowercase: dest, Uppercase: source.\n */\n\tint i, j, i1, i2, j1, j2;\t/* indices for scaled fb (dest) */\n\tint I, J, I1, I2, J1, J2;\t/* indices for main fb   (source) */\n\n\tdouble w, wx, wy, wtot;\t/* pixel weights */\n\n\tdouble x1, y1, x2, y2;\t/* x-y coords for destination pixels edges */\n\tdouble dx, dy;\t\t/* size of destination pixel */\n\tdouble ddx=0, ddy=0;\t/* for interpolation expansion */\n\n\tchar *src, *dest;\t/* pointers to the two framebuffers */\n\n\n\tunsigned short us = 0;\n\tunsigned char  uc = 0;\n\tunsigned int   ui = 0;\n\n\tint use_noblend_shortcut = 1;\n\tint shrink;\t\t/* whether shrinking or expanding */\n\tstatic int constant_weights = -1, mag_int = -1;\n\tstatic int last_Nx = -1, last_Ny = -1, cnt = 0;\n\tstatic double last_factor = -1.0;\n\tint b, k;\n\tdouble pixave[4];\t/* for averaging pixel values */\n\n\tif (factor_x <= 1.0 && factor_y <= 1.0) {\n\t\tshrink = 1;\n\t} else {\n\t\tshrink = 0;\n\t}\n\n\t/*\n\t * N.B. width and height (real numbers) of a scaled pixel.\n\t * both are > 1   (e.g. 1.333 for -scale 3/4)\n\t * they should also be equal but we don't assume it.\n\t *\n\t * This new way is probably the best we can do, take the inverse\n\t * of the scaling factor to double precision.\n\t */\n\tdx = 1.0/factor_x;\n\tdy = 1.0/factor_y;\n\n\t/*\n\t * There is some speedup if the pixel weights are constant, so\n\t * let's special case these.\n\t *\n\t * If scale = 1/n and n divides Nx and Ny, the pixel weights\n\t * are constant (e.g. 1/2 => equal on 2x2 square).\n\t */\n\tif (factor_x != last_factor || Nx != last_Nx || Ny != last_Ny) {\n\t\tconstant_weights = -1;\n\t\tmag_int = -1;\n\t\tlast_Nx = Nx;\n\t\tlast_Ny = Ny;\n\t\tlast_factor = factor_x;\n\t}\n\tif (constant_weights < 0 && factor_x != factor_y) {\n\t\tconstant_weights = 0;\n\t\tmag_int = 0;\n\n\t} else if (constant_weights < 0) {\n\t\tint n = 0;\n\n\t\tconstant_weights = 0;\n\t\tmag_int = 0;\n\n\t\tfor (i = 2; i<=128; i++) {\n\t\t\tdouble test = ((double) 1)/ i;\n\t\t\tdouble diff, eps = 1.0e-7;\n\t\t\tdiff = factor_x - test;\n\t\t\tif (-eps < diff && diff < eps) {\n\t\t\t\tn = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (! blend || ! shrink || interpolate) {\n\t\t\t;\n\t\t} else if (n != 0) {\n\t\t\tif (Nx % n == 0 && Ny % n == 0) {\n\t\t\t\tstatic int didmsg = 0;\n\t\t\t\tif (mark && ! didmsg) {\n\t\t\t\t\tdidmsg = 1;\n\t\t\t\t\trfbLog(\"scale_and_mark_rect: using \"\n\t\t\t\t\t    \"constant pixel weight speedup \"\n\t\t\t\t\t    \"for 1/%d\\n\", n);\n\t\t\t\t}\n\t\t\t\tconstant_weights = 1;\n\t\t\t}\n\t\t}\n\n\t\tn = 0;\n\t\tfor (i = 2; i<=32; i++) {\n\t\t\tdouble test = (double) i;\n\t\t\tdouble diff, eps = 1.0e-7;\n\t\t\tdiff = factor_x - test;\n\t\t\tif (-eps < diff && diff < eps) {\n\t\t\t\tn = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (! blend && factor_x > 1.0 && n) {\n\t\t\tmag_int = n;\n\t\t}\n\t}\n\n\tif (mark && factor_x > 1.0 && blend) {\n\t\t/*\n\t\t * kludge: correct for interpolating blurring leaking\n\t\t * up or left 1 destination pixel.\n\t\t */\n\t\tif (X1 > 0) X1--;\n\t\tif (Y1 > 0) Y1--;\n\t}\n\n\t/*\n\t * find the extent of the change the input rectangle induces in\n\t * the scaled framebuffer.\n\t */\n\n\t/* Left edges: find largest i such that i * dx <= X1  */\n\ti1 = FLOOR(X1/dx);\n\n\t/* Right edges: find smallest i such that (i+1) * dx >= X2+1  */\n\ti2 = CEIL( (X2+1)/dx ) - 1;\n\n\t/* To be safe, correct any overflows: */\n\ti1 = nfix(i1, nx);\n\ti2 = nfix(i2, nx) + 1;\t/* add 1 to make a rectangle upper boundary */\n\n\t/* Repeat above for y direction: */\n\tj1 = FLOOR(Y1/dy);\n\tj2 = CEIL( (Y2+1)/dy ) - 1;\n\n\tj1 = nfix(j1, ny);\n\tj2 = nfix(j2, ny) + 1;\n\n\t/*\n\t * special case integer magnification with no blending.\n\t * vision impaired magnification usage is interested in this case.\n\t */\n\tif (mark && ! blend && mag_int && Bpp != 3) {\n\t\tint jmin, jmax, imin, imax;\n\n\t\t/* outer loop over *source* pixels */\n\t\tfor (J=Y1; J < Y2; J++) {\n\t\t    jmin = J * mag_int;\n\t\t    jmax = jmin + mag_int;\n\t\t    for (I=X1; I < X2; I++) {\n\t\t\t/* extract value */\n\t\t\tsrc = src_fb + J*src_bytes_per_line + I*Bpp;\n\t\t\tif (Bpp == 4) {\n\t\t\t\tui = *((unsigned int *)src);\n\t\t\t} else if (Bpp == 2) {\n\t\t\t\tus = *((unsigned short *)src);\n\t\t\t} else if (Bpp == 1) {\n\t\t\t\tuc = *((unsigned char *)src);\n\t\t\t}\n\t\t\timin = I * mag_int;\n\t\t\timax = imin + mag_int;\n\t\t\t/* inner loop over *dest* pixels */\n\t\t\tfor (j=jmin; j<jmax; j++) {\n\t\t\t    dest = dst_fb + j*dst_bytes_per_line + imin*Bpp;\n\t\t\t    for (i=imin; i<imax; i++) {\n\t\t\t\tif (Bpp == 4) {\n\t\t\t\t\t*((unsigned int *)dest) = ui;\n\t\t\t\t} else if (Bpp == 2) {\n\t\t\t\t\t*((unsigned short *)dest) = us;\n\t\t\t\t} else if (Bpp == 1) {\n\t\t\t\t\t*((unsigned char *)dest) = uc;\n\t\t\t\t}\n\t\t\t\tdest += Bpp;\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t}\n\t\tgoto markit;\n\t}\n\n\t/* set these all to 1.0 to begin with */\n\twx = 1.0;\n\twy = 1.0;\n\tw  = 1.0;\n\n\t/*\n\t * Loop over destination pixels in scaled fb:\n\t */\n\tfor (j=j1; j<j2; j++) {\n\t\ty1 =  j * dy;\t/* top edge */\n\t\tif (y1 > Ny - 1) {\n\t\t\t/* can go over with dy = 1/scale_fac */\n\t\t\ty1 = Ny - 1;\n\t\t}\n\t\ty2 = y1 + dy;\t/* bottom edge */\n\n\t\t/* Find main fb indices covered by this dest pixel: */\n\t\tJ1 = (int) FLOOR(y1);\n\t\tJ1 = nfix(J1, Ny);\n\n\t\tif (shrink && ! interpolate) {\n\t\t\tJ2 = (int) CEIL(y2) - 1;\n\t\t\tJ2 = nfix(J2, Ny);\n\t\t} else {\n\t\t\tJ2 = J1 + 1;\t/* simple interpolation */\n\t\t\tddy = y1 - J1;\n\t\t}\n\n\t\t/* destination char* pointer: */\n\t\tdest = dst_fb + j*dst_bytes_per_line + i1*Bpp;\n\t\t\n\t\tfor (i=i1; i<i2; i++) {\n\n\t\t\tx1 =  i * dx;\t/* left edge */\n\t\t\tif (x1 > Nx - 1) {\n\t\t\t\t/* can go over with dx = 1/scale_fac */\n\t\t\t\tx1 = Nx - 1;\n\t\t\t}\n\t\t\tx2 = x1 + dx;\t/* right edge */\n\n\t\t\tcnt++;\n\n\t\t\t/* Find main fb indices covered by this dest pixel: */\n\t\t\tI1 = (int) FLOOR(x1);\n\t\t\tif (I1 >= Nx) I1 = Nx - 1;\n\n\t\t\tif (! blend && use_noblend_shortcut) {\n\t\t\t\t/*\n\t\t\t\t * The noblend case involves no weights,\n\t\t\t\t * and 1 pixel, so just copy the value\n\t\t\t\t * directly.\n\t\t\t\t */\n\t\t\t\tsrc = src_fb + J1*src_bytes_per_line + I1*Bpp;\n\t\t\t\tif (Bpp == 4) {\n\t\t\t\t\t*((unsigned int *)dest)\n\t\t\t\t\t    = *((unsigned int *)src);\n\t\t\t\t} else if (Bpp == 2) {\n\t\t\t\t\t*((unsigned short *)dest)\n\t\t\t\t\t    = *((unsigned short *)src);\n\t\t\t\t} else if (Bpp == 1) {\n\t\t\t\t\t*(dest) = *(src);\n\t\t\t\t} else if (Bpp == 3) {\n\t\t\t\t\t/* rare case */\n\t\t\t\t\tfor (k=0; k<=2; k++) {\n\t\t\t\t\t\t*(dest+k) = *(src+k);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdest += Bpp;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tif (shrink && ! interpolate) {\n\t\t\t\tI2 = (int) CEIL(x2) - 1;\n\t\t\t\tif (I2 >= Nx) I2 = Nx - 1;\n\t\t\t} else {\n\t\t\t\tI2 = I1 + 1;\t/* simple interpolation */\n\t\t\t\tddx = x1 - I1;\n\t\t\t}\n\n\t\t\t/* Zero out accumulators for next pixel average: */\n\t\t\tfor (b=0; b<4; b++) {\n\t\t\t\tpixave[b] = 0.0; /* for RGB weighted sums */\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * wtot is for accumulating the total weight.\n\t\t\t * It should always sum to 1/(scale_fac * scale_fac).\n\t\t\t */\n\t\t\twtot = 0.0;\n\n\t\t\t/*\n\t\t\t * Loop over source pixels covered by this dest pixel.\n\t\t\t * \n\t\t\t * These \"extra\" loops over \"J\" and \"I\" make\n\t\t\t * the cache/cacheline performance unclear.\n\t\t\t * For example, will the data brought in from\n\t\t\t * src for j, i, and J=0 still be in the cache\n\t\t\t * after the J > 0 data have been accessed and\n\t\t\t * we are at j, i+1, J=0?  The stride in J is\n\t\t\t * main_bytes_per_line, and so ~4 KB.\n\t\t\t *\n\t\t\t * Typical case when shrinking are 2x2 loop, so\n\t\t\t * just two lines to worry about.\n\t\t\t */\n\t\t\tfor (J=J1; J<=J2; J++) {\n\t\t\t    /* see comments for I, x1, x2, etc. below */\n\t\t\t    if (constant_weights) {\n\t\t\t\t;\n\t\t\t    } else if (! blend) {\n\t\t\t\tif (J != J1) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\twy = 1.0;\n\n\t\t\t\t/* interpolation scheme: */\n\t\t\t    } else if (! shrink || interpolate) {\n\t\t\t\tif (J >= Ny) {\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if (J == J1) {\n\t\t\t\t\twy = 1.0 - ddy;\n\t\t\t\t} else if (J != J1) {\n\t\t\t\t\twy = ddy;\n\t\t\t\t}\n\n\t\t\t\t/* integration scheme: */\n\t\t\t    } else if (J < y1) {\n\t\t\t\twy = J+1 - y1;\n\t\t\t    } else if (J+1 > y2) {\n\t\t\t\twy = y2 - J;\n\t\t\t    } else {\n\t\t\t\twy = 1.0;\n\t\t\t    }\n\n\t\t\t    src = src_fb + J*src_bytes_per_line + I1*Bpp;\n\n\t\t\t    for (I=I1; I<=I2; I++) {\n\n\t\t\t\t/* Work out the weight: */\n\n\t\t\t\tif (constant_weights) {\n\t\t\t\t\t;\n\t\t\t\t} else if (! blend) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Ugh, PseudoColor colormap is\n\t\t\t\t\t * bad news, to avoid random\n\t\t\t\t\t * colors just take the first\n\t\t\t\t\t * pixel.  Or user may have\n\t\t\t\t\t * specified :nb to fraction.\n\t\t\t\t\t * The :fb will force blending\n\t\t\t\t\t * for this case.\n\t\t\t\t\t */\n\t\t\t\t\tif (I != I1) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\twx = 1.0;\n\n\t\t\t\t\t/* interpolation scheme: */\n\t\t\t\t} else if (! shrink || interpolate) {\n\t\t\t\t\tif (I >= Nx) {\n\t\t\t\t\t\tcontinue;\t/* off edge */\n\t\t\t\t\t} else if (I == I1) {\n\t\t\t\t\t\twx = 1.0 - ddx;\n\t\t\t\t\t} else if (I != I1) {\n\t\t\t\t\t\twx = ddx;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* integration scheme: */\n\t\t\t\t} else if (I < x1) {\n\t\t\t\t\t/* \n\t\t\t\t\t * source left edge (I) to the\n\t\t\t\t\t * left of dest left edge (x1):\n\t\t\t\t\t * fractional weight\n\t\t\t\t\t */\n\t\t\t\t\twx = I+1 - x1;\n\t\t\t\t} else if (I+1 > x2) {\n\t\t\t\t\t/* \n\t\t\t\t\t * source right edge (I+1) to the\n\t\t\t\t\t * right of dest right edge (x2):\n\t\t\t\t\t * fractional weight\n\t\t\t\t\t */\n\t\t\t\t\twx = x2 - I;\n\t\t\t\t} else {\n\t\t\t\t\t/* \n\t\t\t\t\t * source edges (I and I+1) completely\n\t\t\t\t\t * inside dest edges (x1 and x2):\n\t\t\t\t\t * full weight\n\t\t\t\t\t */\n\t\t\t\t\twx = 1.0;\n\t\t\t\t}\n\n\t\t\t\tw = wx * wy;\n\t\t\t\twtot += w;\n\n\t\t\t\t/* \n\t\t\t\t * We average the unsigned char value\n\t\t\t\t * instead of char value: otherwise\n\t\t\t\t * the minimum (char 0) is right next\n\t\t\t\t * to the maximum (char -1)!  This way\n\t\t\t\t * they are spread between 0 and 255.\n\t\t\t\t */\n\t\t\t\tif (Bpp == 4) {\n\t\t\t\t\t/* unroll the loops, can give 20% */\n\t\t\t\t\tpixave[0] += w * ((unsigned char) *(src  ));\n\t\t\t\t\tpixave[1] += w * ((unsigned char) *(src+1));\n\t\t\t\t\tpixave[2] += w * ((unsigned char) *(src+2));\n\t\t\t\t\tpixave[3] += w * ((unsigned char) *(src+3));\n\t\t\t\t} else if (Bpp == 2) {\n\t\t\t\t\t/*\n\t\t\t\t\t * 16bpp: trickier with green\n\t\t\t\t\t * split over two bytes, so we\n\t\t\t\t\t * use the masks:\n\t\t\t\t\t */\n\t\t\t\t\tus = *((unsigned short *) src);\n\t\t\t\t\tpixave[0] += w*(us & main_red_mask);\n\t\t\t\t\tpixave[1] += w*(us & main_green_mask);\n\t\t\t\t\tpixave[2] += w*(us & main_blue_mask);\n\t\t\t\t} else if (Bpp == 1) {\n\t\t\t\t\tpixave[0] += w *\n\t\t\t\t\t    ((unsigned char) *(src));\n\t\t\t\t} else {\n\t\t\t\t\tfor (b=0; b<Bpp; b++) {\n\t\t\t\t\t\tpixave[b] += w *\n\t\t\t\t\t\t    ((unsigned char) *(src+b));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsrc += Bpp;\n\t\t\t    }\n\t\t\t}\n\n\t\t\tif (wtot <= 0.0) {\n\t\t\t\twtot = 1.0;\n\t\t\t}\n\t\t\twtot = 1.0/wtot;\t/* normalization factor */\n\n\t\t\t/* place weighted average pixel in the scaled fb: */\n\t\t\tif (Bpp == 4) {\n\t\t\t\t*(dest  ) = (char) (wtot * pixave[0]);\n\t\t\t\t*(dest+1) = (char) (wtot * pixave[1]);\n\t\t\t\t*(dest+2) = (char) (wtot * pixave[2]);\n\t\t\t\t*(dest+3) = (char) (wtot * pixave[3]);\n\t\t\t} else if (Bpp == 2) {\n\t\t\t\t/* 16bpp / 565 case: */\n\t\t\t\tpixave[0] *= wtot;\n\t\t\t\tpixave[1] *= wtot;\n\t\t\t\tpixave[2] *= wtot;\n\t\t\t\tus =  (main_red_mask   & (int) pixave[0])\n\t\t\t\t    | (main_green_mask & (int) pixave[1])\n\t\t\t\t    | (main_blue_mask  & (int) pixave[2]);\n\t\t\t\t*( (unsigned short *) dest ) = us;\n\t\t\t} else if (Bpp == 1) {\n\t\t\t\t*(dest) = (char) (wtot * pixave[0]);\n\t\t\t} else {\n\t\t\t\tfor (b=0; b<Bpp; b++) {\n\t\t\t\t\t*(dest+b) = (char) (wtot * pixave[b]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tdest += Bpp;\n\t\t}\n\t}\n\tmarkit:\n\tif (mark) {\n\t\tmark_rect_as_modified(i1, j1, i2, j2, 1);\n\t}\n}",
    "includes": [
      "#include <default8x16.h>",
      "#include \"userinput.h\"",
      "#include \"macosx.h\"",
      "#include \"screen.h\"",
      "#include \"unixpw.h\"",
      "#include \"cleanup.h\"",
      "#include \"pointer.h\"",
      "#include \"screen.h\"",
      "#include \"8to24.h\"",
      "#include \"win_utils.h\"",
      "#include \"xrandr.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"xinerama.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void scale_rect(double factor_x, double factor_y, int blend, int interpolate, int Bpp,\n    char *src_fb, int src_bytes_per_line, char *dst_fb, int dst_bytes_per_line,\n    int Nx, int Ny, int nx, int ny, int X1, int Y1, int X2, int Y2, int mark);",
      "void scale_and_mark_rect(int X1, int Y1, int X2, int Y2, int mark);",
      "void mark_rect_as_modified(int x1, int y1, int x2, int y2, int force);",
      "void nap_sleep(int ms, int split);",
      "void rotate_curs(char *dst_0, char *src_0, int Dx, int Dy, int Bpp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_rect_as_modified",
          "args": [
            "i1",
            "j1",
            "i2",
            "j2",
            "1"
          ],
          "line": 1227
        },
        "resolved": true,
        "details": {
          "function_name": "mark_rect_as_modified",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/scan.c",
          "lines": "1643-1682",
          "snippet": "void mark_rect_as_modified(int x1, int y1, int x2, int y2, int force) {\n\n\tif (damage_time != 0) {\n\t\t/*\n\t\t * This is not XDAMAGE, rather a hack for testing\n\t\t * where we allow the framebuffer to be corrupted for\n\t\t * damage_delay seconds.\n\t\t */\n\t\tint debug = 0;\n\t\tif (time(NULL) > damage_time + damage_delay) {\n\t\t\tif (! quiet) {\n\t\t\t\trfbLog(\"damaging turned off.\\n\");\n\t\t\t}\n\t\t\tdamage_time = 0;\n\t\t\tdamage_delay = 0;\n\t\t} else {\n\t\t\tif (debug) {\n\t\t\t\trfbLog(\"damaging viewer fb by not marking \"\n\t\t\t\t    \"rect: %d,%d,%d,%d\\n\", x1, y1, x2, y2);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n\n\n\tif (rfb_fb == main_fb || force) {\n\t\tmark_wrapper(x1, y1, x2, y2);\n\t\treturn;\n\t}\n\n\tif (cmap8to24) {\n\t\tbpp8to24(x1, y1, x2, y2);\n\t}\n\n\tif (scaling) {\n\t\tscale_and_mark_rect(x1, y1, x2, y2, 1);\n\t} else {\n\t\tmark_wrapper(x1, y1, x2, y2);\n\t}\n}",
          "includes": [
            "#include <default8x16.h>",
            "#include \"userinput.h\"",
            "#include \"macosx.h\"",
            "#include \"screen.h\"",
            "#include \"unixpw.h\"",
            "#include \"cleanup.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"8to24.h\"",
            "#include \"win_utils.h\"",
            "#include \"xrandr.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_rect_as_modified(int x1, int y1, int x2, int y2, int force);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <default8x16.h>\n#include \"userinput.h\"\n#include \"macosx.h\"\n#include \"screen.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"8to24.h\"\n#include \"win_utils.h\"\n#include \"xrandr.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nvoid mark_rect_as_modified(int x1, int y1, int x2, int y2, int force);\n\nvoid mark_rect_as_modified(int x1, int y1, int x2, int y2, int force) {\n\n\tif (damage_time != 0) {\n\t\t/*\n\t\t * This is not XDAMAGE, rather a hack for testing\n\t\t * where we allow the framebuffer to be corrupted for\n\t\t * damage_delay seconds.\n\t\t */\n\t\tint debug = 0;\n\t\tif (time(NULL) > damage_time + damage_delay) {\n\t\t\tif (! quiet) {\n\t\t\t\trfbLog(\"damaging turned off.\\n\");\n\t\t\t}\n\t\t\tdamage_time = 0;\n\t\t\tdamage_delay = 0;\n\t\t} else {\n\t\t\tif (debug) {\n\t\t\t\trfbLog(\"damaging viewer fb by not marking \"\n\t\t\t\t    \"rect: %d,%d,%d,%d\\n\", x1, y1, x2, y2);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n\n\n\tif (rfb_fb == main_fb || force) {\n\t\tmark_wrapper(x1, y1, x2, y2);\n\t\treturn;\n\t}\n\n\tif (cmap8to24) {\n\t\tbpp8to24(x1, y1, x2, y2);\n\t}\n\n\tif (scaling) {\n\t\tscale_and_mark_rect(x1, y1, x2, y2, 1);\n\t} else {\n\t\tmark_wrapper(x1, y1, x2, y2);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "CEIL",
          "args": [
            "x2"
          ],
          "line": 1038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FLOOR",
          "args": [
            "x1"
          ],
          "line": 1009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfix",
          "args": [
            "J2",
            "Ny"
          ],
          "line": 988
        },
        "resolved": true,
        "details": {
          "function_name": "nfix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "95-102",
          "snippet": "int nfix(int i, int n) {\n\tif (i < 0) {\n\t\ti = 0;\n\t} else if (i >= n) {\n\t\ti = n - 1;\n\t}\n\treturn i;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int nfix(int i, int n);",
            "int nabs(int n);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nint nfix(int i, int n);\nint nabs(int n);\n\nint nfix(int i, int n) {\n\tif (i < 0) {\n\t\ti = 0;\n\t} else if (i >= n) {\n\t\ti = n - 1;\n\t}\n\treturn i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CEIL",
          "args": [
            "y2"
          ],
          "line": 987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FLOOR",
          "args": [
            "y1"
          ],
          "line": 983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CEIL",
          "args": [
            "(Y2+1)/dy"
          ],
          "line": 919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FLOOR",
          "args": [
            "Y1/dy"
          ],
          "line": 918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CEIL",
          "args": [
            "(X2+1)/dx"
          ],
          "line": 911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FLOOR",
          "args": [
            "X1/dx"
          ],
          "line": 908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"scale_and_mark_rect: using \"\n\t\t\t\t\t    \"constant pixel weight speedup \"\n\t\t\t\t\t    \"for 1/%d\\n\"",
            "n"
          ],
          "line": 870
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <default8x16.h>\n#include \"userinput.h\"\n#include \"macosx.h\"\n#include \"screen.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"8to24.h\"\n#include \"win_utils.h\"\n#include \"xrandr.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nvoid scale_rect(double factor_x, double factor_y, int blend, int interpolate, int Bpp,\n    char *src_fb, int src_bytes_per_line, char *dst_fb, int dst_bytes_per_line,\n    int Nx, int Ny, int nx, int ny, int X1, int Y1, int X2, int Y2, int mark);\nvoid scale_and_mark_rect(int X1, int Y1, int X2, int Y2, int mark);\nvoid mark_rect_as_modified(int x1, int y1, int x2, int y2, int force);\nvoid nap_sleep(int ms, int split);\nvoid rotate_curs(char *dst_0, char *src_0, int Dx, int Dy, int Bpp);\n\nvoid scale_rect(double factor_x, double factor_y, int blend, int interpolate, int Bpp,\n    char *src_fb, int src_bytes_per_line, char *dst_fb, int dst_bytes_per_line,\n    int Nx, int Ny, int nx, int ny, int X1, int Y1, int X2, int Y2, int mark) {\n/*\n * Notation:\n * \"i\" an x pixel index in the destination (scaled) framebuffer\n * \"j\" a  y pixel index in the destination (scaled) framebuffer\n * \"I\" an x pixel index in the source (un-scaled, i.e. main) framebuffer\n * \"J\" a  y pixel index in the source (un-scaled, i.e. main) framebuffer\n *\n *  Similarly for nx, ny, Nx, Ny, etc.  Lowercase: dest, Uppercase: source.\n */\n\tint i, j, i1, i2, j1, j2;\t/* indices for scaled fb (dest) */\n\tint I, J, I1, I2, J1, J2;\t/* indices for main fb   (source) */\n\n\tdouble w, wx, wy, wtot;\t/* pixel weights */\n\n\tdouble x1, y1, x2, y2;\t/* x-y coords for destination pixels edges */\n\tdouble dx, dy;\t\t/* size of destination pixel */\n\tdouble ddx=0, ddy=0;\t/* for interpolation expansion */\n\n\tchar *src, *dest;\t/* pointers to the two framebuffers */\n\n\n\tunsigned short us = 0;\n\tunsigned char  uc = 0;\n\tunsigned int   ui = 0;\n\n\tint use_noblend_shortcut = 1;\n\tint shrink;\t\t/* whether shrinking or expanding */\n\tstatic int constant_weights = -1, mag_int = -1;\n\tstatic int last_Nx = -1, last_Ny = -1, cnt = 0;\n\tstatic double last_factor = -1.0;\n\tint b, k;\n\tdouble pixave[4];\t/* for averaging pixel values */\n\n\tif (factor_x <= 1.0 && factor_y <= 1.0) {\n\t\tshrink = 1;\n\t} else {\n\t\tshrink = 0;\n\t}\n\n\t/*\n\t * N.B. width and height (real numbers) of a scaled pixel.\n\t * both are > 1   (e.g. 1.333 for -scale 3/4)\n\t * they should also be equal but we don't assume it.\n\t *\n\t * This new way is probably the best we can do, take the inverse\n\t * of the scaling factor to double precision.\n\t */\n\tdx = 1.0/factor_x;\n\tdy = 1.0/factor_y;\n\n\t/*\n\t * There is some speedup if the pixel weights are constant, so\n\t * let's special case these.\n\t *\n\t * If scale = 1/n and n divides Nx and Ny, the pixel weights\n\t * are constant (e.g. 1/2 => equal on 2x2 square).\n\t */\n\tif (factor_x != last_factor || Nx != last_Nx || Ny != last_Ny) {\n\t\tconstant_weights = -1;\n\t\tmag_int = -1;\n\t\tlast_Nx = Nx;\n\t\tlast_Ny = Ny;\n\t\tlast_factor = factor_x;\n\t}\n\tif (constant_weights < 0 && factor_x != factor_y) {\n\t\tconstant_weights = 0;\n\t\tmag_int = 0;\n\n\t} else if (constant_weights < 0) {\n\t\tint n = 0;\n\n\t\tconstant_weights = 0;\n\t\tmag_int = 0;\n\n\t\tfor (i = 2; i<=128; i++) {\n\t\t\tdouble test = ((double) 1)/ i;\n\t\t\tdouble diff, eps = 1.0e-7;\n\t\t\tdiff = factor_x - test;\n\t\t\tif (-eps < diff && diff < eps) {\n\t\t\t\tn = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (! blend || ! shrink || interpolate) {\n\t\t\t;\n\t\t} else if (n != 0) {\n\t\t\tif (Nx % n == 0 && Ny % n == 0) {\n\t\t\t\tstatic int didmsg = 0;\n\t\t\t\tif (mark && ! didmsg) {\n\t\t\t\t\tdidmsg = 1;\n\t\t\t\t\trfbLog(\"scale_and_mark_rect: using \"\n\t\t\t\t\t    \"constant pixel weight speedup \"\n\t\t\t\t\t    \"for 1/%d\\n\", n);\n\t\t\t\t}\n\t\t\t\tconstant_weights = 1;\n\t\t\t}\n\t\t}\n\n\t\tn = 0;\n\t\tfor (i = 2; i<=32; i++) {\n\t\t\tdouble test = (double) i;\n\t\t\tdouble diff, eps = 1.0e-7;\n\t\t\tdiff = factor_x - test;\n\t\t\tif (-eps < diff && diff < eps) {\n\t\t\t\tn = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (! blend && factor_x > 1.0 && n) {\n\t\t\tmag_int = n;\n\t\t}\n\t}\n\n\tif (mark && factor_x > 1.0 && blend) {\n\t\t/*\n\t\t * kludge: correct for interpolating blurring leaking\n\t\t * up or left 1 destination pixel.\n\t\t */\n\t\tif (X1 > 0) X1--;\n\t\tif (Y1 > 0) Y1--;\n\t}\n\n\t/*\n\t * find the extent of the change the input rectangle induces in\n\t * the scaled framebuffer.\n\t */\n\n\t/* Left edges: find largest i such that i * dx <= X1  */\n\ti1 = FLOOR(X1/dx);\n\n\t/* Right edges: find smallest i such that (i+1) * dx >= X2+1  */\n\ti2 = CEIL( (X2+1)/dx ) - 1;\n\n\t/* To be safe, correct any overflows: */\n\ti1 = nfix(i1, nx);\n\ti2 = nfix(i2, nx) + 1;\t/* add 1 to make a rectangle upper boundary */\n\n\t/* Repeat above for y direction: */\n\tj1 = FLOOR(Y1/dy);\n\tj2 = CEIL( (Y2+1)/dy ) - 1;\n\n\tj1 = nfix(j1, ny);\n\tj2 = nfix(j2, ny) + 1;\n\n\t/*\n\t * special case integer magnification with no blending.\n\t * vision impaired magnification usage is interested in this case.\n\t */\n\tif (mark && ! blend && mag_int && Bpp != 3) {\n\t\tint jmin, jmax, imin, imax;\n\n\t\t/* outer loop over *source* pixels */\n\t\tfor (J=Y1; J < Y2; J++) {\n\t\t    jmin = J * mag_int;\n\t\t    jmax = jmin + mag_int;\n\t\t    for (I=X1; I < X2; I++) {\n\t\t\t/* extract value */\n\t\t\tsrc = src_fb + J*src_bytes_per_line + I*Bpp;\n\t\t\tif (Bpp == 4) {\n\t\t\t\tui = *((unsigned int *)src);\n\t\t\t} else if (Bpp == 2) {\n\t\t\t\tus = *((unsigned short *)src);\n\t\t\t} else if (Bpp == 1) {\n\t\t\t\tuc = *((unsigned char *)src);\n\t\t\t}\n\t\t\timin = I * mag_int;\n\t\t\timax = imin + mag_int;\n\t\t\t/* inner loop over *dest* pixels */\n\t\t\tfor (j=jmin; j<jmax; j++) {\n\t\t\t    dest = dst_fb + j*dst_bytes_per_line + imin*Bpp;\n\t\t\t    for (i=imin; i<imax; i++) {\n\t\t\t\tif (Bpp == 4) {\n\t\t\t\t\t*((unsigned int *)dest) = ui;\n\t\t\t\t} else if (Bpp == 2) {\n\t\t\t\t\t*((unsigned short *)dest) = us;\n\t\t\t\t} else if (Bpp == 1) {\n\t\t\t\t\t*((unsigned char *)dest) = uc;\n\t\t\t\t}\n\t\t\t\tdest += Bpp;\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t}\n\t\tgoto markit;\n\t}\n\n\t/* set these all to 1.0 to begin with */\n\twx = 1.0;\n\twy = 1.0;\n\tw  = 1.0;\n\n\t/*\n\t * Loop over destination pixels in scaled fb:\n\t */\n\tfor (j=j1; j<j2; j++) {\n\t\ty1 =  j * dy;\t/* top edge */\n\t\tif (y1 > Ny - 1) {\n\t\t\t/* can go over with dy = 1/scale_fac */\n\t\t\ty1 = Ny - 1;\n\t\t}\n\t\ty2 = y1 + dy;\t/* bottom edge */\n\n\t\t/* Find main fb indices covered by this dest pixel: */\n\t\tJ1 = (int) FLOOR(y1);\n\t\tJ1 = nfix(J1, Ny);\n\n\t\tif (shrink && ! interpolate) {\n\t\t\tJ2 = (int) CEIL(y2) - 1;\n\t\t\tJ2 = nfix(J2, Ny);\n\t\t} else {\n\t\t\tJ2 = J1 + 1;\t/* simple interpolation */\n\t\t\tddy = y1 - J1;\n\t\t}\n\n\t\t/* destination char* pointer: */\n\t\tdest = dst_fb + j*dst_bytes_per_line + i1*Bpp;\n\t\t\n\t\tfor (i=i1; i<i2; i++) {\n\n\t\t\tx1 =  i * dx;\t/* left edge */\n\t\t\tif (x1 > Nx - 1) {\n\t\t\t\t/* can go over with dx = 1/scale_fac */\n\t\t\t\tx1 = Nx - 1;\n\t\t\t}\n\t\t\tx2 = x1 + dx;\t/* right edge */\n\n\t\t\tcnt++;\n\n\t\t\t/* Find main fb indices covered by this dest pixel: */\n\t\t\tI1 = (int) FLOOR(x1);\n\t\t\tif (I1 >= Nx) I1 = Nx - 1;\n\n\t\t\tif (! blend && use_noblend_shortcut) {\n\t\t\t\t/*\n\t\t\t\t * The noblend case involves no weights,\n\t\t\t\t * and 1 pixel, so just copy the value\n\t\t\t\t * directly.\n\t\t\t\t */\n\t\t\t\tsrc = src_fb + J1*src_bytes_per_line + I1*Bpp;\n\t\t\t\tif (Bpp == 4) {\n\t\t\t\t\t*((unsigned int *)dest)\n\t\t\t\t\t    = *((unsigned int *)src);\n\t\t\t\t} else if (Bpp == 2) {\n\t\t\t\t\t*((unsigned short *)dest)\n\t\t\t\t\t    = *((unsigned short *)src);\n\t\t\t\t} else if (Bpp == 1) {\n\t\t\t\t\t*(dest) = *(src);\n\t\t\t\t} else if (Bpp == 3) {\n\t\t\t\t\t/* rare case */\n\t\t\t\t\tfor (k=0; k<=2; k++) {\n\t\t\t\t\t\t*(dest+k) = *(src+k);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdest += Bpp;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tif (shrink && ! interpolate) {\n\t\t\t\tI2 = (int) CEIL(x2) - 1;\n\t\t\t\tif (I2 >= Nx) I2 = Nx - 1;\n\t\t\t} else {\n\t\t\t\tI2 = I1 + 1;\t/* simple interpolation */\n\t\t\t\tddx = x1 - I1;\n\t\t\t}\n\n\t\t\t/* Zero out accumulators for next pixel average: */\n\t\t\tfor (b=0; b<4; b++) {\n\t\t\t\tpixave[b] = 0.0; /* for RGB weighted sums */\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * wtot is for accumulating the total weight.\n\t\t\t * It should always sum to 1/(scale_fac * scale_fac).\n\t\t\t */\n\t\t\twtot = 0.0;\n\n\t\t\t/*\n\t\t\t * Loop over source pixels covered by this dest pixel.\n\t\t\t * \n\t\t\t * These \"extra\" loops over \"J\" and \"I\" make\n\t\t\t * the cache/cacheline performance unclear.\n\t\t\t * For example, will the data brought in from\n\t\t\t * src for j, i, and J=0 still be in the cache\n\t\t\t * after the J > 0 data have been accessed and\n\t\t\t * we are at j, i+1, J=0?  The stride in J is\n\t\t\t * main_bytes_per_line, and so ~4 KB.\n\t\t\t *\n\t\t\t * Typical case when shrinking are 2x2 loop, so\n\t\t\t * just two lines to worry about.\n\t\t\t */\n\t\t\tfor (J=J1; J<=J2; J++) {\n\t\t\t    /* see comments for I, x1, x2, etc. below */\n\t\t\t    if (constant_weights) {\n\t\t\t\t;\n\t\t\t    } else if (! blend) {\n\t\t\t\tif (J != J1) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\twy = 1.0;\n\n\t\t\t\t/* interpolation scheme: */\n\t\t\t    } else if (! shrink || interpolate) {\n\t\t\t\tif (J >= Ny) {\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if (J == J1) {\n\t\t\t\t\twy = 1.0 - ddy;\n\t\t\t\t} else if (J != J1) {\n\t\t\t\t\twy = ddy;\n\t\t\t\t}\n\n\t\t\t\t/* integration scheme: */\n\t\t\t    } else if (J < y1) {\n\t\t\t\twy = J+1 - y1;\n\t\t\t    } else if (J+1 > y2) {\n\t\t\t\twy = y2 - J;\n\t\t\t    } else {\n\t\t\t\twy = 1.0;\n\t\t\t    }\n\n\t\t\t    src = src_fb + J*src_bytes_per_line + I1*Bpp;\n\n\t\t\t    for (I=I1; I<=I2; I++) {\n\n\t\t\t\t/* Work out the weight: */\n\n\t\t\t\tif (constant_weights) {\n\t\t\t\t\t;\n\t\t\t\t} else if (! blend) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Ugh, PseudoColor colormap is\n\t\t\t\t\t * bad news, to avoid random\n\t\t\t\t\t * colors just take the first\n\t\t\t\t\t * pixel.  Or user may have\n\t\t\t\t\t * specified :nb to fraction.\n\t\t\t\t\t * The :fb will force blending\n\t\t\t\t\t * for this case.\n\t\t\t\t\t */\n\t\t\t\t\tif (I != I1) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\twx = 1.0;\n\n\t\t\t\t\t/* interpolation scheme: */\n\t\t\t\t} else if (! shrink || interpolate) {\n\t\t\t\t\tif (I >= Nx) {\n\t\t\t\t\t\tcontinue;\t/* off edge */\n\t\t\t\t\t} else if (I == I1) {\n\t\t\t\t\t\twx = 1.0 - ddx;\n\t\t\t\t\t} else if (I != I1) {\n\t\t\t\t\t\twx = ddx;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* integration scheme: */\n\t\t\t\t} else if (I < x1) {\n\t\t\t\t\t/* \n\t\t\t\t\t * source left edge (I) to the\n\t\t\t\t\t * left of dest left edge (x1):\n\t\t\t\t\t * fractional weight\n\t\t\t\t\t */\n\t\t\t\t\twx = I+1 - x1;\n\t\t\t\t} else if (I+1 > x2) {\n\t\t\t\t\t/* \n\t\t\t\t\t * source right edge (I+1) to the\n\t\t\t\t\t * right of dest right edge (x2):\n\t\t\t\t\t * fractional weight\n\t\t\t\t\t */\n\t\t\t\t\twx = x2 - I;\n\t\t\t\t} else {\n\t\t\t\t\t/* \n\t\t\t\t\t * source edges (I and I+1) completely\n\t\t\t\t\t * inside dest edges (x1 and x2):\n\t\t\t\t\t * full weight\n\t\t\t\t\t */\n\t\t\t\t\twx = 1.0;\n\t\t\t\t}\n\n\t\t\t\tw = wx * wy;\n\t\t\t\twtot += w;\n\n\t\t\t\t/* \n\t\t\t\t * We average the unsigned char value\n\t\t\t\t * instead of char value: otherwise\n\t\t\t\t * the minimum (char 0) is right next\n\t\t\t\t * to the maximum (char -1)!  This way\n\t\t\t\t * they are spread between 0 and 255.\n\t\t\t\t */\n\t\t\t\tif (Bpp == 4) {\n\t\t\t\t\t/* unroll the loops, can give 20% */\n\t\t\t\t\tpixave[0] += w * ((unsigned char) *(src  ));\n\t\t\t\t\tpixave[1] += w * ((unsigned char) *(src+1));\n\t\t\t\t\tpixave[2] += w * ((unsigned char) *(src+2));\n\t\t\t\t\tpixave[3] += w * ((unsigned char) *(src+3));\n\t\t\t\t} else if (Bpp == 2) {\n\t\t\t\t\t/*\n\t\t\t\t\t * 16bpp: trickier with green\n\t\t\t\t\t * split over two bytes, so we\n\t\t\t\t\t * use the masks:\n\t\t\t\t\t */\n\t\t\t\t\tus = *((unsigned short *) src);\n\t\t\t\t\tpixave[0] += w*(us & main_red_mask);\n\t\t\t\t\tpixave[1] += w*(us & main_green_mask);\n\t\t\t\t\tpixave[2] += w*(us & main_blue_mask);\n\t\t\t\t} else if (Bpp == 1) {\n\t\t\t\t\tpixave[0] += w *\n\t\t\t\t\t    ((unsigned char) *(src));\n\t\t\t\t} else {\n\t\t\t\t\tfor (b=0; b<Bpp; b++) {\n\t\t\t\t\t\tpixave[b] += w *\n\t\t\t\t\t\t    ((unsigned char) *(src+b));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsrc += Bpp;\n\t\t\t    }\n\t\t\t}\n\n\t\t\tif (wtot <= 0.0) {\n\t\t\t\twtot = 1.0;\n\t\t\t}\n\t\t\twtot = 1.0/wtot;\t/* normalization factor */\n\n\t\t\t/* place weighted average pixel in the scaled fb: */\n\t\t\tif (Bpp == 4) {\n\t\t\t\t*(dest  ) = (char) (wtot * pixave[0]);\n\t\t\t\t*(dest+1) = (char) (wtot * pixave[1]);\n\t\t\t\t*(dest+2) = (char) (wtot * pixave[2]);\n\t\t\t\t*(dest+3) = (char) (wtot * pixave[3]);\n\t\t\t} else if (Bpp == 2) {\n\t\t\t\t/* 16bpp / 565 case: */\n\t\t\t\tpixave[0] *= wtot;\n\t\t\t\tpixave[1] *= wtot;\n\t\t\t\tpixave[2] *= wtot;\n\t\t\t\tus =  (main_red_mask   & (int) pixave[0])\n\t\t\t\t    | (main_green_mask & (int) pixave[1])\n\t\t\t\t    | (main_blue_mask  & (int) pixave[2]);\n\t\t\t\t*( (unsigned short *) dest ) = us;\n\t\t\t} else if (Bpp == 1) {\n\t\t\t\t*(dest) = (char) (wtot * pixave[0]);\n\t\t\t} else {\n\t\t\t\tfor (b=0; b<Bpp; b++) {\n\t\t\t\t\t*(dest+b) = (char) (wtot * pixave[b]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tdest += Bpp;\n\t\t}\n\t}\n\tmarkit:\n\tif (mark) {\n\t\tmark_rect_as_modified(i1, j1, i2, j2, 1);\n\t}\n}"
  },
  {
    "function_name": "hint_updates",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/scan.c",
    "lines": "584-632",
    "snippet": "static void hint_updates(void) {\n\thint_t hint;\n\tint x, y, i, n, ty, th, tx, tw;\n\tint hint_count = 0, in_run = 0;\n\n\thint.x = hint.y = hint.w = hint.h = 0;\n\n\tfor (y=0; y < ntiles_y; y++) {\n\t\tfor (x=0; x < ntiles_x; x++) {\n\t\t\tn = x + y * ntiles_x;\n\n\t\t\tif (tile_has_diff[n]) {\n\t\t\t\tty = tile_region[n].first_line;\n\t\t\t\tth = tile_region[n].last_line - ty + 1;\n\n\t\t\t\ttx = tile_region[n].first_x;\n\t\t\t\ttw = tile_region[n].last_x - tx + 1;\n\t\t\t\tif (tx < 0) {\n\t\t\t\t\ttx = 0;\n\t\t\t\t\ttw = tile_x;\n\t\t\t\t}\n\n\t\t\t\tif (! in_run) {\n\t\t\t\t\tcreate_tile_hint( x * tile_x + tx,\n\t\t\t\t\t    y * tile_y + ty, tw, th, &hint);\n\t\t\t\t\tin_run = 1;\n\t\t\t\t} else {\n\t\t\t\t\textend_tile_hint( x * tile_x + tx,\n\t\t\t\t\t    y * tile_y + ty, tw, th, &hint);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (in_run) {\n\t\t\t\t\t/* end of a row run of altered tiles: */\n\t\t\t\t\tsave_hint(hint, hint_count++);\n\t\t\t\t\tin_run = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (in_run) {\t/* save the last row run */\n\t\t\tsave_hint(hint, hint_count++);\n\t\t\tin_run = 0;\n\t\t}\n\t}\n\n\tfor (i=0; i < hint_count; i++) {\n\t\t/* pass update info to vnc: */\n\t\tmark_hint(hint_list[i]);\n\t}\n}",
    "includes": [
      "#include <default8x16.h>",
      "#include \"userinput.h\"",
      "#include \"macosx.h\"",
      "#include \"screen.h\"",
      "#include \"unixpw.h\"",
      "#include \"cleanup.h\"",
      "#include \"pointer.h\"",
      "#include \"screen.h\"",
      "#include \"8to24.h\"",
      "#include \"win_utils.h\"",
      "#include \"xrandr.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"xinerama.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void create_tile_hint(int x, int y, int tw, int th, hint_t *hint);",
      "static void extend_tile_hint(int x, int y, int tw, int th, hint_t *hint);",
      "static void hint_updates(void);",
      "static void mark_hint(hint_t hint);",
      "static int island_try(int x, int y, int u, int v, int *run);",
      "static hint_t *hint_list;",
      "static region_t *tile_region;",
      "static int *first_line = NULL, *last_line = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_hint",
          "args": [
            "hint_list[i]"
          ],
          "line": 630
        },
        "resolved": true,
        "details": {
          "function_name": "mark_hint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/scan.c",
          "lines": "1687-1694",
          "snippet": "static void mark_hint(hint_t hint) {\n\tint x = hint.x;\t\n\tint y = hint.y;\t\n\tint w = hint.w;\t\n\tint h = hint.h;\t\n\n\tmark_rect_as_modified(x, y, x + w, y + h, 0);\n}",
          "includes": [
            "#include <default8x16.h>",
            "#include \"userinput.h\"",
            "#include \"macosx.h\"",
            "#include \"screen.h\"",
            "#include \"unixpw.h\"",
            "#include \"cleanup.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"8to24.h\"",
            "#include \"win_utils.h\"",
            "#include \"xrandr.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void create_tile_hint(int x, int y, int tw, int th, hint_t *hint);",
            "static void extend_tile_hint(int x, int y, int tw, int th, hint_t *hint);",
            "static void mark_hint(hint_t hint);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <default8x16.h>\n#include \"userinput.h\"\n#include \"macosx.h\"\n#include \"screen.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"8to24.h\"\n#include \"win_utils.h\"\n#include \"xrandr.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nstatic void create_tile_hint(int x, int y, int tw, int th, hint_t *hint);\nstatic void extend_tile_hint(int x, int y, int tw, int th, hint_t *hint);\nstatic void mark_hint(hint_t hint);\n\nstatic void mark_hint(hint_t hint) {\n\tint x = hint.x;\t\n\tint y = hint.y;\t\n\tint w = hint.w;\t\n\tint h = hint.h;\t\n\n\tmark_rect_as_modified(x, y, x + w, y + h, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "save_hint",
          "args": [
            "hint",
            "hint_count++"
          ],
          "line": 623
        },
        "resolved": true,
        "details": {
          "function_name": "save_hint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/scan.c",
          "lines": "572-578",
          "snippet": "static void save_hint(hint_t hint, int loc) {\n\t/* simply copy it to the global array for later use. */\n\thint_list[loc].x = hint.x;\n\thint_list[loc].y = hint.y;\n\thint_list[loc].w = hint.w;\n\thint_list[loc].h = hint.h;\n}",
          "includes": [
            "#include <default8x16.h>",
            "#include \"userinput.h\"",
            "#include \"macosx.h\"",
            "#include \"screen.h\"",
            "#include \"unixpw.h\"",
            "#include \"cleanup.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"8to24.h\"",
            "#include \"win_utils.h\"",
            "#include \"xrandr.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void create_tile_hint(int x, int y, int tw, int th, hint_t *hint);",
            "static void extend_tile_hint(int x, int y, int tw, int th, hint_t *hint);",
            "static void save_hint(hint_t hint, int loc);",
            "static void mark_hint(hint_t hint);",
            "static hint_t *hint_list;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <default8x16.h>\n#include \"userinput.h\"\n#include \"macosx.h\"\n#include \"screen.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"8to24.h\"\n#include \"win_utils.h\"\n#include \"xrandr.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nstatic void create_tile_hint(int x, int y, int tw, int th, hint_t *hint);\nstatic void extend_tile_hint(int x, int y, int tw, int th, hint_t *hint);\nstatic void save_hint(hint_t hint, int loc);\nstatic void mark_hint(hint_t hint);\nstatic hint_t *hint_list;\n\nstatic void save_hint(hint_t hint, int loc) {\n\t/* simply copy it to the global array for later use. */\n\thint_list[loc].x = hint.x;\n\thint_list[loc].y = hint.y;\n\thint_list[loc].w = hint.w;\n\thint_list[loc].h = hint.h;\n}"
        }
      },
      {
        "call_info": {
          "callee": "extend_tile_hint",
          "args": [
            "x * tile_x + tx",
            "y * tile_y + ty",
            "tw",
            "th",
            "&hint"
          ],
          "line": 611
        },
        "resolved": true,
        "details": {
          "function_name": "extend_tile_hint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/scan.c",
          "lines": "544-570",
          "snippet": "static void extend_tile_hint(int x, int y, int tw, int th, hint_t *hint) {\n\tint w = dpy_x - x;\n\tint h = dpy_y - y;\n\n\tif (w > tw) {\n\t\tw = tw;\n\t}\n\tif (h > th) {\n\t\th = th;\n\t}\n\n\tif (hint->x > x) {\t\t\t/* extend to the left */\n\t\thint->w += hint->x - x;\n\t\thint->x = x;\n\t}\n\tif (hint->y > y) {\t\t\t/* extend upward */\n\t\thint->h += hint->y - y;\n\t\thint->y = y;\n\t}\n\n\tif (hint->x + hint->w < x + w) {\t/* extend to the right */\n\t\thint->w = x + w - hint->x;\n\t}\n\tif (hint->y + hint->h < y + h) {\t/* extend downward */\n\t\thint->h = y + h - hint->y;\n\t}\n}",
          "includes": [
            "#include <default8x16.h>",
            "#include \"userinput.h\"",
            "#include \"macosx.h\"",
            "#include \"screen.h\"",
            "#include \"unixpw.h\"",
            "#include \"cleanup.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"8to24.h\"",
            "#include \"win_utils.h\"",
            "#include \"xrandr.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void create_tile_hint(int x, int y, int tw, int th, hint_t *hint);",
            "static void extend_tile_hint(int x, int y, int tw, int th, hint_t *hint);",
            "static void mark_hint(hint_t hint);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <default8x16.h>\n#include \"userinput.h\"\n#include \"macosx.h\"\n#include \"screen.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"8to24.h\"\n#include \"win_utils.h\"\n#include \"xrandr.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nstatic void create_tile_hint(int x, int y, int tw, int th, hint_t *hint);\nstatic void extend_tile_hint(int x, int y, int tw, int th, hint_t *hint);\nstatic void mark_hint(hint_t hint);\n\nstatic void extend_tile_hint(int x, int y, int tw, int th, hint_t *hint) {\n\tint w = dpy_x - x;\n\tint h = dpy_y - y;\n\n\tif (w > tw) {\n\t\tw = tw;\n\t}\n\tif (h > th) {\n\t\th = th;\n\t}\n\n\tif (hint->x > x) {\t\t\t/* extend to the left */\n\t\thint->w += hint->x - x;\n\t\thint->x = x;\n\t}\n\tif (hint->y > y) {\t\t\t/* extend upward */\n\t\thint->h += hint->y - y;\n\t\thint->y = y;\n\t}\n\n\tif (hint->x + hint->w < x + w) {\t/* extend to the right */\n\t\thint->w = x + w - hint->x;\n\t}\n\tif (hint->y + hint->h < y + h) {\t/* extend downward */\n\t\thint->h = y + h - hint->y;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_tile_hint",
          "args": [
            "x * tile_x + tx",
            "y * tile_y + ty",
            "tw",
            "th",
            "&hint"
          ],
          "line": 607
        },
        "resolved": true,
        "details": {
          "function_name": "create_tile_hint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/scan.c",
          "lines": "527-542",
          "snippet": "static void create_tile_hint(int x, int y, int tw, int th, hint_t *hint) {\n\tint w = dpy_x - x;\n\tint h = dpy_y - y;\n\n\tif (w > tw) {\n\t\tw = tw;\n\t}\n\tif (h > th) {\n\t\th = th;\n\t}\n\n\thint->x = x;\n\thint->y = y;\n\thint->w = w;\n\thint->h = h;\n}",
          "includes": [
            "#include <default8x16.h>",
            "#include \"userinput.h\"",
            "#include \"macosx.h\"",
            "#include \"screen.h\"",
            "#include \"unixpw.h\"",
            "#include \"cleanup.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"8to24.h\"",
            "#include \"win_utils.h\"",
            "#include \"xrandr.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void create_tile_hint(int x, int y, int tw, int th, hint_t *hint);",
            "static void extend_tile_hint(int x, int y, int tw, int th, hint_t *hint);",
            "static void mark_hint(hint_t hint);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <default8x16.h>\n#include \"userinput.h\"\n#include \"macosx.h\"\n#include \"screen.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"8to24.h\"\n#include \"win_utils.h\"\n#include \"xrandr.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nstatic void create_tile_hint(int x, int y, int tw, int th, hint_t *hint);\nstatic void extend_tile_hint(int x, int y, int tw, int th, hint_t *hint);\nstatic void mark_hint(hint_t hint);\n\nstatic void create_tile_hint(int x, int y, int tw, int th, hint_t *hint) {\n\tint w = dpy_x - x;\n\tint h = dpy_y - y;\n\n\tif (w > tw) {\n\t\tw = tw;\n\t}\n\tif (h > th) {\n\t\th = th;\n\t}\n\n\thint->x = x;\n\thint->y = y;\n\thint->w = w;\n\thint->h = h;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <default8x16.h>\n#include \"userinput.h\"\n#include \"macosx.h\"\n#include \"screen.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"8to24.h\"\n#include \"win_utils.h\"\n#include \"xrandr.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nstatic void create_tile_hint(int x, int y, int tw, int th, hint_t *hint);\nstatic void extend_tile_hint(int x, int y, int tw, int th, hint_t *hint);\nstatic void hint_updates(void);\nstatic void mark_hint(hint_t hint);\nstatic int island_try(int x, int y, int u, int v, int *run);\nstatic hint_t *hint_list;\nstatic region_t *tile_region;\nstatic int *first_line = NULL, *last_line = NULL;\n\nstatic void hint_updates(void) {\n\thint_t hint;\n\tint x, y, i, n, ty, th, tx, tw;\n\tint hint_count = 0, in_run = 0;\n\n\thint.x = hint.y = hint.w = hint.h = 0;\n\n\tfor (y=0; y < ntiles_y; y++) {\n\t\tfor (x=0; x < ntiles_x; x++) {\n\t\t\tn = x + y * ntiles_x;\n\n\t\t\tif (tile_has_diff[n]) {\n\t\t\t\tty = tile_region[n].first_line;\n\t\t\t\tth = tile_region[n].last_line - ty + 1;\n\n\t\t\t\ttx = tile_region[n].first_x;\n\t\t\t\ttw = tile_region[n].last_x - tx + 1;\n\t\t\t\tif (tx < 0) {\n\t\t\t\t\ttx = 0;\n\t\t\t\t\ttw = tile_x;\n\t\t\t\t}\n\n\t\t\t\tif (! in_run) {\n\t\t\t\t\tcreate_tile_hint( x * tile_x + tx,\n\t\t\t\t\t    y * tile_y + ty, tw, th, &hint);\n\t\t\t\t\tin_run = 1;\n\t\t\t\t} else {\n\t\t\t\t\textend_tile_hint( x * tile_x + tx,\n\t\t\t\t\t    y * tile_y + ty, tw, th, &hint);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (in_run) {\n\t\t\t\t\t/* end of a row run of altered tiles: */\n\t\t\t\t\tsave_hint(hint, hint_count++);\n\t\t\t\t\tin_run = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (in_run) {\t/* save the last row run */\n\t\t\tsave_hint(hint, hint_count++);\n\t\t\tin_run = 0;\n\t\t}\n\t}\n\n\tfor (i=0; i < hint_count; i++) {\n\t\t/* pass update info to vnc: */\n\t\tmark_hint(hint_list[i]);\n\t}\n}"
  },
  {
    "function_name": "save_hint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/scan.c",
    "lines": "572-578",
    "snippet": "static void save_hint(hint_t hint, int loc) {\n\t/* simply copy it to the global array for later use. */\n\thint_list[loc].x = hint.x;\n\thint_list[loc].y = hint.y;\n\thint_list[loc].w = hint.w;\n\thint_list[loc].h = hint.h;\n}",
    "includes": [
      "#include <default8x16.h>",
      "#include \"userinput.h\"",
      "#include \"macosx.h\"",
      "#include \"screen.h\"",
      "#include \"unixpw.h\"",
      "#include \"cleanup.h\"",
      "#include \"pointer.h\"",
      "#include \"screen.h\"",
      "#include \"8to24.h\"",
      "#include \"win_utils.h\"",
      "#include \"xrandr.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"xinerama.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void create_tile_hint(int x, int y, int tw, int th, hint_t *hint);",
      "static void extend_tile_hint(int x, int y, int tw, int th, hint_t *hint);",
      "static void save_hint(hint_t hint, int loc);",
      "static void mark_hint(hint_t hint);",
      "static hint_t *hint_list;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <default8x16.h>\n#include \"userinput.h\"\n#include \"macosx.h\"\n#include \"screen.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"8to24.h\"\n#include \"win_utils.h\"\n#include \"xrandr.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nstatic void create_tile_hint(int x, int y, int tw, int th, hint_t *hint);\nstatic void extend_tile_hint(int x, int y, int tw, int th, hint_t *hint);\nstatic void save_hint(hint_t hint, int loc);\nstatic void mark_hint(hint_t hint);\nstatic hint_t *hint_list;\n\nstatic void save_hint(hint_t hint, int loc) {\n\t/* simply copy it to the global array for later use. */\n\thint_list[loc].x = hint.x;\n\thint_list[loc].y = hint.y;\n\thint_list[loc].w = hint.w;\n\thint_list[loc].h = hint.h;\n}"
  },
  {
    "function_name": "extend_tile_hint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/scan.c",
    "lines": "544-570",
    "snippet": "static void extend_tile_hint(int x, int y, int tw, int th, hint_t *hint) {\n\tint w = dpy_x - x;\n\tint h = dpy_y - y;\n\n\tif (w > tw) {\n\t\tw = tw;\n\t}\n\tif (h > th) {\n\t\th = th;\n\t}\n\n\tif (hint->x > x) {\t\t\t/* extend to the left */\n\t\thint->w += hint->x - x;\n\t\thint->x = x;\n\t}\n\tif (hint->y > y) {\t\t\t/* extend upward */\n\t\thint->h += hint->y - y;\n\t\thint->y = y;\n\t}\n\n\tif (hint->x + hint->w < x + w) {\t/* extend to the right */\n\t\thint->w = x + w - hint->x;\n\t}\n\tif (hint->y + hint->h < y + h) {\t/* extend downward */\n\t\thint->h = y + h - hint->y;\n\t}\n}",
    "includes": [
      "#include <default8x16.h>",
      "#include \"userinput.h\"",
      "#include \"macosx.h\"",
      "#include \"screen.h\"",
      "#include \"unixpw.h\"",
      "#include \"cleanup.h\"",
      "#include \"pointer.h\"",
      "#include \"screen.h\"",
      "#include \"8to24.h\"",
      "#include \"win_utils.h\"",
      "#include \"xrandr.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"xinerama.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void create_tile_hint(int x, int y, int tw, int th, hint_t *hint);",
      "static void extend_tile_hint(int x, int y, int tw, int th, hint_t *hint);",
      "static void mark_hint(hint_t hint);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <default8x16.h>\n#include \"userinput.h\"\n#include \"macosx.h\"\n#include \"screen.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"8to24.h\"\n#include \"win_utils.h\"\n#include \"xrandr.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nstatic void create_tile_hint(int x, int y, int tw, int th, hint_t *hint);\nstatic void extend_tile_hint(int x, int y, int tw, int th, hint_t *hint);\nstatic void mark_hint(hint_t hint);\n\nstatic void extend_tile_hint(int x, int y, int tw, int th, hint_t *hint) {\n\tint w = dpy_x - x;\n\tint h = dpy_y - y;\n\n\tif (w > tw) {\n\t\tw = tw;\n\t}\n\tif (h > th) {\n\t\th = th;\n\t}\n\n\tif (hint->x > x) {\t\t\t/* extend to the left */\n\t\thint->w += hint->x - x;\n\t\thint->x = x;\n\t}\n\tif (hint->y > y) {\t\t\t/* extend upward */\n\t\thint->h += hint->y - y;\n\t\thint->y = y;\n\t}\n\n\tif (hint->x + hint->w < x + w) {\t/* extend to the right */\n\t\thint->w = x + w - hint->x;\n\t}\n\tif (hint->y + hint->h < y + h) {\t/* extend downward */\n\t\thint->h = y + h - hint->y;\n\t}\n}"
  },
  {
    "function_name": "create_tile_hint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/scan.c",
    "lines": "527-542",
    "snippet": "static void create_tile_hint(int x, int y, int tw, int th, hint_t *hint) {\n\tint w = dpy_x - x;\n\tint h = dpy_y - y;\n\n\tif (w > tw) {\n\t\tw = tw;\n\t}\n\tif (h > th) {\n\t\th = th;\n\t}\n\n\thint->x = x;\n\thint->y = y;\n\thint->w = w;\n\thint->h = h;\n}",
    "includes": [
      "#include <default8x16.h>",
      "#include \"userinput.h\"",
      "#include \"macosx.h\"",
      "#include \"screen.h\"",
      "#include \"unixpw.h\"",
      "#include \"cleanup.h\"",
      "#include \"pointer.h\"",
      "#include \"screen.h\"",
      "#include \"8to24.h\"",
      "#include \"win_utils.h\"",
      "#include \"xrandr.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"xinerama.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void create_tile_hint(int x, int y, int tw, int th, hint_t *hint);",
      "static void extend_tile_hint(int x, int y, int tw, int th, hint_t *hint);",
      "static void mark_hint(hint_t hint);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <default8x16.h>\n#include \"userinput.h\"\n#include \"macosx.h\"\n#include \"screen.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"8to24.h\"\n#include \"win_utils.h\"\n#include \"xrandr.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nstatic void create_tile_hint(int x, int y, int tw, int th, hint_t *hint);\nstatic void extend_tile_hint(int x, int y, int tw, int th, hint_t *hint);\nstatic void mark_hint(hint_t hint);\n\nstatic void create_tile_hint(int x, int y, int tw, int th, hint_t *hint) {\n\tint w = dpy_x - x;\n\tint h = dpy_y - y;\n\n\tif (w > tw) {\n\t\tw = tw;\n\t}\n\tif (h > th) {\n\t\th = th;\n\t}\n\n\thint->x = x;\n\thint->y = y;\n\thint->w = w;\n\thint->h = h;\n}"
  },
  {
    "function_name": "initialize_polling_images",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/scan.c",
    "lines": "423-520",
    "snippet": "void initialize_polling_images(void) {\n\tint i, MB = 1024 * 1024;\n\n\t/* set all shm areas to \"none\" before trying to create any */\n\tscanline_shm.shmid\t= -1;\n\tscanline_shm.shmaddr\t= (char *) -1;\n\tscanline\t\t= NULL;\n\tfullscreen_shm.shmid\t= -1;\n\tfullscreen_shm.shmaddr\t= (char *) -1;\n\tfullscreen\t\t= NULL;\n\tsnaprect_shm.shmid\t= -1;\n\tsnaprect_shm.shmaddr\t= (char *) -1;\n\tsnaprect\t\t= NULL;\n\tfor (i=1; i<=ntiles_x; i++) {\n\t\ttile_row_shm[i].shmid\t= -1;\n\t\ttile_row_shm[i].shmaddr\t= (char *) -1;\n\t\ttile_row[i]\t\t= NULL;\n\t}\n\n\t/* the scanline (e.g. 1280x1) shared memory area image: */\n\n\tif (! shm_create(&scanline_shm, &scanline, dpy_x, 1, \"scanline\")) {\n\t\tclean_up_exit(1);\n\t}\n\n\t/*\n\t * the fullscreen (e.g. 1280x1024/fs_factor) shared memory area image:\n\t * (we cut down the size of the shm area to try avoid and shm segment\n\t * limits, e.g. the default 1MB on Solaris)\n\t */\n\tif (UT.sysname && strstr(UT.sysname, \"Linux\")) {\n\t\tset_fs_factor(10 * MB);\n\t} else {\n\t\tset_fs_factor(1 * MB);\n\t}\n\tif (fs_frac >= 1.0) {\n\t\tfs_frac = 1.1;\n\t\tfs_factor = 0;\n\t}\n\tif (! fs_factor) {\n\t\trfbLog(\"warning: fullscreen updates are disabled.\\n\");\n\t} else {\n\t\tif (! shm_create(&fullscreen_shm, &fullscreen, dpy_x,\n\t\t    dpy_y/fs_factor, \"fullscreen\")) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t}\n\tif (use_snapfb) {\n\t\tif (! fs_factor) {\n\t\t\trfbLog(\"warning: disabling -snapfb mode.\\n\");\n\t\t\tuse_snapfb = 0;\n\t\t} else if (! shm_create(&snaprect_shm, &snaprect, dpy_x,\n\t\t    dpy_y/fs_factor, \"snaprect\")) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t}\n\n\t/*\n\t * for copy_tiles we need a lot of shared memory areas, one for\n\t * each possible run length of changed tiles.  32 for 1024x768\n\t * and 40 for 1280x1024, etc. \n\t */\n\n\ttile_shm_count = 0;\n\tfor (i=1; i<=ntiles_x; i++) {\n\t\tif (! shm_create(&tile_row_shm[i], &tile_row[i], tile_x * i,\n\t\t    tile_y, \"tile_row\")) {\n\t\t\tif (i == 1) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\trfbLog(\"shm: Error creating shared memory tile-row for\"\n\t\t\t    \" len=%d,\\n\", i);\n\t\t\trfbLog(\"shm: reverting to -onetile mode. If this\"\n\t\t\t    \" problem persists\\n\");\n\t\t\trfbLog(\"shm: try using the -onetile or -noshm options\"\n\t\t\t    \" to limit\\n\");\n\t\t\trfbLog(\"shm: shared memory usage, or run ipcrm(1)\"\n\t\t\t    \" to manually\\n\");\n\t\t\trfbLog(\"shm: delete unattached shm segments.\\n\");\n\t\t\tsingle_copytile_count = i;\n\t\t\tsingle_copytile = 1;\n\t\t}\n\t\ttile_shm_count++;\n\t\tif (single_copytile && i >= 1) {\n\t\t\t/* only need 1x1 tiles */\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (verbose) {\n\t\tif (using_shm && ! xform24to32) {\n\t\t\trfbLog(\"created %d tile_row shm polling images.\\n\",\n\t\t\t    tile_shm_count);\n\t\t} else {\n\t\t\trfbLog(\"created %d tile_row polling images.\\n\",\n\t\t\t    tile_shm_count);\n\t\t}\n\t}\n}",
    "includes": [
      "#include <default8x16.h>",
      "#include \"userinput.h\"",
      "#include \"macosx.h\"",
      "#include \"screen.h\"",
      "#include \"unixpw.h\"",
      "#include \"cleanup.h\"",
      "#include \"pointer.h\"",
      "#include \"screen.h\"",
      "#include \"8to24.h\"",
      "#include \"win_utils.h\"",
      "#include \"xrandr.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"xinerama.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void shm_delete(XShmSegmentInfo *shm);",
      "void initialize_polling_images(void);",
      "static int island_try(int x, int y, int u, int v, int *run);",
      "static int fs_factor = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"created %d tile_row polling images.\\n\"",
            "tile_shm_count"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"created %d tile_row shm polling images.\\n\"",
            "tile_shm_count"
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"shm: delete unattached shm segments.\\n\""
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"shm: shared memory usage, or run ipcrm(1)\"\n\t\t\t    \" to manually\\n\""
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"shm: try using the -onetile or -noshm options\"\n\t\t\t    \" to limit\\n\""
          ],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"shm: reverting to -onetile mode. If this\"\n\t\t\t    \" problem persists\\n\""
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"shm: Error creating shared memory tile-row for\"\n\t\t\t    \" len=%d,\\n\"",
            "i"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clean_up_exit",
          "args": [
            "1"
          ],
          "line": 491
        },
        "resolved": true,
        "details": {
          "function_name": "clean_up_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
          "lines": "151-266",
          "snippet": "void clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"uinput.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"screen.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"connections.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void clean_up_exit(int ret);",
            "int known_sigpipe_mode(char *s);",
            "static int exit_flag = 0;",
            "static void clean_icon_mode(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid clean_up_exit(int ret);\nint known_sigpipe_mode(char *s);\nstatic int exit_flag = 0;\nstatic void clean_icon_mode(void);\n\nvoid clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "shm_create",
          "args": [
            "&tile_row_shm[i]",
            "&tile_row[i]",
            "tile_x * i",
            "tile_y",
            "\"tile_row\""
          ],
          "line": 488
        },
        "resolved": true,
        "details": {
          "function_name": "shm_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/scan.c",
          "lines": "247-372",
          "snippet": "static int shm_create(XShmSegmentInfo *shm, XImage **ximg_ptr, int w, int h,\n    char *name) {\n\n\tXImage *xim;\n\tstatic int reported_flip = 0;\n\tint db = 0;\n\n\tshm->shmid = -1;\n\tshm->shmaddr = (char *) -1;\n\t*ximg_ptr = NULL;\n\n\tif (nofb) {\n\t\treturn 1;\n\t}\n\n\tX_LOCK;\n\n\tif (! using_shm || xform24to32 || raw_fb) {\n\t\t/* we only need the XImage created */\n\t\txim = XCreateImage_wr(dpy, default_visual, depth, ZPixmap,\n\t\t    0, NULL, w, h, raw_fb ? 32 : BitmapPad(dpy), 0);\n\n\t\tX_UNLOCK;\n\n\t\tif (xim == NULL) {\n\t\t\trfbErr(\"XCreateImage(%s) failed.\\n\", name);\n\t\t\tif (quiet) {\n\t\t\t\tfprintf(stderr, \"XCreateImage(%s) failed.\\n\",\n\t\t\t\t    name);\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tif (db) fprintf(stderr, \"shm_create simple %d %d\\t%p %s\\n\", w, h, (void *)xim, name);\n\t\txim->data = (char *) malloc(xim->bytes_per_line * xim->height);\n\t\tif (xim->data == NULL) {\n\t\t\trfbErr(\"XCreateImage(%s) data malloc failed.\\n\", name);\n\t\t\tif (quiet) {\n\t\t\t\tfprintf(stderr, \"XCreateImage(%s) data malloc\"\n\t\t\t\t    \" failed.\\n\", name);\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tif (flip_byte_order) {\n\t\t\tchar *order = flip_ximage_byte_order(xim);\n\t\t\tif (! reported_flip && ! quiet) {\n\t\t\t\trfbLog(\"Changing XImage byte order\"\n\t\t\t\t    \" to %s\\n\", order);\n\t\t\t\treported_flip = 1;\n\t\t\t}\n\t\t}\n\n\t\t*ximg_ptr = xim;\n\t\treturn 1;\n\t}\n\n\tif (! dpy) {\n\t\tX_UNLOCK;\n\t\treturn 0;\n\t}\n\n\txim = XShmCreateImage_wr(dpy, default_visual, depth, ZPixmap, NULL,\n\t    shm, w, h);\n\n\tif (xim == NULL) {\n\t\trfbErr(\"XShmCreateImage(%s) failed.\\n\", name);\n\t\tif (quiet) {\n\t\t\tfprintf(stderr, \"XShmCreateImage(%s) failed.\\n\", name);\n\t\t}\n\t\tX_UNLOCK;\n\t\treturn 0;\n\t}\n\n\t*ximg_ptr = xim;\n\n#if HAVE_XSHM\n\tshm->shmid = shmget(IPC_PRIVATE,\n\t    xim->bytes_per_line * xim->height, IPC_CREAT | 0777);\n\n\tif (shm->shmid == -1) {\n\t\trfbErr(\"shmget(%s) failed.\\n\", name);\n\t\trfbLogPerror(\"shmget\");\n\n\t\tXDestroyImage(xim);\n\t\t*ximg_ptr = NULL;\n\n\t\tX_UNLOCK;\n\t\treturn 0;\n\t}\n\n\tshm->shmaddr = xim->data = (char *) shmat(shm->shmid, 0, 0);\n\n\tif (shm->shmaddr == (char *)-1) {\n\t\trfbErr(\"shmat(%s) failed.\\n\", name);\n\t\trfbLogPerror(\"shmat\");\n\n\t\tXDestroyImage(xim);\n\t\t*ximg_ptr = NULL;\n\n\t\tshmctl(shm->shmid, IPC_RMID, 0);\n\t\tshm->shmid = -1;\n\n\t\tX_UNLOCK;\n\t\treturn 0;\n\t}\n\n\tshm->readOnly = False;\n\n\tif (! XShmAttach_wr(dpy, shm)) {\n\t\trfbErr(\"XShmAttach(%s) failed.\\n\", name);\n\t\tXDestroyImage(xim);\n\t\t*ximg_ptr = NULL;\n\n\t\tshmdt(shm->shmaddr);\n\t\tshm->shmaddr = (char *) -1;\n\n\t\tshmctl(shm->shmid, IPC_RMID, 0);\n\t\tshm->shmid = -1;\n\n\t\tX_UNLOCK;\n\t\treturn 0;\n\t}\n#endif\n\n\tX_UNLOCK;\n\treturn 1;\n}",
          "includes": [
            "#include <default8x16.h>",
            "#include \"userinput.h\"",
            "#include \"macosx.h\"",
            "#include \"screen.h\"",
            "#include \"unixpw.h\"",
            "#include \"cleanup.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"8to24.h\"",
            "#include \"win_utils.h\"",
            "#include \"xrandr.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void shm_delete(XShmSegmentInfo *shm);",
            "void shm_clean(XShmSegmentInfo *shm, XImage *xim);",
            "static char *flip_ximage_byte_order(XImage *xim);",
            "static int shm_create(XShmSegmentInfo *shm, XImage **ximg_ptr, int w, int h,\n    char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <default8x16.h>\n#include \"userinput.h\"\n#include \"macosx.h\"\n#include \"screen.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"8to24.h\"\n#include \"win_utils.h\"\n#include \"xrandr.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nvoid shm_delete(XShmSegmentInfo *shm);\nvoid shm_clean(XShmSegmentInfo *shm, XImage *xim);\nstatic char *flip_ximage_byte_order(XImage *xim);\nstatic int shm_create(XShmSegmentInfo *shm, XImage **ximg_ptr, int w, int h,\n    char *name);\n\nstatic int shm_create(XShmSegmentInfo *shm, XImage **ximg_ptr, int w, int h,\n    char *name) {\n\n\tXImage *xim;\n\tstatic int reported_flip = 0;\n\tint db = 0;\n\n\tshm->shmid = -1;\n\tshm->shmaddr = (char *) -1;\n\t*ximg_ptr = NULL;\n\n\tif (nofb) {\n\t\treturn 1;\n\t}\n\n\tX_LOCK;\n\n\tif (! using_shm || xform24to32 || raw_fb) {\n\t\t/* we only need the XImage created */\n\t\txim = XCreateImage_wr(dpy, default_visual, depth, ZPixmap,\n\t\t    0, NULL, w, h, raw_fb ? 32 : BitmapPad(dpy), 0);\n\n\t\tX_UNLOCK;\n\n\t\tif (xim == NULL) {\n\t\t\trfbErr(\"XCreateImage(%s) failed.\\n\", name);\n\t\t\tif (quiet) {\n\t\t\t\tfprintf(stderr, \"XCreateImage(%s) failed.\\n\",\n\t\t\t\t    name);\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tif (db) fprintf(stderr, \"shm_create simple %d %d\\t%p %s\\n\", w, h, (void *)xim, name);\n\t\txim->data = (char *) malloc(xim->bytes_per_line * xim->height);\n\t\tif (xim->data == NULL) {\n\t\t\trfbErr(\"XCreateImage(%s) data malloc failed.\\n\", name);\n\t\t\tif (quiet) {\n\t\t\t\tfprintf(stderr, \"XCreateImage(%s) data malloc\"\n\t\t\t\t    \" failed.\\n\", name);\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tif (flip_byte_order) {\n\t\t\tchar *order = flip_ximage_byte_order(xim);\n\t\t\tif (! reported_flip && ! quiet) {\n\t\t\t\trfbLog(\"Changing XImage byte order\"\n\t\t\t\t    \" to %s\\n\", order);\n\t\t\t\treported_flip = 1;\n\t\t\t}\n\t\t}\n\n\t\t*ximg_ptr = xim;\n\t\treturn 1;\n\t}\n\n\tif (! dpy) {\n\t\tX_UNLOCK;\n\t\treturn 0;\n\t}\n\n\txim = XShmCreateImage_wr(dpy, default_visual, depth, ZPixmap, NULL,\n\t    shm, w, h);\n\n\tif (xim == NULL) {\n\t\trfbErr(\"XShmCreateImage(%s) failed.\\n\", name);\n\t\tif (quiet) {\n\t\t\tfprintf(stderr, \"XShmCreateImage(%s) failed.\\n\", name);\n\t\t}\n\t\tX_UNLOCK;\n\t\treturn 0;\n\t}\n\n\t*ximg_ptr = xim;\n\n#if HAVE_XSHM\n\tshm->shmid = shmget(IPC_PRIVATE,\n\t    xim->bytes_per_line * xim->height, IPC_CREAT | 0777);\n\n\tif (shm->shmid == -1) {\n\t\trfbErr(\"shmget(%s) failed.\\n\", name);\n\t\trfbLogPerror(\"shmget\");\n\n\t\tXDestroyImage(xim);\n\t\t*ximg_ptr = NULL;\n\n\t\tX_UNLOCK;\n\t\treturn 0;\n\t}\n\n\tshm->shmaddr = xim->data = (char *) shmat(shm->shmid, 0, 0);\n\n\tif (shm->shmaddr == (char *)-1) {\n\t\trfbErr(\"shmat(%s) failed.\\n\", name);\n\t\trfbLogPerror(\"shmat\");\n\n\t\tXDestroyImage(xim);\n\t\t*ximg_ptr = NULL;\n\n\t\tshmctl(shm->shmid, IPC_RMID, 0);\n\t\tshm->shmid = -1;\n\n\t\tX_UNLOCK;\n\t\treturn 0;\n\t}\n\n\tshm->readOnly = False;\n\n\tif (! XShmAttach_wr(dpy, shm)) {\n\t\trfbErr(\"XShmAttach(%s) failed.\\n\", name);\n\t\tXDestroyImage(xim);\n\t\t*ximg_ptr = NULL;\n\n\t\tshmdt(shm->shmaddr);\n\t\tshm->shmaddr = (char *) -1;\n\n\t\tshmctl(shm->shmid, IPC_RMID, 0);\n\t\tshm->shmid = -1;\n\n\t\tX_UNLOCK;\n\t\treturn 0;\n\t}\n#endif\n\n\tX_UNLOCK;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"warning: disabling -snapfb mode.\\n\""
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"warning: fullscreen updates are disabled.\\n\""
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_fs_factor",
          "args": [
            "1 * MB"
          ],
          "line": 456
        },
        "resolved": true,
        "details": {
          "function_name": "set_fs_factor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/scan.c",
          "lines": "210-228",
          "snippet": "static void set_fs_factor(int max) {\n\tint f, fac = 1, n = dpy_y;\n\n\tfs_factor = 0;\n\tif ((bpp/8) * dpy_x * dpy_y <= max)  {\n\t\tfs_factor = 1;\n\t\treturn;\n\t}\n\tfor (f=2; f <= 101; f++) {\n\t\twhile (n % f == 0) {\n\t\t\tn = n / f;\n\t\t\tfac = fac * f;\n\t\t\tif ( (bpp/8) * dpy_x * (dpy_y/fac) <= max )  {\n\t\t\t\tfs_factor = fac;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include <default8x16.h>",
            "#include \"userinput.h\"",
            "#include \"macosx.h\"",
            "#include \"screen.h\"",
            "#include \"unixpw.h\"",
            "#include \"cleanup.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"8to24.h\"",
            "#include \"win_utils.h\"",
            "#include \"xrandr.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void set_fs_factor(int max);",
            "static int fs_factor = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <default8x16.h>\n#include \"userinput.h\"\n#include \"macosx.h\"\n#include \"screen.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"8to24.h\"\n#include \"win_utils.h\"\n#include \"xrandr.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nstatic void set_fs_factor(int max);\nstatic int fs_factor = 0;\n\nstatic void set_fs_factor(int max) {\n\tint f, fac = 1, n = dpy_y;\n\n\tfs_factor = 0;\n\tif ((bpp/8) * dpy_x * dpy_y <= max)  {\n\t\tfs_factor = 1;\n\t\treturn;\n\t}\n\tfor (f=2; f <= 101; f++) {\n\t\twhile (n % f == 0) {\n\t\t\tn = n / f;\n\t\t\tfac = fac * f;\n\t\t\tif ( (bpp/8) * dpy_x * (dpy_y/fac) <= max )  {\n\t\t\t\tfs_factor = fac;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "UT.sysname",
            "\"Linux\""
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <default8x16.h>\n#include \"userinput.h\"\n#include \"macosx.h\"\n#include \"screen.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"8to24.h\"\n#include \"win_utils.h\"\n#include \"xrandr.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nvoid shm_delete(XShmSegmentInfo *shm);\nvoid initialize_polling_images(void);\nstatic int island_try(int x, int y, int u, int v, int *run);\nstatic int fs_factor = 0;\n\nvoid initialize_polling_images(void) {\n\tint i, MB = 1024 * 1024;\n\n\t/* set all shm areas to \"none\" before trying to create any */\n\tscanline_shm.shmid\t= -1;\n\tscanline_shm.shmaddr\t= (char *) -1;\n\tscanline\t\t= NULL;\n\tfullscreen_shm.shmid\t= -1;\n\tfullscreen_shm.shmaddr\t= (char *) -1;\n\tfullscreen\t\t= NULL;\n\tsnaprect_shm.shmid\t= -1;\n\tsnaprect_shm.shmaddr\t= (char *) -1;\n\tsnaprect\t\t= NULL;\n\tfor (i=1; i<=ntiles_x; i++) {\n\t\ttile_row_shm[i].shmid\t= -1;\n\t\ttile_row_shm[i].shmaddr\t= (char *) -1;\n\t\ttile_row[i]\t\t= NULL;\n\t}\n\n\t/* the scanline (e.g. 1280x1) shared memory area image: */\n\n\tif (! shm_create(&scanline_shm, &scanline, dpy_x, 1, \"scanline\")) {\n\t\tclean_up_exit(1);\n\t}\n\n\t/*\n\t * the fullscreen (e.g. 1280x1024/fs_factor) shared memory area image:\n\t * (we cut down the size of the shm area to try avoid and shm segment\n\t * limits, e.g. the default 1MB on Solaris)\n\t */\n\tif (UT.sysname && strstr(UT.sysname, \"Linux\")) {\n\t\tset_fs_factor(10 * MB);\n\t} else {\n\t\tset_fs_factor(1 * MB);\n\t}\n\tif (fs_frac >= 1.0) {\n\t\tfs_frac = 1.1;\n\t\tfs_factor = 0;\n\t}\n\tif (! fs_factor) {\n\t\trfbLog(\"warning: fullscreen updates are disabled.\\n\");\n\t} else {\n\t\tif (! shm_create(&fullscreen_shm, &fullscreen, dpy_x,\n\t\t    dpy_y/fs_factor, \"fullscreen\")) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t}\n\tif (use_snapfb) {\n\t\tif (! fs_factor) {\n\t\t\trfbLog(\"warning: disabling -snapfb mode.\\n\");\n\t\t\tuse_snapfb = 0;\n\t\t} else if (! shm_create(&snaprect_shm, &snaprect, dpy_x,\n\t\t    dpy_y/fs_factor, \"snaprect\")) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t}\n\n\t/*\n\t * for copy_tiles we need a lot of shared memory areas, one for\n\t * each possible run length of changed tiles.  32 for 1024x768\n\t * and 40 for 1280x1024, etc. \n\t */\n\n\ttile_shm_count = 0;\n\tfor (i=1; i<=ntiles_x; i++) {\n\t\tif (! shm_create(&tile_row_shm[i], &tile_row[i], tile_x * i,\n\t\t    tile_y, \"tile_row\")) {\n\t\t\tif (i == 1) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\trfbLog(\"shm: Error creating shared memory tile-row for\"\n\t\t\t    \" len=%d,\\n\", i);\n\t\t\trfbLog(\"shm: reverting to -onetile mode. If this\"\n\t\t\t    \" problem persists\\n\");\n\t\t\trfbLog(\"shm: try using the -onetile or -noshm options\"\n\t\t\t    \" to limit\\n\");\n\t\t\trfbLog(\"shm: shared memory usage, or run ipcrm(1)\"\n\t\t\t    \" to manually\\n\");\n\t\t\trfbLog(\"shm: delete unattached shm segments.\\n\");\n\t\t\tsingle_copytile_count = i;\n\t\t\tsingle_copytile = 1;\n\t\t}\n\t\ttile_shm_count++;\n\t\tif (single_copytile && i >= 1) {\n\t\t\t/* only need 1x1 tiles */\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (verbose) {\n\t\tif (using_shm && ! xform24to32) {\n\t\t\trfbLog(\"created %d tile_row shm polling images.\\n\",\n\t\t\t    tile_shm_count);\n\t\t} else {\n\t\t\trfbLog(\"created %d tile_row polling images.\\n\",\n\t\t\t    tile_shm_count);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "shm_clean",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/scan.c",
    "lines": "392-421",
    "snippet": "void shm_clean(XShmSegmentInfo *shm, XImage *xim) {\n\tint db = 0;\n\n\tif (db) fprintf(stderr, \"shm_clean: called:  %p\\n\", (void *)xim);\n\tX_LOCK;\n#if HAVE_XSHM\n\tif (shm != NULL && shm->shmid != -1 && dpy) {\n\t\tif (db) fprintf(stderr, \"shm_clean: XShmDetach_wr\\n\");\n\t\tXShmDetach_wr(dpy, shm);\n\t}\n#endif\n\tif (xim != NULL) {\n\t\tif (! raw_fb_back_to_X) {\t/* raw_fb hack */\n\t\t\tif (xim->bitmap_unit != -1) {\n\t\t\t\tif (db) fprintf(stderr, \"shm_clean: XDestroyImage  %p\\n\", (void *)xim);\n\t\t\t\tXDestroyImage(xim);\n\t\t\t} else {\n\t\t\t\tif (xim->data) {\n\t\t\t\t\tif (db) fprintf(stderr, \"shm_clean: free xim->data  %p %p\\n\", (void *)xim, (void *)(xim->data));\n\t\t\t\t\tfree(xim->data);\n\t\t\t\t\txim->data = NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\txim = NULL;\n\t}\n\tX_UNLOCK;\n\n\tshm_delete(shm);\n}",
    "includes": [
      "#include <default8x16.h>",
      "#include \"userinput.h\"",
      "#include \"macosx.h\"",
      "#include \"screen.h\"",
      "#include \"unixpw.h\"",
      "#include \"cleanup.h\"",
      "#include \"pointer.h\"",
      "#include \"screen.h\"",
      "#include \"8to24.h\"",
      "#include \"win_utils.h\"",
      "#include \"xrandr.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"xinerama.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void shm_delete(XShmSegmentInfo *shm);",
      "void shm_clean(XShmSegmentInfo *shm, XImage *xim);",
      "static char *flip_ximage_byte_order(XImage *xim);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "shm_delete",
          "args": [
            "shm"
          ],
          "line": 420
        },
        "resolved": true,
        "details": {
          "function_name": "shm_delete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/scan.c",
          "lines": "374-390",
          "snippet": "void shm_delete(XShmSegmentInfo *shm) {\n#if HAVE_XSHM\n\tif (getenv(\"X11VNC_SHM_DEBUG\")) fprintf(stderr, \"shm_delete:    %p\\n\", (void *) shm);\n\tif (shm != NULL && shm->shmaddr != (char *) -1) {\n\t\tshmdt(shm->shmaddr);\n\t}\n\tif (shm != NULL && shm->shmid != -1) {\n\t\tshmctl(shm->shmid, IPC_RMID, 0);\n\t}\n\tif (shm != NULL) {\n\t\tshm->shmaddr = (char *) -1;\n\t\tshm->shmid = -1;\n\t}\n#else\n\tif (!shm) {}\n#endif\n}",
          "includes": [
            "#include <default8x16.h>",
            "#include \"userinput.h\"",
            "#include \"macosx.h\"",
            "#include \"screen.h\"",
            "#include \"unixpw.h\"",
            "#include \"cleanup.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"8to24.h\"",
            "#include \"win_utils.h\"",
            "#include \"xrandr.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void shm_delete(XShmSegmentInfo *shm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <default8x16.h>\n#include \"userinput.h\"\n#include \"macosx.h\"\n#include \"screen.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"8to24.h\"\n#include \"win_utils.h\"\n#include \"xrandr.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nvoid shm_delete(XShmSegmentInfo *shm);\n\nvoid shm_delete(XShmSegmentInfo *shm) {\n#if HAVE_XSHM\n\tif (getenv(\"X11VNC_SHM_DEBUG\")) fprintf(stderr, \"shm_delete:    %p\\n\", (void *) shm);\n\tif (shm != NULL && shm->shmaddr != (char *) -1) {\n\t\tshmdt(shm->shmaddr);\n\t}\n\tif (shm != NULL && shm->shmid != -1) {\n\t\tshmctl(shm->shmid, IPC_RMID, 0);\n\t}\n\tif (shm != NULL) {\n\t\tshm->shmaddr = (char *) -1;\n\t\tshm->shmid = -1;\n\t}\n#else\n\tif (!shm) {}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "xim->data"
          ],
          "line": 411
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"shm_clean: free xim->data  %p %p\\n\"",
            "(void *)xim",
            "(void *)(xim->data)"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XDestroyImage",
          "args": [
            "xim"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"shm_clean: XDestroyImage  %p\\n\"",
            "(void *)xim"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XShmDetach_wr",
          "args": [
            "dpy",
            "shm"
          ],
          "line": 400
        },
        "resolved": true,
        "details": {
          "function_name": "XShmDetach_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "235-243",
          "snippet": "Status XShmDetach_wr(Display *disp, XShmSegmentInfo *shminfo) {\n#if HAVE_XSHM\n\tif (getenv(\"X11VNC_SHM_DEBUG\")) fprintf(stderr, \"XShmDetach_wr: %p disp: %p\\n\", (void *)shminfo, (void *)disp);\n\treturn XShmDetach(disp, shminfo);\n#else\n\tif (!disp || !shminfo) {}\n\treturn (Status) 0;\n#endif\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int XFlush_wr(Display *disp);",
            "Status XShmAttach_wr(Display *disp, XShmSegmentInfo *shminfo);",
            "Status XShmDetach_wr(Display *disp, XShmSegmentInfo *shminfo);",
            "Bool XShmQueryExtension_wr(Display *disp);",
            "int XShmGetEventBase_wr(Display *disp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nint XFlush_wr(Display *disp);\nStatus XShmAttach_wr(Display *disp, XShmSegmentInfo *shminfo);\nStatus XShmDetach_wr(Display *disp, XShmSegmentInfo *shminfo);\nBool XShmQueryExtension_wr(Display *disp);\nint XShmGetEventBase_wr(Display *disp);\n\nStatus XShmDetach_wr(Display *disp, XShmSegmentInfo *shminfo) {\n#if HAVE_XSHM\n\tif (getenv(\"X11VNC_SHM_DEBUG\")) fprintf(stderr, \"XShmDetach_wr: %p disp: %p\\n\", (void *)shminfo, (void *)disp);\n\treturn XShmDetach(disp, shminfo);\n#else\n\tif (!disp || !shminfo) {}\n\treturn (Status) 0;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"shm_clean: XShmDetach_wr\\n\""
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"shm_clean: called:  %p\\n\"",
            "(void *)xim"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <default8x16.h>\n#include \"userinput.h\"\n#include \"macosx.h\"\n#include \"screen.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"8to24.h\"\n#include \"win_utils.h\"\n#include \"xrandr.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nvoid shm_delete(XShmSegmentInfo *shm);\nvoid shm_clean(XShmSegmentInfo *shm, XImage *xim);\nstatic char *flip_ximage_byte_order(XImage *xim);\n\nvoid shm_clean(XShmSegmentInfo *shm, XImage *xim) {\n\tint db = 0;\n\n\tif (db) fprintf(stderr, \"shm_clean: called:  %p\\n\", (void *)xim);\n\tX_LOCK;\n#if HAVE_XSHM\n\tif (shm != NULL && shm->shmid != -1 && dpy) {\n\t\tif (db) fprintf(stderr, \"shm_clean: XShmDetach_wr\\n\");\n\t\tXShmDetach_wr(dpy, shm);\n\t}\n#endif\n\tif (xim != NULL) {\n\t\tif (! raw_fb_back_to_X) {\t/* raw_fb hack */\n\t\t\tif (xim->bitmap_unit != -1) {\n\t\t\t\tif (db) fprintf(stderr, \"shm_clean: XDestroyImage  %p\\n\", (void *)xim);\n\t\t\t\tXDestroyImage(xim);\n\t\t\t} else {\n\t\t\t\tif (xim->data) {\n\t\t\t\t\tif (db) fprintf(stderr, \"shm_clean: free xim->data  %p %p\\n\", (void *)xim, (void *)(xim->data));\n\t\t\t\t\tfree(xim->data);\n\t\t\t\t\txim->data = NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\txim = NULL;\n\t}\n\tX_UNLOCK;\n\n\tshm_delete(shm);\n}"
  },
  {
    "function_name": "shm_delete",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/scan.c",
    "lines": "374-390",
    "snippet": "void shm_delete(XShmSegmentInfo *shm) {\n#if HAVE_XSHM\n\tif (getenv(\"X11VNC_SHM_DEBUG\")) fprintf(stderr, \"shm_delete:    %p\\n\", (void *) shm);\n\tif (shm != NULL && shm->shmaddr != (char *) -1) {\n\t\tshmdt(shm->shmaddr);\n\t}\n\tif (shm != NULL && shm->shmid != -1) {\n\t\tshmctl(shm->shmid, IPC_RMID, 0);\n\t}\n\tif (shm != NULL) {\n\t\tshm->shmaddr = (char *) -1;\n\t\tshm->shmid = -1;\n\t}\n#else\n\tif (!shm) {}\n#endif\n}",
    "includes": [
      "#include <default8x16.h>",
      "#include \"userinput.h\"",
      "#include \"macosx.h\"",
      "#include \"screen.h\"",
      "#include \"unixpw.h\"",
      "#include \"cleanup.h\"",
      "#include \"pointer.h\"",
      "#include \"screen.h\"",
      "#include \"8to24.h\"",
      "#include \"win_utils.h\"",
      "#include \"xrandr.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"xinerama.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void shm_delete(XShmSegmentInfo *shm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "shmctl",
          "args": [
            "shm->shmid",
            "IPC_RMID",
            "0"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "shmdt",
          "args": [
            "shm->shmaddr"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"shm_delete:    %p\\n\"",
            "(void *) shm"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"X11VNC_SHM_DEBUG\""
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <default8x16.h>\n#include \"userinput.h\"\n#include \"macosx.h\"\n#include \"screen.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"8to24.h\"\n#include \"win_utils.h\"\n#include \"xrandr.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nvoid shm_delete(XShmSegmentInfo *shm);\n\nvoid shm_delete(XShmSegmentInfo *shm) {\n#if HAVE_XSHM\n\tif (getenv(\"X11VNC_SHM_DEBUG\")) fprintf(stderr, \"shm_delete:    %p\\n\", (void *) shm);\n\tif (shm != NULL && shm->shmaddr != (char *) -1) {\n\t\tshmdt(shm->shmaddr);\n\t}\n\tif (shm != NULL && shm->shmid != -1) {\n\t\tshmctl(shm->shmid, IPC_RMID, 0);\n\t}\n\tif (shm != NULL) {\n\t\tshm->shmaddr = (char *) -1;\n\t\tshm->shmid = -1;\n\t}\n#else\n\tif (!shm) {}\n#endif\n}"
  },
  {
    "function_name": "shm_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/scan.c",
    "lines": "247-372",
    "snippet": "static int shm_create(XShmSegmentInfo *shm, XImage **ximg_ptr, int w, int h,\n    char *name) {\n\n\tXImage *xim;\n\tstatic int reported_flip = 0;\n\tint db = 0;\n\n\tshm->shmid = -1;\n\tshm->shmaddr = (char *) -1;\n\t*ximg_ptr = NULL;\n\n\tif (nofb) {\n\t\treturn 1;\n\t}\n\n\tX_LOCK;\n\n\tif (! using_shm || xform24to32 || raw_fb) {\n\t\t/* we only need the XImage created */\n\t\txim = XCreateImage_wr(dpy, default_visual, depth, ZPixmap,\n\t\t    0, NULL, w, h, raw_fb ? 32 : BitmapPad(dpy), 0);\n\n\t\tX_UNLOCK;\n\n\t\tif (xim == NULL) {\n\t\t\trfbErr(\"XCreateImage(%s) failed.\\n\", name);\n\t\t\tif (quiet) {\n\t\t\t\tfprintf(stderr, \"XCreateImage(%s) failed.\\n\",\n\t\t\t\t    name);\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tif (db) fprintf(stderr, \"shm_create simple %d %d\\t%p %s\\n\", w, h, (void *)xim, name);\n\t\txim->data = (char *) malloc(xim->bytes_per_line * xim->height);\n\t\tif (xim->data == NULL) {\n\t\t\trfbErr(\"XCreateImage(%s) data malloc failed.\\n\", name);\n\t\t\tif (quiet) {\n\t\t\t\tfprintf(stderr, \"XCreateImage(%s) data malloc\"\n\t\t\t\t    \" failed.\\n\", name);\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tif (flip_byte_order) {\n\t\t\tchar *order = flip_ximage_byte_order(xim);\n\t\t\tif (! reported_flip && ! quiet) {\n\t\t\t\trfbLog(\"Changing XImage byte order\"\n\t\t\t\t    \" to %s\\n\", order);\n\t\t\t\treported_flip = 1;\n\t\t\t}\n\t\t}\n\n\t\t*ximg_ptr = xim;\n\t\treturn 1;\n\t}\n\n\tif (! dpy) {\n\t\tX_UNLOCK;\n\t\treturn 0;\n\t}\n\n\txim = XShmCreateImage_wr(dpy, default_visual, depth, ZPixmap, NULL,\n\t    shm, w, h);\n\n\tif (xim == NULL) {\n\t\trfbErr(\"XShmCreateImage(%s) failed.\\n\", name);\n\t\tif (quiet) {\n\t\t\tfprintf(stderr, \"XShmCreateImage(%s) failed.\\n\", name);\n\t\t}\n\t\tX_UNLOCK;\n\t\treturn 0;\n\t}\n\n\t*ximg_ptr = xim;\n\n#if HAVE_XSHM\n\tshm->shmid = shmget(IPC_PRIVATE,\n\t    xim->bytes_per_line * xim->height, IPC_CREAT | 0777);\n\n\tif (shm->shmid == -1) {\n\t\trfbErr(\"shmget(%s) failed.\\n\", name);\n\t\trfbLogPerror(\"shmget\");\n\n\t\tXDestroyImage(xim);\n\t\t*ximg_ptr = NULL;\n\n\t\tX_UNLOCK;\n\t\treturn 0;\n\t}\n\n\tshm->shmaddr = xim->data = (char *) shmat(shm->shmid, 0, 0);\n\n\tif (shm->shmaddr == (char *)-1) {\n\t\trfbErr(\"shmat(%s) failed.\\n\", name);\n\t\trfbLogPerror(\"shmat\");\n\n\t\tXDestroyImage(xim);\n\t\t*ximg_ptr = NULL;\n\n\t\tshmctl(shm->shmid, IPC_RMID, 0);\n\t\tshm->shmid = -1;\n\n\t\tX_UNLOCK;\n\t\treturn 0;\n\t}\n\n\tshm->readOnly = False;\n\n\tif (! XShmAttach_wr(dpy, shm)) {\n\t\trfbErr(\"XShmAttach(%s) failed.\\n\", name);\n\t\tXDestroyImage(xim);\n\t\t*ximg_ptr = NULL;\n\n\t\tshmdt(shm->shmaddr);\n\t\tshm->shmaddr = (char *) -1;\n\n\t\tshmctl(shm->shmid, IPC_RMID, 0);\n\t\tshm->shmid = -1;\n\n\t\tX_UNLOCK;\n\t\treturn 0;\n\t}\n#endif\n\n\tX_UNLOCK;\n\treturn 1;\n}",
    "includes": [
      "#include <default8x16.h>",
      "#include \"userinput.h\"",
      "#include \"macosx.h\"",
      "#include \"screen.h\"",
      "#include \"unixpw.h\"",
      "#include \"cleanup.h\"",
      "#include \"pointer.h\"",
      "#include \"screen.h\"",
      "#include \"8to24.h\"",
      "#include \"win_utils.h\"",
      "#include \"xrandr.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"xinerama.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void shm_delete(XShmSegmentInfo *shm);",
      "void shm_clean(XShmSegmentInfo *shm, XImage *xim);",
      "static char *flip_ximage_byte_order(XImage *xim);",
      "static int shm_create(XShmSegmentInfo *shm, XImage **ximg_ptr, int w, int h,\n    char *name);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "shmctl",
          "args": [
            "shm->shmid",
            "IPC_RMID",
            "0"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "shmdt",
          "args": [
            "shm->shmaddr"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XDestroyImage",
          "args": [
            "xim"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbErr",
          "args": [
            "\"XShmAttach(%s) failed.\\n\"",
            "name"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XShmAttach_wr",
          "args": [
            "dpy",
            "shm"
          ],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "XShmAttach_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "226-233",
          "snippet": "Status XShmAttach_wr(Display *disp, XShmSegmentInfo *shminfo) {\n#if HAVE_XSHM\n\treturn XShmAttach(disp, shminfo);\n#else\n\tif (!disp || !shminfo) {}\n\treturn (Status) 0;\n#endif\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int XFlush_wr(Display *disp);",
            "Status XShmAttach_wr(Display *disp, XShmSegmentInfo *shminfo);",
            "Status XShmDetach_wr(Display *disp, XShmSegmentInfo *shminfo);",
            "Bool XShmQueryExtension_wr(Display *disp);",
            "int XShmGetEventBase_wr(Display *disp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nint XFlush_wr(Display *disp);\nStatus XShmAttach_wr(Display *disp, XShmSegmentInfo *shminfo);\nStatus XShmDetach_wr(Display *disp, XShmSegmentInfo *shminfo);\nBool XShmQueryExtension_wr(Display *disp);\nint XShmGetEventBase_wr(Display *disp);\n\nStatus XShmAttach_wr(Display *disp, XShmSegmentInfo *shminfo) {\n#if HAVE_XSHM\n\treturn XShmAttach(disp, shminfo);\n#else\n\tif (!disp || !shminfo) {}\n\treturn (Status) 0;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "shmctl",
          "args": [
            "shm->shmid",
            "IPC_RMID",
            "0"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XDestroyImage",
          "args": [
            "xim"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLogPerror",
          "args": [
            "\"shmat\""
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbErr",
          "args": [
            "\"shmat(%s) failed.\\n\"",
            "name"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "shmat",
          "args": [
            "shm->shmid",
            "0",
            "0"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XDestroyImage",
          "args": [
            "xim"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLogPerror",
          "args": [
            "\"shmget\""
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbErr",
          "args": [
            "\"shmget(%s) failed.\\n\"",
            "name"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "shmget",
          "args": [
            "IPC_PRIVATE",
            "xim->bytes_per_line * xim->height",
            "IPC_CREAT | 0777"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"XShmCreateImage(%s) failed.\\n\"",
            "name"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbErr",
          "args": [
            "\"XShmCreateImage(%s) failed.\\n\"",
            "name"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XShmCreateImage_wr",
          "args": [
            "dpy",
            "default_visual",
            "depth",
            "ZPixmap",
            "NULL",
            "shm",
            "w",
            "h"
          ],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "XShmCreateImage_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "213-224",
          "snippet": "XImage *XShmCreateImage_wr(Display* disp, Visual* vis, unsigned int depth,\n    int format, char* data, XShmSegmentInfo* shminfo, unsigned int width,\n    unsigned int height) {\n\n#if HAVE_XSHM\n\treturn XShmCreateImage(disp, vis, depth, format, data, shminfo,\n\t    width, height); \n#else\n\tif (!disp || !vis || !depth || !format || !data || !shminfo || !width || !height) {}\n\treturn (XImage *) 0;\n#endif\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int XFlush_wr(Display *disp);",
            "XImage *XShmCreateImage_wr(Display* disp, Visual* vis, unsigned int depth,\n    int format, char* data, XShmSegmentInfo* shminfo, unsigned int width,\n    unsigned int height);",
            "Status XShmAttach_wr(Display *disp, XShmSegmentInfo *shminfo);",
            "Status XShmDetach_wr(Display *disp, XShmSegmentInfo *shminfo);",
            "Bool XShmQueryExtension_wr(Display *disp);",
            "int XShmGetEventBase_wr(Display *disp);",
            "XImage *XGetImage_wr(Display *disp, Drawable d, int x, int y,\n    unsigned int width, unsigned int height, unsigned long plane_mask,\n    int format);",
            "int XFree_wr(void *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nint XFlush_wr(Display *disp);\nXImage *XShmCreateImage_wr(Display* disp, Visual* vis, unsigned int depth,\n    int format, char* data, XShmSegmentInfo* shminfo, unsigned int width,\n    unsigned int height);\nStatus XShmAttach_wr(Display *disp, XShmSegmentInfo *shminfo);\nStatus XShmDetach_wr(Display *disp, XShmSegmentInfo *shminfo);\nBool XShmQueryExtension_wr(Display *disp);\nint XShmGetEventBase_wr(Display *disp);\nXImage *XGetImage_wr(Display *disp, Drawable d, int x, int y,\n    unsigned int width, unsigned int height, unsigned long plane_mask,\n    int format);\nint XFree_wr(void *data);\n\nXImage *XShmCreateImage_wr(Display* disp, Visual* vis, unsigned int depth,\n    int format, char* data, XShmSegmentInfo* shminfo, unsigned int width,\n    unsigned int height) {\n\n#if HAVE_XSHM\n\treturn XShmCreateImage(disp, vis, depth, format, data, shminfo,\n\t    width, height); \n#else\n\tif (!disp || !vis || !depth || !format || !data || !shminfo || !width || !height) {}\n\treturn (XImage *) 0;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"Changing XImage byte order\"\n\t\t\t\t    \" to %s\\n\"",
            "order"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flip_ximage_byte_order",
          "args": [
            "xim"
          ],
          "line": 290
        },
        "resolved": true,
        "details": {
          "function_name": "flip_ximage_byte_order",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/scan.c",
          "lines": "230-242",
          "snippet": "static char *flip_ximage_byte_order(XImage *xim) {\n\tchar *order;\n\tif (xim->byte_order == LSBFirst) {\n\t\torder = \"MSBFirst\";\n\t\txim->byte_order = MSBFirst;\n\t\txim->bitmap_bit_order = MSBFirst;\n\t} else {\n\t\torder = \"LSBFirst\";\n\t\txim->byte_order = LSBFirst;\n\t\txim->bitmap_bit_order = LSBFirst;\n\t}\n\treturn order;\n}",
          "includes": [
            "#include <default8x16.h>",
            "#include \"userinput.h\"",
            "#include \"macosx.h\"",
            "#include \"screen.h\"",
            "#include \"unixpw.h\"",
            "#include \"cleanup.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"8to24.h\"",
            "#include \"win_utils.h\"",
            "#include \"xrandr.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void shm_clean(XShmSegmentInfo *shm, XImage *xim);",
            "static char *flip_ximage_byte_order(XImage *xim);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <default8x16.h>\n#include \"userinput.h\"\n#include \"macosx.h\"\n#include \"screen.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"8to24.h\"\n#include \"win_utils.h\"\n#include \"xrandr.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nvoid shm_clean(XShmSegmentInfo *shm, XImage *xim);\nstatic char *flip_ximage_byte_order(XImage *xim);\n\nstatic char *flip_ximage_byte_order(XImage *xim) {\n\tchar *order;\n\tif (xim->byte_order == LSBFirst) {\n\t\torder = \"MSBFirst\";\n\t\txim->byte_order = MSBFirst;\n\t\txim->bitmap_bit_order = MSBFirst;\n\t} else {\n\t\torder = \"LSBFirst\";\n\t\txim->byte_order = LSBFirst;\n\t\txim->bitmap_bit_order = LSBFirst;\n\t}\n\treturn order;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"XCreateImage(%s) data malloc\"\n\t\t\t\t    \" failed.\\n\"",
            "name"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbErr",
          "args": [
            "\"XCreateImage(%s) data malloc failed.\\n\"",
            "name"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "xim->bytes_per_line * xim->height"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"shm_create simple %d %d\\t%p %s\\n\"",
            "w",
            "h",
            "(void *)xim",
            "name"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"XCreateImage(%s) failed.\\n\"",
            "name"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbErr",
          "args": [
            "\"XCreateImage(%s) failed.\\n\"",
            "name"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XCreateImage_wr",
          "args": [
            "dpy",
            "default_visual",
            "depth",
            "ZPixmap",
            "0",
            "NULL",
            "w",
            "h",
            "raw_fb ? 32 : BitmapPad(dpy)",
            "0"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "XCreateImage_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "370-429",
          "snippet": "XImage *XCreateImage_wr(Display *disp, Visual *visual, unsigned int depth,\n    int format, int offset, char *data, unsigned int width,\n    unsigned int height, int bitmap_pad, int bytes_per_line) {\n\t/*\n\t * This is a kludge to get a created XImage to exactly match what\n\t * XReadScreen returns: we noticed the rgb masks are different\n\t * from XCreateImage with the high color visual (red mask <->\n\t * blue mask).  Note we read from the root window(!) then free\n\t * the data.\n\t */\n\n\tif (raw_fb) {\t/* raw_fb hack */\n\t\tXImage *xi;\n\t\txi = (XImage *) malloc(sizeof(XImage));\n\t\tmemset(xi, 0, sizeof(XImage));\n\t\txi->depth = depth;\n\t\tif (depth >= 24) {\n\t\t\txi->bits_per_pixel = 32;\n\t\t} else if (depth > 16) {\n\t\t\txi->bits_per_pixel = 24;\n\t\t} else if (depth > 8) {\n\t\t\txi->bits_per_pixel = 16;\n\t\t} else {\n\t\t\txi->bits_per_pixel = 8;\n\t\t}\n\t\txi->format = format;\n\t\txi->xoffset = offset;\n\t\txi->data = data;\n\t\txi->width = width;\n\t\txi->height = height;\n\t\txi->bitmap_pad = bitmap_pad;\n\t\txi->bytes_per_line = bytes_per_line ? bytes_per_line : \n\t\t    xi->width * xi->bits_per_pixel / 8;\n\t\txi->bitmap_unit = -1;\t/* hint to not call XDestroyImage */\n\t\treturn xi;\n\t}\n\n#if NO_X11\n\tnox11_exit(1);\n\tif (!disp || !visual || !depth || !format || !offset || !data || !width\n\t    || !height || !width || !bitmap_pad || !bytes_per_line) {}\n\treturn NULL;\n#else\n\tif (overlay) {\n\t\tXImage *xi;\n\t\txi = xreadscreen(disp, window, 0, 0, width, height, False);\n\t\tif (xi == NULL) {\n\t\t\treturn xi;\n\t\t}\n\t\tif (xi->data != NULL) {\n\t\t\tfree(xi->data);\n\t\t}\n\t\txi->data = data;\n\t\treturn xi;\n\t}\n\n\treturn XCreateImage(disp, visual, depth, format, offset, data,\n\t    width, height, bitmap_pad, bytes_per_line);\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int guess_bits_per_color(int bits_per_pixel);",
            "int XFlush_wr(Display *disp);",
            "Status XShmGetImage_wr(Display *disp, Drawable d, XImage *image, int x, int y,\n    unsigned long mask);",
            "XImage *XShmCreateImage_wr(Display* disp, Visual* vis, unsigned int depth,\n    int format, char* data, XShmSegmentInfo* shminfo, unsigned int width,\n    unsigned int height);",
            "Bool XShmQueryExtension_wr(Display *disp);",
            "int XShmGetEventBase_wr(Display *disp);",
            "XImage *XGetImage_wr(Display *disp, Drawable d, int x, int y,\n    unsigned int width, unsigned int height, unsigned long plane_mask,\n    int format);",
            "XImage *XCreateImage_wr(Display *disp, Visual *visual, unsigned int depth,\n    int format, int offset, char *data, unsigned int width,\n    unsigned int height, int bitmap_pad, int bytes_per_line);",
            "int XFree_wr(void *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nint guess_bits_per_color(int bits_per_pixel);\nint XFlush_wr(Display *disp);\nStatus XShmGetImage_wr(Display *disp, Drawable d, XImage *image, int x, int y,\n    unsigned long mask);\nXImage *XShmCreateImage_wr(Display* disp, Visual* vis, unsigned int depth,\n    int format, char* data, XShmSegmentInfo* shminfo, unsigned int width,\n    unsigned int height);\nBool XShmQueryExtension_wr(Display *disp);\nint XShmGetEventBase_wr(Display *disp);\nXImage *XGetImage_wr(Display *disp, Drawable d, int x, int y,\n    unsigned int width, unsigned int height, unsigned long plane_mask,\n    int format);\nXImage *XCreateImage_wr(Display *disp, Visual *visual, unsigned int depth,\n    int format, int offset, char *data, unsigned int width,\n    unsigned int height, int bitmap_pad, int bytes_per_line);\nint XFree_wr(void *data);\n\nXImage *XCreateImage_wr(Display *disp, Visual *visual, unsigned int depth,\n    int format, int offset, char *data, unsigned int width,\n    unsigned int height, int bitmap_pad, int bytes_per_line) {\n\t/*\n\t * This is a kludge to get a created XImage to exactly match what\n\t * XReadScreen returns: we noticed the rgb masks are different\n\t * from XCreateImage with the high color visual (red mask <->\n\t * blue mask).  Note we read from the root window(!) then free\n\t * the data.\n\t */\n\n\tif (raw_fb) {\t/* raw_fb hack */\n\t\tXImage *xi;\n\t\txi = (XImage *) malloc(sizeof(XImage));\n\t\tmemset(xi, 0, sizeof(XImage));\n\t\txi->depth = depth;\n\t\tif (depth >= 24) {\n\t\t\txi->bits_per_pixel = 32;\n\t\t} else if (depth > 16) {\n\t\t\txi->bits_per_pixel = 24;\n\t\t} else if (depth > 8) {\n\t\t\txi->bits_per_pixel = 16;\n\t\t} else {\n\t\t\txi->bits_per_pixel = 8;\n\t\t}\n\t\txi->format = format;\n\t\txi->xoffset = offset;\n\t\txi->data = data;\n\t\txi->width = width;\n\t\txi->height = height;\n\t\txi->bitmap_pad = bitmap_pad;\n\t\txi->bytes_per_line = bytes_per_line ? bytes_per_line : \n\t\t    xi->width * xi->bits_per_pixel / 8;\n\t\txi->bitmap_unit = -1;\t/* hint to not call XDestroyImage */\n\t\treturn xi;\n\t}\n\n#if NO_X11\n\tnox11_exit(1);\n\tif (!disp || !visual || !depth || !format || !offset || !data || !width\n\t    || !height || !width || !bitmap_pad || !bytes_per_line) {}\n\treturn NULL;\n#else\n\tif (overlay) {\n\t\tXImage *xi;\n\t\txi = xreadscreen(disp, window, 0, 0, width, height, False);\n\t\tif (xi == NULL) {\n\t\t\treturn xi;\n\t\t}\n\t\tif (xi->data != NULL) {\n\t\t\tfree(xi->data);\n\t\t}\n\t\txi->data = data;\n\t\treturn xi;\n\t}\n\n\treturn XCreateImage(disp, visual, depth, format, offset, data,\n\t    width, height, bitmap_pad, bytes_per_line);\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "BitmapPad",
          "args": [
            "dpy"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <default8x16.h>\n#include \"userinput.h\"\n#include \"macosx.h\"\n#include \"screen.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"8to24.h\"\n#include \"win_utils.h\"\n#include \"xrandr.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nvoid shm_delete(XShmSegmentInfo *shm);\nvoid shm_clean(XShmSegmentInfo *shm, XImage *xim);\nstatic char *flip_ximage_byte_order(XImage *xim);\nstatic int shm_create(XShmSegmentInfo *shm, XImage **ximg_ptr, int w, int h,\n    char *name);\n\nstatic int shm_create(XShmSegmentInfo *shm, XImage **ximg_ptr, int w, int h,\n    char *name) {\n\n\tXImage *xim;\n\tstatic int reported_flip = 0;\n\tint db = 0;\n\n\tshm->shmid = -1;\n\tshm->shmaddr = (char *) -1;\n\t*ximg_ptr = NULL;\n\n\tif (nofb) {\n\t\treturn 1;\n\t}\n\n\tX_LOCK;\n\n\tif (! using_shm || xform24to32 || raw_fb) {\n\t\t/* we only need the XImage created */\n\t\txim = XCreateImage_wr(dpy, default_visual, depth, ZPixmap,\n\t\t    0, NULL, w, h, raw_fb ? 32 : BitmapPad(dpy), 0);\n\n\t\tX_UNLOCK;\n\n\t\tif (xim == NULL) {\n\t\t\trfbErr(\"XCreateImage(%s) failed.\\n\", name);\n\t\t\tif (quiet) {\n\t\t\t\tfprintf(stderr, \"XCreateImage(%s) failed.\\n\",\n\t\t\t\t    name);\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tif (db) fprintf(stderr, \"shm_create simple %d %d\\t%p %s\\n\", w, h, (void *)xim, name);\n\t\txim->data = (char *) malloc(xim->bytes_per_line * xim->height);\n\t\tif (xim->data == NULL) {\n\t\t\trfbErr(\"XCreateImage(%s) data malloc failed.\\n\", name);\n\t\t\tif (quiet) {\n\t\t\t\tfprintf(stderr, \"XCreateImage(%s) data malloc\"\n\t\t\t\t    \" failed.\\n\", name);\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tif (flip_byte_order) {\n\t\t\tchar *order = flip_ximage_byte_order(xim);\n\t\t\tif (! reported_flip && ! quiet) {\n\t\t\t\trfbLog(\"Changing XImage byte order\"\n\t\t\t\t    \" to %s\\n\", order);\n\t\t\t\treported_flip = 1;\n\t\t\t}\n\t\t}\n\n\t\t*ximg_ptr = xim;\n\t\treturn 1;\n\t}\n\n\tif (! dpy) {\n\t\tX_UNLOCK;\n\t\treturn 0;\n\t}\n\n\txim = XShmCreateImage_wr(dpy, default_visual, depth, ZPixmap, NULL,\n\t    shm, w, h);\n\n\tif (xim == NULL) {\n\t\trfbErr(\"XShmCreateImage(%s) failed.\\n\", name);\n\t\tif (quiet) {\n\t\t\tfprintf(stderr, \"XShmCreateImage(%s) failed.\\n\", name);\n\t\t}\n\t\tX_UNLOCK;\n\t\treturn 0;\n\t}\n\n\t*ximg_ptr = xim;\n\n#if HAVE_XSHM\n\tshm->shmid = shmget(IPC_PRIVATE,\n\t    xim->bytes_per_line * xim->height, IPC_CREAT | 0777);\n\n\tif (shm->shmid == -1) {\n\t\trfbErr(\"shmget(%s) failed.\\n\", name);\n\t\trfbLogPerror(\"shmget\");\n\n\t\tXDestroyImage(xim);\n\t\t*ximg_ptr = NULL;\n\n\t\tX_UNLOCK;\n\t\treturn 0;\n\t}\n\n\tshm->shmaddr = xim->data = (char *) shmat(shm->shmid, 0, 0);\n\n\tif (shm->shmaddr == (char *)-1) {\n\t\trfbErr(\"shmat(%s) failed.\\n\", name);\n\t\trfbLogPerror(\"shmat\");\n\n\t\tXDestroyImage(xim);\n\t\t*ximg_ptr = NULL;\n\n\t\tshmctl(shm->shmid, IPC_RMID, 0);\n\t\tshm->shmid = -1;\n\n\t\tX_UNLOCK;\n\t\treturn 0;\n\t}\n\n\tshm->readOnly = False;\n\n\tif (! XShmAttach_wr(dpy, shm)) {\n\t\trfbErr(\"XShmAttach(%s) failed.\\n\", name);\n\t\tXDestroyImage(xim);\n\t\t*ximg_ptr = NULL;\n\n\t\tshmdt(shm->shmaddr);\n\t\tshm->shmaddr = (char *) -1;\n\n\t\tshmctl(shm->shmid, IPC_RMID, 0);\n\t\tshm->shmid = -1;\n\n\t\tX_UNLOCK;\n\t\treturn 0;\n\t}\n#endif\n\n\tX_UNLOCK;\n\treturn 1;\n}"
  },
  {
    "function_name": "flip_ximage_byte_order",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/scan.c",
    "lines": "230-242",
    "snippet": "static char *flip_ximage_byte_order(XImage *xim) {\n\tchar *order;\n\tif (xim->byte_order == LSBFirst) {\n\t\torder = \"MSBFirst\";\n\t\txim->byte_order = MSBFirst;\n\t\txim->bitmap_bit_order = MSBFirst;\n\t} else {\n\t\torder = \"LSBFirst\";\n\t\txim->byte_order = LSBFirst;\n\t\txim->bitmap_bit_order = LSBFirst;\n\t}\n\treturn order;\n}",
    "includes": [
      "#include <default8x16.h>",
      "#include \"userinput.h\"",
      "#include \"macosx.h\"",
      "#include \"screen.h\"",
      "#include \"unixpw.h\"",
      "#include \"cleanup.h\"",
      "#include \"pointer.h\"",
      "#include \"screen.h\"",
      "#include \"8to24.h\"",
      "#include \"win_utils.h\"",
      "#include \"xrandr.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"xinerama.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void shm_clean(XShmSegmentInfo *shm, XImage *xim);",
      "static char *flip_ximage_byte_order(XImage *xim);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <default8x16.h>\n#include \"userinput.h\"\n#include \"macosx.h\"\n#include \"screen.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"8to24.h\"\n#include \"win_utils.h\"\n#include \"xrandr.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nvoid shm_clean(XShmSegmentInfo *shm, XImage *xim);\nstatic char *flip_ximage_byte_order(XImage *xim);\n\nstatic char *flip_ximage_byte_order(XImage *xim) {\n\tchar *order;\n\tif (xim->byte_order == LSBFirst) {\n\t\torder = \"MSBFirst\";\n\t\txim->byte_order = MSBFirst;\n\t\txim->bitmap_bit_order = MSBFirst;\n\t} else {\n\t\torder = \"LSBFirst\";\n\t\txim->byte_order = LSBFirst;\n\t\txim->bitmap_bit_order = LSBFirst;\n\t}\n\treturn order;\n}"
  },
  {
    "function_name": "set_fs_factor",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/scan.c",
    "lines": "210-228",
    "snippet": "static void set_fs_factor(int max) {\n\tint f, fac = 1, n = dpy_y;\n\n\tfs_factor = 0;\n\tif ((bpp/8) * dpy_x * dpy_y <= max)  {\n\t\tfs_factor = 1;\n\t\treturn;\n\t}\n\tfor (f=2; f <= 101; f++) {\n\t\twhile (n % f == 0) {\n\t\t\tn = n / f;\n\t\t\tfac = fac * f;\n\t\t\tif ( (bpp/8) * dpy_x * (dpy_y/fac) <= max )  {\n\t\t\t\tfs_factor = fac;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n}",
    "includes": [
      "#include <default8x16.h>",
      "#include \"userinput.h\"",
      "#include \"macosx.h\"",
      "#include \"screen.h\"",
      "#include \"unixpw.h\"",
      "#include \"cleanup.h\"",
      "#include \"pointer.h\"",
      "#include \"screen.h\"",
      "#include \"8to24.h\"",
      "#include \"win_utils.h\"",
      "#include \"xrandr.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"xinerama.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void set_fs_factor(int max);",
      "static int fs_factor = 0;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <default8x16.h>\n#include \"userinput.h\"\n#include \"macosx.h\"\n#include \"screen.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"8to24.h\"\n#include \"win_utils.h\"\n#include \"xrandr.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nstatic void set_fs_factor(int max);\nstatic int fs_factor = 0;\n\nstatic void set_fs_factor(int max) {\n\tint f, fac = 1, n = dpy_y;\n\n\tfs_factor = 0;\n\tif ((bpp/8) * dpy_x * dpy_y <= max)  {\n\t\tfs_factor = 1;\n\t\treturn;\n\t}\n\tfor (f=2; f <= 101; f++) {\n\t\twhile (n % f == 0) {\n\t\t\tn = n / f;\n\t\t\tfac = fac * f;\n\t\t\tif ( (bpp/8) * dpy_x * (dpy_y/fac) <= max )  {\n\t\t\t\tfs_factor = fac;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "free_tiles",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/scan.c",
    "lines": "160-201",
    "snippet": "void free_tiles(void) {\n\tif (tile_has_diff) {\n\t\tfree(tile_has_diff);\n\t\ttile_has_diff = NULL;\n\t}\n\tif (tile_has_xdamage_diff) {\n\t\tfree(tile_has_xdamage_diff);\n\t\ttile_has_xdamage_diff = NULL;\n\t}\n\tif (tile_row_has_xdamage_diff) {\n\t\tfree(tile_row_has_xdamage_diff);\n\t\ttile_row_has_xdamage_diff = NULL;\n\t}\n\tif (tile_tried) {\n\t\tfree(tile_tried);\n\t\ttile_tried = NULL;\n\t}\n\tif (tile_copied) {\n\t\tfree(tile_copied);\n\t\ttile_copied = NULL;\n\t}\n\tif (tile_blackout) {\n\t\tfree(tile_blackout);\n\t\ttile_blackout = NULL;\n\t}\n\tif (tile_region) {\n\t\tfree(tile_region);\n\t\ttile_region = NULL;\n\t}\n\tif (tile_row) {\n\t\tfree(tile_row);\n\t\ttile_row = NULL;\n\t}\n\tif (tile_row_shm) {\n\t\tfree(tile_row_shm);\n\t\ttile_row_shm = NULL;\n\t}\n\tif (hint_list) {\n\t\tfree(hint_list);\n\t\thint_list = NULL;\n\t}\n}",
    "includes": [
      "#include <default8x16.h>",
      "#include \"userinput.h\"",
      "#include \"macosx.h\"",
      "#include \"screen.h\"",
      "#include \"unixpw.h\"",
      "#include \"cleanup.h\"",
      "#include \"pointer.h\"",
      "#include \"screen.h\"",
      "#include \"8to24.h\"",
      "#include \"win_utils.h\"",
      "#include \"xrandr.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"xinerama.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void free_tiles(void);",
      "static hint_t *hint_list;",
      "static region_t *tile_region;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "hint_list"
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <default8x16.h>\n#include \"userinput.h\"\n#include \"macosx.h\"\n#include \"screen.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"8to24.h\"\n#include \"win_utils.h\"\n#include \"xrandr.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nvoid free_tiles(void);\nstatic hint_t *hint_list;\nstatic region_t *tile_region;\n\nvoid free_tiles(void) {\n\tif (tile_has_diff) {\n\t\tfree(tile_has_diff);\n\t\ttile_has_diff = NULL;\n\t}\n\tif (tile_has_xdamage_diff) {\n\t\tfree(tile_has_xdamage_diff);\n\t\ttile_has_xdamage_diff = NULL;\n\t}\n\tif (tile_row_has_xdamage_diff) {\n\t\tfree(tile_row_has_xdamage_diff);\n\t\ttile_row_has_xdamage_diff = NULL;\n\t}\n\tif (tile_tried) {\n\t\tfree(tile_tried);\n\t\ttile_tried = NULL;\n\t}\n\tif (tile_copied) {\n\t\tfree(tile_copied);\n\t\ttile_copied = NULL;\n\t}\n\tif (tile_blackout) {\n\t\tfree(tile_blackout);\n\t\ttile_blackout = NULL;\n\t}\n\tif (tile_region) {\n\t\tfree(tile_region);\n\t\ttile_region = NULL;\n\t}\n\tif (tile_row) {\n\t\tfree(tile_row);\n\t\ttile_row = NULL;\n\t}\n\tif (tile_row_shm) {\n\t\tfree(tile_row_shm);\n\t\ttile_row_shm = NULL;\n\t}\n\tif (hint_list) {\n\t\tfree(hint_list);\n\t\thint_list = NULL;\n\t}\n}"
  },
  {
    "function_name": "initialize_tiles",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/scan.c",
    "lines": "131-158",
    "snippet": "void initialize_tiles(void) {\n\n\tntiles_x = (dpy_x - 1)/tile_x + 1;\n\tntiles_y = (dpy_y - 1)/tile_y + 1;\n\tntiles = ntiles_x * ntiles_y;\n\n\ttile_has_diff = (unsigned char *)\n\t\tcalloc((size_t) (ntiles * sizeof(unsigned char)), 1);\n\ttile_has_xdamage_diff = (unsigned char *)\n\t\tcalloc((size_t) (ntiles * sizeof(unsigned char)), 1);\n\ttile_row_has_xdamage_diff = (unsigned char *)\n\t\tcalloc((size_t) (ntiles_y * sizeof(unsigned char)), 1);\n\ttile_tried    = (unsigned char *)\n\t\tcalloc((size_t) (ntiles * sizeof(unsigned char)), 1);\n\ttile_copied   = (unsigned char *)\n\t\tcalloc((size_t) (ntiles * sizeof(unsigned char)), 1);\n\ttile_blackout    = (tile_blackout_t *)\n\t\tcalloc((size_t) (ntiles * sizeof(tile_blackout_t)), 1);\n\ttile_region = (region_t *) calloc((size_t) (ntiles * sizeof(region_t)), 1);\n\n\ttile_row = (XImage **)\n\t\tcalloc((size_t) ((ntiles_x + 1) * sizeof(XImage *)), 1);\n\ttile_row_shm = (XShmSegmentInfo *)\n\t\tcalloc((size_t) ((ntiles_x + 1) * sizeof(XShmSegmentInfo)), 1);\n\n\t/* there will never be more hints than tiles: */\n\thint_list = (hint_t *) calloc((size_t) (ntiles * sizeof(hint_t)), 1);\n}",
    "includes": [
      "#include <default8x16.h>",
      "#include \"userinput.h\"",
      "#include \"macosx.h\"",
      "#include \"screen.h\"",
      "#include \"unixpw.h\"",
      "#include \"cleanup.h\"",
      "#include \"pointer.h\"",
      "#include \"screen.h\"",
      "#include \"8to24.h\"",
      "#include \"win_utils.h\"",
      "#include \"xrandr.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"xinerama.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void initialize_tiles(void);",
      "static hint_t *hint_list;",
      "static region_t *tile_region;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "(size_t) (ntiles * sizeof(hint_t))",
            "1"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "(size_t) ((ntiles_x + 1) * sizeof(XShmSegmentInfo))",
            "1"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "(size_t) ((ntiles_x + 1) * sizeof(XImage *))",
            "1"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "(size_t) (ntiles * sizeof(region_t))",
            "1"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "(size_t) (ntiles * sizeof(tile_blackout_t))",
            "1"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "(size_t) (ntiles * sizeof(unsigned char))",
            "1"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "(size_t) (ntiles * sizeof(unsigned char))",
            "1"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "(size_t) (ntiles_y * sizeof(unsigned char))",
            "1"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "(size_t) (ntiles * sizeof(unsigned char))",
            "1"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "(size_t) (ntiles * sizeof(unsigned char))",
            "1"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <default8x16.h>\n#include \"userinput.h\"\n#include \"macosx.h\"\n#include \"screen.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"8to24.h\"\n#include \"win_utils.h\"\n#include \"xrandr.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nvoid initialize_tiles(void);\nstatic hint_t *hint_list;\nstatic region_t *tile_region;\n\nvoid initialize_tiles(void) {\n\n\tntiles_x = (dpy_x - 1)/tile_x + 1;\n\tntiles_y = (dpy_y - 1)/tile_y + 1;\n\tntiles = ntiles_x * ntiles_y;\n\n\ttile_has_diff = (unsigned char *)\n\t\tcalloc((size_t) (ntiles * sizeof(unsigned char)), 1);\n\ttile_has_xdamage_diff = (unsigned char *)\n\t\tcalloc((size_t) (ntiles * sizeof(unsigned char)), 1);\n\ttile_row_has_xdamage_diff = (unsigned char *)\n\t\tcalloc((size_t) (ntiles_y * sizeof(unsigned char)), 1);\n\ttile_tried    = (unsigned char *)\n\t\tcalloc((size_t) (ntiles * sizeof(unsigned char)), 1);\n\ttile_copied   = (unsigned char *)\n\t\tcalloc((size_t) (ntiles * sizeof(unsigned char)), 1);\n\ttile_blackout    = (tile_blackout_t *)\n\t\tcalloc((size_t) (ntiles * sizeof(tile_blackout_t)), 1);\n\ttile_region = (region_t *) calloc((size_t) (ntiles * sizeof(region_t)), 1);\n\n\ttile_row = (XImage **)\n\t\tcalloc((size_t) ((ntiles_x + 1) * sizeof(XImage *)), 1);\n\ttile_row_shm = (XShmSegmentInfo *)\n\t\tcalloc((size_t) ((ntiles_x + 1) * sizeof(XShmSegmentInfo)), 1);\n\n\t/* there will never be more hints than tiles: */\n\thint_list = (hint_t *) calloc((size_t) (ntiles * sizeof(hint_t)), 1);\n}"
  }
]